for(i = min; i <= max; i++)
    {
      double pi = pdf(i);
      double Pi = cdf_P(i);
      sum += pi;
      gsl_test_rel (Pi, sum, tol, desc, i);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = max; i >= min; i--)
    {
      double pi = pdf(i);
      double Qi = cdf_Q(i);
      gsl_test_rel (Qi, sum, tol, desc, i);
      sum += pi;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = min; i <= max; i++)
    {
      double Pi = cdf_P(i);
      double Qi = cdf_Q(i);
      sum = Pi + Qi;
      gsl_test_rel (sum, 1.0, tol, desc, i);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i < n; i++)
    {
      y = x * (y + c[i]);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 2; (i < MAXI) && (diff > GSL_DBL_EPSILON); i += 2)
    {
      diff = q;
      num *= y * y * (i - 1) / i;
      q += num / (nu + i);
      diff = q - diff;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++)
    {
      xnum = (xnum + a[i]) * xsq;
      xden = (xden + b[i]) * xsq;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 7; i++)
    {
      xnum = (xnum + c[i]) * absx;
      xden = (xden + d[i]) * absx;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 4; i++)
    {
      xnum = (xnum + p[i]) * xsq;
      xden = (xden + q[i]) * xsq;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < num_dim; ++i)
    {
      prod *= 2.0 * x[i];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < num_dim; i++)
    {
      double dx = x[i] - 0.5;
      sum += dx * dx;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < num_dim; i++)
    {
      double dx1 = x[i] - 1. / 3.;
      double dx2 = x[i] - 2. / 3.;
      sum1 += dx1 * dx1;
      sum2 += dx2 * dx2;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < num_dim; i++)
    {
      prod *= c / (c + 1) * pow((c + 1) / (c + x[i]), 2.0);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < dim; i++)
    {
      if (xu[i] <= xl[i])
        {
          GSL_ERROR ("xu must be greater than xl", GSL_EINVAL);
        }

      if (xu[i] - xl[i] > GSL_DBL_MAX)
        {
          GSL_ERROR ("Range of integration is too large, please rescale",
                     GSL_EINVAL);
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(it = 0; it < state->iterations; it++)
    {
      double intgrl = 0.0, intgrl_sq = 0.0;
      double sig = 0.0;
      double wgt;
      size_t calls_per_box = state->calls_per_box;
      double jacbin = state->jac;
      double *x = state->x;
      coord *bin = state->bin;

      state->it_num = state->it_start + it;

      reset_grid_values (state);
      init_box_coord (state, state->box);
      
      do
        {
          double m = 0, q = 0;
          double f_sq_sum = 0.0;

          for(k = 0; k < calls_per_box; k++)
            {
              double fval, bin_vol;

              random_point (x, bin, &bin_vol, state->box, xl, xu, state, r);

              fval = jacbin * bin_vol * GSL_MONTE_FN_EVAL (f, x);

              

              {
                double d = fval - m;
                m += d / (k + 1.0);
                q += d * d * (k / (k + 1.0));
              }

              if (state->mode != GSL_VEGAS_MODE_STRATIFIED)
                {
                  double f_sq = fval * fval;
                  accumulate_distribution (state, bin, f_sq);
                }
            }

          intgrl += m * calls_per_box;

          f_sq_sum = q * calls_per_box ;

          sig += f_sq_sum ;

          if (state->mode == GSL_VEGAS_MODE_STRATIFIED)
            {
              accumulate_distribution (state, bin, f_sq_sum);
            }
        }
      while (change_box_coord (state, state->box));

      

      sig = sig / (calls_per_box - 1.0)  ;

      if (sig > 0) 
        {
          wgt = 1.0 / sig;
        }
      else if (state->sum_wgts > 0) 
        {
          wgt = state->sum_wgts / state->samples;
        }
      else 
        {
          wgt = 0.0;
        }
        
     intgrl_sq = intgrl * intgrl;

     state->result = intgrl;
     state->sigma  = sqrt(sig);

     if (wgt > 0.0)
       {
         state->samples++ ;
         state->sum_wgts += wgt;
         state->wtd_int_sum += intgrl * wgt;
         state->chi_sum += intgrl_sq * wgt;

         cum_int = state->wtd_int_sum / state->sum_wgts;
         cum_sig = sqrt (1 / state->sum_wgts);

         if (state->samples > 1)
           {
             state->chisq = (state->chi_sum - state->wtd_int_sum * cum_int) /
               (state->samples - 1.0);
           }
       }
     else
       {
         cum_int += (intgrl - cum_int) / (it + 1.0);
         cum_sig = 0.0;
       }         


      if (state->verbose >= 0)
        {
          print_res (state,
                     state->it_num, intgrl, sqrt (sig), cum_int, cum_sig,
                     state->chisq);
          if (it + 1 == state->iterations && state->verbose > 0)
            {
              print_grid (state, dim);
            }
        }

      if (state->verbose > 1)
        {
          print_dist (state, dim);
        }

      refine_grid (state);

      if (state->verbose > 1)
        {
          print_grid (state, dim);
        }

    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < dim; i++)
    {
      box[i] = 0;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < dim; j++)
    {
      double dx = xu[j] - xl[j];
      s->delx[j] = dx;
      vol *= dx;

      COORD (s, 0, j) = 0.0;
      COORD (s, 1, j) = 1.0;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < bins; i++)
    {
      for(j = 0; j < dim; j++)
        {
          VALUE (s, i, j) = 0.0;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < dim; j++)
    {
      int i = bin[j];
      VALUE (s, i, j) += y;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < dim; ++j)
    {
      


      double z = ((box[j] + gsl_rng_uniform_pos (r)) / boxes) * bins;

      int k = z;

      double y, bin_width;

      bin[j] = k;

      if (k == 0)
        {
          bin_width = COORD (s, 1, j);
          y = z * bin_width;
        }
      else
        {
          bin_width = COORD (s, k + 1, j) - COORD (s, k, j);
          y = COORD (s, k, j) + (z - k) * bin_width;
        }

      x[j] = xl[j] + y * s->delx[j];

      vol *= bin_width;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < dim; j++)
    {
      double xold;
      double xnew = 0;
      double dw = 0;
      int i = 1;

      for(k = 1; k <= s->bins; k++)
        {
          dw += 1.0;
          xold = xnew;
          xnew = COORD (s, k, j);

          for(; dw > pts_per_bin; i++)
            {
              dw -= pts_per_bin;
              NEW_COORD (s, i) = xnew - (xnew - xold) * dw;
            }
        }

      for(k = 1 ; k < bins; k++)
        {
          COORD(s, k, j) = NEW_COORD(s, k);
        }

      COORD (s, bins, j) = 1;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < dim; j++)
    {
      double grid_tot_j, tot_weight;
      double * weight = s->weight;

      double oldg = VALUE (s, 0, j);
      double newg = VALUE (s, 1, j);

      VALUE (s, 0, j) = (oldg + newg) / 2;
      grid_tot_j = VALUE (s, 0, j);

      

      for(i = 1; i < bins - 1; i++)
        {
          double rc = oldg + newg;
          oldg = newg;
          newg = VALUE (s, i + 1, j);
          VALUE (s, i, j) = (rc + newg) / 3;
          grid_tot_j += VALUE (s, i, j);
        }
      VALUE (s, bins - 1, j) = (newg + oldg) / 2;

      grid_tot_j += VALUE (s, bins - 1, j);

      tot_weight = 0;

      for(i = 0; i < bins; i++)
        {
          weight[i] = 0;

          if (VALUE (s, i, j) > 0)
            {
              oldg = grid_tot_j / VALUE (s, i, j);
              
              weight[i] = pow (((oldg - 1) / oldg / log (oldg)), s->alpha);
            }

          tot_weight += weight[i];

#ifdef DEBUG
          printf("weight[%d] = %g\n", i, weight[i]);
#endif
        }

      {
        double pts_per_bin = tot_weight / bins;

        double xold;
        double xnew = 0;
        double dw = 0;
        i = 1;

        for(k = 0; k < bins; k++)
          {
            dw += weight[k];
            xold = xnew;
            xnew = COORD (s, k + 1, j);

            for(; dw > pts_per_bin; i++)
              {
                dw -= pts_per_bin;
                NEW_COORD (s, i) = xnew - (xnew - xold) * dw / weight[k];
              }
          }

        for(k = 1 ; k < bins ; k++)
          {
            COORD(s, k, j) = NEW_COORD(s, k);
          }

        COORD (s, bins, j) = 1;
      }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < dim; ++j)
    fprintf (state->ostream, "\nxl[%lu]=%f    xu[%lu]=%f", j, xl[j], j, xu[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < dim; ++j)
    {
      fprintf (state->ostream, "\n axis %lu \n", j);
      fprintf (state->ostream, "      x   g\n");
      for(i = 0; i < state->bins; i++)
        {
          fprintf (state->ostream, "weight [%11.2e , %11.2e] = ", 
                   COORD (state, i, j), COORD(state,i+1,j));
          fprintf (state->ostream, " %11.2e\n", VALUE (state, i, j));

        }
      fprintf (state->ostream, "\n");
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < dim; ++j)
    {
      fprintf (state->ostream, "\n axis %lu \n", j);
      fprintf (state->ostream, "      x   \n");
      for(i = 0; i <= state->bins; i++)
        {
          fprintf (state->ostream, "%11.2e", COORD (state, i, j));
          if (i % 5 == 4)
            fprintf (state->ostream, "\n");
        }
      fprintf (state->ostream, "\n");
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < dim; i++)
    {
      if (xu[i] <= xl[i])
        {
          GSL_ERROR ("xu must be greater than xl", GSL_EINVAL);
        }

      if (xu[i] - xl[i] > GSL_DBL_MAX)
        {
          GSL_ERROR ("Range of integration is too large, please rescale",
                     GSL_EINVAL);
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < dim; i++)
    {
      vol *= xu[i] - xl[i];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(n = 0; n < calls; n++)
    {
      

      for(i = 0; i < dim; i++)
        {
          x[i] = xl[i] + gsl_rng_uniform_pos (r) * (xu[i] - xl[i]);
        }

      {
        double fval = GSL_MONTE_FN_EVAL (f, x);

        

        double d = fval - m;
        m += d / (n + 1.0);
        q += d * d * (n / (n + 1.0));
      }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < s->dim; i++)
    {
      s->x[i] = 0.0;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(I = problems ; I->f != 0; I++) 
{
  size_t i;
  double sum = 0, mean, sumd2 = 0, sd, res, err; 
  
  gsl_rng * r;

  if (I->dim > 3)
    {
      continue ;
    }

  r = gsl_rng_alloc (gsl_rng_default);

  for(i = 0; i < TRIALS ; i++)
    {
      MONTE_STATE *s = MONTE_ALLOC (I->dim);
      
      I->f->dim = I->dim;
      
      MONTE_INTEGRATE (I->f, I->xl, I->xu, 
                       I->dim, I->calls / MONTE_SPEEDUP, r, s,
                       &res, &err);
      
      gsl_test_abs (res, I->expected_result, 
                    5 * GSL_MAX(err, 1024*GSL_DBL_EPSILON), 
                    NAME ", %s, result[%d]", I->description, i);

      MONTE_ERROR_TEST (err, I->expected_error);

      result[i] = res;
      error[i] = err;
      
      MONTE_FREE (s);
    }

 for(i = 0; i < TRIALS; i++)
   {
     sum += result[i];
   }

 mean = sum / TRIALS ;

 for(i = 0; i < TRIALS; i++) 
   {
     sumd2 += pow(result[i] - mean, 2.0);
   }

 sd = sqrt(sumd2 / (TRIALS-1.0)) ;
 
 if (sd < TRIALS * GSL_DBL_EPSILON * fabs (mean))
   {
     sd = 0;
   }

 for(i = 0; i < TRIALS; i++)
   {
     if (sd == 0 && fabs(error[i]) < GSL_DBL_EPSILON * fabs(result[i]))
       {
         error[i] = 0.0;
       }

     gsl_test_factor (error[i], sd, 5.0,
                      NAME ", %s, abserr[%d] vs sd", I->description, i);
   }


  gsl_rng_free (r);
}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < dim; i++)
    {
      if (xu[i] <= xl[i])
        {
          GSL_ERROR ("xu must be greater than xl", GSL_EINVAL);
        }

      if (xu[i] - xl[i] > GSL_DBL_MAX)
        {
          GSL_ERROR ("Range of integration is too large, please rescale",
                     GSL_EINVAL);
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < dim; i++)
    {
      vol *= xu[i] - xl[i];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(n = 0; n < calls; n++)
        {
          

          for(i = 0; i < dim; i++)
            {
              x[i] = xl[i] + gsl_rng_uniform_pos (r) * (xu[i] - xl[i]);
            }

          {
            double fval = GSL_MONTE_FN_EVAL (f, x);

            

            double d = fval - m;
            m += d / (n + 1.0);
            q += d * d * (n / (n + 1.0));
          }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < dim; i++)
    {
      s = (gsl_rng_uniform (r) - 0.5) >= 0.0 ? state->dither : -state->dither;
      state->xmid[i] = (0.5 + s) * xl[i] + (0.5 - s) * xu[i];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < dim; i++)
      {
        if (sigma_l[i] >= 0 && sigma_r[i] >= 0)
          {
            
            double var = pow (sigma_l[i], beta) + pow (sigma_r[i], beta);

            if (var <= best_var)
              {
                found_best = 1;
                best_var = var;
                i_bisect = i;
                weight_l = pow (sigma_l[i], beta);
                weight_r = pow (sigma_r[i], beta);
              }
          }
        else
          {
            if (sigma_l[i] < 0)
              {
                GSL_ERROR ("no points in left-half space!", GSL_ESANITY);
              }
            if (sigma_r[i] < 0)
              {
                GSL_ERROR ("no points in right-half space!", GSL_ESANITY);
              }
          }
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < dim; i++)
      {
        xu_tmp[i] = xu[i];
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < dim; i++)
      {
        xl_tmp[i] = xl[i];
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < dim; i++)
    {
      vol *= xu[i] - xl[i];
      hits_l[i] = hits_r[i] = 0;
      fsum_l[i] = fsum_r[i] = 0.0;
      fsum2_l[i] = fsum2_r[i] = 0.0;
      sigma_l[i] = sigma_r[i] = -1;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(n = 0; n < calls; n++)
    {
      double fval;
      
      unsigned int j = (n/2) % dim;
      unsigned int side = (n % 2);

      for(i = 0; i < dim; i++)
        {
          double z = gsl_rng_uniform_pos (r) ;

          if (i != j) 
            {
              x[i] = xl[i] + z * (xu[i] - xl[i]);
            }
          else
            {
              if (side == 0) 
                {
                  x[i] = xmid[i] + z * (xu[i] - xmid[i]);
                }
              else
                {
                  x[i] = xl[i] + z * (xmid[i] - xl[i]);
                }
            }
        }

      fval = GSL_MONTE_FN_EVAL (f, x);

      
      {
        double d = fval - m;
        m += d / (n + 1.0);
        q += d * d * (n / (n + 1.0));
      }

      
      for(i = 0; i < dim; i++)
        {
          if (x[i] <= xmid[i])
            {
              fsum_l[i] += fval;
              fsum2_l[i] += fval * fval;
              hits_l[i]++;
            }
          else
            {
              fsum_r[i] += fval;
              fsum2_r[i] += fval * fval;
              hits_r[i]++;
            }
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < dim; i++)
    {
      double fraction_l = (xmid[i] - xl[i]) / (xu[i] - xl[i]);

      if (hits_l[i] > 0)
        {
          fsum_l[i] /= hits_l[i];
          sigma_l[i] = sqrt (fsum2_l[i] - fsum_l[i] * fsum_l[i] / hits_l[i]);
          sigma_l[i] *= fraction_l * vol / hits_l[i];
        }

      if (hits_r[i] > 0)
        {
          fsum_r[i] /= hits_r[i];
          sigma_r[i] = sqrt (fsum2_r[i] - fsum_r[i] * fsum_r[i] / hits_r[i]);
          sigma_r[i] *= (1 - fraction_l) * vol / hits_r[i];
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<size; i++) {
    for(j=0; j<size; j++) {
      gsl_matrix_set(m, i, j, 1.0/(i+j+1.0));
    }
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<size1; i++) {
    for(j=0; j<size2; j++) {
      gsl_matrix_set(m, i, j, 1.0/(i+j+1.0));
    }
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<size1; i++) {
    for(j=0; j<size2; j++) {
      gsl_matrix_set(m, i, j, 1.0/(i+j+1.0));
    }
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j <size2; j++)
    gsl_matrix_set(m,0,j,0.0);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<size; i++) {
    for(j=0; j<size; j++) {
      gsl_matrix_set(m, i, j, pow(i + 1.0, size - j - 1.0));
    }
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<size; i++) {
    for(j=0; j<size; j++) {
      gsl_matrix_set(m, i, j, GSL_MIN(i+1,j+1)-2.0);
    }
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<size; i++) {
    for(j=0; j<size; j++) {
      gsl_complex z = gsl_complex_rect(1.0/(i+j+1.0), 1/(i*i+j*j+0.5));
      gsl_matrix_complex_set(m, i, j, z);
    }
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<size1; i++) {
      gsl_matrix_set(m, i, 0, 1.0/(i+1.0));
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<size; i++) {
      gsl_matrix_set(m, i, i, a[i]);
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<dim; i++) gsl_vector_set(rhs, i, i+1.0);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<dim; i++) {
    int foo = check(gsl_vector_get(x, i),actual[i],eps);
    if(foo) {
      printf("%3lu[%lu]: %22.18g   %22.18g\n", dim, i, gsl_vector_get(x, i), actual[i]);
    }
    s += foo;
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<dim; i++) {
    int foo = check(gsl_vector_get(x, i),actual[i],eps);
    if(foo) {
      printf("%3lu[%lu]: %22.18g   %22.18g (improved)\n", dim, i, gsl_vector_get(x, i), actual[i]);
    }
    s += foo;
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<dim; i++) 
    {
      gsl_complex z = gsl_complex_rect (2.0*i+1.0, 2.0*i+2.0);
      gsl_vector_complex_set(rhs, i, z);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<dim; i++) {
    gsl_complex z = gsl_vector_complex_get(x, i);
    int foo_r = check(GSL_REAL(z),actual[2*i],eps);
    int foo_i = check(GSL_IMAG(z),actual[2*i+1],eps);
    if(foo_r || foo_i) {
      printf("%3lu[%lu]: %22.18g   %22.18g\n", dim, i, GSL_REAL(z), actual[2*i]);
      printf("%3lu[%lu]: %22.18g   %22.18g\n", dim, i, GSL_IMAG(z), actual[2*i+1]);
    }
    s += foo_r + foo_i;
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<dim; i++) {
    gsl_complex z = gsl_vector_complex_get(x, i);
    int foo_r = check(GSL_REAL(z),actual[2*i],eps);
    int foo_i = check(GSL_IMAG(z),actual[2*i+1],eps);
    if(foo_r || foo_i) {
      printf("%3lu[%lu]: %22.18g   %22.18g (improved)\n", dim, i, GSL_REAL(z), actual[2*i]);
      printf("%3lu[%lu]: %22.18g   %22.18g (improved)\n", dim, i, GSL_IMAG(z), actual[2*i+1]);
    }
    s += foo_r + foo_i;
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<dim; i++) gsl_vector_set(rhs, i, i+1.0);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<dim; i++) {
    int foo = check(gsl_vector_get(x, i), actual[i], eps);
    if(foo) {
      printf("%3lu[%lu]: %22.18g   %22.18g\n", dim, i, gsl_vector_get(x, i), actual[i]);
    }
    s += foo;
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<dim; i++) gsl_vector_set(rhs, i, i+1.0);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<dim; i++) {
    int foo = check(gsl_vector_get(x, i), actual[i], eps);
    if(foo) {
      printf("%3lu[%lu]: %22.18g   %22.18g\n", dim, i, gsl_vector_get(x, i), actual[i]);
    }
    s += foo;
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<M; i++) gsl_vector_set(rhs, i, i+1.0);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<N; i++) {
    int foo = check(gsl_vector_get(x, i), actual[i], eps);
    if(foo) {
      printf("(%3lu,%3lu)[%lu]: %22.18g   %22.18g\n", M, N, i, gsl_vector_get(x, i), actual[i]);
    }
    s += foo;
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<N; i++) {
    int foo = check(gsl_vector_get(res, i), gsl_vector_get(r,i), sqrt(eps));
    if(foo) {
      printf("(%3lu,%3lu)[%lu]: %22.18g   %22.18g\n", M, N, i, gsl_vector_get(res, i), gsl_vector_get(r,i));
    }
    s += foo;
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<M; i++) {
    for(j=0; j<N; j++) {
      double aij = gsl_matrix_get(a, i, j);
      double mij = gsl_matrix_get(m, i, j);
      int foo = check(aij, mij, eps);
      if(foo) {
        printf("(%3lu,%3lu)[%lu,%lu]: %22.18g   %22.18g\n", M, N, i,j, aij, mij);
      }
      s += foo;
    }
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<dim; i++) gsl_vector_set(rhs, i, i+1.0);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<dim; i++) {
    int foo = check(gsl_vector_get(x, i), actual[i], eps);
    if(foo) {
      printf("%3lu[%lu]: %22.18g   %22.18g\n", dim, i, gsl_vector_get(x, i), actual[i]);
    }
    s += foo;
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<dim; i++) gsl_vector_set(rhs, i, i+1.0);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<dim; i++) {
    int foo = check(gsl_vector_get(x, i), actual[i], eps);
    if(foo) {
      printf("%3lu[%lu]: %22.18g   %22.18g\n", dim, i, gsl_vector_get(x, i), actual[i]);
    }
    s += foo;
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < M; i++) {
    gsl_vector_view row = gsl_matrix_row (a, i);
    gsl_permute_vector_inverse (perm, &row.vector);
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<M; i++) {
    for(j=0; j<N; j++) {
      double aij = gsl_matrix_get(a, i, j);
      double mij = gsl_matrix_get(m, i, j);
      int foo = check(aij, mij, eps);
      if(foo) {
        printf("(%3lu,%3lu)[%lu,%lu]: %22.18g   %22.18g\n", M, N, i,j, aij, mij);
      }
      s += foo;
    }
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<N; i++) gsl_vector_set(rhs, i, i+1.0);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<M; i++) gsl_vector_set(u, i, sin(i+1.0));



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<N; i++) gsl_vector_set(v, i, cos(i+2.0) + sin(i*i+3.0));



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<M; i++) 
    {
      double ui = gsl_vector_get(u, i);
      for(j=0; j<N; j++) 
        {
          double vj = gsl_vector_get(v, j);
          double qij = gsl_matrix_get(qr1, i, j);
          gsl_matrix_set(qr1, i, j, qij + ui * vj);
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < M; j++)
    {
      double sum = 0;
      for(i = 0; i < M; i++)
          sum += gsl_matrix_get (q2, i, j) * gsl_vector_get (u, i);
      gsl_vector_set (w, j, sum);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < M; i++)
    {
      for(j = 0; j< N; j++)
        {
          double sum = 0;
          for(k = 0; k <= GSL_MIN(j,M-1); k++)
            {
              double qik = gsl_matrix_get(q2, i, k);
              double rkj = gsl_matrix_get(r2, k, j);
              sum += qik * rkj ;
            }
          gsl_matrix_set (qr2, i, j, sum);
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<M; i++) {
    for(j=0; j<N; j++) {
      double s1 = gsl_matrix_get(qr1, i, j);
      double s2 = gsl_matrix_get(qr2, i, j);
      
      int foo = check(s1, s2, eps);
      if(foo) {
        printf("(%3lu,%3lu)[%lu,%lu]: %22.18g   %22.18g\n", M, N, i,j, s1, s2);
      }
      s += foo;
    }
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<dim; i++) gsl_vector_set(rhs, i, i+1.0);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<dim; i++) {
    int foo = check(gsl_vector_get(x, i), actual[i], eps);
    if(foo) {
      printf("%3lu[%lu]: %22.18g   %22.18g\n", dim, i, gsl_vector_get(x, i), actual[i]);
    }
    s += foo;
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<dim; i++) gsl_vector_set(rhs, i, i+1.0);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<dim; i++) {
    int foo = check(gsl_vector_get(x, i), actual[i], eps);
    if(foo) {
      printf("%3lu[%lu]: %22.18g   %22.18g\n", dim, i, gsl_vector_get(x, i), actual[i]);
    }
    s += foo;
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<M; i++) gsl_vector_set(rhs, i, i+1.0);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<N; i++) {
    int foo = check(gsl_vector_get(x, i), actual[i], eps);
    if(foo) {
      printf("(%3lu,%3lu)[%lu]: %22.18g   %22.18g\n", M, N, i, gsl_vector_get(x, i), actual[i]);
    }
    s += foo;
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<N; i++) {
    int foo = check(gsl_vector_get(res, i), gsl_vector_get(r,i), sqrt(eps));
    if(foo) {
      printf("(%3lu,%3lu)[%lu]: %22.18g   %22.18g\n", M, N, i, gsl_vector_get(res, i), gsl_vector_get(r,i));
    }
    s += foo;
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<M; i++) {
    for(j=0; j<N; j++) {
      double aij = gsl_matrix_get(a, i, j);
      double mij = gsl_matrix_get(m, i, j);
      int foo = check(aij, mij, eps);
      if(foo) {
        printf("(%3lu,%3lu)[%lu,%lu]: %22.18g   %22.18g\n", M, N, i,j, aij, mij);
      }
      s += foo;
    }
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<dim; i++) gsl_vector_set(rhs, i, i+1.0);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<dim; i++) {
    int foo = check(gsl_vector_get(x, i), actual[i], eps);
    if(foo) {
      printf("%3lu[%lu]: %22.18g   %22.18g\n", dim, i, gsl_vector_get(x, i), actual[i]);
    }
    s += foo;
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<dim; i++) gsl_vector_set(rhs, i, i+1.0);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<dim; i++) {
    int foo = check(gsl_vector_get(x, i), actual[i], eps);
    if(foo) {
      printf("%3lu[%lu]: %22.18g   %22.18g\n", dim, i, gsl_vector_get(x, i), actual[i]);
    }
    s += foo;
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < M; i++) {
    gsl_vector_view col = gsl_matrix_column (a, i);
    gsl_permute_vector_inverse (perm, &col.vector);
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<M; i++) {
    for(j=0; j<N; j++) {
      double aij = gsl_matrix_get(a, j, i);
      double mij = gsl_matrix_get(m, i, j);
      int foo = check(aij, mij, eps);
      if(foo) {
        printf("(%3lu,%3lu)[%lu,%lu]: %22.18g   %22.18g\n", M, N, i,j, aij, mij);
      }
      s += foo;
    }
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<M; i++) gsl_vector_set(u, i, sin(i+1.0));



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<N; i++) gsl_vector_set(v, i, cos(i+2.0) + sin(i*i+3.0));



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<N; i++) {
    for(j=0; j<M; j++) {
      double s1 = gsl_matrix_get(lq1, i, j);
      double s2 = gsl_matrix_get(lq2, i, j);
      
      int foo = check(s1, s2, eps);
#if 0
      if(foo) {
	  printf("LQ:(%3lu,%3lu)[%lu,%lu]: %22.18g   %22.18g\n", M, N, i,j, s1, s2);
      }
#endif
      s += foo;
    }
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<dim; i++) gsl_vector_set(rhs, i, i+1.0);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<dim; i++) {
    int foo = check(gsl_vector_get(x, i), actual[i], eps);
    if(foo) {
      printf("%3lu[%lu]: %22.18g   %22.18g\n", dim, i, gsl_vector_get(x, i), actual[i]);
    }
    s += foo;
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
    {
      double di = gsl_vector_get (d, i);

      if (gsl_isnan (di))
        {
          continue;  
        }

      if (di < 0) {
        s++;
        printf("singular value %lu = %22.18g < 0\n", i, di);
      }

      if(i > 0 && di > di1) {
        s++;
        printf("singular value %lu = %22.18g vs previous %22.18g\n", i, di, di1);
      }

      di1 = di;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N ; i++)
    {
      double di = gsl_vector_get (d, i);

      for(j = 0; j < N; j++)
        {
          double qji = gsl_matrix_get(q, j, i);
          gsl_matrix_set (dqt, i, j, qji * di);
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<M; i++) {
    for(j=0; j<N; j++) {
      double aij = gsl_matrix_get(a, i, j);
      double mij = gsl_matrix_get(m, i, j);
      int foo = check(aij, mij, eps);
      if(foo) {
        printf("(%3lu,%3lu)[%lu,%lu]: %22.18g   %22.18g\n", M, N, i,j, aij, mij);
      }
      s += foo;
    }
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i1 = lower; i1 <= upper; i1++)
      {
        for(i2 = lower; i2 <= upper; i2++)
          {
            for(i3 = lower; i3 <= upper; i3++)
              {
                for(i4 = lower; i4 <= upper; i4++)
                  {
                    gsl_matrix_set (A22, 0,0, i1);
                    gsl_matrix_set (A22, 0,1, i2);
                    gsl_matrix_set (A22, 1,0, i3);
                    gsl_matrix_set (A22, 1,1, i4);
                    
                    f = test_SV_decomp_dim(A22, 16 * GSL_DBL_EPSILON);
                    gsl_test(f, "  SV_decomp (2x2) A=[%g, %g; %g, %g]", i1,i2,i3,i4);
                    s += f;
                  }
              }
          }
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<9; i++) {
      a[i] = lower;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=9; carry > 0.0 && i>0 && i--;) 
        {
          double v=a[i]+carry;
          carry = (v>upper) ? 1.0 : 0.0;
          a[i] = (v>upper) ? lower : v;
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<16; i++) {
      a[i] = lower;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=16; carry > 0.0 && i>0 && i--;) 
        {
          double v=a[i]+carry;
          carry = (v>upper) ? 1.0 : 0.0;
          a[i] = (v>upper) ? lower : v;
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
    {
      double di = gsl_vector_get (d, i);

      if (gsl_isnan (di))
        {
          continue;  
        }

      if (di < 0) {
        s++;
        printf("singular value %lu = %22.18g < 0\n", i, di);
      }

      if(i > 0 && di > di1) {
        s++;
        printf("singular value %lu = %22.18g vs previous %22.18g\n", i, di, di1);
      }

      di1 = di;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N ; i++)
    {
      double di = gsl_vector_get (d, i);

      for(j = 0; j < N; j++)
        {
          double qji = gsl_matrix_get(q, j, i);
          gsl_matrix_set (dqt, i, j, qji * di);
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<M; i++) {
    for(j=0; j<N; j++) {
      double aij = gsl_matrix_get(a, i, j);
      double mij = gsl_matrix_get(m, i, j);
      int foo = check(aij, mij, eps);
      if(foo) {
        printf("(%3lu,%3lu)[%lu,%lu]: %22.18g   %22.18g\n", M, N, i,j, aij, mij);
      }
      s += foo;
    }
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i1 = lower; i1 <= upper; i1++)
      {
        for(i2 = lower; i2 <= upper; i2++)
          {
            for(i3 = lower; i3 <= upper; i3++)
              {
                for(i4 = lower; i4 <= upper; i4++)
                  {
                    gsl_matrix_set (A22, 0,0, i1);
                    gsl_matrix_set (A22, 0,1, i2);
                    gsl_matrix_set (A22, 1,0, i3);
                    gsl_matrix_set (A22, 1,1, i4);
                    
                    f = test_SV_decomp_mod_dim(A22, 16 * GSL_DBL_EPSILON);
                    gsl_test(f, "  SV_decomp_mod (2x2) A=[%g, %g; %g, %g]", i1,i2,i3,i4);
                    s += f;
                  }
              }
          }
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<9; i++) {
      a[i] = lower;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=9; carry > 0.0 && i>0 && i--;) 
        {
          double v=a[i]+carry;
          carry = (v>upper) ? 1.0 : 0.0;
          a[i] = (v>upper) ? lower : v;
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<16; i++) {
      a[i] = lower;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=16; carry>0.0 && i>0 && i--;) 
        {
          double v=a[i]+carry;
          carry = (v>upper) ? 1.0 : 0.0;
          a[i] = (v>upper) ? lower : v;
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
    {
      double di = gsl_vector_get (d, i);

      if (gsl_isnan (di))
        {
          continue;  
        }

      if (di < 0) {
        s++;
        printf("singular value %lu = %22.18g < 0\n", i, di);
      }

      if(i > 0 && di > di1) {
        s++;
        printf("singular value %lu = %22.18g vs previous %22.18g\n", i, di, di1);
      }

      di1 = di;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N ; i++)
    {
      double di = gsl_vector_get (d, i);

      for(j = 0; j < N; j++)
        {
          double qji = gsl_matrix_get(q, j, i);
          gsl_matrix_set (dqt, i, j, qji * di);
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<M; i++) {
    for(j=0; j<N; j++) {
      double aij = gsl_matrix_get(a, i, j);
      double mij = gsl_matrix_get(m, i, j);
      int foo = check(aij, mij, eps);
      if(foo) {
        printf("(%3lu,%3lu)[%lu,%lu]: %22.18g   %22.18g\n", M, N, i,j, aij, mij);
      }
      s += foo;
    }
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i1 = lower; i1 <= upper; i1++)
      {
        for(i2 = lower; i2 <= upper; i2++)
          {
            for(i3 = lower; i3 <= upper; i3++)
              {
                for(i4 = lower; i4 <= upper; i4++)
                  {
                    gsl_matrix_set (A22, 0,0, i1);
                    gsl_matrix_set (A22, 0,1, i2);
                    gsl_matrix_set (A22, 1,0, i3);
                    gsl_matrix_set (A22, 1,1, i4);
                    
                    f = test_SV_decomp_jacobi_dim(A22, 16 * GSL_DBL_EPSILON);
                    gsl_test(f, "  SV_decomp_jacobi (2x2) A=[%g, %g; %g, %g]", i1,i2,i3,i4);
                    s += f;
                  }
              }
          }
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<9; i++) {
      a[i] = lower;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=9; carry > 0.0 && i>0 && i--;) 
        {
          double v=a[i]+carry;
          carry = (v>upper) ? 1.0 : 0.0;
          a[i] = (v>upper) ? lower : v;
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<16; i++) {
      a[i] = lower;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=16; carry > 0.0 && i>0 && i--;) 
        {
          double v=a[i]+carry;
          carry = (v>upper) ? 1.0 : 0.0;
          a[i] = (v>upper) ? lower : v;
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<25; i++) {
      a[i] = lower;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=25; carry >0.0 && i>0 && i--;) 
        {
          double v=a[i]+carry;
          carry = (v>upper) ? 1.0 : 0.0;
          a[i] = (v>upper) ? lower : v;
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<dim; i++) gsl_vector_set(rhs, i, i+1.0);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<dim; i++) {
    int foo = check(gsl_vector_get(x, i), actual[i], eps);
    if(foo) {
      printf("%3lu[%lu]: %22.18g   %22.18g\n", dim, i, gsl_vector_get(x, i), actual[i]);
    }
    s += foo;
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N ; i++)
    {
      for(j = 0; j < N; j++)
        {
          double vij = gsl_matrix_get(v, i, j);
          gsl_matrix_set (l, i, j, i>=j ? vij : 0);
          gsl_matrix_set (lt, i, j, i<=j ? vij : 0);
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<M; i++) {
    for(j=0; j<N; j++) {
      double aij = gsl_matrix_get(a, i, j);
      double mij = gsl_matrix_get(m, i, j);
      int foo = check(aij, mij, eps);
      if(foo) {
        printf("(%3lu,%3lu)[%lu,%lu]: %22.18g   %22.18g\n", M, N, i,j, aij, mij);
      }
      s += foo;
    }
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N ; i++)
  {
    for(j = 0; j < N; j++)
    {
      const double vij = gsl_matrix_get(v, i, j);
      gsl_matrix_set (l,  i, j, i>=j ? vij : 0);
      gsl_matrix_set (lt, i, j, i<=j ? vij : 0);
    }
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < M; ++i) gsl_matrix_set(dm, i, i, gsl_vector_get(dv, i));



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < M; i++)
  {
    for(j = 0; j < N; j++)
    {
      const double aij = gsl_matrix_get(a, i, j);
      const double mij = gsl_matrix_get(m, i, j);
      int foo = check(aij, mij, eps);
      if(foo)
      {
        printf("(%3lu,%3lu)[%lu,%lu]: %22.18g   %22.18g\n", M, N, i,j, aij, mij);
      }
      s += foo;
    }
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<dim; i++) gsl_vector_set(x, i, i+1.0);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<dim; i++) {
    int foo = check(gsl_vector_get(x, i),actual[i],eps);
    if( foo) {
      printf("%3lu[%lu]: %22.18g   %22.18g\n", dim, i, gsl_vector_get(x, i), actual[i]);
    }
    s += foo;
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<dim; i++) {
    gsl_vector_set(diag, i, d);
    gsl_vector_set(rhs,  i, i + 1.0);
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<dim-1; i++) {
    gsl_vector_set(offdiag, i, od);
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<dim; i++) {
    double si = gsl_vector_get(x, i);
    double ai = actual[i];
    int foo = check(si, ai, eps);
    if(foo) {
      printf("%3lu[%lu]: %22.18g   %22.18g\n", dim, i, gsl_vector_get(x, i), actual[i]);
    }
    s += foo;
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<dim; i++) {
    gsl_vector_set(diag, i, d[i]);
    gsl_vector_set(rhs,  i, r[i]);
    gsl_vector_set(offdiag, i, od[i]);
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<dim; i++) {
    double si = gsl_vector_get(x, i);
    double ai = actual[i];
    int foo = check(si, ai, eps);
    if(foo) {
      printf("%3lu[%lu]: %22.18g   %22.18g\n", dim, i, gsl_vector_get(x, i), actual[i]);
    }
    s += foo;
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<dim; i++) {
    gsl_vector_set(diag, i, d);
    gsl_vector_set(rhs,  i, i + 1.0);
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<dim-1; i++) {
    gsl_vector_set(abovediag, i, a);
    gsl_vector_set(belowdiag, i, b);
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<dim; i++) {
    double si = gsl_vector_get(x, i);
    double ai = actual[i];
    int foo = check(si, ai, eps);
    if(foo) {
      printf("%3lu[%lu]: %22.18g   %22.18g\n", dim, i, gsl_vector_get(x, i), actual[i]);
    }
    s += foo;
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<dim; i++) {
    gsl_vector_set(diag, i, d);
    gsl_vector_set(rhs,  i, i + 1.0);
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<dim; i++) {
    gsl_vector_set(abovediag, i, a);
    gsl_vector_set(belowdiag, i, b);
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<dim; i++) {
    double si = gsl_vector_get(x, i);
    double ai = actual[i];
    int foo = check(si, ai, eps);
    if(foo) {
      printf("%3lu[%lu]: %22.18g   %22.18g\n", dim, i, gsl_vector_get(x, i), actual[i]);
    }
    s += foo;
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++) gsl_matrix_set(b, i,i, gsl_vector_get(d,i));



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N-1; i++) gsl_matrix_set(b, i,i+1, gsl_vector_get(sd,i));



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < M ; i++)
    {
      for(j = 0; j < N; j++)
        {
          double sum = 0;

          for(k = 0; k < N; k++)
            {
              for(r = 0; r < N; r++)
                {
                  sum += gsl_matrix_get(u, i, k) * gsl_matrix_get (b, k, r)
                    * gsl_matrix_get(v, j, r);
                }
            }
          gsl_matrix_set (a, i, j, sum);
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<M; i++) {
    for(j=0; j<N; j++) {
      double aij = gsl_matrix_get(a, i, j);
      double mij = gsl_matrix_get(m, i, j);
      int foo = check(aij, mij, eps);
      if(foo) {
        printf("(%3lu,%3lu)[%lu,%lu]: %22.18g   %22.18g\n", M, N, i,j, aij, mij);
      }
      s += foo;
    }
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 2; k < M; k++)
        {
          double A_kk = gsl_matrix_get (A, k, k);
          
          for(i = 0; i < k; i++)
            {
              double sum = 0;

              double A_ki = gsl_matrix_get (A, k, i);
              double A_ii = gsl_matrix_get (A, i, i);

              gsl_vector_view ci = gsl_matrix_row (A, i);
              gsl_vector_view ck = gsl_matrix_row (A, k);

              if (i > 0) {
                gsl_vector_view di = gsl_vector_subvector(&ci.vector, 0, i);
                gsl_vector_view dk = gsl_vector_subvector(&ck.vector, 0, i);
                
                gsl_blas_ddot (&di.vector, &dk.vector, &sum);
              }

              A_ki = (A_ki - sum) / A_ii;
              gsl_matrix_set (A, k, i, A_ki);
            } 

          {
            gsl_vector_view ck = gsl_matrix_row (A, k);
            gsl_vector_view dk = gsl_vector_subvector (&ck.vector, 0, k);
            
            double sum = gsl_blas_dnrm2 (&dk.vector);
            double diag = A_kk - sum * sum;

            double L_kk = quiet_sqrt(diag);
            
            if (diag <= 0)
              {
                status = GSL_EDOM;
              }
            
            gsl_matrix_set (A, k, k, L_kk);
          }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i < M; i++)
        {
          for(j = 0; j < i; j++)
            {
              double A_ij = gsl_matrix_get (A, i, j);
              gsl_matrix_set (A, j, i, A_ij);
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; ++i)
    {
      const double C_ii = gsl_matrix_get(A, i, i);
      gsl_vector_set(D, i, C_ii*C_ii);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; ++i)
    {
      for(j = 0; j < N; ++j)
      {
        gsl_matrix_set(A, i, j, gsl_matrix_get(A, i, j) / sqrt(gsl_vector_get(D, j)));
      }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; ++i)
      for(j = i + 1; j < N; ++j)
        gsl_matrix_set(A, i, j, gsl_matrix_get(A, j, i));



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < K; j++)
    {
      double Sj = gsl_vector_get (S, j);
      
      if (Sj < 0.0)
        {
          for(i = 0; i < N; i++)
            {
              double Vij = gsl_matrix_get (V, i, j);
              gsl_matrix_set (V, i, j, -Vij);
            }
          
          gsl_vector_set (S, j, -Sj);
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < K; i++)
    {
      double S_max = gsl_vector_get (S, i);
      size_t i_max = i;
      
      for(j = i + 1; j < K; j++)
        {
          double Sj = gsl_vector_get (S, j);
          
          if (Sj > S_max)
            {
              S_max = Sj;
              i_max = j;
            }
        }
      
      if (i_max != i)
        {
          
          gsl_vector_swap_elements (S, i, i_max);
          
          
          gsl_matrix_swap_columns (A, i, i_max);
          gsl_matrix_swap_columns (V, i, i_max);
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
    {
      gsl_vector_view c = gsl_matrix_column (A, i);
      gsl_vector_view v = gsl_vector_subvector (&c.vector, i, M - i);
      double tau_i = gsl_linalg_householder_transform (&v.vector);

      

      if (i + 1 < N)
        {
          gsl_matrix_view m =
            gsl_matrix_submatrix (A, i, i + 1, M - i, N - (i + 1));
          gsl_linalg_householder_hm (tau_i, &v.vector, &m.matrix);
        }

      gsl_vector_set (S, i, tau_i);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
    {
      for(j = 0; j < i; j++)
        {
          gsl_matrix_set (X, i, j, 0.0);
        }

      {
        double Aii = gsl_matrix_get (A, i, i);
        gsl_matrix_set (X, i, i, Aii);
      }

      for(j = i + 1; j < N; j++)
        {
          double Aij = gsl_matrix_get (A, i, j);
          gsl_matrix_set (X, i, j, Aij);
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = N; j > 0 && j--;)
    {
      
      double tj = gsl_vector_get (S, j);
      gsl_matrix_view m = gsl_matrix_submatrix (A, j, j, M - j, N - j);
      gsl_linalg_householder_hm1 (tj, &m.matrix);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < M; i++)
      {
        gsl_vector_view L_i = gsl_matrix_row (A, i);
        gsl_vector_set_zero (&sum.vector);

        for(j = 0; j < N; j++)
          {
            double Lij = gsl_vector_get (&L_i.vector, j);
            gsl_vector_view X_j = gsl_matrix_row (X, j);
            gsl_blas_daxpy (Lij, &X_j.vector, &sum.vector);
          }

        gsl_vector_memcpy (&L_i.vector, &sum.vector);
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
        {
          double wi = gsl_vector_get (w, i);
          double alpha = gsl_vector_get (S, i);
          if (alpha != 0)
            alpha = 1.0 / alpha;
          gsl_vector_set (w, i, alpha * wi);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < N; j++)
        {
          gsl_vector_view cj = gsl_matrix_column (A, j);
          double sj = gsl_blas_dnrm2 (&cj.vector);
          gsl_vector_set(S, j, GSL_DBL_EPSILON * sj);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < N - 1; j++)
            {
              for(k = j + 1; k < N; k++)
                {
                  double a = 0.0;
                  double b = 0.0;
                  double p = 0.0;
                  double q = 0.0;
                  double cosine, sine;
                  double v;
                  double abserr_a, abserr_b;
                  int sorted, orthog, noisya, noisyb;

                  gsl_vector_view cj = gsl_matrix_column (A, j);
                  gsl_vector_view ck = gsl_matrix_column (A, k);

                  gsl_blas_ddot (&cj.vector, &ck.vector, &p);
                  p *= 2.0 ;  

                  a = gsl_blas_dnrm2 (&cj.vector);
                  b = gsl_blas_dnrm2 (&ck.vector);

                  q = a * a - b * b;
                  v = hypot(p, q);

                  

                  abserr_a = gsl_vector_get(S,j);
                  abserr_b = gsl_vector_get(S,k);

                  sorted = (gsl_coerce_double(a) >= gsl_coerce_double(b));
                  orthog = (fabs (p) <= tolerance * gsl_coerce_double(a * b));
                  noisya = (a < abserr_a);
                  noisyb = (b < abserr_b);

                  if (sorted && (orthog || noisya || noisyb))
                    {
                      count--;
                      continue;
                    }

                  
                  if (v == 0 || !sorted)
                    {
                      cosine = 0.0;
                      sine = 1.0;
                    }
                  else
                    {
                      cosine = sqrt((v + q) / (2.0 * v));
                      sine = p / (2.0 * v * cosine);
                    }

                  
                  for(i = 0; i < M; i++)
                    {
                      const double Aik = gsl_matrix_get (A, i, k);
                      const double Aij = gsl_matrix_get (A, i, j);
                      gsl_matrix_set (A, i, j, Aij * cosine + Aik * sine);
                      gsl_matrix_set (A, i, k, -Aij * sine + Aik * cosine);
                    }

                  gsl_vector_set(S, j, fabs(cosine) * abserr_a + fabs(sine) * abserr_b);
                  gsl_vector_set(S, k, fabs(sine) * abserr_a + fabs(cosine) * abserr_b);

                  
                  for(i = 0; i < N; i++)
                    {
                      const double Qij = gsl_matrix_get (Q, i, j);
                      const double Qik = gsl_matrix_get (Q, i, k);
                      gsl_matrix_set (Q, i, j, Qij * cosine + Qik * sine);
                      gsl_matrix_set (Q, i, k, -Qij * sine + Qik * cosine);
                    }
                }
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < N; j++)
          {
            gsl_vector_view column = gsl_matrix_column (A, j);
            double norm = gsl_blas_dnrm2 (&column.vector);

            



            if (norm == 0.0 || prev_norm == 0.0 
                || (j > 0 && norm <= tolerance * prev_norm))
              {
                gsl_vector_set (S, j, 0.0);     
                gsl_vector_set_zero (&column.vector);   

                prev_norm = 0.0;
              }
            else
              {
                gsl_vector_set (S, j, norm);    
                gsl_vector_scale (&column.vector, 1.0 / norm);  

                prev_norm = norm;
              }
          }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < A->size2; j++)
      {
        double wj = 0.0;
        gsl_vector_view A1j = gsl_matrix_column(&A1.matrix, j);
        gsl_blas_ddot (&A1j.vector, &v1.vector, &wj);
        wj += gsl_matrix_get(A,0,j);

        {
          double A0j = gsl_matrix_get (A, 0, j);
          gsl_matrix_set (A, 0, j, A0j - tau *  wj);
        }

        gsl_blas_daxpy (-tau * wj, &v1.vector, &A1j.vector);
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < A->size2; j++)
      {
        
        
        double wj = gsl_matrix_get(A,0,j);  
        
        for(i = 1; i < A->size1; i++)  
          {
            wj += gsl_matrix_get(A,i,j) * gsl_vector_get(v,i);
          }
        
        
        
        
        {
          double A0j = gsl_matrix_get (A, 0, j);
          gsl_matrix_set (A, 0, j, A0j - tau *  wj);
        }
        
        
        
        for(i = 1; i < A->size1; i++)
          {
            double Aij = gsl_matrix_get (A, i, j);
            double vi = gsl_vector_get (v, i);
            gsl_matrix_set (A, i, j, Aij - tau * vi * wj);
          }
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < A->size1; i++)
      {
        double wi = 0.0;
        gsl_vector_view A1i = gsl_matrix_row(&A1.matrix, i);
        gsl_blas_ddot (&A1i.vector, &v1.vector, &wi);
        wi += gsl_matrix_get(A,i,0);  
        
        {
          double Ai0 = gsl_matrix_get (A, i, 0);
          gsl_matrix_set (A, i, 0, Ai0 - tau *  wi);
        }
        
        gsl_blas_daxpy(-tau * wi, &v1.vector, &A1i.vector);
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < A->size1; i++)
      {
        double wi = gsl_matrix_get(A,i,0);  
        
        for(j = 1; j < A->size2; j++)  
          {
            wi += gsl_matrix_get(A,i,j) * gsl_vector_get(v,j);
          }
        
        
        
        {
          double Ai0 = gsl_matrix_get (A, i, 0);
          gsl_matrix_set (A, i, 0, Ai0 - tau *  wi);
        }
        
        
        
        for(j = 1; j < A->size2; j++) 
          {
            double vj = gsl_vector_get (v, j);
            double Aij = gsl_matrix_get (A, i, j);
            gsl_matrix_set (A, i, j, Aij - tau * wi * vj);
          }
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 1; j < A->size2; j++)
        {
          gsl_matrix_set (A, 0, j, 0.0);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i < A->size1; i++)
        {
          gsl_matrix_set (A, i, 0, 0.0);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 1; j < A->size2; j++)
      {
        double wj = 0.0;   
        
        gsl_vector_view A1j = gsl_matrix_column(&A1.matrix, j);
        gsl_blas_ddot (&A1j.vector, &v1.vector, &wj);

        
        
        gsl_matrix_set (A, 0, j, - tau *  wj);
        
        gsl_blas_daxpy(-tau*wj, &v1.vector, &A1j.vector);
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 1; j < A->size2; j++)
      {
        double wj = 0.0;   
        
        for(i = 1; i < A->size1; i++)
          {
            double vi = gsl_matrix_get(A, i, 0);
            wj += gsl_matrix_get(A,i,j) * vi;
          }
        
        
        
        gsl_matrix_set (A, 0, j, - tau *  wj);
        
        for(i = 1; i < A->size1; i++)
          {
            double vi = gsl_matrix_get (A, i, 0);
            double Aij = gsl_matrix_get (A, i, j);
            gsl_matrix_set (A, i, j, Aij - tau * vi * wj);
          }
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i < A->size1; i++)
      {
        double vi = gsl_matrix_get(A, i, 0);
        gsl_matrix_set(A, i, 0, -tau * vi);
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < N - 1; j++)
        {
          

          gsl_complex ajj = gsl_matrix_complex_get (A, j, j);
          double max = gsl_complex_abs (ajj);
          size_t i_pivot = j;

          for(i = j + 1; i < N; i++)
            {
              gsl_complex aij = gsl_matrix_complex_get (A, i, j);
              double ai = gsl_complex_abs (aij);

              if (ai > max)
                {
                  max = ai;
                  i_pivot = i;
                }
            }

          if (i_pivot != j)
            {
              gsl_matrix_complex_swap_rows (A, j, i_pivot);
              gsl_permutation_swap (p, j, i_pivot);
              *signum = -(*signum);
            }

          ajj = gsl_matrix_complex_get (A, j, j);

          if (!(GSL_REAL(ajj) == 0.0 && GSL_IMAG(ajj) == 0.0))
            {
              for(i = j + 1; i < N; i++)
                {
                  gsl_complex aij_orig = gsl_matrix_complex_get (A, i, j);
                  gsl_complex aij = gsl_complex_div (aij_orig, ajj);
                  gsl_matrix_complex_set (A, i, j, aij);

                  for(k = j + 1; k < N; k++)
                    {
                      gsl_complex aik = gsl_matrix_complex_get (A, i, k);
                      gsl_complex ajk = gsl_matrix_complex_get (A, j, k);
                      
                      

                      gsl_complex aijajk = gsl_complex_mul (aij, ajk);
                      gsl_complex aik_new = gsl_complex_sub (aik, aijajk);

                      gsl_matrix_complex_set (A, i, k, aik_new);
                    }
                }
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
    {
      gsl_vector_complex_view c = gsl_matrix_complex_column (inverse, i);
      int status_i = gsl_linalg_complex_LU_svx (LU, p, &(c.vector));

      if (status_i)
        status = status_i;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
    {
      gsl_complex zi = gsl_matrix_complex_get (LU, i, i);
      det = gsl_complex_mul (det, zi);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
    {
      gsl_complex z = gsl_matrix_complex_get (LU, i, i);
      lndet += log (gsl_complex_abs (z));
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
    {
      gsl_complex z = gsl_matrix_complex_get (LU, i, i);
      
      double r = gsl_complex_abs(z);

      if (r == 0)
        {
          phase = gsl_complex_rect(0.0, 0.0);
          break;
        }
      else
        {
          z = gsl_complex_div_real(z, r);
          phase = gsl_complex_mul(phase, z);
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < C->size1; i++)
        {
          for(j = 0; j < C->size2; j++)
            {
              a = gsl_matrix_get (A, i, 0);
              b = gsl_matrix_get (B, 0, j);
              temp = a * b;
              for(k = 1; k < A->size2; k++)
                {
                  a = gsl_matrix_get (A, i, k);
                  b = gsl_matrix_get (B, k, j);
                  temp += a * b;
                }
              gsl_matrix_set (C, i, j, temp);
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < dim1_C; i++)
            {
              for(j = 0; j < dim2_C; j++)
                {
                  a1 = i;
                  a2 = 0;
                  b1 = 0;
                  b2 = j;
                  if (modA & GSL_LINALG_MOD_TRANSPOSE)
                    SWAP_SIZE_T (a1, a2);
                  if (modB & GSL_LINALG_MOD_TRANSPOSE)
                    SWAP_SIZE_T (b1, b2);

                  a = gsl_matrix_get (A, a1, a2);
                  b = gsl_matrix_get (B, b1, b2);
                  temp = a * b;

                  for(k = 1; k < dim2_A; k++)
                    {
                      a1 = i;
                      a2 = k;
                      b1 = k;
                      b2 = j;
                      if (modA & GSL_LINALG_MOD_TRANSPOSE)
                        SWAP_SIZE_T (a1, a2);
                      if (modB & GSL_LINALG_MOD_TRANSPOSE)
                        SWAP_SIZE_T (b1, b2);
                      a = gsl_matrix_get (A, a1, a2);
                      b = gsl_matrix_get (B, b1, b2);
                      temp += a * b;
                    }

                  gsl_matrix_set (C, i, j, temp);
                }
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
        {
          gsl_vector_view c = gsl_matrix_row (A, i);
          double x = gsl_blas_dnrm2 (&c.vector);
          gsl_vector_set (norm, i, x);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < GSL_MIN (M, N); i++)
        {
          

          double max_norm = gsl_vector_get(norm, i);
          size_t j, kmax = i;

          for(j = i + 1; j < N; j++)
            {
              double x = gsl_vector_get (norm, j);

              if (x > max_norm)
                {
                  max_norm = x;
                  kmax = j;
                }
            }

          if (kmax != i)
            {
              gsl_matrix_swap_rows (A, i, kmax);
              gsl_permutation_swap (p, i, kmax);
              gsl_vector_swap_elements(norm,i,kmax);

              (*signum) = -(*signum);
            }

          


          {
            gsl_vector_view c_full = gsl_matrix_row (A, i);
            gsl_vector_view c = gsl_vector_subvector (&c_full.vector, 
                                                      i, M - i);
            double tau_i = gsl_linalg_householder_transform (&c.vector);

            gsl_vector_set (tau, i, tau_i);

            

            if (i + 1 < N)
              {
                gsl_matrix_view m = gsl_matrix_submatrix (A, i +1, i, N - (i+1), M - i);

                gsl_linalg_householder_mh (tau_i, &c.vector, &m.matrix);
              }
          }

          

          if (i + 1 < M) 
            {
              for(j = i + 1; j < N; j++)
                {
                  double x = gsl_vector_get (norm, j);

                  if (x > 0.0)
                    {
                      double y = 0;
                      double temp= gsl_matrix_get (A, j, i) / x;
                  
                      if (fabs (temp) >= 1)
                        y = 0.0;
                      else
                        y = x * sqrt (1 - temp * temp);
                      
                      

                      if (fabs (y / x) < sqrt (20.0) * GSL_SQRT_DBL_EPSILON)
                        {
                          gsl_vector_view c_full = gsl_matrix_row (A, j);
                          gsl_vector_view c = 
                            gsl_vector_subvector(&c_full.vector,
                                                 i+1, M - (i+1));
                          y = gsl_blas_dnrm2 (&c.vector);
                        }
                  
                      gsl_vector_set (norm, j, y);
                    }
                }
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = M - 1; k > 0; k--)
        {
          double c, s;
          double wk = gsl_vector_get (w, k);
          double wkm1 = gsl_vector_get (w, k - 1);

          create_givens (wkm1, wk, &c, &s);
          apply_givens_vec (w, k - 1, k, c, s);
          apply_givens_lq (M, N, Q, L, k - 1, k, c, s);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < N; j++)
        {
          double lj0 = gsl_matrix_get (L, j, 0);
          size_t p_j = gsl_permutation_get (p, j);
          double vj = gsl_vector_get (v, p_j);
          gsl_matrix_set (L, j, 0, lj0 + w0 * vj);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 1; k < N; k++)
        {
          double c, s;
          double diag = gsl_matrix_get (L, k - 1, k - 1);
          double offdiag = gsl_matrix_get (L, k - 1, k );

          create_givens (diag, offdiag, &c, &s);
          apply_givens_lq (M, N, Q, L, k - 1, k, c, s);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 0; k < M; k++)
    {
      double qki = gsl_matrix_get (Q, k, i);
      double qkj = gsl_matrix_get (Q, k, j);
      gsl_matrix_set (Q, k, i, qki * c - qkj * s);
      gsl_matrix_set (Q, k, j, qki * s + qkj * c);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = GSL_MIN (i, j); k < N; k++)
    {
      double rik = gsl_matrix_get (R, i, k);
      double rjk = gsl_matrix_get (R, j, k);
      gsl_matrix_set (R, i, k, c * rik - s * rjk);
      gsl_matrix_set (R, j, k, s * rik + c * rjk);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 0; k < M; k++)
    {
      double qik = gsl_matrix_get (Q, i, k);
      double qjk = gsl_matrix_get (Q, j, k);
      gsl_matrix_set (Q, i, k, qik * c - qjk * s);
      gsl_matrix_set (Q, j, k, qik * s + qjk * c);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = GSL_MIN (i, j); k < N; k++)
    {
      double lki = gsl_matrix_get (L, k, i);
      double lkj = gsl_matrix_get (L, k, j);
      gsl_matrix_set (L, k, i, c * lki - s * lkj);
      gsl_matrix_set (L, k, j, s * lki + c * lkj);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < A->size2; j++)
    {
      gsl_complex tauwj;
      gsl_complex wj = gsl_matrix_complex_get(A,0,j);  

      for(i = 1; i < A->size1; i++)  
        {
          gsl_complex Aij = gsl_matrix_complex_get(A,i,j);
          gsl_complex vi = gsl_vector_complex_get(v,i);
          gsl_complex Av = gsl_complex_mul (Aij, gsl_complex_conjugate(vi));
          wj = gsl_complex_add (wj, Av);
        }

      tauwj = gsl_complex_mul (tau, wj);

      
      
      {
        gsl_complex A0j = gsl_matrix_complex_get (A, 0, j);
        gsl_complex Atw = gsl_complex_sub (A0j, tauwj);
        
        gsl_matrix_complex_set (A, 0, j, Atw);
      }
      
      for(i = 1; i < A->size1; i++)
        {
          gsl_complex vi = gsl_vector_complex_get (v, i);
          gsl_complex tauvw = gsl_complex_mul(vi, tauwj);
          gsl_complex Aij = gsl_matrix_complex_get (A, i, j);
          gsl_complex Atwv = gsl_complex_sub (Aij, tauvw);
          
          gsl_matrix_complex_set (A, i, j, Atwv);
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < N - 1; j++)
        {
          

          REAL ajj, max = fabs (gsl_matrix_get (A, j, j));
          size_t i_pivot = j;

          for(i = j + 1; i < N; i++)
            {
              REAL aij = fabs (gsl_matrix_get (A, i, j));

              if (aij > max)
                {
                  max = aij;
                  i_pivot = i;
                }
            }

          if (i_pivot != j)
            {
              gsl_matrix_swap_rows (A, j, i_pivot);
              gsl_permutation_swap (p, j, i_pivot);
              *signum = -(*signum);
            }

          ajj = gsl_matrix_get (A, j, j);

          if (ajj != 0.0)
            {
              for(i = j + 1; i < N; i++)
                {
                  REAL aij = gsl_matrix_get (A, i, j) / ajj;
                  gsl_matrix_set (A, i, j, aij);

                  for(k = j + 1; k < N; k++)
                    {
                      REAL aik = gsl_matrix_get (A, i, k);
                      REAL ajk = gsl_matrix_get (A, j, k);
                      gsl_matrix_set (A, i, k, aik - aij * ajk);
                    }
                }
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
    {
      gsl_vector_view c = gsl_matrix_column (inverse, i);
      int status_i = gsl_linalg_LU_svx (LU, p, &(c.vector));

      if (status_i)
        status = status_i;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
    {
      det *= gsl_matrix_get (LU, i, i);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
    {
      lndet += log (fabs (gsl_matrix_get (LU, i, i)));
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
    {
      double u = gsl_matrix_get (LU, i, i);

      if (u < 0)
        {
          s *= -1;
        }
      else if (u == 0)
        {
          s = 0;
          break;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < N; j++)
    {
      gsl_vector_view A_j = gsl_matrix_column (A, j);
      
      double s = gsl_blas_dasum(&A_j.vector);
      
      double f = 1.0;
      
      if (s == 0.0 || !gsl_finite(s))
        {
          gsl_vector_set (D, j, f);
          continue;
        }

      

      while (s > 1.0)
        {
          s /= 2.0;
          f *= 2.0;
        }
      
      while (s < 0.5)
        {
          s *= 2.0;
          f /= 2.0;
        }
      
      gsl_vector_set (D, j, f);

      if (f != 1.0)
        {
          gsl_blas_dscal(1.0/f, &A_j.vector);
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(count = number_of_terms-1; count >= 1; --count)
  {
    
    gsl_blas_dgemm(CblasNoTrans, CblasNoTrans, 1.0, B, eB, 0.0, temp);
    gsl_matrix_scale(temp, 1.0/count);
    gsl_matrix_add_diagonal(temp, 1.0);

    
    gsl_matrix_memcpy(eB, temp);
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < sugg.j; ++i)
    {
      gsl_blas_dgemm(CblasNoTrans, CblasNoTrans, 1.0, eA, eA, 0.0, reduced_A);
      gsl_matrix_memcpy(eA, reduced_A);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i < N - 1; i++)
        {
          alpha[i] = diag[d_stride * i] - offdiag[o_stride*(i - 1)] * gamma[i - 1];
          gamma[i] = offdiag[o_stride * i] / alpha[i];
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i < N; i++)
        {
          z[i] = b[b_stride * i] - gamma[i - 1] * z[i - 1];
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
        {
          c[i] = z[i] / alpha[i];
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = N - 2, j = 0; j <= N - 2; j++, i--)
            {
              x[x_stride * i] = c[i] - gamma[i] * x[x_stride * (i + 1)];
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i < N; i++)
        {
          const double t = belowdiag[b_stride*(i - 1)]/alpha[i-1];
          alpha[i] = diag[d_stride*i] - t*abovediag[a_stride*(i - 1)];
          z[i] = rhs[r_stride*i] - t*z[i-1];
          
          if (alpha[i] == 0) {
            status = GSL_EZERODIV;
            goto solve_tridiag_nonsym_END;
          }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = N - 2, j = 0; j <= N - 2; j++, i--)
            {
              x[x_stride * i] = (z[i] - abovediag[a_stride*i] * x[x_stride * (i + 1)])/alpha[i];
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i < N - 2; i++)
        {
          alpha[i] = diag[d_stride * i] - offdiag[o_stride * (i-1)] * gamma[i - 1];
          gamma[i] = offdiag[o_stride * i] / alpha[i];
          delta[i] = -delta[i - 1] * offdiag[o_stride * (i-1)] / alpha[i];
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N - 2; i++)
        {
          sum += alpha[i] * delta[i] * delta[i];
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i < N - 1; i++)
        {
          z[i] = b[b_stride * i] - z[i - 1] * gamma[i - 1];
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N - 2; i++)
        {
          sum += delta[i] * z[i];
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
        {
          c[i] = z[i] / alpha[i];
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = N - 3, j = 0; j <= N - 3; j++, i--)
            {
              x[x_stride * i] = c[i] - gamma[i] * x[x_stride * (i + 1)] - delta[i] * x[x_stride * (N - 1)];
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i+1 < N; i++)
        {
          const double t = belowdiag[b_stride*(i - 1)]/alpha[i-1];
          alpha[i] = diag[d_stride*i] - t*abovediag[a_stride*(i - 1)];
          zb[i] = rhs[r_stride*i] - t*zb[i-1];
          zu[i] = -t*zu[i-1];
          
          if (alpha[i] == 0) {
            status = GSL_EZERODIV;
            goto solve_cyc_tridiag_nonsym_END;
          }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = N - 2, j = 0; j <= N - 2; j++, i--)
          {
            w[i] = (zu[i] - abovediag[a_stride*i] * w[i+1])/alpha[i];
            x[i*x_stride] = (zb[i] - abovediag[a_stride*i] * x[x_stride*(i + 1)])/alpha[i];
          }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
            x[i] -= vx/(1 + vw)*w[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
        {
          const REAL aii = gsl_matrix_get (A, i, i);
          REAL alpha;
          REAL f;
          REAL ak;
          REAL max_norm = 0.0;
          REAL r = 0.0;

          for(k = i; k < M; k++)
            {
              REAL aki = gsl_matrix_get (A, k, i);
              r += aki * aki;
            }

          if (r == 0.0)
            {
              
              free (d);
              GSL_ERROR ("matrix is rank deficient", GSL_ESING);
            }

          alpha = sqrt (r) * GSL_SIGN (aii);

          ak = 1.0 / (r + alpha * aii);
          gsl_matrix_set (A, i, i, aii + alpha);

          d[i] = -alpha;

          for(k = i + 1; k < N; k++)
            {
              REAL norm = 0.0;
              f = 0.0;
              for(j = i; j < M; j++)
                {
                  REAL ajk = gsl_matrix_get (A, j, k);
                  REAL aji = gsl_matrix_get (A, j, i);
                  norm += ajk * ajk;
                  f += ajk * aji;
                }
              max_norm = GSL_MAX (max_norm, norm);

              f *= ak;

              for(j = i; j < M; j++)
                {
                  REAL ajk = gsl_matrix_get (A, j, k);
                  REAL aji = gsl_matrix_get (A, j, i);
                  gsl_matrix_set (A, j, k, ajk - f * aji);
                }
            }

          if (fabs (alpha) < 2.0 * GSL_DBL_EPSILON * sqrt (max_norm))
            {
              
              free (d);
              GSL_ERROR("apparent singularity detected", GSL_ESING);
            }

          

          f = 0.0;
          for(j = i; j < M; j++)
            {
              f += gsl_vector_get (x, j) * gsl_matrix_get (A, j, i);
            }
          f *= ak;
          for(j = i; j < M; j++)
            {
              REAL xj = gsl_vector_get (x, j);
              REAL aji = gsl_matrix_get (A, j, i);
              gsl_vector_set (x, j, xj - f * aji);
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = N; i > 0 && i--;)
        {
          REAL xi = gsl_vector_get (x, i);
          REAL sum = 0.0;
          for(k = i + 1; k < N; k++)
            {
              sum += gsl_matrix_get (A, i, k) * gsl_vector_get (x, k);
            }

          gsl_vector_set (x, i, (xi - sum) / d[i]);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0 ; i < N - 2; i++)
        {
          gsl_vector_view c = gsl_matrix_column (A, i);
          gsl_vector_view v = gsl_vector_subvector (&c.vector, i + 1, N - (i + 1));
          double tau_i = gsl_linalg_householder_transform (&v.vector);
          
          

          if (tau_i != 0.0) 
            {
              gsl_matrix_view m = gsl_matrix_submatrix (A, i + 1, i + 1, 
                                                        N - (i+1), N - (i+1));
              double ei = gsl_vector_get(&v.vector, 0);
              gsl_vector_view x = gsl_vector_subvector (tau, i, N-(i+1));
              gsl_vector_set (&v.vector, 0, 1.0);
              
              
              gsl_blas_dsymv (CblasLower, tau_i, &m.matrix, &v.vector, 0.0, &x.vector);

              
              {
                double xv, alpha;
                gsl_blas_ddot(&x.vector, &v.vector, &xv);
                alpha = - (tau_i / 2.0) * xv;
                gsl_blas_daxpy(alpha, &v.vector, &x.vector);
              }
              
              
              gsl_blas_dsyr2(CblasLower, -1.0, &v.vector, &x.vector, &m.matrix);

              gsl_vector_set (&v.vector, 0, ei);
            }
          
          gsl_vector_set (tau, i, tau_i);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = N - 2; i > 0 && i--;)
        {
          gsl_vector_const_view c = gsl_matrix_const_column (A, i);
          gsl_vector_const_view h = gsl_vector_const_subvector (&c.vector, i + 1, N - (i+1));
          double ti = gsl_vector_get (tau, i);

          gsl_matrix_view m = gsl_matrix_submatrix (Q, i + 1, i + 1, N-(i+1), N-(i+1));

          gsl_linalg_householder_hm (ti, &h.vector, &m.matrix);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
        {
          double Aii = gsl_matrix_get (A, i, i);
          gsl_vector_set (diag, i, Aii);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N - 1; i++)
        {
          double Aji = gsl_matrix_get (A, i+1, i);
          gsl_vector_set (sdiag, i, Aji);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
        {
          double Aii = gsl_matrix_get (A, i, i);
          gsl_vector_set (diag, i, Aii);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N - 1; i++)
        {
          double Aij = gsl_matrix_get (A, i+1, i);
          gsl_vector_set (sdiag, i, Aij);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N - 1; i++)
    {
      double f_i = gsl_vector_get (f, i);
      double d_ip1 = gsl_vector_get (d, i + 1);

      if (fabs (f_i) < GSL_DBL_EPSILON * (fabs (d_i) + fabs (d_ip1)))
        {
          gsl_vector_set (f, i, 0.0);
        }
      d_i = d_ip1;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < M; i++)
        {
          double Uip = gsl_matrix_get (U, i, 0);
          double Uiq = gsl_matrix_get (U, i, 1);
          gsl_matrix_set (U, i, 0, c * Uip - s * Uiq);
          gsl_matrix_set (U, i, 1, s * Uip + c * Uiq);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
        {
          double Vip = gsl_matrix_get (V, i, 0);
          double Viq = gsl_matrix_get (V, i, 1);
          gsl_matrix_set (V, i, 0, c * Vip - s * Viq);
          gsl_matrix_set (V, i, 1, s * Vip + c * Viq);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
        {
          double Vip = gsl_matrix_get (V, i, 0);
          double Viq = gsl_matrix_get (V, i, 1);
          gsl_matrix_set (V, i, 0, c * Vip - s * Viq);
          gsl_matrix_set (V, i, 1, s * Vip + c * Viq);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < M; i++)
        {
          double Uip = gsl_matrix_get (U, i, 0);
          double Uiq = gsl_matrix_get (U, i, 1);
          gsl_matrix_set (U, i, 0, c * Uip - s * Uiq);
          gsl_matrix_set (U, i, 1, s * Uip + c * Uiq);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = k0; k < n - 1; k++)
    {
      create_givens (y, -x, &c, &s);
      
      

#ifdef USE_BLAS
      {
        gsl_vector_view Uk0 = gsl_matrix_column(U,k0);
        gsl_vector_view Ukp1 = gsl_matrix_column(U,k+1);
        gsl_blas_drot(&Uk0.vector, &Ukp1.vector, c, -s);
      }
#else
      {
        size_t i;

        for(i = 0; i < M; i++)
          {
            double Uip = gsl_matrix_get (U, i, k0);
            double Uiq = gsl_matrix_get (U, i, k + 1);
            gsl_matrix_set (U, i, k0, c * Uip - s * Uiq);
            gsl_matrix_set (U, i, k + 1, s * Uip + c * Uiq);
          }
      }
#endif
      
      
      
      gsl_vector_set (d, k + 1, s * x + c * y);

      if (k == k0)
        gsl_vector_set (f, k, c * x - s * y );

      if (k < n - 2) 
        {
          double z = gsl_vector_get (f, k + 1);
          gsl_vector_set (f, k + 1, c * z); 

          x = -s * z ;
          y = gsl_vector_get (d, k + 2); 
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = n - 1; k > 0 && k--;)
    {
      create_givens (x, y, &c, &s);

      

#ifdef USE_BLAS
      {
        gsl_vector_view Vp = gsl_matrix_column(V,k);
        gsl_vector_view Vq = gsl_matrix_column(V,n-1);
        gsl_blas_drot(&Vp.vector, &Vq.vector, c, -s);
      }
#else
      {
        size_t i;
   
        for(i = 0; i < N; i++)
          {
            double Vip = gsl_matrix_get (V, i, k);
            double Viq = gsl_matrix_get (V, i, n - 1);
            gsl_matrix_set (V, i, k, c * Vip - s * Viq);
            gsl_matrix_set (V, i, n - 1, s * Vip + c * Viq);
          }
      }
#endif

      
      
      gsl_vector_set (d, k, c * x - s * y);

      if (k == n - 2)
        gsl_vector_set (f, k, s * x + c * y );

      if (k > 0) 
        {
          double z = gsl_vector_get (f, k - 1);
          gsl_vector_set (f, k - 1, c * z); 

          x = gsl_vector_get (d, k - 1); 
          y = s * z ;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n - 1; i++)
    {
      double d_i = gsl_vector_get (d, i);
      
      if (d_i == 0.0)
        {
          chase_out_intermediate_zero (d, f, U, i);
          return;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 0; k < n - 1; k++)
    {
      double c, s;
      create_givens (y, z, &c, &s);

      

#ifdef USE_BLAS
      {
        gsl_vector_view Vk = gsl_matrix_column(V,k);
        gsl_vector_view Vkp1 = gsl_matrix_column(V,k+1);
        gsl_blas_drot(&Vk.vector, &Vkp1.vector, c, -s);
      }
#else
      for(i = 0; i < N; i++)
        {
          double Vip = gsl_matrix_get (V, i, k);
          double Viq = gsl_matrix_get (V, i, k + 1);
          gsl_matrix_set (V, i, k, c * Vip - s * Viq);
          gsl_matrix_set (V, i, k + 1, s * Vip + c * Viq);
        }
#endif

      

      {
        double bk1 = c * bk - s * z;

        double ap1 = c * ap - s * bp;
        double bp1 = s * ap + c * bp;
        double zp1 = -s * aq;

        double aq1 = c * aq;

        if (k > 0)
          {
            gsl_vector_set (f, k - 1, bk1);
          }

        ak = ap1;
        bk = bp1;
        zk = zp1;

        ap = aq1;

        if (k < n - 2)
          {
            bp = gsl_vector_get (f, k + 1);
          }
        else
          {
            bp = 0.0;
          }

        y = ak;
        z = zk;
      }

      create_givens (y, z, &c, &s);

      

#ifdef USE_BLAS
      {
        gsl_vector_view Uk = gsl_matrix_column(U,k);
        gsl_vector_view Ukp1 = gsl_matrix_column(U,k+1);
        gsl_blas_drot(&Uk.vector, &Ukp1.vector, c, -s);
      }
#else
      for(i = 0; i < M; i++)
        {
          double Uip = gsl_matrix_get (U, i, k);
          double Uiq = gsl_matrix_get (U, i, k + 1);
          gsl_matrix_set (U, i, k, c * Uip - s * Uiq);
          gsl_matrix_set (U, i, k + 1, s * Uip + c * Uiq);
        }
#endif

      

      {
        double ak1 = c * ak - s * zk;
        double bk1 = c * bk - s * ap;
        double zk1 = -s * bp;

        double ap1 = s * bk + c * ap;
        double bp1 = c * bp;

        gsl_vector_set (d, k, ak1);

        ak = ak1;
        bk = bk1;
        zk = zk1;

        ap = ap1;
        bp = bp1;

        if (k < n - 2)
          {
            aq = gsl_vector_get (d, k + 2);
          }
        else
          {
            aq = 0.0;
          }

        y = bk;
        z = zk;
      }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
        {
          gsl_vector_view c = gsl_matrix_column (A, i);
          double x = gsl_blas_dnrm2 (&c.vector);
          gsl_vector_set (norm, i, x);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < GSL_MIN (M, N); i++)
        {
          

          double max_norm = gsl_vector_get(norm, i);
          size_t j, kmax = i;

          for(j = i + 1; j < N; j++)
            {
              double x = gsl_vector_get (norm, j);

              if (x > max_norm)
                {
                  max_norm = x;
                  kmax = j;
                }
            }

          if (kmax != i)
            {
              gsl_matrix_swap_columns (A, i, kmax);
              gsl_permutation_swap (p, i, kmax);
              gsl_vector_swap_elements(norm,i,kmax);

              (*signum) = -(*signum);
            }

          


          {
            gsl_vector_view c_full = gsl_matrix_column (A, i);
            gsl_vector_view c = gsl_vector_subvector (&c_full.vector, 
                                                      i, M - i);
            double tau_i = gsl_linalg_householder_transform (&c.vector);

            gsl_vector_set (tau, i, tau_i);

            

            if (i + 1 < N)
              {
                gsl_matrix_view m = gsl_matrix_submatrix (A, i, i + 1, M - i, N - (i+1));

                gsl_linalg_householder_hm (tau_i, &c.vector, &m.matrix);
              }
          }

          

          if (i + 1 < M) 
            {
              for(j = i + 1; j < N; j++)
                {
                  double x = gsl_vector_get (norm, j);

                  if (x > 0.0)
                    {
                      double y = 0;
                      double temp= gsl_matrix_get (A, i, j) / x;
                  
                      if (fabs (temp) >= 1)
                        y = 0.0;
                      else
                        y = x * sqrt (1 - temp * temp);
                      
                      

                      if (fabs (y / x) < sqrt (20.0) * GSL_SQRT_DBL_EPSILON)
                        {
                          gsl_vector_view c_full = gsl_matrix_column (A, j);
                          gsl_vector_view c = 
                            gsl_vector_subvector(&c_full.vector,
                                                 i+1, M - (i+1));
                          y = gsl_blas_dnrm2 (&c.vector);
                        }
                  
                      gsl_vector_set (norm, j, y);
                    }
                }
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = N - 1; k > 0; k--)
        {
          double c, s;
          double wk = gsl_vector_get (w, k);
          double wkm1 = gsl_vector_get (w, k - 1);

          create_givens (wkm1, wk, &c, &s);
          apply_givens_vec (w, k - 1, k, c, s);
          apply_givens_qr (M, N, Q, R, k - 1, k, c, s);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < N; j++)
        {
          double r0j = gsl_matrix_get (R, 0, j);
          size_t p_j = gsl_permutation_get (p, j);
          double vj = gsl_vector_get (v, p_j);
          gsl_matrix_set (R, 0, j, r0j + w0 * vj);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 1; k < N; k++)
        {
          double c, s;
          double diag = gsl_matrix_get (R, k - 1, k - 1);
          double offdiag = gsl_matrix_get (R, k, k - 1);

          create_givens (diag, offdiag, &c, &s);
          apply_givens_qr (M, N, Q, R, k - 1, k, c, s);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0 ; i < N; i++)
        {
          
          
          {
            gsl_vector_view c = gsl_matrix_column (A, i);
            gsl_vector_view v = gsl_vector_subvector (&c.vector, i, M - i);
            double tau_i = gsl_linalg_householder_transform (&v.vector);
            
            
            
            if (i + 1 < N)
              {
                gsl_matrix_view m = 
                  gsl_matrix_submatrix (A, i, i + 1, M - i, N - (i + 1));
                gsl_linalg_householder_hm (tau_i, &v.vector, &m.matrix);
              }

            gsl_vector_set (tau_U, i, tau_i);            

          }

          
          
          if (i + 1 < N)
            {
              gsl_vector_view r = gsl_matrix_row (A, i);
              gsl_vector_view v = gsl_vector_subvector (&r.vector, i + 1, N - (i + 1));
              double tau_i = gsl_linalg_householder_transform (&v.vector);
              
              
              
              if (i + 1 < M)
                {
                  gsl_matrix_view m = 
                    gsl_matrix_submatrix (A, i+1, i+1, M - (i+1), N - (i+1));
                  gsl_linalg_householder_mh (tau_i, &v.vector, &m.matrix);
                }

              gsl_vector_set (tau_V, i, tau_i);
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
        {
          double Aii = gsl_matrix_get (A, i, i);
          gsl_vector_set (diag, i, Aii);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N - 1; i++)
        {
          double Aij = gsl_matrix_get (A, i, i+1);
          gsl_vector_set (superdiag, i, Aij);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = N - 1; i > 0 && i--;)
        {
          
          gsl_vector_const_view r = gsl_matrix_const_row (A, i);
          gsl_vector_const_view h = 
            gsl_vector_const_subvector (&r.vector, i + 1, N - (i+1));
          
          double ti = gsl_vector_get (tau_V, i);
          
          gsl_matrix_view m = 
            gsl_matrix_submatrix (V, i + 1, i + 1, N-(i+1), N-(i+1));
          
          gsl_linalg_householder_hm (ti, &h.vector, &m.matrix);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = N; j > 0 && j--;)
        {
          
          gsl_vector_const_view c = gsl_matrix_const_column (A, j);
          gsl_vector_const_view h = gsl_vector_const_subvector (&c.vector, j, M - j);
          double tj = gsl_vector_get (tau_U, j);
          
          gsl_matrix_view m = 
            gsl_matrix_submatrix (U, j, j, M-j, N-j);
          
          gsl_linalg_householder_hm (tj, &h.vector, &m.matrix);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = N - 1; i > 0 && i--;)
        {
          
          gsl_vector_const_view r = gsl_matrix_const_row (A, i);
          gsl_vector_const_view h = 
            gsl_vector_const_subvector (&r.vector, i + 1, N - (i+1));
          
          double ti = gsl_vector_get (tau_V, i);
          
          gsl_matrix_view m = 
            gsl_matrix_submatrix (V, i + 1, i + 1, N-(i+1), N-(i+1));
          
          gsl_linalg_householder_hm (ti, &h.vector, &m.matrix);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N - 1; i++)
        {
          double Aij = gsl_matrix_get (A, i, i+1);
          gsl_vector_set (tau_V, i, Aij);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = N; j > 0 && j--;)
        {
          
          double tj = gsl_vector_get (tau_U, j);
          double Ajj = gsl_matrix_get (A, j, j);
          gsl_matrix_view m = gsl_matrix_submatrix (A, j, j, M-j, N-j);

          gsl_vector_set (tau_U, j, Ajj);
          gsl_linalg_householder_hm1 (tj, &m.matrix);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < K; i++)
        {
          double Aii = gsl_matrix_get (A, i, i);
          gsl_vector_set (diag, i, Aii);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < K - 1; i++)
        {
          double Aij = gsl_matrix_get (A, i, i+1);
          gsl_vector_set (superdiag, i, Aij);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < GSL_MIN (M, N); i++)
        {
          


          gsl_vector_view c_full = gsl_matrix_column (A, i);
          gsl_vector_view c = gsl_vector_subvector (&(c_full.vector), i, M-i);

          double tau_i = gsl_linalg_householder_transform (&(c.vector));

          gsl_vector_set (tau, i, tau_i);

          


          if (i + 1 < N)
            {
              gsl_matrix_view m = gsl_matrix_submatrix (A, i, i + 1, M - i, N - (i + 1));
              gsl_linalg_householder_hm (tau_i, &(c.vector), &(m.matrix));
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < GSL_MIN (M, N); i++)
        {
          gsl_vector_const_view c = gsl_matrix_const_column (QR, i);
          gsl_vector_const_view h = gsl_vector_const_subvector (&(c.vector), i, M - i);
          gsl_vector_view w = gsl_vector_subvector (v, i, M - i);
          double ti = gsl_vector_get (tau, i);
          gsl_linalg_householder_hv (ti, &(h.vector), &(w.vector));
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = GSL_MIN (M, N); i > 0 && i--;)
        {
          gsl_vector_const_view c = gsl_matrix_const_column (QR, i);
          gsl_vector_const_view h = gsl_vector_const_subvector (&(c.vector), 
                                                                i, M - i);
          gsl_vector_view w = gsl_vector_subvector (v, i, M - i);
          double ti = gsl_vector_get (tau, i);
          gsl_linalg_householder_hv (ti, &h.vector, &w.vector);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = GSL_MIN (M, N); i > 0 && i--;)
        {
          gsl_vector_const_view c = gsl_matrix_const_column (QR, i);
          gsl_vector_const_view h = gsl_vector_const_subvector (&c.vector,
                                                                i, M - i);
          gsl_matrix_view m = gsl_matrix_submatrix (Q, i, i, M - i, M - i);
          double ti = gsl_vector_get (tau, i);
          gsl_linalg_householder_hm (ti, &h.vector, &m.matrix);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < M; i++)
        {
          for(j = 0; j < i && j < N; j++)
            gsl_matrix_set (R, i, j, 0.0);

          for(j = i; j < N; j++)
            gsl_matrix_set (R, i, j, gsl_matrix_get (QR, i, j));
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = M - 1; k > 0; k--)
        {
          double c, s;
          double wk = gsl_vector_get (w, k);
          double wkm1 = gsl_vector_get (w, k - 1);

          create_givens (wkm1, wk, &c, &s);
          apply_givens_vec (w, k - 1, k, c, s);
          apply_givens_qr (M, N, Q, R, k - 1, k, c, s);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < N; j++)
        {
          double r0j = gsl_matrix_get (R, 0, j);
          double vj = gsl_vector_get (v, j);
          gsl_matrix_set (R, 0, j, r0j + w0 * vj);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 1; k < GSL_MIN(M,N+1); k++)
        {
          double c, s;
          double diag = gsl_matrix_get (R, k - 1, k - 1);
          double offdiag = gsl_matrix_get (R, k, k - 1);

          create_givens (diag, offdiag, &c, &s);
          apply_givens_qr (M, N, Q, R, k - 1, k, c, s);

          gsl_matrix_set (R, k, k - 1, 0.0);    
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N - 2; ++i)
        {
          




          c = gsl_matrix_column(A, i);
          c = gsl_vector_subvector(&c.vector, i + 1, N - (i + 1));

          hv = gsl_vector_subvector(tau, i + 1, N - (i + 1));
          gsl_vector_memcpy(&hv.vector, &c.vector);

          
          tau_i = gsl_linalg_householder_transform(&hv.vector);

          
          m = gsl_matrix_submatrix(A, i + 1, i, N - (i + 1), N - i);
          gsl_linalg_householder_hm(tau_i, &hv.vector, &m.matrix);

          
          m = gsl_matrix_submatrix(A, 0, i + 1, N, N - (i + 1));
          gsl_linalg_householder_mh(tau_i, &hv.vector, &m.matrix);

          
          gsl_vector_set(tau, i, tau_i);

          




          c = gsl_vector_subvector(&c.vector, 1, c.vector.size - 1);
          hv = gsl_vector_subvector(&hv.vector, 1, hv.vector.size - 1);
          gsl_vector_memcpy(&c.vector, &hv.vector);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < (N - 2); ++j)
        {
          c = gsl_matrix_column(H, j);

          tau_j = gsl_vector_get(tau, j);

          





          hv = gsl_vector_subvector(&c.vector, j + 1, N - (j + 1));

          







          m = gsl_matrix_submatrix(V, 0, j + 1, V->size1, N - (j + 1));

          
          gsl_linalg_householder_mh(tau_j, &hv.vector, &m.matrix);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < N - 2; ++j)
    {
      for(i = j + 2; i < N; ++i)
        {
          gsl_matrix_set(H, i, j, 0.0);
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N - 2; ++i)
        {
          




          c = gsl_matrix_column(A, i);
          c = gsl_vector_subvector(&c.vector, i + 1, N - (i + 1));

          hv = gsl_vector_subvector(tau, i + 1, N - (i + 1));
          gsl_vector_memcpy(&hv.vector, &c.vector);

          
          tau_i = gsl_linalg_householder_transform(&hv.vector);

          



          m = gsl_matrix_submatrix(M,
                                   top + i + 1,
                                   top + i,
                                   N - (i + 1),
                                   N_M - top - i);
          gsl_linalg_householder_hm(tau_i, &hv.vector, &m.matrix);

          





          m = gsl_matrix_submatrix(M,
                                   0,
                                   top + i + 1,
                                   top + N,
                                   N - (i + 1));
          gsl_linalg_householder_mh(tau_i, &hv.vector, &m.matrix);

          
          gsl_vector_set(tau, i, tau_i);

          




          c = gsl_vector_subvector(&c.vector, 1, c.vector.size - 1);
          hv = gsl_vector_subvector(&hv.vector, 1, hv.vector.size - 1);
          gsl_vector_memcpy(&c.vector, &hv.vector);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < GSL_MIN (M, N); i++)
        {
          


          gsl_vector_view c_full = gsl_matrix_row (A, i);
          gsl_vector_view c = gsl_vector_subvector (&(c_full.vector), i, M-i);

          double tau_i = gsl_linalg_householder_transform (&(c.vector));

          gsl_vector_set (tau, i, tau_i);

          


          if (i + 1 < N)
            {
              gsl_matrix_view m = gsl_matrix_submatrix (A, i + 1, i, N - (i + 1), M - i );
              gsl_linalg_householder_mh (tau_i, &(c.vector), &(m.matrix));
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < GSL_MIN (M, N); i++)
        {
          gsl_vector_const_view c = gsl_matrix_const_row (LQ, i);
          gsl_vector_const_view h = gsl_vector_const_subvector (&(c.vector),
                                                                i, M - i);
          gsl_vector_view w = gsl_vector_subvector (v, i, M - i);
          double ti = gsl_vector_get (tau, i);
          gsl_linalg_householder_hv (ti, &(h.vector), &(w.vector));
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i =  GSL_MIN (M, N); i > 0 && i--;) 
        {
          gsl_vector_const_view c = gsl_matrix_const_row (LQ, i);
          gsl_vector_const_view h = gsl_vector_const_subvector (&(c.vector),
                                                                i, M - i);
          gsl_vector_view w = gsl_vector_subvector (v, i, M - i);
          double ti = gsl_vector_get (tau, i);
          gsl_linalg_householder_hv (ti, &(h.vector), &(w.vector));
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = GSL_MIN (M, N); i > 0 && i--;)
        {
          gsl_vector_const_view c = gsl_matrix_const_row (LQ, i);
          gsl_vector_const_view h = gsl_vector_const_subvector (&c.vector,
                                                                i, M - i);
          gsl_matrix_view m = gsl_matrix_submatrix (Q, i, i, M - i, M - i);
          double ti = gsl_vector_get (tau, i);
          gsl_linalg_householder_mh (ti, &h.vector, &m.matrix);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
        {
	    l_border=GSL_MIN(i,M-1);
		for(j = 0; j <= l_border ; j++)
		    gsl_matrix_set (L, i, j, gsl_matrix_get (LQ, i, j));

	    for(j = l_border+1; j < M; j++)
		gsl_matrix_set (L, i, j, 0.0);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = M - 1; k > 0; k--)
        {
          double c, s;
          double wk = gsl_vector_get (w, k);
          double wkm1 = gsl_vector_get (w, k - 1);

          create_givens (wkm1, wk, &c, &s);
          apply_givens_vec (w, k - 1, k, c, s);
          apply_givens_lq (M, N, Q, L, k - 1, k, c, s);
       }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < N; j++)
        {
          double lj0 = gsl_matrix_get (L, j, 0);
          double vj = gsl_vector_get (v, j);
          gsl_matrix_set (L, j, 0, lj0 + w0 * vj);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 1; k < GSL_MIN(M,N+1); k++)
        {
          double c, s;
          double diag = gsl_matrix_get (L, k - 1, k - 1);
          double offdiag = gsl_matrix_get (L, k - 1 , k);

          create_givens (diag, offdiag, &c, &s);
          apply_givens_lq (M, N, Q, L, k - 1, k, c, s);

          gsl_matrix_set (L, k - 1, k, 0.0);    
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; ++i)
            {
              row_norm = 0.0;
              col_norm = 0.0;

              for(j = 0; j < N; ++j)
                {
                  if (j != i)
                    {
                      col_norm += fabs(gsl_matrix_get(A, j, i));
                      row_norm += fabs(gsl_matrix_get(A, i, j));
                    }
                }

              if ((col_norm == 0.0) || (row_norm == 0.0))
                {
                  continue;
                }

              g = row_norm / FLOAT_RADIX;
              f = 1.0;
              s = col_norm + row_norm;

              



              while (col_norm < g)
                {
                  f *= FLOAT_RADIX;
                  col_norm *= FLOAT_RADIX_SQ;
                }

              g = row_norm * FLOAT_RADIX;

              while (col_norm > g)
                {
                  f /= FLOAT_RADIX;
                  col_norm /= FLOAT_RADIX_SQ;
                }

              if ((row_norm + col_norm) < 0.95 * s * f)
                {
                  not_converged = 1;

                  g = 1.0 / f;

                  




                  
                  v = gsl_matrix_row(A, i);
                  gsl_blas_dscal(g, &v.vector);

                  
                  v = gsl_matrix_column(A, i);
                  gsl_blas_dscal(f, &v.vector);

                  
                  gsl_vector_set(D, i, gsl_vector_get(D, i) * f);
                }
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; ++i)
        {
          s = gsl_vector_get(D, i);
          r = gsl_matrix_row(A, i);

          gsl_blas_dscal(s, &r.vector);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0 ; i < N - 1; i++)
        {
          gsl_vector_complex_view c = gsl_matrix_complex_column (A, i);
          gsl_vector_complex_view v = gsl_vector_complex_subvector (&c.vector, i + 1, N - (i + 1));
          gsl_complex tau_i = gsl_linalg_complex_householder_transform (&v.vector);
          
          

          if ((i + 1) < (N - 1) 
              && !(GSL_REAL(tau_i) == 0.0 && GSL_IMAG(tau_i) == 0.0)) 
            {
              gsl_matrix_complex_view m = 
                gsl_matrix_complex_submatrix (A, i + 1, i + 1, 
                                              N - (i+1), N - (i+1));
              gsl_complex ei = gsl_vector_complex_get(&v.vector, 0);
              gsl_vector_complex_view x = gsl_vector_complex_subvector (tau, i, N-(i+1));
              gsl_vector_complex_set (&v.vector, 0, one);
              
              
              gsl_blas_zhemv (CblasLower, tau_i, &m.matrix, &v.vector, zero, &x.vector);

              
              {
                gsl_complex xv, txv, alpha;
                gsl_blas_zdotc(&x.vector, &v.vector, &xv);
                txv = gsl_complex_mul(tau_i, xv);
                alpha = gsl_complex_mul_real(txv, -0.5);
                gsl_blas_zaxpy(alpha, &v.vector, &x.vector);
              }
              
              
              gsl_blas_zher2(CblasLower, neg_one, &v.vector, &x.vector, &m.matrix);

              gsl_vector_complex_set (&v.vector, 0, ei);
            }
          
          gsl_vector_complex_set (tau, i, tau_i);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = N - 1; i > 0 && i--;)
        {
          gsl_complex ti = gsl_vector_complex_get (tau, i);

          gsl_vector_complex_const_view c = gsl_matrix_complex_const_column (A, i);

          gsl_vector_complex_const_view h = 
            gsl_vector_complex_const_subvector (&c.vector, i + 1, N - (i+1));

          gsl_matrix_complex_view m = 
            gsl_matrix_complex_submatrix (Q, i + 1, i + 1, N-(i+1), N-(i+1));

          gsl_linalg_complex_householder_hm (ti, &h.vector, &m.matrix);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
        {
          gsl_complex Aii = gsl_matrix_complex_get (A, i, i);
          gsl_vector_set (diag, i, GSL_REAL(Aii));
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N - 1; i++)
        {
          gsl_complex Aji = gsl_matrix_complex_get (A, i+1, i);
          gsl_vector_set (sdiag, i, GSL_REAL(Aji));
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
        {
          gsl_complex Aii = gsl_matrix_complex_get (A, i, i);
          gsl_vector_set (diag, i, GSL_REAL(Aii));
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N - 1; i++)
        {
          gsl_complex Aji = gsl_matrix_complex_get (A, i+1, i);
          gsl_vector_set (sdiag, i, GSL_REAL(Aji));
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=4; i<maxiter; i++) {
    int j;
    double c2;
    double d1z;
    double g1, g2, g3;
    double x2i1 = 2*i - 3;
    ct1   = x2i1/(x2i1-2.0);
    anbn += x2i1 + sab;
    ct2   = (x2i1 - 1.0)/anbn;
    c2    = x2i1*ct2 - 1.0;
    d1z   = 2.0*x2i1*x/anbn;
    
    ct3 = sab*ct2;
    g1  = d1z + ct1*(c2+ct3);
    g2  = d1z - c2;
    g3  = ct1*(1.0 - ct3 - 2.0*ct2);
    
    bb[3] = g1*bb[2] + g2*bb[1] + g3*bb[0];
    aa[3] = g1*aa[2] + g2*aa[1] + g3*aa[0];
    
    if(fabs(aa[3]*bb[0]-aa[0]*bb[3]) < EPS*fabs(bb[3]*bb[0])) break;
    
    for(j=0; j<3; j++) {
      aa[j] = aa[j+1];
      bb[j] = bb[j+1];
    }
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=1; i<= -N; i++) {
      const double xi1  = i - 1;
      const double mult = (a+xi1)*x/((b+xi1)*(xi1+1.0));
      t_val *= mult;
      t_err += fabs(mult) * t_err + fabs(t_val) * 8.0 * 2.0 * GSL_DBL_EPSILON;
      sum_val += t_val;
      sum_err += t_err;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=1; i<=M; i++) {
        const double mult = (a-b+i)*x/((1.0-b+i)*i);
        t_val *= mult;
        t_err += t_err * fabs(mult) + fabs(t_val) * 8.0 * 2.0 * GSL_DBL_EPSILON;
        sum_val += t_val;
        sum_err += t_err;
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=1; i<2000; i++) {
        const double xi  = istrt + i;
        const double xi1 = istrt + i - 1;
        const double tmp = (a-1.0)*(xn+2.0*xi-1.0) + xi*(xi-beps);
        const double b0_multiplier = (a+xi1-beps)*x/((xn+xi1)*(xi-beps));
        const double c0_multiplier_1 = (a+xi1)*x/((b+xi1)*xi);
        const double c0_multiplier_2 = tmp / (xi*(b+xi1)*(a+xi1-beps));
        b0_val *= b0_multiplier;
        b0_err += fabs(b0_multiplier) * b0_err + fabs(b0_val) * 8.0 * 2.0 * GSL_DBL_EPSILON;
        c0_val  = c0_multiplier_1 * c0_val - c0_multiplier_2 * b0_val;
        c0_err  =  fabs(c0_multiplier_1) * c0_err
                 + fabs(c0_multiplier_2) * b0_err
                 + fabs(c0_val) * 8.0 * 2.0 * GSL_DBL_EPSILON
                 + fabs(b0_val * c0_multiplier_2) * 16.0 * 2.0 * GSL_DBL_EPSILON;
        t_val  = c0_val + xeps1_val*b0_val;
        t_err  = c0_err + fabs(xeps1_val)*b0_err;
        t_err += fabs(b0_val*lnx) * dexprl.err;
        t_err += fabs(b0_val)*xeps1_err;
        dchu_val += t_val;
        dchu_err += t_err;
        if(fabs(t_val) < EPS*fabs(dchu_val)) break;
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=1; i<2000; i++) {
        double xi = istrt + i;
        double xi1 = istrt + i - 1;
        double a0_multiplier = (a+xi1)*x/((b+xi1)*xi);
        double b0_multiplier = (a+xi1-beps)*x/((aintb+xi1)*(xi-beps));
        a0_val *= a0_multiplier;
        a0_err += fabs(a0_multiplier) * a0_err;
        b0_val *= b0_multiplier;
        b0_err += fabs(b0_multiplier) * b0_err;
        t_val = a0_val - b0_val;
        t_err = a0_err + b0_err;
        dchu_val += t_val;
        dchu_err += t_err;
        if(fabs(t_val) < EPS*fabs(dchu_val)) break;
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(bp = b0+1.0; bp<b-0.1; bp += 1.0) {
      Ubp1 = ((1.0+a-bp)*Ubm1 + (bp+x-1.0)*Ub)/x;
      Ubm1 = Ub;
      Ub   = Ubp1;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ap=-1; ap>a; ap--) {
      Uam1 = ap*(b-ap-1.0)*Uap1 + (x+2.0*ap-b)*Ua;
      Uap1 = Ua;
      Ua   = Uam1;
      RESCALE_2(Ua,Uap1,scale_factor,scale_count);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ap=1; ap<a; ap++) {
      Uap1 = -(Uam1 + (b-2.0*ap-x)*Ua)/(ap*(1.0+ap-b));
      Uam1 = Ua;
      Ua   = Uap1;
      RESCALE_2(Ua,Uam1,scale_factor,scale_count);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ap=a; ap>a_target; ap--) {
        Uam1 = -((b-2.0*ap-x)*Ua + ap*(1.0+ap-b)*Uap1);
        Uap1 = Ua;
        Ua   = Uam1;
        RESCALE_2(Ua,Uap1,scale_factor,scale_count);
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ap=a; ap>a1; ap--) {
          Uam1 = -((b-2.0*ap-x)*Ua + ap*(1.0+ap-b)*Uap1);
          Uap1 = Ua;
          Ua   = Uam1;
          RESCALE_2(Ua,Uap1,scale_factor,scale_count_bck);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ap=a0; ap<a1; ap++) {
          Uap1 = -(Uam1 + (b-2.0*ap-x)*Ua)/(ap*(1.0+ap-b));
          Uam1 = Ua;
          Ua   = Uap1;
          RESCALE_2(Ua,Uam1,scale_factor,scale_count_for);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ap=a0; ap>a+0.1; ap -= 1.0) {
      Uam1 = ap*(b0-ap-1.0)*Uap1 + (x+2.0*ap-b0)*Ua;
      Uap1 = Ua;
      Ua   = Uam1;
      RESCALE_2(Ua,Uap1,scale_factor,scale_count);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(bp=b0+1.0; bp<b-0.1; bp += 1.0) {
        Ubp1 = ((1.0+a-bp)*Ubm1 + (bp+x-1.0)*Ub)/x;
        Ubm1 = Ub;
        Ub   = Ubp1;
        RESCALE_2(Ub,Ubm1,scale_factor,scale_count);
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ap=a0; ap<a-0.1; ap += 1.0) {
      Uap1 = -(Uam1 + (b-2.0*ap-x)*Ua)/(ap*(1.0+ap-b));
      Uam1 = Ua;
      Ua   = Uap1;
      RESCALE_2(Ua,Uam1,scale_factor,scale_count);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ap=a; ap>a0+0.1; ap -= 1.0) {
        Uam1 = -((b-2.0*ap-x)*Ua + ap*(1.0+ap-b)*Uap1);
        Uap1 = Ua;
        Ua   = Uam1;
        RESCALE_2(Ua,Uap1,scale_factor,scale_count);
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ap=a; ap>a1+0.1; ap -= 1.0) {
          Uam1 = -((b-2.0*ap-x)*Ua + ap*(1.0+ap-b)*Uap1);
          Uap1 = Ua;
          Ua   = Uam1;
          RESCALE_2(Ua,Uap1,scale_factor,scale_count_bck);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ap=a0; ap<a1-0.1; ap += 1.0) {
          Uap1 = -(Uam1 + (b-2.0*ap-x)*Ua)/(ap*(1.0+ap-b));
          Uam1 = Ua;
          Ua   = Uap1;
          RESCALE_2(Ua,Uam1,scale_factor,scale_count_for);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(n=0; n<N; n++) {
      K_num1 = K_nu;
      K_nu   = K_nup1;
      K_nup1 = 2.0*(mu+n+1)/x * K_nu + K_num1;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k=1; k<=numexp; k++) {
    double sum2 = 1.0;
    double xk  = 1.0/(rk*x);
    double xk1 = 1.0;
    int j;
    for(j=1; j<=order; j++) {
      sum2 = sum2*xk1*xk + 1.0;
      xk1 += 1.0;
    }
    sumexp *= t;
    sumexp += sum2;
    rk -= 1.0;
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k=1; k<=n-1; k++) {
    k_term *= -y/(k * (n-k));
    sum1 += k_term;
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k=1; k<KMAX; k++) {
      psi_kp1   += 1.0/k;
      psi_npkp1 += 1.0/(n+k);
      k_fact    *= k;
      npk_fact.val *= n+k;
      yk *= y;
      k_term = yk*(psi_kp1 + psi_npkp1 - 2.0*ln_x_2)/(k_fact*npk_fact.val);
      sum2 += k_term;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=1; j<n; j++) {
      b_jp1 = b_jm1 + j * two_over_x * b_j;
      b_jm1 = b_j;
      b_j   = b_jp1; 
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0; j<=nmax-nmin; j++) result_array[j] = 0.0;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(n=nmin+1; n<=nmax+1; n++) {
      if(Knm1 < GSL_DBL_MAX) {
        result_array[n-1-nmin] = Knm1;
        Knp1 = Knm1 + n * two_over_x * Kn;
        Knm1 = Kn;
        Kn   = Knp1;
      }
      else {
        






        int j;
        for(j=n; j<=nmax+1; j++) result_array[j-1-nmin] = 0.0;
        GSL_ERROR ("overflow", GSL_EOVRFLW);
      }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<=nmax-nmin; i++) result_array[i] *= ex;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=iterm-1; j>=0; j--) {
      double c = factor * (j+1.0) / (iterm+1.0);
      factor *= ratio;
      qden[j] = qden[j+1] - c * qden[j];
      qnum[j] = qnum[j+1] - c * qnum[j];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k=2; k<=n; k++) {
      qcoeff[k] = -qcoeff[k-1];
      for(i=k-1; i>=2; i--) {
        qcoeff[i] = i*qcoeff[i] - (k-(i-1))*qcoeff[i-1];
      }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=2; i<=n; i++) {
        f = f*a + qcoeff[i];
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=n-1; i>=1; i--) {
        f = f*a + qcoeff[i];
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(n=2; n<100; n++) {
      double rat = (n-1.0)/n;
      double p   = pow(rat, j+1.0);
      term *= -ex * p;
      sum  += term;
      if(fabs(term/sum) < GSL_DBL_EPSILON) break;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(jterm=0; jterm<=itmax; jterm++) {
      double p = pow(jterm+1.0, j+1.0);
      double term = enx/p;
      f_previous = f;
      fd_whiz(term, jterm, qnum, qden, &f, &s);
      xn += x;
      if(fabs(f-f_previous) < fabs(f)*2.0*GSL_DBL_EPSILON || xn < GSL_LOG_DBL_MIN) break;
      enx *= ex;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(n=1; n<=itmax; n++) {
    double add_previous = add;
    gsl_sf_result eta;
    gsl_sf_eta_int_e(2*n, &eta);
    xgam = xgam * xm2 * (j + 1.0 - (2*n-2)) * (j + 1.0 - (2*n-1));
    add  = eta.val * xgam;
    if(!j_integer && fabs(add) > fabs(add_previous)) break;
    if(fabs(add/seqn_val) < GSL_DBL_EPSILON) break;
    seqn_val += add;
    seqn_err += 2.0 * GSL_DBL_EPSILON * fabs(add);
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(n=1; n<nmax; n++) {
    double term;
    gsl_sf_eta_e(j+1.0-n, &eta_factor);
    pow_factor *= x/n;
    term = pow_factor * eta_factor;
    sum += term;
    if(fabs(term/sum) < GSL_DBL_EPSILON && fabs(prev/sum) < GSL_DBL_EPSILON) break;
    prev = term;
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(n=1; n<=j+2; n++) {
    gsl_sf_eta_int_e(j+1-n, &eta_factor);
    pow_factor *= x/n;
    del  = pow_factor * eta_factor.val;
    sum += del;
    if(fabs(del/sum) < GSL_DBL_EPSILON) break;
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(m=3; m<24; m++) {
      gsl_sf_eta_int_e(1-2*m, &eta_factor);
      pow_factor *= x*x / ((j+2*m)*(j+2*m-1));
      sum2 += eta_factor.val * pow_factor;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(n=1; n<nmax; n+=2) {
    double del_val;
    double del_err;
    gsl_sf_result U;
    gsl_sf_result M;
    int stat_h_U = gsl_sf_hyperg_U_int_e(1, j+2, n*x, &U);
    int stat_h_F = gsl_sf_hyperg_1F1_int_e(1, j+2, -n*x, &M);
    stat_h = GSL_ERROR_SELECT_3(stat_h, stat_h_U, stat_h_F);
    del_val = ((j+1.0)*U.val - M.val);
    del_err = (fabs(j+1.0)*U.err + M.err);
    sum_odd_val += del_val;
    sum_odd_err += del_err;
    if(fabs(del_val/sum_odd_val) < GSL_DBL_EPSILON) break;
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(n=2; n<nmax; n+=2) {
    double del_val;
    double del_err;
    gsl_sf_result U;
    gsl_sf_result M;
    int stat_h_U = gsl_sf_hyperg_U_int_e(1, j+2, n*x, &U);
    int stat_h_F = gsl_sf_hyperg_1F1_int_e(1, j+2, -n*x, &M);
    stat_h = GSL_ERROR_SELECT_3(stat_h, stat_h_U, stat_h_F);
    del_val = ((j+1.0)*U.val - M.val);
    del_err = (fabs(j+1.0)*U.err + M.err);
    sum_even_val -= del_val;
    sum_even_err += del_err;
    if(fabs(del_val/sum_even_val) < GSL_DBL_EPSILON) break;
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(n=2; n<100 ; n++) {
      double rat = (n-1.0)/n;
      term *= -ex * rat * rat;
      sum  += term;
      if(fabs(term/sum) < GSL_DBL_EPSILON) break;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(n=2; n<100 ; n++) {
      double rat = (n-1.0)/n;
      term *= -ex * rat * rat * rat;
      sum  += term;
      if(fabs(term/sum) < GSL_DBL_EPSILON) break;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(n=2; n<200 ; n++) {
      double rat = (n-1.0)/n;
      term *= -ex * sqrt(rat);
      sum  += term;
      if(fabs(term/sum) < GSL_DBL_EPSILON) break;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(n=2; n<100 ; n++) {
      double rat = (n-1.0)/n;
      term *= -ex * rat * sqrt(rat);
      sum  += term;
      if(fabs(term/sum) < GSL_DBL_EPSILON) break;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(n=2; n<100 ; n++) {
      double rat = (n-1.0)/n;
      term *= -ex * rat * rat * sqrt(rat);
      sum  += term;
      if(fabs(term/sum) < GSL_DBL_EPSILON) break;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k=1; k<=kmax; k++) {
    double L = lam_min + k;
    cl[k] = cl[k-1] * hypot(L, eta)/(L*(2.0*L+1.0));
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k=2; k<kmax; k++) {
    double del;
    double del_p;
    double abs_del;
    double abs_del_p;

    Ak = (2.0*eta*Akm1 - Akm2)/(k*(2.0*lam + 1.0 + k));

    xpow *= x;
    del   = Ak*xpow;
    del_p = (k+lam+1.0)*del;
    sum  += del;
    sump += del_p;

    abs_del   = fabs(del);
    abs_del_p = fabs(del_p);

    if(          abs_del/(fabs(sum)+abs_del)          < GSL_DBL_EPSILON
       &&   prev_abs_del/(fabs(sum)+prev_abs_del)     < GSL_DBL_EPSILON
       &&      abs_del_p/(fabs(sump)+abs_del_p)       < GSL_DBL_EPSILON
       && prev_abs_del_p/(fabs(sump)+prev_abs_del_p)  < GSL_DBL_EPSILON
       && k > kmin
       ) break;

    



    prev_abs_del   = abs_del;
    prev_abs_del_p = abs_del_p;

    Akm2 = Akm1;
    Akm1 = Ak;
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k=kmax-1; k>=0; k--) {
    double el = eta/lam;
    double rl = hypot(1.0, el);
    double sl = el  + lam*x_inv;
    double fc_lm1;
    fc_lm1 = (fcl*sl + fpl)/rl;
    fpl    =  fc_lm1*sl - fcl*rl;
    fcl    =  fc_lm1;
    lam -= 1.0;
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k=1; k<=kmax; k++) {
    double el = eta/lam;
    double rl = hypot(1.0, el);
    double sl = el + lam*x_inv;
    double gcl1 = (sl*gcl - gpl)/rl;
    gpl   = rl*gcl - sl*gcl1;
    gcl   = gcl1;
    lam += 1.0;
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k=0; k<=kmax; k++) {
      fc_array[k] = 0.0;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k=kmax-1; k>=0; k--) {
      double el = eta/lam;
      double rl = hypot(1.0, el);
      double sl = el  + lam*x_inv;
      double fc_lm1 = (fcl*sl + fpl)/rl;
      fc_array[k]   = fc_lm1;
      fpl           =  fc_lm1*sl - fcl*rl;
      fcl           =  fc_lm1;
      lam -= 1.0;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k=kmax-1; k>=0; k--) {
    double el = eta/lam;
    double rl = hypot(1.0, el);
    double sl = el  + lam*x_inv;
    double fc_lm1;
    fc_lm1 = (fcl*sl + fpl)/rl;
    fc_array[k] = fc_lm1;
    fpl         =  fc_lm1*sl - fcl*rl;
    fcl         =  fc_lm1;
    lam -= 1.0;
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k=1; k<=kmax; k++) {
    double el = eta/lam;
    double rl = hypot(1.0, el);
    double sl = el + lam*x_inv;
    double gcl1 = (sl*gcl - gpl)/rl;
    gc_array[k] = gcl1;
    gpl         = rl*gcl - sl*gcl1;
    gcl         = gcl1;
    lam += 1.0;
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k=kmax-1; k>=0; k--) {
    double el = eta/lam;
    double rl = hypot(1.0, el);
    double sl = el  + lam*x_inv;
    double fc_lm1;
    fc_lm1 = (fcl*sl + fpl)/rl;
    fc_array[k]  = fc_lm1;
    fpl          = fc_lm1*sl - fcl*rl;
    fcp_array[k] = fpl;
    fcl          =  fc_lm1;
    lam -= 1.0;
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k=1; k<=kmax; k++) {
    double el = eta/lam;
    double rl = hypot(1.0, el);
    double sl = el + lam*x_inv;
    double gcl1 = (sl*gcl - gpl)/rl;
    gc_array[k]  = gcl1;
    gpl          = rl*gcl - sl*gcl1;
    gcp_array[k] = gpl;
    gcl          = gcl1;
    lam += 1.0;
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k=0; k<=kmax; k++) {
      fc_array[k] = 0.0;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k=0; k<=kmax; k++) {
      fc_array[k] = fc_array[k] / x;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=4; i>=0; --i) {
      num = x*num + P[i];
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=5; i>=0; --i) {
      den = x*den + Q[i];
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=1; i<5; ++i) {
    
    coef *= -(2*i+1)/(i*(4*x*x*x*x));
    e += coef;
    






  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k=1; k<30; ++k) {
    coef *= -x*x/k;
    del   = coef/(2.0*k+1.0);
    e += del;
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k=1; k<=n-1; k++) {
    k_term *= y/(k * (n-k));
    sum1 += k_term;
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k=1; k<KMAX; k++) {
      psi_kp1   += 1./k;
      psi_npkp1 += 1./(n+k);
      k_fact   *= k;
      npk_fact.val *= n+k;
      yk *= -y;
      k_term = yk*(psi_kp1 + psi_npkp1 - 2.0*ln_x_2)/(k_fact*npk_fact.val);
      sum2 += k_term;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=1; j<n; j++) { 
        byp = j*two_over_x*by - bym;
        bym = by;
        by  = byp;
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0; j<=nmax-nmin; j++) result_array[j] = 0.0;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(n=nmin+1; n<=nmax+1; n++) {
        result_array[n-nmin-1] = Ynm1;
        Ynp1 = -Ynm1 + 2.0*n/x * Yn;
        Ynm1 = Yn;
        Yn   = Ynp1;
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(n=nmin; n<=nmax; n++) {
        result_array[n-nmin] = 0.0;
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = n_recurse; i >= 1; --i)
  {
    gsl_complex zn = gsl_complex_add_real(z, i - 1.0);
    gsl_complex zn_inverse = gsl_complex_inverse(zn);
    a = gsl_complex_sub(a, zn_inverse);
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(n=1; n<=M; n++) {
      sum += 1.0/(n * (n*n + y*y));
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(m = 0; m < M; ++m)
      sum += 1.0/((x+m)*(x+m));



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k=1; k<=8; k++) {
    double R = zr + k;
    double I = zi;
    double a = lanczos_7_c[k] / (R*R + I*I);
    Ag_r +=  a * R;
    Ag_i -=  a * I;
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k=1; k<=8; k++) { Ag += lanczos_7_c[k]/(x+k); }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k=1; k<=n; k++) {
        product *= (x/k);
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k=n; k>=m+1; k--) {
          double tk = (double)k / (double)(k-m);
          if(tk > GSL_DBL_MAX/prod) {
            OVERFLOW_ERROR(result);
          }
          prod *= tk;
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ii=0; ii<ni; ii++)
      {
          nn = GSL_SF_MATHIEU_COEFF - ii - 1;
          ff[ni-ii-1] = -1.0/((4*nn*nn - aa)/qq + ff[ni-ii]);
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ii=0; ii<ni; ii++)
      {
          nn = GSL_SF_MATHIEU_COEFF - ii - 1;
          ff[ni-ii-1] = -1.0/(((2*nn + 1)*(2*nn + 1) - aa)/qq + ff[ni-ii]);
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ii=0; ii<ni; ii++)
      {
          nn = GSL_SF_MATHIEU_COEFF - ii - 1;
          ff[ni-ii-1] = -1.0/((4*(nn + 1)*(nn + 1) - aa)/qq + ff[ni-ii]);
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ii=0; ii<ni; ii++)
      {
          nn = GSL_SF_MATHIEU_COEFF - ii - 1;
          ff[ni-ii-1] = -1.0/(((2*nn + 1)*(2*nn + 1) - aa)/qq + ff[ni-ii]);
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ii=0; ii<GSL_SF_MATHIEU_COEFF; ii++)
          coeff[ii] = 0.0;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ii=3; ii<order/2+1; ii++)
          {
              coeff[ii] = (aa - 4*(ii - 1)*(ii - 1))/qq*coeff[ii-1] -
                                                                  coeff[ii-2];
              sum += coeff[ii];
          }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ii=2; ii<order/2+1; ii++)
          {
              coeff[ii] = (aa - (2*ii - 1)*(2*ii - 1))/qq*coeff[ii-1] -
                                                                  coeff[ii-2];
              sum += coeff[ii];
          }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ii=nn+1; ii<GSL_SF_MATHIEU_COEFF; ii++)
  {
      coeff[ii] = ff[ii-nn-1]*coeff[ii-1];
      sum += coeff[ii];

      

      if (fabs(coeff[ii]) < 1e-20)
      {
          for(; ii<GSL_SF_MATHIEU_COEFF;)
              coeff[ii++] = 0.0;
      }
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ii=0; ii<GSL_SF_MATHIEU_COEFF; ii++)
      coeff[ii] /= sum;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ii=0; ii<GSL_SF_MATHIEU_COEFF; ii++)
          coeff[ii] = 0.0;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ii=2; ii<order/2; ii++)
          {
              coeff[ii] = (aa - 4*ii*ii)/qq*coeff[ii-1] - coeff[ii-2];
              sum += 2*(ii + 1)*coeff[ii];
          }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ii=2; ii<order/2+1; ii++)
          {
              coeff[ii] = (aa - (2*ii - 1)*(2*ii - 1))/qq*coeff[ii-1] -
                                                                  coeff[ii-2];
              sum += (2*(ii + 1) - 1)*coeff[ii];
          }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ii=nn+1; ii<GSL_SF_MATHIEU_COEFF; ii++)
  {
      coeff[ii] = ff[ii-nn-1]*coeff[ii-1];
      sum += 2*(ii + 1)*coeff[ii];

      

      if (fabs(coeff[ii]) < 1e-20)
      {
          for(; ii<GSL_SF_MATHIEU_COEFF;)
              coeff[ii++] = 0.0;
      }
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ii=0; ii<GSL_SF_MATHIEU_COEFF; ii++)
      coeff[ii] /= sum;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<100; i++) {
    J[i] = i/10.0;
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<100; i++) {
    J[i] = i;
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<100; i++) {
    J[i] = i * 20;
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=1; i<=lmax; i++) {
      t_coeff /= i*(2*(i-l) - 1);
      t_power *= t;
      delta = t_power*t_coeff;
      sum += delta;
      if(fabs(delta/sum) < 0.5*GSL_DBL_EPSILON) break;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=1; j<l; j++) { 
      byp = (2*j+1)/x*by - bym;
      bym = by;
      by  = byp;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ell = 1; ell < lmax; ell++) {
      yellp1 = (2*ell+1)/x * yell - yellm1;
      result_array[ell+1] = yellp1;
      yellm1 = yell;
      yell   = yellp1;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k=4; k<=n; k++) {
        gk = (2.0*(k+lambda-1.0)*x*gkm1 - (k+2.0*lambda-2.0)*gkm2) / k;
        gkm2 = gkm1;
        gkm1 = gk;
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k=2; k<=nmax; k++) {
    double term1 = 2.0*(k+lambda-1.0) * x * result_array[k-1];
    double term2 = (k+2.0*lambda-2.0)     * result_array[k-2];
    result_array[k] = (term1 - term2) / k;
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(n=steps; n>0; n--) {
    Jnm1 = 2.0*(nu+n)/x * Jn - Jnp1;
    Jnp1 = Jn;
    Jnp1_save = Jn;
    Jn   = Jnm1;
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(n=1; n<N; n++) {
        Ynp1 = 2.0*(mu+n)/x * Yn - Ynm1;
        Ynm1 = Yn;
        Yn   = Ynp1;
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(n=N; n>0; n--) {
        Jnm1 = 2.0*(mu+n)/x * Jn - Jnp1;
        Jnp1 = Jn;
        Jn   = Jnm1;
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k=1; k<=kmax; k++) {
        term *= y/((nu+k)*k);
        sumk += term;
        if(fabs(term/sumk) < threshold) break;
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=1; i<16; i++) tpow[i] = t * tpow[i-1];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=1; i<16; i++) tpow[i] = t * tpow[i-1];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k=1; k<maxk; k++) {
    double ak = -0.25 * (x/(nu+k)) * x/(nu+k+1.0);
    rhok = -ak*(1.0 + rhok)/(1.0 + ak*(1.0 + rhok));
    tk  *= rhok;
    sum += tk;

    dk = 1.0 / (2.0/x - (nu+k-1.0)/(nu+k) * dk);
    if(dk < 0.0) s = -s;

    if(fabs(tk/sum) < GSL_DBL_EPSILON) break;
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k=1; k<maxk; k++) {
    double ak = 0.25 * (x/(nu+k)) * x/(nu+k+1.0);
    rhok = -ak*(1.0 + rhok)/(1.0 + ak*(1.0 + rhok));
    tk  *= rhok;
    sum += tk;
    if(fabs(tk/sum) < GSL_DBL_EPSILON) break;
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=2; i<=max_iter; i++) {
    a  += 2*(i-1);
    bi += 2.0;
    dr = a*dr + br;
    di = a*di + bi;
    if(fabs(dr)+fabs(di) < SMALL) dr = SMALL;
    fact = a/(cr*cr+ci*ci);
    cr = br + cr*fact;
    ci = bi - ci*fact;
    if(fabs(cr)+fabs(ci) < SMALL) cr = SMALL;
    den = dr*dr + di*di;
    dr /= den;
    di /= -den;
    dlr = cr*dr - ci*di;
    dli = cr*di + ci*dr;
    temp = p*dlr - q*dli;
    q = p*dli + q*dlr;
    p = temp;
    if(fabs(dlr-1.0)+fabs(dli) < GSL_DBL_EPSILON) break;
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=2; i<=maxiter; i++) {
    double dels;
    double tmp;
    ai -= 2.0*(i-1);
    ci  = -ai*ci/i;
    tmp  = (qi - bi*qip1)/ai;
    qi   = qip1;
    qip1 = tmp;
    Qi += ci*qip1;
    bi += 2.0;
    di  = 1.0/(bi + ai*di);
    delhi = (bi*di - 1.0) * delhi;
    hi += delhi;
    dels = Qi*delhi;
    s += dels;
    if(fabs(dels/s) < GSL_DBL_EPSILON) break;
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k=0; k<5; k++)
        result += C[k] * pow(xo2, 2.*k);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(n=1; n<nmax; n++) {
    double aR = n - 0.5;
    term *= (aR*aR + lambda*lambda)*zeta/(ell + n + 0.5)/n;
    sum  += term;
    sum_err += 2.0*GSL_DBL_EPSILON*fabs(term);
    if(fabs(term/sum) < 2.0 * GSL_DBL_EPSILON) break;
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k=1; k<maxk; k++) {
    double tlk = (2.0*ell + 1.0 + 2.0*k);
    double l1k = (ell + 1.0 + k);
    double ak = -(lambda*lambda + l1k*l1k)/(tlk*(tlk+2.0)*coth_eta*coth_eta);
    rhok = -ak*(1.0 + rhok)/(1.0 + ak*(1.0 + rhok));
    tk  *= rhok;
    sum += tk;
    sum_err += 2.0 * GSL_DBL_EPSILON * k * fabs(tk);
    if(fabs(tk/sum) < GSL_DBL_EPSILON) break;
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(lp=ell; lp>0; lp--) {
      double root_term_0 = hypot(lambda,lp);
      double root_term_1 = hypot(lambda,lp+1.0);
      Hlm1 = ((2.0*lp + 1.0)*coth_eta*Hl - root_term_1 * Hlp1)/root_term_0;
      Hlp1 = Hl;
      Hl   = Hlm1;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ell=0; ell<=lmax; ell++) result_array[ell] = 0.0;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ell=0; ell<=lmax; ell++) result_array[ell] = 0.0;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ell=lmax-1; ell>0; ell--) {
      double root_term_0 = hypot(lambda,ell);
      double root_term_1 = hypot(lambda,ell+1.0);
      Hlm1 = ((2.0*ell + 1.0)*coth_eta*Hl - root_term_1 * Hlp1)/root_term_0;
      result_array[ell-1] = Hlm1;
      if(!(Hlm1 < GSL_DBL_MAX)) stat_recursion = GSL_EOVRFLW;
      Hlp1 = Hl;
      Hl   = Hlm1;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<max_iters; i++) {
    double tol;
    const double e = exp(w);
    const double p = w + 1.0;
    double t = w*e - x;
    

    if (w > 0) {
      t = (t/p)/e;  
    } else {
      t /= e*p - 0.5*(p + 1.0)*t/p;  
    };

    w -= t;

    tol = GSL_DBL_EPSILON * GSL_MAX_DBL(fabs(w), 1.0/(fabs(p)*e));

    if(fabs(t) < tol)
    {
      result->val = w;
      result->err = 2.0*tol;
      return GSL_SUCCESS;
    }
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=1; i<ad; i++) {
          int j = i-1;
          term *= (a + d2 + j) * (b + d2 + j) / (1.0 + d2 + j) / i * (1.0-x);
          sum1 += term;
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=1; j<maxiter; j++) {
        
        double term1 = 1.0/(double)j  + 1.0/(ad+j);
        double term2 = 1.0/(a+d1+j-1.0) + 1.0/(b+d1+j-1.0);
        double delta = 0.0;
        psi_val += term1 - term2;
        psi_err += GSL_DBL_EPSILON * (fabs(term1) + fabs(term2));
        fact *= (a+d1+j-1.0)*(b+d1+j-1.0)/((ad+j)*j) * (1.0-x);
        delta = fact * psi_val;
        sum2_val += delta;
        sum2_err += fabs(fact * psi_err) + GSL_DBL_EPSILON*fabs(delta);
        if(fabs(delta) < GSL_DBL_EPSILON * fabs(sum2_val)) break;
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k=2; k<=nterms; k++) {
        double gbk = 0.0;
        for(j=1; j<=k; j++) {
          gbk += bern[k-j+1]*gbern[j];
        }
        gbern[k+1] = -rho*gbk/k;

        term  *= (2*k-2-x)*(2*k-1-x)*var2;
        poly1 += gbern[k+1]*term;
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=incr-1; i >= 0; i--) {
      



      double binv = 1.0/(bp+i);
      dpoch1 = (dpoch1 - binv) / (1.0 + x*binv);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ell=1; ell<l; ell++) {
      Qellp1 = (x*(2.0*ell + 1.0) * Qell - ell * Qellm1) / (ell + 1.0);
      Qellm1 = Qell;
      Qell   = Qellp1;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ell=l; ell>0; ell--) {
      Qellm1 = (x * (2.0*ell + 1.0) * Qell - (ell+1.0) * Qellp1) / ell;
      Qellp1 = Qell;
      Qell   = Qellm1;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=2; i<=n; i++) {
    En = 1./(i-1) * (ex - x * En);
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k=2; k<kmax; k++) {
    const double rk = (k-1.0)/k;
    term *= x;
    term *= rk*rk;
    sum += term;
    if(fabs(term/sum) < GSL_DBL_EPSILON) break;
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k=2; k<10; k++)
  {
    double ds;
    rk *= r;
    ds = rk/(k*k*(k+1.0));
    sum += ds;
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(; k<kmax; k++)
  {
    double ds;
    rk *= r;
    ds = rk/(k*k*(k+1.0));
    sum += ds;
    if(fabs(ds/sum) < 0.5*GSL_DBL_EPSILON) break;
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k=2; k<kmax; k++) {
    double dr, di;
    double ck_tmp = ck;
    ck = ck - (alpha*ck + beta*sk);
    sk = sk - (alpha*sk - beta*ck_tmp);
    rk *= r;
    dr = rk/((double)k*k) * ck;
    di = rk/((double)k*k) * sk;
    real_sum += dr;
    imag_sum += di;
    if(fabs((dr*dr + di*di)/(real_sum*real_sum + imag_sum*imag_sum)) < GSL_DBL_EPSILON*GSL_DBL_EPSILON) break;
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k=2; k<kmax; k++)
  {
    double dr, di;
    const double ck_tmp = ck;
    ck = ck - (alpha*ck + beta*sk);
    sk = sk - (alpha*sk - beta*ck_tmp);
    rk *= r;
    dr = rk/((double)k*k*(k+1.0)) * ck;
    di = rk/((double)k*k*(k+1.0)) * sk;
    real_sum += dr;
    imag_sum += di;
    if(fabs((dr*dr + di*di)/(real_sum*real_sum + imag_sum*imag_sum)) < GSL_DBL_EPSILON*GSL_DBL_EPSILON) break;
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(n=1; n<=6; n++) {
    double t;
    an *= a;
    nfact *= n;
    t = an/nfact;
    sum_re += t * H_re[n];
    sum_im += t * H_im[n];
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(kk=0; kk<GSL_SF_MATHIEU_COEFF; kk++)
      {
          amax = GSL_MAX(amax, fabs(coeff[kk]));
          if (fabs(coeff[kk])/amax < maxerr)
              break;

          j1c = gsl_sf_bessel_Jn(kk, u1);
          if (kind == 1)
          {
              z2c = gsl_sf_bessel_Jn(kk, u2);
          }
          else 
          {
              z2c = gsl_sf_bessel_Yn(kk, u2);
          }
              
          fc = pow(-1.0, 0.5*order+kk)*coeff[kk];
          fn += fc*j1c*z2c;
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(kk=0; kk<GSL_SF_MATHIEU_COEFF; kk++)
      {
          amax = GSL_MAX(amax, fabs(coeff[kk]));
          if (fabs(coeff[kk])/amax < maxerr)
              break;

          j1c = gsl_sf_bessel_Jn(kk, u1);
          j1pc = gsl_sf_bessel_Jn(kk+1, u1);
          if (kind == 1)
          {
              z2c = gsl_sf_bessel_Jn(kk, u2);
              z2pc = gsl_sf_bessel_Jn(kk+1, u2);
          }
          else 
          {
              z2c = gsl_sf_bessel_Yn(kk, u2);
              z2pc = gsl_sf_bessel_Yn(kk+1, u2);
          }
          fc = pow(-1.0, 0.5*(order-1)+kk)*coeff[kk];
          fn += fc*(j1c*z2pc + j1pc*z2c);
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(kk=0; kk<GSL_SF_MATHIEU_COEFF; kk++)
      {
          amax = GSL_MAX(amax, fabs(coeff[kk]));
          if (fabs(coeff[kk])/amax < maxerr)
              break;

          j1mc = gsl_sf_bessel_Jn(kk, u1);
          j1pc = gsl_sf_bessel_Jn(kk+2, u1);
          if (kind == 1)
          {
              z2mc = gsl_sf_bessel_Jn(kk, u2);
              z2pc = gsl_sf_bessel_Jn(kk+2, u2);
          }
          else 
          {
              z2mc = gsl_sf_bessel_Yn(kk, u2);
              z2pc = gsl_sf_bessel_Yn(kk+2, u2);
          }
          
          fc = pow(-1.0, 0.5*order+kk+1)*coeff[kk];
          fn += fc*(j1mc*z2pc - j1pc*z2mc);
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(kk=0; kk<GSL_SF_MATHIEU_COEFF; kk++)
      {
          amax = GSL_MAX(amax, fabs(coeff[kk]));
          if (fabs(coeff[kk])/amax < maxerr)
              break;

          j1c = gsl_sf_bessel_Jn(kk, u1);
          j1pc = gsl_sf_bessel_Jn(kk+1, u1);
          if (kind == 1)
          {
              z2c = gsl_sf_bessel_Jn(kk, u2);
              z2pc = gsl_sf_bessel_Jn(kk+1, u2);
          }
          else 
          {
              z2c = gsl_sf_bessel_Yn(kk, u2);
              z2pc = gsl_sf_bessel_Yn(kk+1, u2);
          }
          
          fc = pow(-1.0, 0.5*(order-1)+kk)*coeff[kk];
          fn += fc*(j1c*z2pc - j1pc*z2c);
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ii=0; ii<nmax-nmin+1; ii++)
      result_array[ii] = 0.0;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ii=0, order=nmin; order<=nmax; ii++, order++)
  {
      even_odd = 0;
      if (order % 2 != 0)
          even_odd = 1;

      
      status = gsl_sf_mathieu_a_coeff(order, qq, aa[order], coeff);
      if (status != GSL_SUCCESS)
      {
          return status;
      }

      if (even_odd == 0)
      {
          for(kk=0; kk<GSL_SF_MATHIEU_COEFF; kk++)
          {
              amax = GSL_MAX(amax, fabs(coeff[kk]));
              if (fabs(coeff[kk])/amax < maxerr)
                  break;

              j1c = gsl_sf_bessel_Jn(kk, u1);
              if (kind == 1)
              {
                  z2c = gsl_sf_bessel_Jn(kk, u2);
              }
              else 
              {
                  z2c = gsl_sf_bessel_Yn(kk, u2);
              }
              
              fc = pow(-1.0, 0.5*order+kk)*coeff[kk];
              fn += fc*j1c*z2c;
          }

          fn *= sqrt(pi/2.0)/coeff[0];
      }
      else
      {
          for(kk=0; kk<GSL_SF_MATHIEU_COEFF; kk++)
          {
              amax = GSL_MAX(amax, fabs(coeff[kk]));
              if (fabs(coeff[kk])/amax < maxerr)
                  break;

              j1c = gsl_sf_bessel_Jn(kk, u1);
              j1pc = gsl_sf_bessel_Jn(kk+1, u1);
              if (kind == 1)
              {
                  z2c = gsl_sf_bessel_Jn(kk, u2);
                  z2pc = gsl_sf_bessel_Jn(kk+1, u2);
              }
              else 
              {
                  z2c = gsl_sf_bessel_Yn(kk, u2);
                  z2pc = gsl_sf_bessel_Yn(kk+1, u2);
              }
              fc = pow(-1.0, 0.5*(order-1)+kk)*coeff[kk];
              fn += fc*(j1c*z2pc + j1pc*z2c);
          }

          fn *= sqrt(pi/2.0)/coeff[0];
      }

      result_array[ii] = fn;
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ii=0; ii<nmax-nmin+1; ii++)
      result_array[ii] = 0.0;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ii=0, order=nmin; order<=nmax; ii++, order++)
  {
      even_odd = 0;
      if (order % 2 != 0)
          even_odd = 1;
  
      
      status = gsl_sf_mathieu_b_coeff(order, qq, bb[order], coeff);
      if (status != GSL_SUCCESS)
      {
          return status;
      }

      if (even_odd == 0)
      {
          for(kk=0; kk<GSL_SF_MATHIEU_COEFF; kk++)
          {
              amax = GSL_MAX(amax, fabs(coeff[kk]));
              if (fabs(coeff[kk])/amax < maxerr)
                  break;

              j1mc = gsl_sf_bessel_Jn(kk, u1);
              j1pc = gsl_sf_bessel_Jn(kk+2, u1);
              if (kind == 1)
              {
                  z2mc = gsl_sf_bessel_Jn(kk, u2);
                  z2pc = gsl_sf_bessel_Jn(kk+2, u2);
              }
              else 
              {
                  z2mc = gsl_sf_bessel_Yn(kk, u2);
                  z2pc = gsl_sf_bessel_Yn(kk+2, u2);
              }
          
              fc = pow(-1.0, 0.5*order+kk+1)*coeff[kk];
              fn += fc*(j1mc*z2pc - j1pc*z2mc);
          }

          fn *= sqrt(pi/2.0)/coeff[0];
      }
      else
      {
          for(kk=0; kk<GSL_SF_MATHIEU_COEFF; kk++)
          {
              amax = GSL_MAX(amax, fabs(coeff[kk]));
              if (fabs(coeff[kk])/amax < maxerr)
                  break;

              j1c = gsl_sf_bessel_Jn(kk, u1);
              j1pc = gsl_sf_bessel_Jn(kk+1, u1);
              if (kind == 1)
              {
                  z2c = gsl_sf_bessel_Jn(kk, u2);
                  z2pc = gsl_sf_bessel_Jn(kk+1, u2);
              }
              else 
              {
                  z2c = gsl_sf_bessel_Yn(kk, u2);
                  z2pc = gsl_sf_bessel_Yn(kk+1, u2);
              }
          
              fc = pow(-1.0, 0.5*(order-1)+kk)*coeff[kk];
              fn += fc*(j1c*z2pc - j1pc*z2c);
          }

          fn *= sqrt(pi/2.0)/coeff[0];
      }

      result_array[ii] = fn;
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=1; i<=m; i++)
    {
      p_mm *= -fact_coeff * root_factor;
      fact_coeff += 2.0;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ell=2; ell <= l; ell++){
      p_ell = (x*(2*ell-1)*p_ellm1 - (ell-1)*p_ellm2) / ell;
      p_ellm2 = p_ellm1;
      p_ellm1 = p_ell;

      e_ell = 0.5*(fabs(x)*(2*ell-1.0) * e_ellm1 + (ell-1.0)*e_ellm2)/ell;
      e_ellm2 = e_ellm1;
      e_ellm1 = e_ell;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ell=2; ell <= lmax; ell++){
      p_ell = (x*(2*ell-1)*p_ellm1 - (ell-1)*p_ellm2) / ell;
      p_ellm2 = p_ellm1;
      p_ellm1 = p_ell;
      result_array[ell] = p_ell;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ell = 2; ell <= lmax; ell++)
      {
        const double pre = 0.5 * ell * (ell+1.0);
        result_deriv_array[ell] = pre * (1.0 - 0.25 * (1.0-x) * (ell+2.0)*(ell-1.0));
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ell = 2; ell <= lmax; ell++)
      {
        const double sgn = ( GSL_IS_ODD(ell) ? 1.0 : -1.0 ); 
        const double pre = sgn * 0.5 * ell * (ell+1.0);
        result_deriv_array[ell] = pre * (1.0 - 0.25 * (1.0+x) * (ell+2.0)*(ell-1.0));
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ell = 2; ell <= lmax; ell++)
      {
        result_deriv_array[ell] = - ell * (x * result_array[ell] - result_array[ell-1]) / (diff_a * diff_b);
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ell=m+2; ell <= l; ell++){
        p_ell = (x*(2*ell-1)*p_ellm1 - (ell+m-1)*p_ellm2) / (ell-m);
        p_ellm2 = p_ellm1;
        p_ellm1 = p_ell;
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ell=m; ell<=lmax; ell++) result_array[ell-m] = 0.0;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ell=m+2; ell <= lmax; ell++){
        p_ell = (x*(2.0*ell-1.0)*p_ellm1 - (ell+m-1)*p_ellm2) / (ell-m);
        p_ellm2 = p_ellm1;
        p_ellm1 = p_ell;
        result_array[ell-m] = p_ell;
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ell = m; ell <= lmax; ell++) result_deriv_array[ell-m] = -0.25 * x * (ell - 1.0)*ell*(ell+1.0)*(ell+2.0);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ell = m; ell <= lmax; ell++)
          {
            const double sgn = ( GSL_IS_ODD(ell) ? 1.0 : -1.0 );
            result_deriv_array[ell-m] = -0.25 * sgn * x * (ell - 1.0)*ell*(ell+1.0)*(ell+2.0);
          }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ell = m; ell <= lmax; ell++) result_deriv_array[ell-m] = 0.0;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ell = m+2; ell <= lmax; ell++)
          {
            result_deriv_array[ell-m] = - (ell * x * result_array[ell-m] - (ell+m) * result_array[ell-1-m]) / (diff_a * diff_b);
          }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ell=m+2; ell <= l; ell++){
        const double rat1 = (double)(ell-m)/(double)(ell+m);
        const double rat2 = (ell-m-1.0)/(ell+m-1.0);
        const double factor1 = sqrt(rat1*(2.0*ell+1.0)*(2.0*ell-1.0));
        const double factor2 = sqrt(rat1*rat2*(2.0*ell+1.0)/(2.0*ell-3.0));
        y_ell = (x*y_mmp1*factor1 - (ell+m-1.0)*y_mm*factor2) / (ell-m);
        y_mm   = y_mmp1;
        y_mmp1 = y_ell;

        y_ell_err = 0.5*(fabs(x*factor1)*y_mmp1_err + fabs((ell+m-1.0)*factor2)*y_mm_err) / fabs(ell-m);
        y_mm_err = y_mmp1_err;
        y_mmp1_err = y_ell_err;
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ell=m; ell<=lmax; ell++) result_array[ell-m] = 0.0;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ell=m+2; ell <= lmax; ell++){
        const double rat1 = (double)(ell-m)/(double)(ell+m);
        const double rat2 = (ell-m-1.0)/(ell+m-1.0);
        const double factor1 = sqrt(rat1*(2*ell+1)*(2*ell-1));
        const double factor2 = sqrt(rat1*rat2*(2*ell+1)/(2*ell-3));
        y_ell = (x*y_mmp1*factor1 - (ell+m-1)*y_mm*factor2) / (ell-m);
        y_mm   = y_mmp1;
        y_mmp1 = y_ell;
        result_array[ell-m] = y_ell;
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ell = 0; ell <= lmax; ell++)
    {
      const double prefactor = sqrt((2.0 * ell + 1.0)/(4.0*M_PI));
      result_array[ell] *= prefactor;
      result_deriv_array[ell] *= prefactor;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ell = 1; ell <= lmax; ell++)
    {
      const double prefactor = sqrt((2.0 * ell + 1.0)/(ell + 1.0) / (4.0*M_PI*ell));
      result_array[ell-1] *= prefactor;
      result_deriv_array[ell-1] *= prefactor;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ell = m; ell <= lmax; ell++) result_deriv_array[ell-m] = 0.0;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ell = m+2; ell <= lmax; ell++)
        {
          const double c1 = sqrt(((2.0*ell+1.0)/(2.0*ell-1.0)) * ((double)(ell-m)/(double)(ell+m)));
          result_deriv_array[ell-m] = - (ell * x * result_array[ell-m] - c1 * (ell+m) * result_array[ell-1-m]) / (diff_a * diff_b);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k=1; k<maxk; k++) {
    double tlk = 2.0*(ell + mu + k);
    double l1k = (ell + mu - 0.5 + 1.0 + k);
    double ak = -(tau*tau + l1k*l1k)/(tlk*(tlk+2.0)) * gamma;
    rhok = -ak*(1.0 + rhok)/(1.0 + ak*(1.0 + rhok));
    tk  *= rhok;
    sum += tk;
    if(fabs(tk/sum) < GSL_DBL_EPSILON) break;
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k=1; k<=kmax; k++) {
    double re_ak = re_a + k - 1.0;
    double re_bk = re_b + k - 1.0;
    double re_ck = re_c + k - 1.0;
    double im_ak = im_a;
    double im_bk = im_b;
    double im_ck = im_c;
    double den = re_ck*re_ck + im_ck*im_ck;
    double re_multiplier = ((re_ak*re_bk - im_ak*im_bk)*re_ck + im_ck*(im_ak*re_bk + re_ak*im_bk)) / den;
    double im_multiplier = ((im_ak*re_bk + re_ak*im_bk)*re_ck - im_ck*(re_ak*re_bk - im_ak*im_bk)) / den;
    double re_tmp = re_multiplier*re_term - im_multiplier*im_term;
    double im_tmp = im_multiplier*re_term + re_multiplier*im_term;
    double asum = fabs(re_sum) + fabs(im_sum);
    re_term = y/k * re_tmp;
    im_term = y/k * im_tmp;
    if(fabs(re_term/asum) < GSL_DBL_EPSILON && fabs(im_term/asum) < GSL_DBL_EPSILON) break;
    re_sum += re_term;
    im_sum += im_term;
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=1; i<=7; i++) {
    T[i] = T[i-1] * t;
    H[i] = H[i-1] * (t*f);
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=1; i<=11; i++) {
    V[i] = V[i-1] * tau;
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=1; i<=7; i++) {
    T[i] = T[i-1] * t;
    H[i] = H[i-1] * (t*f);
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=1; i<=11; i++) {
    V[i] = V[i-1] * tau;
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ell=0; ell<l; ell++) {
      double d = (ell+1.0)*(ell+1.0) + lambda*lambda;
      Pellp1 = (Pellm1 - (2.0*ell+1.0)*c*x * Pell) / d;
      Pellm1 = Pell;
      Pell   = Pellp1;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ell=l; ell>=0; ell--) {
      double d = (ell+1.0)*(ell+1.0) + lambda*lambda;
      Pellm1 = (2.0*ell+1.0)*xi * Pell + d * Pellp1;
      Pellp1 = Pell;
      Pell   = Pellm1;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ell=l; ell>=0; ell--) {
      double d = (ell+1.0)*(ell+1.0) + lambda*lambda;
      Pellm1 = (2.0*ell+1.0)*xi * Pell - d * Pellp1;
      Pellp1 = Pell;
      Pell   = Pellm1;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k=0; k<m; k++) {
      double d = (k+0.5)*(k+0.5) + lambda*lambda;
      Pkp1 = (Pkm1 - 2.0*k*c*x * Pk) / d;
      Pkm1 = Pk;
      Pk   = Pkp1;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k=m; k>0; k--) {
      double d = (k+0.5)*(k+0.5) + lambda*lambda;
      Pkm1 = 2.0*k*xi * Pk + d * Pkp1;
      Pkp1 = Pk;
      Pk   = Pkm1;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k=m; k>-1; k--) {
      double d = (k+0.5)*(k+0.5) + lambda*lambda;
      Pkm1 = 2.0*k*xi * Pk - d * Pkp1;
      Pkp1 = Pk;
      Pk   = Pkm1;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(n=0; n<N; n++) {
      K_num1 = K_nu;
      K_nu   = K_nup1;
      K_nup1 = 2.0*(mu+n+1)/x * K_nu + K_num1;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ii=0; ii<n1; ii++)
              term = qq*qq/(aa - 4.0*(ii+1)*(ii+1) - term);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ii=0; ii<nterms; ii++)
      term1 = qq*qq/



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ii=0; ii<n1; ii++)
      term = qq*qq/(aa - (2.0*ii + 1.0)*(2.0*ii + 1.0) - term);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ii=0; ii<nterms; ii++)
      term1 = qq*qq/



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ii=0; ii<n1; ii++)
      term = qq*qq/(aa - 4.0*(ii + 1)*(ii + 1) - term);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ii=0; ii<nterms; ii++)
      term1 = qq*qq/



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ii=0; ii<n1; ii++)
      term = qq*qq/(aa - (2.0*ii + 1.0)*(2.0*ii + 1.0) - term);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ii=0; ii<nterms; ii++)
      term1 = qq*qq/



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(;;)
      {
          if (even_odd == 0)
              fa = ceer(order, qq, aa, nterms);
          else
              fa = ceor(order, qq, aa, nterms);
      
          a2 = a1;
          a1 = aa;

          if (fa == fa1)
          {
              result->err = GSL_DBL_EPSILON;
              break;
          }
          aa -= (aa - a2)/(fa - fa1)*fa;
          dela = fabs(aa - a2);
          if (dela < GSL_DBL_EPSILON)
          {
              result->err = GSL_DBL_EPSILON;
              break;
          }
          if (ii > 20)
          {
              result->err = dela;
              break;
          }
          fa1 = fa;
          ii++;
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(;;)
      {
          if (even_odd == 0)
              fa = seer(order, qq, aa, nterms);
          else
              fa = seor(order, qq, aa, nterms);
      
          a2 = a1;
          a1 = aa;

          if (fa == fa1)
          {
              result->err = GSL_DBL_EPSILON;
              break;
          }
          aa -= (aa - a2)/(fa - fa1)*fa;
          dela = fabs(aa - a2);
          if (dela < 1e-18)
          {
              result->err = GSL_DBL_EPSILON;
              break;
          }
          if (ii > 20)
          {
              result->err = dela;
              break;
          }
          fa1 = fa;
          ii++;
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ii=0; ii<nn; ii++)
  {
      if (ii != 0)
      {
          e2[ii] = tt[3*ii]*tt[3*(ii-1)+2];

          if (e2[ii] < 0.0)
          {
              

              return (nn + ii);
          }

          if (e2[ii] == 0.0 && (tt[3*ii] != 0.0 || tt[3*(ii-1)+2] != 0.0))
          {
              

              return (-1*(3*nn + ii));
          }

          ee[ii] = sqrt(e2[ii]);
      }

      dd[ii] = tt[3*ii+1];
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ii=1; ii<even_order-1; ii++)
  {
      tt[3*ii] = qq;
      tt[3*ii+1] = 4*ii*ii;
      tt[3*ii+2] = qq;
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ii=0; ii<even_order*even_order; ii++)
      zz[ii] = 0.0;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ii=1; ii<even_order-1; ii++)
  {
      zz[ii*even_order+ii-1] = ee[ii];
      zz[ii*even_order+ii] = dd[ii];
      zz[ii*even_order+ii+1] = ee[ii+1];
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ii=0; ii<even_order-extra_values; ii++)
      aa[2*ii] = gsl_vector_get(&eval.vector, ii);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ii=0; ii<odd_order*odd_order; ii++)
      zz[ii] = 0.0;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ii=0; ii<odd_order; ii++)
      for(jj=0; jj<odd_order; jj++)
      {
          if (ii == jj)
              zz[ii*odd_order+jj] = (2*ii + 1)*(2*ii + 1);
          else if (ii == jj + 1 || ii + 1 == jj)
              zz[ii*odd_order+jj] = qq;
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ii=0; ii<odd_order-extra_values; ii++)
      aa[2*ii+1] = gsl_vector_get(&eval.vector, ii);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ii = order_min ; ii <= order_max ; ii++)
    {
      result_array[ii - order_min] = aa[ii];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ii=0; ii<even_order*even_order; ii++)
      zz[ii] = 0.0;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ii=0; ii<even_order; ii++)
      for(jj=0; jj<even_order; jj++)
      {
          if (ii == jj)
              zz[ii*even_order+jj] = 4*(ii + 1)*(ii + 1);
          else if (ii == jj + 1 || ii + 1 == jj)
              zz[ii*even_order+jj] = qq;
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ii=0; ii<even_order-extra_values; ii++)
      bb[2*(ii+1)] = gsl_vector_get(&eval.vector, ii);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ii=0; ii<odd_order*odd_order; ii++)
      zz[ii] = 0.0;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ii=0; ii<odd_order; ii++)
      for(jj=0; jj<odd_order; jj++)
      {
          if (ii == jj)
              zz[ii*odd_order+jj] = (2*ii + 1)*(2*ii + 1);
          else if (ii == jj + 1 || ii + 1 == jj)
              zz[ii*odd_order+jj] = qq;
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ii=0; ii<odd_order-extra_values; ii++)
      bb[2*ii+1] = gsl_vector_get(&eval.vector, ii);  



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ii = order_min ; ii <= order_max ; ii++)
    {
      result_array[ii - order_min] = bb[ii];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k=n; k>0; k--) {
        Jkm1 = 2.0*k/x * Jk - Jkp1;
        Jkp1 = Jk;
        Jk   = Jkm1;
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(n=nmax; n>=nmin; n--) {
      result_array[n-nmin] = 0.0;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(n=nmax; n>=nmin; n--) {
      result_array[n-nmin] = 0.0;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(n=nmax; n>=nmin; n--) {
        result_array[n-nmin] = Jn;
        Jnm1 = -Jnp1 + 2.0*n/x * Jn;
        Jnp1 = Jn;
        Jn   = Jnm1;
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(n=nmax; n>=nmin; n--) {
        result_array[n-nmin] = 0.0;
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k=1; k<=kmax; k++) {
    double ak = (x/(2.0*l+1.0+2.0*k)) * (x/(2.0*l+3.0+2.0*k));
    rhok = -ak*(1.0 + rhok)/(1.0 + ak*(1.0 + rhok));
    tk  *= rhok;
    sum += tk;
    if(fabs(tk/sum) < threshold) break;
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ell = l; ell >= 1; ell--) {
      iellm1 = iellp1 + (2*ell + 1)/x * iell;
      iellp1 = iell;
      iell   = iellm1;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ell = LMAX; ell >= l+1; ell--) {
      iellm1 = iellp1 + (2*ell + 1)/x * iell;
      iellp1 = iell;
      iell   = iellm1;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ell = lmax; ell >= 1; ell--) {
      result_array[ell] = 0.0;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ell = lmax; ell >= 1; ell--) {
      iellm1 = iellp1 + (2*ell + 1)/x * iell;
      iellp1 = iell;
      iell   = iellm1;
      result_array[ell-1] = iellm1;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = cs->order; j>=1; j--) {
    double temp = d;
    d = y2*d - dd + cs->c[j];
    e += fabs(y2*temp) + fabs(dd) + fabs(cs->c[j]);
    dd = temp;
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(n=N; n>0; n--) {
    B_nm1 = 2.0*(2.0*u-1.0) * B_n - B_np1 + c[n-1];
    B_np1 = B_n;
    B_n   = B_nm1;
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k=1; k<=kmax; k++) {
    double nuox = nu*x_inv;
    double Y_nu_save = Y_nu;
    Y_nu  = -Yp_nu + nuox * Y_nu;
    Yp_nu = Y_nu_save - (nuox+x_inv) * Y_nu;
    nu += 1.0;
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(n=1; n<=N; n++) {
      Ynp1 = 2.0*(mu+n)/x * Yn - Ynm1;
      Ynm1 = Yn;
      Yn   = Ynp1;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ell = l; ell > 0; ell--) {
      jellm1 = -jellp1 + (2*ell + 1)/x * jell;
      jellp1 = jell;
      jell   = jellm1;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0; j<=lmax; j++) result_array[j] = 0.0;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=1; j<=lmax; j++) result_array[j] = 0.0;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ell = lmax; ell >= 1; ell--) {
      jellm1 = -jellp1 + (2*ell + 1)/x * jell;
      jellp1 = jell;
      jell   = jellm1;
      result_array[ell-1] = jellm1;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0; j<=lmax; j++) jl_x[j] = 0.0;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=1; j<=lmax; j++) jl_x[j] = 0.0;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(l=0; l<=lmax; l++) {
      jl_x[l]  = x_l * inv_fact;
      jl_x[l] *= 1.0 - 0.5*x*x/(2.0*l+3.0);
      inv_fact /= 2.0*l+3.0;
      x_l      *= x;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(LP = 1; LP<=lmax; LP++) {
        jl_x[L-1] = PL * jl_x[L] + XP2;
        FP = PL*jl_x[L-1] - jl_x[L];
        XP2 = FP;
        PL -= x_inv;
        --L;
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(L=1; L<=lmax; L++) {
        jl_x[L] *= W;
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k=n; k >= 1; k--) {
      Ikm1 = Ikp1 + 2.0*k/ax * Ik;
      Ikp1 = Ik;
      Ik   = Ikm1;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k=nhi; k > n; k--) {
      Ikm1 = Ikp1 + 2.0*k/ax * Ik;
      Ikp1 = Ik;
      Ik   = Ikm1;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0; j<=nmax-nmin; j++) result_array[j] = 0.0;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0; j<=nmax-nmin; j++) result_array[j] = 0.0;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(n=nmax; n>=nmin; n--) {
      result_array[n-nmin] = In;
      Inm1 = Inp1 + n * two_over_x * In;
      Inp1 = In;
      In   = Inm1;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(n=nmin; n<=nmax; n++) {
        if(GSL_IS_ODD(n)) result_array[n-nmin] = -result_array[n-nmin];
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0; j<=nmax-nmin; j++) result_array[j] = 0.0; 



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0; j<=nmax-nmin; j++) result_array[j] *= eax;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = eval_order; j>=1; j--) {
    double temp = d;
    d = y2*d - dd + cs->c[j];
    dd = temp;
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(n=1; n<nmax; n++) {
    term *= x/(a+n);
    sum  += term;
    if(fabs(term/sum) < GSL_DBL_EPSILON) break;
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(n=1; n<nmax; n++) {
    term *= (a-n)/x;
    if(fabs(term/last) > 1.0) break;
    if(fabs(term/sum)  < GSL_DBL_EPSILON) break;
    sum  += term;
    last  = term;
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( n = 2 ; n < nmax ; n++ )
  {
    double an;
    double delta;

    if(GSL_IS_ODD(n))
      an = 0.5*(n-1)/x;
    else
      an = (0.5*n-a)/x;

    Dn = 1.0 + an * Dn;
    if ( fabs(Dn) < small )
      Dn = small;
    Cn = 1.0 + an/Cn;
    if ( fabs(Cn) < small )
      Cn = small;
    Dn = 1.0 / Dn;
    delta = Cn * Dn;
    hn *= delta;
    if(fabs(delta-1.0) < GSL_DBL_EPSILON) break;
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(n=1; n<nmax; n++) {
      t *= -x/(n+1.0);
      sum += (a+1.0)/(a+n+1.0)*t;
      if(fabs(t/sum) < GSL_DBL_EPSILON) break;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k=1; k<maxiter; k++) {
      double ak = (a + k)*x/((b-x+k-1.0)*(b-x+k));
      rhok = -ak*(1.0 + rhok)/(1.0 + ak*(1.0+rhok));
      pk  *= rhok;
      sum += pk;
      if(fabs(pk/sum) < 2.0*GSL_DBL_EPSILON) break;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(n=a; n>0; n--) {
      Mnm1 = (n * Mnp1 - (2*n-b+x) * Mn) / (b-n);
      Mnp1 = Mn;
      Mn   = Mnm1;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(n=a+1; n<b; n++) {
      Mnp1 = ((b-n)*Mnm1 + (2*n-b+x)*Mn)/n;
      Mnm1 = Mn;
      Mn   = Mnp1;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(n=b+1; n<a; n++) {
          Mnp1 = ((b-n)*Mnm1 + (2*n-b+x)*Mn)/n;
          Mnm1 = Mn;
          Mn   = Mnp1;
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(n=1; n<a; n++) {
        Mnp1 = ((b-n)*Mnm1 + (2*n-b+x)*Mn)/n;
        Mnm1 = Mn;
        Mn   = Mnp1;
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(n=a-1; n>b; n--) {
        Manm1 = (-n*(1-n-x)*Man - x*(n-a)*Manp1)/(n*(n-1.0));
        Manp1 = Man;
        Man = Manm1;
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(n=a0-1; n>b; n--) {
          Ma0nm1 = (-n*(1-n-x)*Ma0n - x*(n-a0)*Ma0np1)/(n*(n-1.0));
          Ma0np1 = Ma0n;
          Ma0n = Ma0nm1;
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(n=a0+1; n<a; n++) {
            Mnp1 = ((b-n)*Mnm1 + (2*n-b+x)*Mn)/n;
            Mnm1 = Mn;
            Mn   = Mnp1;
          }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k=N-1; k>=0; k--) {
      double t = (a+k)/(b+k) * (x/(k+1));
      double r = t + 1.0/poly;
      if(r > 0.9*GSL_DBL_MAX/poly) {
        OVERFLOW_ERROR(result);
      }
      else {
        poly *= r;  
      }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(n=a; n>0.5; n -= 1.0) {
      Mnm1 = (n * Mnp1 - (2.0*n-b+x) * Mn) / (b-n);
      Mnp1 = Mn;
      Mn   = Mnm1;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(n=a+1.0; n<b-0.5; n += 1.0) {
      Mnp1 = ((b-n)*Mnm1 + (2*n-b+x)*Mn)/n;
      Mnm1 = Mn;
      Mn   = Mnp1;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ap=b+eps; ap<a-0.1; ap += 1.0) {
        Map1 = ((b-ap)*Mam1 + (2.0*ap-b+x)*Ma)/ap;
        Mam1 = Ma;
        Ma   = Map1;
        minim_pair = GSL_MIN_DBL(fabs(Mam1) + fabs(Ma), minim_pair);
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(n=eps+1.0; n<a-0.1; n++) {
        Mnp1 = ((b-n)*Mnm1 + (2*n-b+x)*Mn)/n;
        Mnm1 = Mn;
        Mn   = Mnp1;
        minim_pair = GSL_MIN_DBL(fabs(Mn) + fabs(Mnm1), minim_pair);
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(n=a+eps-1.0; n>b+0.1; n -= 1.0) {
        Manm1 = (-n*(1-n-x)*Man - x*(n-a)*Manp1)/(n*(n-1.0));
        Manp1 = Man;
        Man = Manm1;
        minim_pair = GSL_MIN_DBL(fabs(Manp1) + fabs(Man), minim_pair);
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(n=a0+epsb-1.0; n>b+0.1; n -= 1.0) {
          Ma0nm1 = (-n*(1-n-x)*Ma0n - x*(n-a0)*Ma0np1)/(n*(n-1.0));
          Ma0np1 = Ma0n;
          Ma0n = Ma0nm1;
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(n=a0+1.0; n<a-0.1; n += 1.0) {
            Mnp1 = ((b-n)*Mnm1 + (2*n-b+x)*Mn)/n;
            Mnm1 = Mn;
            Mn   = Mnp1;
          }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k=0; k<kmax; k++) {
        ans += pow(k + q, -s);
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0; j<=jmax; j++) {
        double delta = hzeta_c[j+1] * scp * pcp;
        ans += delta;
        if(fabs(delta/ans) < 0.5*GSL_DBL_EPSILON) break;
        scp *= (s+2*j+1)*(s+2*j+2);
        pcp /= (kmax + q)*(kmax + q);
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k=1; k<N; k++) {
          term *= (N-k)/x;
          bigGsum += term;
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k=1; k<N; k++) {
        term *= (N-k)/x;
        sum  += term;
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0, xj=x; j<Nd; j++, xj += dx) {
        rk_step(nu, xj, dx, &Jp, &J);
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ii=0; ii<GSL_SF_MATHIEU_COEFF; ii++)
      {
          fn += coeff[ii]*cos(2.0*ii*zz);
          norm += coeff[ii]*coeff[ii];
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ii=0; ii<GSL_SF_MATHIEU_COEFF; ii++)
      {
          fn += coeff[ii]*cos((2.0*ii + 1.0)*zz);
          norm += coeff[ii]*coeff[ii];
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ii=0; ii<GSL_SF_MATHIEU_COEFF; ii++)
      {
          norm += coeff[ii]*coeff[ii];
          fn += coeff[ii]*sin(2.0*(ii + 1)*zz);
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ii=0; ii<GSL_SF_MATHIEU_COEFF; ii++)
      {
          norm += coeff[ii]*coeff[ii];
          fn += coeff[ii]*sin((2.0*ii + 1)*zz);
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ii=0; ii<nmax-nmin+1; ii++)
      result_array[ii] = 0.0;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ii=0, order=nmin; order<=nmax; ii++, order++)
  {
      norm = 0.0;
      even_odd = 0;
      if (order % 2 != 0)
          even_odd = 1;
  
      
      if (qq == 0.0)
      {
          norm = 1.0;
          if (order == 0)
              norm = sqrt(2.0);

          result_array[ii] = cos(order*zz)/norm;

          continue;
      }
  
      
      status = gsl_sf_mathieu_a_coeff(order, qq, aa[order], coeff);
      if (status != GSL_SUCCESS)
          return status;
  
      if (even_odd == 0)
      {
          norm = coeff[0]*coeff[0];
          for(jj=0; jj<GSL_SF_MATHIEU_COEFF; jj++)
          {
              result_array[ii] += coeff[jj]*cos(2.0*jj*zz);
              norm += coeff[jj]*coeff[jj];
          }
      }
      else
      {
          for(jj=0; jj<GSL_SF_MATHIEU_COEFF; jj++)
          {
              result_array[ii] += coeff[jj]*cos((2.0*jj + 1.0)*zz);
              norm += coeff[jj]*coeff[jj];
          }
      }
  
      norm = sqrt(norm);
      result_array[ii] /= norm;
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ii=0; ii<nmax-nmin+1; ii++)
      result_array[ii] = 0.0;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ii=0, order=nmin; order<=nmax; ii++, order++)
  {
      norm = 0.0;
      even_odd = 0;
      if (order % 2 != 0)
          even_odd = 1;
  
      
      if (qq == 0.0)
      {
          norm = 1.0;
          result_array[ii] = sin(order*zz);

          continue;
      }
  
      
      status = gsl_sf_mathieu_b_coeff(order, qq, bb[order], coeff);
      if (status != GSL_SUCCESS)
      {
          return status;
      }
  
      if (even_odd == 0)
      {
          for(jj=0; jj<GSL_SF_MATHIEU_COEFF; jj++)
          {
              result_array[ii] += coeff[jj]*sin(2.0*(jj + 1)*zz);
              norm += coeff[jj]*coeff[jj];
          }
      }
      else
      {
          for(jj=0; jj<GSL_SF_MATHIEU_COEFF; jj++)
          {
              result_array[ii] += coeff[jj]*sin((2.0*jj + 1.0)*zz);
              norm += coeff[jj]*coeff[jj];
          }
      }
  
      norm = sqrt(norm);
      result_array[ii] /= norm;
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=1; i<lmax; i++) {
      t_coeff /= i*(2*(i-l) - 1);
      t_power *= t;
      delta = t_power*t_coeff;
      sum += delta;
      if(fabs(delta/sum) < GSL_DBL_EPSILON) break;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=1; j<l; j++) { 
      bkp = (2*j+1)/x*bk + bkm;
      bkm = bk;
      bk  = bkp;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ell = 1; ell < lmax; ell++) {
      kellp1 = (2*ell+1)/x * kell + kellm1;
      result_array[ell+1] = kellp1;
      kellm1 = kell;
      kell   = kellp1;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k=n-1; k>=0; k--) {
    double t = (-n+k)/(a+1.0+k) * (x/(k+1));
    double r = t + 1.0/poly_1F1_val;
    if(r > 0.9*GSL_DBL_MAX/poly_1F1_val) {
      
      INTERNAL_OVERFLOW_ERROR(result);
    }
    else {
      
      poly_1F1_val  = 1.0 + t * poly_1F1_val;
      poly_1F1_err += GSL_DBL_EPSILON + fabs(t) * poly_1F1_err;
    }
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k=n-1; k>=0; k--) {
      term *= ((b+k)/(n-k))*(k+1.0)/mx;
      sum_val += term;
      sum_err += 4.0 * GSL_DBL_EPSILON * fabs(term);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k=2; k<=n; k++) {
      product *= (a + k)/k;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k=2; k<n; k++) {
      Lkp1 = (-(k+a)*Lkm1 + (2.0*k+a+1.0-x)*Lk)/(k+1.0);
      Lkm1 = Lk;
      Lk   = Lkp1;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=nexp; i>=1; i--) {
      sum *= ex;
      sum += (1.0 + 1.0/xk)/rk;
      rk -= 1.0;
      xk -= x;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=nexp; i>=1; i--) {
      sum *= ex;
      sum += (1.0 + 2.0/xk + 2.0/(xk*xk)) / rk;
      rk -= 1.0;
      xk -= x;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=nexp; i>=1; i--) {
      double xk_inv = 1.0/xk;
      sum *= ex;
      sum += (((6.0*xk_inv + 6.0)*xk_inv + 3.0)*xk_inv + 1.0) / rk;
      rk -= 1.0;
      xk -= x;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=nexp; i>=1; i--) {
      double xk_inv = 1.0/xk;
      sum *= ex;
      sum += ((((24.0*xk_inv + 24.0)*xk_inv + 12.0)*xk_inv + 4.0)*xk_inv + 1.0) / rk;
      rk -= 1.0;
      xk -= x;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=nexp; i>=1; i--) {
      double xk_inv = 1.0/xk;
      sum *= ex;
      sum += (((((120.0*xk_inv + 120.0)*xk_inv + 60.0)*xk_inv + 20.0)*xk_inv + 5.0)*xk_inv+ 1.0) / rk;
      rk -= 1.0;
      xk -= x;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=nexp; i>=1; i--) {
      double xk_inv = 1.0/xk;
      sum *= ex;
      sum += ((((((720.0*xk_inv + 720.0)*xk_inv + 360.0)*xk_inv + 120.0)*xk_inv + 30.0)*xk_inv+ 6.0)*xk_inv+ 1.0) / rk;
      rk -= 1.0;
      xk -= x;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = kmin; k <= kmax; k++) {
      status += gsl_sf_choose_e (jcc, k, &bc1);
      status += gsl_sf_choose_e (jcb, jmma - k, &bc2);
      status += gsl_sf_choose_e (jca, jpmb - k, &bc3);
      
      if (status != 0) {
        OVERFLOW_ERROR (result);
      }
      
      term = bc1.val * bc2.val * bc3.val;
      
      if (sign < 0) {
        sum_neg += norm * term;
      } else {
        sum_pos += norm * term;
      }
      
      sign = -sign;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(tk=tkmin; tk<=tkmax; tk += 2) {
      double term;
      double term_err;
      gsl_sf_result den_1, den_2;
      gsl_sf_result d1_a, d1_b;
      status = 0;

      status += gsl_sf_fact_e((two_ja + two_jb + two_je + two_jd - tk)/2 + 1, &n1);
      status += gsl_sf_fact_e(tk/2, &d1_a);
      status += gsl_sf_fact_e((two_jc + two_jf - two_ja - two_jd + tk)/2, &d1_b);
      status += gsl_sf_fact_e((two_jc + two_jf - two_jb - two_je + tk)/2, &d2);
      status += gsl_sf_fact_e((two_ja + two_jb - two_jc - tk)/2, &d3);
      status += gsl_sf_fact_e((two_je + two_jd - two_jc - tk)/2, &d4);
      status += gsl_sf_fact_e((two_ja + two_je - two_jf - tk)/2, &d5);
      status += gsl_sf_fact_e((two_jb + two_jd - two_jf - tk)/2, &d6);

      if(status != GSL_SUCCESS) {
        OVERFLOW_ERROR(result);
      }

      d1.val = d1_a.val * d1_b.val;
      d1.err = d1_a.err * fabs(d1_b.val) + fabs(d1_a.val) * d1_b.err;

      den_1.val  = d1.val*d2.val*d3.val;
      den_1.err  = d1.err * fabs(d2.val*d3.val);
      den_1.err += d2.err * fabs(d1.val*d3.val);
      den_1.err += d3.err * fabs(d1.val*d2.val);

      den_2.val  = d4.val*d5.val*d6.val;
      den_2.err  = d4.err * fabs(d5.val*d6.val);
      den_2.err += d5.err * fabs(d4.val*d6.val);
      den_2.err += d6.err * fabs(d4.val*d5.val);

      term  = phase * n1.val / den_1.val / den_2.val;
      phase = -phase;
      term_err  = n1.err / fabs(den_1.val) / fabs(den_2.val);
      term_err += fabs(term / den_1.val) * den_1.err;
      term_err += fabs(term / den_2.val) * den_2.err;

      if(term >= 0.0) {
        sum_pos += norm*term;
      }
      else {
        sum_neg -= norm*term;
      }

      sumsq_err += norm*norm * term_err*term_err;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(tk=tkmin; tk<=tkmax; tk += 2) {
      gsl_sf_result s1, s2, s3;
      double term;
      double term_err;
      int status = 0;

      status += gsl_sf_coupling_6j_e(two_ja, two_ji, tk,  two_jh, two_jd, two_jg,  &s1);
      status += gsl_sf_coupling_6j_e(two_jb, two_jf, tk,  two_jd, two_jh, two_je,  &s2);
      status += gsl_sf_coupling_6j_e(two_ja, two_ji, tk,  two_jf, two_jb, two_jc,  &s3);

      if(status != GSL_SUCCESS) {
        OVERFLOW_ERROR(result);
      }
      term = s1.val * s2.val * s3.val;
      term_err  = s1.err * fabs(s2.val*s3.val);
      term_err += s2.err * fabs(s1.val*s3.val);
      term_err += s3.err * fabs(s1.val*s2.val);

      if(term >= 0.0) {
        sum_pos += (tk + 1) * term;
      }
      else {
        sum_neg -= (tk + 1) * term;
      }

      sumsq_err += ((tk+1) * term_err) * ((tk+1) * term_err);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(n = 0; n < N; n++)
      {
        double np1 = n + 1.0;
        t[n] = 1.0 / (np1 * np1);
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(n = 1; n < N; n++)
      {
        t[n] = t[n - 1] * (x / n);
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(n = 1; n < N; n++)
      {
        t[n] = t[n - 1] * (x / n);
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(n = 1; n < N; n++)
      {
        t[n] = t[n - 1] * (x * n) / (n + 1.0);
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(n = 1; n < N; n++)
      {
        t[n] = t[n - 1] * (x * n) / (n + 1.0);
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(n = 1; n < N; n++)
      {
        t[n] = -t[n - 1] * (4.0 * (n + 1.0) - 1.0) / (M_PI * M_PI);
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(n = 1; n < N; n++)
      {
        t[n] = 1/(n+1.0) + log(n/(n+1.0));
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(n = 0; n < N; n++)
      {
        t[n] = (n%2 ? -1 : 1) * 1.0 /sqrt(n + 1.0);
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(n = 0; n < min_terms; n++)
        {
          const double t = array[n];
          result_nm1 = result_n;
          gsl_sum_levin_u_step (t, n, nmax, w, &result_n);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
        {
          double dn = w->dsum[i] * GSL_MACH_EPS * array[i];
          variance += dn * dn;
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(; n <= nmax; n++)
        {
          const double t = array[n];

          result_nm1 = result_n;
          gsl_sum_levin_u_step (t, n, nmax, w, &result_n);

          

          actual_trunc_nm1 = actual_trunc_n;
          actual_trunc_n = fabs (result_n - result_nm1);

          


          trunc_nm1 = trunc_n;
          trunc_n = 0.5 * (actual_trunc_n + actual_trunc_nm1);

          noise_nm1 = noise_n;
          variance = 0;

          for(i = 0; i <= n; i++)
            {
              double dn = w->dsum[i] * GSL_MACH_EPS * array[i];
              variance += dn * dn;
            }

          noise_n = sqrt (variance);

          

          better = (trunc_n < trunc_nm1 || trunc_n < SMALL * fabs (result_n));
          converging = converging || (better && before);
          before = better;

          if (converging)
            {
              if (trunc_n < least_trunc)
                {
                  


                  least_trunc_result = result_n;
                  least_trunc = trunc_n;
                  least_trunc_noise = noise_n;
                }

              if (noise_n > trunc_n / 3.0)
                break;

              if (trunc_n < 10.0 * GSL_MACH_EPS * fabs (result_n))
                break;
            }

        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
        {
          w->dq_den[I (i, n)] = 0;
          w->dq_num[I (i, n)] = w->q_den[n];
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = n - 1; j >= 0; j--)
        {
          double c = factor * (j + 1) / (n + 1);
          factor *= ratio;
          w->q_den[j] = w->q_den[j + 1] - c * w->q_den[j];
          w->q_num[j] = w->q_num[j + 1] - c * w->q_num[j];

          for(i = 0; i < n; i++)
            {
              w->dq_den[I (i, j)] =
                w->dq_den[I (i, j + 1)] - c * w->dq_den[I (i, j)];
              w->dq_num[I (i, j)] =
                w->dq_num[I (i, j + 1)] - c * w->dq_num[I (i, j)];
            }

          w->dq_den[I (n, j)] = w->dq_den[I (n, j + 1)];
          w->dq_num[I (n, j)] = w->dq_num[I (n, j + 1)];
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i <= n; i++)
        {
          w->dsum[i] =
            (w->dq_num[I (i, 0)] -
             result * w->dq_den[I (i, 0)]) / w->q_den[0];
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(n = 0; n < min_terms; n++)
        {
          const double t = array[n];

          result_nm1 = result_n;
          gsl_sum_levin_utrunc_step (t, n, w, &result_n);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(; n <= nmax; n++)
        {
          const double t = array[n];

          result_nm1 = result_n;
          gsl_sum_levin_utrunc_step (t, n, w, &result_n);

          

          actual_trunc_nm1 = actual_trunc_n;
          actual_trunc_n = fabs (result_n - result_nm1);

          


          trunc_nm1 = trunc_n;
          trunc_n = 0.5 * (actual_trunc_n + actual_trunc_nm1);

          

          better = (trunc_n < trunc_nm1 || trunc_n < SMALL * fabs (result_n));
          converging = converging || (better && before);
          before = better;

          if (converging)
            {
              if (trunc_n < least_trunc)
                {
                  


                  least_trunc = trunc_n;
                  result_least_trunc = result_n;
                }

              if (fabs (trunc_n / result_n) < 10.0 * GSL_MACH_EPS)
                break;
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = n - 1; j >= 0; j--)
        {
          double c = factor * (j + 1) / (n + 1);
          factor *= ratio;
          w->q_den[j] = w->q_den[j + 1] - c * w->q_den[j];
          w->q_num[j] = w->q_num[j + 1] - c * w->q_num[j];
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < params.iters_fixed_T; ++i) {
      if (copyfunc) {
        copyfunc(x, new_x);
      } else {
        memcpy (new_x, x, element_size);
      }

      take_step (r, new_x, params.step_size);
      new_E = Ef (new_x);

      if(new_E <= best_E){
        if (copyfunc) {
          copyfunc(new_x,best_x);
        } else {
          memcpy (best_x, new_x, element_size);
        }
        best_E=new_E;
      }

      ++n_evals;                
      

      if (new_E < E) {
        
        if (copyfunc) {
          copyfunc(new_x, x);
        } else {
          memcpy (x, new_x, element_size);
        }
        E = new_E;
        ++n_eless;
      } else if (gsl_rng_uniform(r) < safe_exp (-(new_E - E)/(params.k * T)) ) {
        
        if (copyfunc) {
          copyfunc(new_x, x);
        } else {
          memcpy(x, new_x, element_size);
        }
        E = new_E;
        ++n_accepts;
      } else {
        ++n_rejects;
      }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < params.n_tries - 1; ++i)
        {                       
          
          sum_probs[i] = 0;
          memcpy ((char *)new_x + i * element_size, x, element_size);
          take_step (r, (char *)new_x + i * element_size, params.step_size);
          energies[i] = Ef ((char *)new_x + i * element_size);
          probs[i] = safe_exp (-(energies[i] - Ex) / (params.k * T));
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i < params.n_tries; ++i)
        {
          sum_probs[i] = sum_probs[i - 1] + probs[i];
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < params.n_tries; ++i)
        {
          if (u < sum_probs[i])
            {
              memcpy (x, (char *)new_x + i * element_size, element_size);
              break;
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N_CITIES; ++i) {
    

    E += distance_matrix[route[i]][route[(i + 1) % N_CITIES]];
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N_CITIES; ++i) {
    distance += ((route1[i] == route2[i]) ? 0 : 1);
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N_CITIES; ++i) {
    printf(" %d ", route[i]);
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N_CITIES; ++i) {
    printf("# \"%s\"\n", cities[i].name);
    x_initial[i] = i;
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N_CITIES+1; ++i) {
    printf("###initial_city_coord: %g %g \"%s\"\n",
           -cities[x_initial[i % N_CITIES]].longitude,
           cities[x_initial[i % N_CITIES]].lat,
           cities[x_initial[i % N_CITIES]].name);
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N_CITIES; ++i) {
    printf("# \"%s\"\n", cities[x_initial[i]].name);
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N_CITIES+1; ++i) {
    printf("###final_city_coord: %g %g %s\n",
           -cities[x_initial[i % N_CITIES]].longitude,
           cities[x_initial[i % N_CITIES]].lat,
           cities[x_initial[i % N_CITIES]].name);
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N_CITIES; ++i) {
    for(j = 0; j < N_CITIES; ++j) {
      if (i == j) {
        dist = 0;
      } else {
        dist = city_distance(cities[i], cities[j]);
      }
      distance_matrix[i][j] = dist;
    }
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N_CITIES; ++i) {
    printf("# ");
    for(j = 0; j < N_CITIES; ++j) {
      printf("%15.8f   ", distance_matrix[i][j]);
    }
    printf("\n");
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = n; j < N_CITIES; ++j) {
      swap_tmp = new_route[j];
      new_route[j] = new_route[n];
      new_route[n] = swap_tmp;
      do_all_perms(new_route, n+1);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0 ; i < p; i++)
        {
          gsl_test_rel (gsl_vector_get (s->x, i), X[p*iter+i], 1e-5, 
                        "lmsder, iter=%u, x%u", iter, i);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 4; i++) 
      {
        for(j = 0; j < 4; j++)
          {
            gsl_test_rel (gsl_matrix_get(covar,i,j), cov[i*p + j], 1e-7, 
                          "gsl_multifit_covar cov(%d,%d)", i, j) ;
          }
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0 ; i < p; i++)
      {
        gsl_test_rel (gsl_vector_get (s->x, i), x_final[i], 1e-5, 
                      "%s, lmsder, x%u", name, i);
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < p; i++) 
        {
          double ei = sqrt(s2/(n-p))*sqrt(gsl_matrix_get(covar,i,i));
          gsl_test_rel (ei, sigma[i], 1e-4, 
                        "%s, sigma(%d)", name, i) ;
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0 ; i < pontius_n; i++) 
      {
        for(j = 0; j < pontius_p; j++) 
          {
            gsl_matrix_set(X, i, j, pow(pontius_x[i], j));
          }
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0 ; i < pontius_n; i++) 
      {
        for(j = 0; j < pontius_p; j++) 
          {
            gsl_matrix_set(X, i, j, pow(pontius_x[i], j));
          }
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < pontius_p; i++) 
      {
        for(j = 0; j < pontius_p; j++)
          {
            gsl_test_rel (gsl_matrix_get(cov,i,j), expected_cov[i][j], 1e-10, 
                          "pontius gsl_fit_wmultilinear cov(%d,%d)", i, j) ;
          }
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 20; i++)
    {
      double ti = 0.2 * (i + 1);
      double ui = x0 + x1 * ti - exp (ti);
      double vi = x2 + x3 * sin (ti) - cos (ti);

      gsl_vector_set (f, i, ui * ui + vi * vi);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 20; i++)
    {
      double ti = 0.2 * (i + 1);
      double ui = x0 + x1 * ti - exp (ti);
      double vi = x2 + x3 * sin (ti) - cos (ti);

      gsl_matrix_set (df, i, 0, 2 * ui);
      gsl_matrix_set (df, i, 1, 2 * ui * ti);
      gsl_matrix_set (df, i, 2, 2 * vi);
      gsl_matrix_set (df, i, 3, 2 * vi * sin (ti));

    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0 ; i < n ; i++)
    {
      double xi = gsl_vector_get(x,i);
      double dxi = gsl_vector_get(dx,i);
      double tolerance = epsabs + epsrel * fabs(xi)  ;

      if (fabs(dxi) < tolerance)
        {
          ok = 1;
        }
      else
        {
          ok = 0;
          break;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0 ; i < n ; i++)
    {
      double gi = gsl_vector_get(g, i);
      
      residual += fabs(gi);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < n; j++)
    {
      double rjj = gsl_matrix_get (r, j, j);
      double qtbj = gsl_vector_get (qtb, j);

      for(i = j + 1; i < n; i++)
        {
          double rji = gsl_matrix_get (r, j, i);
          gsl_matrix_set (r, i, j, rji);
        }

      gsl_vector_set (x, j, rjj);
      gsl_vector_set (wa, j, qtbj);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < n; j++)
    {
      double qtbpj;

      size_t pj = gsl_permutation_get (p, j);

      double diagpj = lambda * gsl_vector_get (diag, pj);

      if (diagpj == 0)
        {
          continue;
        }

      gsl_vector_set (sdiag, j, diagpj);

      for(k = j + 1; k < n; k++)
        {
          gsl_vector_set (sdiag, k, 0.0);
        }

      



      qtbpj = 0;

      for(k = j; k < n; k++)
        {
          


          double sine, cosine;

          double wak = gsl_vector_get (wa, k);
          double rkk = gsl_matrix_get (r, k, k);
          double sdiagk = gsl_vector_get (sdiag, k);

          if (sdiagk == 0)
            {
              continue;
            }

          if (fabs (rkk) < fabs (sdiagk))
            {
              double cotangent = rkk / sdiagk;
              sine = 0.5 / sqrt (0.25 + 0.25 * cotangent * cotangent);
              cosine = sine * cotangent;
            }
          else
            {
              double tangent = sdiagk / rkk;
              cosine = 0.5 / sqrt (0.25 + 0.25 * tangent * tangent);
              sine = cosine * tangent;
            }

          


          {
            double new_rkk = cosine * rkk + sine * sdiagk;
            double new_wak = cosine * wak + sine * qtbpj;
            
            qtbpj = -sine * wak + cosine * qtbpj;

            gsl_matrix_set(r, k, k, new_rkk);
            gsl_vector_set(wa, k, new_wak);
          }

          

          for(i = k + 1; i < n; i++)
            {
              double rik = gsl_matrix_get (r, i, k);
              double sdiagi = gsl_vector_get (sdiag, i);
              
              double new_rik = cosine * rik + sine * sdiagi;
              double new_sdiagi = -sine * rik + cosine * sdiagi;
              
              gsl_matrix_set(r, i, k, new_rik);
              gsl_vector_set(sdiag, i, new_sdiagi);
            }
        }

      


      {
        double rjj = gsl_matrix_get (r, j, j);
        double xj = gsl_vector_get(x, j);
        
        gsl_vector_set (sdiag, j, rjj);
        gsl_matrix_set (r, j, j, xj);
      }

    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < n; j++)
    {
      double sdiagj = gsl_vector_get (sdiag, j);

      if (sdiagj == 0)
        {
          nsing = j;
          break;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = nsing; j < n; j++)
    {
      gsl_vector_set (wa, j, 0.0);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 0; k < nsing; k++)
    {
      double sum = 0;

      j = (nsing - 1) - k;

      for(i = j + 1; i < nsing; i++)
        {
          sum += gsl_matrix_get(r, i, j) * gsl_vector_get(wa, i);
        }

      {
        double waj = gsl_vector_get (wa, j);
        double sdiagj = gsl_vector_get (sdiag, j);

        gsl_vector_set (wa, j, (waj - sum) / sdiagj);
      }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < n; j++)
    {
      size_t pj = gsl_permutation_get (p, j);
      double waj = gsl_vector_get (wa, j);

      gsl_vector_set (x, pj, waj);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
    {
      double fi = gsl_vector_get (f, i);
      double di = gsl_vector_get (d, i);
      double u = di * fi;
      e2 += u * u;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < p; j++)
    {
      double sum = 0;

      for(i = 0; i < n; i++)
        {
          double Jij = gsl_matrix_get (J, i, j);
          sum += Jij * Jij;
        }
      if (sum == 0)
        sum = 1.0;

      gsl_vector_set (diag, j, sqrt (sum));
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < n; j++)
    {
      double cnorm, diagj, sum = 0;
      for(i = 0; i < n; i++)
        {
          double Jij = gsl_matrix_get (J, i, j);
          sum += Jij * Jij;
        }
      if (sum == 0)
        sum = 1.0;

      cnorm = sqrt (sum);
      diagj = gsl_vector_get (diag, j);

      if (cnorm > diagj)
        gsl_vector_set (diag, j, cnorm);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
    {
      double sum = 0;

      for(j = i; j < N; j++)
        {
          size_t pj = gsl_permutation_get (p, j);

          sum += gsl_matrix_get (r, i, j) * gsl_vector_get (dx, pj);
        }

      gsl_vector_set (rptdx, i, sum);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
    {
      double pi = gsl_vector_get (dx, i);
      double xi = gsl_vector_get (x, i);
      gsl_vector_set (x_trial, i, xi + pi);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 5; i++)
    {
      b[i] = gsl_vector_get(x, i);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 151; i++)
    {
      double x = kirby2_F0[i];
      double y = ((b[0] + x* (b[1]  + x * b[2]))
                  / (1 + x*(b[3]  + x *b[4])));
      gsl_vector_set (f, i, kirby2_F1[i] - y);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 5; i++)
    {
      b[i] = gsl_vector_get(x, i);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 151; i++)
    {
      double x = kirby2_F0[i];
      double u = (b[0] + x*(b[1] + x*b[2]));
      double v = (1 + x*(b[3] + x*b[4]));
      gsl_matrix_set (df, i, 0, -1/v);
      gsl_matrix_set (df, i, 1, -x/v);
      gsl_matrix_set (df, i, 2, -x*x/v);
      gsl_matrix_set (df, i, 3, x*u/(v*v));
      gsl_matrix_set (df, i, 4, x*x*u/(v*v));
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++)
    {
      b[i] = gsl_vector_get(x, i);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 128; i++)
    {
      double x1 = nelson_F[i][1];
      double x2 = nelson_F[i][2];

      double y = b[0] - b[1] * x1 * (b[2]*x2 < -100) ? 0.0 : exp(-b[2] * x2);

      gsl_vector_set (f, i, log(nelson_F[i][0]) - y);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++)
    {
      b[i] = gsl_vector_get(x, i);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 128; i++)
    {
      double x1 = nelson_F[i][1];
      double x2 = nelson_F[i][2];

      gsl_matrix_set (df, i, 0, -1.0);
      gsl_matrix_set (df, i, 1, x1 * exp(-b[2] * x2));
      gsl_matrix_set (df, i, 2, -b[1] * x1 * x2 * exp(-b[2] * x2));
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 0 ; k < n ; k++)
    {
      double rkk = gsl_matrix_get(r, k, k);

      if (fabs(rkk) <= tolr)
        {
          break;
        }

      gsl_matrix_set(r, k, k, 1.0/rkk);

      for(j = 0; j < k ; j++)
        {
          double t = gsl_matrix_get(r, j, k) / rkk;
          gsl_matrix_set (r, j, k, 0.0);

          for(i = 0; i <= j; i++)
            {
              double rik = gsl_matrix_get (r, i, k);
              double rij = gsl_matrix_get (r, i, j);
              
              gsl_matrix_set (r, i, k, rik - t * rij);
            }
        }
      kmax = k;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 0; k <= kmax ; k++)
    {
      for(j = 0; j < k; j++)
        {
          double rjk = gsl_matrix_get (r, j, k);

          for(i = 0; i <= j ; i++)
            {
              double rij = gsl_matrix_get (r, i, j);
              double rik = gsl_matrix_get (r, i, k);

              gsl_matrix_set (r, i, j, rij + rjk * rik);
            }
        }
      
      {
        double t = gsl_matrix_get (r, k, k);

        for(i = 0; i <= k; i++)
          {
            double rik = gsl_matrix_get (r, i, k);

            gsl_matrix_set (r, i, k, t * rik);
          };
      }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0 ; j < n ; j++)
    {
      size_t pj = gsl_permutation_get (perm, j);
      
      for(i = 0; i <= j; i++)
        {
          size_t pi = gsl_permutation_get (perm, i);

          double rij;

          if (j > kmax)
            {
              gsl_matrix_set (r, i, j, 0.0);
              rij = 0.0 ;
            }
          else 
            {
              rij = gsl_matrix_get (r, i, j);
            }

          if (pi > pj)
            {
              gsl_matrix_set (r, pi, pj, rij); 
            } 
          else if (pi < pj)
            {
              gsl_matrix_set (r, pj, pi, rij);
            }

        }
      
      { 
        double rjj = gsl_matrix_get (r, j, j);
        gsl_matrix_set (covar, pj, pj, rjj);
      }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0 ; j < n ; j++)
    {
      for(i = 0; i < j ; i++)
        {
          double rji = gsl_matrix_get (r, j, i);

          gsl_matrix_set (covar, j, i, rji);
          gsl_matrix_set (covar, i, j, rji);
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0 ; i < filip_n; i++) 
      {
        for(j = 0; j < filip_p; j++) 
          {
            gsl_matrix_set(X, i, j, pow(filip_x[i], j));
          }
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0 ; i < filip_n; i++) 
      {
        for(j = 0; j < filip_p; j++) 
          {
            gsl_matrix_set(X, i, j, pow(filip_x[i], j));
          }
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < filip_p; i++) 
      {
        for(j = 0; j < filip_p; j++)
          {
            gsl_test_rel (gsl_matrix_get(cov,i,j), expected_cov[i][j], 1e-6,
                          "filip gsl_fit_wmultilinear cov(%d,%d)", i, j) ;
          }
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < p; j++)
          {
            gsl_vector_view column = gsl_matrix_column (QSI, j);
            double alpha = gsl_vector_get (S, j);

            if (alpha <= tol * alpha0) {
              alpha = 0.0;
            } else {
              alpha = 1.0 / alpha;
              p_eff++;
            }

            gsl_vector_scale (&column.vector, alpha);
          }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
          {
            double yi = gsl_vector_get (y, i);
            gsl_vector_const_view row = gsl_matrix_const_row (X, i);
            double y_est, ri;
            gsl_blas_ddot (&row.vector, c, &y_est);
            ri = yi - y_est;
            r2 += ri * ri;
          }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < p; i++)
          {
            gsl_vector_view row_i = gsl_matrix_row (QSI, i);
            double d_i = gsl_vector_get (D, i);

            for(j = i; j < p; j++)
              {
                gsl_vector_view row_j = gsl_matrix_row (QSI, j);
                double d_j = gsl_vector_get (D, j);
                double s;

                gsl_blas_ddot (&row_i.vector, &row_j.vector, &s);

                gsl_matrix_set (cov, i, j, s * s2 / (d_i * d_j));
                gsl_matrix_set (cov, j, i, s * s2 / (d_i * d_j));
              }
          }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
        {
          double wi = gsl_vector_get (w, i);

          if (wi < 0)
            wi = 0;

          {
            gsl_vector_view row = gsl_matrix_row (A, i);
            gsl_vector_scale (&row.vector, sqrt (wi));
          }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
        {
          double wi = gsl_vector_get (w, i);
          double yi = gsl_vector_get (y, i);
          if (wi < 0)
            wi = 0;
          gsl_vector_set (t, i, sqrt (wi) * yi);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < p; j++)
          {
            gsl_vector_view column = gsl_matrix_column (QSI, j);
            double alpha = gsl_vector_get (S, j);

            if (alpha <= tol * alpha0) {
              alpha = 0.0;
            } else {
              alpha = 1.0 / alpha;
              p_eff++;
            }

            gsl_vector_scale (&column.vector, alpha);
          }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < p; i++)
        {
          gsl_vector_view row_i = gsl_matrix_row (QSI, i);
          double d_i = gsl_vector_get (D, i);

          for(j = i; j < p; j++)
            {
              gsl_vector_view row_j = gsl_matrix_row (QSI, j);
              double d_j = gsl_vector_get (D, j);
              double s;

              gsl_blas_ddot (&row_i.vector, &row_j.vector, &s);

              gsl_matrix_set (cov, i, j, s / (d_i * d_j));
              gsl_matrix_set (cov, j, i, s / (d_i * d_j));
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
          {
            double yi = gsl_vector_get (y, i);
            double wi = gsl_vector_get (w, i);
            gsl_vector_const_view row = gsl_matrix_const_row (X, i);
            double y_est, ri;
            gsl_blas_ddot (&row.vector, c, &y_est);
            ri = yi - y_est;
            r2 += wi * ri * ri;
          }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < x->size; i++)
        {
          const double xi = gsl_vector_get (x, i);
          var += xi * xi * gsl_matrix_get (cov, i, i);

          for(j = 0; j < i; j++)
            {
              const double xj = gsl_vector_get (x, j);
              var += 2 * xi * xj * gsl_matrix_get (cov, i, j);
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 7; i++)
    {
      b[i] = gsl_vector_get(x, i);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 236; i++)
    {
      double x = hahn1_F0[i];
      double y = ((b[0] + x* (b[1]  + x * (b[2] + x * b[3])))
                  / (1 + x*(b[4]  + x *(b[5] + x*b[6]))));
      gsl_vector_set (f, i, hahn1_F1[i] - y);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 7; i++)
    {
      b[i] = gsl_vector_get(x, i);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 236; i++)
    {
      double x = hahn1_F0[i];
      double u = (b[0] + x*(b[1] + x*(b[2] + x * b[3])));
      double v = (1 + x*(b[4] + x*(b[5] + x*b[6])));
      gsl_matrix_set (df, i, 0, -1/v);
      gsl_matrix_set (df, i, 1, -x/v);
      gsl_matrix_set (df, i, 2, -x*x/v);
      gsl_matrix_set (df, i, 3, -x*x*x/v);
      gsl_matrix_set (df, i, 4, x*u/(v*v));
      gsl_matrix_set (df, i, 5, x*x*u/(v*v));
      gsl_matrix_set (df, i, 6, x*x*x*u/(v*v));
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
    {
      double rii = gsl_matrix_get (r, i, i);

      if (rii == 0)
        {
          break;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0 ; i < n ; i++)
    {
      double qtfi = gsl_vector_get (qtf, i);
      gsl_vector_set (x, i,  qtfi);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = nsing; i < n; i++)
    {
      gsl_vector_set (x, i, 0.0);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = nsing; j > 0 && j--;)
        {
          double rjj = gsl_matrix_get (r, j, j);
          double temp = gsl_vector_get (x, j) / rjj;
          
          gsl_vector_set (x, j, temp);
          
          for(i = 0; i < j; i++)
            {
              double rij = gsl_matrix_get (r, i, j);
              double xi = gsl_vector_get (x, i);
              gsl_vector_set (x, i, xi - rij * temp);
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
    {
      size_t pi = gsl_permutation_get (p, i);

      double dpi = gsl_vector_get (diag, pi);
      double xpi = gsl_vector_get (x, pi);

      gsl_vector_set (w, i, dpi * (dpi * xpi) / dxnorm);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < n; j++)
    {
      double sj = gsl_vector_get (sdiag, j);
      double wj = gsl_vector_get (w, j);

      double tj = wj / sj;

      gsl_vector_set (w, j, tj);

      for(i = j + 1; i < n; i++)
        {
          double rij = gsl_matrix_get (r, i, j);
          double wi = gsl_vector_get (w, i);

          gsl_vector_set (w, i, wi - rij * tj);
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
    {
      size_t pi = gsl_permutation_get (perm, i);

      double dpi = gsl_vector_get (diag, pi);
      double xpi = gsl_vector_get (x, pi);

      gsl_vector_set (w, i, dpi * (dpi * xpi / dxnorm));
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < n; j++)
    {
      double sum = 0;

      for(i = 0; i < j; i++)
        {
          sum += gsl_matrix_get (r, i, j) * gsl_vector_get (w, i);
        }

      {
        double rjj = gsl_matrix_get (r, j, j);
        double wj = gsl_vector_get (w, j);

        gsl_vector_set (w, j, (wj - sum) / rjj);
      }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < n; j++)
    {
      double sum = 0;

      for(i = 0; i <= j; i++)
        {
          sum += gsl_matrix_get (r, i, j) * gsl_vector_get (qtf, i);
        }

      {
        size_t pj = gsl_permutation_get (p, j);
        double dpj = gsl_vector_get (diag, pj);

        gsl_vector_set (g, j, sum / dpj);
      }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < longley_p; i++) 
      {
        for(j = 0; j < longley_p; j++)
          {
            gsl_test_rel (gsl_matrix_get(cov,i,j), expected_cov[i][j], 1e-7, 
                          "longley gsl_fit_wmultilinear cov(%d,%d)", i, j) ;
          }
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 9; i++)
    {
      b[i] = gsl_vector_get(x, i);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 168; i++)
    {
      double t = (i + 1.0);
      double y;
      y = b[0];
      y += b[1] * cos(2*M_PI*t/12);
      y += b[2] * sin(2*M_PI*t/12);
      y += b[4] * cos(2*M_PI*t/b[3]);
      y += b[5] * sin(2*M_PI*t/b[3]);
      y += b[7] * cos(2*M_PI*t/b[6]);
      y += b[8] * sin(2*M_PI*t/b[6]);

      gsl_vector_set (f, i, enso_F[i] - y);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 9; i++)
    {
      b[i] = gsl_vector_get(x, i);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 168; i++)
    {
      double t = (i + 1.0);

      gsl_matrix_set (df, i, 0, -1.0);
      gsl_matrix_set (df, i, 1, -cos(2*M_PI*t/12));
      gsl_matrix_set (df, i, 2, -sin(2*M_PI*t/12));
      gsl_matrix_set (df, i, 3, 
                      -b[4]*(2*M_PI*t/(b[3]*b[3]))*sin(2*M_PI*t/b[3])
                      +b[5]*(2*M_PI*t/(b[3]*b[3]))*cos(2*M_PI*t/b[3]));
      gsl_matrix_set (df, i, 4, -cos(2*M_PI*t/b[3]));
      gsl_matrix_set (df, i, 5, -sin(2*M_PI*t/b[3]));
      gsl_matrix_set (df, i, 6, 
                     -b[7] * (2*M_PI*t/(b[6]*b[6])) * sin(2*M_PI*t/b[6])
                     +b[8] * (2*M_PI*t/(b[6]*b[6])) * cos(2*M_PI*t/b[6]));
      gsl_matrix_set (df, i, 7, -cos(2*M_PI*t/b[6]));
      gsl_matrix_set (df, i, 8, -sin(2*M_PI*t/b[6]));
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(source += length, dest += length; length; --length)
      *--dest = *--source;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(; length; --length)
      *dest++ = *source++;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(c = *s; c != '\0'; c = *++s)
    {
      if (isdigit (c))
        c -= '0';
      else if (isalpha (c))
        c = toupper (c) - 'A' + 10;
      else
        break;
      if (c >= base)
        break;
      
      if (i > cutoff || (i == cutoff && c > cutlim))
        overflow = 1;
      else
        {
          i *= (unsigned long int) base;
          i += c;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
    {
      int k;
      int status;

      for(k = 0; k < MULTIPLICITY; k++)
        {
          if (k > 0)
            {
              status = putc (' ', stream);

              if (status == EOF)
                {
                  GSL_ERROR ("putc failed", GSL_EFAILED);
                }
            }
          status = fprintf (stream,
                            format,
                            data[MULTIPLICITY * i + k]);
          if (status < 0)
            {
              GSL_ERROR ("fprintf failed", GSL_EFAILED);
            }
        }

      status = putc ('\n', stream);

      if (status == EOF)
        {
          GSL_ERROR ("putc failed", GSL_EFAILED);
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
    {
      int k;
      for(k = 0; k < MULTIPLICITY; k++)
        {
          ATOMIC_IO tmp ;

          int status = fscanf (stream, IN_FORMAT, &tmp) ;
          
          data [MULTIPLICITY * i + k] = tmp;


          if (status != 1)
            {
              GSL_ERROR ("fscanf failed", GSL_EFAILED);
            }
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
    {
      int k;
      int status;

      for(k = 0; k < MULTIPLICITY; k++)
        {
          if (k > 0)
            {
              status = putc (' ', stream);

              if (status == EOF)
                {
                  GSL_ERROR ("putc failed", GSL_EFAILED);
                }
            }
          status = fprintf (stream,
                            format,
                            data[MULTIPLICITY * i * stride + k]);
          if (status < 0)
            {
              GSL_ERROR ("fprintf failed", GSL_EFAILED);
            }
        }

      status = putc ('\n', stream);

      if (status == EOF)
        {
          GSL_ERROR ("putc failed", GSL_EFAILED);
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
    {
      int k;
      for(k = 0; k < MULTIPLICITY; k++)
        {
          ATOMIC_IO tmp;

          int status = fscanf (stream, IN_FORMAT, &tmp) ;

          data [MULTIPLICITY * i * stride + k] = tmp;

          if (status != 1)
            GSL_ERROR ("fscanf failed", GSL_EFAILED);
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
    {
      if (v->data[i] != 0.0)
        status = 1;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
      {
        v->data[i] = (ATOMIC)(N - i);
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
      {
        if (w->data[i] != (ATOMIC) (N - i))
          status = 1;
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
        {
          size_t item = fread (data + MULTIPLICITY * i * stride,
                               MULTIPLICITY * sizeof (ATOMIC), 1, stream);
          if (item != 1)
            {
              GSL_ERROR ("fread failed", GSL_EFAILED);
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
        {
          size_t item = fwrite (data + MULTIPLICITY * i * stride,
                                MULTIPLICITY * sizeof (ATOMIC),
                                1, stream);
          if (item != 1)
            {
              GSL_ERROR ("fwrite failed", GSL_EFAILED);
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
      {
        v->data[2*i] = (ATOMIC)i ;
        v->data[2*i + 1] = (ATOMIC)(10*i + 1) ;
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
      {
        if (w->data[2 * i] != (ATOMIC) i || w->data[2 * i + 1] != (ATOMIC) (10*i + 1))
          status = 1;
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
    {
      if (b->data[2 * i] != 0.0 || b->data[2 * i + 1] != 0.0)
        status = 1;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
      {
        v->data[2*i] = (ATOMIC)(N - i);
        v->data[2*i + 1] = (ATOMIC)(10*(N-i) + 1);
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
      {
        if (w->data[2 * i] != (ATOMIC) (N - i) || w->data[2 * i + 1] != (ATOMIC) (10*(N - i) + 1))
          status = 1;
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < MULTIPLICITY * n; i++)
    {
      b->data[i] = 0;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
      {
        v->data[i] = (ATOMIC) i;
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
      {
        if (w->data[i] != (ATOMIC) i)
          status = 1;
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 23; i++)
      {
        float x = f / (float)pow (2.0, 1 + (float) i);
        mantissa[i] = '1';
        gsl_ieee_float_to_rep (&x, &r);

        gsl_test_int (r.sign, 0, "float x = FLT_MIN/2^%d, sign is +", i + 1);
        gsl_test_int (r.exponent, -127,
                      "float x = FLT_MIN/2^%d, exponent is -127", i + 1);
        gsl_test_str (r.mantissa, mantissa,
                      "float x = FLT_MIN/2^%d, mantissa", i + 1);
        gsl_test_int (r.type, GSL_IEEE_TYPE_DENORMAL,
                      "float x = FLT_MIN/2^%d, type is DENORMAL", i + 1);
        mantissa[i] = '0';
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 52; i++)
      {
        double x = d / pow (2.0, 1 + (double) i);
        mantissa[i] = '1';
        gsl_ieee_double_to_rep (&x, &r);

        gsl_test_int (r.sign, 0, "double x = DBL_MIN/2^%d, sign is +", i + 1);
        gsl_test_int (r.exponent, -1023,
                      "double x = DBL_MIN/2^%d, exponent", i + 1);
        gsl_test_str (r.mantissa, mantissa,
                      "double x = DBL_MIN/2^%d, mantissa", i + 1);
        gsl_test_int (r.type, GSL_IEEE_TYPE_DENORMAL,
                      "double x = DBL_MIN/2^%d, type is DENORMAL", i + 1);
        mantissa[i] = '0';
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(r = rngs ; *r != 0; r++)
    rng_float_test (*r);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(r = rngs ; *r != 0; r++)
    rng_state_test (*r);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(r = rngs ; *r != 0; r++)
    rng_parallel_state_test (*r);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(r = rngs ; *r != 0; r++)
    rng_read_write_test (*r);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(r = rngs ; *r != 0; r++)
    generic_rng_test (*r);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
    {
      k = gsl_rng_get (r);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N2; i++)
    {
      k = gsl_rng_get (ri);
      u = gsl_rng_get (rf);
      if (c*k != u)
        {
          status = 1 ;
          break ;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; ++i)
    {
      gsl_rng_get (r);  
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; ++i)
    {
      test_a[i] = gsl_rng_get (r);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; ++i)
    {
      test_b[i] = gsl_rng_get (r);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; ++i)
      {
        status |= (test_b[i] != test_a[i]);
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; ++i)
    {
      gsl_rng_get (r1);         
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; ++i)
    {
      
      test_a[i] = gsl_rng_get (r1);     
      test_b[i] = gsl_rng_get (r2);
      test_c[i] = gsl_rng_uniform_int (r1, 1234);       
      test_d[i] = gsl_rng_uniform_int (r2, 1234);
      test_e[i] = gsl_rng_uniform (r1); 
      test_f[i] = gsl_rng_uniform (r2);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; ++i)
      {
        status |= (test_b[i] != test_a[i]);
        status |= (test_c[i] != test_d[i]);
        status |= (test_e[i] != test_f[i]);
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; ++i)
    {
      gsl_rng_get (r);  
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; ++i)
    {
      test_a[i] = gsl_rng_get (r);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; ++i)
    {
      test_b[i] = gsl_rng_get (r);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; ++i)
      {
        status |= (test_b[i] != test_a[i]);
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N2; ++i)
    {
      unsigned long int k = gsl_rng_get (r);
      if (k > max)
        max = k;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N2; ++i)
    {
      unsigned long int k = gsl_rng_get (r);
      if (k < min)
        min = k;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N2; ++i)
    {
      double x = gsl_rng_uniform (r) - 0.5;
      sum += x;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < BINS+EXTRA; i++)
      count[i] = 0 ;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N2; i++)
    {
      int j = gsl_rng_uniform_int (r, BINS);
      count[j]++ ;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < BINS; i++)
    {
      double x = (double)N2/(double)BINS ;
      double d = (count[i] - x) ;
      chisq += (d*d) / x;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = BINS; i < BINS+EXTRA; i++)
    {
      if (count[i] != 0)
        {
          status = 1 ;
          gsl_test (status, 
                    "%s, wrote outside range in bin test "
                    "(%d observed vs %d expected)",
                    gsl_rng_name(r), i, BINS - 1);
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(t = t0; *t != 0; t++)
        {
          if (strcmp (p, (*t)->name) == 0)
            {
              gsl_rng_default = *t;
              break;
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(t = t0; *t != 0; t++)
            {
              fprintf (stderr, " %18s", (*t)->name);

              if ((++i) % 4 == 0)
                {
                  fputc ('\n', stderr);
                }
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 0; ir > 0; ++k)
    {
      y1 = xdbl[jr] - xdbl[ir];
      y2 = y1 - carry;
      if (y2 < 0)
        {
          carry = one_bit;
          y2 += 1;
        }
      else
        {
          carry = 0;
        }
      xdbl[ir] = y2;
      ir = next[ir];
      jr = next[jr];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(; k <= kmax; k += 12)
    {
      y1 = xdbl[7] - xdbl[0];
      y1 -= carry;

      RANLUX_STEP (y2, y1, 8, 1, 0);
      RANLUX_STEP (y3, y2, 9, 2, 1);
      RANLUX_STEP (y1, y3, 10, 3, 2);
      RANLUX_STEP (y2, y1, 11, 4, 3);
      RANLUX_STEP (y3, y2, 0, 5, 4);
      RANLUX_STEP (y1, y3, 1, 6, 5);
      RANLUX_STEP (y2, y1, 2, 7, 6);
      RANLUX_STEP (y3, y2, 3, 8, 7);
      RANLUX_STEP (y1, y3, 4, 9, 8);
      RANLUX_STEP (y2, y1, 5, 10, 9);
      RANLUX_STEP (y3, y2, 6, 11, 10);

      if (y3 < 0)
        {
          carry = one_bit;
          y3 += 1;
        }
      else
        {
          carry = 0;
        }
      xdbl[11] = y3;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(; k < kmax; ++k)
    {
      y1 = xdbl[jr] - xdbl[ir];
      y2 = y1 - carry;
      if (y2 < 0)
        {
          carry = one_bit;
          y2 += 1;
        }
      else
        {
          carry = 0;
        }
      xdbl[ir] = y2;
      ir = next[ir];
      jr = next[jr];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 0; k < 31; ++k)
    {
      xbit[k] = i % 2;
      i /= 2;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 0; k < 12; ++k)
    {
      x = 0;

      for(l = 1; l <= 48; ++l)
        {
          y = (double) ((xbit[ibit] + 1) % 2);
          x += x + y;
          xbit[ibit] = (xbit[ibit] + xbit[jbit]) % 2;
          ibit = (ibit + 1) % 31;
          jbit = (jbit + 1) % 31;
        }
      state->xdbl[k] = one_bit * x;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 8; i++)
    {
      long int h = s / q;
      long int t = a * (s - h * q) - h * r;
      if (t < 0)
        t += m;
      s = t;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = N_SHUFFLE - 1; i >= 0; i--)
    {
      long int h = s / q;
      long int t = a * (s - h * q) - h * r;
      if (t < 0)
        t += m;
      s = t;
      state->shuffle[i] = s;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i <= M; i++)
    {
      unsigned long t = 0 ;
      unsigned long bit = msb ;
      for(j = 0; j < 32; j++)
        {
          s = LCG(s) ;
          if (s & msb) 
            t |= bit ;
          bit >>= 1 ;
        }
      state->ra[i] = t ;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<32; ++i) {
      int k=7+i*3;
      state->ra[k] &= mask;     
      state->ra[k] |= msb;      
      mask >>= 1;
      msb >>= 1;
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 250; i++)     
    {
      s = LCG (s);
      state->x[i] = s;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 32; i++)
      {
        int k = 7 * i + 3;      
        state->x[k] &= mask;    
        state->x[k] |= msb;     
        mask >>= 1;
        msb >>= 1;
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i < 55; i++)
    {
      int n = (21 * i) % 55;
      state->buffer[n] = k;
      k = j - k;
      if (k < 0)
        k += M_BIG;
      j = state->buffer[n];

    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i1 = 0; i1 < 4; i1++)
    {
      for(i = 1; i < 56; i++)
        {
          long int t = state->buffer[i] - state->buffer[1 + (i + 30) % 55];
          if (t < 0)
            t += M_BIG;
          state->buffer[i] = t;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N - M; i++)
        {
          x[i] = x[i + M] ^ (x[i] >> 1) ^ mag01[x[i] % 2];
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(; i < N; i++)
        {
          x[i] = x[i + (M - N)] ^ (x[i] >> 1) ^ mag01[x[i] % 2];
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i < N; i++)
        state->x[i] = (69069 * state->x[i - 1]) & 0xffffffffUL;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < KK; j++)
    aa[j] = ran_x[j];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(; j < n; j++)
    aa[j] = mod_diff (aa[j - KK], aa[j - LL]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < LL; i++, j++)
    ran_x[i] = mod_diff (aa[j - KK], aa[j - LL]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(; i < KK; i++, j++)
    ran_x[i] = mod_diff (aa[j - KK], ran_x[i - LL]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < KK; j++)
    {
      x[j] = ss;                
      ss <<= 1;
      if (ss >= MM)             
        ss -= MM - 2;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(; j < KK + KK - 1; j++)
    x[j] = 0;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = KK - 1; j > 0; j--)      
        x[j + j] = x[j];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = KK + KK - 2; j > KK - LL; j -= 2)
        x[KK + KK - 1 - j] = evenize (x[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = KK + KK - 2; j >= KK; j--)
        if (is_odd (x[j]))
          {
            x[j - (KK - LL)] = mod_diff (x[j - (KK - LL)], x[j]);
            x[j - KK] = mod_diff (x[j - KK], x[j]);
          }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = KK; j > 0; j--)
            x[j] = x[j - 1];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < LL; j++)
    state->ran_x[j + KK - LL] = x[j];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(; j < KK; j++)
    state->ran_x[j - LL] = x[j];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 17; i++)
    {
      seed = j0 * k0;
      j1 = (seed / m2 + j0 * k1 + j1 * k0) % (m2 / 2);
      j0 = seed % m2;
      state->m[i] = j0 + m2 * j1;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ii = 0; ii < 607; ++ii)
    {
      x = 0.0;
      y = 0.5;
      
      for(jj = 1; jj <= 24; ++jj)
        {
          m = i * j % 179 * k % 179;
          i = j;
          j = k;
          k = m;
          l = (l * 53 + 1) % 169;
          if (l * m % 64 >= 32)
            {
              x += y;
            }
          y *= 0.5;
        }
      state->u[ii] = (unsigned long int) (x * zuf_randmax);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 17; ++i)
    {
      seed = j0 * k0;
      j1 = (seed / m2 + j0 * k1 + j1 * k0) % (m2 / 2);
      j0 = seed % m2;
      state->m[i] = j0 + m2 * j1;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(a = 0; a < 97; a++)
    {
      unsigned long int sum = 0 ;
      unsigned long int t = two24 ;

      for(b = 0; b < 24; b++)
        {
          unsigned long int m = (((i * j) % 179) * k) % 179 ;
          i = j ;
          j = k ;
          k = m ;
          l = (53 * l + 1) % 169 ;
          t >>= 1 ;
          
          if ((l * m) % 64 >= 32)
            sum += t ;
        }

      state->u[a] = sum ;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 8; i++)
    {
      long int h = s / q1;
      long int t = a1 * (s - h * q1) - h * r1;
      if (t < 0)
        t += m1;
      s = t;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = N_SHUFFLE - 1; i >= 0; i--)
    {
      long int h = s / q1;
      long int t = a1 * (s - h * q1) - h * r1;
      if (t < 0)
        t += m1;
      s = t;
      state->shuffle[i] = s;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < skip; i++)
        increment_state (state);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 24; i++)
    {
      unsigned long int k = seed / 53668;
      seed = 40014 * (seed - k * 53668) - k * 12211;
      if (seed < 0)
        {
          seed += 2147483563;
        }
      state->u[i] = seed % two24;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
    {
      
      printf ("%.2x", *(p + i));
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0 ; i < 10 * 7 ; i++)
    random32_get (state) ; 



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0 ; i < 10 * 15 ; i++)
    random64_get (state) ; 



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0 ; i < 10 * 31 ; i++)
    random128_get (state) ; 



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0 ; i < 10 * 63 ; i++)
    random256_get (state) ; 



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1 ; i < n ; i++)
    x[i] = 1103515245 * x[i-1] + 12345 ;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1 ; i < n ; i++)
    x[i] = 1103515145 * x[i-1] + 12345 ;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1 ; i < n ; i++)
    {
      const long int h = s / 127773;
      const long int t = 16807 * (s - h * 127773) - h * 2836;
      if (t < 0)
        {
          s = t + 2147483647 ;
        }
      else
        {
          s = t ;
        }

    x[i] = s ;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0 ; i < 10 * 7 ; i++)
    random32_get (state) ; 



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0 ; i < 10 * 15 ; i++)
    random64_get (state) ; 



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0 ; i < 10 * 31 ; i++)
    random128_get (state) ; 



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0 ; i < 10 * 63 ; i++)
    random256_get (state) ; 



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0 ; i < 10 * 7 ; i++)
    random32_get (state) ; 



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0 ; i < 10 * 15 ; i++)
    random64_get (state) ; 



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0 ; i < 10 * 31 ; i++)
    random128_get (state) ; 



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0 ; i < 10 * 63 ; i++)
    random256_get (state) ; 



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < KK; j++)
    aa[j] = ran_x[j];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(; j < n; j++)
    aa[j] = mod_diff (aa[j - KK], aa[j - LL]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < LL; i++, j++)
    ran_x[i] = mod_diff (aa[j - KK], aa[j - LL]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(; i < KK; i++, j++)
    ran_x[i] = mod_diff (aa[j - KK], ran_x[i - LL]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < KK; j++)
    {
      x[j] = ss;                
      ss <<= 1;
      if (ss >= MM)             
        ss -= MM - 2;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = KK - 1; j > 0; j--)      
        {
          x[j + j] = x[j];
          x[j + j - 1] = 0;
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = KK + KK - 2; j >= KK; j--)
        {
          x[j - (KK - LL)] = mod_diff (x[j - (KK - LL)], x[j]);
          x[j - KK] = mod_diff (x[j - KK], x[j]);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = KK; j > 0; j--)
            {
              x[j] = x[j - 1];
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < LL; j++)
    state->ran_x[j + KK - LL] = x[j];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(; j < KK; j++)
    state->ran_x[j - LL] = x[j];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j< 10; j++) 
    ran_array(x, KK+KK-1, state->ran_x);  



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(kk = 0; kk < N - M; kk++)
        {
          unsigned long y = (mt[kk] & UPPER_MASK) | (mt[kk + 1] & LOWER_MASK);
          mt[kk] = mt[kk + M] ^ (y >> 1) ^ MAGIC(y);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(; kk < N - 1; kk++)
        {
          unsigned long y = (mt[kk] & UPPER_MASK) | (mt[kk + 1] & LOWER_MASK);
          mt[kk] = mt[kk + (M - N)] ^ (y >> 1) ^ MAGIC(y);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i < N; i++)
    {
      


      state->mt[i] =
        (1812433253UL * (state->mt[i-1] ^ (state->mt[i-1] >> 30)) + i);
      
      state->mt[i] &= 0xffffffffUL;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
    {
      state->mt[i] = s & 0xffff0000UL;
      s = LCG(s);
      state->mt[i] |= (s &0xffff0000UL) >> 16;
      s = LCG(s);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i < N; i++)
    state->mt[i] = LCG1998 (state->mt[i - 1]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 0; ir > 0; ++k)
    {
      y1 = xdbl[jr] - xdbl[ir];
      y2 = y1 - carry;
      if (y2 < 0)
        {
          carry = one_bit;
          y2 += 1;
        }
      else
        {
          carry = 0;
        }
      xdbl[ir] = y2;
      ir = next[ir];
      jr = next[jr];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(; k <= kmax; k += 12)
    {
      y1 = xdbl[7] - xdbl[0];
      y1 -= carry;

      RANLUX_STEP (y2, y1, 8, 1, 0);
      RANLUX_STEP (y3, y2, 9, 2, 1);
      RANLUX_STEP (y1, y3, 10, 3, 2);
      RANLUX_STEP (y2, y1, 11, 4, 3);
      RANLUX_STEP (y3, y2, 0, 5, 4);
      RANLUX_STEP (y1, y3, 1, 6, 5);
      RANLUX_STEP (y2, y1, 2, 7, 6);
      RANLUX_STEP (y3, y2, 3, 8, 7);
      RANLUX_STEP (y1, y3, 4, 9, 8);
      RANLUX_STEP (y2, y1, 5, 10, 9);
      RANLUX_STEP (y3, y2, 6, 11, 10);

      if (y3 < 0)
        {
          carry = one_bit;
          y3 += 1;
        }
      else
        {
          carry = 0;
        }
      xdbl[11] = y3;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(; k < kmax; ++k)
    {
      y1 = xdbl[jr] - xdbl[ir];
      y2 = y1 - carry;
      if (y2 < 0)
        {
          carry = one_bit;
          y2 += 1;
        }
      else
        {
          carry = 0;
        }
      xdbl[ir] = y2;
      ydbl[ir] = y2 + shift;
      ir = next[ir];
      jr = next[jr];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = next[ir]; k > 0;)
    {
      ydbl[k] = xdbl[k] + shift;
      k = next[k];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 0, m = 0; k < 12; ++k)
    {
      x = xdbl[k];
      y2 = ydbl[k] - shift;
      if (y2 > x)
        y2 -= sone_bit;
      y1 = (x - y2) * sbase;

      xflt[m++] = (float) y1;
      xflt[m++] = (float) y2;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 0; k < 31; ++k)
    {
      xbit[k] = i % 2;
      i /= 2;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 0; k < 12; ++k)
    {
      x = 0;

      for(m = 1; m <= 48; ++m)
        {
          y = (double) xbit[ibit];
          x += x + y;
          xbit[ibit] = (xbit[ibit] + xbit[jbit]) % 2;
          ibit = (ibit + 1) % 31;
          jbit = (jbit + 1) % 31;
        }
      state->xdbl[k] = one_bit * x;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(N = 1; N <= 16384; N *= 2)
    {
      for(stride = 1; stride <= 5; stride++)
        {
          for(i = 0; i < N_BS; i++)
            {
              test_1d (N, stride, gsl_wavelet_bspline, member[i]);
              test_1d (N, stride, gsl_wavelet_bspline_centered, member[i]);
            }

          for(i = 4; i <= 20; i += 2)
            {
              test_1d (N, stride, gsl_wavelet_daubechies, i);
              test_1d (N, stride, gsl_wavelet_daubechies_centered, i);
            }

          test_1d (N, stride, gsl_wavelet_haar, 2);
          test_1d (N, stride, gsl_wavelet_haar_centered, 2);
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(N = 1; N <= 64; N *= 2)
    {
      for(tda = N; tda <= N + 5; tda++)
        {
          for(i = 0; i < N_BS; i++)
            {
              test_2d (N, tda, gsl_wavelet_bspline, member[i], S);
              test_2d (N, tda, gsl_wavelet_bspline_centered, member[i], S);

              test_2d (N, tda, gsl_wavelet_bspline, member[i], NS);
              test_2d (N, tda, gsl_wavelet_bspline_centered, member[i], NS);
            }
          
          for(i = 4; i <= 20; i += 2)
            {
              test_2d (N, tda, gsl_wavelet_daubechies, i, S);
              test_2d (N, tda, gsl_wavelet_daubechies_centered, i, S);

              test_2d (N, tda, gsl_wavelet_daubechies, i, NS);
              test_2d (N, tda, gsl_wavelet_daubechies_centered, i, NS);
            }
          
          test_2d (N, tda, gsl_wavelet_haar, 2, S);
          test_2d (N, tda, gsl_wavelet_haar_centered, 2, S);

          test_2d (N, tda, gsl_wavelet_haar, 2, NS);
          test_2d (N, tda, gsl_wavelet_haar_centered, 2, NS);
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N * stride; i++)
    data[i] = 12345.0 + i;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
    {
      gsl_vector_set (v1, i, urand ());
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
    {
      double x1 = gsl_vector_get (v1, i);
      double x2 = gsl_vector_get (v2, i);
      gsl_vector_set (vdelta, i, fabs (x1 - x2));
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N * stride; i++)
        {
          if (i % stride == 0)
            continue;

          status |= (data[i] != (12345.0 + i));
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N * tda; i++)
    data[i] = 12345.0 + i;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
    {
      for(j = 0; j < N; j++)
        {
            gsl_matrix_set (m1, i, j, urand());
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
    {
      for(j = 0; j < N; j++)
        {
          double x1 = gsl_matrix_get (m1, i, j);
          double x2 = gsl_matrix_get (m2, i, j );
          gsl_matrix_set (mdelta, i, j, fabs (x1 - x2));
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N ; i++)
        {
          for(j = N; j < tda; j++)
            {
              status |= (data[i*tda+j] != (12345.0 + (i*tda+j)));
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i < (n < 10 ? n : 10); i++)
    {
      printf
        (" h1(%d):%12.8f   g1(%d):%12.8f       h2(%d):%12.8f   g2(%d):%12.8f\n",
         i, w->h1[i], i, w->g1[i], i, w->h2[i], i, w->g2[i]);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(; i < n; i++)
    {
      printf
        ("h1(%d):%12.8f  g1(%d):%12.8f      h2(%d):%12.8f  g2(%d):%12.8f\n",
         i, w->h1[i], i, w->g1[i], i, w->h2[i], i, w->g2[i]);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < work->n; i++)
    {
      work->scratch[i] = 0.0;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ii = 0, i = 0; i < n; i += 2, ii++)
        {
          ni = i + nmod;
          for(k = 0; k < w->nc; k++)
            {
              jf = n1 & (ni + k);
              work->scratch[ii] += w->h1[k] * ELEMENT (a, stride, jf);
              work->scratch[ii + nh] += w->g1[k] * ELEMENT (a, stride, jf);
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ii = 0, i = 0; i < n; i += 2, ii++)
        {
          ai = ELEMENT (a, stride, ii);
          ai1 = ELEMENT (a, stride, ii + nh);
          ni = i + nmod;
          for(k = 0; k < w->nc; k++)
            {
              jf = (n1 & (ni + k));
              work->scratch[jf] += (w->h2[k] * ai + w->g2[k] * ai1);
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
    {
      ELEMENT (a, stride, i) = work->scratch[i];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = n; i >= 2; i >>= 1)
        {
          dwt_step (w, data, stride, i, dir, work);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 2; i <= n; i <<= 1)
        {
          dwt_step (w, data, stride, i, dir, work);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < size1; i++)       
        {
          gsl_wavelet_transform (w, &ELEMENT(data, tda, i), 1, size1, dir, work);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < size2; i++)       
        {
          gsl_wavelet_transform (w, &ELEMENT(data, 1, i), tda, size2, dir, work);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < size2; i++)       
        {
          gsl_wavelet_transform (w, &ELEMENT(data, 1, i), tda, size2, dir, work);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < size1; i++)       
        {
          gsl_wavelet_transform (w, &ELEMENT(data, tda, i), 1, size1, dir, work);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = size1; i >= 2; i >>= 1)
        {
          for(j = 0; j < i; j++)       
            {
              dwt_step (w, &ELEMENT(data, tda, j), 1, i, dir, work);
            }
          for(j = 0; j < i; j++)       
            {
              dwt_step (w, &ELEMENT(data, 1, j), tda, i, dir, work);
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 2; i <= size1; i <<= 1)
        {
          for(j = 0; j < i; j++)       
            {
              dwt_step (w, &ELEMENT(data, 1, j), tda, i, dir, work);
            }
          for(j = 0; j < i; j++)       
            {
              dwt_step (w, &ELEMENT(data, tda, j), 1, i, dir, work);
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(T = fsolver ; *T != 0 ; T++)
    {
      test_f (*T, "sin(x) [3, 4]", &F_sin, 3.0, 4.0, M_PI);
      test_f (*T, "sin(x) [-4, -3]", &F_sin, -4.0, -3.0, -M_PI);
      test_f (*T, "sin(x) [-1/3, 1]", &F_sin, -1.0 / 3.0, 1.0, 0.0);
      test_f (*T, "cos(x) [0, 3]", &F_cos, 0.0, 3.0, M_PI / 2.0);
      test_f (*T, "cos(x) [-3, 0]", &F_cos, -3.0, 0.0, -M_PI / 2.0);
      test_f (*T, "x^20 - 1 [0.1, 2]", &F_func1, 0.1, 2.0, 1.0);
      test_f (*T, "sqrt(|x|)*sgn(x)", &F_func2, -1.0 / 3.0, 1.0, 0.0);
      test_f (*T, "x^2 - 1e-8 [0, 1]", &F_func3, 0.0, 1.0, sqrt (1e-8));
      test_f (*T, "x exp(-x) [-1/3, 2]", &F_func4, -1.0 / 3.0, 2.0, 0.0);
      test_f (*T, "(x - 1)^7 [0.9995, 1.0002]", &F_func6, 0.9995, 1.0002, 1.0);
      
      test_f_e (*T, "invalid range check [4, 0]", &F_sin, 4.0, 0.0, M_PI);
      test_f_e (*T, "invalid range check [1, 1]", &F_sin, 1.0, 1.0, M_PI);
      test_f_e (*T, "invalid range check [0.1, 0.2]", &F_sin, 0.1, 0.2, M_PI);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(S = fdfsolver ; *S != 0 ; S++)
    {
      test_fdf (*S,"sin(x) {3.4}", &FDF_sin, 3.4, M_PI);
      test_fdf (*S,"sin(x) {-3.3}", &FDF_sin, -3.3, -M_PI);
      test_fdf (*S,"sin(x) {0.5}", &FDF_sin, 0.5, 0.0);
      test_fdf (*S,"cos(x) {0.6}", &FDF_cos, 0.6, M_PI / 2.0);
      test_fdf (*S,"cos(x) {-2.5}", &FDF_cos, -2.5, -M_PI / 2.0);
      test_fdf (*S,"x^{20} - 1 {0.9}", &FDF_func1, 0.9, 1.0);
      test_fdf (*S,"x^{20} - 1 {1.1}", &FDF_func1, 1.1, 1.0);
      test_fdf (*S,"sqrt(|x|)*sgn(x) {1.001}", &FDF_func2, 0.001, 0.0);
      test_fdf (*S,"x^2 - 1e-8 {1}", &FDF_func3, 1.0, sqrt (1e-8));
      test_fdf (*S,"x exp(-x) {-2}", &FDF_func4, -2.0, 0.0);
      test_fdf_e (*S,"max iterations x -> +Inf, x exp(-x) {2}", &FDF_func4, 2.0, 0.0);
      test_fdf_e (*S,"max iterations x -> -Inf, 1/(1 + exp(-x)) {0}", &FDF_func5, 0.0, 0.0);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n_factors; i++)
    {
      size_t j;
      const size_t factor = wavetable->factor[i];
      wavetable->twiddle[i] = wavetable->trig + t;
      product_1 = product;      
      product *= factor;
      q = n / product;

      for(j = 1; j < factor; j++)
        {
          size_t k;
          size_t m = 0;
          for(k = 1; k < (q + 1) / 2; k++)
            {
              double theta;
              m = m + j * product_1;
              m = m % n;
              theta = d_theta * m;      
              GSL_REAL(wavetable->trig[t]) = cos (theta);
              GSL_IMAG(wavetable->trig[t]) = sin (theta);

              t++;
            }
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1 ; i <= end ; i *= 2) 
    {
      if (i >= start) 
        {
          for(stride = 1 ; stride < 4 ; stride++)
            {
              test_complex_bitreverse_order (stride, i) ;
              test_complex_radix2 (stride, i) ;
              test_real_bitreverse_order (stride, i) ;
              test_real_radix2 (stride, i) ;
            }
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = start ; i <= end ; i++) 
    {
      for(stride = 1 ; stride < 4 ; stride++)
        {
          test_complex_func (stride, i) ;
          test_complex_float_func (stride, i) ;
          test_real_func (stride, i) ;
          test_real_float_func (stride, i) ;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k1 = 0; k1 < product_1; k1++)
    {
      const size_t from0 = 3 * k1 * q;
      const size_t from1 = from0 + 2 * q - 1;

      const ATOMIC z0_real = VECTOR(in,istride,from0);
      const ATOMIC z1_real = VECTOR(in,istride,from1);
      const ATOMIC z1_imag = VECTOR(in,istride,from1 + 1);

      const ATOMIC t1_real = 2 * z1_real;
      const ATOMIC t2_real = z0_real - z1_real;
      const ATOMIC t3_imag = 2 * tau * z1_imag;

      const size_t to0 = q * k1;
      const size_t to1 = to0 + m;
      const size_t to2 = to1 + m;

      VECTOR(out,ostride,to0) = z0_real + t1_real;
      VECTOR(out,ostride,to1) = t2_real - t3_imag;
      VECTOR(out,ostride,to2) = t2_real + t3_imag;

    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 1; k < (q + 1) / 2; k++)
    {
      const ATOMIC w1_real = GSL_REAL(twiddle1[k - 1]);
      const ATOMIC w1_imag = GSL_IMAG(twiddle1[k - 1]);
      const ATOMIC w2_real = GSL_REAL(twiddle2[k - 1]);
      const ATOMIC w2_imag = GSL_IMAG(twiddle2[k - 1]);

      for(k1 = 0; k1 < product_1; k1++)
        {
          const size_t from0 = 3 * k1 * q + 2 * k - 1;
          const size_t from1 = from0 + 2 * q;
          const size_t from2 = 3 * k1 * q - 2 * k + 2 * q - 1;

          const ATOMIC z0_real = VECTOR(in,istride,from0);
          const ATOMIC z0_imag = VECTOR(in,istride,from0 + 1);

          const ATOMIC z1_real = VECTOR(in,istride,from1);
          const ATOMIC z1_imag = VECTOR(in,istride,from1 + 1);

          const ATOMIC z2_real = VECTOR(in,istride,from2);
          const ATOMIC z2_imag = -VECTOR(in,istride,from2 + 1);

          

          
          const ATOMIC t1_real = z1_real + z2_real;
          const ATOMIC t1_imag = z1_imag + z2_imag;

          
          const ATOMIC t2_real = z0_real - t1_real / 2.0;
          const ATOMIC t2_imag = z0_imag - t1_imag / 2.0;

          
          const ATOMIC t3_real = tau * (z1_real - z2_real);
          const ATOMIC t3_imag = tau * (z1_imag - z2_imag);

          
          const ATOMIC x0_real = z0_real + t1_real;
          const ATOMIC x0_imag = z0_imag + t1_imag;

          
          const ATOMIC x1_real = t2_real - t3_imag;
          const ATOMIC x1_imag = t2_imag + t3_real;

          
          const ATOMIC x2_real = t2_real + t3_imag;
          const ATOMIC x2_imag = t2_imag - t3_real;

          const size_t to0 = k1 * q + 2 * k - 1;
          const size_t to1 = to0 + m;
          const size_t to2 = to1 + m;

          VECTOR(out,ostride,to0) = x0_real;
          VECTOR(out,ostride,to0 + 1) = x0_imag;

          VECTOR(out,ostride,to1) = w1_real * x1_real - w1_imag * x1_imag;
          VECTOR(out,ostride,to1 + 1) = w1_imag * x1_real + w1_real * x1_imag;

          VECTOR(out,ostride,to2) = w2_real * x2_real - w2_imag * x2_imag;
          VECTOR(out,ostride,to2 + 1) = w2_imag * x2_real + w2_real * x2_imag;

        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k1 = 0; k1 < product_1; k1++)
    {
      const size_t from0 = 3 * k1 * q + q - 1;
      const size_t from1 = from0 + 2 * q;

      const ATOMIC z0_real = VECTOR(in,istride,from0);
      const ATOMIC z0_imag = VECTOR(in,istride,from0 + 1);
      const ATOMIC z1_real = VECTOR(in,istride,from1);

      const ATOMIC t1_real = z0_real - z1_real;
      const ATOMIC t2_real = 2 * tau * z0_imag;

      const ATOMIC x0_real = 2 * z0_real + z1_real;
      const ATOMIC x1_real = t1_real - t2_real;
      const ATOMIC x2_real = -t1_real - t2_real;

      const size_t to0 = k1 * q + q - 1;
      const size_t to1 = to0 + m;
      const size_t to2 = to1 + m;

      VECTOR(out,ostride,to0) = x0_real;
      VECTOR(out,ostride,to1) = x1_real;
      VECTOR(out,ostride,to2) = x2_real;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n_factors; i++)
    {
      size_t j;
      const size_t factor = wavetable->factor[i];
      wavetable->twiddle[i] = wavetable->trig + t;
      product_1 = product;      
      product *= factor;
      q = n / product;

      for(j = 1; j < factor; j++)
        {
          size_t k;
          size_t m = 0;
          for(k = 1; k <= q; k++)
            {
              double theta;
              m = m + j * product_1;
              m = m % n;
              theta = d_theta * m;      
              GSL_REAL(wavetable->trig[t]) = cos (theta);
              GSL_IMAG(wavetable->trig[t]) = sin (theta);

              t++;
            }
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0 ; i < nf ; i++)
    {
      dest->twiddle[i] = dest->trig + (src->twiddle[i] - src->trig) ;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 0; k < q; k++)
    {
      ATOMIC w_real, w_imag;

      if (k == 0)
        {
          w_real = 1.0;
          w_imag = 0.0;
        }
      else
        {
          if (sign == gsl_fft_forward)
            {
              
              w_real = GSL_REAL(twiddle[k - 1]);
              w_imag = GSL_IMAG(twiddle[k - 1]);
            }
          else
            {
              
              w_real = GSL_REAL(twiddle[k - 1]);
              w_imag = -GSL_IMAG(twiddle[k - 1]);
            }
        }

      for(k1 = 0; k1 < product_1; k1++)
        {
          const ATOMIC z0_real = REAL(in,istride,i);
          const ATOMIC z0_imag = IMAG(in,istride,i);

          const ATOMIC z1_real = REAL(in,istride,i+m);
          const ATOMIC z1_imag = IMAG(in,istride,i+m);

          

          
          const ATOMIC x0_real = z0_real + z1_real;
          const ATOMIC x0_imag = z0_imag + z1_imag;

          
          const ATOMIC x1_real = z0_real - z1_real;
          const ATOMIC x1_imag = z0_imag - z1_imag;

          
          
          
          REAL(out,ostride,j) = x0_real;
          IMAG(out,ostride,j) = x0_imag;
          
          
          REAL(out,ostride,j+product_1) = w_real * x1_real - w_imag * x1_imag;
          IMAG(out,ostride,j+product_1) = w_real * x1_imag + w_imag * x1_real;
          
          i++;
          j++;
        }
      j += jump;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < m; i++)
    {
      REAL(out,ostride,i) = REAL(in,istride,i);
      IMAG(out,ostride,i) = IMAG(in,istride,i);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(e = 1; e < (factor - 1) / 2 + 1; e++)
    {
      for(i = 0; i < m; i++)
        {
          const size_t idx = i + e * m;
          const size_t idxc = i + (factor - e) * m;
          REAL(out,ostride,idx) = REAL(in,istride,idx) + REAL(in,istride,idxc);
          IMAG(out,ostride,idx) = IMAG(in,istride,idx) + IMAG(in,istride,idxc);
          REAL(out,ostride,idxc) = REAL(in,istride,idx) - REAL(in,istride,idxc);
          IMAG(out,ostride,idxc) = IMAG(in,istride,idx) - IMAG(in,istride,idxc);
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0 ; i<m; i++) 
    {
      REAL(in,istride,i) = REAL(out,ostride,i);
      IMAG(in,istride,i) = IMAG(out,ostride,i);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(e1 = 1; e1 < (factor - 1) / 2 + 1; e1++)
    {
      for(i = 0; i < m; i++)
        {
          REAL(in,istride,i) += REAL(out,ostride,i + e1*m) ;
          IMAG(in,istride,i) += IMAG(out,ostride,i + e1*m) ;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(e = 1; e < (factor-1)/2 + 1; e++)
    {
      size_t idx = e*q ;
      const size_t idx_step = e * q ;
      ATOMIC w_real, w_imag ;

      const size_t em = e * m ;
      const size_t ecm = (factor - e) * m ;

      for(i = 0; i < m; i++) 
        {
          REAL(in,istride,i+em) = REAL(out,ostride,i) ;
          IMAG(in,istride,i+em) = IMAG(out,ostride,i) ;
          REAL(in,istride,i+ecm) = REAL(out,ostride,i) ;
          IMAG(in,istride,i+ecm) = IMAG(out,ostride,i) ;
        }

      for(e1 = 1; e1 < (factor - 1) / 2 + 1; e1++)
        {
          if (idx == 0) {
            w_real = 1 ;
            w_imag = 0 ;
          } else {
            if (sign == gsl_fft_forward) {
              w_real = GSL_REAL(twiddle[idx - 1]) ;
              w_imag = GSL_IMAG(twiddle[idx - 1]) ;
            } else {
              w_real = GSL_REAL(twiddle[idx - 1]) ;
              w_imag = -GSL_IMAG(twiddle[idx - 1]) ;
            }
          }

          for(i = 0; i < m; i++) 
            {
              const ATOMIC xp_real = REAL(out,ostride,i + e1 * m);
              const ATOMIC xp_imag = IMAG(out,ostride,i + e1 * m);
              const ATOMIC xm_real = REAL(out,ostride,i + (factor - e1) *m);
              const ATOMIC xm_imag = IMAG(out,ostride,i + (factor - e1) *m);
        
              const ATOMIC ap = w_real * xp_real ;
              const ATOMIC am = w_imag * xm_imag ; 

              ATOMIC sum_real = ap - am;
              ATOMIC sumc_real = ap + am;

              const ATOMIC bp = w_real * xp_imag ;
              const ATOMIC bm = w_imag * xm_real ;

              ATOMIC sum_imag = bp + bm;
              ATOMIC sumc_imag = bp - bm;

              REAL(in,istride,i + em) += sum_real;
              IMAG(in,istride,i + em) += sum_imag;
              REAL(in,istride,i + ecm) += sumc_real;
              IMAG(in,istride,i + ecm) += sumc_imag;
            }
          idx += idx_step ;
          idx %= factor * q ;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k1 = 0; k1 < p_1; k1++)
    {
      REAL(out,ostride,k1) = REAL(in,istride,k1);
      IMAG(out,ostride,k1) = IMAG(in,istride,k1);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(e1 = 1; e1 < factor; e1++)
    {
      for(k1 = 0; k1 < p_1; k1++)
        {
          REAL(out,ostride,k1 + e1 * p_1) = REAL(in,istride,k1 + e1 * m) ;
          IMAG(out,ostride,k1 + e1 * p_1) = IMAG(in,istride,k1 + e1 * m) ;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 1; k < q; k++)
    {
      for(k1 = 0; k1 < p_1; k1++)
        {
          REAL(out,ostride,j) = REAL(in,istride,i);
          IMAG(out,ostride,j) = IMAG(in,istride,i);
          i++;
          j++;
        }
      j += jump;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 1; k < q; k++)
    {
      for(k1 = 0; k1 < p_1; k1++)
        {
          for(e1 = 1; e1 < factor; e1++)
            {
              ATOMIC x_real = REAL(in, istride,i + e1 * m);
              ATOMIC x_imag = IMAG(in, istride,i + e1 * m);

              ATOMIC w_real, w_imag ;
              if (sign == gsl_fft_forward) {
                w_real = GSL_REAL(twiddle[(e1-1)*q + k-1]) ;
                w_imag = GSL_IMAG(twiddle[(e1-1)*q + k-1]) ;
              } else {
                w_real = GSL_REAL(twiddle[(e1-1)*q + k-1]) ;
                w_imag = -GSL_IMAG(twiddle[(e1-1)*q + k-1]) ; 
              }

              REAL(out,ostride,j + e1 * p_1) = w_real * x_real - w_imag * x_imag;
              IMAG(out,ostride,j + e1 * p_1) = w_real * x_imag + w_imag * x_real;
            }
          i++;
          j++;
        }
      j += jump;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i < n - i; i++)
    {
      const ATOMIC hc_real = halfcomplex_coefficient[(2 * i - 1) * stride];
      const ATOMIC hc_imag = halfcomplex_coefficient[2 * i * stride];

      REAL(complex_coefficient,stride,i) = hc_real;
      IMAG(complex_coefficient,stride,i) = hc_imag;
      REAL(complex_coefficient,stride,n - i) = hc_real;
      IMAG(complex_coefficient,stride,n - i) = -hc_imag;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i < n - i; i++)
    {
      const ATOMIC hc_real = halfcomplex_coefficient[i * stride];
      const ATOMIC hc_imag = halfcomplex_coefficient[(n - i) * stride];

      REAL(complex_coefficient,stride,i) = hc_real;
      IMAG(complex_coefficient,stride,i) = hc_imag;
      REAL(complex_coefficient,stride,n - i) = hc_real;
      IMAG(complex_coefficient,stride,n - i) = -hc_imag;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
    {
      REAL(complex_coefficient,stride,i) = real_coefficient[i * stride];
      IMAG(complex_coefficient,stride,i) = 0.0;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
      {
        data[stride*i] *= norm;
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i <= logn; i++)
    {
      size_t a, b;

      

      for(b = 0; b < q; b++)
        {
          const ATOMIC z0 = VECTOR(data,stride,b*p);
          const ATOMIC z1 = VECTOR(data,stride,b*p + p_1);
          
          const ATOMIC t0_real = z0 + z1 ;
          const ATOMIC t1_real = z0 - z1 ;
          
          VECTOR(data,stride,b*p) = t0_real;
          VECTOR(data,stride,b*p + p_1) = t1_real ;
        }

      

      {
        ATOMIC w_real = 1.0;
        ATOMIC w_imag = 0.0;

        const ATOMIC theta = 2.0 * M_PI / p;
        
        const ATOMIC s = sin (theta);
        const ATOMIC t = sin (theta / 2.0);
        const ATOMIC s2 = 2.0 * t * t;
        
        for(a = 1; a < (p_1)/2; a++)
          {
            
            
            {
              const ATOMIC tmp_real = w_real - s * w_imag - s2 * w_real;
              const ATOMIC tmp_imag = w_imag + s * w_real - s2 * w_imag;
              w_real = tmp_real;
              w_imag = tmp_imag;
            }
            
            for(b = 0; b < q; b++)
              {
                ATOMIC z0_real = VECTOR(data,stride,b*p + a) ;
                ATOMIC z0_imag = VECTOR(data,stride,b*p + p - a) ;
                ATOMIC z1_real = VECTOR(data,stride,b*p + p_1 - a) ;
                ATOMIC z1_imag = -VECTOR(data,stride,b*p + p_1 + a) ;
                
                
                
                ATOMIC t0_real = z0_real + z1_real;
                ATOMIC t0_imag = z0_imag + z1_imag;
                
                
                
                ATOMIC t1_real = z0_real -  z1_real;
                ATOMIC t1_imag = z0_imag -  z1_imag;
                
                VECTOR(data,stride,b*p + a) = t0_real ;
                VECTOR(data,stride,b*p + p_1 - a) = t0_imag ;
                
                VECTOR(data,stride,b*p + p_1 + a) = (w_real * t1_real - w_imag * t1_imag) ;
                VECTOR(data,stride,b*p + p - a) = (w_real * t1_imag + w_imag * t1_real) ;
              }
          }
      }

      if (p_1 >  1) {
        for(b = 0; b < q; b++) {
          VECTOR(data,stride,b*p + p_1/2) *= 2 ;
          VECTOR(data,stride,b*p + p_1 + p_1/2) *= -2 ;
        }
      }

      p_1 = p_1 / 2 ;
      p = p / 2 ;
      q = q * 2 ;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k1 = 0; k1 < q; k1++)
    {
      const size_t from0 = k1 * product_1;
      const size_t from1 = from0 + m;

      const ATOMIC r0 = VECTOR(in,istride,from0);
      const ATOMIC r1 = VECTOR(in,istride,from1);
      
      const ATOMIC s0 = r0 + r1;
      const ATOMIC s1 = r0 - r1;
      
      const size_t to0 = product * k1;
      const size_t to1 = to0 + product - 1;
      
      VECTOR(out,ostride,to0) = s0;
      VECTOR(out,ostride,to1) = s1;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 1; k < (product_1 + 1) / 2; k++)
    {

      
      const ATOMIC w_real = GSL_REAL(twiddle[k - 1]);
      const ATOMIC w_imag = -GSL_IMAG(twiddle[k - 1]);

      for(k1 = 0; k1 < q; k1++)
        {
          const size_t from0 = k1 * product_1 + 2 * k - 1;
          const size_t from1 = from0 + m;

          const ATOMIC f0_real = VECTOR(in,istride,from0);
          const ATOMIC f0_imag = VECTOR(in,istride,from0 + 1);

          const ATOMIC f1_real = VECTOR(in,istride,from1);
          const ATOMIC f1_imag = VECTOR(in,istride,from1 + 1);

          const ATOMIC z0_real = f0_real;
          const ATOMIC z0_imag = f0_imag;

          const ATOMIC z1_real = w_real * f1_real - w_imag * f1_imag;
          const ATOMIC z1_imag = w_real * f1_imag + w_imag * f1_real;

          

          
          const ATOMIC x0_real = z0_real + z1_real;
          const ATOMIC x0_imag = z0_imag + z1_imag;

          
          const ATOMIC x1_real = z0_real - z1_real;
          const ATOMIC x1_imag = z0_imag - z1_imag;

          const size_t to0 = k1 * product + 2 * k - 1;
          const size_t to1 = k1 * product + product - 2 * k - 1;
          
          VECTOR(out,ostride,to0) = x0_real;
          VECTOR(out,ostride,to0 + 1) = x0_imag;
          
          
          VECTOR(out,ostride,to1) = x1_real;
          VECTOR(out,ostride,to1 + 1) = -x1_imag;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k1 = 0; k1 < q; k1++)
    {
      const size_t from0 = k1 * product_1 + product_1 - 1;
      const size_t from1 = from0 + m;
      const size_t to0 = k1 * product + product_1 - 1;

      VECTOR(out,ostride,to0) = VECTOR(in,istride,from0);
      VECTOR(out,ostride,to0 + 1) = -VECTOR(in,istride,from1);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k1 = 0; k1 < q; k1++)
    {
      const size_t from0 = k1 * product_1;
      const size_t from1 = from0 + m;
      const size_t from2 = from1 + m;
      const size_t from3 = from2 + m;
      const size_t from4 = from3 + m;
      
      const ATOMIC z0_real = VECTOR(in,istride,from0);
      const ATOMIC z1_real = VECTOR(in,istride,from1);
      const ATOMIC z2_real = VECTOR(in,istride,from2);
      const ATOMIC z3_real = VECTOR(in,istride,from3);
      const ATOMIC z4_real = VECTOR(in,istride,from4);
      
      
      const ATOMIC t1_real = z1_real + z4_real;

      
      const ATOMIC t2_real = z2_real + z3_real;

      
      const ATOMIC t3_real = z1_real - z4_real;

      
      const ATOMIC t4_real = z2_real - z3_real;

      
      const ATOMIC t5_real = t1_real + t2_real;

      
      const ATOMIC t6_real = (sqrt (5.0) / 4.0) * (t1_real - t2_real);

      
      const ATOMIC t7_real = z0_real - t5_real / 4.0;

      
      const ATOMIC t8_real = t7_real + t6_real;

      
      const ATOMIC t9_real = t7_real - t6_real;

      
      const ATOMIC t10_real = -sina * t3_real - sinb * t4_real;

      
      const ATOMIC t11_real = -sinb * t3_real + sina * t4_real;

      
      const ATOMIC x0_real = z0_real + t5_real;

      
      const ATOMIC x1_real = t8_real;
      const ATOMIC x1_imag = t10_real;

      
      const ATOMIC x2_real = t9_real;
      const ATOMIC x2_imag = t11_real;

      const size_t to0 = product * k1;
      const size_t to1 = to0 + 2 * product_1 - 1;
      const size_t to2 = to1 + 2 * product_1;
      
      VECTOR(out,ostride,to0) = x0_real;
      VECTOR(out,ostride,to1) = x1_real;
      VECTOR(out,ostride,to1 + 1) = x1_imag;
      VECTOR(out,ostride,to2) = x2_real;
      VECTOR(out,ostride,to2 + 1) = x2_imag;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 1; k < (product_1 + 1) / 2; k++)
    {
      const ATOMIC w1_real = GSL_REAL(twiddle1[k - 1]);
      const ATOMIC w1_imag = -GSL_IMAG(twiddle1[k - 1]);
      const ATOMIC w2_real = GSL_REAL(twiddle2[k - 1]);
      const ATOMIC w2_imag = -GSL_IMAG(twiddle2[k - 1]);
      const ATOMIC w3_real = GSL_REAL(twiddle3[k - 1]);
      const ATOMIC w3_imag = -GSL_IMAG(twiddle3[k - 1]);
      const ATOMIC w4_real = GSL_REAL(twiddle4[k - 1]);
      const ATOMIC w4_imag = -GSL_IMAG(twiddle4[k - 1]);

      for(k1 = 0; k1 < q; k1++)
        {
          const size_t from0 = k1 * product_1 + 2 * k - 1;
          const size_t from1 = from0 + m;
          const size_t from2 = from1 + m;
          const size_t from3 = from2 + m;
          const size_t from4 = from3 + m;
          
          const ATOMIC f0_real = VECTOR(in,istride,from0);
          const ATOMIC f0_imag = VECTOR(in,istride,from0 + 1);
          const ATOMIC f1_real = VECTOR(in,istride,from1);
          const ATOMIC f1_imag = VECTOR(in,istride,from1 + 1);
          const ATOMIC f2_real = VECTOR(in,istride,from2);
          const ATOMIC f2_imag = VECTOR(in,istride,from2 + 1);
          const ATOMIC f3_real = VECTOR(in,istride,from3);
          const ATOMIC f3_imag = VECTOR(in,istride,from3 + 1);
          const ATOMIC f4_real = VECTOR(in,istride,from4);
          const ATOMIC f4_imag = VECTOR(in,istride,from4 + 1);
          
          const ATOMIC z0_real = f0_real;
          const ATOMIC z0_imag = f0_imag;
          const ATOMIC z1_real = w1_real * f1_real - w1_imag * f1_imag;
          const ATOMIC z1_imag = w1_real * f1_imag + w1_imag * f1_real;
          const ATOMIC z2_real = w2_real * f2_real - w2_imag * f2_imag;
          const ATOMIC z2_imag = w2_real * f2_imag + w2_imag * f2_real;
          const ATOMIC z3_real = w3_real * f3_real - w3_imag * f3_imag;
          const ATOMIC z3_imag = w3_real * f3_imag + w3_imag * f3_real;
          const ATOMIC z4_real = w4_real * f4_real - w4_imag * f4_imag;
          const ATOMIC z4_imag = w4_real * f4_imag + w4_imag * f4_real;
          
          
          
          
          const ATOMIC t1_real = z1_real + z4_real;
          const ATOMIC t1_imag = z1_imag + z4_imag;
          
          
          const ATOMIC t2_real = z2_real + z3_real;
          const ATOMIC t2_imag = z2_imag + z3_imag;
          
          
          const ATOMIC t3_real = z1_real - z4_real;
          const ATOMIC t3_imag = z1_imag - z4_imag;
          
          
          const ATOMIC t4_real = z2_real - z3_real;
          const ATOMIC t4_imag = z2_imag - z3_imag;
          
          
          const ATOMIC t5_real = t1_real + t2_real;
          const ATOMIC t5_imag = t1_imag + t2_imag;
          
          
          const ATOMIC t6_real = (sqrt (5.0) / 4.0) * (t1_real - t2_real);
          const ATOMIC t6_imag = (sqrt (5.0) / 4.0) * (t1_imag - t2_imag);
          
          
          const ATOMIC t7_real = z0_real - t5_real / 4.0;
          const ATOMIC t7_imag = z0_imag - t5_imag / 4.0;
          
          
          const ATOMIC t8_real = t7_real + t6_real;
          const ATOMIC t8_imag = t7_imag + t6_imag;
          
          
          const ATOMIC t9_real = t7_real - t6_real;
          const ATOMIC t9_imag = t7_imag - t6_imag;
          
          
          const ATOMIC t10_real = -sina * t3_real - sinb * t4_real;
          const ATOMIC t10_imag = -sina * t3_imag - sinb * t4_imag;
          
          
          const ATOMIC t11_real = -sinb * t3_real + sina * t4_real;
          const ATOMIC t11_imag = -sinb * t3_imag + sina * t4_imag;

          
          const ATOMIC x0_real = z0_real + t5_real;
          const ATOMIC x0_imag = z0_imag + t5_imag;

          
          const ATOMIC x1_real = t8_real - t10_imag;
          const ATOMIC x1_imag = t8_imag + t10_real;

          
          const ATOMIC x2_real = t9_real - t11_imag;
          const ATOMIC x2_imag = t9_imag + t11_real;
          
          
          const ATOMIC x3_real = t9_real + t11_imag;
          const ATOMIC x3_imag = t9_imag - t11_real;

          
          const ATOMIC x4_real = t8_real + t10_imag;
          const ATOMIC x4_imag = t8_imag - t10_real;

          const size_t to0 = k1 * product + 2 * k - 1;
          const size_t to1 = to0 + 2 * product_1;
          const size_t to2 = to1 + 2 * product_1;
          const size_t to3 = 2 * product_1 - 2 * k + k1 * product - 1;
          const size_t to4 = to3 + 2 * product_1;
          
          VECTOR(out,ostride,to0) = x0_real;
          VECTOR(out,ostride,to0 + 1) = x0_imag;
          
          VECTOR(out,ostride,to1) = x1_real;
          VECTOR(out,ostride,to1 + 1) = x1_imag;
          
          VECTOR(out,ostride,to2) = x2_real;
          VECTOR(out,ostride,to2 + 1) = x2_imag;
          
          VECTOR(out,ostride,to3) = x4_real;
          VECTOR(out,ostride,to3 + 1) = -x4_imag;
          
          VECTOR(out,ostride,to4) = x3_real;
          VECTOR(out,ostride,to4 + 1) = -x3_imag;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k1 = 0; k1 < q; k1++)
    {
      const size_t from0 = k1 * product_1 + product_1 - 1;
      const size_t from1 = from0 + m;
      const size_t from2 = from1 + m;
      const size_t from3 = from2 + m;
      const size_t from4 = from3 + m;
      
      const ATOMIC z0_real = VECTOR(in,istride,from0);
      const ATOMIC z1_real = VECTOR(in,istride,from1);
      const ATOMIC z2_real = VECTOR(in,istride,from2);
      const ATOMIC z3_real = VECTOR(in,istride,from3);
      const ATOMIC z4_real = VECTOR(in,istride,from4);
      
      const ATOMIC t1 = z1_real - z4_real;
      const ATOMIC t2 = z1_real + z4_real;
      const ATOMIC t3 = z2_real - z3_real;
      const ATOMIC t4 = z2_real + z3_real;
      const ATOMIC t5 = t1 - t3;
      const ATOMIC t6 = z0_real + t5 / 4.0;
      const ATOMIC t7 = (sqrt (5.0) / 4.0) * (t1 + t3);

      const size_t to0 = k1 * product + product_1 - 1;
      const size_t to1 = to0 + 2 * product_1;
      const size_t to2 = to1 + 2 * product_1;
      
      VECTOR(out,ostride,to0) = t6 + t7;
      VECTOR(out,ostride,to0 + 1) = -sinb * t2 - sina * t4;
      
      VECTOR(out,ostride,to1) = t6 - t7;
      VECTOR(out,ostride,to1 + 1) = -sina * t2 + sinb * t4;
      
      VECTOR(out,ostride,to2) = z0_real - t5;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k1 = 0; k1 < product_1; k1++)
    {
      const size_t from0 = 5 * k1 * q;
      const size_t from1 = from0 + 2 * q - 1;
      const size_t from2 = from1 + 2 * q;

      const ATOMIC z0_real = VECTOR(in,istride,from0);
      const ATOMIC z1_real = VECTOR(in,istride,from1);
      const ATOMIC z1_imag = VECTOR(in,istride,from1 + 1);
      const ATOMIC z2_real = VECTOR(in,istride,from2);
      const ATOMIC z2_imag = VECTOR(in,istride,from2 + 1);

      const ATOMIC t1_real = 2 * (z1_real + z2_real);
      const ATOMIC t2_real = 2 * (sqrt (5.0) / 4.0) * (z1_real - z2_real);
      const ATOMIC t3_real = z0_real - t1_real / 4.0;
      const ATOMIC t4_real = t2_real + t3_real;
      const ATOMIC t5_real = -t2_real + t3_real;
      const ATOMIC t6_imag = 2 * (sina * z1_imag + sinb * z2_imag);
      const ATOMIC t7_imag = 2 * (sinb * z1_imag - sina * z2_imag);

      const ATOMIC x0_real = z0_real + t1_real;
      const ATOMIC x1_real = t4_real - t6_imag;
      const ATOMIC x2_real = t5_real - t7_imag;
      const ATOMIC x3_real = t5_real + t7_imag;
      const ATOMIC x4_real = t4_real + t6_imag;

      const size_t to0 = q * k1;
      const size_t to1 = to0 + m;
      const size_t to2 = to1 + m;
      const size_t to3 = to2 + m;
      const size_t to4 = to3 + m;

      VECTOR(out,ostride,to0) = x0_real;
      VECTOR(out,ostride,to1) = x1_real;
      VECTOR(out,ostride,to2) = x2_real;
      VECTOR(out,ostride,to3) = x3_real;
      VECTOR(out,ostride,to4) = x4_real;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 1; k < (q + 1) / 2; k++)
    {
      const ATOMIC w1_real = GSL_REAL(twiddle1[k - 1]);
      const ATOMIC w1_imag = GSL_IMAG(twiddle1[k - 1]);
      const ATOMIC w2_real = GSL_REAL(twiddle2[k - 1]);
      const ATOMIC w2_imag = GSL_IMAG(twiddle2[k - 1]);
      const ATOMIC w3_real = GSL_REAL(twiddle3[k - 1]);
      const ATOMIC w3_imag = GSL_IMAG(twiddle3[k - 1]);
      const ATOMIC w4_real = GSL_REAL(twiddle4[k - 1]);
      const ATOMIC w4_imag = GSL_IMAG(twiddle4[k - 1]);

      for(k1 = 0; k1 < product_1; k1++)
        {
          const size_t from0 = 5 * k1 * q + 2 * k - 1;
          const size_t from1 = from0 + 2 * q;
          const size_t from2 = from1 + 2 * q;
          const size_t from3 = 5 * k1 * q - 2 * k + 2 * q - 1;
          const size_t from4 = from3 + 2 * q;

          const ATOMIC z0_real = VECTOR(in,istride,from0);
          const ATOMIC z0_imag = VECTOR(in,istride,from0 + 1);

          const ATOMIC z1_real = VECTOR(in,istride,from1);
          const ATOMIC z1_imag = VECTOR(in,istride,from1 + 1);

          const ATOMIC z2_real = VECTOR(in,istride,from2);
          const ATOMIC z2_imag = VECTOR(in,istride,from2 + 1);

          const ATOMIC z3_real = VECTOR(in,istride,from4);
          const ATOMIC z3_imag = -VECTOR(in,istride,from4 + 1);

          const ATOMIC z4_real = VECTOR(in,istride,from3);
          const ATOMIC z4_imag = -VECTOR(in,istride,from3 + 1);

          

          
          const ATOMIC t1_real = z1_real + z4_real;
          const ATOMIC t1_imag = z1_imag + z4_imag;

          
          const ATOMIC t2_real = z2_real + z3_real;
          const ATOMIC t2_imag = z2_imag + z3_imag;

          
          const ATOMIC t3_real = z1_real - z4_real;
          const ATOMIC t3_imag = z1_imag - z4_imag;

          
          const ATOMIC t4_real = z2_real - z3_real;
          const ATOMIC t4_imag = z2_imag - z3_imag;

          
          const ATOMIC t5_real = t1_real + t2_real;
          const ATOMIC t5_imag = t1_imag + t2_imag;

          
          const ATOMIC t6_real = (sqrt (5.0) / 4.0) * (t1_real - t2_real);
          const ATOMIC t6_imag = (sqrt (5.0) / 4.0) * (t1_imag - t2_imag);

          
          const ATOMIC t7_real = z0_real - t5_real / 4.0;
          const ATOMIC t7_imag = z0_imag - t5_imag / 4.0;

          
          const ATOMIC t8_real = t7_real + t6_real;
          const ATOMIC t8_imag = t7_imag + t6_imag;

          
          const ATOMIC t9_real = t7_real - t6_real;
          const ATOMIC t9_imag = t7_imag - t6_imag;

          
          const ATOMIC t10_real = sina * t3_real + sinb * t4_real;
          const ATOMIC t10_imag = sina * t3_imag + sinb * t4_imag;

          
          const ATOMIC t11_real = sinb * t3_real - sina * t4_real;
          const ATOMIC t11_imag = sinb * t3_imag - sina * t4_imag;

          
          const ATOMIC x0_real = z0_real + t5_real;
          const ATOMIC x0_imag = z0_imag + t5_imag;

          
          const ATOMIC x1_real = t8_real - t10_imag;
          const ATOMIC x1_imag = t8_imag + t10_real;

          
          const ATOMIC x2_real = t9_real - t11_imag;
          const ATOMIC x2_imag = t9_imag + t11_real;

          
          const ATOMIC x3_real = t9_real + t11_imag;
          const ATOMIC x3_imag = t9_imag - t11_real;

          
          const ATOMIC x4_real = t8_real + t10_imag;
          const ATOMIC x4_imag = t8_imag - t10_real;

          const size_t to0 = k1 * q + 2 * k - 1;
          const size_t to1 = to0 + m;
          const size_t to2 = to1 + m;
          const size_t to3 = to2 + m;
          const size_t to4 = to3 + m;

          

          
          VECTOR(out,ostride,to0) = x0_real;
          VECTOR(out,ostride,to0 + 1) = x0_imag;

          
          VECTOR(out,ostride,to1) = w1_real * x1_real - w1_imag * x1_imag;
          VECTOR(out,ostride,to1 + 1) = w1_real * x1_imag + w1_imag * x1_real;

          
          VECTOR(out,ostride,to2) = w2_real * x2_real - w2_imag * x2_imag;
          VECTOR(out,ostride,to2 + 1) = w2_real * x2_imag + w2_imag * x2_real;

          
          VECTOR(out,ostride,to3) = w3_real * x3_real - w3_imag * x3_imag;
          VECTOR(out,ostride,to3 + 1) = w3_real * x3_imag + w3_imag * x3_real;

          
          VECTOR(out,ostride,to4) = w4_real * x4_real - w4_imag * x4_imag;
          VECTOR(out,ostride,to4 + 1) = w4_real * x4_imag + w4_imag * x4_real;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k1 = 0; k1 < product_1; k1++)
    {
      const size_t from0 = 5 * k1 * q + q - 1;
      const size_t from1 = from0 + 2 * q;
      const size_t from2 = from1 + 2 * q;

      const ATOMIC z0_real = 2 * VECTOR(in,istride,from0);
      const ATOMIC z0_imag = 2 * VECTOR(in,istride,from0 + 1);

      const ATOMIC z1_real = 2 * VECTOR(in,istride,from1);
      const ATOMIC z1_imag = 2 * VECTOR(in,istride,from1 + 1);

      const ATOMIC z2_real = VECTOR(in,istride,from2);

      const ATOMIC t1_real = z0_real + z1_real;
      const ATOMIC t2_real = (t1_real / 4.0) - z2_real;
      const ATOMIC t3_real = (sqrt (5.0) / 4.0) * (z0_real - z1_real);
      const ATOMIC t4_real = sinb * z0_imag + sina * z1_imag;
      const ATOMIC t5_real = sina * z0_imag - sinb * z1_imag;
      const ATOMIC t6_real = t3_real + t2_real;
      const ATOMIC t7_real = t3_real - t2_real;

      const ATOMIC x0_real = t1_real + z2_real;
      const ATOMIC x1_real = t6_real - t4_real;
      const ATOMIC x2_real = t7_real - t5_real;
      const ATOMIC x3_real = -t7_real - t5_real;
      const ATOMIC x4_real = -t6_real - t4_real;

      const size_t to0 = k1 * q + q - 1;
      const size_t to1 = to0 + m;
      const size_t to2 = to1 + m;
      const size_t to3 = to2 + m;
      const size_t to4 = to3 + m;

      VECTOR(out,ostride,to0) = x0_real;
      VECTOR(out,ostride,to1) = x1_real;
      VECTOR(out,ostride,to2) = x2_real;
      VECTOR(out,ostride,to3) = x3_real;
      VECTOR(out,ostride,to4) = x4_real;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 0; k < q; k++)
    {
      ATOMIC w1_real, w1_imag, w2_real, w2_imag, w3_real, w3_imag, w4_real,
        w4_imag, w5_real, w5_imag;

      if (k == 0)
        {
          w1_real = 1.0;
          w1_imag = 0.0;
          w2_real = 1.0;
          w2_imag = 0.0;
          w3_real = 1.0;
          w3_imag = 0.0;
          w4_real = 1.0;
          w4_imag = 0.0;
          w5_real = 1.0;
          w5_imag = 0.0;
        }
      else
        {
          if (sign == gsl_fft_forward)
            {
              
              w1_real = GSL_REAL(twiddle1[k - 1]);
              w1_imag = GSL_IMAG(twiddle1[k - 1]);
              w2_real = GSL_REAL(twiddle2[k - 1]);
              w2_imag = GSL_IMAG(twiddle2[k - 1]);
              w3_real = GSL_REAL(twiddle3[k - 1]);
              w3_imag = GSL_IMAG(twiddle3[k - 1]);
              w4_real = GSL_REAL(twiddle4[k - 1]);
              w4_imag = GSL_IMAG(twiddle4[k - 1]);
              w5_real = GSL_REAL(twiddle5[k - 1]);
              w5_imag = GSL_IMAG(twiddle5[k - 1]);
            }
          else
            {
              
              w1_real = GSL_REAL(twiddle1[k - 1]);
              w1_imag = -GSL_IMAG(twiddle1[k - 1]);
              w2_real = GSL_REAL(twiddle2[k - 1]);
              w2_imag = -GSL_IMAG(twiddle2[k - 1]);
              w3_real = GSL_REAL(twiddle3[k - 1]);
              w3_imag = -GSL_IMAG(twiddle3[k - 1]);
              w4_real = GSL_REAL(twiddle4[k - 1]);
              w4_imag = -GSL_IMAG(twiddle4[k - 1]);
              w5_real = GSL_REAL(twiddle5[k - 1]);
              w5_imag = -GSL_IMAG(twiddle5[k - 1]);
            }
        }

      for(k1 = 0; k1 < p_1; k1++)
        {
          const ATOMIC z0_real = REAL(in,istride,i);
          const ATOMIC z0_imag = IMAG(in,istride,i);
          const ATOMIC z1_real = REAL(in,istride,i+m);
          const ATOMIC z1_imag = IMAG(in,istride,i+m);
          const ATOMIC z2_real = REAL(in,istride,i+2*m);
          const ATOMIC z2_imag = IMAG(in,istride,i+2*m);
          const ATOMIC z3_real = REAL(in,istride,i+3*m);
          const ATOMIC z3_imag = IMAG(in,istride,i+3*m);
          const ATOMIC z4_real = REAL(in,istride,i+4*m);
          const ATOMIC z4_imag = IMAG(in,istride,i+4*m);
          const ATOMIC z5_real = REAL(in,istride,i+5*m);
          const ATOMIC z5_imag = IMAG(in,istride,i+5*m);

          

          

          
          
          const ATOMIC ta1_real = z2_real + z4_real;
          const ATOMIC ta1_imag = z2_imag + z4_imag;
          
          
          const ATOMIC ta2_real = z0_real - ta1_real / 2;
          const ATOMIC ta2_imag = z0_imag - ta1_imag / 2;
          
          
          const ATOMIC ta3_real = ((int) sign) * tau * (z2_real - z4_real);
          const ATOMIC ta3_imag = ((int) sign) * tau * (z2_imag - z4_imag);
          
          
          const ATOMIC a0_real = z0_real + ta1_real;
          const ATOMIC a0_imag = z0_imag + ta1_imag;
          
          
          const ATOMIC a1_real = ta2_real - ta3_imag;
          const ATOMIC a1_imag = ta2_imag + ta3_real;
          
          
          const ATOMIC a2_real = ta2_real + ta3_imag;
          const ATOMIC a2_imag = ta2_imag - ta3_real;
          
          
          const ATOMIC tb1_real = z5_real + z1_real;
          const ATOMIC tb1_imag = z5_imag + z1_imag;
          
          
          const ATOMIC tb2_real = z3_real - tb1_real / 2;
          const ATOMIC tb2_imag = z3_imag - tb1_imag / 2;
          
          
          const ATOMIC tb3_real = ((int) sign) * tau * (z5_real - z1_real);
          const ATOMIC tb3_imag = ((int) sign) * tau * (z5_imag - z1_imag);
          
          
          const ATOMIC b0_real = z3_real + tb1_real;
          const ATOMIC b0_imag = z3_imag + tb1_imag;
          
          
          const ATOMIC b1_real = tb2_real - tb3_imag;
          const ATOMIC b1_imag = tb2_imag + tb3_real;
          
          
          const ATOMIC b2_real = tb2_real + tb3_imag;
          const ATOMIC b2_imag = tb2_imag - tb3_real;
          
          
          const ATOMIC x0_real = a0_real + b0_real;
          const ATOMIC x0_imag = a0_imag + b0_imag;
          
          
          const ATOMIC x4_real = a1_real + b1_real;
          const ATOMIC x4_imag = a1_imag + b1_imag;
          
          
          const ATOMIC x2_real = a2_real + b2_real;
          const ATOMIC x2_imag = a2_imag + b2_imag;
          
          
          const ATOMIC x3_real = a0_real - b0_real;
          const ATOMIC x3_imag = a0_imag - b0_imag;
          
          
          const ATOMIC x1_real = a1_real - b1_real;
          const ATOMIC x1_imag = a1_imag - b1_imag;
          
          
          const ATOMIC x5_real = a2_real - b2_real;
          const ATOMIC x5_imag = a2_imag - b2_imag;

          
          
          
          REAL(out,ostride,j) = x0_real;
          IMAG(out,ostride,j) = x0_imag;
          
          
          REAL(out,ostride,j+p_1) = w1_real * x1_real - w1_imag * x1_imag;
          IMAG(out,ostride,j+p_1) = w1_real * x1_imag + w1_imag * x1_real;
          
          
          REAL(out,ostride,j+2*p_1) = w2_real * x2_real - w2_imag * x2_imag;
          IMAG(out,ostride,j+2*p_1) = w2_real * x2_imag + w2_imag * x2_real;
          
          
          REAL(out,ostride,j+3*p_1) = w3_real * x3_real - w3_imag * x3_imag;
          IMAG(out,ostride,j+3*p_1) = w3_real * x3_imag + w3_imag * x3_real;
          
          
          REAL(out,ostride,j+4*p_1) = w4_real * x4_real - w4_imag * x4_imag;
          IMAG(out,ostride,j+4*p_1) = w4_real * x4_imag + w4_imag * x4_real;
          
          
          REAL(out,ostride,j+5*p_1) = w5_real * x5_real - w5_imag * x5_imag;
          IMAG(out,ostride,j+5*p_1) = w5_real * x5_imag + w5_imag * x5_real;

          i++;
          j++;
        }
      j += jump;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
      {
        data[stride*i] *= norm;
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nf; i++)
    {
      factor = wavetable->factor[i];
      product_1 = product;
      product *= factor;
      q = n / product;

      tskip = (q + 1) / 2 - 1;

      if (state == 0)
        {
          in = data;
          istride = stride;
          out = scratch;
          ostride = 1;
          state = 1;
        }
      else
        {
          in = scratch;
          istride = 1;
          out = data;
          ostride = stride;
          state = 0;
        }

      if (factor == 2)
        {
          twiddle1 = wavetable->twiddle[i];
          FUNCTION(fft_halfcomplex,pass_2) (in, istride, out, ostride, 
                                            product, n, twiddle1);
        }
      else if (factor == 3)
        {
          twiddle1 = wavetable->twiddle[i];
          twiddle2 = twiddle1 + tskip;
          FUNCTION(fft_halfcomplex,pass_3) (in, istride, out, ostride,
                                            product, n, twiddle1, twiddle2);
        }
      else if (factor == 4)
        {
          twiddle1 = wavetable->twiddle[i];
          twiddle2 = twiddle1 + tskip;
          twiddle3 = twiddle2 + tskip;
          FUNCTION(fft_halfcomplex,pass_4) (in, istride, out, ostride,
                                            product, n, twiddle1, twiddle2, 
                                            twiddle3);
        }
      else if (factor == 5)
        {
          twiddle1 = wavetable->twiddle[i];
          twiddle2 = twiddle1 + tskip;
          twiddle3 = twiddle2 + tskip;
          twiddle4 = twiddle3 + tskip;
          FUNCTION(fft_halfcomplex,pass_5) (in, istride, out, ostride,
                                            product, n, twiddle1, twiddle2, 
                                            twiddle3, twiddle4);
        }
      else
        {
          twiddle1 = wavetable->twiddle[i];
          FUNCTION(fft_halfcomplex,pass_n) (in, istride, out, ostride,
                                            factor, product, n, twiddle1);
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
        {
          data[stride*i] = scratch[i] ;
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 0; k < q; k++)
    {
      ATOMIC w1_real, w1_imag, w2_real, w2_imag, w3_real, w3_imag;

      if (k == 0)
        {
          w1_real = 1.0;
          w1_imag = 0.0;
          w2_real = 1.0;
          w2_imag = 0.0;
          w3_real = 1.0;
          w3_imag = 0.0;
        }
      else
        {
          if (sign == gsl_fft_forward)
            {
              
              w1_real = GSL_REAL(twiddle1[k - 1]);
              w1_imag = GSL_IMAG(twiddle1[k - 1]);
              w2_real = GSL_REAL(twiddle2[k - 1]);
              w2_imag = GSL_IMAG(twiddle2[k - 1]);
              w3_real = GSL_REAL(twiddle3[k - 1]);
              w3_imag = GSL_IMAG(twiddle3[k - 1]);
            }
          else
            {
              
              w1_real = GSL_REAL(twiddle1[k - 1]);
              w1_imag = -GSL_IMAG(twiddle1[k - 1]);
              w2_real = GSL_REAL(twiddle2[k - 1]);
              w2_imag = -GSL_IMAG(twiddle2[k - 1]);
              w3_real = GSL_REAL(twiddle3[k - 1]);
              w3_imag = -GSL_IMAG(twiddle3[k - 1]);
            }
        }

      for(k1 = 0; k1 < p_1; k1++)
        {
          const ATOMIC z0_real = REAL(in,istride,i);
          const ATOMIC z0_imag = IMAG(in,istride,i);
          const ATOMIC z1_real = REAL(in,istride,i+m);
          const ATOMIC z1_imag = IMAG(in,istride,i+m);
          const ATOMIC z2_real = REAL(in,istride,i+2*m);
          const ATOMIC z2_imag = IMAG(in,istride,i+2*m);
          const ATOMIC z3_real = REAL(in,istride,i+3*m);
          const ATOMIC z3_imag = IMAG(in,istride,i+3*m);

          
          
          
          const ATOMIC t1_real = z0_real + z2_real;
          const ATOMIC t1_imag = z0_imag + z2_imag;
          
          
          const ATOMIC t2_real = z1_real + z3_real;
          const ATOMIC t2_imag = z1_imag + z3_imag;
          
          
          const ATOMIC t3_real = z0_real - z2_real;
          const ATOMIC t3_imag = z0_imag - z2_imag;
          
          
          const ATOMIC t4_real = ((int) sign) * (z1_real - z3_real);
          const ATOMIC t4_imag = ((int) sign) * (z1_imag - z3_imag);

            
          const ATOMIC x0_real = t1_real + t2_real;
          const ATOMIC x0_imag = t1_imag + t2_imag;

            
          const ATOMIC x1_real = t3_real - t4_imag;
          const ATOMIC x1_imag = t3_imag + t4_real;

            
          const ATOMIC x2_real = t1_real - t2_real;
          const ATOMIC x2_imag = t1_imag - t2_imag;

            
          const ATOMIC x3_real = t3_real + t4_imag;
          const ATOMIC x3_imag = t3_imag - t4_real;

          

          
          REAL(out,ostride,j) = x0_real;
          IMAG(out,ostride,j) = x0_imag;

          
          REAL(out, ostride, j + p_1) = w1_real * x1_real - w1_imag * x1_imag;
          IMAG(out, ostride, j + p_1) = w1_real * x1_imag + w1_imag * x1_real;
          
          
          REAL(out, ostride, j + 2 * p_1) = w2_real * x2_real - w2_imag * x2_imag;
          IMAG(out, ostride, j + 2 * p_1) = w2_real * x2_imag + w2_imag * x2_real;
          
          
          REAL(out, ostride, j + 3 * p_1) = w3_real * x3_real - w3_imag * x3_imag;
          IMAG(out, ostride, j + 3 * p_1) = w3_real * x3_imag + w3_imag * x3_real;
          
          i++;
          j++;
        }
      j += jump;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k1 = 0; k1 < product_1; k1++)
    {
      

      ATOMIC dw_real = 1.0, dw_imag = 0.0;

      for(e1 = 0; e1 < factor; e1++)
        {
          ATOMIC sum_real = 0.0;
          ATOMIC w_real = 1.0, w_imag = 0.0;

          if (e1 > 0)
            {
              ATOMIC tmp_real = dw_real * cos_d_theta - dw_imag * sin_d_theta;
              ATOMIC tmp_imag = dw_real * sin_d_theta + dw_imag * cos_d_theta;
              dw_real = tmp_real;
              dw_imag = tmp_imag;
            }

          for(e2 = 0; e2 <= factor - e2; e2++)
            {
              ATOMIC z_real, z_imag;

              if (e2 > 0)
                {
                  ATOMIC tmp_real = dw_real * w_real - dw_imag * w_imag;
                  ATOMIC tmp_imag = dw_real * w_imag + dw_imag * w_real;
                  w_real = tmp_real;
                  w_imag = tmp_imag;
                }

              if (e2 == 0)
                {
                  size_t from_idx = factor * k1 * q;
                  z_real = VECTOR(in,istride,from_idx);
                  z_imag = 0.0;
                  sum_real += w_real * z_real - w_imag * z_imag;
                }
              else if (e2 == factor - e2)
                {
                  size_t from_idx = factor * q * k1 + 2 * e2 * q - 1;
                  z_real = VECTOR(in,istride,from_idx);
                  z_imag = 0.0;
                  sum_real += w_real * z_real;
                }
              else
                {
                  size_t from_idx = factor * q * k1 + 2 * e2 * q - 1;
                  z_real = VECTOR(in,istride,from_idx);
                  z_imag = VECTOR(in,istride,from_idx + 1);
                  sum_real += 2 * (w_real * z_real - w_imag * z_imag);
                }

            }

          {
            const size_t to_idx = q * k1 + e1 * m;
            VECTOR(out,ostride,to_idx) = sum_real;
          }
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 1; k < (q + 1) / 2; k++)
    {
      for(k1 = 0; k1 < product_1; k1++)
        {

          ATOMIC dw_real = 1.0, dw_imag = 0.0;

          for(e1 = 0; e1 < factor; e1++)
            {
              ATOMIC z_real, z_imag;
              ATOMIC sum_real = 0.0;
              ATOMIC sum_imag = 0.0;
              ATOMIC w_real = 1.0, w_imag = 0.0;

              if (e1 > 0)
                {
                  ATOMIC t_real = dw_real * cos_d_theta - dw_imag * sin_d_theta;
                  ATOMIC t_imag = dw_real * sin_d_theta + dw_imag * cos_d_theta;
                  dw_real = t_real;
                  dw_imag = t_imag;
                }

              for(e2 = 0; e2 < factor; e2++)
                {

                  if (e2 > 0)
                    {
                      ATOMIC tmp_real = dw_real * w_real - dw_imag * w_imag;
                      ATOMIC tmp_imag = dw_real * w_imag + dw_imag * w_real;
                      w_real = tmp_real;
                      w_imag = tmp_imag;
                    }

                  if (e2 < factor - e2)
                    {
                      const size_t from0 = factor * k1 * q + 2 * k + 2 * e2 * q - 1;
                      z_real = VECTOR(in,istride,from0);
                      z_imag = VECTOR(in,istride,from0 + 1);
                    }
                  else
                    {
                      const size_t from0 = factor * k1 * q - 2 * k + 2 * (factor - e2) * q - 1;
                      z_real = VECTOR(in,istride,from0);
                      z_imag = -VECTOR(in,istride,from0 + 1);
                    }

                  sum_real += w_real * z_real - w_imag * z_imag;
                  sum_imag += w_real * z_imag + w_imag * z_real;
                }

              if (k == 0 || e1 == 0)
                {
                  w_real = 1.0;
                  w_imag = 0.0;
                }
              else
                {
                  size_t tskip = (q + 1) / 2 - 1;
                  w_real = GSL_REAL(twiddle[k - 1 + tskip * (e1 - 1)]);
                  w_imag = GSL_IMAG(twiddle[k - 1 + tskip * (e1 - 1)]);
                }

              {
                const size_t to0 = k1 * q + 2 * k + e1 * m - 1;
                VECTOR(out,ostride,to0) = w_real * sum_real - w_imag * sum_imag;
                VECTOR(out,ostride,to0 + 1) = w_real * sum_imag + w_imag * sum_real;
              }

            }
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k1 = 0; k1 < product_1; k1++)
      {

        ATOMIC dw_real = 1.0, dw_imag = 0.0;
        ATOMIC tw_real = 1.0, tw_imag = 0.0;

        for(e1 = 0; e1 < factor; e1++)
          {
            ATOMIC w_real, w_imag, z_real, z_imag;

            ATOMIC sum_real = 0.0;

            if (e1 > 0)
              {
                ATOMIC tmp_real = tw_real * cos_tw_arg - tw_imag * sin_tw_arg;
                ATOMIC tmp_imag = tw_real * sin_tw_arg + tw_imag * cos_tw_arg;
                tw_real = tmp_real;
                tw_imag = tmp_imag;
              }

            w_real = tw_real;
            w_imag = tw_imag;

            if (e1 > 0)
              {
                ATOMIC t_real = dw_real * cos_d_theta - dw_imag * sin_d_theta;
                ATOMIC t_imag = dw_real * sin_d_theta + dw_imag * cos_d_theta;
                dw_real = t_real;
                dw_imag = t_imag;
              }

            for(e2 = 0; e2 <= factor - e2 - 1; e2++)
              {

                if (e2 > 0)
                  {
                    ATOMIC tmp_real = dw_real * w_real - dw_imag * w_imag;
                    ATOMIC tmp_imag = dw_real * w_imag + dw_imag * w_real;
                    w_real = tmp_real;
                    w_imag = tmp_imag;
                  }


                if (e2 == factor - e2 - 1)
                  {
                    const size_t from0 = factor * k1 * q + q + 2 * e2 * q - 1;
                    z_real = VECTOR(in,istride,from0);
                    z_imag = 0.0;
                    sum_real += w_real * z_real - w_imag * z_imag;
                  }
                else
                  {
                    const size_t from0 = factor * k1 * q + q + 2 * e2 * q - 1;
                    z_real = VECTOR(in,istride,from0);
                    z_imag = VECTOR(in,istride,from0 + 1);
                    sum_real += 2 * (w_real * z_real - w_imag * z_imag);
                  }

              }

            {
              const size_t to0 = k1 * q + q + e1 * m - 1;
              VECTOR(out,ostride,to0) = sum_real;
            }
          }
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k1 = 0; k1 < q; k1++)
    {
      

      ATOMIC dw_real = 1.0, dw_imag = 0.0;

      for(e1 = 0; e1 <= factor - e1; e1++)
        {
          ATOMIC sum_real = 0.0;
          ATOMIC sum_imag = 0.0;

          ATOMIC w_real = 1.0, w_imag = 0.0;

          if (e1 > 0)
            {
              ATOMIC tmp_real = dw_real * cos_d_theta + dw_imag * sin_d_theta;
              ATOMIC tmp_imag = -dw_real * sin_d_theta + dw_imag * cos_d_theta;
              dw_real = tmp_real;
              dw_imag = tmp_imag;
            }

          for(e2 = 0; e2 < factor; e2++)
            {
              ATOMIC z_real = VECTOR(in,istride,k1 * product_1 + e2 * m);

              if (e2 > 0)
                {
                  ATOMIC tmp_real = dw_real * w_real - dw_imag * w_imag;
                  ATOMIC tmp_imag = dw_real * w_imag + dw_imag * w_real;
                  w_real = tmp_real;
                  w_imag = tmp_imag;
                }

              sum_real += w_real * z_real;
              sum_imag += w_imag * z_real;

            }
          if (e1 == 0)
            {
              const size_t to0 = product * k1;
              VECTOR(out,ostride,to0) = sum_real;
            }
          else if (e1 < factor - e1)
            {
              const size_t to0 = k1 * product + 2 * e1 * product_1 - 1;
              VECTOR(out,ostride,to0) = sum_real;
              VECTOR(out,ostride,to0 + 1) = sum_imag;
            }
          else if (e1 == factor - e1)
            {
              const size_t to0 = k1 * product + 2 * e1 * product_1 - 1;
              VECTOR(out,ostride,to0) = sum_real;
            }

        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 1; k < (product_1 + 1) / 2; k++)
    {
      for(k1 = 0; k1 < q; k1++)
        {

          ATOMIC dw_real = 1.0, dw_imag = 0.0;

          for(e1 = 0; e1 < factor; e1++)
            {
              ATOMIC sum_real = 0.0, sum_imag = 0.0;

              ATOMIC w_real = 1.0, w_imag = 0.0;

              if (e1 > 0)
                {
                  const ATOMIC tmp_real = dw_real * cos_d_theta + dw_imag * sin_d_theta;
                  const ATOMIC tmp_imag = -dw_real * sin_d_theta + dw_imag * cos_d_theta;
                  dw_real = tmp_real;
                  dw_imag = tmp_imag;
                }

              for(e2 = 0; e2 < factor; e2++)
                {

                  int tskip = (product_1 + 1) / 2 - 1;
                  const size_t from0 = k1 * product_1 + 2 * k + e2 * m - 1;
                  ATOMIC tw_real, tw_imag;
                  ATOMIC z_real, z_imag;

                  if (e2 == 0)
                    {
                      tw_real = 1.0;
                      tw_imag = 0.0;
                    }
                  else
                    {
                      const size_t t_index = (k - 1) + (e2 - 1) * tskip;
                      tw_real = GSL_REAL(twiddle[t_index]);
                      tw_imag = -GSL_IMAG(twiddle[t_index]);
                    }

                  {
                    const ATOMIC f0_real = VECTOR(in,istride,from0);
                    const ATOMIC f0_imag = VECTOR(in,istride,from0 + 1);

                    z_real = tw_real * f0_real - tw_imag * f0_imag;
                    z_imag = tw_real * f0_imag + tw_imag * f0_real;
                  }

                  if (e2 > 0)
                    {
                      const ATOMIC tmp_real = dw_real * w_real - dw_imag * w_imag;
                      const ATOMIC tmp_imag = dw_real * w_imag + dw_imag * w_real;
                      w_real = tmp_real;
                      w_imag = tmp_imag;
                    }

                  sum_real += w_real * z_real - w_imag * z_imag;
                  sum_imag += w_real * z_imag + w_imag * z_real;
                }

              if (e1 < factor - e1)
                {
                  const size_t to0 = k1 * product - 1 + 2 * e1 * product_1 + 2 * k;
                  VECTOR(out,ostride,to0) = sum_real;
                  VECTOR(out,ostride,to0 + 1) = sum_imag;
                }
              else
                {
                  const size_t to0 = k1 * product - 1 + 2 * (factor - e1) * product_1 - 2 * k;
                  VECTOR(out,ostride,to0) = sum_real;
                  VECTOR(out,ostride,to0 + 1) = -sum_imag;
                }

            }
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k1 = 0; k1 < q; k1++)
      {
        ATOMIC dw_real = 1.0, dw_imag = 0.0;

        for(e1 = 0; e1 < factor; e1++)
          {
            ATOMIC z_real, z_imag;

            ATOMIC sum_real = 0.0;
            ATOMIC sum_imag = 0.0;

            ATOMIC w_real = 1.0, w_imag = 0.0;
            ATOMIC tw_real = 1.0, tw_imag = 0.0;

            if (e1 > 0)
              {
                ATOMIC t_real = dw_real * cos_d_theta + dw_imag * sin_d_theta;
                ATOMIC t_imag = -dw_real * sin_d_theta + dw_imag * cos_d_theta;
                dw_real = t_real;
                dw_imag = t_imag;
              }

            for(e2 = 0; e2 < factor; e2++)
              {

                if (e2 > 0)
                  {
                    ATOMIC tmp_real = tw_real * cos_tw_arg - tw_imag * sin_tw_arg;
                    ATOMIC tmp_imag = tw_real * sin_tw_arg + tw_imag * cos_tw_arg;
                    tw_real = tmp_real;
                    tw_imag = tmp_imag;
                  }

                if (e2 > 0)
                  {
                    ATOMIC tmp_real = dw_real * w_real - dw_imag * w_imag;
                    ATOMIC tmp_imag = dw_real * w_imag + dw_imag * w_real;
                    w_real = tmp_real;
                    w_imag = tmp_imag;
                  }


                {
                  const size_t from0 = k1 * product_1 + 2 * k + e2 * m - 1;
                  const ATOMIC f0_real = VECTOR(in,istride,from0);
                  z_real = tw_real * f0_real;
                  z_imag = tw_imag * f0_real;
                }

                sum_real += w_real * z_real - w_imag * z_imag;
                sum_imag += w_real * z_imag + w_imag * z_real;
              }

            if (e1 + 1 < factor - e1)
              {
                const size_t to0 = k1 * product - 1 + 2 * e1 * product_1 + 2 * k;
                VECTOR(out,ostride,to0) = sum_real;
                VECTOR(out,ostride,to0 + 1) = sum_imag;
              }
            else if (e1 + 1 == factor - e1)
              {
                const size_t to0 = k1 * product - 1 + 2 * e1 * product_1 + 2 * k;
                VECTOR(out,ostride,to0) = sum_real;
              }
            else
              {
                const size_t to0 = k1 * product - 1 + 2 * (factor - e1) * product_1 - 2 * k;
                VECTOR(out,ostride,to0) = sum_real;
                VECTOR(out,ostride,to0 + 1) = -sum_imag;
              }

          }
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
      {
        REAL(data,stride,i) *= norm;
        IMAG(data,stride,i) *= norm;
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(bit = 0; bit < logn; bit++)
    {
      ATOMIC w_real = 1.0;
      ATOMIC w_imag = 0.0;

      const double theta = 2.0 * ((int) sign) * M_PI / (2.0 * (double) dual);

      const ATOMIC s = sin (theta);
      const ATOMIC t = sin (theta / 2.0);
      const ATOMIC s2 = 2.0 * t * t;

      size_t a, b;

      

      for(b = 0; b < n; b += 2 * dual)
        {
          const size_t i = b ;
          const size_t j = b + dual;
          
          const ATOMIC z1_real = REAL(data,stride,j) ;
          const ATOMIC z1_imag = IMAG(data,stride,j) ;

          const ATOMIC wd_real = z1_real ;
          const ATOMIC wd_imag = z1_imag ;
          
          REAL(data,stride,j) = REAL(data,stride,i) - wd_real;
          IMAG(data,stride,j) = IMAG(data,stride,i) - wd_imag;
          REAL(data,stride,i) += wd_real;
          IMAG(data,stride,i) += wd_imag;
        }
      
      

      for(a = 1; a < dual; a++)
        {

          

          {
            const ATOMIC tmp_real = w_real - s * w_imag - s2 * w_real;
            const ATOMIC tmp_imag = w_imag + s * w_real - s2 * w_imag;
            w_real = tmp_real;
            w_imag = tmp_imag;
          }

          for(b = 0; b < n; b += 2 * dual)
            {
              const size_t i = b + a;
              const size_t j = b + a + dual;

              const ATOMIC z1_real = REAL(data,stride,j) ;
              const ATOMIC z1_imag = IMAG(data,stride,j) ;
              
              const ATOMIC wd_real = w_real * z1_real - w_imag * z1_imag;
              const ATOMIC wd_imag = w_real * z1_imag + w_imag * z1_real;

              REAL(data,stride,j) = REAL(data,stride,i) - wd_real;
              IMAG(data,stride,j) = IMAG(data,stride,i) - wd_imag;
              REAL(data,stride,i) += wd_real;
              IMAG(data,stride,i) += wd_imag;
            }
        }
      dual *= 2;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
      {
        REAL(data,stride,i) *= norm;
        IMAG(data,stride,i) *= norm;
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(bit = 0; bit < logn; bit++)
    {
      ATOMIC w_real = 1.0;
      ATOMIC w_imag = 0.0;

      const double theta = 2.0 * ((int) sign) * M_PI / ((double) (2 * dual));

      const ATOMIC s = sin (theta);
      const ATOMIC t = sin (theta / 2.0);
      const ATOMIC s2 = 2.0 * t * t;

      size_t a, b;

      for(b = 0; b < dual; b++)
        {
          for(a = 0; a < n; a+= 2 * dual)
            {
              const size_t i = b + a;
              const size_t j = b + a + dual;
              
              const ATOMIC t1_real = REAL(data,stride,i) + REAL(data,stride,j);
              const ATOMIC t1_imag = IMAG(data,stride,i) + IMAG(data,stride,j);
              const ATOMIC t2_real = REAL(data,stride,i) - REAL(data,stride,j);
              const ATOMIC t2_imag = IMAG(data,stride,i) - IMAG(data,stride,j);

              REAL(data,stride,i) = t1_real;
              IMAG(data,stride,i) = t1_imag;
              REAL(data,stride,j) = w_real*t2_real - w_imag * t2_imag;
              IMAG(data,stride,j) = w_real*t2_imag + w_imag * t2_real;
            }

          

          {
            const ATOMIC tmp_real = w_real - s * w_imag - s2 * w_real;
            const ATOMIC tmp_imag = w_imag + s * w_real - s2 * w_imag;
            w_real = tmp_real;
            w_imag = tmp_imag;
          }
        }
      dual /= 2;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 0; k < q; k++)
    {

      ATOMIC w1_real, w1_imag, w2_real, w2_imag, w3_real, w3_imag, w4_real,
        w4_imag;

      if (k == 0)
        {
          w1_real = 1.0;
          w1_imag = 0.0;
          w2_real = 1.0;
          w2_imag = 0.0;
          w3_real = 1.0;
          w3_imag = 0.0;
          w4_real = 1.0;
          w4_imag = 0.0;
        }
      else
        {
          if (sign == gsl_fft_forward)
            {
              
              w1_real = GSL_REAL(twiddle1[k - 1]);
              w1_imag = GSL_IMAG(twiddle1[k - 1]);
              w2_real = GSL_REAL(twiddle2[k - 1]);
              w2_imag = GSL_IMAG(twiddle2[k - 1]);
              w3_real = GSL_REAL(twiddle3[k - 1]);
              w3_imag = GSL_IMAG(twiddle3[k - 1]);
              w4_real = GSL_REAL(twiddle4[k - 1]);
              w4_imag = GSL_IMAG(twiddle4[k - 1]);
            }
          else
            {
              
              w1_real = GSL_REAL(twiddle1[k - 1]);
              w1_imag = -GSL_IMAG(twiddle1[k - 1]);
              w2_real = GSL_REAL(twiddle2[k - 1]);
              w2_imag = -GSL_IMAG(twiddle2[k - 1]);
              w3_real = GSL_REAL(twiddle3[k - 1]);
              w3_imag = -GSL_IMAG(twiddle3[k - 1]);
              w4_real = GSL_REAL(twiddle4[k - 1]);
              w4_imag = -GSL_IMAG(twiddle4[k - 1]);
            }
        }

      for(k1 = 0; k1 < p_1; k1++)
        {

          ATOMIC x0_real, x0_imag, x1_real, x1_imag, x2_real, x2_imag,
            x3_real, x3_imag, x4_real, x4_imag;

          const ATOMIC z0_real = REAL(in,istride,i);
          const ATOMIC z0_imag = IMAG(in,istride,i);
          const ATOMIC z1_real = REAL(in,istride,i + m);
          const ATOMIC z1_imag = IMAG(in,istride,i + m);
          const ATOMIC z2_real = REAL(in,istride,i + 2*m);
          const ATOMIC z2_imag = IMAG(in,istride,i + 2*m);
          const ATOMIC z3_real = REAL(in,istride,i + 3*m);
          const ATOMIC z3_imag = IMAG(in,istride,i + 3*m);
          const ATOMIC z4_real = REAL(in,istride,i + 4*m);
          const ATOMIC z4_imag = IMAG(in,istride,i + 4*m);

          

          
          const ATOMIC t1_real = z1_real + z4_real;
          const ATOMIC t1_imag = z1_imag + z4_imag;
          
          
          const ATOMIC t2_real = z2_real + z3_real;
          const ATOMIC t2_imag = z2_imag + z3_imag;
          
          
          const ATOMIC t3_real = z1_real - z4_real;
          const ATOMIC t3_imag = z1_imag - z4_imag;
          
          
          const ATOMIC t4_real = z2_real - z3_real;
          const ATOMIC t4_imag = z2_imag - z3_imag;
          
          
          const ATOMIC t5_real = t1_real + t2_real;
          const ATOMIC t5_imag = t1_imag + t2_imag;
          
          
          const ATOMIC t6_real = (sqrt (5.0) / 4.0) * (t1_real - t2_real);
          const ATOMIC t6_imag = (sqrt (5.0) / 4.0) * (t1_imag - t2_imag);
          
          
          const ATOMIC t7_real = z0_real - t5_real / 4.0;
          const ATOMIC t7_imag = z0_imag - t5_imag / 4.0;
          
          
          const ATOMIC t8_real = t7_real + t6_real;
          const ATOMIC t8_imag = t7_imag + t6_imag;
          
          
          const ATOMIC t9_real = t7_real - t6_real;
          const ATOMIC t9_imag = t7_imag - t6_imag;
          
          
          const ATOMIC t10_real = ((int) sign) * (sin_2pi_by_5 * t3_real +
                                                  sin_2pi_by_10 * t4_real);
          const ATOMIC t10_imag = ((int) sign) * (sin_2pi_by_5 * t3_imag +
                                                  sin_2pi_by_10 * t4_imag);
          
          
          const ATOMIC t11_real = ((int) sign) * (sin_2pi_by_10 * t3_real -
                                                  sin_2pi_by_5 * t4_real);
          const ATOMIC t11_imag = ((int) sign) * (sin_2pi_by_10 * t3_imag -
                                                  sin_2pi_by_5 * t4_imag);
          
          
          x0_real = z0_real + t5_real;
          x0_imag = z0_imag + t5_imag;
          
          
          x1_real = t8_real - t10_imag;
          x1_imag = t8_imag + t10_real;
          
          
          x2_real = t9_real - t11_imag;
          x2_imag = t9_imag + t11_real;
          
          
          x3_real = t9_real + t11_imag;
          x3_imag = t9_imag - t11_real;
          
          
          x4_real = t8_real + t10_imag;
          x4_imag = t8_imag - t10_real;
      
          
          
          
          REAL(out,ostride,j) = x0_real;
          IMAG(out,ostride,j) = x0_imag;
          
          
          REAL(out,ostride,j + p_1) = w1_real * x1_real - w1_imag * x1_imag;
          IMAG(out,ostride,j + p_1) = w1_real * x1_imag + w1_imag * x1_real;
          
          
          REAL(out,ostride,j + 2*p_1) = w2_real * x2_real - w2_imag * x2_imag;
          IMAG(out,ostride,j+2*p_1) = w2_real * x2_imag + w2_imag * x2_real;
          
          
          REAL(out,ostride,j+3*p_1) = w3_real * x3_real - w3_imag * x3_imag;
          IMAG(out,ostride,j+3*p_1) = w3_real * x3_imag + w3_imag * x3_real;
          
          
          REAL(out,ostride,j+4*p_1) = w4_real * x4_real - w4_imag * x4_imag;
          IMAG(out,ostride,j+4*p_1) = w4_real * x4_imag + w4_imag * x4_real;
          
          i++;
          j++;
        }
      j += jump;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k1 = 0; k1 < product_1; k1++)
    {
      const size_t from0 = 4 * k1 * q;
      const size_t from1 = from0 + 2 * q - 1;
      const size_t from2 = from1 + 2 * q;

      const ATOMIC z0_real = VECTOR(in,istride,from0);
      const ATOMIC z1_real = VECTOR(in,istride,from1);
      const ATOMIC z1_imag = VECTOR(in,istride,from1 + 1);
      const ATOMIC z2_real = VECTOR(in,istride,from2);

      const ATOMIC t1_real = z0_real + z2_real;
      const ATOMIC t2_real = 2 * z1_real;
      const ATOMIC t3_real = z0_real - z2_real;
      const ATOMIC t4_imag = 2 * z1_imag;

      const size_t to0 = q * k1;
      const size_t to1 = to0 + m;
      const size_t to2 = to1 + m;
      const size_t to3 = to2 + m;

      VECTOR(out,ostride,to0) = t1_real + t2_real;
      VECTOR(out,ostride,to1) = t3_real - t4_imag;
      VECTOR(out,ostride,to2) = t1_real - t2_real;
      VECTOR(out,ostride,to3) = t3_real + t4_imag;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 1; k < (q + 1) / 2; k++)
    {
      const ATOMIC w1_real = GSL_REAL(twiddle1[k - 1]);
      const ATOMIC w1_imag = GSL_IMAG(twiddle1[k - 1]);
      const ATOMIC w2_real = GSL_REAL(twiddle2[k - 1]);
      const ATOMIC w2_imag = GSL_IMAG(twiddle2[k - 1]);
      const ATOMIC w3_real = GSL_REAL(twiddle3[k - 1]);
      const ATOMIC w3_imag = GSL_IMAG(twiddle3[k - 1]);

      for(k1 = 0; k1 < product_1; k1++)
        {
          const size_t from0 = 4 * k1 * q + 2 * k - 1;
          const size_t from1 = from0 + 2 * q;
          const size_t from2 = 4 * k1 * q - 2 * k + 2 * q - 1;
          const size_t from3 = from2 + 2 * q;

          const ATOMIC z0_real = VECTOR(in,istride,from0);
          const ATOMIC z0_imag = VECTOR(in,istride,from0 + 1);

          const ATOMIC z1_real = VECTOR(in,istride,from1);
          const ATOMIC z1_imag = VECTOR(in,istride,from1 + 1);

          const ATOMIC z2_real = VECTOR(in,istride,from3);
          const ATOMIC z2_imag = -VECTOR(in,istride,from3 + 1);

          const ATOMIC z3_real = VECTOR(in,istride,from2);
          const ATOMIC z3_imag = -VECTOR(in,istride,from2 + 1);

          

          
          const ATOMIC t1_real = z0_real + z2_real;
          const ATOMIC t1_imag = z0_imag + z2_imag;

          
          const ATOMIC t2_real = z1_real + z3_real;
          const ATOMIC t2_imag = z1_imag + z3_imag;

          
          const ATOMIC t3_real = z0_real - z2_real;
          const ATOMIC t3_imag = z0_imag - z2_imag;

          
          const ATOMIC t4_real = (z1_real - z3_real);
          const ATOMIC t4_imag = (z1_imag - z3_imag);

          
          const ATOMIC x0_real = t1_real + t2_real;
          const ATOMIC x0_imag = t1_imag + t2_imag;

          
          const ATOMIC x1_real = t3_real - t4_imag;
          const ATOMIC x1_imag = t3_imag + t4_real;

          
          const ATOMIC x2_real = t1_real - t2_real;
          const ATOMIC x2_imag = t1_imag - t2_imag;

          
          const ATOMIC x3_real = t3_real + t4_imag;
          const ATOMIC x3_imag = t3_imag - t4_real;

          const size_t to0 = k1 * q + 2 * k - 1;
          const size_t to1 = to0 + m;
          const size_t to2 = to1 + m;
          const size_t to3 = to2 + m;

          VECTOR(out,ostride,to0) = x0_real;
          VECTOR(out,ostride,to0 + 1) = x0_imag;

          VECTOR(out,ostride,to1) = w1_real * x1_real - w1_imag * x1_imag;
          VECTOR(out,ostride,to1 + 1) = w1_imag * x1_real + w1_real * x1_imag;

          VECTOR(out,ostride,to2) = w2_real * x2_real - w2_imag * x2_imag;
          VECTOR(out,ostride,to2 + 1) = w2_imag * x2_real + w2_real * x2_imag;

          
          VECTOR(out,ostride,to3) = w3_real * x3_real - w3_imag * x3_imag;
          VECTOR(out,ostride,to3 + 1) = w3_real * x3_imag + w3_imag * x3_real;

        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k1 = 0; k1 < product_1; k1++)
    {
      const size_t from0 = 4 * k1 * q + q - 1;
      const size_t from1 = from0 + 2 * q;

      const ATOMIC z0_real = VECTOR(in,istride,from0);
      const ATOMIC z0_imag = VECTOR(in,istride,from0 + 1);

      const ATOMIC z1_real = VECTOR(in,istride,from1);
      const ATOMIC z1_imag = VECTOR(in,istride,from1 + 1);

      const ATOMIC t1_real = sqrt (2.0) * (z0_imag + z1_imag);
      const ATOMIC t2_real = sqrt (2.0) * (z0_real - z1_real);

      const ATOMIC x0_real = 2 * (z0_real + z1_real);
      const ATOMIC x1_real = t2_real - t1_real;
      const ATOMIC x2_real = 2 * (z1_imag - z0_imag);
      const ATOMIC x3_real = -(t2_real + t1_real);

      const size_t to0 = k1 * q + q - 1;
      const size_t to1 = to0 + m;
      const size_t to2 = to1 + m;
      const size_t to3 = to2 + m;

      VECTOR(out,ostride,to0) = x0_real;
      VECTOR(out,ostride,to1) = x1_real;
      VECTOR(out,ostride,to2) = x2_real;
      VECTOR(out,ostride,to3) = x3_real;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nf; i++)
      {
        product *= factors[i];
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < n; j++)
    {
      REAL(data,stride,j) = 0.0;
      IMAG(data,stride,j) = 0.0;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < n; j++)
    {
      const double arg = -2 * M_PI * ((double) ((j * k) % n)) / ((double) n);
      const BASE w_real = (BASE)cos (arg);
      const BASE w_imag = (BASE)sin (arg);
      REAL(fft,stride,j) = w_real * z_real - w_imag * z_imag;
      IMAG(fft,stride,j) = w_real * z_imag + w_imag * z_real;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < n; j++)
    {
      REAL(data,stride,j) = z_real;
      IMAG(data,stride,j) = z_imag;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < n; j++)
    {
      REAL(fft,stride,j) = 0.0;
      IMAG(fft,stride,j) = 0.0;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < n; j++)
    {
      const double arg = 2 * M_PI * ((double) ((j * k) % n)) / ((double) n);
      const BASE w_real = (BASE)cos (arg);
      const BASE w_imag = (BASE)sin (arg);
      REAL(data,stride,j) = w_real * z_real - w_imag * z_imag;
      IMAG(data,stride,j) = w_real * z_imag + w_imag * z_real;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < n; j++)
    {
      REAL(fft,stride,j) = 0.0;
      IMAG(fft,stride,j) = 0.0;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < n; j++)
    {
      const double arg1 = 2 * M_PI * ((double) ((j * k1) % n)) / ((double) n);
      const BASE w1_real = (BASE)cos (arg1);
      const BASE w1_imag = (BASE)sin (arg1);
      const double arg2 = 2 * M_PI * ((double) ((j * k2) % n)) / ((double) n);
      const BASE w2_real = (BASE)cos (arg2);
      const BASE w2_imag = (BASE)sin (arg2);
      REAL(data,stride,j) = w1_real * z1_real - w1_imag * z1_imag;
      IMAG(data,stride,j) = w1_real * z1_imag + w1_imag * z1_real;
      REAL(data,stride,j) += w2_real * z2_real - w2_imag * z2_imag;
      IMAG(data,stride,j) += w2_real * z2_imag + w2_imag * z2_real;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < n; j++)
    {
      REAL(fft,stride,j) = 0.0;
      IMAG(fft,stride,j) = 0.0;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
    {
      REAL(data,stride,i) = (BASE)urand();
      IMAG(data,stride,i) = (BASE)urand();
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
    {
      REAL(data,stride,i) = (BASE)urand();
      IMAG(data,stride,i) = 0.0;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
    {
      dr = b[2*stride*i] - a[2*stride*i];
      di = b[2*stride*i+1] - a[2*stride*i+1];
      ticks = (fabs (dr) + fabs (di)) / BASE_EPSILON;
      if (ticks > max_ticks)
        {
          max_ticks = ticks;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
    {
      dr = b[2*stride*i] - a[2*stride*i];
      di = b[2*stride*i+1] - a[2*stride*i+1];
      ticks = (fabs (dr) + fabs (di)) / BASE_EPSILON;

      if (ticks > 1000)
        {
          flag = "***";
        }
      else
        {
          flag = "";
        }

      printf ("%15s: %d  %.16f %.16f %s\n", name_a, (int)i,
              a[2*stride*i], a[2*stride*i+1], flag);
      printf ("%15s: %d  %.16f %.16f %e %s\n", name_b, (int)i,
              b[2*stride*i], b[2*stride*i+1], ticks, flag);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
    {
      dr = b[stride*i] - a[stride*i];
      ticks = fabs (dr) / BASE_EPSILON;
      if (ticks > max_ticks)
        {
          max_ticks = ticks;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
    {
      dr = b[stride*i] - a[stride*i];
      ticks = fabs (dr) / BASE_EPSILON;

      if (ticks > 1000)
        {
          flag = "***";
        }
      else
        {
          flag = "";
        }

      printf ("%15s: %d  %.16f %s\n", name_a, (int)i, 
              a[stride*i], flag);
      printf ("%15s: %d  %.16f %e %s\n", name_b, (int)i, 
              b[stride*i], ticks, flag);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nf; i++)
    {
      const size_t factor = wavetable->factor[i];
      product_1 = product;
      product *= factor;
      q = n / product;

      tskip = (product_1 + 1) / 2 - 1;

      if (state == 0)
        {
          in = data;
          istride = stride;
          out = scratch;
          ostride = 1;
          state = 1;
        }
      else
        {
          in = scratch;
          istride = 1;
          out = data;
          ostride = stride;
          state = 0;
        }

      if (factor == 2)
        {
          twiddle1 = wavetable->twiddle[i];
          FUNCTION(fft_real,pass_2) (in, istride, out, ostride, product, n, twiddle1);
        }
      else if (factor == 3)
        {
          twiddle1 = wavetable->twiddle[i];
          twiddle2 = twiddle1 + tskip;
          FUNCTION(fft_real,pass_3) (in, istride, out, ostride, product, n, twiddle1,
                               twiddle2);
        }
      else if (factor == 4)
        {
          twiddle1 = wavetable->twiddle[i];
          twiddle2 = twiddle1 + tskip;
          twiddle3 = twiddle2 + tskip;
          FUNCTION(fft_real,pass_4) (in, istride, out, ostride, product, n, twiddle1,
                                     twiddle2, twiddle3);
        }
      else if (factor == 5)
        {
          twiddle1 = wavetable->twiddle[i];
          twiddle2 = twiddle1 + tskip;
          twiddle3 = twiddle2 + tskip;
          twiddle4 = twiddle3 + tskip;
          FUNCTION(fft_real,pass_5) (in, istride, out, ostride, product, n, twiddle1,
                                     twiddle2, twiddle3, twiddle4);
        }
      else
        {
          twiddle1 = wavetable->twiddle[i];
          FUNCTION(fft_real,pass_n) (in, istride, out, ostride, factor, product, n,
                                     twiddle1);
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
        {
          data[stride*i] = scratch[i] ;
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
      {
        REAL(result,stride,i) *= norm;
        IMAG(result,stride,i) *= norm;
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
    {
      ATOMIC sum_real = 0;
      ATOMIC sum_imag = 0;

      exponent = 0;

      for(j = 0; j < n; j++)
        {
          double theta = d_theta * (double) exponent;
          

          ATOMIC w_real = (ATOMIC) cos (theta);
          ATOMIC w_imag = (ATOMIC) sin (theta);

          ATOMIC data_real = REAL(data,stride,j);
          ATOMIC data_imag = IMAG(data,stride,j);

          sum_real += w_real * data_real - w_imag * data_imag;
          sum_imag += w_real * data_imag + w_imag * data_real;

          exponent = (exponent + i) % n;
        }
      REAL(result,stride,i) = sum_real;
      IMAG(result,stride,i) = sum_imag;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k1 = 0; k1 < product_1; k1++)
    {
      const ATOMIC r0 = VECTOR(in,istride,2 * k1 * q);
      const ATOMIC r1 = VECTOR(in,istride,2 * k1 * q + 2 * q - 1);

      const ATOMIC s0 = r0 + r1;
      const ATOMIC s1 = r0 - r1;

      VECTOR(out,ostride,q * k1) = s0;
      VECTOR(out,ostride,q * k1 + m) = s1;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 1; k < (q + 1) / 2; k++)
    {
      const ATOMIC w_real = GSL_REAL(twiddle[k - 1]);
      const ATOMIC w_imag = GSL_IMAG(twiddle[k - 1]);

      for(k1 = 0; k1 < product_1; k1++)
        {
          const size_t from0 = 2 * k1 * q + 2 * k - 1;
          const size_t from1 = 2 * k1 * q - 2 * k + 2 * q - 1;

          const ATOMIC z0_real = VECTOR(in,istride,from0);
          const ATOMIC z0_imag = VECTOR(in,istride,from0 + 1);

          const ATOMIC z1_real = VECTOR(in,istride,from1);
          const ATOMIC z1_imag = VECTOR(in,istride,from1 + 1);

          

          
          const ATOMIC x0_real = z0_real + z1_real;
          const ATOMIC x0_imag = z0_imag - z1_imag;

          
          const ATOMIC x1_real = z0_real - z1_real;
          const ATOMIC x1_imag = z0_imag + z1_imag;

          const size_t to0 = k1 * q + 2 * k - 1;
          const size_t to1 = to0 + m;

          VECTOR(out,ostride,to0) = x0_real;
          VECTOR(out,ostride,to0 + 1) = x0_imag;

          VECTOR(out,ostride,to1) = w_real * x1_real - w_imag * x1_imag;
          VECTOR(out,ostride,to1 + 1) = w_imag * x1_real + w_real * x1_imag;

        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k1 = 0; k1 < product_1; k1++)
    {
      const size_t from0 = 2 * k1 * q + q - 1;
      const size_t to0 = k1 * q + q - 1;
      const size_t to1 = to0 + m;

      VECTOR(out,ostride,to0) = 2 * VECTOR(in,istride,from0);
      VECTOR(out,ostride,to1) = -2 * VECTOR(in,istride,from0 + 1);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 0; k < q; k++)
    {
      ATOMIC w1_real, w1_imag, w2_real, w2_imag, w3_real, w3_imag, w4_real,
        w4_imag, w5_real, w5_imag, w6_real, w6_imag;

      if (k == 0)
        {
          w1_real = 1.0;
          w1_imag = 0.0;
          w2_real = 1.0;
          w2_imag = 0.0;
          w3_real = 1.0;
          w3_imag = 0.0;
          w4_real = 1.0;
          w4_imag = 0.0;
          w5_real = 1.0;
          w5_imag = 0.0;
          w6_real = 1.0;
          w6_imag = 0.0;
        }
      else
        {
          if (sign == gsl_fft_forward)
            {
              
              w1_real = GSL_REAL(twiddle1[k - 1]);
              w1_imag = GSL_IMAG(twiddle1[k - 1]);
              w2_real = GSL_REAL(twiddle2[k - 1]);
              w2_imag = GSL_IMAG(twiddle2[k - 1]);
              w3_real = GSL_REAL(twiddle3[k - 1]);
              w3_imag = GSL_IMAG(twiddle3[k - 1]);
              w4_real = GSL_REAL(twiddle4[k - 1]);
              w4_imag = GSL_IMAG(twiddle4[k - 1]);
              w5_real = GSL_REAL(twiddle5[k - 1]);
              w5_imag = GSL_IMAG(twiddle5[k - 1]);
              w6_real = GSL_REAL(twiddle6[k - 1]);
              w6_imag = GSL_IMAG(twiddle6[k - 1]);
            }
          else
            {
              
              w1_real = GSL_REAL(twiddle1[k - 1]);
              w1_imag = -GSL_IMAG(twiddle1[k - 1]);
              w2_real = GSL_REAL(twiddle2[k - 1]);
              w2_imag = -GSL_IMAG(twiddle2[k - 1]);
              w3_real = GSL_REAL(twiddle3[k - 1]);
              w3_imag = -GSL_IMAG(twiddle3[k - 1]);
              w4_real = GSL_REAL(twiddle4[k - 1]);
              w4_imag = -GSL_IMAG(twiddle4[k - 1]);
              w5_real = GSL_REAL(twiddle5[k - 1]);
              w5_imag = -GSL_IMAG(twiddle5[k - 1]);
              w6_real = GSL_REAL(twiddle6[k - 1]);
              w6_imag = -GSL_IMAG(twiddle6[k - 1]);
            }
        }

      for(k1 = 0; k1 < p_1; k1++)
        {
          const ATOMIC z0_real = REAL(in,istride,i);
          const ATOMIC z0_imag = IMAG(in,istride,i);
          const ATOMIC z1_real = REAL(in,istride,i+m);
          const ATOMIC z1_imag = IMAG(in,istride,i+m);
          const ATOMIC z2_real = REAL(in,istride,i+2*m);
          const ATOMIC z2_imag = IMAG(in,istride,i+2*m);
          const ATOMIC z3_real = REAL(in,istride,i+3*m);
          const ATOMIC z3_imag = IMAG(in,istride,i+3*m);
          const ATOMIC z4_real = REAL(in,istride,i+4*m);
          const ATOMIC z4_imag = IMAG(in,istride,i+4*m);
          const ATOMIC z5_real = REAL(in,istride,i+5*m);
          const ATOMIC z5_imag = IMAG(in,istride,i+5*m);
          const ATOMIC z6_real = REAL(in,istride,i+6*m);
          const ATOMIC z6_imag = IMAG(in,istride,i+6*m);

          
          
          
          const ATOMIC t0_real = z1_real + z6_real ;
          const ATOMIC t0_imag = z1_imag + z6_imag ; 
          
          
          const ATOMIC t1_real = z1_real - z6_real ;
          const ATOMIC t1_imag = z1_imag - z6_imag ; 
          
          
          const ATOMIC t2_real = z2_real + z5_real ;
          const ATOMIC t2_imag = z2_imag + z5_imag ; 
          
          
          const ATOMIC t3_real = z2_real - z5_real ;
          const ATOMIC t3_imag = z2_imag - z5_imag ; 
          
          
          const ATOMIC t4_real = z4_real + z3_real ;
          const ATOMIC t4_imag = z4_imag + z3_imag ; 
          
          
          const ATOMIC t5_real = z4_real - z3_real ;
          const ATOMIC t5_imag = z4_imag - z3_imag ; 
          
          
          const ATOMIC t6_real = t2_real + t0_real ;
          const ATOMIC t6_imag = t2_imag + t0_imag ;
          
          
          const ATOMIC t7_real = t5_real + t3_real ;
          const ATOMIC t7_imag = t5_imag + t3_imag ;
          
          
          const ATOMIC b0_real = z0_real + t6_real + t4_real ;
          const ATOMIC b0_imag = z0_imag + t6_imag + t4_imag ;
          
          
          const ATOMIC b1_real = (((c1 + c2 + c3)/3.0 - 1.0) * (t6_real + t4_real));
          const ATOMIC b1_imag = (((c1 + c2 + c3)/3.0 - 1.0) * (t6_imag + t4_imag));
          
          
          const ATOMIC b2_real = (((2.0 * c1 - c2 - c3)/3.0) * (t0_real - t4_real));
          const ATOMIC b2_imag = (((2.0 * c1 - c2 - c3)/3.0) * (t0_imag - t4_imag));
          
          
          const ATOMIC b3_real = (((c1 - 2.0*c2 + c3)/3.0) * (t4_real - t2_real));
          const ATOMIC b3_imag = (((c1 - 2.0*c2 + c3)/3.0) * (t4_imag - t2_imag));
          
          
          const ATOMIC b4_real = (((c1 + c2 - 2.0 * c3)/3.0) * (t2_real - t0_real));
          const ATOMIC b4_imag = (((c1 + c2 - 2.0 * c3)/3.0) * (t2_imag - t0_imag));
          
          
          const ATOMIC b5_real = (-(int)sign) * ((s1 + s2 - s3)/3.0) * (t7_real + t1_real) ;
          const ATOMIC b5_imag = (-(int)sign) * ((s1 + s2 - s3)/3.0) * (t7_imag + t1_imag) ;
          
          
          const ATOMIC b6_real = (-(int)sign) * ((2.0 * s1 - s2 + s3)/3.0) * (t1_real - t5_real) ;
          const ATOMIC b6_imag = (-(int)sign) * ((2.0 * s1 - s2 + s3)/3.0) * (t1_imag - t5_imag) ;
          
          
          const ATOMIC b7_real = (-(int)sign) * ((s1 - 2.0 * s2 - s3)/3.0) * (t5_real - t3_real) ;
          const ATOMIC b7_imag = (-(int)sign) * ((s1 - 2.0 * s2 - s3)/3.0) * (t5_imag - t3_imag) ;
          
          
          const ATOMIC b8_real = (-(int)sign) * ((s1 + s2 + 2.0 * s3)/3.0) * (t3_real - t1_real) ;
          const ATOMIC b8_imag = (-(int)sign) * ((s1 + s2 + 2.0 * s3)/3.0) * (t3_imag - t1_imag) ;
          
          
          
          const ATOMIC T0_real = b0_real + b1_real ;
          const ATOMIC T0_imag = b0_imag + b1_imag ;
          
          
          const ATOMIC T1_real = b2_real + b3_real ;
          const ATOMIC T1_imag = b2_imag + b3_imag ;
          
          
          const ATOMIC T2_real = b4_real - b3_real ;
          const ATOMIC T2_imag = b4_imag - b3_imag ;
          
          
          const ATOMIC T3_real = -b2_real - b4_real ;
          const ATOMIC T3_imag = -b2_imag - b4_imag ;
          
          
          const ATOMIC T4_real = b6_real + b7_real ;
          const ATOMIC T4_imag = b6_imag + b7_imag ;
          
          
          const ATOMIC T5_real = b8_real - b7_real ;
          const ATOMIC T5_imag = b8_imag - b7_imag ;
          
          
          const ATOMIC T6_real = -b8_real - b6_real ;
          const ATOMIC T6_imag = -b8_imag - b6_imag ;
          
          
          const ATOMIC T7_real = T0_real + T1_real ;
          const ATOMIC T7_imag = T0_imag + T1_imag ;
          
          
          const ATOMIC T8_real = T0_real + T2_real ;
          const ATOMIC T8_imag = T0_imag + T2_imag ;
          
          
          const ATOMIC T9_real = T0_real + T3_real ;
          const ATOMIC T9_imag = T0_imag + T3_imag ;
          
          
          const ATOMIC T10_real = T4_real + b5_real ;
          const ATOMIC T10_imag = T4_imag + b5_imag ;
          
          
          const ATOMIC T11_real = T5_real + b5_real ;
          const ATOMIC T11_imag = T5_imag + b5_imag ;
          
          
          const ATOMIC T12_real = T6_real + b5_real ;
          const ATOMIC T12_imag = T6_imag + b5_imag ;
          
          
          
          const ATOMIC x0_real = b0_real ;
          const ATOMIC x0_imag = b0_imag ;
          
          
          const ATOMIC x1_real = T7_real + T10_imag ;
          const ATOMIC x1_imag = T7_imag - T10_real ;
          
          
          const ATOMIC x2_real = T9_real + T12_imag ;
          const ATOMIC x2_imag = T9_imag - T12_real ;
          
          
          const ATOMIC x3_real = T8_real - T11_imag ;
          const ATOMIC x3_imag = T8_imag + T11_real ;
          
          
          const ATOMIC x4_real = T8_real + T11_imag ;
          const ATOMIC x4_imag = T8_imag - T11_real ;
          
          
          const ATOMIC x5_real = T9_real - T12_imag ;
          const ATOMIC x5_imag = T9_imag + T12_real ;
          
          
          const ATOMIC x6_real = T7_real - T10_imag ;
          const ATOMIC x6_imag = T7_imag + T10_real ;
          
          
          
          
          REAL(out,ostride,j) = x0_real;
          IMAG(out,ostride,j) = x0_imag;
          
          
          REAL(out,ostride,j+p_1) = w1_real * x1_real - w1_imag * x1_imag;
          IMAG(out,ostride,j+p_1) = w1_real * x1_imag + w1_imag * x1_real;

          
          REAL(out,ostride,j+2*p_1) = w2_real * x2_real - w2_imag * x2_imag;
          IMAG(out,ostride,j+2*p_1) = w2_real * x2_imag + w2_imag * x2_real;

          
          REAL(out,ostride,j+3*p_1) = w3_real * x3_real - w3_imag * x3_imag;
          IMAG(out,ostride,j+3*p_1) = w3_real * x3_imag + w3_imag * x3_real;

          
          REAL(out,ostride,j+4*p_1) = w4_real * x4_real - w4_imag * x4_imag;
          IMAG(out,ostride,j+4*p_1) = w4_real * x4_imag + w4_imag * x4_real;

          
          REAL(out,ostride,j+5*p_1) = w5_real * x5_real - w5_imag * x5_imag;
          IMAG(out,ostride,j+5*p_1) = w5_real * x5_imag + w5_imag * x5_real;
          
          
          REAL(out,ostride,j+6*p_1) = w6_real * x6_real - w6_imag * x6_imag;
          IMAG(out,ostride,j+6*p_1) = w6_real * x6_imag + w6_imag * x6_real;
          
          i++; j++;
        }
      j += jump;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < wavetable->nf; i++)
    {
      size_t j;
      const size_t factor = wavetable->factor[i];
      wavetable->twiddle[i] = wavetable->trig + t;
      product_1 = product;      
      product *= factor;
      q = n / product;

      for(j = 1; j < factor; j++)
        {
          size_t k;
          size_t m = 0;
          for(k = 1; k < (product_1 + 1) / 2; k++)
            {
              double theta;
              m = m + j * q;
              m = m % n;
              theta = d_theta * m;      
              GSL_REAL(wavetable->trig[t]) = cos (theta);
              GSL_IMAG(wavetable->trig[t]) = sin (theta);

              t++;
            }
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n - 1; i++)
    {
      size_t k = n / 2 ;

      if (i < j)
        {
          const BASE tmp_real = REAL(data,stride,i);
          const BASE tmp_imag = IMAG(data,stride,i);
          REAL(data,stride,i) = REAL(data,stride,j);
          IMAG(data,stride,i) = IMAG(data,stride,j);
          REAL(data,stride,j) = tmp_real;
          IMAG(data,stride,j) = tmp_imag;
        }

      while (k <= j) 
        {
          j = j - k ;
          k = k / 2 ;
        }

      j += k ;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n - 1; i++)
    {
      size_t k = n / 2 ;

      if (i < j)
        {
          const BASE tmp = VECTOR(data,stride,i);
          VECTOR(data,stride,i) = VECTOR(data,stride,j);
          VECTOR(data,stride,j) = tmp;
        }

      while (k <= j) 
        {
          j = j - k ;
          k = k / 2 ;
        }

      j += k ;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 0; k < q; k++)
    {
      ATOMIC w1_real, w1_imag, w2_real, w2_imag;

      if (k == 0)
        {
          w1_real = 1.0;
          w1_imag = 0.0;
          w2_real = 1.0;
          w2_imag = 0.0;
        }
      else
        {
          if (sign == gsl_fft_forward)
            {
              
              w1_real = GSL_REAL(twiddle1[k - 1]);
              w1_imag = GSL_IMAG(twiddle1[k - 1]);
              w2_real = GSL_REAL(twiddle2[k - 1]);
              w2_imag = GSL_IMAG(twiddle2[k - 1]);
            }
          else
            {
              
              w1_real = GSL_REAL(twiddle1[k - 1]);
              w1_imag = -GSL_IMAG(twiddle1[k - 1]);
              w2_real = GSL_REAL(twiddle2[k - 1]);
              w2_imag = -GSL_IMAG(twiddle2[k - 1]);
            }
        }

      for(k1 = 0; k1 < product_1; k1++)
        {
          const ATOMIC z0_real = REAL(in,istride,i);
          const ATOMIC z0_imag = IMAG(in,istride,i);
          const ATOMIC z1_real = REAL(in,istride,i+m);
          const ATOMIC z1_imag = IMAG(in,istride,i+m);
          const ATOMIC z2_real = REAL(in,istride,i+2*m);
          const ATOMIC z2_imag = IMAG(in,istride,i+2*m);

          

          
          const ATOMIC t1_real = z1_real + z2_real;
          const ATOMIC t1_imag = z1_imag + z2_imag;
          
          
          const ATOMIC t2_real = z0_real - t1_real / 2.0;
          const ATOMIC t2_imag = z0_imag - t1_imag / 2.0;
          
          
          const ATOMIC t3_real = ((int) sign) * tau * (z1_real - z2_real);
          const ATOMIC t3_imag = ((int) sign) * tau * (z1_imag - z2_imag);
          
          
          const ATOMIC x0_real = z0_real + t1_real;
          const ATOMIC x0_imag = z0_imag + t1_imag;
          
          
          const ATOMIC x1_real = t2_real - t3_imag;
          const ATOMIC x1_imag = t2_imag + t3_real;
          
          
          const ATOMIC x2_real = t2_real + t3_imag;
          const ATOMIC x2_imag = t2_imag - t3_real;

          

          
          REAL(out,ostride,j) = x0_real;
          IMAG(out,ostride,j) = x0_imag;
          
          
          REAL(out,ostride,j+product_1) = w1_real * x1_real - w1_imag * x1_imag;
          IMAG(out,ostride,j+product_1) = w1_real * x1_imag + w1_imag * x1_real;
          
          
          REAL(out,ostride,j+2*product_1) = w2_real * x2_real - w2_imag * x2_imag;
          IMAG(out,ostride,j+2*product_1) = w2_real * x2_imag + w2_imag * x2_real;

          i++; j++;
        }
      j += jump;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++) 
    {
      k += 2 ;
      
      for(j = 1; j < stride; j++)
        {
          status |= data[k] != k + offset ;
          k++ ;
          status |= data[k] != k + offset ;
          k++ ;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0 ; i < 2 * n * stride ; i++)
    {
      complex_data[i] = (BASE)i ;
      complex_tmp[i] = (BASE)(i + 1000.0) ;
      fft_complex_data[i] = (BASE)(i + 2000.0) ;
      fft_complex_tmp[i] = (BASE)(i + 3000.0) ;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0 ; i < n ; i++)
      {
        REAL(complex_tmp,stride,i) = REAL(complex_data,stride,i) ;
        IMAG(complex_tmp,stride,i) = IMAG(complex_data,stride,i) ;
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0 ; i < n ; i++)
      {
        REAL(fft_complex_tmp,stride,i) = REAL(complex_data,stride,i) ;
        IMAG(fft_complex_tmp,stride,i) = IMAG(complex_data,stride,i) ;
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
      {
        REAL(complex_tmp,stride,i) *= n;
        IMAG(complex_tmp,stride,i) *= n;
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
      {
        FUNCTION(fft_signal,complex_exp) ((int)i, n, stride, 1.0, 0.0, complex_data,
                                          fft_complex_data);
        FUNCTION(gsl_fft_complex,forward) (complex_data, stride, n, cw, cwork);
        status |= FUNCTION(compare_complex,results) ("analytic", 
                                                     fft_complex_data,
                                                     "fft of exp", 
                                                     complex_data,
                                                     stride, n, 1e6);
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i <  2 * stride * n; i++) 
    {
      data[i] = (BASE)i ;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++) 
    {
      size_t i_tmp = i ;
      size_t j = 0 ;
      size_t bit ;

      for(bit = 0; bit < logn; bit++)
        {
          j <<= 1;              
          j |= i_tmp & 1;
          i_tmp >>= 1;
        }

      reversed_data[2*j*stride] = data[2*i*stride] ;
      reversed_data[2*j*stride+1] = data[2*i*stride+1] ;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0 ; i < 2 * n * stride ; i++)
    {
      complex_data[i] = (BASE)i ;
      complex_tmp[i] = (BASE)(i + 1000.0) ;
      fft_complex_data[i] = (BASE)(i + 2000.0) ;
      fft_complex_tmp[i] = (BASE)(i + 3000.0) ;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0 ; i < n ; i++)
      {
        REAL(complex_tmp,stride,i) = REAL(complex_data,stride,i) ;
        IMAG(complex_tmp,stride,i) = IMAG(complex_data,stride,i) ;
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0 ; i < n ; i++)
      {
        REAL(fft_complex_tmp,stride,i) = REAL(complex_data,stride,i) ;
        IMAG(fft_complex_tmp,stride,i) = IMAG(complex_data,stride,i) ;
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
      {
        REAL(complex_tmp,stride,i) *= n;
        IMAG(complex_tmp,stride,i) *= n;
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
      {
        FUNCTION(fft_signal,complex_exp) ((int)i, n, stride, 1.0, 0.0, complex_data,
                                          fft_complex_data);
        FUNCTION(gsl_fft_complex,radix2_forward) (complex_data, stride, n);
        status |= FUNCTION(compare_complex,results) ("analytic", 
                                                     fft_complex_data,
                                                     "fft of exp", 
                                                     complex_data,
                                                     stride, n, 1e6);
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k1 = 0; k1 < q; k1++)
    {
      const size_t from0 = k1 * product_1;
      const size_t from1 = from0 + m;
      const size_t from2 = from1 + m;
      
      const ATOMIC z0_real = VECTOR(in,istride,from0);
      const ATOMIC z1_real = VECTOR(in,istride,from1);
      const ATOMIC z2_real = VECTOR(in,istride,from2);
      
      const ATOMIC t1 = z1_real + z2_real;

      const ATOMIC x0_real = z0_real + t1;
      const ATOMIC x1_real = z0_real - t1 / 2.0;
      const ATOMIC x1_imag = -tau * (z1_real - z2_real);

      const size_t to0 = product * k1;
      const size_t to1 = to0 + 2 * product_1 - 1;

      VECTOR(out,ostride,to0) = x0_real;
      VECTOR(out,ostride,to1) = x1_real;
      VECTOR(out,ostride,to1 + 1) = x1_imag;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 1; k < (product_1 + 1) / 2; k++)
    {
      const ATOMIC w1_real = GSL_REAL(twiddle1[k - 1]);
      const ATOMIC w1_imag = -GSL_IMAG(twiddle1[k - 1]);
      const ATOMIC w2_real = GSL_REAL(twiddle2[k - 1]);
      const ATOMIC w2_imag = -GSL_IMAG(twiddle2[k - 1]);

      for(k1 = 0; k1 < q; k1++)
        {
          const size_t from0 = k1 * product_1 + 2 * k - 1;
          const size_t from1 = from0 + m;
          const size_t from2 = from1 + m;
          
          const ATOMIC f0_real = VECTOR(in,istride,from0);
          const ATOMIC f0_imag = VECTOR(in,istride,from0 + 1);
          const ATOMIC f1_real = VECTOR(in,istride,from1);
          const ATOMIC f1_imag = VECTOR(in,istride,from1 + 1);
          const ATOMIC f2_real = VECTOR(in,istride,from2);
          const ATOMIC f2_imag = VECTOR(in,istride,from2 + 1);
          
          const ATOMIC z0_real = f0_real;
          const ATOMIC z0_imag = f0_imag;
          const ATOMIC z1_real = w1_real * f1_real - w1_imag * f1_imag;
          const ATOMIC z1_imag = w1_real * f1_imag + w1_imag * f1_real;
          const ATOMIC z2_real = w2_real * f2_real - w2_imag * f2_imag;
          const ATOMIC z2_imag = w2_real * f2_imag + w2_imag * f2_real;

          

          
          const ATOMIC t1_real = z1_real + z2_real;
          const ATOMIC t1_imag = z1_imag + z2_imag;
          
          
          const ATOMIC t2_real = z0_real - t1_real / 2;
          const ATOMIC t2_imag = z0_imag - t1_imag / 2;
          
          
          const ATOMIC t3_real = -tau * (z1_real - z2_real);
          const ATOMIC t3_imag = -tau * (z1_imag - z2_imag);
          
          
          const ATOMIC x0_real = z0_real + t1_real;
          const ATOMIC x0_imag = z0_imag + t1_imag;
          
          
          const ATOMIC x1_real = t2_real - t3_imag;
          const ATOMIC x1_imag = t2_imag + t3_real;

            
          const ATOMIC x2_real = t2_real + t3_imag;
          const ATOMIC x2_imag = t2_imag - t3_real;

          
          
          const size_t to0 = k1 * product + 2 * k - 1;
          const size_t to1 = to0 + 2 * product_1;
          const size_t to2 = 2 * product_1 - 2 * k + k1 * product - 1;
          
          
          VECTOR(out,ostride,to0) = x0_real;
          VECTOR(out,ostride,to0 + 1) = x0_imag;
          
          
          VECTOR(out,ostride,to1) = x1_real;
          VECTOR(out,ostride,to1 + 1) = x1_imag;
          
          
          VECTOR(out,ostride,to2) = x2_real;
          VECTOR(out,ostride,to2 + 1) = -x2_imag;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k1 = 0; k1 < q; k1++)
    {
      const size_t from0 = k1 * product_1 + product_1 - 1;
      const size_t from1 = from0 + m;
      const size_t from2 = from1 + m;
      
      const ATOMIC z0_real = VECTOR(in,istride,from0);
      const ATOMIC z1_real = VECTOR(in,istride,from1);
      const ATOMIC z2_real = VECTOR(in,istride,from2);

      const ATOMIC t1 = z1_real - z2_real;
      const ATOMIC x0_real = z0_real + t1 / 2.0;
      const ATOMIC x0_imag = -tau * (z1_real + z2_real);
      const ATOMIC x1_real = z0_real - t1;

      const size_t to0 = k1 * product + product_1 - 1;
      const size_t to1 = to0 + 2 * product_1;
      
      VECTOR(out,ostride,to0) = x0_real;
      VECTOR(out,ostride,to0 + 1) = x0_imag;
      VECTOR(out,ostride,to1) = x1_real;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i <= logn; i++)
    {
      size_t a, b;

      p_1 = p ;
      p = 2 * p ;
      q = q / 2 ;

      

      for(b = 0; b < q; b++)
        {
          ATOMIC t0_real = VECTOR(data,stride,b*p) + VECTOR(data,stride,b*p + p_1) ;
          ATOMIC t1_real = VECTOR(data,stride,b*p) - VECTOR(data,stride,b*p + p_1) ;
          
          VECTOR(data,stride,b*p) = t0_real ;
          VECTOR(data,stride,b*p + p_1) = t1_real ;
        }

      

      {
        ATOMIC w_real = 1.0;
        ATOMIC w_imag = 0.0;

        const double theta = - 2.0 * M_PI / p;
        
        const ATOMIC s = sin (theta);
        const ATOMIC t = sin (theta / 2.0);
        const ATOMIC s2 = 2.0 * t * t;
        
        for(a = 1; a < (p_1)/2; a++)
          {
            
            
            {
              const ATOMIC tmp_real = w_real - s * w_imag - s2 * w_real;
              const ATOMIC tmp_imag = w_imag + s * w_real - s2 * w_imag;
              w_real = tmp_real;
              w_imag = tmp_imag;
            }
            
            for(b = 0; b < q; b++)
              {
                ATOMIC z0_real = VECTOR(data,stride,b*p + a) ;
                ATOMIC z0_imag = VECTOR(data,stride,b*p + p_1 - a) ;
                ATOMIC z1_real = VECTOR(data,stride,b*p + p_1 + a) ;
                ATOMIC z1_imag = VECTOR(data,stride,b*p + p - a) ;
                
                
                
                ATOMIC t0_real = z0_real + w_real * z1_real - w_imag * z1_imag;
                ATOMIC t0_imag = z0_imag + w_real * z1_imag + w_imag * z1_real;
                
                
                
                ATOMIC t1_real = z0_real - w_real * z1_real + w_imag * z1_imag;
                ATOMIC t1_imag = z0_imag - w_real * z1_imag - w_imag * z1_real;
                
                VECTOR(data,stride,b*p + a) = t0_real ;
                VECTOR(data,stride,b*p + p - a) = t0_imag ;
                
                VECTOR(data,stride,b*p + p_1 - a) = t1_real ;
                VECTOR(data,stride,b*p + p_1 + a) = -t1_imag ;
              }
          }
      }

      if (p_1 >  1) 
        {
          for(b = 0; b < q; b++) 
            {
              
              
              VECTOR(data,stride,b*p + p - p_1/2) *= -1 ;
            }
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k1 = 0; k1 < q; k1++)
    {
      const size_t from0 = k1 * product_1;
      const size_t from1 = from0 + m;
      const size_t from2 = from1 + m;
      const size_t from3 = from2 + m;
      
      const ATOMIC z0_real = VECTOR(in,istride,from0);
      const ATOMIC z1_real = VECTOR(in,istride,from1);
      const ATOMIC z2_real = VECTOR(in,istride,from2);
      const ATOMIC z3_real = VECTOR(in,istride,from3);

      

      
      const ATOMIC t1_real = z0_real + z2_real;
      
      
      const ATOMIC t2_real = z1_real + z3_real;
      
        
      const ATOMIC t3_real = z0_real - z2_real;
      
      
      const ATOMIC t4_real = -(z1_real - z3_real);
      
      
      const ATOMIC x0_real = t1_real + t2_real;

      
      const ATOMIC x1_real = t3_real;
      const ATOMIC x1_imag = t4_real;

      
      const ATOMIC x2_real = t1_real - t2_real;

      const size_t to0 = product * k1;
      const size_t to1 = to0 + 2 * product_1 - 1;
      const size_t to2 = to1 + 2 * product_1;
      
      VECTOR(out,ostride,to0) = x0_real;
      VECTOR(out,ostride,to1) = x1_real;
      VECTOR(out,ostride,to1 + 1) = x1_imag;
      VECTOR(out,ostride,to2) = x2_real;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 1; k < (product_1 + 1) / 2; k++)
    {
      ATOMIC w1_real, w1_imag, w2_real, w2_imag, w3_real, w3_imag;
      w1_real = GSL_REAL(twiddle1[k - 1]);
      w1_imag = -GSL_IMAG(twiddle1[k - 1]);
      w2_real = GSL_REAL(twiddle2[k - 1]);
      w2_imag = -GSL_IMAG(twiddle2[k - 1]);
      w3_real = GSL_REAL(twiddle3[k - 1]);
      w3_imag = -GSL_IMAG(twiddle3[k - 1]);

      for(k1 = 0; k1 < q; k1++)
        {
          const size_t from0 = k1 * product_1 + 2 * k - 1;
          const size_t from1 = from0 + m;
          const size_t from2 = from1 + m;
          const size_t from3 = from2 + m;
          
          const ATOMIC f0_real = VECTOR(in,istride,from0);
          const ATOMIC f0_imag = VECTOR(in,istride,from0 + 1);
          const ATOMIC f1_real = VECTOR(in,istride,from1);
          const ATOMIC f1_imag = VECTOR(in,istride,from1 + 1);
          const ATOMIC f2_real = VECTOR(in,istride,from2);
          const ATOMIC f2_imag = VECTOR(in,istride,from2 + 1);
          const ATOMIC f3_real = VECTOR(in,istride,from3);
          const ATOMIC f3_imag = VECTOR(in,istride,from3 + 1);
          
          const ATOMIC z0_real = f0_real;
          const ATOMIC z0_imag = f0_imag;
          const ATOMIC z1_real = w1_real * f1_real - w1_imag * f1_imag;
          const ATOMIC z1_imag = w1_real * f1_imag + w1_imag * f1_real;
          const ATOMIC z2_real = w2_real * f2_real - w2_imag * f2_imag;
          const ATOMIC z2_imag = w2_real * f2_imag + w2_imag * f2_real;
          const ATOMIC z3_real = w3_real * f3_real - w3_imag * f3_imag;
          const ATOMIC z3_imag = w3_real * f3_imag + w3_imag * f3_real;

          

          
          const ATOMIC t1_real = z0_real + z2_real;
          const ATOMIC t1_imag = z0_imag + z2_imag;
          
          
          const ATOMIC t2_real = z1_real + z3_real;
          const ATOMIC t2_imag = z1_imag + z3_imag;
          
          
          const ATOMIC t3_real = z0_real - z2_real;
          const ATOMIC t3_imag = z0_imag - z2_imag;
          
          
          const ATOMIC t4_real = -(z1_real - z3_real);
          const ATOMIC t4_imag = -(z1_imag - z3_imag);
          
          
          const ATOMIC x0_real = t1_real + t2_real;
          const ATOMIC x0_imag = t1_imag + t2_imag;
          
          
          const ATOMIC x1_real = t3_real - t4_imag;
          const ATOMIC x1_imag = t3_imag + t4_real;
          
          
          const ATOMIC x2_real = t1_real - t2_real;
          const ATOMIC x2_imag = t1_imag - t2_imag;
          
          
          const ATOMIC x3_real = t3_real + t4_imag;
          const ATOMIC x3_imag = t3_imag - t4_real;

          const size_t to0 = k1 * product + 2 * k - 1;
          const size_t to1 = to0 + 2 * product_1;
          const size_t to2 = 2 * product_1 - 2 * k + k1 * product - 1;
          const size_t to3 = to2 + 2 * product_1;
          
          VECTOR(out,ostride,to0) = x0_real;
          VECTOR(out,ostride,to0 + 1) = x0_imag;
          
          VECTOR(out,ostride,to1) = x1_real;
          VECTOR(out,ostride,to1 + 1) = x1_imag;
          
          VECTOR(out,ostride,to3) = x2_real;
          VECTOR(out,ostride,to3 + 1) = -x2_imag;
          
          VECTOR(out,ostride,to2) = x3_real;
          VECTOR(out,ostride,to2 + 1) = -x3_imag;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k1 = 0; k1 < q; k1++)
    {
      const size_t from0 = k1 * product_1 + product_1 - 1;
      const size_t from1 = from0 + m;
      const size_t from2 = from1 + m;
      const size_t from3 = from2 + m;
      
      const ATOMIC x0 = VECTOR(in,istride,from0);
      const ATOMIC x1 = VECTOR(in,istride,from1);
      const ATOMIC x2 = VECTOR(in,istride,from2);
      const ATOMIC x3 = VECTOR(in,istride,from3);
      
      const ATOMIC t1 = (1.0 / sqrt (2.0)) * (x1 - x3);
      const ATOMIC t2 = (1.0 / sqrt (2.0)) * (x1 + x3);
      
      const size_t to0 = k1 * product + 2 * k - 1;
      const size_t to1 = to0 + 2 * product_1;
      
      VECTOR(out,ostride,to0) = x0 + t1;
      VECTOR(out,ostride,to0 + 1) = -x2 - t2;
      
      VECTOR(out,ostride,to1) = x0 - t1;
      VECTOR(out,ostride,to1 + 1) = x2 - t2;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0 ; i < n * stride ; i++)
    {
      real_data[i] = (BASE)i ;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0 ; i < 2 * n * stride ; i++)
    {
      complex_data[i] = (BASE)(i + 1000.0) ;
      complex_tmp[i] = (BASE)(i + 2000.0) ;
      fft_complex_data[i] = (BASE)(i + 3000.0) ;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
    {
      real_data[i*stride] = REAL(complex_data,stride,i);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
    {
      real_data[i*stride] /= n;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i <  stride * n; i++) 
    {
      data[i] = (BASE)i ;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++) 
    {
      size_t i_tmp = i ;
      size_t j = 0 ;
      size_t bit ;

      for(bit = 0; bit < logn; bit++)
        {
          j <<= 1;              
          j |= i_tmp & 1;
          i_tmp >>= 1;
        }

      reversed_data[j*stride] = data[i*stride] ;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0 ; i < n * stride ; i++)
    {
      real_data[i] = (BASE)i ;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0 ; i < 2 * n * stride ; i++)
    {
      complex_data[i] = (BASE)(i + 1000.0) ;
      complex_tmp[i] = (BASE)(i + 2000.0) ;
      fft_complex_data[i] = (BASE)(i + 3000.0) ;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
    {
      real_data[i*stride] = REAL(complex_data,stride,i);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
    {
      real_data[i*stride] /= n;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
      {
        REAL(data,stride,i) *= norm;
        IMAG(data,stride,i) *= norm;
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nf; i++)
    {
      const size_t factor = wavetable->factor[i];
      product *= factor;
      q = n / product;

      if (state == 0)
        {
          in = data;
          istride = stride;
          out = scratch;
          ostride = 1;
          state = 1;
        }
      else
        {
          in = scratch;
          istride = 1;
          out = data;
          ostride = stride;
          state = 0;
        }

      if (factor == 2)
        {
          twiddle1 = wavetable->twiddle[i];
          FUNCTION(fft_complex,pass_2) (in, istride, out, ostride, sign, 
                                        product, n, twiddle1);
        }
      else if (factor == 3)
        {
          twiddle1 = wavetable->twiddle[i];
          twiddle2 = twiddle1 + q;
          FUNCTION(fft_complex,pass_3) (in, istride, out, ostride, sign, 
                                        product, n, twiddle1, twiddle2);
        }
      else if (factor == 4)
        {
          twiddle1 = wavetable->twiddle[i];
          twiddle2 = twiddle1 + q;
          twiddle3 = twiddle2 + q;
          FUNCTION(fft_complex,pass_4) (in, istride, out, ostride, sign, 
                                        product, n, twiddle1, twiddle2, 
                                        twiddle3);
        }
      else if (factor == 5)
        {
          twiddle1 = wavetable->twiddle[i];
          twiddle2 = twiddle1 + q;
          twiddle3 = twiddle2 + q;
          twiddle4 = twiddle3 + q;
          FUNCTION(fft_complex,pass_5) (in, istride, out, ostride, sign, 
                                        product, n, twiddle1, twiddle2, 
                                        twiddle3, twiddle4);
        }
      else if (factor == 6)
        {
          twiddle1 = wavetable->twiddle[i];
          twiddle2 = twiddle1 + q;
          twiddle3 = twiddle2 + q;
          twiddle4 = twiddle3 + q;
          twiddle5 = twiddle4 + q;
          FUNCTION(fft_complex,pass_6) (in, istride, out, ostride, sign, 
                                        product, n, twiddle1, twiddle2, 
                                        twiddle3, twiddle4, twiddle5);
        }
      else if (factor == 7)
        {
          twiddle1 = wavetable->twiddle[i];
          twiddle2 = twiddle1 + q;
          twiddle3 = twiddle2 + q;
          twiddle4 = twiddle3 + q;
          twiddle5 = twiddle4 + q;
          twiddle6 = twiddle5 + q;
          FUNCTION(fft_complex,pass_7) (in, istride, out, ostride, sign, 
                                        product, n, twiddle1, twiddle2, 
                                        twiddle3, twiddle4, twiddle5, 
                                        twiddle6);
        }
      else
        {
          twiddle1 = wavetable->twiddle[i];
          FUNCTION(fft_complex,pass_n) (in, istride, out, ostride, sign, 
                                        factor, product, n, twiddle1);
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
        {
          REAL(data,stride,i) = REAL(scratch,1,i) ;
          IMAG(data,stride,i) = IMAG(scratch,1,i) ;
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
    {
      BASE xi = data[i * stride];

      if (xi > max)
        max = xi;
#ifdef FP
      if (isnan (xi))
        return xi;
#endif
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
    {
      BASE xi = data[i * stride];

      if (xi < min)
        min = xi;
#ifdef FP
      if (isnan (xi))
        return xi;
#endif
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
    {
      BASE xi = data[i * stride];

      if (xi < min)
        min = xi;

      if (xi > max)
        max = xi;

#ifdef FP
      if (isnan (xi))
        {
          min = xi;
          max = xi;
          break;
        }
#endif

    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
    {
      BASE xi = data[i * stride];

      if (xi > max)
        {
          max = xi;
          max_index = i;
        }

#ifdef FP
      if (isnan (xi))
        {
          return i;
        }
#endif
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
    {
      BASE xi = data[i * stride];

      if (xi < min)
        {
          min = xi;
          min_index = i;
        }

#ifdef FP
      if (isnan (xi))
        {
          return i;
        }
#endif
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
    {
      BASE xi = data[i * stride];

      if (xi < min)
        {
          min = xi;
          min_index = i;
        }

      if (xi > max)
        {
          max = xi;
          max_index = i;
        }

#ifdef FP
      if (isnan (xi))
        {
          min_index = i;
          max_index = i;
          break;
        }
#endif
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(s1 = 1; s1 < 4 ; s1++) 
    {
      s2 = (s1 < 3) ? 1 : (s1 - 1) ;

      test_func (s1,s2);
      test_float_func (s1,s2);
      test_long_double_func (s1,s2);
      
      test_ulong_func (s1,s2);
      test_long_func (s1,s2);
      test_uint_func (s1,s2);
      test_int_func (s1,s2);
      test_ushort_func (s1,s2);
      test_short_func (s1,s2);
      test_uchar_func (s1,s2);
      test_char_func (s1,s2);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
    {
      BASE wi = w[i * wstride];
      
      if (wi > 0) {
        const long double x = (data[i * stride] - wmean) / wsd;
        W += wi ;
        wskew += (x * x * x - wskew) * (wi / W);
      }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0 ; i < ina ; i++)
    igroupa[i * stridea] = irawa[i] ;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0 ; i < inb ; i++)
    igroupb[i * strideb] = irawb[i] ;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0 ; i < 6 ; i++)
    test1[i * stridea] = raw1[i] ;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0 ; i < ina ; i++)
    sorted[stridea * i] = igroupa[stridea * i] ;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
    {
      const long double x = (data[i * stride] - mean) / sd;
      skew += (x * x * x - skew) / (i + 1);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < size; i++)
    {
      mean += (data[i * stride] - mean) / (i + 1);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
    {
      const double delta = fabs(data[i * stride] - mean);
      sum += delta;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0 ; i < na ; i++)
    groupa[i * stridea] = (BASE) rawa[i] ;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0 ; i < na ; i++)
    w[i * strideb] = (BASE) raww[i] ;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0 ; i < nb ; i++)
    groupb[i * strideb] = (BASE) rawb[i] ;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0 ; i < na ; i++)
    sorted[stridea * i] = groupa[stridea * i] ;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
    {
      const long double x = (data[i * stride] - mean) / sd;
      avg += (x * x * x * x - avg)/(i + 1);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
    {
      const long double delta = (data[i * stride] - mean);
      variance += (delta * delta - variance) / (i + 1);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < size; i++)
    {
      BASE wi = w[i * wstride];

      if (wi > 0)
        {
          W += wi;
          wmean += (data[i * stride] - wmean) * (wi / W);
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i < size ; i++)
    {
      const long double delta0 = (data[(i-1) * stride] - mean);
      const long double delta1 = (data[i * stride] - mean);
      q += (delta0 * delta1 - q)/(i + 1);
      v += (delta1 * delta1 - v)/(i + 1);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
    {
      const long double delta1 = (data1[i * stride1] - mean1);
      const long double delta2 = (data2[i * stride2] - mean2);
      covariance += (delta1 * delta2 - covariance) / (i + 1);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
    {
      BASE wi = w[i * wstride];
      
      if (wi > 0) {
        const long double delta = fabs(data[i * stride] - wmean);
        W += wi ;
        wabsdev += (delta - wabsdev) * (wi / W);
      }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
    {
      BASE wi = w[i * wstride];
      
      if (wi > 0) {
        const long double x = (data[i * stride] - wmean) / wsd;
        W += wi ;
        wavg += (x * x * x * x - wavg) * (wi / W);
      }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
    {
      BASE wi = w[i * wstride];

      if (wi > 0) {
        const long double delta = (data[i * stride] - wmean);
        W += wi ;
        wvariance += (delta * delta - wvariance) * (wi / W);
      }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
    {
      BASE wi = w[i * wstride];

      if (wi > 0)
        {
          a += wi ;
          b += wi * wi ;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1 ; i < 1000  ; i += 2) 
    {
      numacc2[i] = 1.1 ;
      numacc2[i+1] = 1.3 ;
      numacc3[i] = 1000000.1 ;
      numacc3[i+1] = 1000000.3 ;
      numacc4[i] = 10000000.1 ;
      numacc4[i+1] = 10000000.3 ;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < w->k; ++i)
        gsl_vector_set(w->knots, i, gsl_vector_get(breakpts, 0));



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i < w->l; ++i)
        {
          gsl_vector_set(w->knots, w->k - 1 + i,
                         gsl_vector_get(breakpts, i));
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = w->n; i < w->n + w->k; ++i)
        gsl_vector_set(w->knots, i, gsl_vector_get(breakpts, w->l));



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < w->k; ++i)
    gsl_vector_set(w->knots, i, a);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < w->l - 1; ++i)
    {
      gsl_vector_set(w->knots, w->k + i, x);
      x += delta;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = w->n; i < w->n + w->k; ++i)
    gsl_vector_set(w->knots, i, b);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < start; ++i)
        gsl_vector_set(B, i, 0.0);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = start; i <= idx; ++i)
        gsl_vector_set(B, i, gsl_vector_get(w->B, i - start));



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = idx + 1; i < w->n; ++i)
        gsl_vector_set(B, i, 0.0);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < w->k - 1; ++j)
        {
          gsl_vector_set(w->deltar, j,
                         gsl_vector_get(w->knots, i + j + 1) - x);
          gsl_vector_set(w->deltal, j,
                         x - gsl_vector_get(w->knots, i - j));

          saved = 0.0;

          for(ii = 0; ii <= j; ++ii)
            {
              term = gsl_vector_get(B, ii) /
                     (gsl_vector_get(w->deltar, ii) +
                      gsl_vector_get(w->deltal, j - ii));

              gsl_vector_set(B, ii,
                             saved +
                             gsl_vector_get(w->deltar, ii) * term);

              saved = gsl_vector_get(w->deltal, j - ii) * term;
            }

          gsl_vector_set(B, j + 1, saved);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = w->k - 1; i < w->k + w->l - 1; ++i)
    {
      const double ti = gsl_vector_get(w->knots, i);
      const double tip1 = gsl_vector_get(w->knots, i + 1);

      if (tip1 < ti)
        {
          GSL_ERROR("knots vector is not increasing", GSL_EINVAL);
        }

      if (ti <= x && x < tip1)
        break;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
    {
      double xi = a + (b - a) * (i / (n - 1.0));
      double sum = 0;
      gsl_bspline_eval (xi, B, bw);

      for(j = 0; j < ncoeffs; j++)
        {
          double Bj = gsl_vector_get (B, j);
          int s = (Bj < 0 || Bj > 1);
          gsl_test (s,
                    "basis-spline coefficient %u is in range [0,1] for x=%g",
                    j, xi);
          sum += Bj;
        }

      gsl_test_rel (sum, 1.0, order * GSL_DBL_EPSILON,
                    "basis-spline order %u is normalized for x=%g", order,
                    xi);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(order = 1; order < 10; order++)
    {
      for(breakpoints = 2; breakpoints < 100; breakpoints++)
        {
          double a = -1.23 * order, b = 45.6 * order;
          gsl_bspline_workspace *bw = gsl_bspline_alloc (order, breakpoints);
          gsl_bspline_knots_uniform (a, b, bw);
          test_bspline (bw);
          gsl_bspline_free (bw);
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(order = 1; order < 10; order++)
    {
      for(breakpoints = 2; breakpoints < 100; breakpoints++)
        {
          double a = -1.23 * order, b = 45.6 * order;
          gsl_bspline_workspace *bw = gsl_bspline_alloc (order, breakpoints);
          gsl_vector *k = gsl_vector_alloc (breakpoints);
          for(i = 0; i < breakpoints; i++)
            {
              double f, x;
              f = sqrt (i / (breakpoints - 1.0));
              x = (1 - f) * a + f * b;
              gsl_vector_set (k, i, x);
            };
          gsl_bspline_knots (k, bw);
          test_bspline (bw);
          gsl_vector_free (k);
          gsl_bspline_free (bw);
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < 3; j++)
        {
          status |= (c->data[j] != c63[i][j]);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < 3; j++)
    {
      status |= (c->data[j] != c63[19][j]);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < 3; j++)
      {
        status |= (d->data[j] != c->data[j]);
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < 3; j++)
        {
          status |= (c->data[j] != c63[i][j]);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < 3; j++)
    {
      status |= (c->data[j] != c63[0][j]);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < 3; j++)
      {
        status |= (d->data[j] != c->data[j]);
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < 7; j++)
  {
    status |= (gsl_combination_get(c, j) != j);
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < 7; j++)
  {
    status |= (gsl_combination_get(c, j) != j);
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < 7; j++)
  {
    status |= (gsl_combination_get(c, j) != j);
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < 7; j++)
  {
    status |= (gsl_combination_get(c, j) != j);
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < 7; j++)
  {
    status |= (gsl_combination_get(c, j) != j);
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < k; i++) 
    {
      const size_t ci = c->data[i];

      if (ci >= n)
        {
          GSL_ERROR("combination index outside range", GSL_FAILURE) ;
        }

      for(j = 0; j < i; j++)
        {
          if (c->data[j] == ci)
            {
              GSL_ERROR("duplicate combination index", GSL_FAILURE) ;
            }
          if (c->data[j] > ci)
            {
              GSL_ERROR("combination indices not in increasing order",
                        GSL_FAILURE) ;
            }
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(; i < k - 1; i++)
    {
      data[i + 1] = data[i] + 1;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(; i < k; i++)
    {
      data[i] = n - k + i;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < src_k; j++)
       {
         dest->data[j] = src->data[j];
       }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < k; i++)
    {
      c->data[i] = i;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < k; i++)
    {
      c->data[i] = i;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < k; i++)
    {
      c->data[i] = n - k + i;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < k; i++)
    {
      int status = fprintf (stream, format, data[i]);

      if (status < 0)
        {
          GSL_ERROR ("fprintf failed", GSL_EFAILED);
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < k; i++)
    {
      unsigned long j ;  

      




      int status = fscanf (stream, IN_FORMAT, &j);  

      if (status != 1)
        {
          GSL_ERROR ("fscanf failed", GSL_EFAILED);
        }

      data[i] = j;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
    {
      double fl, fh;
  
      double xi = gsl_vector_get (x, i);
      double dx = fabs(xi) * h;

      if (dx == 0.0) dx = h;

      gsl_vector_set (x1, i, xi + dx);
      fh = GSL_MULTIMIN_FN_EVAL(f, x1);

      gsl_vector_set (x1, i, xi - dx);
      fl = GSL_MULTIMIN_FN_EVAL(f, x1);

      gsl_vector_set (x1, i, xi);
      gsl_vector_set (g, i, (fh - fl) / (2.0 * dx));
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < x1->size2; j++)
    {
      mp = 0.0;
      for(i = 0; i < x1->size1; i++)
        {
          if (i != corner)
            {
              mp += (gsl_matrix_get (x1, i, j));
            }
        }
      mp /= (double) (x1->size1 - 1);
      newval = mp - coeff * (mp - gsl_matrix_get (x1, corner, j));
      gsl_vector_set (xc, j, newval);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < x1->size1; i++)
    {
      if (i != best)
        {
          for(j = 0; j < x1->size2; j++)
            {
              newval = 0.5 * (gsl_matrix_get (x1, i, j)
                              + gsl_matrix_get (x1, best, j));
              gsl_matrix_set (x1, i, j, newval);
            }

          

          gsl_matrix_get_row (xc, x1, i);
          newval = GSL_MULTIMIN_FN_EVAL (f, xc);
          gsl_vector_set (y1, i, newval);
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < x1->size2; j++)
    {
      val = 0.0;
      for(i = 0; i < x1->size1; i++)
        {
          val += gsl_matrix_get (x1, i, j);
        }
      val /= x1->size1;
      gsl_vector_set (mp, j, val);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < x1->size1; i++)
    {
      gsl_matrix_get_row (s, x1, i);
      gsl_blas_daxpy (-1.0, mp, s);
      ss += gsl_blas_dnrm2 (s);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < x->size; i++)
    {
      status = gsl_vector_memcpy (xtemp, x);

      if (status != 0)
        {
          GSL_ERROR ("vector memcopy failed", GSL_EFAILED);
        }

      val = gsl_vector_get (xtemp, i) + gsl_vector_get (step_size, i);
      gsl_vector_set (xtemp, i, val);
      val = GSL_MULTIMIN_FN_EVAL (f, xtemp);
      gsl_matrix_set_row (state->x1, i + 1, xtemp);
      gsl_vector_set (state->y1, i + 1, val);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i < n; i++)
    {
      val = (gsl_vector_get (y1, i));
      if (val < dlo)
        {
          dlo = val;
          lo = i;
        }
      else if (val > dhi)
        {
          ds_hi = dhi;
          s_hi = hi;
          dhi = val;
          hi = i;
        }
      else if (val > ds_hi)
        {
          ds_hi = val;
          s_hi = i;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < f->n; i++) 
    gsl_vector_set (step_size, i, 1);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < src_size; j++)
      {
        size_t k;

        for(k = 0; k < MULTIPLICITY; k++) 
          {
            dest->data[MULTIPLICITY * dest_stride * j + k] 
              = src->data[MULTIPLICITY * src_stride * j + k];
          }
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
    {
      BASE x = v->data[i*stride];
      if (x > max)
        max = x;
#ifdef FP
      if (isnan (x))
        return x;
#endif
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
    {
      BASE x = v->data[i*stride];
      if (x < min)
        min = x;
#ifdef FP
      if (isnan (x))
        return x;
#endif
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
    {
      BASE x = v->data[i*stride];
      if (x < min)
        {
          min = x;
        }
      if (x > max)
        {
          max = x;
        }
#ifdef FP
      if (isnan (x))
        {
          min = x;
          max = x;
          break;
        }
#endif
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
    {
      BASE x = v->data[i*stride];
      if (x > max)
        {
          max = x;
          imax = i;
        }
#ifdef FP
      if (isnan (x))
        {
          return i;
        }
#endif
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
    {
      BASE x = v->data[i*stride];
      if (x < min)
        {
          min = x;
          imin = i;
        }
#ifdef FP
      if (isnan (x))
        {
          return i;
        }
#endif
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
    {
      BASE x = v->data[i*stride];
      if (x < min)
        {
          min = x;
          imin = i;
        }
      if (x > max)
        {
          max = x;
          imax = i;
        }
#ifdef FP
      if (isnan (x))
        {
          imin = i;
          imax = i;
          break;
        }
#endif
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(N = 10; N < 1024; N = 2*N + 1) 
    {
      for(stride = 1; stride < 5 ; stride++)
        {
          test_func (stride, N);
          test_float_func (stride, N);
          test_long_double_func (stride, N);
          test_ulong_func (stride, N);
          test_long_func (stride, N);
          test_uint_func (stride, N);
          test_int_func (stride, N);
          test_ushort_func (stride, N);
          test_short_func (stride, N);
          test_uchar_func (stride, N);
          test_char_func (stride, N);

          test_complex_func (stride, N);
          test_complex_float_func (stride, N);
          test_complex_long_double_func (stride, N);

          for(ostride = 1; ostride < 5 ; ostride++)
            {
              test_ops (stride, ostride, N);
              test_float_ops (stride, ostride, N);
              test_long_double_ops (stride, ostride, N);
              test_ulong_ops (stride, ostride, N);
              test_long_ops (stride, ostride, N);
              test_uint_ops (stride, ostride, N);
              test_int_ops (stride, ostride, N);
              test_ushort_ops (stride, ostride, N);
              test_short_ops (stride, ostride, N);
              test_uchar_ops (stride, ostride, N);
              test_char_ops (stride, ostride, N);
            }              

          test_text (stride, N);
          test_float_text (stride, N);
#if HAVE_PRINTF_LONGDOUBLE
          test_long_double_text (stride, N);
#endif
          test_ulong_text (stride, N);
          test_long_text (stride, N);
          test_uint_text (stride, N);
          test_int_text (stride, N);
          test_ushort_text (stride, N);
          test_short_text (stride, N);
          test_uchar_text (stride, N);
          test_char_text (stride, N);

          test_complex_text (stride, N);
          test_complex_float_text (stride, N);
#if HAVE_PRINTF_LONGDOUBLE
          test_complex_long_double_text (stride, N);
#endif

          test_file (stride, N);
          test_float_file (stride, N);
          test_long_double_file (stride, N);
          test_ulong_file (stride, N);
          test_long_file (stride, N);
          test_uint_file (stride, N);
          test_int_file (stride, N);
          test_ushort_file (stride, N);
          test_short_file (stride, N);
          test_uchar_file (stride, N);
          test_char_file (stride, N);
          test_complex_file (stride, N);
          test_complex_float_file (stride, N);
          test_complex_long_double_file (stride, N);
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(N = 1; N < 1024; N *=2) 
    {
      for(stride = 1; stride < 5 ; stride++)
        {
          test_trap (stride, N);
          test_float_trap (stride, N);
          test_long_double_trap (stride, N);
          test_ulong_trap (stride, N);
          test_long_trap (stride, N);
          test_uint_trap (stride, N);
          test_int_trap (stride, N);
          test_ushort_trap (stride, N);
          test_short_trap (stride, N);
          test_uchar_trap (stride, N);
          test_char_trap (stride, N);
          test_complex_trap (stride, N);
          test_complex_float_trap (stride, N);
          test_complex_long_double_trap (stride, N);
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < size; i++)
    {
      for(k = 0; k < MULTIPLICITY; k++)
        {
          ATOMIC tmp = d1[i*s1 + k];
          d1[i*s1+k] = d2[i*s2 + k];
          d2[i*s2+k] = tmp;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 0; k < MULTIPLICITY; k++)
        {
          ATOMIC tmp = data[j*s + k];
          data[j*s+k] = data[i*s + k];
          data[i*s+k] = tmp;
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0 ; i < (size / 2) ; i++)
    {
      size_t j = size - i - 1 ;
      size_t k;

      for(k = 0; k < MULTIPLICITY; k++)
        {
          ATOMIC tmp = data[j*s + k];
          data[j*s+k] = data[i*s + k];
          data[i*s+k] = tmp;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N*stride; i++)
        {
          v0->data[i] = i;
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
      {
        FUNCTION (gsl_vector, set) (v, i, (ATOMIC) i);
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
      {
        if (v->data[i*stride] != (ATOMIC) (i))
          status = 1;
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
      {
        if (FUNCTION (gsl_vector, get) (v, i) != (ATOMIC) (i))
          status = 1;
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
      {
        if (FUNCTION (gsl_vector, ptr) (v, i) != v->data + i*stride)
          status = 1;
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
      {
        if (FUNCTION (gsl_vector, const_ptr) (v, i) != v->data + i*stride)
          status = 1;
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
      {
        FUNCTION (gsl_vector, set) (v, i, (ATOMIC) 0);
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
      {
        FUNCTION (gsl_vector, set) (v, i, (ATOMIC) (i % 10));
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
      {
        FUNCTION (gsl_vector, set) (v, i, (ATOMIC) ((i % 10) - 5));
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
      {
        FUNCTION (gsl_vector, set) (v, i, -(ATOMIC) (i % 10));
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
      {
        FUNCTION (gsl_vector, set) (v, i, (ATOMIC) (i % 10 + 1));
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
      {
        FUNCTION (gsl_vector, set) (v, i, -(ATOMIC) (i % 10 + 1));
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
      {
        if (FUNCTION (gsl_vector, get) (v, i) != (ATOMIC)0)
          status = 1;
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
      {
        if (FUNCTION (gsl_vector, get) (v, i) != (ATOMIC) (27))
          status = 1;
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
      {
        FUNCTION (gsl_vector, set_basis) (v, i);

        for(j = 0; j < N; j++)
          {
            if (i == j)
              {
                if (FUNCTION (gsl_vector, get) (v, j) != (ATOMIC)1)
                  status = 1 ;
              }
            else 
              {
                if (FUNCTION (gsl_vector, get) (v, j) != (ATOMIC)(0))
                  status = 1;
              }
          };
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
      {
        FUNCTION (gsl_vector, set) (v, i, (ATOMIC) i);
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
      {
        if (FUNCTION (gsl_vector, get) (v, i) != (ATOMIC) (i*2.0))
          status = 1;
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
      {
        if (FUNCTION (gsl_vector, get) (v, i) != (ATOMIC) (i*2.0 + 7))
          status = 1;
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
      {
        FUNCTION (gsl_vector, set) (v, i, (ATOMIC) i);
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
      {
        status |= (FUNCTION (gsl_vector, get) (v, i) !=  (ATOMIC) (N - i - 1));
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
      {
        if (FUNCTION (gsl_vector, get) (&v1.vector, i*stride) != FUNCTION (gsl_vector, get) (v, i)) 
          status = 1;
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
      {
        if (FUNCTION (gsl_vector, get) (&v1.vector, i) != FUNCTION (gsl_vector, get) (v, i)) 
          status = 1;
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N/2; i++)
      {
        if (FUNCTION (gsl_vector, get) (&v1.vector, i) != FUNCTION (gsl_vector, get) (v, (N/3) + i)) 
          status = 1;
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N/4; i++)
      {
        if (FUNCTION (gsl_vector, get) (&v1.vector, i) != FUNCTION (gsl_vector, get) (v, (N/5) + 3*i)) 
          status = 1;
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
      {
        BASE k = FUNCTION(gsl_vector, get) (v, i) ;
        if (k < exp_min) {
          exp_min = FUNCTION(gsl_vector, get) (v, i);
          exp_imin = i;
        }
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
      {
        BASE k = FUNCTION(gsl_vector, get) (v, i) ;
        if (k > exp_max) {
          exp_max = FUNCTION(gsl_vector, get) (v, i) ;
          exp_imax = i;
        } 
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
    {
      FUNCTION (gsl_vector, set) (a, i, (BASE)(3 + i));
      FUNCTION (gsl_vector, set) (b, i, (BASE)(3 + 2 * i));
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
      {
        BASE r = FUNCTION(gsl_vector,get) (v,i);
        BASE x = FUNCTION(gsl_vector,get) (a,i);
        BASE y = FUNCTION(gsl_vector,get) (b,i);
        BASE z = x + y;
        if (r != z)
          status = 1;
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
      {
        status |= (FUNCTION (gsl_vector, get) (a, i) != (BASE)(3 + 2 * i));
        status |= (FUNCTION (gsl_vector, get) (b, i) != (BASE)(3 + i));
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
      {
        status |= (FUNCTION (gsl_vector, get) (a, i) != (BASE)(3 + i));
        status |= (FUNCTION (gsl_vector, get) (b, i) != (BASE)(3 + 2 * i));
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
      {
        BASE r = FUNCTION(gsl_vector,get) (v,i);
        BASE x = FUNCTION(gsl_vector,get) (a,i);
        BASE y = FUNCTION(gsl_vector,get) (b,i);
        BASE z = x - y;
        if (r != z)
          status = 1;
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
      {
        BASE r = FUNCTION(gsl_vector,get) (v,i);
        BASE x = FUNCTION(gsl_vector,get) (a,i);
        BASE y = FUNCTION(gsl_vector,get) (b,i);
        BASE z = x * y;
        if (r != z)
          status = 1;
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
      {
        BASE r = FUNCTION(gsl_vector,get) (v,i);
        BASE x = FUNCTION(gsl_vector,get) (a,i);
        BASE y = FUNCTION(gsl_vector,get) (b,i);
        BASE z = x / y;
        if (fabs(r - z) > 2 * GSL_FLT_EPSILON * fabs(z))
          status = 1;
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
      {
        FUNCTION (gsl_vector, set) (v, i, (ATOMIC) (N - i));
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
      {
        if (w->data[i*stride] != (ATOMIC) (N - i))
          status = 1;
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
      {
        FUNCTION (gsl_vector, set) (v, i, (ATOMIC) i);
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
      {
        if (w->data[i*stride] != (ATOMIC) i)
          status = 1;
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < n; j++)
    {
      size_t k;
      
      for(k = 0; k < MULTIPLICITY; k++) 
        {
          if (v->data[MULTIPLICITY * stride * j + k] != 0.0)
            {
              return 0;
            }
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < n; j++)
    {
      size_t k;
      
      for(k = 0; k < MULTIPLICITY; k++) 
        {
          if (v->data[MULTIPLICITY * stride * j + k] <= 0.0)
            {
              return 0;
            }
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < n; j++)
    {
      size_t k;
      
      for(k = 0; k < MULTIPLICITY; k++) 
        {
          if (v->data[MULTIPLICITY * stride * j + k] >= 0.0)
            {
              return 0;
            }
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N*stride; i++)
        {
          BASE x = ZERO;
          GSL_REAL (x) = (ATOMIC)i;
          GSL_IMAG (x) = (ATOMIC)(i + 1234);
          FUNCTION (gsl_vector, set) (v0, i, x);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
      {
        BASE x = ZERO;
        GSL_REAL (x) = (ATOMIC)i;
        GSL_IMAG (x) = (ATOMIC)(i + 1234);
        FUNCTION (gsl_vector, set) (v, i, x);
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
      {
        if (v->data[2*i*stride] != (ATOMIC) (i) || v->data[2 * i * stride + 1] != (ATOMIC) (i + 1234))
          status = 1;
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
      {
        BASE x, y;
        GSL_REAL (x) = (ATOMIC)i;
        GSL_IMAG (x) = (ATOMIC)(i + 1234);
        y = FUNCTION (gsl_vector, get) (v, i);
        if (!GSL_COMPLEX_EQ (x, y))
          status = 1;
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
      {
        if (FUNCTION (gsl_vector, ptr) (v, i) != (BASE *)v->data + i*stride)
          status = 1;
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
      {
        if (FUNCTION (gsl_vector, const_ptr) (v, i) != (BASE *)v->data + i*stride)
          status = 1;
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
      {
        BASE x = ZERO;
        FUNCTION (gsl_vector, set) (v, i, x);
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
      {
        BASE x = ZERO;
        GSL_REAL (x) = (ATOMIC)i;
        GSL_IMAG (x) = (ATOMIC)(i + 1234);
        FUNCTION (gsl_vector, set) (v, i, x);
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
      {
        BASE x, y = ZERO;
        x = FUNCTION (gsl_vector, get) (v, i);
        if (!GSL_COMPLEX_EQ (x, y))
          status = 1;
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
      {
        BASE y = FUNCTION (gsl_vector, get) (v, i);
        if (!GSL_COMPLEX_EQ (x, y))
          status = 1;
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
      {
        FUNCTION (gsl_vector, set_basis) (v, i);

        for(j = 0; j < N; j++)
          {
            BASE x = FUNCTION (gsl_vector, get) (v, j);
            BASE one = ONE;
            BASE zero = ZERO;
              
            if (i == j)
              {
                if (!GSL_COMPLEX_EQ (x, one))
                  status = 1 ;
              }
            else 
              {
                if (!GSL_COMPLEX_EQ (x, zero))
                  status = 1;
              }
          };
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
    {
      BASE x = ZERO;
      GSL_REAL (x) = (ATOMIC)i;
      GSL_IMAG (x) = (ATOMIC)(i + 1234);
      FUNCTION (gsl_vector, set) (v, i, x);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
      {
        BASE x,r ;
        GSL_REAL(x) = (ATOMIC)(N - i - 1) ;
        GSL_IMAG(x) = (ATOMIC)(N - i - 1 + 1234);
        
        r = FUNCTION (gsl_vector, get) (v, i);
        
        status |= !GSL_COMPLEX_EQ(r,x);
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
      {
        BASE x = FUNCTION (gsl_vector, get) (&v1.vector, i*stride) ;
        BASE y = FUNCTION (gsl_vector, get) (v, i);
        if (!GSL_COMPLEX_EQ(x,y)) 
          status = 1;
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
      {
        BASE x = FUNCTION (gsl_vector, get) (&v1.vector, i) ;
        BASE y = FUNCTION (gsl_vector, get) (v, i);
        if (!GSL_COMPLEX_EQ(x,y)) 
          status = 1;
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N/2; i++)
      {
        BASE x = FUNCTION (gsl_vector, get) (&v1.vector, i) ;
        BASE y = FUNCTION (gsl_vector, get) (v, (N/3)+i);
        if (!GSL_COMPLEX_EQ(x,y)) 
          status = 1;
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N/4; i++)
      {
        BASE x = FUNCTION (gsl_vector, get) (&v1.vector, i) ;
        BASE y = FUNCTION (gsl_vector, get) (v, (N/5)+3*i);
        if (!GSL_COMPLEX_EQ(x,y)) 
          status = 1;
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
      {
        ATOMIC xr = REAL_VIEW (gsl_vector, get) (&vv.vector, i) ;
        BASE y = FUNCTION (gsl_vector, get) (v, i);
        ATOMIC yr = GSL_REAL(y);

        if (xr != yr) 
          status = 1;
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
      {
        ATOMIC xr = REAL_VIEW (gsl_vector, get) (&vv.vector, i) ;
        BASE y = FUNCTION (gsl_vector, get) (v, i);
        ATOMIC yr = GSL_IMAG(y);

        if (xr != yr) 
          status = 1;
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
      {
        BASE x = ZERO;
        GSL_REAL (x) = (ATOMIC)(N - i);
        GSL_IMAG (x) = (ATOMIC)(N - i + 1);
        FUNCTION (gsl_vector, set) (v, i, x);
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
      {
        if (w->data[2 * i * stride] != (ATOMIC) (N - i) || w->data[2 * i * stride + 1] != (ATOMIC) (N - i + 1))
          status = 1;
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
      {
        BASE x;
        GSL_REAL (x) = (ATOMIC)i;
        GSL_IMAG (x) = (ATOMIC)(i + 1);
        FUNCTION (gsl_vector, set) (v, i, x);
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
      {
        if (w->data[2 * i * stride] != (ATOMIC) i || w->data[2 * i * stride + 1] != (ATOMIC) (i + 1))
          status = 1;
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < MULTIPLICITY * n; i++)
    {
      v->data[i] = 0;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
    {
      *(BASE *) (data + MULTIPLICITY * i * stride) = x;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
    {
      *(BASE *) (data + MULTIPLICITY * i * stride) = zero;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 0; k < n; k++)
    {
      *(BASE *) (data + MULTIPLICITY * k * stride) = zero;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
        {
          a->data[i * stride_a] += b->data[i * stride_b];
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
        {
          a->data[i * stride_a] -= b->data[i * stride_b];
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
        {
          a->data[i * stride_a] *= b->data[i * stride_b];
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
        {
          a->data[i * stride_a] /= b->data[i * stride_b];
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
    {
      a->data[i * stride] *= x;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
    {
      a->data[i * stride] += x;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < norris_n; i++) 
    {
      x[i*xstride] = norris_x[i];
      w[i*wstride] = 1.0;
      y[i*ystride] = norris_y[i];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < noint1_n; i++) 
    {
      x[i*xstride] = noint1_x[i];
      w[i*wstride] = 1.0;
      y[i*ystride] = noint1_y[i];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < noint2_n; i++) 
    {
      x[i*xstride] = noint2_x[i];
      w[i*wstride] = 1.0;
      y[i*ystride] = noint2_y[i];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
    {
      m_x += (x[i * xstride] - m_x) / (i + 1.0);
      m_y += (y[i * ystride] - m_y) / (i + 1.0);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
    {
      const double dx = x[i * xstride] - m_x;
      const double dy = y[i * ystride] - m_y;

      m_dx2 += (dx * dx - m_dx2) / (i + 1.0);
      m_dxdy += (dx * dy - m_dxdy) / (i + 1.0);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
      {
        const double dx = x[i * xstride] - m_x;
        const double dy = y[i * ystride] - m_y;
        const double d = dy - b * dx;
        d2 += d * d;
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
    {
      const double wi = w[i * wstride];

      if (wi > 0)
        {
          W += wi;
          wm_x += (x[i * xstride] - wm_x) * (wi / W);
          wm_y += (y[i * ystride] - wm_y) * (wi / W);
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
    {
      const double wi = w[i * wstride];

      if (wi > 0)
        {
          const double dx = x[i * xstride] - wm_x;
          const double dy = y[i * ystride] - wm_y;

          W += wi;
          wm_dx2 += (dx * dx - wm_dx2) * (wi / W);
          wm_dxdy += (dx * dy - wm_dxdy) * (wi / W);
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
      {
        const double wi = w[i * wstride];

        if (wi > 0)
          {
            const double dx = x[i * xstride] - wm_x;
            const double dy = y[i * ystride] - wm_y;
            const double d = dy - b * dx;
            d2 += wi * d * d;
          }
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
    {
      m_x += (x[i * xstride] - m_x) / (i + 1.0);
      m_y += (y[i * ystride] - m_y) / (i + 1.0);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
    {
      const double dx = x[i * xstride] - m_x;
      const double dy = y[i * ystride] - m_y;

      m_dx2 += (dx * dx - m_dx2) / (i + 1.0);
      m_dxdy += (dx * dy - m_dxdy) / (i + 1.0);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
      {
        const double dx = x[i * xstride] - m_x;
        const double dy = y[i * ystride] - m_y;
        const double d = (m_y - b * m_x) + dy - b * dx;
        d2 += d * d;
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
    {
      const double wi = w[i * wstride];

      if (wi > 0)
        {
          W += wi;
          wm_x += (x[i * xstride] - wm_x) * (wi / W);
          wm_y += (y[i * ystride] - wm_y) * (wi / W);
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
    {
      const double wi = w[i * wstride];

      if (wi > 0)
        {
          const double dx = x[i * xstride] - wm_x;
          const double dy = y[i * ystride] - wm_y;

          W += wi;
          wm_dx2 += (dx * dx - wm_dx2) * (wi / W);
          wm_dxdy += (dx * dy - wm_dxdy) * (wi / W);
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
      {
        const double wi = w[i * wstride];

        if (wi > 0)
          {
            const double dx = x[i * xstride] - wm_x;
            const double dy = y[i * ystride] - wm_y;
            const double d = (wm_y - b * wm_x) + (dy - b * dx);
            d2 += wi * d * d;
          }
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6 ; i++) 
        gsl_test_rel(w->alist[i],a[i],1e-15,"qag(f1) smooth alist") ;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6 ; i++) 
        gsl_test_rel(w->blist[i],b[i],1e-15,"qag(f1) smooth blist") ;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6 ; i++) 
        gsl_test_rel(w->rlist[i],r[i],1e-15,"qag(f1) smooth rlist") ;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6 ; i++) 
        gsl_test_rel(w->elist[i],e[i],1e-6,"qag(f1) smooth elist") ;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6 ; i++) 
        gsl_test_int((int)w->order[i],order[i]-1,"qag(f1) smooth order") ;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 8 ; i++) 
        gsl_test_rel(w->alist[i],a[i],1e-15,"qag(f1,21pt) smooth alist") ;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 8 ; i++) 
        gsl_test_rel(w->blist[i],b[i],1e-15,"qag(f1,21pt) smooth blist") ;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 8 ; i++) 
        gsl_test_rel(w->rlist[i],r[i],1e-15,"qag(f1,21pt) smooth rlist") ;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 8 ; i++) 
        gsl_test_rel(w->elist[i],e[i],1e-6,"qag(f1,21pt) smooth elist") ;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 8 ; i++) 
        gsl_test_int((int)w->order[i],order[i]-1,"qag(f1,21pt) smooth order");



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3 ; i++) 
        gsl_test_rel(w->alist[i],a[i],1e-15,"qag(f16,61pt) limit alist") ;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3 ; i++) 
        gsl_test_rel(w->blist[i],b[i],1e-15,"qag(f16,61pt) limit blist") ;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3 ; i++) 
        gsl_test_rel(w->rlist[i],r[i],1e-15,"qag(f16,61pt) limit rlist") ;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3 ; i++) 
        gsl_test_rel(w->elist[i],e[i],1e-6,"qag(f16,61pt) limit elist") ;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3 ; i++) 
        gsl_test_int((int)w->order[i],order[i]-1,"qag(f16,61pt) limit order");



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 5 ; i++) 
        gsl_test_rel(w->alist[i],a[i],1e-15,"qags(f1) smooth alist") ;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 5 ; i++) 
        gsl_test_rel(w->blist[i],b[i],1e-15,"qags(f1) smooth blist") ;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 5 ; i++) 
        gsl_test_rel(w->rlist[i],r[i],1e-15,"qags(f1) smooth rlist") ;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 5 ; i++) 
        gsl_test_rel(w->elist[i],e[i],1e-6,"qags(f1) smooth elist") ;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 5 ; i++) 
        gsl_test_int((int)w->order[i],order[i]-1,"qags(f1) smooth order") ;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 9 ; i++) 
        gsl_test_rel(w->alist[i],a[i],1e-15,"qags(f11) smooth alist") ;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 9 ; i++) 
        gsl_test_rel(w->blist[i],b[i],1e-15,"qags(f11) smooth blist") ;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 9 ; i++) 
        gsl_test_rel(w->rlist[i],r[i],1e-15,"qags(f11) smooth rlist") ;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 9 ; i++) 
        gsl_test_rel(w->elist[i],e[i],1e-5,"qags(f11) smooth elist") ;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 9 ; i++) 
        gsl_test_int((int)w->order[i],order[i]-1,"qags(f11) smooth order");



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 10 ; i++) 
        gsl_test_rel(w->alist[i],a[i],1e-15,"qagiu(f455) smooth alist") ;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 10 ; i++) 
        gsl_test_rel(w->blist[i],b[i],1e-15,"qagiu(f455) smooth blist") ;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 10 ; i++) 
        gsl_test_rel(w->rlist[i],r[i],1e-15,"qagiu(f455) smooth rlist") ;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 10 ; i++) 
        gsl_test_rel(w->elist[i],e[i],1e-4,"qagiu(f455) smooth elist") ;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 10 ; i++) 
        gsl_test_int((int)w->order[i],order[i]-1,"qagiu(f455) smooth order");



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 10 ; i++) 
        gsl_test_rel(w->alist[i],a[i],1e-15,"qagiu(f15) smooth alist") ;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 10 ; i++) 
        gsl_test_rel(w->blist[i],b[i],1e-15,"qagiu(f15) smooth blist") ;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 10 ; i++) 
        gsl_test_rel(w->rlist[i],r[i],1e-15,"qagiu(f15) smooth rlist") ;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 10 ; i++) 
        gsl_test_rel(w->elist[i],e[i],1e-4,"qagiu(f15) smooth elist") ;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 10 ; i++) 
        gsl_test_int((int)w->order[i],order[i]-1,"qagiu(f15) smooth order");



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6 ; i++) 
        gsl_test_rel(w->alist[i],a[i],1e-15,"qagiu(f16) smooth alist") ;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6 ; i++) 
        gsl_test_rel(w->blist[i],b[i],1e-15,"qagiu(f16) smooth blist") ;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6 ; i++) 
        gsl_test_rel(w->rlist[i],r[i],1e-15,"qagiu(f16) smooth rlist") ;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6 ; i++) 
        gsl_test_rel(w->elist[i],e[i],1e-4,"qagiu(f16) smooth elist") ;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6 ; i++) 
        gsl_test_int((int)w->order[i],order[i]-1,"qagiu(f16) smooth order");



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 5 ; i++) 
        gsl_test_rel(w->alist[i],a[i],1e-15,"qagiu(myfn1) smooth alist") ;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 5 ; i++) 
        gsl_test_rel(w->blist[i],b[i],1e-15,"qagiu(myfn1) smooth blist") ;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 5 ; i++) 
        gsl_test_rel(w->rlist[i],r[i],1e-14,"qagiu(myfn1) smooth rlist") ;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 5 ; i++) 
        gsl_test_rel(w->elist[i],e[i],1e-4,"qagiu(myfn1) smooth elist") ;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 5 ; i++) 
        gsl_test_int((int)w->order[i],order[i]-1,"qagiu(myfn1) smooth order");



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 5 ; i++) 
        gsl_test_rel(w->alist[i],a[i],1e-15,"qagiu(myfn2) smooth alist") ;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 5 ; i++) 
        gsl_test_rel(w->blist[i],b[i],1e-15,"qagiu(myfn2) smooth blist") ;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 5 ; i++) 
        gsl_test_rel(w->rlist[i],r[i],1e-14,"qagiu(myfn2) smooth rlist") ;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 5 ; i++) 
        gsl_test_rel(w->elist[i],e[i],1e-4,"qagiu(myfn2) smooth elist") ;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 5 ; i++) 
        gsl_test_int((int)w->order[i],order[i]-1,"qagiu(myfn2) smooth order");



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 20 ; i++) 
        gsl_test_rel(w->alist[i],a[i],1e-15,"qagp(f454) singular alist") ;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 20 ; i++) 
        gsl_test_rel(w->blist[i],b[i],1e-15,"qagp(f454) singular blist") ;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 20 ; i++) 
        gsl_test_rel(w->rlist[i],r[i],1e-14,"qagp(f454) singular rlist") ;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 20 ; i++) 
        gsl_test_rel(w->elist[i],e[i],1e-4,"qagp(f454) singular elist") ;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 20 ; i++) 
        gsl_test_int((int)w->order[i],order[i]-1,"qagp(f454) singular order");



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6 ; i++) 
        gsl_test_rel(w->alist[i],a[i],1e-15,"qawc(f459) alist") ;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6 ; i++) 
        gsl_test_rel(w->blist[i],b[i],1e-15,"qawc(f459) blist") ;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6 ; i++) 
        gsl_test_rel(w->rlist[i],r[i],1e-14,"qawc(f459) rlist") ;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6 ; i++) 
        gsl_test_rel(w->elist[i],e[i],1e-5,"qawc(f459) elist") ;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6 ; i++) 
        gsl_test_int((int)w->order[i],order[i]-1,"qawc(f459) order");



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6 ; i++) 
        gsl_test_rel(w->alist[i],a[i],1e-15,"qaws(f458) ln(x-a) alist") ;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6 ; i++) 
        gsl_test_rel(w->blist[i],b[i],1e-15,"qaws(f458) ln(x-a) blist") ;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6 ; i++) 
        gsl_test_rel(w->rlist[i],r[i],1e-14,"qaws(f458) ln(x-a) rlist") ;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6 ; i++) 
        gsl_test_rel(w->elist[i],e[i],1e-4,"qaws(f458) ln(x-a) elist") ;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6 ; i++) 
        gsl_test_int((int)w->order[i],order[i]-1,"qaws(f458) ln(x-a) order");



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 9 ; i++) 
        gsl_test_rel(w->alist[i],a[i],1e-15,"qawo(f456) alist") ;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 9 ; i++) 
        gsl_test_rel(w->blist[i],b[i],1e-15,"qawo(f456) blist") ;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 9 ; i++) 
        gsl_test_rel(w->rlist[i],r[i],1e-14,"qawo(f456) rlist") ;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 9 ; i++) 
        gsl_test_rel(w->elist[i],e[i],1e-3,"qawo(f456) elist") ;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 9 ; i++) 
        gsl_test_int((int)w->order[i],order[i]-1,"qawo(f456) order");



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 9 ; i++) 
        gsl_test_rel(w->rlist[i],r[i],1e-12,"qawf(f457) rlist") ;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 9 ; i++) 
        gsl_test_rel(w->elist[i],e[i],50.0,"qawf(f457) elist") ;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nint; i++)
    {
      if (pts[i + 1] < pts[i])
        {
          GSL_ERROR ("points are not in an ascending sequence", GSL_EINVAL);
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nint; i++)
    {
      double area1, error1, resabs1, resasc1;
      const double a1 = pts[i];
      const double b1 = pts[i + 1];

      q (f, a1, b1, &area1, &error1, &resabs1, &resasc1);

      result0 = result0 + area1;
      abserr0 = abserr0 + error1;
      resabs0 = resabs0 + resabs1;

      append_interval (workspace, a1, b1, area1, error1);

      if (error1 == resasc1 && error1 != 0.0)
        {
          ndin[i] = 1;
        }
      else
        {
          ndin[i] = 0;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nint; i++)
    {
      if (ndin[i])
        {
          workspace->elist[i] = abserr0;
        }

      errsum = errsum + workspace->elist[i];

    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nint; i++)
    {
      workspace->level[i] = 0;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(iteration = 0; iteration < limit; iteration++)
    {
      double area1, error1, reseps, erreps;

      double a1 = a + iteration * cycle;
      double b1 = a1 + cycle;

      double epsabs1 = eps * factor;

      int status = gsl_integration_qawo (f, a1, epsabs1, 0.0, limit,
                                         cycle_workspace, wf,
                                         &area1, &error1);

      append_interval (workspace, a1, b1, area1, error1);

      factor *= p;

      area = area + area1;
      errsum = errsum + error1;

      

      truncation_error = 50 * fabs (area1);

      total_error = errsum + truncation_error;

      if (total_error < epsabs && iteration > 4)
        {
          goto compute_result;
        }

      if (error1 > correc)
        {
          correc = error1;
        }

      if (status)
        {
          eps = GSL_MAX_DBL (initial_eps, correc * (1.0 - p));
        }

      if (status && total_error < 10 * correc && iteration > 3)
        {
          goto compute_result;
        }

      append_table (&table, area);

      if (table.n < 2)
        {
          continue;
        }

      qelg (&table, &reseps, &erreps);

      ktmin++;

      if (ktmin >= 15 && err_ext < 0.001 * total_error)
        {
          error_type = 4;
        }

      if (erreps < err_ext)
        {
          ktmin = 0;
          err_ext = erreps;
          res_ext = reseps;

          if (err_ext + 10 * correc <= epsabs)
            break;
          if (err_ext <= epsabs && 10 * correc >= epsabs)
            break;
        }

    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i < 12; i++)
    {
      const size_t j = 24 - i;
      const double u = half_length * x[i-1];
      fval[i] = GSL_FN_EVAL(f, center + u);
      fval[j] = GSL_FN_EVAL(f, center - u);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 12; i++)
    {
      const size_t j = 24 - i;
      v[i] = fval[i] - fval[j];
      fval[i] = fval[i] + fval[j];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++)
    {
      const size_t j = 12 - i;
      v[i] = fval[i] - fval[j];
      fval[i] = fval[i] + fval[j];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++)
    {
      const size_t j = 6 - i;
      v[i] = fval[i] - fval[j];
      fval[i] = fval[i] + fval[j];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i < 12; i++)
    {
      cheb12[i] *= 1.0 / 6.0;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i < 24; i++)
    {
      cheb24[i] *= 1.0 / 12.0;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 2; i < 25; i++)
    {
      ri[i] = -(r_alpha + an * (an - alpha_p2) * ri[i - 1])
        / (anm1 * (an + alpha_p1));
      anm1 = an;
      an = an + 1.0;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 2; i < 25; i++)
    {
      rj[i] = -(r_beta + an * (an - beta_p2) * rj[i - 1])
        / (anm1 * (an + beta_p1));
      anm1 = an;
      an = an + 1.0;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 2; i < 25; i++)
    {
      rg[i] = -(an * (an - alpha_p2) * rg[i - 1] - an * ri[i - 1]
                + anm1 * ri[i]) / (anm1 * (an + alpha_p1));
      anm1 = an;
      an = an + 1.0;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 2; i < 25; i++)
    {
      rh[i] = -(an * (an - beta_p2) * rh[i - 1] - an * rj[i - 1]
                + anm1 * rj[i]) / (anm1 * (an + beta_p1));
      anm1 = an;
      an = an + 1.0;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i < 25; i += 2)
    {
      rj[i] *= -1;
      rh[i] *= -1;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 0; k < 5; k++)
    {
      const double abscissa = half_length * x1[k];
      const double fval1 = GSL_FN_EVAL(f, center + abscissa);
      const double fval2 = GSL_FN_EVAL(f, center - abscissa);
      const double fval = fval1 + fval2;
      res10 += w10[k] * fval;
      res21 += w21a[k] * fval;
      resabs += w21a[k] * (fabs (fval1) + fabs (fval2));
      savfun[k] = fval;
      fv1[k] = fval1;
      fv2[k] = fval2;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 0; k < 5; k++)
    {
      const double abscissa = half_length * x2[k];
      const double fval1 = GSL_FN_EVAL(f, center + abscissa);
      const double fval2 = GSL_FN_EVAL(f, center - abscissa);
      const double fval = fval1 + fval2;
      res21 += w21b[k] * fval;
      resabs += w21b[k] * (fabs (fval1) + fabs (fval2));
      savfun[k + 5] = fval;
      fv3[k] = fval1;
      fv4[k] = fval2;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 0; k < 5; k++)
      {
        resasc +=
          (w21a[k] * (fabs (fv1[k] - mean) + fabs (fv2[k] - mean))
          + w21b[k] * (fabs (fv3[k] - mean) + fabs (fv4[k] - mean)));
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 0; k < 10; k++)
    {
      res43 += savfun[k] * w43a[k];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 0; k < 11; k++)
    {
      const double abscissa = half_length * x3[k];
      const double fval = (GSL_FN_EVAL(f, center + abscissa) 
                           + GSL_FN_EVAL(f, center - abscissa));
      res43 += fval * w43b[k];
      savfun[k + 10] = fval;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 0; k < 21; k++)
    {
      res87 += savfun[k] * w87a[k];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 0; k < 22; k++)
    {
      const double abscissa = half_length * x4[k];
      res87 += w87b[k] * (GSL_FN_EVAL(f, center + abscissa) 
                          + GSL_FN_EVAL(f, center - abscissa));
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nint; i++)
    {
      size_t i1 = order[i];
      double e1 = elist[i1];
      size_t i_max = i1;
      size_t j;

      for(j = i + 1; j < nint; j++)
        {
          size_t i2 = order[j];
          double e2 = elist[i2];

          if (e2 >= e1)
            {
              i_max = i2;
              e1 = e2;
            }
        }

      if (i_max != i1)
        {
          order[i] = order[i_max];
          order[i_max] = i1;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < (n - 1) / 2; j++)
    {
      const int jtw = j * 2 + 1;        
      const double abscissa = half_length * xgk[jtw];
      const double fval1 = GSL_FN_EVAL (f, center - abscissa);
      const double fval2 = GSL_FN_EVAL (f, center + abscissa);
      const double fsum = fval1 + fval2;
      fv1[jtw] = fval1;
      fv2[jtw] = fval2;
      result_gauss += wg[j] * fsum;
      result_kronrod += wgk[jtw] * fsum;
      result_abs += wgk[jtw] * (fabs (fval1) + fabs (fval2));
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < n / 2; j++)
    {
      int jtwm1 = j * 2;
      const double abscissa = half_length * xgk[jtwm1];
      const double fval1 = GSL_FN_EVAL (f, center - abscissa);
      const double fval2 = GSL_FN_EVAL (f, center + abscissa);
      fv1[jtwm1] = fval1;
      fv2[jtwm1] = fval2;
      result_kronrod += wgk[jtwm1] * (fval1 + fval2);
      result_abs += wgk[jtwm1] * (fabs (fval1) + fabs (fval2));
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < n - 1; j++)
    {
      result_asc += wgk[j] * (fabs (fv1[j] - mean) + fabs (fv2[j] - mean));
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 13; i++)
    {
      res12 += r[i] * cheb12[i];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 25; i++)
    {
      res24 += r[i] * cheb24[i];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0 ; i < t->n; i++)
      {
        compute_moments (t->par * scale, t->chebmo + 25*i);
        scale *= 0.5;
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0 ; i < t->n; i++)
      {
        compute_moments (t->par * scale, t->chebmo + 25*i);
        scale *= 0.5;
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0 ; i < t->n; i++)
      {
        compute_moments (t->par * scale, t->chebmo + 25*i);
        scale *= 0.5;
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 0; k < noeq - 1; k++)
        {
          an2 = an * an;
          d[k] = -2 * (an2 - 4) * (par22 - 2 * an2);
          d2[k] = (an - 1) * (an - 2) * par2;
          d1[k + 1] = (an + 3) * (an + 4) * par2;
          v[k + 3] = as - (an2 - 4) * ac;
          an = an + 2.0;
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 3; k < 13; k++)
        {
          double an2 = an * an;
          v[k] = ((an2 - 4) * (2 * (par22 - 2 * an2) * v[k - 1] - ac)
                  + as - par2 * (an + 1) * (an + 2) * v[k - 2]) 
            / (par2 * (an - 1) * (an - 2));
          an = an + 2.0;
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 13; i++)
    {
      chebmo[2 * i] = v[i];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 0; k < noeq - 1; k++)
        {
          an2 = an * an;
          d[k] = -2 * (an2 - 4) * (par22 - 2 * an2);
          d2[k] = (an - 1) * (an - 2) * par2;
          d1[k + 1] = (an + 3) * (an + 4) * par2;
          v[k + 2] = ac + (an2 - 4) * as;
          an = an + 2.0;
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 2; k < 12; k++)
        {
          double an2 = an * an;
          v[k] = ((an2 - 4) * (2 * (par22 - 2 * an2) * v[k - 1] + as)
                  + ac - par2 * (an + 1) * (an + 2) * v[k - 2]) 
            / (par2 * (an - 1) * (an - 2));
          an = an + 2.0;
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 12; i++)
    {
      chebmo[2 * i + 1] = v[i];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 0; k < n - 1; k++)
    {
      size_t k1 = k + 1;

      if (fabs (c[k1]) >= fabs (c[k]))
        {
          {
            double t = c[k1];
            c[k1] = c[k];
            c[k] = t;
          };
          {
            double t = d[k1];
            d[k1] = d[k];
            d[k] = t;
          };
          {
            double t = e[k1];
            e[k1] = e[k];
            e[k] = t;
          };
          {
            double t = b[k1];
            b[k1] = b[k];
            b[k] = t;
          };
        }

      if (c[k] == 0)
        {
          return GSL_FAILURE ;
        }

      {
        double t = -c[k1] / c[k];

        c[k1] = d[k1] + t * d[k];
        d[k1] = e[k1] + t * e[k];
        e[k1] = 0;
        b[k1] = b[k1] + t * b[k];
      }

    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = n ; k > 2; k--)
    {
      size_t kb = k - 3;
      b[kb] = (b[kb] - d[kb] * b[kb + 1] - e[kb] * b[kb + 2]) / c[kb];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = id; k <= jupbnd; k++)
    {
      size_t i_max = order[workspace->nrmax];
      
      workspace->i = i_max ;

      if (level[i_max] < workspace->maximum_level)
        {
          return 1;
        }

      workspace->nrmax++;

    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 13; i++)
        {
          res12 += cheb12[i] * moment[i];
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 25; i++)
        {
          res24 += cheb24[i] * moment[i];
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 2; k < 25; k++)
    {
      double a2;

      if ((k % 2) == 0)
        {
          a2 = 2.0 * cc * a1 - a0;
        }
      else
        {
          const double km1 = k - 1.0;
          a2 = 2.0 * cc * a1 - a0 - 4.0 / (km1 * km1 - 1.0);
        }

      moment[k] = a2;

      a0 = a1;
      a1 = a2;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < newelm; i++)
    {
      double res = epstab[n - 2 * i + 2];
      double e0 = epstab[n - 2 * i - 2];
      double e1 = epstab[n - 2 * i - 1];
      double e2 = res;

      double e1abs = fabs (e1);
      double delta2 = e2 - e1;
      double err2 = fabs (delta2);
      double tol2 = GSL_MAX_DBL (fabs (e2), e1abs) * GSL_DBL_EPSILON;
      double delta3 = e1 - e0;
      double err3 = fabs (delta3);
      double tol3 = GSL_MAX_DBL (e1abs, fabs (e0)) * GSL_DBL_EPSILON;

      double e3, delta1, err1, tol1, ss;

      if (err2 <= tol2 && err3 <= tol3)
        {
          


          *result = res;
          absolute = err2 + err3;
          relative = 5 * GSL_DBL_EPSILON * fabs (res);
          *abserr = GSL_MAX_DBL (absolute, relative);
          return;
        }

      e3 = epstab[n - 2 * i];
      epstab[n - 2 * i] = e1;
      delta1 = e1 - e3;
      err1 = fabs (delta1);
      tol1 = GSL_MAX_DBL (e1abs, fabs (e3)) * GSL_DBL_EPSILON;

      


      if (err1 <= tol1 || err2 <= tol2 || err3 <= tol3)
        {
          n_final = 2 * i;
          break;
        }

      ss = (1 / delta1 + 1 / delta2) - 1 / delta3;

      



      if (fabs (ss * e1) <= 0.0001)
        {
          n_final = 2 * i;
          break;
        }

      


      res = e1 + 1 / ss;
      epstab[n - 2 * i] = res;

      {
        const double error = err2 + fabs (res - e2) + err3;

        if (error <= *abserr)
          {
            *abserr = error;
            *result = res;
          }
      }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i <= newelm; i++)
        {
          epstab[1 + i * 2] = epstab[i * 2 + 3];
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i <= newelm; i++)
        {
          epstab[i * 2] = epstab[i * 2 + 2];
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i <= n_final; i++)
        {
          epstab[i] = epstab[n_orig - n_final + i];
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 0; k < n; k++)
    {
      result_sum += rlist[k];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++)
        {
          size_t k = 10 - 2 * i;
          res12_cos += cheb12[k] * moment[k];
          res12_sin += cheb12[k + 1] * moment[k + 1];
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 12; i++)
        {
          size_t k = 22 - 2 * i;
          res24_cos += cheb24[k] * moment[k];
          res24_sin += cheb24[k + 1] * moment[k + 1];
          result_abs += fabs(cheb24[k]) + fabs(cheb24[k+1]);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < size; i++) 
    {
      if (p->data[i] >= size)
        {
          GSL_ERROR("permutation index outside range", GSL_FAILURE) ;
        }

      for(j = 0; j < i; j++)
        {
          if (p->data[i] == p->data[j])
            {
              GSL_ERROR("duplicate permutation index", GSL_FAILURE) ;
            }
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < (size / 2); i++) 
    {
      size_t j = size - i - 1;

      size_t tmp = p->data[i] ;
      p->data[i] = p->data[j] ;
      p->data[j] = tmp ;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < size; i++) 
    {
      inv->data[p->data[i]] = i ;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = i + 2; j < size; j++ )
    {
      if ((p->data[j] > p->data[i]) && (p->data[j] < p->data[k]))
        {
          k = j;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = i + 1; j <= ((size + i) / 2); j++)
    {
      size_t tmp = p->data[j];
      p->data[j] = p->data[size + i - j];
      p->data[size + i - j] = tmp;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = i + 2; j < size; j++ )
    {
      if ((p->data[j] < p->data[i]) && (p->data[j] > p->data[k]))
        {
          k = j;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = i + 1; j <= ((size + i) / 2); j++)
    {
      size_t tmp = p->data[j];
      p->data[j] = p->data[size + i - j];
      p->data[size + i - j] = tmp;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < size; i++)
    {
      p->data[i] = pb->data[pa->data[i]];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < src_size; j++)
      {
        dest->data[j] = src->data[j];
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < 5; j++)
          {
            status |= (p->data[j] != p5[i][j]);
          }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < 5; j++)
          {
            status |= (p->data[j] != p5[i][j]);
          }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 5; i++) 
              {
                if (x[i] != y[i]) 
                  status = 1;
              }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < 5; j++)
          {
            pcan->data[j] = 0;
          }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < 5; j++)
          {
            status |= (pcan->data[j] != c5[i][j]);
          }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < 5; j++)
          {
            plin->data[j] = 0;
          }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < 5; j++)
          {
            status |= (plin->data[j] != p5[i][j]);
          }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
    {
      p->data[i] = i;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
    {
      p->data[i] = i;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
    {
      int status = fprintf (stream, format, data[i]);

      if (status < 0)
        {
          GSL_ERROR ("fprintf failed", GSL_EFAILED);
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
    {
      unsigned long j ;  

      




      int status = fscanf (stream, IN_FORMAT, &j);  

      if (status != 1)
        {
          GSL_ERROR ("fscanf failed", GSL_EFAILED);
        }

      data[i] = j;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
    {

      k = pp[i];
      s = 1;

      while (k > i)
        {
          k = pp[k];
          s++;
        }

      if (k < i)
        continue;

      

      t -= s;

      qq[t] = i;

      k = pp[i];
      s = 1;

      while (k > i)
        {
          qq[t + s] = k;
          k = pp[k];
          s++;
        }

      if (t == 0)
        break;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
    {
      pp[i] = i;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i < n; i++)
    {
      kk = qq[i];

      if (kk > first)
        {
          pp[k] = pp[kk];
          k = kk;
        }
      else
        {
          pp[k] = first;
          k = kk;
          first = pp[kk];
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < size - 1; i++)
    {
      for(j = i + 1; j < size; j++)
        {
          if (p->data[i] > p->data[j])
            {
              count++;
            }
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < size; i++)
    {

      k = p->data[i];

      while (k > i)
        {
          k = p->data[k];
        }

      if (k < i)
        continue;

      count++;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < p->size; i++)
    {
      if (p->data[i] < min)
        {
          min = p->data[i];
          count++;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
    {
      k = p[i];
      
      while (k > i) 
        k = p[k];
      
      if (k < i)
        continue ;
      
      
      
      pk = p[k];
      
      if (pk == i)
        continue ;
      
      
      
      {
        unsigned int a;

        ATOMIC t[MULTIPLICITY];
        
        for(a = 0; a < MULTIPLICITY; a++)
          t[a] = data[i*stride*MULTIPLICITY + a];
      
        while (pk != i)
          {
            for(a = 0; a < MULTIPLICITY; a++)
              {
                ATOMIC r1 = data[pk*stride*MULTIPLICITY + a];
                data[k*stride*MULTIPLICITY + a] = r1;
              }
            k = pk;
            pk = p[k];
          };
        
        for(a = 0; a < MULTIPLICITY; a++)
          data[k*stride*MULTIPLICITY + a] = t[a];
      }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
    {
      k = p[i];
          
      while (k > i) 
        k = p[k];

      if (k < i)
        continue ;
      
      

      pk = p[k];

      if (pk == i)
        continue ;
      
      
      
      {
        unsigned int a;

        ATOMIC t[MULTIPLICITY];

        for(a = 0; a < MULTIPLICITY; a++)
          t[a] = data[k*stride*MULTIPLICITY+a];

        while (pk != i)
          {
            for(a = 0; a < MULTIPLICITY; a++)
              {
                ATOMIC r1 = data[pk*stride*MULTIPLICITY + a];
                data[pk*stride*MULTIPLICITY + a] = t[a];
                t[a] = r1;
              }

            k = pk;
            pk = p[k];
          };

        for(a = 0; a < MULTIPLICITY; a++)
          data[pk*stride*MULTIPLICITY+a] = t[a];
      }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0 ; i < 10; i++) 
    {
      double r = (i - 5.0) * 0.3 ;
      double t = 2.0 * M_PI * i / 5 ;
      double x = r * cos(t), y = r * sin(t) ;
      gsl_complex z = gsl_complex_polar (r, t) ;
      gsl_test_rel (GSL_REAL(z), x, 10 * GSL_DBL_EPSILON, "gsl_complex_polar real part at (r=%g,t=%g)", r, t);
      
      gsl_test_rel (GSL_IMAG(z), y, 10 * GSL_DBL_EPSILON, "gsl_complex_polar imag part at (r=%g,t=%g)", r, t);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++) { printf("%g\n", (x)) ; }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++) { a ; printf("%g\n", x) ; }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++) { a ; printf("%g %g\n", x, y) ; }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++) { a ; printf("%g %g %g\n", x, y, z) ; }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++) { printf("%d\n", (x)) ; }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++) { 
        gsl_ran_dir_nd (r, n1, xarr) ; 
        for(j = 0; j < n1; j++) { 
          if (j) putchar(' '); 
          printf("%g", xarr[j]) ; 
        } 
        putchar('\n'); 
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i < 1024; i = (i < 32) ? i + 1 : 2 * i)
    test_heapsort (i);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i < 1024; i = (i < 32) ? i + 1 : 2 * i)
    {
      for(s = 1; s < 4; s++)
        {
          test_sort_vector (i, s);
          test_sort_vector_float (i, s);
          test_sort_vector_long_double (i, s);
          test_sort_vector_ulong (i, s);
          test_sort_vector_long (i, s);
          test_sort_vector_uint (i, s);
          test_sort_vector_int (i, s);
          test_sort_vector_ushort (i, s);
          test_sort_vector_short (i, s);
          test_sort_vector_uchar (i, s);
          test_sort_vector_char (i, s);
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < count; i++)
    {
      p[i] = i ;                
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i < n; i++)
    {
      size_t i1;

      BASE xi = src[i * stride];

      if (j < k)
        {
          j++;
        }
      else if (xi >= xbound)
        {
          continue;
        }

      for(i1 = j - 1; i1 > 0 ; i1--)
        {
          if (xi > src[p[i1 - 1] * stride])
            break;

          p[i1] = p[i1 - 1];
        }

      p[i1] = i;

      xbound = src[p[j-1] * stride];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i < n; i++)
    {
      size_t i1;

      BASE xi = src[i * stride];

      if (j < k)
        {
          j++;
        }
      else if (xi <= xbound)
        {
          continue;
        }

      for(i1 = j - 1; i1 > 0 ; i1--)
        {
          if (xi < src[stride * p[i1 - 1]])
            break;

          p[i1] = p[i1 - 1];
        }

      p[i1] = i;

      xbound = src[stride * p[j-1]];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i < n; i++)
    {
      size_t i1;

      BASE xi = src[i * stride];

      if (j < k)
        {
          j++;
        }
      else if (xi >= xbound)
        {
          continue;
        }

      for(i1 = j - 1; i1 > 0 ; i1--)
        {
          if (xi > dest[i1 - 1])
            break;

          dest[i1] = dest[i1 - 1];
        }

      dest[i1] = xi;

      xbound = dest[j-1];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i < n; i++)
    {
      size_t i1;

      BASE xi = src[i * stride];

      if (j < k)
        {
          j++;
        }
      else if (xi <= xbound)
        {
          continue;
        }

      for(i1 = j - 1; i1 > 0 ; i1--)
        {
          if (xi < dest[i1 - 1])
            break;

          dest[i1] = dest[i1 - 1];
        }

      dest[i1] = xi;

      xbound = dest[j-1];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0 ; i < n ; i++)
    {
      p[i] = i ;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
    {
      data[i] = i;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
    {
      dest[i] = src[i];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
    {
      size_t j = urand (N);
      double tmp = data[i];
      data[i] = data[j];
      data[j] = tmp;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N / 2; i++)
    {
      size_t j = N - i - 1;

      {
        double tmp = data[i];
        data[i] = data[j];
        data[j] = tmp;
      }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
    {
      if (data[i] != orig[i])
        {
          return GSL_FAILURE;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
    {
      if (data[p[i]] != orig[i])
        {
          return GSL_FAILURE;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < v->size; i++)
    {
      kk = k;
      k++;
      if (k < kk)               
        k = kk;
      FUNCTION (gsl_vector, set) (v, i, k);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < v->size; i++)
    {
      size_t j = urand (v->size);
      FUNCTION (gsl_vector, swap_elements) (v, i, j);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < data->size; i++)
    {
      if (FUNCTION (gsl_vector, get) (data, i) != FUNCTION (gsl_vector, get) (orig, i))
        {
          return GSL_FAILURE;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < p->size; i++)
    {
      if (FUNCTION (gsl_vector, get) (data, p->data[i]) != FUNCTION (gsl_vector, get) (orig, i))
        {
          return GSL_FAILURE;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < k; i++)
    {
      if (x[i] != FUNCTION (gsl_vector, get) (data, i))
        {
          return GSL_FAILURE;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < k; i++)
    {
      if (x[i] != FUNCTION (gsl_vector, get) (data, data->size - i - 1))
        {
          return GSL_FAILURE;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < k; i++)
    {
      if (FUNCTION(gsl_vector,get)(data,p1[i]) 
          != FUNCTION(gsl_vector,get)(data, p->data[i]))
        {
          return GSL_FAILURE;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < k; i++)
    {
      if (FUNCTION(gsl_vector,get)(data,p1[i]) 
          != FUNCTION(gsl_vector,get)(data, p->data[p->size - i - 1]))
        {
          return GSL_FAILURE;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; ++i)
    {
      double sigma;
      double xi = (15.0/(N-1)) * i;
      double yi = cos(xi) * exp(-0.1 * xi);

      sigma = 0.1;
      dy = gsl_ran_gaussian(r, sigma);
      yi += dy;

      gsl_vector_set(x, i, xi);
      gsl_vector_set(y, i, yi);
      gsl_vector_set(w, i, 1.0 / (sigma*sigma));

      printf("%f %f\n", xi, yi);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; ++i)
    {
      double xi = gsl_vector_get(x, i);

      
      gsl_bspline_eval(xi, B, bw);

      
      for(j = 0; j < ncoeffs; ++j)
        {
          double Bj = gsl_vector_get(B, j);
          gsl_matrix_set(X, i, j, Bj);
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(xi = 0.0; xi < 15.0; xi += 0.1)
      {
        gsl_bspline_eval(xi, B, bw);
        gsl_multifit_linear_est(B, c, cov, &yi, &yerr);
        printf("%f %f\n", xi, yi);
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(x = 0.1; x < 2; x+= 0.1)
    {
      double y0 = exp (x);
      double sigma = 0.1 * y0;
      double dy = gsl_ran_gaussian (r, sigma);

      printf ("%g %g %g\n", x, y0 + dy, sigma);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
    {
      data[i] = 0.0;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = n / 3; i < 2 * n / 3; i++)
    {
      data[i] = 1.0;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
    {
      printf ("%d: %e\n", i, data[i]);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 11; i < n; i++)
    {
      data[i] = 0;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
    {
      printf ("%d: %e\n", i, data[i]);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++) 
    {
      double u = gsl_rng_uniform (r);
      printf ("%.5f\n", u);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++) 
    {
      unsigned int k = gsl_ran_poisson (r, mu);
      printf (" %u", k);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 10; i++)
    for(j = 0; j < 3; j++)
      gsl_matrix_set (m, i, j, 0.23 + 100*i + j);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 100; i++)  
    for(j = 0; j < 3; j++)
      printf ("m(%d,%d) = %g\n", i, j, 



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 10; i++)
    {
      x[i] = i + 0.5 * sin (i);
      y[i] = i + cos (i * i);
      printf ("%g %g\n", x[i], y[i]);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(xi = x[0]; xi < x[9]; xi += 0.01)
      {
        yi = gsl_spline_eval (spline, xi, acc);
        printf ("%g %g\n", xi, yi);
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 10; i++)
    {
      gsl_ran_dir_2d (r, &dx, &dy);
      x += dx; y += dy; 
      printf ("%g %g\n", x, y);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
    {
      x[i] = gsl_rng_uniform(r);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < k; i++)
    {
      printf ("%d: %.18f\n", i, small[i]);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
    {
      printf ("%g %g\n", x[i], y[i]);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i <= 100; i++)
    {
      xi = (1 - i / 100.0) * x[0] + (i / 100.0) * x[N-1];
      yi = gsl_spline_eval (spline, xi, acc);
      printf ("%g %g\n", xi, yi);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
    {
      REAL(data,i) = 0.0;
      IMAG(data,i) = 0.0;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i <= 10; i++)
    {
      REAL(data,i) = REAL(data,n-i) = 1.0;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
    {
      printf ("%d: %e %e\n", i, REAL(data,i), 
                                IMAG(data,i));
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < wavetable->nf; i++)
    {
       printf ("# factor %d: %d\n", i, 
               wavetable->factor[i]);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
    {
      printf ("%d: %e %e\n", i, REAL(data,i), 
                                IMAG(data,i));
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1024; i++)
    {
      double v[2];
      gsl_qrng_get (q, v);
      printf ("%.5f %.5f\n", v[0], v[1]);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++)
    {
      gsl_vector_set (v, i, 1.23 + i);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 100; i++) 
    {
      printf ("v_%d = %g\n", i, gsl_vector_get (v, i));
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
    {
      
      double t = i;
      double Yi = A * exp (-lambda * t) + b;
      gsl_vector_set (f, i, (Yi - y[i])/sigma[i]);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
    {
      
      
      
      
      double t = i;
      double s = sigma[i];
      double e = exp(-lambda * t);
      gsl_matrix_set (J, i, 0, e/s); 
      gsl_matrix_set (J, i, 1, -t * A * e/s);
      gsl_matrix_set (J, i, 2, 1/s);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 10000; i++)
    {
      ntuple_row.x = gsl_ran_ugaussian (r);
      ntuple_row.y = gsl_ran_ugaussian (r);
      ntuple_row.z = gsl_ran_ugaussian (r);
      
      gsl_ntuple_write (ntuple);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i <= 4; i++)
    {
      c = gsl_combination_calloc (4, i);
      do
        {
          printf ("{");
          gsl_combination_fprintf (stdout, c, " %u");
          printf (" }\n");
        }
      while (gsl_combination_next (c) == GSL_SUCCESS);
      gsl_combination_free (c);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
    {
      double t = i;
      y[i] = 1.0 + 5 * exp (-0.1 * t) 
                 + gsl_ran_gaussian (r, 0.1);
      sigma[i] = 0.1;
      printf ("data: %u %g %g\n", i, y[i], sigma[i]);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 100; i++)
    for(j = 0; j < 100; j++)
      gsl_matrix_set (m, i, j, 0.23 + i + j);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 100; i++)
    for(j = 0; j < 100; j++)
      {
        double mij = gsl_matrix_get (m, i, j);
        double aij = gsl_matrix_get (a, i, j);
        if (mij != aij) k++;
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 10; i++)
    for(j = 0; j < 10; j++)
      gsl_matrix_set (m, i, j, sin (i) + cos (j));



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < 10; j++)
    {
      gsl_vector_view column = gsl_matrix_column (m, j);
      double d;

      d = gsl_blas_dnrm2 (&column.vector);

      printf ("matrix column %d, norm = %g\n", j, d);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1000; i++) {
      double x, y;
      double u = gsl_rng_uniform (r);
      double v = gsl_rng_uniform (r);
       
      gsl_histogram2d_pdf_sample (p, u, v, &x, &y);
      
      printf ("%g %g\n", x, y);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(n = 0; n < N; n++)
    {
      double np1 = n + 1.0;
      t[n] = 1.0 / (np1 * np1);
      sum += t[n];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 4; i++)
      {
        double eval_i 
           = gsl_vector_get (eval, i);
        gsl_vector_view evec_i 
           = gsl_matrix_column (evec, i);

        printf ("eigenvalue = %g\n", eval_i);
        printf ("eigenvector = \n");
        gsl_vector_fprintf (stdout, 
                            &evec_i.vector, "%g");
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 4; i++)
      {
        gsl_complex eval_i 
           = gsl_vector_complex_get (eval, i);
        gsl_vector_complex_view evec_i 
           = gsl_matrix_complex_column (evec, i);

        printf ("eigenvalue = %g + %gi\n",
                GSL_REAL(eval_i), GSL_IMAG(eval_i));
        printf ("eigenvector = \n");
        for(j = 0; j < 4; ++j)
          {
            gsl_complex z = gsl_vector_complex_get(&evec_i.vector, j);
            printf("%g + %gi\n", GSL_REAL(z), GSL_IMAG(z));
          }
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
    {
      fscanf (f, "%lg", &data[i]);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
    {
      abscoeff[i] = fabs (data[i]);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; (i + nc) < n; i++)
    data[p[i]] = 0;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
    {
      printf ("%g\n", data[i]);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 100; i++)
    {
      gsl_vector_set (v, i, 1.23 + i);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 5; i++)
    {
      printf ("z%d = %+.18f %+.18f\n", 
              i, z[2*i], z[2*i+1]);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 10; i++)
    {
      printf ("%g\n", gsl_vector_get(v, i));
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
    {
      int count = fscanf (stdin, "%lg %lg %lg",
                          &xi, &yi, &ei);

      if (count != 3)
        {
          fprintf (stderr, "error reading file\n");
          exit (-1);
        }

      printf ("%g %g +/- %g\n", xi, yi, ei);
      
      gsl_matrix_set (X, i, 0, 1.0);
      gsl_matrix_set (X, i, 1, xi);
      gsl_matrix_set (X, i, 2, xi*xi);
      
      gsl_vector_set (y, i, yi);
      gsl_vector_set (w, i, 1.0/(ei*ei));
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
    {
      double x = i / (double)n;
      double r10 = gsl_cheb_eval_n (cs, 10, x);
      double r40 = gsl_cheb_eval (cs, x);
      printf ("%g %g %g %g\n", 
              x, GSL_FN_EVAL (&F, x), r10, r40);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
    printf ("data: %g %g %g\n", 



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = -30; i < 130; i++)
    {
      double xf = x[0] + (i/100.0) * (x[n-1] - x[0]);
      double yf, yf_err;

      gsl_fit_linear_est (xf, 
                          c0, c1, 
                          cov00, cov01, cov11, 
                          &yf, &yf_err);

      printf ("fit: %g %g\n", xf, yf);
      printf ("hi : %g %g\n", xf, yf + yf_err);
      printf ("lo : %g %g\n", xf, yf - yf_err);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 128; i++)
    {
       REAL(data,i) = 0.0; IMAG(data,i) = 0.0;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i <= 10; i++)
    {
       REAL(data,i) = REAL(data,128-i) = 1.0;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 128; i++)
    {
      printf ("%d %e %e\n", i, 
              REAL(data,i), IMAG(data,i));
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 128; i++)
    {
      printf ("%d %e %e\n", i, 
              REAL(data,i)/sqrt(128), 
              IMAG(data,i)/sqrt(128));
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0 ; i < n ; i++) 
    {
      if (verbose) printf ("%s = %d\n", errors[i].name, errors[i].number) ;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
    {
      int status = 0;
      for(j = 0; j < n; j++)
        {
          if (j != i)
              status |= (errors[i].number == errors[j].number);
        }

      gsl_test (status, "%s is distinct from other error values",
                errors[i].name);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
    {
      int status = 0;
      int e1 = errors[i].number ;
      for(j = 0; j < n; j++)
        {
          if (j != i)
            {
              int e2 = errors[j].number;
              status |= (gsl_strerror(e1) == gsl_strerror(e2)) ;
            }
        }
      gsl_test (status, "%s has a distinct error message",
                errors[i].name);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < test_table->n; i++)
    {
      double x = test_table->x[i];
      double y;
      double deriv;
      double integ;
      double diff_y, diff_deriv, diff_integ;
      s1 = gsl_interp_eval_e (interp, data_table->x, data_table->y, x, a, &y);
      s2 = gsl_interp_eval_deriv_e (interp, data_table->x, data_table->y, x, a, &deriv);
      s3 = gsl_interp_eval_integ_e (interp, data_table->x, data_table->y, test_table->x[0], x, a, &integ);

      gsl_test (s1, "gsl_interp_eval_e %s", gsl_interp_name(interp));
      gsl_test (s2, "gsl_interp_eval_deriv_e %s", gsl_interp_name(interp));
      gsl_test (s3, "gsl_interp_eval_integ_e %s", gsl_interp_name(interp));

      gsl_test_abs (y, test_table->y[i], 1e-10, "%s %d", gsl_interp_name(interp), i);
      gsl_test_abs (deriv, test_d_table->y[i], 1e-10, "%s deriv %d", gsl_interp_name(interp), i);
      gsl_test_abs (integ, test_i_table->y[i], 1e-10, "%s integ %d", gsl_interp_name(interp), i);

      diff_y = y - test_table->y[i];
      diff_deriv = deriv - test_d_table->y[i];
      diff_integ = integ - test_i_table->y[i];
      if (fabs (diff_y) > 1.e-10 || fabs(diff_deriv) > 1.0e-10 || fabs(diff_integ) > 1.0e-10) {
        status++;
      }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i < size; i++)
    {
      sum += state->coeff[i] * (pow (b, i + 1) - pow (a, i + 1)) / (i + 1.0);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < sys_size; i++)
    {
      const double h_i   = xa[i + 1] - xa[i];
      const double h_ip1 = xa[i + 2] - xa[i + 1];
      const double ydiff_i   = ya[i + 1] - ya[i];
      const double ydiff_ip1 = ya[i + 2] - ya[i + 1];
      const double g_i = (h_i != 0.0) ? 1.0 / h_i : 0.0;
      const double g_ip1 = (h_ip1 != 0.0) ? 1.0 / h_ip1 : 0.0;
      state->offdiag[i] = h_ip1;
      state->diag[i] = 2.0 * (h_ip1 + h_i);
      state->g[i] = 3.0 * (ydiff_ip1 * g_ip1 -  ydiff_i * g_i);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < sys_size-1; i++) {
      const double h_i       = xa[i + 1] - xa[i];
      const double h_ip1     = xa[i + 2] - xa[i + 1];
      const double ydiff_i   = ya[i + 1] - ya[i];
      const double ydiff_ip1 = ya[i + 2] - ya[i + 1];
      const double g_i = (h_i != 0.0) ? 1.0 / h_i : 0.0;
      const double g_ip1 = (h_ip1 != 0.0) ? 1.0 / h_ip1 : 0.0;
      state->offdiag[i] = h_ip1;
      state->diag[i] = 2.0 * (h_ip1 + h_i);
      state->g[i] = 3.0 * (ydiff_ip1 * g_ip1 - ydiff_i * g_i);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=index_a; i<=index_b; i++) {
    const double x_hi = x_array[i + 1];
    const double x_lo = x_array[i];
    const double y_lo = y_array[i];
    const double y_hi = y_array[i + 1];
    const double dx = x_hi - x_lo;
    const double dy = y_hi - y_lo;
    if(dx != 0.0) {
      double b_i, c_i, d_i; 
      coeff_calc(state->c, dy, dx, i,  &b_i, &c_i, &d_i);
      
      if (i == index_a || i == index_b)
        {
          double x1 = (i == index_a) ? a : x_lo;
          double x2 = (i == index_b) ? b : x_hi;
          *result += integ_eval(y_lo, b_i, c_i, d_i, x_lo, x1, x2);
        }
      else
        {
          *result += dx * (y_lo + dx*(0.5*b_i + dx*(c_i/3.0 + 0.25*d_i*dx)));
        }
    }
    else {
      *result = 0.0;
      return GSL_FAILURE;
    }
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < (size - 1); i++)
    {
      const double NE = fabs (m[i + 1] - m[i]) + fabs (m[i - 1] - m[i - 2]);
      if (NE == 0.0)
        {
          b[i] = m[i];
          c[i] = 0.0;
          d[i] = 0.0;
        }
      else
        {
          const double h_i = x_array[i + 1] - x_array[i];
          const double NE_next = fabs (m[i + 2] - m[i + 1]) + fabs (m[i] - m[i - 1]);
          const double alpha_i = fabs (m[i - 1] - m[i - 2]) / NE;
          double alpha_ip1;
          double tL_ip1;
          if (NE_next == 0.0)
            {
              tL_ip1 = m[i];
            }
          else
            {
              alpha_ip1 = fabs (m[i] - m[i - 1]) / NE_next;
              tL_ip1 = (1.0 - alpha_ip1) * m[i] + alpha_ip1 * m[i + 1];
            }
          b[i] = (1.0 - alpha_i) * m[i - 1] + alpha_i * m[i];
          c[i] = (3.0 * m[i] - 2.0 * b[i] - tL_ip1) / h_i;
          d[i] = (b[i] + tL_ip1 - 2.0 * m[i]) / (h_i * h_i);
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i <= size - 2; i++)
    {
      m[i] = (y_array[i + 1] - y_array[i]) / (x_array[i + 1] - x_array[i]);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i <= size - 2; i++)
    {
      m[i] = (y_array[i + 1] - y_array[i]) / (x_array[i + 1] - x_array[i]);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=index_a; i<=index_b; i++) {
    const double x_hi = x_array[i + 1];
    const double x_lo = x_array[i];
    const double y_lo = y_array[i];
    const double dx = x_hi - x_lo;
    if(dx != 0.0) {

      if (i == index_a || i == index_b)
        {
          double x1 = (i == index_a) ? a : x_lo;
          double x2 = (i == index_b) ? b : x_hi;
          *result += integ_eval (y_lo, state->b[i], state->c[i], state->d[i],
                                 x_lo, x1, x2);
        }
      else
        {
          *result += dx * (y_lo 
                           + dx*(0.5*state->b[i] 
                                 + dx*(state->c[i]/3.0 
                                       + 0.25*state->d[i]*dx)));
        }
    }
    else {
      *result = 0.0;
      return GSL_FAILURE;
    }
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=index_a; i<=index_b; i++) {
    const double x_hi = x_array[i + 1];
    const double x_lo = x_array[i];
    const double y_lo = y_array[i];
    const double y_hi = y_array[i + 1];
    const double dx = x_hi - x_lo;

    if(dx != 0.0) {
      if (i == index_a || i == index_b)
        {
          double x1 = (i == index_a) ? a : x_lo;
          double x2 = (i == index_b) ? b : x_hi;
          const double D = (y_hi-y_lo)/dx;
          *result += (x2-x1) * (y_lo + 0.5*D*((x2-x_lo)+(x1-x_lo)));
        }
      else
        {
          *result += 0.5 * dx * (y_lo + y_hi);
        }
    }
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=len-1; i>0; i--) ans = c[i-1] + x * ans;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 7; i++)
      {
        gsl_test_rel (dd[i], dd_expected[i], 1e-10, "divided difference dd[%d]", i);
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 7; i++)
      {
        double y = gsl_poly_dd_eval(dd, xa, 7, xa[i]);
        gsl_test_rel (y, ya[i], 1e-10, "divided difference y[%d]", i);
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 7; i++)
      {
        double y = gsl_poly_eval(coeff, 7, xa[i] - 1.5);
        gsl_test_rel (y, ya[i], 1e-10, "taylor expansion about 1.5 y[%d]", i);
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nc; i++)
        {
          

          if (i != nc - 1)
            {
              col_norm = fabs (MAT (m, i + 1, i, nc));
            }
          else
            {
              col_norm = 0;

              for(j = 0; j < nc - 1; j++)
                {
                  col_norm += fabs (MAT (m, j, nc - 1, nc));
                }
            }

          

          if (i == 0)
            {
              row_norm = fabs (MAT (m, 0, nc - 1, nc));
            }
          else if (i == nc - 1)
            {
              row_norm = fabs (MAT (m, i, i - 1, nc));
            }
          else
            {
              row_norm = (fabs (MAT (m, i, i - 1, nc)) 
                          + fabs (MAT (m, i, nc - 1, nc)));
            }

          if (col_norm == 0 || row_norm == 0)
            {
              continue;
            }

          g = row_norm / RADIX;
          f = 1;
          s = col_norm + row_norm;

          while (col_norm < g)
            {
              f *= RADIX;
              col_norm *= RADIX2;
            }

          g = row_norm * RADIX;

          while (col_norm > g)
            {
              f /= RADIX;
              col_norm /= RADIX2;
            }

          if ((row_norm + col_norm) < 0.95 * s * f)
            {
              not_converged = 1;

              g = 1 / f;

              if (i == 0)
                {
                  MAT (m, 0, nc - 1, nc) *= g;
                }
              else
                {
                  MAT (m, i, i - 1, nc) *= g;
                  MAT (m, i, nc - 1, nc) *= g;
                }

              if (i == nc - 1)
                {
                  for(j = 0; j < nc; j++)
                    {
                      MAT (m, j, i, nc) *= f;
                    }
                }
              else
                {
                  MAT (m, i + 1, i, nc) *= f;
                }
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = size - 1; j >= 1; j--)
    {
      dd[j] = (ya[j] - ya[j - 1]) / (xa[j] - xa[j - 1]);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 2; i < size; i++)
    {
      for(j = size - 1; j >= i; j--)
        {
          dd[j] = (dd[j] - dd[j - 1]) / (xa[j] - xa[j - i]);
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = size - 1; i--;)
    {
      y = dd[i] + (x - xa[i]) * y;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < size; i++)
    {
      c[i] = 0.0;
      w[i] = 0.0;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = size - 1; i > 0 && i--;)
    {
      w[i] = -w[i + 1] * (xa[size - 2 - i] - xp);

      for(j = i + 1; j < size - 1; j++)
        {
          w[j] = w[j] - w[j + 1] * (xa[size - 2 - i] - xp);
        }

      for(j = i; j < size; j++)
        {
          c[j - i] += w[j] * dd[size - i - 1];
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(e = n; e >= 2; e--)
    {
      double a1 = fabs (FMAT (h, e, e - 1, nc));
      double a2 = fabs (FMAT (h, e - 1, e - 1, nc));
      double a3 = fabs (FMAT (h, e, e, nc));

      if (a1 <= GSL_DBL_EPSILON * (a2 + a3))
        break;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i <= n; i++)
        {
          FMAT (h, i, i, nc) -= x;
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(m = n - 2; m >= e; m--)
    {
      double a1, a2, a3;

      z = FMAT (h, m, m, nc);
      r = x - z;
      s = y - z;
      p = FMAT (h, m, m + 1, nc) + (r * s - w) / FMAT (h, m + 1, m, nc);
      q = FMAT (h, m + 1, m + 1, nc) - z - r - s;
      r = FMAT (h, m + 2, m + 1, nc);
      s = fabs (p) + fabs (q) + fabs (r);
      p /= s;
      q /= s;
      r /= s;

      if (m == e)
        break;
      
      a1 = fabs (FMAT (h, m, m - 1, nc));
      a2 = fabs (FMAT (h, m - 1, m - 1, nc));
      a3 = fabs (FMAT (h, m + 1, m + 1, nc));

      if (a1 * (fabs (q) + fabs (r)) <= GSL_DBL_EPSILON * fabs (p) * (a2 + a3))
        break;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = m + 2; i <= n; i++)
    {
      FMAT (h, i, i - 2, nc) = 0;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = m + 3; i <= n; i++)
    {
      FMAT (h, i, i - 3, nc) = 0;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = m; k <= n - 1; k++)
    {
      notlast = (k != n - 1);

      if (k != m)
        {
          p = FMAT (h, k, k - 1, nc);
          q = FMAT (h, k + 1, k - 1, nc);
          r = notlast ? FMAT (h, k + 2, k - 1, nc) : 0.0;

          x = fabs (p) + fabs (q) + fabs (r);

          if (x == 0)
            continue;           

          p /= x;
          q /= x;
          r /= x;
        }

      s = sqrt (p * p + q * q + r * r);

      if (p < 0)
        s = -s;

      if (k != m)
        {
          FMAT (h, k, k - 1, nc) = -s * x;
        }
      else if (e != m)
        {
          FMAT (h, k, k - 1, nc) *= -1;
        }

      p += s;
      x = p / s;
      y = q / s;
      z = r / s;
      q /= p;
      r /= p;

      

      for(j = k; j <= n; j++)
        {
          p = FMAT (h, k, j, nc) + q * FMAT (h, k + 1, j, nc);

          if (notlast)
            {
              p += r * FMAT (h, k + 2, j, nc);
              FMAT (h, k + 2, j, nc) -= p * z;
            }

          FMAT (h, k + 1, j, nc) -= p * y;
          FMAT (h, k, j, nc) -= p * x;
        }

      j = (k + 3 < n) ? (k + 3) : n;

      

      for(i = e; i <= j; i++)
        {
          p = x * FMAT (h, i, k, nc) + y * FMAT (h, i, k + 1, nc);

          if (notlast)
            {
              p += z * FMAT (h, i, k + 2, nc);
              FMAT (h, i, k + 2, nc) -= p * r;
            }
          FMAT (h, i, k + 1, nc) -= p * q;
          FMAT (h, i, k, nc) -= p;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nc; i++)
    for(j = 0; j < nc; j++)
      MAT (m, i, j, nc) = 0.0;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i < nc; i++)
    MAT (m, i, i - 1, nc) = 1.0;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nc; i++)
    MAT (m, i, nc - 1, nc) = -a[i] / a[nc];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(T = fminimizer ; *T != 0 ; T++)
    {
      test_f (*T, "cos(x) [0 (3) 6]", &F_cos, 0.0, 3.0, 6.0, M_PI);
      test_f (*T, "x^4 - 1 [-3 (-1) 17]", &F_func1, -3.0, -1.0, 17.0, 0.0);
      test_f (*T, "sqrt(|x|) [-2 (-1) 1.5]", &F_func2, -2.0, -1.0, 1.5, 0.0);
      test_f (*T, "func3(x) [-2 (3) 4]", &F_func3, -2.0, 3.0, 4.0, 1.0);
      test_f (*T, "func4(x) [0 (0.782) 1]", &F_func4, 0, 0.782, 1.0, 0.8);

      test_f_e (*T, "invalid range check [4, 0]", &F_cos, 4.0, 3.0, 0.0, M_PI);
      test_f_e (*T, "invalid range check [1, 1]", &F_cos, 1.0, 1.0, 1.0, M_PI);
      test_f_e (*T, "invalid range check [-1, 1]", &F_cos, -1.0, 0.0, 1.0, M_PI);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 4; i++) {
       gsl_test_rel(C[i], C_expected[i], flteps, "ssyrk(case 1566)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 4; i++) {
       gsl_test_rel(C[i], C_expected[i], flteps, "ssyrk(case 1567)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 4; i++) {
       gsl_test_rel(C[i], C_expected[i], flteps, "ssyrk(case 1568)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 4; i++) {
       gsl_test_rel(C[i], C_expected[i], flteps, "ssyrk(case 1569)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 4; i++) {
       gsl_test_rel(C[i], C_expected[i], flteps, "ssyrk(case 1570)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 4; i++) {
       gsl_test_rel(C[i], C_expected[i], flteps, "ssyrk(case 1571)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 4; i++) {
       gsl_test_rel(C[i], C_expected[i], flteps, "ssyrk(case 1572)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 4; i++) {
       gsl_test_rel(C[i], C_expected[i], flteps, "ssyrk(case 1573)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 4; i++) {
       gsl_test_rel(C[i], C_expected[i], dbleps, "dsyrk(case 1574)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 4; i++) {
       gsl_test_rel(C[i], C_expected[i], dbleps, "dsyrk(case 1575)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 4; i++) {
       gsl_test_rel(C[i], C_expected[i], dbleps, "dsyrk(case 1576)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 4; i++) {
       gsl_test_rel(C[i], C_expected[i], dbleps, "dsyrk(case 1577)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 4; i++) {
       gsl_test_rel(C[i], C_expected[i], dbleps, "dsyrk(case 1578)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 4; i++) {
       gsl_test_rel(C[i], C_expected[i], dbleps, "dsyrk(case 1579)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 4; i++) {
       gsl_test_rel(C[i], C_expected[i], dbleps, "dsyrk(case 1580)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 4; i++) {
       gsl_test_rel(C[i], C_expected[i], dbleps, "dsyrk(case 1581)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 4; i++) {
       gsl_test_rel(C[2*i], C_expected[2*i], flteps, "csyrk(case 1582) real");
       gsl_test_rel(C[2*i+1], C_expected[2*i+1], flteps, "csyrk(case 1582) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 4; i++) {
       gsl_test_rel(C[2*i], C_expected[2*i], flteps, "csyrk(case 1583) real");
       gsl_test_rel(C[2*i+1], C_expected[2*i+1], flteps, "csyrk(case 1583) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 4; i++) {
       gsl_test_rel(C[2*i], C_expected[2*i], flteps, "csyrk(case 1584) real");
       gsl_test_rel(C[2*i+1], C_expected[2*i+1], flteps, "csyrk(case 1584) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 4; i++) {
       gsl_test_rel(C[2*i], C_expected[2*i], flteps, "csyrk(case 1585) real");
       gsl_test_rel(C[2*i+1], C_expected[2*i+1], flteps, "csyrk(case 1585) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 4; i++) {
       gsl_test_rel(C[2*i], C_expected[2*i], flteps, "csyrk(case 1586) real");
       gsl_test_rel(C[2*i+1], C_expected[2*i+1], flteps, "csyrk(case 1586) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 4; i++) {
       gsl_test_rel(C[2*i], C_expected[2*i], flteps, "csyrk(case 1587) real");
       gsl_test_rel(C[2*i+1], C_expected[2*i+1], flteps, "csyrk(case 1587) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 4; i++) {
       gsl_test_rel(C[2*i], C_expected[2*i], flteps, "csyrk(case 1588) real");
       gsl_test_rel(C[2*i+1], C_expected[2*i+1], flteps, "csyrk(case 1588) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 4; i++) {
       gsl_test_rel(C[2*i], C_expected[2*i], flteps, "csyrk(case 1589) real");
       gsl_test_rel(C[2*i+1], C_expected[2*i+1], flteps, "csyrk(case 1589) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 4; i++) {
       gsl_test_rel(C[2*i], C_expected[2*i], dbleps, "zsyrk(case 1590) real");
       gsl_test_rel(C[2*i+1], C_expected[2*i+1], dbleps, "zsyrk(case 1590) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 4; i++) {
       gsl_test_rel(C[2*i], C_expected[2*i], dbleps, "zsyrk(case 1591) real");
       gsl_test_rel(C[2*i+1], C_expected[2*i+1], dbleps, "zsyrk(case 1591) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 4; i++) {
       gsl_test_rel(C[2*i], C_expected[2*i], dbleps, "zsyrk(case 1592) real");
       gsl_test_rel(C[2*i+1], C_expected[2*i+1], dbleps, "zsyrk(case 1592) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 4; i++) {
       gsl_test_rel(C[2*i], C_expected[2*i], dbleps, "zsyrk(case 1593) real");
       gsl_test_rel(C[2*i+1], C_expected[2*i+1], dbleps, "zsyrk(case 1593) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 4; i++) {
       gsl_test_rel(C[2*i], C_expected[2*i], dbleps, "zsyrk(case 1594) real");
       gsl_test_rel(C[2*i+1], C_expected[2*i+1], dbleps, "zsyrk(case 1594) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 4; i++) {
       gsl_test_rel(C[2*i], C_expected[2*i], dbleps, "zsyrk(case 1595) real");
       gsl_test_rel(C[2*i+1], C_expected[2*i+1], dbleps, "zsyrk(case 1595) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 4; i++) {
       gsl_test_rel(C[2*i], C_expected[2*i], dbleps, "zsyrk(case 1596) real");
       gsl_test_rel(C[2*i+1], C_expected[2*i+1], dbleps, "zsyrk(case 1596) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 4; i++) {
       gsl_test_rel(C[2*i], C_expected[2*i], dbleps, "zsyrk(case 1597) real");
       gsl_test_rel(C[2*i+1], C_expected[2*i+1], dbleps, "zsyrk(case 1597) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(Ap[i], Ap_expected[i], flteps, "sspr(case 1426)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(Ap[i], Ap_expected[i], flteps, "sspr(case 1427)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(Ap[i], Ap_expected[i], flteps, "sspr(case 1428)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(Ap[i], Ap_expected[i], flteps, "sspr(case 1429)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(Ap[i], Ap_expected[i], dbleps, "dspr(case 1430)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(Ap[i], Ap_expected[i], dbleps, "dspr(case 1431)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(Ap[i], Ap_expected[i], dbleps, "dspr(case 1432)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(Ap[i], Ap_expected[i], dbleps, "dspr(case 1433)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(Y[i], y_expected[i], flteps, "sgbmv(case 794)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(Y[i], y_expected[i], flteps, "sgbmv(case 795)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 4; i++) {
       gsl_test_rel(Y[i], y_expected[i], flteps, "sgbmv(case 796)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 4; i++) {
       gsl_test_rel(Y[i], y_expected[i], flteps, "sgbmv(case 797)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(Y[i], y_expected[i], dbleps, "dgbmv(case 798)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(Y[i], y_expected[i], dbleps, "dgbmv(case 799)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 4; i++) {
       gsl_test_rel(Y[i], y_expected[i], dbleps, "dgbmv(case 800)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 4; i++) {
       gsl_test_rel(Y[i], y_expected[i], dbleps, "dgbmv(case 801)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(Y[2*i], y_expected[2*i], flteps, "cgbmv(case 802) real");
       gsl_test_rel(Y[2*i+1], y_expected[2*i+1], flteps, "cgbmv(case 802) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(Y[2*i], y_expected[2*i], flteps, "cgbmv(case 803) real");
       gsl_test_rel(Y[2*i+1], y_expected[2*i+1], flteps, "cgbmv(case 803) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 4; i++) {
       gsl_test_rel(Y[2*i], y_expected[2*i], flteps, "cgbmv(case 804) real");
       gsl_test_rel(Y[2*i+1], y_expected[2*i+1], flteps, "cgbmv(case 804) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 4; i++) {
       gsl_test_rel(Y[2*i], y_expected[2*i], flteps, "cgbmv(case 805) real");
       gsl_test_rel(Y[2*i+1], y_expected[2*i+1], flteps, "cgbmv(case 805) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 4; i++) {
       gsl_test_rel(Y[2*i], y_expected[2*i], flteps, "cgbmv(case 806) real");
       gsl_test_rel(Y[2*i+1], y_expected[2*i+1], flteps, "cgbmv(case 806) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 4; i++) {
       gsl_test_rel(Y[2*i], y_expected[2*i], flteps, "cgbmv(case 807) real");
       gsl_test_rel(Y[2*i+1], y_expected[2*i+1], flteps, "cgbmv(case 807) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(Y[2*i], y_expected[2*i], dbleps, "zgbmv(case 808) real");
       gsl_test_rel(Y[2*i+1], y_expected[2*i+1], dbleps, "zgbmv(case 808) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(Y[2*i], y_expected[2*i], dbleps, "zgbmv(case 809) real");
       gsl_test_rel(Y[2*i+1], y_expected[2*i+1], dbleps, "zgbmv(case 809) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 4; i++) {
       gsl_test_rel(Y[2*i], y_expected[2*i], dbleps, "zgbmv(case 810) real");
       gsl_test_rel(Y[2*i+1], y_expected[2*i+1], dbleps, "zgbmv(case 810) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 4; i++) {
       gsl_test_rel(Y[2*i], y_expected[2*i], dbleps, "zgbmv(case 811) real");
       gsl_test_rel(Y[2*i+1], y_expected[2*i+1], dbleps, "zgbmv(case 811) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 4; i++) {
       gsl_test_rel(Y[2*i], y_expected[2*i], dbleps, "zgbmv(case 812) real");
       gsl_test_rel(Y[2*i+1], y_expected[2*i+1], dbleps, "zgbmv(case 812) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 4; i++) {
       gsl_test_rel(Y[2*i], y_expected[2*i], dbleps, "zgbmv(case 813) real");
       gsl_test_rel(Y[2*i+1], y_expected[2*i+1], dbleps, "zgbmv(case 813) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Ap[2*i], Ap_expected[2*i], flteps, "chpr2(case 1458) real");
       gsl_test_rel(Ap[2*i+1], Ap_expected[2*i+1], flteps, "chpr2(case 1458) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Ap[2*i], Ap_expected[2*i], flteps, "chpr2(case 1459) real");
       gsl_test_rel(Ap[2*i+1], Ap_expected[2*i+1], flteps, "chpr2(case 1459) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Ap[2*i], Ap_expected[2*i], flteps, "chpr2(case 1460) real");
       gsl_test_rel(Ap[2*i+1], Ap_expected[2*i+1], flteps, "chpr2(case 1460) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Ap[2*i], Ap_expected[2*i], flteps, "chpr2(case 1461) real");
       gsl_test_rel(Ap[2*i+1], Ap_expected[2*i+1], flteps, "chpr2(case 1461) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Ap[2*i], Ap_expected[2*i], dbleps, "zhpr2(case 1462) real");
       gsl_test_rel(Ap[2*i+1], Ap_expected[2*i+1], dbleps, "zhpr2(case 1462) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Ap[2*i], Ap_expected[2*i], dbleps, "zhpr2(case 1463) real");
       gsl_test_rel(Ap[2*i+1], Ap_expected[2*i+1], dbleps, "zhpr2(case 1463) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Ap[2*i], Ap_expected[2*i], dbleps, "zhpr2(case 1464) real");
       gsl_test_rel(Ap[2*i+1], Ap_expected[2*i+1], dbleps, "zhpr2(case 1464) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Ap[2*i], Ap_expected[2*i], dbleps, "zhpr2(case 1465) real");
       gsl_test_rel(Ap[2*i+1], Ap_expected[2*i+1], dbleps, "zhpr2(case 1465) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(C[i], C_expected[i], flteps, "ssyr2k(case 1614)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(C[i], C_expected[i], flteps, "ssyr2k(case 1615)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(C[i], C_expected[i], flteps, "ssyr2k(case 1616)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(C[i], C_expected[i], flteps, "ssyr2k(case 1617)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(C[i], C_expected[i], flteps, "ssyr2k(case 1618)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(C[i], C_expected[i], flteps, "ssyr2k(case 1619)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(C[i], C_expected[i], flteps, "ssyr2k(case 1620)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(C[i], C_expected[i], flteps, "ssyr2k(case 1621)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(C[i], C_expected[i], dbleps, "dsyr2k(case 1622)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(C[i], C_expected[i], dbleps, "dsyr2k(case 1623)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(C[i], C_expected[i], dbleps, "dsyr2k(case 1624)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(C[i], C_expected[i], dbleps, "dsyr2k(case 1625)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(C[i], C_expected[i], dbleps, "dsyr2k(case 1626)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(C[i], C_expected[i], dbleps, "dsyr2k(case 1627)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(C[i], C_expected[i], dbleps, "dsyr2k(case 1628)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(C[i], C_expected[i], dbleps, "dsyr2k(case 1629)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(C[2*i], C_expected[2*i], flteps, "csyr2k(case 1630) real");
       gsl_test_rel(C[2*i+1], C_expected[2*i+1], flteps, "csyr2k(case 1630) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(C[2*i], C_expected[2*i], flteps, "csyr2k(case 1631) real");
       gsl_test_rel(C[2*i+1], C_expected[2*i+1], flteps, "csyr2k(case 1631) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(C[2*i], C_expected[2*i], flteps, "csyr2k(case 1632) real");
       gsl_test_rel(C[2*i+1], C_expected[2*i+1], flteps, "csyr2k(case 1632) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(C[2*i], C_expected[2*i], flteps, "csyr2k(case 1633) real");
       gsl_test_rel(C[2*i+1], C_expected[2*i+1], flteps, "csyr2k(case 1633) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(C[2*i], C_expected[2*i], flteps, "csyr2k(case 1634) real");
       gsl_test_rel(C[2*i+1], C_expected[2*i+1], flteps, "csyr2k(case 1634) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(C[2*i], C_expected[2*i], flteps, "csyr2k(case 1635) real");
       gsl_test_rel(C[2*i+1], C_expected[2*i+1], flteps, "csyr2k(case 1635) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(C[2*i], C_expected[2*i], flteps, "csyr2k(case 1636) real");
       gsl_test_rel(C[2*i+1], C_expected[2*i+1], flteps, "csyr2k(case 1636) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(C[2*i], C_expected[2*i], flteps, "csyr2k(case 1637) real");
       gsl_test_rel(C[2*i+1], C_expected[2*i+1], flteps, "csyr2k(case 1637) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(C[2*i], C_expected[2*i], dbleps, "zsyr2k(case 1638) real");
       gsl_test_rel(C[2*i+1], C_expected[2*i+1], dbleps, "zsyr2k(case 1638) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(C[2*i], C_expected[2*i], dbleps, "zsyr2k(case 1639) real");
       gsl_test_rel(C[2*i+1], C_expected[2*i+1], dbleps, "zsyr2k(case 1639) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(C[2*i], C_expected[2*i], dbleps, "zsyr2k(case 1640) real");
       gsl_test_rel(C[2*i+1], C_expected[2*i+1], dbleps, "zsyr2k(case 1640) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(C[2*i], C_expected[2*i], dbleps, "zsyr2k(case 1641) real");
       gsl_test_rel(C[2*i+1], C_expected[2*i+1], dbleps, "zsyr2k(case 1641) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(C[2*i], C_expected[2*i], dbleps, "zsyr2k(case 1642) real");
       gsl_test_rel(C[2*i+1], C_expected[2*i+1], dbleps, "zsyr2k(case 1642) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(C[2*i], C_expected[2*i], dbleps, "zsyr2k(case 1643) real");
       gsl_test_rel(C[2*i+1], C_expected[2*i+1], dbleps, "zsyr2k(case 1643) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(C[2*i], C_expected[2*i], dbleps, "zsyr2k(case 1644) real");
       gsl_test_rel(C[2*i+1], C_expected[2*i+1], dbleps, "zsyr2k(case 1644) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(C[2*i], C_expected[2*i], dbleps, "zsyr2k(case 1645) real");
       gsl_test_rel(C[2*i+1], C_expected[2*i+1], dbleps, "zsyr2k(case 1645) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(C[i], C_expected[i], flteps, "ssymm(case 1518)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(C[i], C_expected[i], flteps, "ssymm(case 1519)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(C[i], C_expected[i], flteps, "ssymm(case 1520)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(C[i], C_expected[i], flteps, "ssymm(case 1521)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(C[i], C_expected[i], flteps, "ssymm(case 1522)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(C[i], C_expected[i], flteps, "ssymm(case 1523)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(C[i], C_expected[i], flteps, "ssymm(case 1524)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(C[i], C_expected[i], flteps, "ssymm(case 1525)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(C[i], C_expected[i], dbleps, "dsymm(case 1526)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(C[i], C_expected[i], dbleps, "dsymm(case 1527)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(C[i], C_expected[i], dbleps, "dsymm(case 1528)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(C[i], C_expected[i], dbleps, "dsymm(case 1529)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(C[i], C_expected[i], dbleps, "dsymm(case 1530)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(C[i], C_expected[i], dbleps, "dsymm(case 1531)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(C[i], C_expected[i], dbleps, "dsymm(case 1532)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(C[i], C_expected[i], dbleps, "dsymm(case 1533)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(C[2*i], C_expected[2*i], flteps, "csymm(case 1534) real");
       gsl_test_rel(C[2*i+1], C_expected[2*i+1], flteps, "csymm(case 1534) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(C[2*i], C_expected[2*i], flteps, "csymm(case 1535) real");
       gsl_test_rel(C[2*i+1], C_expected[2*i+1], flteps, "csymm(case 1535) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(C[2*i], C_expected[2*i], flteps, "csymm(case 1536) real");
       gsl_test_rel(C[2*i+1], C_expected[2*i+1], flteps, "csymm(case 1536) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(C[2*i], C_expected[2*i], flteps, "csymm(case 1537) real");
       gsl_test_rel(C[2*i+1], C_expected[2*i+1], flteps, "csymm(case 1537) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(C[2*i], C_expected[2*i], flteps, "csymm(case 1538) real");
       gsl_test_rel(C[2*i+1], C_expected[2*i+1], flteps, "csymm(case 1538) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(C[2*i], C_expected[2*i], flteps, "csymm(case 1539) real");
       gsl_test_rel(C[2*i+1], C_expected[2*i+1], flteps, "csymm(case 1539) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(C[2*i], C_expected[2*i], flteps, "csymm(case 1540) real");
       gsl_test_rel(C[2*i+1], C_expected[2*i+1], flteps, "csymm(case 1540) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(C[2*i], C_expected[2*i], flteps, "csymm(case 1541) real");
       gsl_test_rel(C[2*i+1], C_expected[2*i+1], flteps, "csymm(case 1541) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(C[2*i], C_expected[2*i], dbleps, "zsymm(case 1542) real");
       gsl_test_rel(C[2*i+1], C_expected[2*i+1], dbleps, "zsymm(case 1542) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(C[2*i], C_expected[2*i], dbleps, "zsymm(case 1543) real");
       gsl_test_rel(C[2*i+1], C_expected[2*i+1], dbleps, "zsymm(case 1543) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(C[2*i], C_expected[2*i], dbleps, "zsymm(case 1544) real");
       gsl_test_rel(C[2*i+1], C_expected[2*i+1], dbleps, "zsymm(case 1544) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(C[2*i], C_expected[2*i], dbleps, "zsymm(case 1545) real");
       gsl_test_rel(C[2*i+1], C_expected[2*i+1], dbleps, "zsymm(case 1545) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(C[2*i], C_expected[2*i], dbleps, "zsymm(case 1546) real");
       gsl_test_rel(C[2*i+1], C_expected[2*i+1], dbleps, "zsymm(case 1546) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(C[2*i], C_expected[2*i], dbleps, "zsymm(case 1547) real");
       gsl_test_rel(C[2*i+1], C_expected[2*i+1], dbleps, "zsymm(case 1547) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(C[2*i], C_expected[2*i], dbleps, "zsymm(case 1548) real");
       gsl_test_rel(C[2*i+1], C_expected[2*i+1], dbleps, "zsymm(case 1548) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(C[2*i], C_expected[2*i], dbleps, "zsymm(case 1549) real");
       gsl_test_rel(C[2*i+1], C_expected[2*i+1], dbleps, "zsymm(case 1549) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 4; i++) {
       gsl_test_rel(C[2*i], C_expected[2*i], flteps, "cherk(case 1598) real");
       gsl_test_rel(C[2*i+1], C_expected[2*i+1], flteps, "cherk(case 1598) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 4; i++) {
       gsl_test_rel(C[2*i], C_expected[2*i], flteps, "cherk(case 1599) real");
       gsl_test_rel(C[2*i+1], C_expected[2*i+1], flteps, "cherk(case 1599) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 4; i++) {
       gsl_test_rel(C[2*i], C_expected[2*i], flteps, "cherk(case 1600) real");
       gsl_test_rel(C[2*i+1], C_expected[2*i+1], flteps, "cherk(case 1600) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 4; i++) {
       gsl_test_rel(C[2*i], C_expected[2*i], flteps, "cherk(case 1601) real");
       gsl_test_rel(C[2*i+1], C_expected[2*i+1], flteps, "cherk(case 1601) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 4; i++) {
       gsl_test_rel(C[2*i], C_expected[2*i], flteps, "cherk(case 1602) real");
       gsl_test_rel(C[2*i+1], C_expected[2*i+1], flteps, "cherk(case 1602) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 4; i++) {
       gsl_test_rel(C[2*i], C_expected[2*i], flteps, "cherk(case 1603) real");
       gsl_test_rel(C[2*i+1], C_expected[2*i+1], flteps, "cherk(case 1603) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 4; i++) {
       gsl_test_rel(C[2*i], C_expected[2*i], flteps, "cherk(case 1604) real");
       gsl_test_rel(C[2*i+1], C_expected[2*i+1], flteps, "cherk(case 1604) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 4; i++) {
       gsl_test_rel(C[2*i], C_expected[2*i], flteps, "cherk(case 1605) real");
       gsl_test_rel(C[2*i+1], C_expected[2*i+1], flteps, "cherk(case 1605) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 4; i++) {
       gsl_test_rel(C[2*i], C_expected[2*i], dbleps, "zherk(case 1606) real");
       gsl_test_rel(C[2*i+1], C_expected[2*i+1], dbleps, "zherk(case 1606) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 4; i++) {
       gsl_test_rel(C[2*i], C_expected[2*i], dbleps, "zherk(case 1607) real");
       gsl_test_rel(C[2*i+1], C_expected[2*i+1], dbleps, "zherk(case 1607) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 4; i++) {
       gsl_test_rel(C[2*i], C_expected[2*i], dbleps, "zherk(case 1608) real");
       gsl_test_rel(C[2*i+1], C_expected[2*i+1], dbleps, "zherk(case 1608) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 4; i++) {
       gsl_test_rel(C[2*i], C_expected[2*i], dbleps, "zherk(case 1609) real");
       gsl_test_rel(C[2*i+1], C_expected[2*i+1], dbleps, "zherk(case 1609) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 4; i++) {
       gsl_test_rel(C[2*i], C_expected[2*i], dbleps, "zherk(case 1610) real");
       gsl_test_rel(C[2*i+1], C_expected[2*i+1], dbleps, "zherk(case 1610) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 4; i++) {
       gsl_test_rel(C[2*i], C_expected[2*i], dbleps, "zherk(case 1611) real");
       gsl_test_rel(C[2*i+1], C_expected[2*i+1], dbleps, "zherk(case 1611) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 4; i++) {
       gsl_test_rel(C[2*i], C_expected[2*i], dbleps, "zherk(case 1612) real");
       gsl_test_rel(C[2*i+1], C_expected[2*i+1], dbleps, "zherk(case 1612) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 4; i++) {
       gsl_test_rel(C[2*i], C_expected[2*i], dbleps, "zherk(case 1613) real");
       gsl_test_rel(C[2*i+1], C_expected[2*i+1], dbleps, "zherk(case 1613) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[i], x_expected[i], flteps, "stpmv(case 974)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[i], x_expected[i], flteps, "stpmv(case 975)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[i], x_expected[i], flteps, "stpmv(case 976)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[i], x_expected[i], flteps, "stpmv(case 977)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[i], x_expected[i], flteps, "stpmv(case 978)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[i], x_expected[i], flteps, "stpmv(case 979)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[i], x_expected[i], flteps, "stpmv(case 980)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[i], x_expected[i], flteps, "stpmv(case 981)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[i], x_expected[i], flteps, "stpmv(case 982)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[i], x_expected[i], flteps, "stpmv(case 983)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[i], x_expected[i], flteps, "stpmv(case 984)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[i], x_expected[i], flteps, "stpmv(case 985)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[i], x_expected[i], flteps, "stpmv(case 986)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[i], x_expected[i], flteps, "stpmv(case 987)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[i], x_expected[i], flteps, "stpmv(case 988)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[i], x_expected[i], flteps, "stpmv(case 989)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[i], x_expected[i], dbleps, "dtpmv(case 990)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[i], x_expected[i], dbleps, "dtpmv(case 991)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[i], x_expected[i], dbleps, "dtpmv(case 992)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[i], x_expected[i], dbleps, "dtpmv(case 993)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[i], x_expected[i], dbleps, "dtpmv(case 994)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[i], x_expected[i], dbleps, "dtpmv(case 995)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[i], x_expected[i], dbleps, "dtpmv(case 996)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[i], x_expected[i], dbleps, "dtpmv(case 997)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[i], x_expected[i], dbleps, "dtpmv(case 998)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[i], x_expected[i], dbleps, "dtpmv(case 999)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[i], x_expected[i], dbleps, "dtpmv(case 1000)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[i], x_expected[i], dbleps, "dtpmv(case 1001)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[i], x_expected[i], dbleps, "dtpmv(case 1002)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[i], x_expected[i], dbleps, "dtpmv(case 1003)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[i], x_expected[i], dbleps, "dtpmv(case 1004)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[i], x_expected[i], dbleps, "dtpmv(case 1005)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], flteps, "ctpmv(case 1006) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], flteps, "ctpmv(case 1006) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], flteps, "ctpmv(case 1007) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], flteps, "ctpmv(case 1007) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], flteps, "ctpmv(case 1008) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], flteps, "ctpmv(case 1008) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], flteps, "ctpmv(case 1009) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], flteps, "ctpmv(case 1009) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], flteps, "ctpmv(case 1010) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], flteps, "ctpmv(case 1010) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], flteps, "ctpmv(case 1011) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], flteps, "ctpmv(case 1011) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], flteps, "ctpmv(case 1012) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], flteps, "ctpmv(case 1012) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], flteps, "ctpmv(case 1013) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], flteps, "ctpmv(case 1013) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], flteps, "ctpmv(case 1014) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], flteps, "ctpmv(case 1014) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], flteps, "ctpmv(case 1015) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], flteps, "ctpmv(case 1015) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], flteps, "ctpmv(case 1016) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], flteps, "ctpmv(case 1016) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], flteps, "ctpmv(case 1017) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], flteps, "ctpmv(case 1017) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], flteps, "ctpmv(case 1018) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], flteps, "ctpmv(case 1018) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], flteps, "ctpmv(case 1019) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], flteps, "ctpmv(case 1019) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], flteps, "ctpmv(case 1020) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], flteps, "ctpmv(case 1020) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], flteps, "ctpmv(case 1021) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], flteps, "ctpmv(case 1021) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], flteps, "ctpmv(case 1022) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], flteps, "ctpmv(case 1022) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], flteps, "ctpmv(case 1023) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], flteps, "ctpmv(case 1023) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], flteps, "ctpmv(case 1024) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], flteps, "ctpmv(case 1024) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], flteps, "ctpmv(case 1025) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], flteps, "ctpmv(case 1025) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], flteps, "ctpmv(case 1026) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], flteps, "ctpmv(case 1026) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], flteps, "ctpmv(case 1027) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], flteps, "ctpmv(case 1027) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], flteps, "ctpmv(case 1028) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], flteps, "ctpmv(case 1028) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], flteps, "ctpmv(case 1029) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], flteps, "ctpmv(case 1029) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], dbleps, "ztpmv(case 1030) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], dbleps, "ztpmv(case 1030) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], dbleps, "ztpmv(case 1031) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], dbleps, "ztpmv(case 1031) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], dbleps, "ztpmv(case 1032) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], dbleps, "ztpmv(case 1032) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], dbleps, "ztpmv(case 1033) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], dbleps, "ztpmv(case 1033) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], dbleps, "ztpmv(case 1034) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], dbleps, "ztpmv(case 1034) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], dbleps, "ztpmv(case 1035) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], dbleps, "ztpmv(case 1035) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], dbleps, "ztpmv(case 1036) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], dbleps, "ztpmv(case 1036) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], dbleps, "ztpmv(case 1037) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], dbleps, "ztpmv(case 1037) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], dbleps, "ztpmv(case 1038) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], dbleps, "ztpmv(case 1038) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], dbleps, "ztpmv(case 1039) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], dbleps, "ztpmv(case 1039) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], dbleps, "ztpmv(case 1040) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], dbleps, "ztpmv(case 1040) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], dbleps, "ztpmv(case 1041) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], dbleps, "ztpmv(case 1041) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], dbleps, "ztpmv(case 1042) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], dbleps, "ztpmv(case 1042) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], dbleps, "ztpmv(case 1043) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], dbleps, "ztpmv(case 1043) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], dbleps, "ztpmv(case 1044) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], dbleps, "ztpmv(case 1044) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], dbleps, "ztpmv(case 1045) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], dbleps, "ztpmv(case 1045) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], dbleps, "ztpmv(case 1046) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], dbleps, "ztpmv(case 1046) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], dbleps, "ztpmv(case 1047) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], dbleps, "ztpmv(case 1047) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], dbleps, "ztpmv(case 1048) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], dbleps, "ztpmv(case 1048) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], dbleps, "ztpmv(case 1049) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], dbleps, "ztpmv(case 1049) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], dbleps, "ztpmv(case 1050) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], dbleps, "ztpmv(case 1050) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], dbleps, "ztpmv(case 1051) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], dbleps, "ztpmv(case 1051) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], dbleps, "ztpmv(case 1052) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], dbleps, "ztpmv(case 1052) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], dbleps, "ztpmv(case 1053) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], dbleps, "ztpmv(case 1053) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[i], expected[i], flteps, "scopy(case 76)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[i], expected[i], dbleps, "dcopy(case 77)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[2*i], expected[2*i], flteps, "ccopy(case 78) real");
       gsl_test_rel(Y[2*i+1], expected[2*i+1], flteps, "ccopy(case 78) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[2*i], expected[2*i], dbleps, "zcopy(case 79) real");
       gsl_test_rel(Y[2*i+1], expected[2*i+1], dbleps, "zcopy(case 79) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[i], expected[i], flteps, "scopy(case 80)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[i], expected[i], dbleps, "dcopy(case 81)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[2*i], expected[2*i], flteps, "ccopy(case 82) real");
       gsl_test_rel(Y[2*i+1], expected[2*i+1], flteps, "ccopy(case 82) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[2*i], expected[2*i], dbleps, "zcopy(case 83) real");
       gsl_test_rel(Y[2*i+1], expected[2*i+1], dbleps, "zcopy(case 83) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[i], expected[i], flteps, "scopy(case 84)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[i], expected[i], dbleps, "dcopy(case 85)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[2*i], expected[2*i], flteps, "ccopy(case 86) real");
       gsl_test_rel(Y[2*i+1], expected[2*i+1], flteps, "ccopy(case 86) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[2*i], expected[2*i], dbleps, "zcopy(case 87) real");
       gsl_test_rel(Y[2*i+1], expected[2*i+1], dbleps, "zcopy(case 87) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(Ap[i], Ap_expected[i], flteps, "sspr2(case 1442)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(Ap[i], Ap_expected[i], flteps, "sspr2(case 1443)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(Ap[i], Ap_expected[i], flteps, "sspr2(case 1444)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(Ap[i], Ap_expected[i], flteps, "sspr2(case 1445)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(Ap[i], Ap_expected[i], dbleps, "dspr2(case 1446)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(Ap[i], Ap_expected[i], dbleps, "dspr2(case 1447)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(Ap[i], Ap_expected[i], dbleps, "dspr2(case 1448)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(Ap[i], Ap_expected[i], dbleps, "dspr2(case 1449)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(A[2*i], A_expected[2*i], flteps, "cher(case 1410) real");
       gsl_test_rel(A[2*i+1], A_expected[2*i+1], flteps, "cher(case 1410) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(A[2*i], A_expected[2*i], flteps, "cher(case 1411) real");
       gsl_test_rel(A[2*i+1], A_expected[2*i+1], flteps, "cher(case 1411) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(A[2*i], A_expected[2*i], flteps, "cher(case 1412) real");
       gsl_test_rel(A[2*i+1], A_expected[2*i+1], flteps, "cher(case 1412) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(A[2*i], A_expected[2*i], flteps, "cher(case 1413) real");
       gsl_test_rel(A[2*i+1], A_expected[2*i+1], flteps, "cher(case 1413) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(A[2*i], A_expected[2*i], dbleps, "zher(case 1414) real");
       gsl_test_rel(A[2*i+1], A_expected[2*i+1], dbleps, "zher(case 1414) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(A[2*i], A_expected[2*i], dbleps, "zher(case 1415) real");
       gsl_test_rel(A[2*i+1], A_expected[2*i+1], dbleps, "zher(case 1415) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(A[2*i], A_expected[2*i], dbleps, "zher(case 1416) real");
       gsl_test_rel(A[2*i+1], A_expected[2*i+1], dbleps, "zher(case 1416) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(A[2*i], A_expected[2*i], dbleps, "zher(case 1417) real");
       gsl_test_rel(A[2*i+1], A_expected[2*i+1], dbleps, "zher(case 1417) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(A[i], A_expected[i], flteps, "ssyr(case 1402)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(A[i], A_expected[i], flteps, "ssyr(case 1403)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(A[i], A_expected[i], flteps, "ssyr(case 1404)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(A[i], A_expected[i], flteps, "ssyr(case 1405)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(A[i], A_expected[i], dbleps, "dsyr(case 1406)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(A[i], A_expected[i], dbleps, "dsyr(case 1407)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(A[i], A_expected[i], dbleps, "dsyr(case 1408)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(A[i], A_expected[i], dbleps, "dsyr(case 1409)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(Y[i], y_expected[i], flteps, "ssbmv(case 1102)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(Y[i], y_expected[i], flteps, "ssbmv(case 1103)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(Y[i], y_expected[i], flteps, "ssbmv(case 1104)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(Y[i], y_expected[i], flteps, "ssbmv(case 1105)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(Y[i], y_expected[i], flteps, "ssbmv(case 1106)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(Y[i], y_expected[i], flteps, "ssbmv(case 1107)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(Y[i], y_expected[i], flteps, "ssbmv(case 1108)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(Y[i], y_expected[i], flteps, "ssbmv(case 1109)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(Y[i], y_expected[i], dbleps, "dsbmv(case 1110)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(Y[i], y_expected[i], dbleps, "dsbmv(case 1111)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(Y[i], y_expected[i], dbleps, "dsbmv(case 1112)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(Y[i], y_expected[i], dbleps, "dsbmv(case 1113)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(Y[i], y_expected[i], dbleps, "dsbmv(case 1114)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(Y[i], y_expected[i], dbleps, "dsbmv(case 1115)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(Y[i], y_expected[i], dbleps, "dsbmv(case 1116)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(Y[i], y_expected[i], dbleps, "dsbmv(case 1117)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[2*i], y_expected[2*i], flteps, "chemv(case 1070) real");
       gsl_test_rel(Y[2*i+1], y_expected[2*i+1], flteps, "chemv(case 1070) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[2*i], y_expected[2*i], flteps, "chemv(case 1071) real");
       gsl_test_rel(Y[2*i+1], y_expected[2*i+1], flteps, "chemv(case 1071) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[2*i], y_expected[2*i], flteps, "chemv(case 1072) real");
       gsl_test_rel(Y[2*i+1], y_expected[2*i+1], flteps, "chemv(case 1072) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[2*i], y_expected[2*i], flteps, "chemv(case 1073) real");
       gsl_test_rel(Y[2*i+1], y_expected[2*i+1], flteps, "chemv(case 1073) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[2*i], y_expected[2*i], flteps, "chemv(case 1074) real");
       gsl_test_rel(Y[2*i+1], y_expected[2*i+1], flteps, "chemv(case 1074) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[2*i], y_expected[2*i], flteps, "chemv(case 1075) real");
       gsl_test_rel(Y[2*i+1], y_expected[2*i+1], flteps, "chemv(case 1075) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[2*i], y_expected[2*i], flteps, "chemv(case 1076) real");
       gsl_test_rel(Y[2*i+1], y_expected[2*i+1], flteps, "chemv(case 1076) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[2*i], y_expected[2*i], flteps, "chemv(case 1077) real");
       gsl_test_rel(Y[2*i+1], y_expected[2*i+1], flteps, "chemv(case 1077) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[2*i], y_expected[2*i], dbleps, "zhemv(case 1078) real");
       gsl_test_rel(Y[2*i+1], y_expected[2*i+1], dbleps, "zhemv(case 1078) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[2*i], y_expected[2*i], dbleps, "zhemv(case 1079) real");
       gsl_test_rel(Y[2*i+1], y_expected[2*i+1], dbleps, "zhemv(case 1079) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[2*i], y_expected[2*i], dbleps, "zhemv(case 1080) real");
       gsl_test_rel(Y[2*i+1], y_expected[2*i+1], dbleps, "zhemv(case 1080) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[2*i], y_expected[2*i], dbleps, "zhemv(case 1081) real");
       gsl_test_rel(Y[2*i+1], y_expected[2*i+1], dbleps, "zhemv(case 1081) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[2*i], y_expected[2*i], dbleps, "zhemv(case 1082) real");
       gsl_test_rel(Y[2*i+1], y_expected[2*i+1], dbleps, "zhemv(case 1082) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[2*i], y_expected[2*i], dbleps, "zhemv(case 1083) real");
       gsl_test_rel(Y[2*i+1], y_expected[2*i+1], dbleps, "zhemv(case 1083) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[2*i], y_expected[2*i], dbleps, "zhemv(case 1084) real");
       gsl_test_rel(Y[2*i+1], y_expected[2*i+1], dbleps, "zhemv(case 1084) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[2*i], y_expected[2*i], dbleps, "zhemv(case 1085) real");
       gsl_test_rel(Y[2*i+1], y_expected[2*i+1], dbleps, "zhemv(case 1085) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], x_expected[i], flteps, "strsv(case 1150)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], x_expected[i], flteps, "strsv(case 1151)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], x_expected[i], flteps, "strsv(case 1152)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], x_expected[i], flteps, "strsv(case 1153)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], x_expected[i], flteps, "strsv(case 1154)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], x_expected[i], flteps, "strsv(case 1155)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], x_expected[i], flteps, "strsv(case 1156)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], x_expected[i], flteps, "strsv(case 1157)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], x_expected[i], flteps, "strsv(case 1158)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], x_expected[i], flteps, "strsv(case 1159)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], x_expected[i], flteps, "strsv(case 1160)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], x_expected[i], flteps, "strsv(case 1161)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], x_expected[i], flteps, "strsv(case 1162)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], x_expected[i], flteps, "strsv(case 1163)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], x_expected[i], flteps, "strsv(case 1164)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], x_expected[i], flteps, "strsv(case 1165)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], x_expected[i], dbleps, "dtrsv(case 1166)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], x_expected[i], dbleps, "dtrsv(case 1167)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], x_expected[i], dbleps, "dtrsv(case 1168)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], x_expected[i], dbleps, "dtrsv(case 1169)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], x_expected[i], dbleps, "dtrsv(case 1170)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], x_expected[i], dbleps, "dtrsv(case 1171)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], x_expected[i], dbleps, "dtrsv(case 1172)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], x_expected[i], dbleps, "dtrsv(case 1173)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], x_expected[i], dbleps, "dtrsv(case 1174)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], x_expected[i], dbleps, "dtrsv(case 1175)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], x_expected[i], dbleps, "dtrsv(case 1176)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], x_expected[i], dbleps, "dtrsv(case 1177)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], x_expected[i], dbleps, "dtrsv(case 1178)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], x_expected[i], dbleps, "dtrsv(case 1179)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], x_expected[i], dbleps, "dtrsv(case 1180)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], x_expected[i], dbleps, "dtrsv(case 1181)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], flteps, "ctrsv(case 1182) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], flteps, "ctrsv(case 1182) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], flteps, "ctrsv(case 1183) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], flteps, "ctrsv(case 1183) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], flteps, "ctrsv(case 1184) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], flteps, "ctrsv(case 1184) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], flteps, "ctrsv(case 1185) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], flteps, "ctrsv(case 1185) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], flteps, "ctrsv(case 1186) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], flteps, "ctrsv(case 1186) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], flteps, "ctrsv(case 1187) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], flteps, "ctrsv(case 1187) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], flteps, "ctrsv(case 1188) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], flteps, "ctrsv(case 1188) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], flteps, "ctrsv(case 1189) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], flteps, "ctrsv(case 1189) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], flteps, "ctrsv(case 1190) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], flteps, "ctrsv(case 1190) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], flteps, "ctrsv(case 1191) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], flteps, "ctrsv(case 1191) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], flteps, "ctrsv(case 1192) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], flteps, "ctrsv(case 1192) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], flteps, "ctrsv(case 1193) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], flteps, "ctrsv(case 1193) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], flteps, "ctrsv(case 1194) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], flteps, "ctrsv(case 1194) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], flteps, "ctrsv(case 1195) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], flteps, "ctrsv(case 1195) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], flteps, "ctrsv(case 1196) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], flteps, "ctrsv(case 1196) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], flteps, "ctrsv(case 1197) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], flteps, "ctrsv(case 1197) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], flteps, "ctrsv(case 1198) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], flteps, "ctrsv(case 1198) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], flteps, "ctrsv(case 1199) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], flteps, "ctrsv(case 1199) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], flteps, "ctrsv(case 1200) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], flteps, "ctrsv(case 1200) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], flteps, "ctrsv(case 1201) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], flteps, "ctrsv(case 1201) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], flteps, "ctrsv(case 1202) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], flteps, "ctrsv(case 1202) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], flteps, "ctrsv(case 1203) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], flteps, "ctrsv(case 1203) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], flteps, "ctrsv(case 1204) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], flteps, "ctrsv(case 1204) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], flteps, "ctrsv(case 1205) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], flteps, "ctrsv(case 1205) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], dbleps, "ztrsv(case 1206) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], dbleps, "ztrsv(case 1206) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], dbleps, "ztrsv(case 1207) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], dbleps, "ztrsv(case 1207) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], dbleps, "ztrsv(case 1208) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], dbleps, "ztrsv(case 1208) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], dbleps, "ztrsv(case 1209) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], dbleps, "ztrsv(case 1209) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], dbleps, "ztrsv(case 1210) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], dbleps, "ztrsv(case 1210) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], dbleps, "ztrsv(case 1211) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], dbleps, "ztrsv(case 1211) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], dbleps, "ztrsv(case 1212) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], dbleps, "ztrsv(case 1212) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], dbleps, "ztrsv(case 1213) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], dbleps, "ztrsv(case 1213) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], dbleps, "ztrsv(case 1214) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], dbleps, "ztrsv(case 1214) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], dbleps, "ztrsv(case 1215) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], dbleps, "ztrsv(case 1215) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], dbleps, "ztrsv(case 1216) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], dbleps, "ztrsv(case 1216) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], dbleps, "ztrsv(case 1217) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], dbleps, "ztrsv(case 1217) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], dbleps, "ztrsv(case 1218) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], dbleps, "ztrsv(case 1218) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], dbleps, "ztrsv(case 1219) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], dbleps, "ztrsv(case 1219) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], dbleps, "ztrsv(case 1220) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], dbleps, "ztrsv(case 1220) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], dbleps, "ztrsv(case 1221) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], dbleps, "ztrsv(case 1221) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], dbleps, "ztrsv(case 1222) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], dbleps, "ztrsv(case 1222) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], dbleps, "ztrsv(case 1223) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], dbleps, "ztrsv(case 1223) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], dbleps, "ztrsv(case 1224) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], dbleps, "ztrsv(case 1224) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], dbleps, "ztrsv(case 1225) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], dbleps, "ztrsv(case 1225) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], dbleps, "ztrsv(case 1226) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], dbleps, "ztrsv(case 1226) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], dbleps, "ztrsv(case 1227) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], dbleps, "ztrsv(case 1227) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], dbleps, "ztrsv(case 1228) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], dbleps, "ztrsv(case 1228) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], dbleps, "ztrsv(case 1229) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], dbleps, "ztrsv(case 1229) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[i], x_expected[i], flteps, "stbsv(case 1230)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[i], x_expected[i], flteps, "stbsv(case 1231)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[i], x_expected[i], flteps, "stbsv(case 1232)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[i], x_expected[i], flteps, "stbsv(case 1233)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[i], x_expected[i], flteps, "stbsv(case 1234)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[i], x_expected[i], flteps, "stbsv(case 1235)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[i], x_expected[i], flteps, "stbsv(case 1236)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[i], x_expected[i], flteps, "stbsv(case 1237)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[i], x_expected[i], flteps, "stbsv(case 1238)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[i], x_expected[i], flteps, "stbsv(case 1239)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[i], x_expected[i], flteps, "stbsv(case 1240)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[i], x_expected[i], flteps, "stbsv(case 1241)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[i], x_expected[i], flteps, "stbsv(case 1242)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[i], x_expected[i], flteps, "stbsv(case 1243)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[i], x_expected[i], flteps, "stbsv(case 1244)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[i], x_expected[i], flteps, "stbsv(case 1245)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[i], x_expected[i], dbleps, "dtbsv(case 1246)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[i], x_expected[i], dbleps, "dtbsv(case 1247)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[i], x_expected[i], dbleps, "dtbsv(case 1248)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[i], x_expected[i], dbleps, "dtbsv(case 1249)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[i], x_expected[i], dbleps, "dtbsv(case 1250)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[i], x_expected[i], dbleps, "dtbsv(case 1251)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[i], x_expected[i], dbleps, "dtbsv(case 1252)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[i], x_expected[i], dbleps, "dtbsv(case 1253)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[i], x_expected[i], dbleps, "dtbsv(case 1254)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[i], x_expected[i], dbleps, "dtbsv(case 1255)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[i], x_expected[i], dbleps, "dtbsv(case 1256)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[i], x_expected[i], dbleps, "dtbsv(case 1257)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[i], x_expected[i], dbleps, "dtbsv(case 1258)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[i], x_expected[i], dbleps, "dtbsv(case 1259)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[i], x_expected[i], dbleps, "dtbsv(case 1260)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[i], x_expected[i], dbleps, "dtbsv(case 1261)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], flteps, "ctbsv(case 1262) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], flteps, "ctbsv(case 1262) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], flteps, "ctbsv(case 1263) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], flteps, "ctbsv(case 1263) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], flteps, "ctbsv(case 1264) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], flteps, "ctbsv(case 1264) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], flteps, "ctbsv(case 1265) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], flteps, "ctbsv(case 1265) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], flteps, "ctbsv(case 1266) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], flteps, "ctbsv(case 1266) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], flteps, "ctbsv(case 1267) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], flteps, "ctbsv(case 1267) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], flteps, "ctbsv(case 1268) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], flteps, "ctbsv(case 1268) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], flteps, "ctbsv(case 1269) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], flteps, "ctbsv(case 1269) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], flteps, "ctbsv(case 1270) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], flteps, "ctbsv(case 1270) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], flteps, "ctbsv(case 1271) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], flteps, "ctbsv(case 1271) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], flteps, "ctbsv(case 1272) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], flteps, "ctbsv(case 1272) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], flteps, "ctbsv(case 1273) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], flteps, "ctbsv(case 1273) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], flteps, "ctbsv(case 1274) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], flteps, "ctbsv(case 1274) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], flteps, "ctbsv(case 1275) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], flteps, "ctbsv(case 1275) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], flteps, "ctbsv(case 1276) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], flteps, "ctbsv(case 1276) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], flteps, "ctbsv(case 1277) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], flteps, "ctbsv(case 1277) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], flteps, "ctbsv(case 1278) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], flteps, "ctbsv(case 1278) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], flteps, "ctbsv(case 1279) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], flteps, "ctbsv(case 1279) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], flteps, "ctbsv(case 1280) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], flteps, "ctbsv(case 1280) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], flteps, "ctbsv(case 1281) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], flteps, "ctbsv(case 1281) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], flteps, "ctbsv(case 1282) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], flteps, "ctbsv(case 1282) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], flteps, "ctbsv(case 1283) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], flteps, "ctbsv(case 1283) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], flteps, "ctbsv(case 1284) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], flteps, "ctbsv(case 1284) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], flteps, "ctbsv(case 1285) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], flteps, "ctbsv(case 1285) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], dbleps, "ztbsv(case 1286) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], dbleps, "ztbsv(case 1286) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], dbleps, "ztbsv(case 1287) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], dbleps, "ztbsv(case 1287) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], dbleps, "ztbsv(case 1288) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], dbleps, "ztbsv(case 1288) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], dbleps, "ztbsv(case 1289) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], dbleps, "ztbsv(case 1289) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], dbleps, "ztbsv(case 1290) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], dbleps, "ztbsv(case 1290) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], dbleps, "ztbsv(case 1291) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], dbleps, "ztbsv(case 1291) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], dbleps, "ztbsv(case 1292) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], dbleps, "ztbsv(case 1292) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], dbleps, "ztbsv(case 1293) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], dbleps, "ztbsv(case 1293) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], dbleps, "ztbsv(case 1294) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], dbleps, "ztbsv(case 1294) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], dbleps, "ztbsv(case 1295) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], dbleps, "ztbsv(case 1295) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], dbleps, "ztbsv(case 1296) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], dbleps, "ztbsv(case 1296) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], dbleps, "ztbsv(case 1297) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], dbleps, "ztbsv(case 1297) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], dbleps, "ztbsv(case 1298) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], dbleps, "ztbsv(case 1298) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], dbleps, "ztbsv(case 1299) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], dbleps, "ztbsv(case 1299) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], dbleps, "ztbsv(case 1300) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], dbleps, "ztbsv(case 1300) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], dbleps, "ztbsv(case 1301) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], dbleps, "ztbsv(case 1301) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], dbleps, "ztbsv(case 1302) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], dbleps, "ztbsv(case 1302) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], dbleps, "ztbsv(case 1303) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], dbleps, "ztbsv(case 1303) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], dbleps, "ztbsv(case 1304) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], dbleps, "ztbsv(case 1304) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], dbleps, "ztbsv(case 1305) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], dbleps, "ztbsv(case 1305) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], dbleps, "ztbsv(case 1306) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], dbleps, "ztbsv(case 1306) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], dbleps, "ztbsv(case 1307) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], dbleps, "ztbsv(case 1307) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], dbleps, "ztbsv(case 1308) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], dbleps, "ztbsv(case 1308) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], dbleps, "ztbsv(case 1309) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], dbleps, "ztbsv(case 1309) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[i], y_expected[i], flteps, "ssymv(case 1054)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[i], y_expected[i], flteps, "ssymv(case 1055)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[i], y_expected[i], flteps, "ssymv(case 1056)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[i], y_expected[i], flteps, "ssymv(case 1057)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[i], y_expected[i], flteps, "ssymv(case 1058)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[i], y_expected[i], flteps, "ssymv(case 1059)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[i], y_expected[i], flteps, "ssymv(case 1060)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[i], y_expected[i], flteps, "ssymv(case 1061)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[i], y_expected[i], dbleps, "dsymv(case 1062)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[i], y_expected[i], dbleps, "dsymv(case 1063)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[i], y_expected[i], dbleps, "dsymv(case 1064)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[i], y_expected[i], dbleps, "dsymv(case 1065)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[i], y_expected[i], dbleps, "dsymv(case 1066)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[i], y_expected[i], dbleps, "dsymv(case 1067)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[i], y_expected[i], dbleps, "dsymv(case 1068)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[i], y_expected[i], dbleps, "dsymv(case 1069)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(Y[2*i], y_expected[2*i], flteps, "chbmv(case 1086) real");
       gsl_test_rel(Y[2*i+1], y_expected[2*i+1], flteps, "chbmv(case 1086) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(Y[2*i], y_expected[2*i], flteps, "chbmv(case 1087) real");
       gsl_test_rel(Y[2*i+1], y_expected[2*i+1], flteps, "chbmv(case 1087) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(Y[2*i], y_expected[2*i], flteps, "chbmv(case 1088) real");
       gsl_test_rel(Y[2*i+1], y_expected[2*i+1], flteps, "chbmv(case 1088) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(Y[2*i], y_expected[2*i], flteps, "chbmv(case 1089) real");
       gsl_test_rel(Y[2*i+1], y_expected[2*i+1], flteps, "chbmv(case 1089) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(Y[2*i], y_expected[2*i], flteps, "chbmv(case 1090) real");
       gsl_test_rel(Y[2*i+1], y_expected[2*i+1], flteps, "chbmv(case 1090) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(Y[2*i], y_expected[2*i], flteps, "chbmv(case 1091) real");
       gsl_test_rel(Y[2*i+1], y_expected[2*i+1], flteps, "chbmv(case 1091) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(Y[2*i], y_expected[2*i], flteps, "chbmv(case 1092) real");
       gsl_test_rel(Y[2*i+1], y_expected[2*i+1], flteps, "chbmv(case 1092) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(Y[2*i], y_expected[2*i], flteps, "chbmv(case 1093) real");
       gsl_test_rel(Y[2*i+1], y_expected[2*i+1], flteps, "chbmv(case 1093) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(Y[2*i], y_expected[2*i], dbleps, "zhbmv(case 1094) real");
       gsl_test_rel(Y[2*i+1], y_expected[2*i+1], dbleps, "zhbmv(case 1094) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(Y[2*i], y_expected[2*i], dbleps, "zhbmv(case 1095) real");
       gsl_test_rel(Y[2*i+1], y_expected[2*i+1], dbleps, "zhbmv(case 1095) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(Y[2*i], y_expected[2*i], dbleps, "zhbmv(case 1096) real");
       gsl_test_rel(Y[2*i+1], y_expected[2*i+1], dbleps, "zhbmv(case 1096) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(Y[2*i], y_expected[2*i], dbleps, "zhbmv(case 1097) real");
       gsl_test_rel(Y[2*i+1], y_expected[2*i+1], dbleps, "zhbmv(case 1097) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(Y[2*i], y_expected[2*i], dbleps, "zhbmv(case 1098) real");
       gsl_test_rel(Y[2*i+1], y_expected[2*i+1], dbleps, "zhbmv(case 1098) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(Y[2*i], y_expected[2*i], dbleps, "zhbmv(case 1099) real");
       gsl_test_rel(Y[2*i+1], y_expected[2*i+1], dbleps, "zhbmv(case 1099) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(Y[2*i], y_expected[2*i], dbleps, "zhbmv(case 1100) real");
       gsl_test_rel(Y[2*i+1], y_expected[2*i+1], dbleps, "zhbmv(case 1100) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(Y[2*i], y_expected[2*i], dbleps, "zhbmv(case 1101) real");
       gsl_test_rel(Y[2*i+1], y_expected[2*i+1], dbleps, "zhbmv(case 1101) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[i], x_expected[i], flteps, "stbmv(case 894)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[i], x_expected[i], flteps, "stbmv(case 895)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[i], x_expected[i], flteps, "stbmv(case 896)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[i], x_expected[i], flteps, "stbmv(case 897)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[i], x_expected[i], flteps, "stbmv(case 898)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[i], x_expected[i], flteps, "stbmv(case 899)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[i], x_expected[i], flteps, "stbmv(case 900)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[i], x_expected[i], flteps, "stbmv(case 901)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[i], x_expected[i], flteps, "stbmv(case 902)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[i], x_expected[i], flteps, "stbmv(case 903)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[i], x_expected[i], flteps, "stbmv(case 904)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[i], x_expected[i], flteps, "stbmv(case 905)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[i], x_expected[i], flteps, "stbmv(case 906)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[i], x_expected[i], flteps, "stbmv(case 907)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[i], x_expected[i], flteps, "stbmv(case 908)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[i], x_expected[i], flteps, "stbmv(case 909)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[i], x_expected[i], dbleps, "dtbmv(case 910)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[i], x_expected[i], dbleps, "dtbmv(case 911)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[i], x_expected[i], dbleps, "dtbmv(case 912)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[i], x_expected[i], dbleps, "dtbmv(case 913)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[i], x_expected[i], dbleps, "dtbmv(case 914)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[i], x_expected[i], dbleps, "dtbmv(case 915)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[i], x_expected[i], dbleps, "dtbmv(case 916)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[i], x_expected[i], dbleps, "dtbmv(case 917)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[i], x_expected[i], dbleps, "dtbmv(case 918)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[i], x_expected[i], dbleps, "dtbmv(case 919)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[i], x_expected[i], dbleps, "dtbmv(case 920)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[i], x_expected[i], dbleps, "dtbmv(case 921)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[i], x_expected[i], dbleps, "dtbmv(case 922)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[i], x_expected[i], dbleps, "dtbmv(case 923)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[i], x_expected[i], dbleps, "dtbmv(case 924)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[i], x_expected[i], dbleps, "dtbmv(case 925)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], flteps, "ctbmv(case 926) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], flteps, "ctbmv(case 926) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], flteps, "ctbmv(case 927) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], flteps, "ctbmv(case 927) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], flteps, "ctbmv(case 928) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], flteps, "ctbmv(case 928) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], flteps, "ctbmv(case 929) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], flteps, "ctbmv(case 929) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], flteps, "ctbmv(case 930) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], flteps, "ctbmv(case 930) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], flteps, "ctbmv(case 931) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], flteps, "ctbmv(case 931) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], flteps, "ctbmv(case 932) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], flteps, "ctbmv(case 932) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], flteps, "ctbmv(case 933) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], flteps, "ctbmv(case 933) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], flteps, "ctbmv(case 934) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], flteps, "ctbmv(case 934) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], flteps, "ctbmv(case 935) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], flteps, "ctbmv(case 935) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], flteps, "ctbmv(case 936) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], flteps, "ctbmv(case 936) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], flteps, "ctbmv(case 937) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], flteps, "ctbmv(case 937) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], flteps, "ctbmv(case 938) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], flteps, "ctbmv(case 938) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], flteps, "ctbmv(case 939) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], flteps, "ctbmv(case 939) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], flteps, "ctbmv(case 940) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], flteps, "ctbmv(case 940) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], flteps, "ctbmv(case 941) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], flteps, "ctbmv(case 941) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], flteps, "ctbmv(case 942) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], flteps, "ctbmv(case 942) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], flteps, "ctbmv(case 943) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], flteps, "ctbmv(case 943) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], flteps, "ctbmv(case 944) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], flteps, "ctbmv(case 944) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], flteps, "ctbmv(case 945) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], flteps, "ctbmv(case 945) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], flteps, "ctbmv(case 946) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], flteps, "ctbmv(case 946) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], flteps, "ctbmv(case 947) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], flteps, "ctbmv(case 947) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], flteps, "ctbmv(case 948) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], flteps, "ctbmv(case 948) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], flteps, "ctbmv(case 949) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], flteps, "ctbmv(case 949) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], dbleps, "ztbmv(case 950) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], dbleps, "ztbmv(case 950) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], dbleps, "ztbmv(case 951) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], dbleps, "ztbmv(case 951) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], dbleps, "ztbmv(case 952) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], dbleps, "ztbmv(case 952) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], dbleps, "ztbmv(case 953) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], dbleps, "ztbmv(case 953) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], dbleps, "ztbmv(case 954) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], dbleps, "ztbmv(case 954) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], dbleps, "ztbmv(case 955) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], dbleps, "ztbmv(case 955) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], dbleps, "ztbmv(case 956) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], dbleps, "ztbmv(case 956) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], dbleps, "ztbmv(case 957) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], dbleps, "ztbmv(case 957) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], dbleps, "ztbmv(case 958) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], dbleps, "ztbmv(case 958) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], dbleps, "ztbmv(case 959) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], dbleps, "ztbmv(case 959) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], dbleps, "ztbmv(case 960) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], dbleps, "ztbmv(case 960) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], dbleps, "ztbmv(case 961) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], dbleps, "ztbmv(case 961) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], dbleps, "ztbmv(case 962) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], dbleps, "ztbmv(case 962) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], dbleps, "ztbmv(case 963) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], dbleps, "ztbmv(case 963) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], dbleps, "ztbmv(case 964) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], dbleps, "ztbmv(case 964) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], dbleps, "ztbmv(case 965) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], dbleps, "ztbmv(case 965) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], dbleps, "ztbmv(case 966) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], dbleps, "ztbmv(case 966) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], dbleps, "ztbmv(case 967) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], dbleps, "ztbmv(case 967) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], dbleps, "ztbmv(case 968) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], dbleps, "ztbmv(case 968) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], dbleps, "ztbmv(case 969) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], dbleps, "ztbmv(case 969) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], dbleps, "ztbmv(case 970) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], dbleps, "ztbmv(case 970) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], dbleps, "ztbmv(case 971) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], dbleps, "ztbmv(case 971) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], dbleps, "ztbmv(case 972) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], dbleps, "ztbmv(case 972) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], dbleps, "ztbmv(case 973) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], dbleps, "ztbmv(case 973) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(Y[2*i], y_expected[2*i], flteps, "chpmv(case 1118) real");
       gsl_test_rel(Y[2*i+1], y_expected[2*i+1], flteps, "chpmv(case 1118) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(Y[2*i], y_expected[2*i], flteps, "chpmv(case 1119) real");
       gsl_test_rel(Y[2*i+1], y_expected[2*i+1], flteps, "chpmv(case 1119) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(Y[2*i], y_expected[2*i], flteps, "chpmv(case 1120) real");
       gsl_test_rel(Y[2*i+1], y_expected[2*i+1], flteps, "chpmv(case 1120) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(Y[2*i], y_expected[2*i], flteps, "chpmv(case 1121) real");
       gsl_test_rel(Y[2*i+1], y_expected[2*i+1], flteps, "chpmv(case 1121) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(Y[2*i], y_expected[2*i], flteps, "chpmv(case 1122) real");
       gsl_test_rel(Y[2*i+1], y_expected[2*i+1], flteps, "chpmv(case 1122) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(Y[2*i], y_expected[2*i], flteps, "chpmv(case 1123) real");
       gsl_test_rel(Y[2*i+1], y_expected[2*i+1], flteps, "chpmv(case 1123) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(Y[2*i], y_expected[2*i], flteps, "chpmv(case 1124) real");
       gsl_test_rel(Y[2*i+1], y_expected[2*i+1], flteps, "chpmv(case 1124) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(Y[2*i], y_expected[2*i], flteps, "chpmv(case 1125) real");
       gsl_test_rel(Y[2*i+1], y_expected[2*i+1], flteps, "chpmv(case 1125) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(Y[2*i], y_expected[2*i], dbleps, "zhpmv(case 1126) real");
       gsl_test_rel(Y[2*i+1], y_expected[2*i+1], dbleps, "zhpmv(case 1126) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(Y[2*i], y_expected[2*i], dbleps, "zhpmv(case 1127) real");
       gsl_test_rel(Y[2*i+1], y_expected[2*i+1], dbleps, "zhpmv(case 1127) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(Y[2*i], y_expected[2*i], dbleps, "zhpmv(case 1128) real");
       gsl_test_rel(Y[2*i+1], y_expected[2*i+1], dbleps, "zhpmv(case 1128) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(Y[2*i], y_expected[2*i], dbleps, "zhpmv(case 1129) real");
       gsl_test_rel(Y[2*i+1], y_expected[2*i+1], dbleps, "zhpmv(case 1129) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(Y[2*i], y_expected[2*i], dbleps, "zhpmv(case 1130) real");
       gsl_test_rel(Y[2*i+1], y_expected[2*i+1], dbleps, "zhpmv(case 1130) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(Y[2*i], y_expected[2*i], dbleps, "zhpmv(case 1131) real");
       gsl_test_rel(Y[2*i+1], y_expected[2*i+1], dbleps, "zhpmv(case 1131) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(Y[2*i], y_expected[2*i], dbleps, "zhpmv(case 1132) real");
       gsl_test_rel(Y[2*i+1], y_expected[2*i+1], dbleps, "zhpmv(case 1132) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(Y[2*i], y_expected[2*i], dbleps, "zhpmv(case 1133) real");
       gsl_test_rel(Y[2*i+1], y_expected[2*i+1], dbleps, "zhpmv(case 1133) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], expected1[i], flteps, "sswap(case 88)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[i], expected2[i], flteps, "sswap(case 89)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], expected1[i], dbleps, "dswap(case 90)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[i], expected2[i], dbleps, "dswap(case 91)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[2*i], expected1[2*i], flteps, "cswap(case 92) real");
       gsl_test_rel(X[2*i+1], expected1[2*i+1], flteps, "cswap(case 92) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[2*i], expected2[2*i], flteps, "cswap(case 93) real");
       gsl_test_rel(Y[2*i+1], expected2[2*i+1], flteps, "cswap(case 93) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[2*i], expected1[2*i], dbleps, "zswap(case 94) real");
       gsl_test_rel(X[2*i+1], expected1[2*i+1], dbleps, "zswap(case 94) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[2*i], expected2[2*i], dbleps, "zswap(case 95) real");
       gsl_test_rel(Y[2*i+1], expected2[2*i+1], dbleps, "zswap(case 95) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], expected1[i], flteps, "sswap(case 96)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[i], expected2[i], flteps, "sswap(case 97)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], expected1[i], dbleps, "dswap(case 98)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[i], expected2[i], dbleps, "dswap(case 99)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[2*i], expected1[2*i], flteps, "cswap(case 100) real");
       gsl_test_rel(X[2*i+1], expected1[2*i+1], flteps, "cswap(case 100) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[2*i], expected2[2*i], flteps, "cswap(case 101) real");
       gsl_test_rel(Y[2*i+1], expected2[2*i+1], flteps, "cswap(case 101) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[2*i], expected1[2*i], dbleps, "zswap(case 102) real");
       gsl_test_rel(X[2*i+1], expected1[2*i+1], dbleps, "zswap(case 102) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[2*i], expected2[2*i], dbleps, "zswap(case 103) real");
       gsl_test_rel(Y[2*i+1], expected2[2*i+1], dbleps, "zswap(case 103) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], expected1[i], flteps, "sswap(case 104)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[i], expected2[i], flteps, "sswap(case 105)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], expected1[i], dbleps, "dswap(case 106)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[i], expected2[i], dbleps, "dswap(case 107)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[2*i], expected1[2*i], flteps, "cswap(case 108) real");
       gsl_test_rel(X[2*i+1], expected1[2*i+1], flteps, "cswap(case 108) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[2*i], expected2[2*i], flteps, "cswap(case 109) real");
       gsl_test_rel(Y[2*i+1], expected2[2*i+1], flteps, "cswap(case 109) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[2*i], expected1[2*i], dbleps, "zswap(case 110) real");
       gsl_test_rel(X[2*i+1], expected1[2*i+1], dbleps, "zswap(case 110) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[2*i], expected2[2*i], dbleps, "zswap(case 111) real");
       gsl_test_rel(Y[2*i+1], expected2[2*i+1], dbleps, "zswap(case 111) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[i], expected[i], flteps, "saxpy(case 64)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[i], expected[i], dbleps, "daxpy(case 65)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[2*i], expected[2*i], flteps, "caxpy(case 66) real");
       gsl_test_rel(Y[2*i+1], expected[2*i+1], flteps, "caxpy(case 66) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[2*i], expected[2*i], dbleps, "zaxpy(case 67) real");
       gsl_test_rel(Y[2*i+1], expected[2*i+1], dbleps, "zaxpy(case 67) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[i], expected[i], flteps, "saxpy(case 68)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[i], expected[i], dbleps, "daxpy(case 69)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[2*i], expected[2*i], flteps, "caxpy(case 70) real");
       gsl_test_rel(Y[2*i+1], expected[2*i+1], flteps, "caxpy(case 70) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[2*i], expected[2*i], dbleps, "zaxpy(case 71) real");
       gsl_test_rel(Y[2*i+1], expected[2*i+1], dbleps, "zaxpy(case 71) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[i], expected[i], flteps, "saxpy(case 72)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[i], expected[i], dbleps, "daxpy(case 73)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[2*i], expected[2*i], flteps, "caxpy(case 74) real");
       gsl_test_rel(Y[2*i+1], expected[2*i+1], flteps, "caxpy(case 74) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[2*i], expected[2*i], dbleps, "zaxpy(case 75) real");
       gsl_test_rel(Y[2*i+1], expected[2*i+1], dbleps, "zaxpy(case 75) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], x_expected[i], flteps, "srot(case 558)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[i], y_expected[i], flteps, "srot(case 559)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], x_expected[i], flteps, "srot(case 560)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[i], y_expected[i], flteps, "srot(case 561)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], x_expected[i], flteps, "srot(case 562)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[i], y_expected[i], flteps, "srot(case 563)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], x_expected[i], flteps, "srot(case 564)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[i], y_expected[i], flteps, "srot(case 565)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], x_expected[i], dbleps, "drot(case 566)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[i], y_expected[i], dbleps, "drot(case 567)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], x_expected[i], dbleps, "drot(case 568)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[i], y_expected[i], dbleps, "drot(case 569)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], x_expected[i], dbleps, "drot(case 570)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[i], y_expected[i], dbleps, "drot(case 571)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], x_expected[i], dbleps, "drot(case 572)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[i], y_expected[i], dbleps, "drot(case 573)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], x_expected[i], flteps, "srot(case 574)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[i], y_expected[i], flteps, "srot(case 575)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], x_expected[i], flteps, "srot(case 576)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[i], y_expected[i], flteps, "srot(case 577)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], x_expected[i], flteps, "srot(case 578)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[i], y_expected[i], flteps, "srot(case 579)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], x_expected[i], flteps, "srot(case 580)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[i], y_expected[i], flteps, "srot(case 581)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], x_expected[i], dbleps, "drot(case 582)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[i], y_expected[i], dbleps, "drot(case 583)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], x_expected[i], dbleps, "drot(case 584)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[i], y_expected[i], dbleps, "drot(case 585)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], x_expected[i], dbleps, "drot(case 586)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[i], y_expected[i], dbleps, "drot(case 587)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], x_expected[i], dbleps, "drot(case 588)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[i], y_expected[i], dbleps, "drot(case 589)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], x_expected[i], flteps, "srot(case 590)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[i], y_expected[i], flteps, "srot(case 591)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], x_expected[i], flteps, "srot(case 592)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[i], y_expected[i], flteps, "srot(case 593)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], x_expected[i], flteps, "srot(case 594)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[i], y_expected[i], flteps, "srot(case 595)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], x_expected[i], flteps, "srot(case 596)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[i], y_expected[i], flteps, "srot(case 597)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], x_expected[i], dbleps, "drot(case 598)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[i], y_expected[i], dbleps, "drot(case 599)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], x_expected[i], dbleps, "drot(case 600)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[i], y_expected[i], dbleps, "drot(case 601)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], x_expected[i], dbleps, "drot(case 602)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[i], y_expected[i], dbleps, "drot(case 603)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], x_expected[i], dbleps, "drot(case 604)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[i], y_expected[i], dbleps, "drot(case 605)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(C[2*i], C_expected[2*i], flteps, "chemm(case 1550) real");
       gsl_test_rel(C[2*i+1], C_expected[2*i+1], flteps, "chemm(case 1550) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(C[2*i], C_expected[2*i], flteps, "chemm(case 1551) real");
       gsl_test_rel(C[2*i+1], C_expected[2*i+1], flteps, "chemm(case 1551) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(C[2*i], C_expected[2*i], flteps, "chemm(case 1552) real");
       gsl_test_rel(C[2*i+1], C_expected[2*i+1], flteps, "chemm(case 1552) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(C[2*i], C_expected[2*i], flteps, "chemm(case 1553) real");
       gsl_test_rel(C[2*i+1], C_expected[2*i+1], flteps, "chemm(case 1553) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(C[2*i], C_expected[2*i], flteps, "chemm(case 1554) real");
       gsl_test_rel(C[2*i+1], C_expected[2*i+1], flteps, "chemm(case 1554) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(C[2*i], C_expected[2*i], flteps, "chemm(case 1555) real");
       gsl_test_rel(C[2*i+1], C_expected[2*i+1], flteps, "chemm(case 1555) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(C[2*i], C_expected[2*i], flteps, "chemm(case 1556) real");
       gsl_test_rel(C[2*i+1], C_expected[2*i+1], flteps, "chemm(case 1556) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(C[2*i], C_expected[2*i], flteps, "chemm(case 1557) real");
       gsl_test_rel(C[2*i+1], C_expected[2*i+1], flteps, "chemm(case 1557) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(C[2*i], C_expected[2*i], dbleps, "zhemm(case 1558) real");
       gsl_test_rel(C[2*i+1], C_expected[2*i+1], dbleps, "zhemm(case 1558) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(C[2*i], C_expected[2*i], dbleps, "zhemm(case 1559) real");
       gsl_test_rel(C[2*i+1], C_expected[2*i+1], dbleps, "zhemm(case 1559) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(C[2*i], C_expected[2*i], dbleps, "zhemm(case 1560) real");
       gsl_test_rel(C[2*i+1], C_expected[2*i+1], dbleps, "zhemm(case 1560) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(C[2*i], C_expected[2*i], dbleps, "zhemm(case 1561) real");
       gsl_test_rel(C[2*i+1], C_expected[2*i+1], dbleps, "zhemm(case 1561) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(C[2*i], C_expected[2*i], dbleps, "zhemm(case 1562) real");
       gsl_test_rel(C[2*i+1], C_expected[2*i+1], dbleps, "zhemm(case 1562) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(C[2*i], C_expected[2*i], dbleps, "zhemm(case 1563) real");
       gsl_test_rel(C[2*i+1], C_expected[2*i+1], dbleps, "zhemm(case 1563) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(C[2*i], C_expected[2*i], dbleps, "zhemm(case 1564) real");
       gsl_test_rel(C[2*i+1], C_expected[2*i+1], dbleps, "zhemm(case 1564) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(C[2*i], C_expected[2*i], dbleps, "zhemm(case 1565) real");
       gsl_test_rel(C[2*i+1], C_expected[2*i+1], dbleps, "zhemm(case 1565) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(C[i], C_expected[i], flteps, "sgemm(case 1466)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(C[i], C_expected[i], flteps, "sgemm(case 1467)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(C[i], C_expected[i], flteps, "sgemm(case 1468)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(C[i], C_expected[i], flteps, "sgemm(case 1469)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(C[i], C_expected[i], flteps, "sgemm(case 1470)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(C[i], C_expected[i], flteps, "sgemm(case 1471)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(C[i], C_expected[i], flteps, "sgemm(case 1472)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(C[i], C_expected[i], flteps, "sgemm(case 1473)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(C[i], C_expected[i], dbleps, "dgemm(case 1474)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(C[i], C_expected[i], dbleps, "dgemm(case 1475)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(C[i], C_expected[i], dbleps, "dgemm(case 1476)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(C[i], C_expected[i], dbleps, "dgemm(case 1477)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(C[i], C_expected[i], dbleps, "dgemm(case 1478)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(C[i], C_expected[i], dbleps, "dgemm(case 1479)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(C[i], C_expected[i], dbleps, "dgemm(case 1480)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(C[i], C_expected[i], dbleps, "dgemm(case 1481)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(C[2*i], C_expected[2*i], flteps, "cgemm(case 1482) real");
       gsl_test_rel(C[2*i+1], C_expected[2*i+1], flteps, "cgemm(case 1482) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(C[2*i], C_expected[2*i], flteps, "cgemm(case 1483) real");
       gsl_test_rel(C[2*i+1], C_expected[2*i+1], flteps, "cgemm(case 1483) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(C[2*i], C_expected[2*i], flteps, "cgemm(case 1484) real");
       gsl_test_rel(C[2*i+1], C_expected[2*i+1], flteps, "cgemm(case 1484) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(C[2*i], C_expected[2*i], flteps, "cgemm(case 1485) real");
       gsl_test_rel(C[2*i+1], C_expected[2*i+1], flteps, "cgemm(case 1485) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(C[2*i], C_expected[2*i], flteps, "cgemm(case 1486) real");
       gsl_test_rel(C[2*i+1], C_expected[2*i+1], flteps, "cgemm(case 1486) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(C[2*i], C_expected[2*i], flteps, "cgemm(case 1487) real");
       gsl_test_rel(C[2*i+1], C_expected[2*i+1], flteps, "cgemm(case 1487) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(C[2*i], C_expected[2*i], flteps, "cgemm(case 1488) real");
       gsl_test_rel(C[2*i+1], C_expected[2*i+1], flteps, "cgemm(case 1488) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(C[2*i], C_expected[2*i], flteps, "cgemm(case 1489) real");
       gsl_test_rel(C[2*i+1], C_expected[2*i+1], flteps, "cgemm(case 1489) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(C[2*i], C_expected[2*i], flteps, "cgemm(case 1490) real");
       gsl_test_rel(C[2*i+1], C_expected[2*i+1], flteps, "cgemm(case 1490) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(C[2*i], C_expected[2*i], flteps, "cgemm(case 1491) real");
       gsl_test_rel(C[2*i+1], C_expected[2*i+1], flteps, "cgemm(case 1491) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(C[2*i], C_expected[2*i], flteps, "cgemm(case 1492) real");
       gsl_test_rel(C[2*i+1], C_expected[2*i+1], flteps, "cgemm(case 1492) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(C[2*i], C_expected[2*i], flteps, "cgemm(case 1493) real");
       gsl_test_rel(C[2*i+1], C_expected[2*i+1], flteps, "cgemm(case 1493) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(C[2*i], C_expected[2*i], flteps, "cgemm(case 1494) real");
       gsl_test_rel(C[2*i+1], C_expected[2*i+1], flteps, "cgemm(case 1494) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(C[2*i], C_expected[2*i], flteps, "cgemm(case 1495) real");
       gsl_test_rel(C[2*i+1], C_expected[2*i+1], flteps, "cgemm(case 1495) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(C[2*i], C_expected[2*i], flteps, "cgemm(case 1496) real");
       gsl_test_rel(C[2*i+1], C_expected[2*i+1], flteps, "cgemm(case 1496) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(C[2*i], C_expected[2*i], flteps, "cgemm(case 1497) real");
       gsl_test_rel(C[2*i+1], C_expected[2*i+1], flteps, "cgemm(case 1497) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(C[2*i], C_expected[2*i], flteps, "cgemm(case 1498) real");
       gsl_test_rel(C[2*i+1], C_expected[2*i+1], flteps, "cgemm(case 1498) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(C[2*i], C_expected[2*i], flteps, "cgemm(case 1499) real");
       gsl_test_rel(C[2*i+1], C_expected[2*i+1], flteps, "cgemm(case 1499) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(C[2*i], C_expected[2*i], dbleps, "zgemm(case 1500) real");
       gsl_test_rel(C[2*i+1], C_expected[2*i+1], dbleps, "zgemm(case 1500) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(C[2*i], C_expected[2*i], dbleps, "zgemm(case 1501) real");
       gsl_test_rel(C[2*i+1], C_expected[2*i+1], dbleps, "zgemm(case 1501) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(C[2*i], C_expected[2*i], dbleps, "zgemm(case 1502) real");
       gsl_test_rel(C[2*i+1], C_expected[2*i+1], dbleps, "zgemm(case 1502) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(C[2*i], C_expected[2*i], dbleps, "zgemm(case 1503) real");
       gsl_test_rel(C[2*i+1], C_expected[2*i+1], dbleps, "zgemm(case 1503) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(C[2*i], C_expected[2*i], dbleps, "zgemm(case 1504) real");
       gsl_test_rel(C[2*i+1], C_expected[2*i+1], dbleps, "zgemm(case 1504) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(C[2*i], C_expected[2*i], dbleps, "zgemm(case 1505) real");
       gsl_test_rel(C[2*i+1], C_expected[2*i+1], dbleps, "zgemm(case 1505) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(C[2*i], C_expected[2*i], dbleps, "zgemm(case 1506) real");
       gsl_test_rel(C[2*i+1], C_expected[2*i+1], dbleps, "zgemm(case 1506) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(C[2*i], C_expected[2*i], dbleps, "zgemm(case 1507) real");
       gsl_test_rel(C[2*i+1], C_expected[2*i+1], dbleps, "zgemm(case 1507) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(C[2*i], C_expected[2*i], dbleps, "zgemm(case 1508) real");
       gsl_test_rel(C[2*i+1], C_expected[2*i+1], dbleps, "zgemm(case 1508) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(C[2*i], C_expected[2*i], dbleps, "zgemm(case 1509) real");
       gsl_test_rel(C[2*i+1], C_expected[2*i+1], dbleps, "zgemm(case 1509) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(C[2*i], C_expected[2*i], dbleps, "zgemm(case 1510) real");
       gsl_test_rel(C[2*i+1], C_expected[2*i+1], dbleps, "zgemm(case 1510) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(C[2*i], C_expected[2*i], dbleps, "zgemm(case 1511) real");
       gsl_test_rel(C[2*i+1], C_expected[2*i+1], dbleps, "zgemm(case 1511) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(C[2*i], C_expected[2*i], dbleps, "zgemm(case 1512) real");
       gsl_test_rel(C[2*i+1], C_expected[2*i+1], dbleps, "zgemm(case 1512) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(C[2*i], C_expected[2*i], dbleps, "zgemm(case 1513) real");
       gsl_test_rel(C[2*i+1], C_expected[2*i+1], dbleps, "zgemm(case 1513) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(C[2*i], C_expected[2*i], dbleps, "zgemm(case 1514) real");
       gsl_test_rel(C[2*i+1], C_expected[2*i+1], dbleps, "zgemm(case 1514) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(C[2*i], C_expected[2*i], dbleps, "zgemm(case 1515) real");
       gsl_test_rel(C[2*i+1], C_expected[2*i+1], dbleps, "zgemm(case 1515) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(C[2*i], C_expected[2*i], dbleps, "zgemm(case 1516) real");
       gsl_test_rel(C[2*i+1], C_expected[2*i+1], dbleps, "zgemm(case 1516) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(C[2*i], C_expected[2*i], dbleps, "zgemm(case 1517) real");
       gsl_test_rel(C[2*i+1], C_expected[2*i+1], dbleps, "zgemm(case 1517) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(A[2*i], A_expected[2*i], flteps, "cher2(case 1450) real");
       gsl_test_rel(A[2*i+1], A_expected[2*i+1], flteps, "cher2(case 1450) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(A[2*i], A_expected[2*i], flteps, "cher2(case 1451) real");
       gsl_test_rel(A[2*i+1], A_expected[2*i+1], flteps, "cher2(case 1451) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(A[2*i], A_expected[2*i], flteps, "cher2(case 1452) real");
       gsl_test_rel(A[2*i+1], A_expected[2*i+1], flteps, "cher2(case 1452) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(A[2*i], A_expected[2*i], flteps, "cher2(case 1453) real");
       gsl_test_rel(A[2*i+1], A_expected[2*i+1], flteps, "cher2(case 1453) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(A[2*i], A_expected[2*i], dbleps, "zher2(case 1454) real");
       gsl_test_rel(A[2*i+1], A_expected[2*i+1], dbleps, "zher2(case 1454) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(A[2*i], A_expected[2*i], dbleps, "zher2(case 1455) real");
       gsl_test_rel(A[2*i+1], A_expected[2*i+1], dbleps, "zher2(case 1455) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(A[2*i], A_expected[2*i], dbleps, "zher2(case 1456) real");
       gsl_test_rel(A[2*i+1], A_expected[2*i+1], dbleps, "zher2(case 1456) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(A[2*i], A_expected[2*i], dbleps, "zher2(case 1457) real");
       gsl_test_rel(A[2*i+1], A_expected[2*i+1], dbleps, "zher2(case 1457) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(Y[i], y_expected[i], flteps, "sspmv(case 1134)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(Y[i], y_expected[i], flteps, "sspmv(case 1135)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(Y[i], y_expected[i], flteps, "sspmv(case 1136)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(Y[i], y_expected[i], flteps, "sspmv(case 1137)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(Y[i], y_expected[i], flteps, "sspmv(case 1138)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(Y[i], y_expected[i], flteps, "sspmv(case 1139)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(Y[i], y_expected[i], flteps, "sspmv(case 1140)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(Y[i], y_expected[i], flteps, "sspmv(case 1141)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(Y[i], y_expected[i], dbleps, "dspmv(case 1142)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(Y[i], y_expected[i], dbleps, "dspmv(case 1143)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(Y[i], y_expected[i], dbleps, "dspmv(case 1144)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(Y[i], y_expected[i], dbleps, "dspmv(case 1145)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(Y[i], y_expected[i], dbleps, "dspmv(case 1146)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(Y[i], y_expected[i], dbleps, "dspmv(case 1147)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(Y[i], y_expected[i], dbleps, "dspmv(case 1148)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(Y[i], y_expected[i], dbleps, "dspmv(case 1149)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(A[i], A_expected[i], flteps, "ssyr2(case 1434)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(A[i], A_expected[i], flteps, "ssyr2(case 1435)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(A[i], A_expected[i], flteps, "ssyr2(case 1436)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(A[i], A_expected[i], flteps, "ssyr2(case 1437)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(A[i], A_expected[i], dbleps, "dsyr2(case 1438)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(A[i], A_expected[i], dbleps, "dsyr2(case 1439)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(A[i], A_expected[i], dbleps, "dsyr2(case 1440)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(A[i], A_expected[i], dbleps, "dsyr2(case 1441)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[i], B_expected[i], flteps, "strmm(case 1662)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[i], B_expected[i], flteps, "strmm(case 1663)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[i], B_expected[i], flteps, "strmm(case 1664)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[i], B_expected[i], flteps, "strmm(case 1665)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[i], B_expected[i], flteps, "strmm(case 1666)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[i], B_expected[i], flteps, "strmm(case 1667)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[i], B_expected[i], flteps, "strmm(case 1668)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[i], B_expected[i], flteps, "strmm(case 1669)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[i], B_expected[i], flteps, "strmm(case 1670)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[i], B_expected[i], flteps, "strmm(case 1671)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[i], B_expected[i], flteps, "strmm(case 1672)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[i], B_expected[i], flteps, "strmm(case 1673)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[i], B_expected[i], flteps, "strmm(case 1674)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[i], B_expected[i], flteps, "strmm(case 1675)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[i], B_expected[i], flteps, "strmm(case 1676)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[i], B_expected[i], flteps, "strmm(case 1677)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[i], B_expected[i], flteps, "strmm(case 1678)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[i], B_expected[i], flteps, "strmm(case 1679)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[i], B_expected[i], flteps, "strmm(case 1680)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[i], B_expected[i], flteps, "strmm(case 1681)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[i], B_expected[i], flteps, "strmm(case 1682)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[i], B_expected[i], flteps, "strmm(case 1683)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[i], B_expected[i], flteps, "strmm(case 1684)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[i], B_expected[i], flteps, "strmm(case 1685)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[i], B_expected[i], flteps, "strmm(case 1686)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[i], B_expected[i], flteps, "strmm(case 1687)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[i], B_expected[i], flteps, "strmm(case 1688)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[i], B_expected[i], flteps, "strmm(case 1689)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[i], B_expected[i], flteps, "strmm(case 1690)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[i], B_expected[i], flteps, "strmm(case 1691)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[i], B_expected[i], flteps, "strmm(case 1692)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[i], B_expected[i], flteps, "strmm(case 1693)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[i], B_expected[i], dbleps, "dtrmm(case 1694)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[i], B_expected[i], dbleps, "dtrmm(case 1695)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[i], B_expected[i], dbleps, "dtrmm(case 1696)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[i], B_expected[i], dbleps, "dtrmm(case 1697)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[i], B_expected[i], dbleps, "dtrmm(case 1698)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[i], B_expected[i], dbleps, "dtrmm(case 1699)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[i], B_expected[i], dbleps, "dtrmm(case 1700)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[i], B_expected[i], dbleps, "dtrmm(case 1701)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[i], B_expected[i], dbleps, "dtrmm(case 1702)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[i], B_expected[i], dbleps, "dtrmm(case 1703)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[i], B_expected[i], dbleps, "dtrmm(case 1704)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[i], B_expected[i], dbleps, "dtrmm(case 1705)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[i], B_expected[i], dbleps, "dtrmm(case 1706)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[i], B_expected[i], dbleps, "dtrmm(case 1707)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[i], B_expected[i], dbleps, "dtrmm(case 1708)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[i], B_expected[i], dbleps, "dtrmm(case 1709)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[i], B_expected[i], dbleps, "dtrmm(case 1710)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[i], B_expected[i], dbleps, "dtrmm(case 1711)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[i], B_expected[i], dbleps, "dtrmm(case 1712)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[i], B_expected[i], dbleps, "dtrmm(case 1713)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[i], B_expected[i], dbleps, "dtrmm(case 1714)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[i], B_expected[i], dbleps, "dtrmm(case 1715)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[i], B_expected[i], dbleps, "dtrmm(case 1716)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[i], B_expected[i], dbleps, "dtrmm(case 1717)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[i], B_expected[i], dbleps, "dtrmm(case 1718)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[i], B_expected[i], dbleps, "dtrmm(case 1719)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[i], B_expected[i], dbleps, "dtrmm(case 1720)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[i], B_expected[i], dbleps, "dtrmm(case 1721)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[i], B_expected[i], dbleps, "dtrmm(case 1722)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[i], B_expected[i], dbleps, "dtrmm(case 1723)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[i], B_expected[i], dbleps, "dtrmm(case 1724)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[i], B_expected[i], dbleps, "dtrmm(case 1725)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], flteps, "ctrmm(case 1726) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], flteps, "ctrmm(case 1726) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], flteps, "ctrmm(case 1727) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], flteps, "ctrmm(case 1727) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], flteps, "ctrmm(case 1728) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], flteps, "ctrmm(case 1728) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], flteps, "ctrmm(case 1729) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], flteps, "ctrmm(case 1729) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], flteps, "ctrmm(case 1730) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], flteps, "ctrmm(case 1730) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], flteps, "ctrmm(case 1731) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], flteps, "ctrmm(case 1731) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], flteps, "ctrmm(case 1732) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], flteps, "ctrmm(case 1732) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], flteps, "ctrmm(case 1733) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], flteps, "ctrmm(case 1733) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], flteps, "ctrmm(case 1734) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], flteps, "ctrmm(case 1734) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], flteps, "ctrmm(case 1735) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], flteps, "ctrmm(case 1735) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], flteps, "ctrmm(case 1736) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], flteps, "ctrmm(case 1736) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], flteps, "ctrmm(case 1737) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], flteps, "ctrmm(case 1737) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], flteps, "ctrmm(case 1738) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], flteps, "ctrmm(case 1738) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], flteps, "ctrmm(case 1739) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], flteps, "ctrmm(case 1739) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], flteps, "ctrmm(case 1740) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], flteps, "ctrmm(case 1740) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], flteps, "ctrmm(case 1741) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], flteps, "ctrmm(case 1741) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], flteps, "ctrmm(case 1742) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], flteps, "ctrmm(case 1742) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], flteps, "ctrmm(case 1743) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], flteps, "ctrmm(case 1743) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], flteps, "ctrmm(case 1744) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], flteps, "ctrmm(case 1744) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], flteps, "ctrmm(case 1745) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], flteps, "ctrmm(case 1745) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], flteps, "ctrmm(case 1746) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], flteps, "ctrmm(case 1746) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], flteps, "ctrmm(case 1747) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], flteps, "ctrmm(case 1747) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], flteps, "ctrmm(case 1748) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], flteps, "ctrmm(case 1748) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], flteps, "ctrmm(case 1749) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], flteps, "ctrmm(case 1749) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], flteps, "ctrmm(case 1750) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], flteps, "ctrmm(case 1750) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], flteps, "ctrmm(case 1751) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], flteps, "ctrmm(case 1751) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], flteps, "ctrmm(case 1752) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], flteps, "ctrmm(case 1752) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], flteps, "ctrmm(case 1753) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], flteps, "ctrmm(case 1753) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], flteps, "ctrmm(case 1754) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], flteps, "ctrmm(case 1754) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], flteps, "ctrmm(case 1755) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], flteps, "ctrmm(case 1755) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], flteps, "ctrmm(case 1756) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], flteps, "ctrmm(case 1756) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], flteps, "ctrmm(case 1757) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], flteps, "ctrmm(case 1757) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], flteps, "ctrmm(case 1758) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], flteps, "ctrmm(case 1758) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], flteps, "ctrmm(case 1759) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], flteps, "ctrmm(case 1759) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], flteps, "ctrmm(case 1760) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], flteps, "ctrmm(case 1760) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], flteps, "ctrmm(case 1761) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], flteps, "ctrmm(case 1761) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], flteps, "ctrmm(case 1762) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], flteps, "ctrmm(case 1762) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], flteps, "ctrmm(case 1763) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], flteps, "ctrmm(case 1763) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], flteps, "ctrmm(case 1764) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], flteps, "ctrmm(case 1764) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], flteps, "ctrmm(case 1765) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], flteps, "ctrmm(case 1765) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], flteps, "ctrmm(case 1766) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], flteps, "ctrmm(case 1766) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], flteps, "ctrmm(case 1767) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], flteps, "ctrmm(case 1767) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], flteps, "ctrmm(case 1768) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], flteps, "ctrmm(case 1768) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], flteps, "ctrmm(case 1769) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], flteps, "ctrmm(case 1769) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], flteps, "ctrmm(case 1770) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], flteps, "ctrmm(case 1770) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], flteps, "ctrmm(case 1771) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], flteps, "ctrmm(case 1771) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], flteps, "ctrmm(case 1772) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], flteps, "ctrmm(case 1772) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], flteps, "ctrmm(case 1773) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], flteps, "ctrmm(case 1773) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], dbleps, "ztrmm(case 1774) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], dbleps, "ztrmm(case 1774) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], dbleps, "ztrmm(case 1775) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], dbleps, "ztrmm(case 1775) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], dbleps, "ztrmm(case 1776) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], dbleps, "ztrmm(case 1776) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], dbleps, "ztrmm(case 1777) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], dbleps, "ztrmm(case 1777) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], dbleps, "ztrmm(case 1778) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], dbleps, "ztrmm(case 1778) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], dbleps, "ztrmm(case 1779) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], dbleps, "ztrmm(case 1779) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], dbleps, "ztrmm(case 1780) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], dbleps, "ztrmm(case 1780) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], dbleps, "ztrmm(case 1781) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], dbleps, "ztrmm(case 1781) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], dbleps, "ztrmm(case 1782) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], dbleps, "ztrmm(case 1782) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], dbleps, "ztrmm(case 1783) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], dbleps, "ztrmm(case 1783) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], dbleps, "ztrmm(case 1784) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], dbleps, "ztrmm(case 1784) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], dbleps, "ztrmm(case 1785) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], dbleps, "ztrmm(case 1785) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], dbleps, "ztrmm(case 1786) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], dbleps, "ztrmm(case 1786) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], dbleps, "ztrmm(case 1787) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], dbleps, "ztrmm(case 1787) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], dbleps, "ztrmm(case 1788) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], dbleps, "ztrmm(case 1788) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], dbleps, "ztrmm(case 1789) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], dbleps, "ztrmm(case 1789) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], dbleps, "ztrmm(case 1790) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], dbleps, "ztrmm(case 1790) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], dbleps, "ztrmm(case 1791) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], dbleps, "ztrmm(case 1791) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], dbleps, "ztrmm(case 1792) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], dbleps, "ztrmm(case 1792) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], dbleps, "ztrmm(case 1793) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], dbleps, "ztrmm(case 1793) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], dbleps, "ztrmm(case 1794) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], dbleps, "ztrmm(case 1794) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], dbleps, "ztrmm(case 1795) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], dbleps, "ztrmm(case 1795) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], dbleps, "ztrmm(case 1796) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], dbleps, "ztrmm(case 1796) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], dbleps, "ztrmm(case 1797) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], dbleps, "ztrmm(case 1797) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], dbleps, "ztrmm(case 1798) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], dbleps, "ztrmm(case 1798) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], dbleps, "ztrmm(case 1799) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], dbleps, "ztrmm(case 1799) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], dbleps, "ztrmm(case 1800) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], dbleps, "ztrmm(case 1800) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], dbleps, "ztrmm(case 1801) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], dbleps, "ztrmm(case 1801) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], dbleps, "ztrmm(case 1802) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], dbleps, "ztrmm(case 1802) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], dbleps, "ztrmm(case 1803) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], dbleps, "ztrmm(case 1803) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], dbleps, "ztrmm(case 1804) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], dbleps, "ztrmm(case 1804) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], dbleps, "ztrmm(case 1805) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], dbleps, "ztrmm(case 1805) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], dbleps, "ztrmm(case 1806) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], dbleps, "ztrmm(case 1806) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], dbleps, "ztrmm(case 1807) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], dbleps, "ztrmm(case 1807) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], dbleps, "ztrmm(case 1808) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], dbleps, "ztrmm(case 1808) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], dbleps, "ztrmm(case 1809) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], dbleps, "ztrmm(case 1809) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], dbleps, "ztrmm(case 1810) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], dbleps, "ztrmm(case 1810) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], dbleps, "ztrmm(case 1811) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], dbleps, "ztrmm(case 1811) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], dbleps, "ztrmm(case 1812) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], dbleps, "ztrmm(case 1812) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], dbleps, "ztrmm(case 1813) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], dbleps, "ztrmm(case 1813) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], dbleps, "ztrmm(case 1814) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], dbleps, "ztrmm(case 1814) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], dbleps, "ztrmm(case 1815) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], dbleps, "ztrmm(case 1815) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], dbleps, "ztrmm(case 1816) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], dbleps, "ztrmm(case 1816) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], dbleps, "ztrmm(case 1817) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], dbleps, "ztrmm(case 1817) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], dbleps, "ztrmm(case 1818) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], dbleps, "ztrmm(case 1818) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], dbleps, "ztrmm(case 1819) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], dbleps, "ztrmm(case 1819) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], dbleps, "ztrmm(case 1820) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], dbleps, "ztrmm(case 1820) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], dbleps, "ztrmm(case 1821) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], dbleps, "ztrmm(case 1821) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[i], x_expected[i], flteps, "stpsv(case 1310)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[i], x_expected[i], flteps, "stpsv(case 1311)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[i], x_expected[i], flteps, "stpsv(case 1312)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[i], x_expected[i], flteps, "stpsv(case 1313)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[i], x_expected[i], flteps, "stpsv(case 1314)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[i], x_expected[i], flteps, "stpsv(case 1315)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[i], x_expected[i], flteps, "stpsv(case 1316)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[i], x_expected[i], flteps, "stpsv(case 1317)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[i], x_expected[i], flteps, "stpsv(case 1318)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[i], x_expected[i], flteps, "stpsv(case 1319)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[i], x_expected[i], flteps, "stpsv(case 1320)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[i], x_expected[i], flteps, "stpsv(case 1321)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[i], x_expected[i], flteps, "stpsv(case 1322)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[i], x_expected[i], flteps, "stpsv(case 1323)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[i], x_expected[i], flteps, "stpsv(case 1324)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[i], x_expected[i], flteps, "stpsv(case 1325)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[i], x_expected[i], dbleps, "dtpsv(case 1326)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[i], x_expected[i], dbleps, "dtpsv(case 1327)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[i], x_expected[i], dbleps, "dtpsv(case 1328)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[i], x_expected[i], dbleps, "dtpsv(case 1329)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[i], x_expected[i], dbleps, "dtpsv(case 1330)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[i], x_expected[i], dbleps, "dtpsv(case 1331)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[i], x_expected[i], dbleps, "dtpsv(case 1332)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[i], x_expected[i], dbleps, "dtpsv(case 1333)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[i], x_expected[i], dbleps, "dtpsv(case 1334)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[i], x_expected[i], dbleps, "dtpsv(case 1335)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[i], x_expected[i], dbleps, "dtpsv(case 1336)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[i], x_expected[i], dbleps, "dtpsv(case 1337)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[i], x_expected[i], dbleps, "dtpsv(case 1338)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[i], x_expected[i], dbleps, "dtpsv(case 1339)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[i], x_expected[i], dbleps, "dtpsv(case 1340)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[i], x_expected[i], dbleps, "dtpsv(case 1341)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], flteps, "ctpsv(case 1342) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], flteps, "ctpsv(case 1342) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], flteps, "ctpsv(case 1343) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], flteps, "ctpsv(case 1343) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], flteps, "ctpsv(case 1344) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], flteps, "ctpsv(case 1344) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], flteps, "ctpsv(case 1345) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], flteps, "ctpsv(case 1345) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], flteps, "ctpsv(case 1346) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], flteps, "ctpsv(case 1346) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], flteps, "ctpsv(case 1347) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], flteps, "ctpsv(case 1347) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], flteps, "ctpsv(case 1348) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], flteps, "ctpsv(case 1348) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], flteps, "ctpsv(case 1349) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], flteps, "ctpsv(case 1349) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], flteps, "ctpsv(case 1350) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], flteps, "ctpsv(case 1350) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], flteps, "ctpsv(case 1351) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], flteps, "ctpsv(case 1351) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], flteps, "ctpsv(case 1352) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], flteps, "ctpsv(case 1352) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], flteps, "ctpsv(case 1353) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], flteps, "ctpsv(case 1353) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], flteps, "ctpsv(case 1354) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], flteps, "ctpsv(case 1354) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], flteps, "ctpsv(case 1355) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], flteps, "ctpsv(case 1355) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], flteps, "ctpsv(case 1356) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], flteps, "ctpsv(case 1356) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], flteps, "ctpsv(case 1357) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], flteps, "ctpsv(case 1357) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], flteps, "ctpsv(case 1358) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], flteps, "ctpsv(case 1358) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], flteps, "ctpsv(case 1359) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], flteps, "ctpsv(case 1359) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], flteps, "ctpsv(case 1360) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], flteps, "ctpsv(case 1360) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], flteps, "ctpsv(case 1361) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], flteps, "ctpsv(case 1361) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], flteps, "ctpsv(case 1362) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], flteps, "ctpsv(case 1362) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], flteps, "ctpsv(case 1363) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], flteps, "ctpsv(case 1363) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], flteps, "ctpsv(case 1364) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], flteps, "ctpsv(case 1364) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], flteps, "ctpsv(case 1365) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], flteps, "ctpsv(case 1365) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], dbleps, "ztpsv(case 1366) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], dbleps, "ztpsv(case 1366) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], dbleps, "ztpsv(case 1367) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], dbleps, "ztpsv(case 1367) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], dbleps, "ztpsv(case 1368) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], dbleps, "ztpsv(case 1368) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], dbleps, "ztpsv(case 1369) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], dbleps, "ztpsv(case 1369) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], dbleps, "ztpsv(case 1370) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], dbleps, "ztpsv(case 1370) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], dbleps, "ztpsv(case 1371) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], dbleps, "ztpsv(case 1371) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], dbleps, "ztpsv(case 1372) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], dbleps, "ztpsv(case 1372) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], dbleps, "ztpsv(case 1373) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], dbleps, "ztpsv(case 1373) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], dbleps, "ztpsv(case 1374) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], dbleps, "ztpsv(case 1374) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], dbleps, "ztpsv(case 1375) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], dbleps, "ztpsv(case 1375) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], dbleps, "ztpsv(case 1376) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], dbleps, "ztpsv(case 1376) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], dbleps, "ztpsv(case 1377) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], dbleps, "ztpsv(case 1377) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], dbleps, "ztpsv(case 1378) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], dbleps, "ztpsv(case 1378) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], dbleps, "ztpsv(case 1379) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], dbleps, "ztpsv(case 1379) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], dbleps, "ztpsv(case 1380) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], dbleps, "ztpsv(case 1380) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], dbleps, "ztpsv(case 1381) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], dbleps, "ztpsv(case 1381) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], dbleps, "ztpsv(case 1382) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], dbleps, "ztpsv(case 1382) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], dbleps, "ztpsv(case 1383) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], dbleps, "ztpsv(case 1383) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], dbleps, "ztpsv(case 1384) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], dbleps, "ztpsv(case 1384) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], dbleps, "ztpsv(case 1385) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], dbleps, "ztpsv(case 1385) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], dbleps, "ztpsv(case 1386) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], dbleps, "ztpsv(case 1386) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], dbleps, "ztpsv(case 1387) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], dbleps, "ztpsv(case 1387) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], dbleps, "ztpsv(case 1388) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], dbleps, "ztpsv(case 1388) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], dbleps, "ztpsv(case 1389) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], dbleps, "ztpsv(case 1389) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(A[i], A_expected[i], flteps, "sger(case 1390)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(A[i], A_expected[i], flteps, "sger(case 1391)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(A[i], A_expected[i], dbleps, "dger(case 1392)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(A[i], A_expected[i], dbleps, "dger(case 1393)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(A[2*i], A_expected[2*i], flteps, "cgeru(case 1394) real");
       gsl_test_rel(A[2*i+1], A_expected[2*i+1], flteps, "cgeru(case 1394) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(A[2*i], A_expected[2*i], flteps, "cgerc(case 1395) real");
       gsl_test_rel(A[2*i+1], A_expected[2*i+1], flteps, "cgerc(case 1395) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(A[2*i], A_expected[2*i], flteps, "cgeru(case 1396) real");
       gsl_test_rel(A[2*i+1], A_expected[2*i+1], flteps, "cgeru(case 1396) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(A[2*i], A_expected[2*i], flteps, "cgerc(case 1397) real");
       gsl_test_rel(A[2*i+1], A_expected[2*i+1], flteps, "cgerc(case 1397) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(A[2*i], A_expected[2*i], dbleps, "zgeru(case 1398) real");
       gsl_test_rel(A[2*i+1], A_expected[2*i+1], dbleps, "zgeru(case 1398) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(A[2*i], A_expected[2*i], dbleps, "zgerc(case 1399) real");
       gsl_test_rel(A[2*i+1], A_expected[2*i+1], dbleps, "zgerc(case 1399) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(A[2*i], A_expected[2*i], dbleps, "zgeru(case 1400) real");
       gsl_test_rel(A[2*i+1], A_expected[2*i+1], dbleps, "zgeru(case 1400) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(A[2*i], A_expected[2*i], dbleps, "zgerc(case 1401) real");
       gsl_test_rel(A[2*i+1], A_expected[2*i+1], dbleps, "zgerc(case 1401) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], expected[i], flteps, "sscal(case 112)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], expected[i], flteps, "sscal(case 113)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], expected[i], flteps, "sscal(case 114)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], expected[i], dbleps, "dscal(case 115)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], expected[i], dbleps, "dscal(case 116)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], expected[i], dbleps, "dscal(case 117)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[2*i], expected[2*i], flteps, "cscal(case 118) real");
       gsl_test_rel(X[2*i+1], expected[2*i+1], flteps, "cscal(case 118) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[2*i], expected[2*i], flteps, "cscal(case 119) real");
       gsl_test_rel(X[2*i+1], expected[2*i+1], flteps, "cscal(case 119) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[2*i], expected[2*i], flteps, "cscal(case 120) real");
       gsl_test_rel(X[2*i+1], expected[2*i+1], flteps, "cscal(case 120) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[2*i], expected[2*i], flteps, "cscal(case 121) real");
       gsl_test_rel(X[2*i+1], expected[2*i+1], flteps, "cscal(case 121) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[2*i], expected[2*i], flteps, "cscal(case 122) real");
       gsl_test_rel(X[2*i+1], expected[2*i+1], flteps, "cscal(case 122) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[2*i], expected[2*i], flteps, "cscal(case 123) real");
       gsl_test_rel(X[2*i+1], expected[2*i+1], flteps, "cscal(case 123) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[2*i], expected[2*i], dbleps, "zscal(case 124) real");
       gsl_test_rel(X[2*i+1], expected[2*i+1], dbleps, "zscal(case 124) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[2*i], expected[2*i], dbleps, "zscal(case 125) real");
       gsl_test_rel(X[2*i+1], expected[2*i+1], dbleps, "zscal(case 125) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[2*i], expected[2*i], dbleps, "zscal(case 126) real");
       gsl_test_rel(X[2*i+1], expected[2*i+1], dbleps, "zscal(case 126) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[2*i], expected[2*i], dbleps, "zscal(case 127) real");
       gsl_test_rel(X[2*i+1], expected[2*i+1], dbleps, "zscal(case 127) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[2*i], expected[2*i], dbleps, "zscal(case 128) real");
       gsl_test_rel(X[2*i+1], expected[2*i+1], dbleps, "zscal(case 128) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[2*i], expected[2*i], dbleps, "zscal(case 129) real");
       gsl_test_rel(X[2*i+1], expected[2*i+1], dbleps, "zscal(case 129) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[i], expected[i], flteps, "sscal(case 130)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[i], expected[i], flteps, "sscal(case 131)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[i], expected[i], flteps, "sscal(case 132)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[i], expected[i], dbleps, "dscal(case 133)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[i], expected[i], dbleps, "dscal(case 134)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[i], expected[i], dbleps, "dscal(case 135)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[2*i], expected[2*i], flteps, "cscal(case 136) real");
       gsl_test_rel(X[2*i+1], expected[2*i+1], flteps, "cscal(case 136) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[2*i], expected[2*i], flteps, "cscal(case 137) real");
       gsl_test_rel(X[2*i+1], expected[2*i+1], flteps, "cscal(case 137) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[2*i], expected[2*i], flteps, "cscal(case 138) real");
       gsl_test_rel(X[2*i+1], expected[2*i+1], flteps, "cscal(case 138) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[2*i], expected[2*i], flteps, "cscal(case 139) real");
       gsl_test_rel(X[2*i+1], expected[2*i+1], flteps, "cscal(case 139) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[2*i], expected[2*i], flteps, "cscal(case 140) real");
       gsl_test_rel(X[2*i+1], expected[2*i+1], flteps, "cscal(case 140) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[2*i], expected[2*i], flteps, "cscal(case 141) real");
       gsl_test_rel(X[2*i+1], expected[2*i+1], flteps, "cscal(case 141) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[2*i], expected[2*i], dbleps, "zscal(case 142) real");
       gsl_test_rel(X[2*i+1], expected[2*i+1], dbleps, "zscal(case 142) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[2*i], expected[2*i], dbleps, "zscal(case 143) real");
       gsl_test_rel(X[2*i+1], expected[2*i+1], dbleps, "zscal(case 143) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[2*i], expected[2*i], dbleps, "zscal(case 144) real");
       gsl_test_rel(X[2*i+1], expected[2*i+1], dbleps, "zscal(case 144) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[2*i], expected[2*i], dbleps, "zscal(case 145) real");
       gsl_test_rel(X[2*i+1], expected[2*i+1], dbleps, "zscal(case 145) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[2*i], expected[2*i], dbleps, "zscal(case 146) real");
       gsl_test_rel(X[2*i+1], expected[2*i+1], dbleps, "zscal(case 146) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[2*i], expected[2*i], dbleps, "zscal(case 147) real");
       gsl_test_rel(X[2*i+1], expected[2*i+1], dbleps, "zscal(case 147) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[i], expected[i], flteps, "sscal(case 148)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[i], expected[i], flteps, "sscal(case 149)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[i], expected[i], flteps, "sscal(case 150)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[i], expected[i], dbleps, "dscal(case 151)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[i], expected[i], dbleps, "dscal(case 152)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[i], expected[i], dbleps, "dscal(case 153)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[2*i], expected[2*i], flteps, "cscal(case 154) real");
       gsl_test_rel(X[2*i+1], expected[2*i+1], flteps, "cscal(case 154) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[2*i], expected[2*i], flteps, "cscal(case 155) real");
       gsl_test_rel(X[2*i+1], expected[2*i+1], flteps, "cscal(case 155) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[2*i], expected[2*i], flteps, "cscal(case 156) real");
       gsl_test_rel(X[2*i+1], expected[2*i+1], flteps, "cscal(case 156) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[2*i], expected[2*i], flteps, "cscal(case 157) real");
       gsl_test_rel(X[2*i+1], expected[2*i+1], flteps, "cscal(case 157) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[2*i], expected[2*i], flteps, "cscal(case 158) real");
       gsl_test_rel(X[2*i+1], expected[2*i+1], flteps, "cscal(case 158) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[2*i], expected[2*i], flteps, "cscal(case 159) real");
       gsl_test_rel(X[2*i+1], expected[2*i+1], flteps, "cscal(case 159) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[2*i], expected[2*i], dbleps, "zscal(case 160) real");
       gsl_test_rel(X[2*i+1], expected[2*i+1], dbleps, "zscal(case 160) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[2*i], expected[2*i], dbleps, "zscal(case 161) real");
       gsl_test_rel(X[2*i+1], expected[2*i+1], dbleps, "zscal(case 161) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[2*i], expected[2*i], dbleps, "zscal(case 162) real");
       gsl_test_rel(X[2*i+1], expected[2*i+1], dbleps, "zscal(case 162) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[2*i], expected[2*i], dbleps, "zscal(case 163) real");
       gsl_test_rel(X[2*i+1], expected[2*i+1], dbleps, "zscal(case 163) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[2*i], expected[2*i], dbleps, "zscal(case 164) real");
       gsl_test_rel(X[2*i+1], expected[2*i+1], dbleps, "zscal(case 164) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 2; i++) {
       gsl_test_rel(X[2*i], expected[2*i], dbleps, "zscal(case 165) real");
       gsl_test_rel(X[2*i+1], expected[2*i+1], dbleps, "zscal(case 165) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(Ap[2*i], Ap_expected[2*i], flteps, "chpr(case 1418) real");
       gsl_test_rel(Ap[2*i+1], Ap_expected[2*i+1], flteps, "chpr(case 1418) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(Ap[2*i], Ap_expected[2*i], flteps, "chpr(case 1419) real");
       gsl_test_rel(Ap[2*i+1], Ap_expected[2*i+1], flteps, "chpr(case 1419) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(Ap[2*i], Ap_expected[2*i], flteps, "chpr(case 1420) real");
       gsl_test_rel(Ap[2*i+1], Ap_expected[2*i+1], flteps, "chpr(case 1420) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(Ap[2*i], Ap_expected[2*i], flteps, "chpr(case 1421) real");
       gsl_test_rel(Ap[2*i+1], Ap_expected[2*i+1], flteps, "chpr(case 1421) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(Ap[2*i], Ap_expected[2*i], dbleps, "zhpr(case 1422) real");
       gsl_test_rel(Ap[2*i+1], Ap_expected[2*i+1], dbleps, "zhpr(case 1422) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(Ap[2*i], Ap_expected[2*i], dbleps, "zhpr(case 1423) real");
       gsl_test_rel(Ap[2*i+1], Ap_expected[2*i+1], dbleps, "zhpr(case 1423) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(Ap[2*i], Ap_expected[2*i], dbleps, "zhpr(case 1424) real");
       gsl_test_rel(Ap[2*i+1], Ap_expected[2*i+1], dbleps, "zhpr(case 1424) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++) {
       gsl_test_rel(Ap[2*i], Ap_expected[2*i], dbleps, "zhpr(case 1425) real");
       gsl_test_rel(Ap[2*i+1], Ap_expected[2*i+1], dbleps, "zhpr(case 1425) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[i], y_expected[i], flteps, "sgemv(case 774)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[i], y_expected[i], flteps, "sgemv(case 775)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[i], y_expected[i], flteps, "sgemv(case 776)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[i], y_expected[i], flteps, "sgemv(case 777)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[i], y_expected[i], dbleps, "dgemv(case 778)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[i], y_expected[i], dbleps, "dgemv(case 779)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[i], y_expected[i], dbleps, "dgemv(case 780)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[i], y_expected[i], dbleps, "dgemv(case 781)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[2*i], y_expected[2*i], flteps, "cgemv(case 782) real");
       gsl_test_rel(Y[2*i+1], y_expected[2*i+1], flteps, "cgemv(case 782) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[2*i], y_expected[2*i], flteps, "cgemv(case 783) real");
       gsl_test_rel(Y[2*i+1], y_expected[2*i+1], flteps, "cgemv(case 783) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[2*i], y_expected[2*i], flteps, "cgemv(case 784) real");
       gsl_test_rel(Y[2*i+1], y_expected[2*i+1], flteps, "cgemv(case 784) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[2*i], y_expected[2*i], flteps, "cgemv(case 785) real");
       gsl_test_rel(Y[2*i+1], y_expected[2*i+1], flteps, "cgemv(case 785) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[2*i], y_expected[2*i], flteps, "cgemv(case 786) real");
       gsl_test_rel(Y[2*i+1], y_expected[2*i+1], flteps, "cgemv(case 786) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[2*i], y_expected[2*i], flteps, "cgemv(case 787) real");
       gsl_test_rel(Y[2*i+1], y_expected[2*i+1], flteps, "cgemv(case 787) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[2*i], y_expected[2*i], dbleps, "zgemv(case 788) real");
       gsl_test_rel(Y[2*i+1], y_expected[2*i+1], dbleps, "zgemv(case 788) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[2*i], y_expected[2*i], dbleps, "zgemv(case 789) real");
       gsl_test_rel(Y[2*i+1], y_expected[2*i+1], dbleps, "zgemv(case 789) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[2*i], y_expected[2*i], dbleps, "zgemv(case 790) real");
       gsl_test_rel(Y[2*i+1], y_expected[2*i+1], dbleps, "zgemv(case 790) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[2*i], y_expected[2*i], dbleps, "zgemv(case 791) real");
       gsl_test_rel(Y[2*i+1], y_expected[2*i+1], dbleps, "zgemv(case 791) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[2*i], y_expected[2*i], dbleps, "zgemv(case 792) real");
       gsl_test_rel(Y[2*i+1], y_expected[2*i+1], dbleps, "zgemv(case 792) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[2*i], y_expected[2*i], dbleps, "zgemv(case 793) real");
       gsl_test_rel(Y[2*i+1], y_expected[2*i+1], dbleps, "zgemv(case 793) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], x_expected[i], flteps, "strmv(case 814)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], x_expected[i], flteps, "strmv(case 815)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], x_expected[i], flteps, "strmv(case 816)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], x_expected[i], flteps, "strmv(case 817)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], x_expected[i], flteps, "strmv(case 818)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], x_expected[i], flteps, "strmv(case 819)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], x_expected[i], flteps, "strmv(case 820)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], x_expected[i], flteps, "strmv(case 821)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], x_expected[i], flteps, "strmv(case 822)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], x_expected[i], flteps, "strmv(case 823)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], x_expected[i], flteps, "strmv(case 824)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], x_expected[i], flteps, "strmv(case 825)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], x_expected[i], flteps, "strmv(case 826)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], x_expected[i], flteps, "strmv(case 827)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], x_expected[i], flteps, "strmv(case 828)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], x_expected[i], flteps, "strmv(case 829)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], x_expected[i], dbleps, "dtrmv(case 830)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], x_expected[i], dbleps, "dtrmv(case 831)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], x_expected[i], dbleps, "dtrmv(case 832)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], x_expected[i], dbleps, "dtrmv(case 833)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], x_expected[i], dbleps, "dtrmv(case 834)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], x_expected[i], dbleps, "dtrmv(case 835)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], x_expected[i], dbleps, "dtrmv(case 836)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], x_expected[i], dbleps, "dtrmv(case 837)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], x_expected[i], dbleps, "dtrmv(case 838)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], x_expected[i], dbleps, "dtrmv(case 839)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], x_expected[i], dbleps, "dtrmv(case 840)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], x_expected[i], dbleps, "dtrmv(case 841)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], x_expected[i], dbleps, "dtrmv(case 842)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], x_expected[i], dbleps, "dtrmv(case 843)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], x_expected[i], dbleps, "dtrmv(case 844)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], x_expected[i], dbleps, "dtrmv(case 845)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], flteps, "ctrmv(case 846) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], flteps, "ctrmv(case 846) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], flteps, "ctrmv(case 847) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], flteps, "ctrmv(case 847) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], flteps, "ctrmv(case 848) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], flteps, "ctrmv(case 848) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], flteps, "ctrmv(case 849) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], flteps, "ctrmv(case 849) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], flteps, "ctrmv(case 850) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], flteps, "ctrmv(case 850) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], flteps, "ctrmv(case 851) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], flteps, "ctrmv(case 851) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], flteps, "ctrmv(case 852) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], flteps, "ctrmv(case 852) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], flteps, "ctrmv(case 853) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], flteps, "ctrmv(case 853) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], flteps, "ctrmv(case 854) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], flteps, "ctrmv(case 854) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], flteps, "ctrmv(case 855) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], flteps, "ctrmv(case 855) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], flteps, "ctrmv(case 856) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], flteps, "ctrmv(case 856) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], flteps, "ctrmv(case 857) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], flteps, "ctrmv(case 857) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], flteps, "ctrmv(case 858) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], flteps, "ctrmv(case 858) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], flteps, "ctrmv(case 859) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], flteps, "ctrmv(case 859) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], flteps, "ctrmv(case 860) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], flteps, "ctrmv(case 860) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], flteps, "ctrmv(case 861) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], flteps, "ctrmv(case 861) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], flteps, "ctrmv(case 862) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], flteps, "ctrmv(case 862) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], flteps, "ctrmv(case 863) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], flteps, "ctrmv(case 863) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], flteps, "ctrmv(case 864) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], flteps, "ctrmv(case 864) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], flteps, "ctrmv(case 865) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], flteps, "ctrmv(case 865) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], flteps, "ctrmv(case 866) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], flteps, "ctrmv(case 866) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], flteps, "ctrmv(case 867) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], flteps, "ctrmv(case 867) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], flteps, "ctrmv(case 868) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], flteps, "ctrmv(case 868) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], flteps, "ctrmv(case 869) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], flteps, "ctrmv(case 869) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], dbleps, "ztrmv(case 870) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], dbleps, "ztrmv(case 870) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], dbleps, "ztrmv(case 871) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], dbleps, "ztrmv(case 871) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], dbleps, "ztrmv(case 872) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], dbleps, "ztrmv(case 872) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], dbleps, "ztrmv(case 873) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], dbleps, "ztrmv(case 873) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], dbleps, "ztrmv(case 874) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], dbleps, "ztrmv(case 874) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], dbleps, "ztrmv(case 875) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], dbleps, "ztrmv(case 875) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], dbleps, "ztrmv(case 876) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], dbleps, "ztrmv(case 876) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], dbleps, "ztrmv(case 877) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], dbleps, "ztrmv(case 877) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], dbleps, "ztrmv(case 878) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], dbleps, "ztrmv(case 878) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], dbleps, "ztrmv(case 879) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], dbleps, "ztrmv(case 879) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], dbleps, "ztrmv(case 880) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], dbleps, "ztrmv(case 880) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], dbleps, "ztrmv(case 881) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], dbleps, "ztrmv(case 881) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], dbleps, "ztrmv(case 882) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], dbleps, "ztrmv(case 882) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], dbleps, "ztrmv(case 883) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], dbleps, "ztrmv(case 883) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], dbleps, "ztrmv(case 884) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], dbleps, "ztrmv(case 884) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], dbleps, "ztrmv(case 885) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], dbleps, "ztrmv(case 885) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], dbleps, "ztrmv(case 886) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], dbleps, "ztrmv(case 886) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], dbleps, "ztrmv(case 887) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], dbleps, "ztrmv(case 887) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], dbleps, "ztrmv(case 888) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], dbleps, "ztrmv(case 888) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], dbleps, "ztrmv(case 889) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], dbleps, "ztrmv(case 889) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], dbleps, "ztrmv(case 890) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], dbleps, "ztrmv(case 890) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], dbleps, "ztrmv(case 891) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], dbleps, "ztrmv(case 891) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], dbleps, "ztrmv(case 892) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], dbleps, "ztrmv(case 892) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[2*i], x_expected[2*i], dbleps, "ztrmv(case 893) real");
       gsl_test_rel(X[2*i+1], x_expected[2*i+1], dbleps, "ztrmv(case 893) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], x_expected[i], flteps, "srotm(case 654)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[i], y_expected[i], flteps, "srotm(case 655)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], x_expected[i], flteps, "srotm(case 656)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[i], y_expected[i], flteps, "srotm(case 657)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], x_expected[i], flteps, "srotm(case 658)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[i], y_expected[i], flteps, "srotm(case 659)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], x_expected[i], flteps, "srotm(case 660)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[i], y_expected[i], flteps, "srotm(case 661)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], x_expected[i], flteps, "srotm(case 662)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[i], y_expected[i], flteps, "srotm(case 663)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], x_expected[i], flteps, "srotm(case 664)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[i], y_expected[i], flteps, "srotm(case 665)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], x_expected[i], flteps, "srotm(case 666)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[i], y_expected[i], flteps, "srotm(case 667)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], x_expected[i], flteps, "srotm(case 668)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[i], y_expected[i], flteps, "srotm(case 669)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], x_expected[i], flteps, "srotm(case 670)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[i], y_expected[i], flteps, "srotm(case 671)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], x_expected[i], flteps, "srotm(case 672)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[i], y_expected[i], flteps, "srotm(case 673)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], x_expected[i], dbleps, "drotm(case 674)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[i], y_expected[i], dbleps, "drotm(case 675)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], x_expected[i], dbleps, "drotm(case 676)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[i], y_expected[i], dbleps, "drotm(case 677)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], x_expected[i], dbleps, "drotm(case 678)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[i], y_expected[i], dbleps, "drotm(case 679)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], x_expected[i], dbleps, "drotm(case 680)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[i], y_expected[i], dbleps, "drotm(case 681)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], x_expected[i], dbleps, "drotm(case 682)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[i], y_expected[i], dbleps, "drotm(case 683)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], x_expected[i], dbleps, "drotm(case 684)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[i], y_expected[i], dbleps, "drotm(case 685)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], x_expected[i], dbleps, "drotm(case 686)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[i], y_expected[i], dbleps, "drotm(case 687)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], x_expected[i], dbleps, "drotm(case 688)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[i], y_expected[i], dbleps, "drotm(case 689)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], x_expected[i], dbleps, "drotm(case 690)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[i], y_expected[i], dbleps, "drotm(case 691)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], x_expected[i], dbleps, "drotm(case 692)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[i], y_expected[i], dbleps, "drotm(case 693)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], x_expected[i], flteps, "srotm(case 694)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[i], y_expected[i], flteps, "srotm(case 695)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], x_expected[i], flteps, "srotm(case 696)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[i], y_expected[i], flteps, "srotm(case 697)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], x_expected[i], flteps, "srotm(case 698)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[i], y_expected[i], flteps, "srotm(case 699)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], x_expected[i], flteps, "srotm(case 700)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[i], y_expected[i], flteps, "srotm(case 701)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], x_expected[i], flteps, "srotm(case 702)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[i], y_expected[i], flteps, "srotm(case 703)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], x_expected[i], flteps, "srotm(case 704)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[i], y_expected[i], flteps, "srotm(case 705)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], x_expected[i], flteps, "srotm(case 706)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[i], y_expected[i], flteps, "srotm(case 707)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], x_expected[i], flteps, "srotm(case 708)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[i], y_expected[i], flteps, "srotm(case 709)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], x_expected[i], flteps, "srotm(case 710)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[i], y_expected[i], flteps, "srotm(case 711)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], x_expected[i], flteps, "srotm(case 712)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[i], y_expected[i], flteps, "srotm(case 713)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], x_expected[i], dbleps, "drotm(case 714)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[i], y_expected[i], dbleps, "drotm(case 715)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], x_expected[i], dbleps, "drotm(case 716)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[i], y_expected[i], dbleps, "drotm(case 717)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], x_expected[i], dbleps, "drotm(case 718)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[i], y_expected[i], dbleps, "drotm(case 719)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], x_expected[i], dbleps, "drotm(case 720)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[i], y_expected[i], dbleps, "drotm(case 721)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], x_expected[i], dbleps, "drotm(case 722)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[i], y_expected[i], dbleps, "drotm(case 723)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], x_expected[i], dbleps, "drotm(case 724)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[i], y_expected[i], dbleps, "drotm(case 725)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], x_expected[i], dbleps, "drotm(case 726)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[i], y_expected[i], dbleps, "drotm(case 727)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], x_expected[i], dbleps, "drotm(case 728)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[i], y_expected[i], dbleps, "drotm(case 729)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], x_expected[i], dbleps, "drotm(case 730)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[i], y_expected[i], dbleps, "drotm(case 731)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], x_expected[i], dbleps, "drotm(case 732)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[i], y_expected[i], dbleps, "drotm(case 733)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], x_expected[i], flteps, "srotm(case 734)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[i], y_expected[i], flteps, "srotm(case 735)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], x_expected[i], flteps, "srotm(case 736)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[i], y_expected[i], flteps, "srotm(case 737)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], x_expected[i], flteps, "srotm(case 738)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[i], y_expected[i], flteps, "srotm(case 739)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], x_expected[i], flteps, "srotm(case 740)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[i], y_expected[i], flteps, "srotm(case 741)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], x_expected[i], flteps, "srotm(case 742)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[i], y_expected[i], flteps, "srotm(case 743)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], x_expected[i], flteps, "srotm(case 744)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[i], y_expected[i], flteps, "srotm(case 745)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], x_expected[i], flteps, "srotm(case 746)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[i], y_expected[i], flteps, "srotm(case 747)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], x_expected[i], flteps, "srotm(case 748)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[i], y_expected[i], flteps, "srotm(case 749)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], x_expected[i], flteps, "srotm(case 750)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[i], y_expected[i], flteps, "srotm(case 751)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], x_expected[i], flteps, "srotm(case 752)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[i], y_expected[i], flteps, "srotm(case 753)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], x_expected[i], dbleps, "drotm(case 754)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[i], y_expected[i], dbleps, "drotm(case 755)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], x_expected[i], dbleps, "drotm(case 756)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[i], y_expected[i], dbleps, "drotm(case 757)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], x_expected[i], dbleps, "drotm(case 758)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[i], y_expected[i], dbleps, "drotm(case 759)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], x_expected[i], dbleps, "drotm(case 760)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[i], y_expected[i], dbleps, "drotm(case 761)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], x_expected[i], dbleps, "drotm(case 762)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[i], y_expected[i], dbleps, "drotm(case 763)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], x_expected[i], dbleps, "drotm(case 764)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[i], y_expected[i], dbleps, "drotm(case 765)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], x_expected[i], dbleps, "drotm(case 766)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[i], y_expected[i], dbleps, "drotm(case 767)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], x_expected[i], dbleps, "drotm(case 768)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[i], y_expected[i], dbleps, "drotm(case 769)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], x_expected[i], dbleps, "drotm(case 770)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[i], y_expected[i], dbleps, "drotm(case 771)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(X[i], x_expected[i], dbleps, "drotm(case 772)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(Y[i], y_expected[i], dbleps, "drotm(case 773)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(C[2*i], C_expected[2*i], flteps, "cher2k(case 1646) real");
       gsl_test_rel(C[2*i+1], C_expected[2*i+1], flteps, "cher2k(case 1646) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(C[2*i], C_expected[2*i], flteps, "cher2k(case 1647) real");
       gsl_test_rel(C[2*i+1], C_expected[2*i+1], flteps, "cher2k(case 1647) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(C[2*i], C_expected[2*i], flteps, "cher2k(case 1648) real");
       gsl_test_rel(C[2*i+1], C_expected[2*i+1], flteps, "cher2k(case 1648) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(C[2*i], C_expected[2*i], flteps, "cher2k(case 1649) real");
       gsl_test_rel(C[2*i+1], C_expected[2*i+1], flteps, "cher2k(case 1649) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(C[2*i], C_expected[2*i], flteps, "cher2k(case 1650) real");
       gsl_test_rel(C[2*i+1], C_expected[2*i+1], flteps, "cher2k(case 1650) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(C[2*i], C_expected[2*i], flteps, "cher2k(case 1651) real");
       gsl_test_rel(C[2*i+1], C_expected[2*i+1], flteps, "cher2k(case 1651) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(C[2*i], C_expected[2*i], flteps, "cher2k(case 1652) real");
       gsl_test_rel(C[2*i+1], C_expected[2*i+1], flteps, "cher2k(case 1652) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(C[2*i], C_expected[2*i], flteps, "cher2k(case 1653) real");
       gsl_test_rel(C[2*i+1], C_expected[2*i+1], flteps, "cher2k(case 1653) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(C[2*i], C_expected[2*i], dbleps, "zher2k(case 1654) real");
       gsl_test_rel(C[2*i+1], C_expected[2*i+1], dbleps, "zher2k(case 1654) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(C[2*i], C_expected[2*i], dbleps, "zher2k(case 1655) real");
       gsl_test_rel(C[2*i+1], C_expected[2*i+1], dbleps, "zher2k(case 1655) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(C[2*i], C_expected[2*i], dbleps, "zher2k(case 1656) real");
       gsl_test_rel(C[2*i+1], C_expected[2*i+1], dbleps, "zher2k(case 1656) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(C[2*i], C_expected[2*i], dbleps, "zher2k(case 1657) real");
       gsl_test_rel(C[2*i+1], C_expected[2*i+1], dbleps, "zher2k(case 1657) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(C[2*i], C_expected[2*i], dbleps, "zher2k(case 1658) real");
       gsl_test_rel(C[2*i+1], C_expected[2*i+1], dbleps, "zher2k(case 1658) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(C[2*i], C_expected[2*i], dbleps, "zher2k(case 1659) real");
       gsl_test_rel(C[2*i+1], C_expected[2*i+1], dbleps, "zher2k(case 1659) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(C[2*i], C_expected[2*i], dbleps, "zher2k(case 1660) real");
       gsl_test_rel(C[2*i+1], C_expected[2*i+1], dbleps, "zher2k(case 1660) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++) {
       gsl_test_rel(C[2*i], C_expected[2*i], dbleps, "zher2k(case 1661) real");
       gsl_test_rel(C[2*i+1], C_expected[2*i+1], dbleps, "zher2k(case 1661) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[i], B_expected[i], flteps, "strsm(case 1822)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[i], B_expected[i], flteps, "strsm(case 1823)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[i], B_expected[i], flteps, "strsm(case 1824)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[i], B_expected[i], flteps, "strsm(case 1825)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[i], B_expected[i], flteps, "strsm(case 1826)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[i], B_expected[i], flteps, "strsm(case 1827)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[i], B_expected[i], flteps, "strsm(case 1828)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[i], B_expected[i], flteps, "strsm(case 1829)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[i], B_expected[i], flteps, "strsm(case 1830)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[i], B_expected[i], flteps, "strsm(case 1831)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[i], B_expected[i], flteps, "strsm(case 1832)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[i], B_expected[i], flteps, "strsm(case 1833)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[i], B_expected[i], flteps, "strsm(case 1834)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[i], B_expected[i], flteps, "strsm(case 1835)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[i], B_expected[i], flteps, "strsm(case 1836)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[i], B_expected[i], flteps, "strsm(case 1837)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[i], B_expected[i], flteps, "strsm(case 1838)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[i], B_expected[i], flteps, "strsm(case 1839)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[i], B_expected[i], flteps, "strsm(case 1840)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[i], B_expected[i], flteps, "strsm(case 1841)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[i], B_expected[i], flteps, "strsm(case 1842)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[i], B_expected[i], flteps, "strsm(case 1843)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[i], B_expected[i], flteps, "strsm(case 1844)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[i], B_expected[i], flteps, "strsm(case 1845)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[i], B_expected[i], flteps, "strsm(case 1846)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[i], B_expected[i], flteps, "strsm(case 1847)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[i], B_expected[i], flteps, "strsm(case 1848)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[i], B_expected[i], flteps, "strsm(case 1849)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[i], B_expected[i], flteps, "strsm(case 1850)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[i], B_expected[i], flteps, "strsm(case 1851)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[i], B_expected[i], flteps, "strsm(case 1852)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[i], B_expected[i], flteps, "strsm(case 1853)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[i], B_expected[i], dbleps, "dtrsm(case 1854)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[i], B_expected[i], dbleps, "dtrsm(case 1855)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[i], B_expected[i], dbleps, "dtrsm(case 1856)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[i], B_expected[i], dbleps, "dtrsm(case 1857)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[i], B_expected[i], dbleps, "dtrsm(case 1858)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[i], B_expected[i], dbleps, "dtrsm(case 1859)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[i], B_expected[i], dbleps, "dtrsm(case 1860)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[i], B_expected[i], dbleps, "dtrsm(case 1861)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[i], B_expected[i], dbleps, "dtrsm(case 1862)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[i], B_expected[i], dbleps, "dtrsm(case 1863)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[i], B_expected[i], dbleps, "dtrsm(case 1864)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[i], B_expected[i], dbleps, "dtrsm(case 1865)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[i], B_expected[i], dbleps, "dtrsm(case 1866)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[i], B_expected[i], dbleps, "dtrsm(case 1867)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[i], B_expected[i], dbleps, "dtrsm(case 1868)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[i], B_expected[i], dbleps, "dtrsm(case 1869)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[i], B_expected[i], dbleps, "dtrsm(case 1870)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[i], B_expected[i], dbleps, "dtrsm(case 1871)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[i], B_expected[i], dbleps, "dtrsm(case 1872)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[i], B_expected[i], dbleps, "dtrsm(case 1873)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[i], B_expected[i], dbleps, "dtrsm(case 1874)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[i], B_expected[i], dbleps, "dtrsm(case 1875)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[i], B_expected[i], dbleps, "dtrsm(case 1876)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[i], B_expected[i], dbleps, "dtrsm(case 1877)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[i], B_expected[i], dbleps, "dtrsm(case 1878)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[i], B_expected[i], dbleps, "dtrsm(case 1879)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[i], B_expected[i], dbleps, "dtrsm(case 1880)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[i], B_expected[i], dbleps, "dtrsm(case 1881)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[i], B_expected[i], dbleps, "dtrsm(case 1882)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[i], B_expected[i], dbleps, "dtrsm(case 1883)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[i], B_expected[i], dbleps, "dtrsm(case 1884)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[i], B_expected[i], dbleps, "dtrsm(case 1885)");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], flteps, "ctrsm(case 1886) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], flteps, "ctrsm(case 1886) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], flteps, "ctrsm(case 1887) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], flteps, "ctrsm(case 1887) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], flteps, "ctrsm(case 1888) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], flteps, "ctrsm(case 1888) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], flteps, "ctrsm(case 1889) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], flteps, "ctrsm(case 1889) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], flteps, "ctrsm(case 1890) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], flteps, "ctrsm(case 1890) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], flteps, "ctrsm(case 1891) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], flteps, "ctrsm(case 1891) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], flteps, "ctrsm(case 1892) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], flteps, "ctrsm(case 1892) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], flteps, "ctrsm(case 1893) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], flteps, "ctrsm(case 1893) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], flteps, "ctrsm(case 1894) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], flteps, "ctrsm(case 1894) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], flteps, "ctrsm(case 1895) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], flteps, "ctrsm(case 1895) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], flteps, "ctrsm(case 1896) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], flteps, "ctrsm(case 1896) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], flteps, "ctrsm(case 1897) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], flteps, "ctrsm(case 1897) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], flteps, "ctrsm(case 1898) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], flteps, "ctrsm(case 1898) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], flteps, "ctrsm(case 1899) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], flteps, "ctrsm(case 1899) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], flteps, "ctrsm(case 1900) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], flteps, "ctrsm(case 1900) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], flteps, "ctrsm(case 1901) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], flteps, "ctrsm(case 1901) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], flteps, "ctrsm(case 1902) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], flteps, "ctrsm(case 1902) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], flteps, "ctrsm(case 1903) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], flteps, "ctrsm(case 1903) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], flteps, "ctrsm(case 1904) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], flteps, "ctrsm(case 1904) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], flteps, "ctrsm(case 1905) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], flteps, "ctrsm(case 1905) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], flteps, "ctrsm(case 1906) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], flteps, "ctrsm(case 1906) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], flteps, "ctrsm(case 1907) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], flteps, "ctrsm(case 1907) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], flteps, "ctrsm(case 1908) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], flteps, "ctrsm(case 1908) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], flteps, "ctrsm(case 1909) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], flteps, "ctrsm(case 1909) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], flteps, "ctrsm(case 1910) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], flteps, "ctrsm(case 1910) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], flteps, "ctrsm(case 1911) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], flteps, "ctrsm(case 1911) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], flteps, "ctrsm(case 1912) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], flteps, "ctrsm(case 1912) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], flteps, "ctrsm(case 1913) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], flteps, "ctrsm(case 1913) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], flteps, "ctrsm(case 1914) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], flteps, "ctrsm(case 1914) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], flteps, "ctrsm(case 1915) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], flteps, "ctrsm(case 1915) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], flteps, "ctrsm(case 1916) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], flteps, "ctrsm(case 1916) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], flteps, "ctrsm(case 1917) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], flteps, "ctrsm(case 1917) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], flteps, "ctrsm(case 1918) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], flteps, "ctrsm(case 1918) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], flteps, "ctrsm(case 1919) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], flteps, "ctrsm(case 1919) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], flteps, "ctrsm(case 1920) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], flteps, "ctrsm(case 1920) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], flteps, "ctrsm(case 1921) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], flteps, "ctrsm(case 1921) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], flteps, "ctrsm(case 1922) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], flteps, "ctrsm(case 1922) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], flteps, "ctrsm(case 1923) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], flteps, "ctrsm(case 1923) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], flteps, "ctrsm(case 1924) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], flteps, "ctrsm(case 1924) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], flteps, "ctrsm(case 1925) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], flteps, "ctrsm(case 1925) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], flteps, "ctrsm(case 1926) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], flteps, "ctrsm(case 1926) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], flteps, "ctrsm(case 1927) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], flteps, "ctrsm(case 1927) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], flteps, "ctrsm(case 1928) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], flteps, "ctrsm(case 1928) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], flteps, "ctrsm(case 1929) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], flteps, "ctrsm(case 1929) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], flteps, "ctrsm(case 1930) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], flteps, "ctrsm(case 1930) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], flteps, "ctrsm(case 1931) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], flteps, "ctrsm(case 1931) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], flteps, "ctrsm(case 1932) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], flteps, "ctrsm(case 1932) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], flteps, "ctrsm(case 1933) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], flteps, "ctrsm(case 1933) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], dbleps, "ztrsm(case 1934) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], dbleps, "ztrsm(case 1934) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], dbleps, "ztrsm(case 1935) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], dbleps, "ztrsm(case 1935) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], dbleps, "ztrsm(case 1936) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], dbleps, "ztrsm(case 1936) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], dbleps, "ztrsm(case 1937) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], dbleps, "ztrsm(case 1937) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], dbleps, "ztrsm(case 1938) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], dbleps, "ztrsm(case 1938) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], dbleps, "ztrsm(case 1939) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], dbleps, "ztrsm(case 1939) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], dbleps, "ztrsm(case 1940) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], dbleps, "ztrsm(case 1940) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], dbleps, "ztrsm(case 1941) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], dbleps, "ztrsm(case 1941) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], dbleps, "ztrsm(case 1942) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], dbleps, "ztrsm(case 1942) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], dbleps, "ztrsm(case 1943) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], dbleps, "ztrsm(case 1943) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], dbleps, "ztrsm(case 1944) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], dbleps, "ztrsm(case 1944) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], dbleps, "ztrsm(case 1945) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], dbleps, "ztrsm(case 1945) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], dbleps, "ztrsm(case 1946) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], dbleps, "ztrsm(case 1946) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], dbleps, "ztrsm(case 1947) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], dbleps, "ztrsm(case 1947) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], dbleps, "ztrsm(case 1948) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], dbleps, "ztrsm(case 1948) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], dbleps, "ztrsm(case 1949) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], dbleps, "ztrsm(case 1949) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], dbleps, "ztrsm(case 1950) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], dbleps, "ztrsm(case 1950) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], dbleps, "ztrsm(case 1951) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], dbleps, "ztrsm(case 1951) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], dbleps, "ztrsm(case 1952) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], dbleps, "ztrsm(case 1952) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], dbleps, "ztrsm(case 1953) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], dbleps, "ztrsm(case 1953) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], dbleps, "ztrsm(case 1954) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], dbleps, "ztrsm(case 1954) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], dbleps, "ztrsm(case 1955) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], dbleps, "ztrsm(case 1955) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], dbleps, "ztrsm(case 1956) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], dbleps, "ztrsm(case 1956) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], dbleps, "ztrsm(case 1957) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], dbleps, "ztrsm(case 1957) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], dbleps, "ztrsm(case 1958) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], dbleps, "ztrsm(case 1958) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], dbleps, "ztrsm(case 1959) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], dbleps, "ztrsm(case 1959) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], dbleps, "ztrsm(case 1960) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], dbleps, "ztrsm(case 1960) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], dbleps, "ztrsm(case 1961) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], dbleps, "ztrsm(case 1961) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], dbleps, "ztrsm(case 1962) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], dbleps, "ztrsm(case 1962) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], dbleps, "ztrsm(case 1963) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], dbleps, "ztrsm(case 1963) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], dbleps, "ztrsm(case 1964) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], dbleps, "ztrsm(case 1964) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], dbleps, "ztrsm(case 1965) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], dbleps, "ztrsm(case 1965) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], dbleps, "ztrsm(case 1966) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], dbleps, "ztrsm(case 1966) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], dbleps, "ztrsm(case 1967) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], dbleps, "ztrsm(case 1967) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], dbleps, "ztrsm(case 1968) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], dbleps, "ztrsm(case 1968) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], dbleps, "ztrsm(case 1969) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], dbleps, "ztrsm(case 1969) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], dbleps, "ztrsm(case 1970) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], dbleps, "ztrsm(case 1970) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], dbleps, "ztrsm(case 1971) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], dbleps, "ztrsm(case 1971) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], dbleps, "ztrsm(case 1972) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], dbleps, "ztrsm(case 1972) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], dbleps, "ztrsm(case 1973) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], dbleps, "ztrsm(case 1973) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], dbleps, "ztrsm(case 1974) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], dbleps, "ztrsm(case 1974) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], dbleps, "ztrsm(case 1975) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], dbleps, "ztrsm(case 1975) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], dbleps, "ztrsm(case 1976) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], dbleps, "ztrsm(case 1976) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], dbleps, "ztrsm(case 1977) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], dbleps, "ztrsm(case 1977) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], dbleps, "ztrsm(case 1978) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], dbleps, "ztrsm(case 1978) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], dbleps, "ztrsm(case 1979) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], dbleps, "ztrsm(case 1979) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], dbleps, "ztrsm(case 1980) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], dbleps, "ztrsm(case 1980) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 6; i++) {
       gsl_test_rel(B[2*i], B_expected[2*i], dbleps, "ztrsm(case 1981) real");
       gsl_test_rel(B[2*i+1], B_expected[2*i+1], dbleps, "ztrsm(case 1981) imag");
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = cs->order; i >= 1; i--)
    {
      double temp = d1;
      d1 = y2 * d1 - d2 + cs->c[i];
      d2 = temp;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = eval_order; i >= 1; i--)
    {
      double temp = d1;
      d1 = y2 * d1 - d2 + cs->c[i];
      d2 = temp;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = cs->order; i >= 1; i--)
    {
      double temp = d1;
      d1 = y2 * d1 - d2 + cs->c[i];
      d2 = temp;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i <= cs->order; i++)
    {
      absc += fabs(cs->c[i]);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = eval_order; i >= 1; i--)
    {
      double temp = d1;
      d1 = y2 * d1 - d2 + cs->c[i];
      d2 = temp;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i <= eval_order; i++)
    {
      absc += fabs(cs->c[i]);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = eval_order; i >= 1; i--)
    {
      double temp = d1;
      d1 = y2 * d1 - d2 + cs->c[i];
      d2 = temp;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i <= eval_order; i++)
    {
      absc += fabs(cs->c[i]);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i<cs->order; i++)
    {
      double c_exp = (i == 0) ? 2.0 : 0.0;
      gsl_test_abs (cs->c[i], c_exp, tol, "c[%d] for T_0(x)", i);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i<cs->order; i++)
    {
      double c_exp = (i == 1) ? 1.0 : 0.0;
      gsl_test_abs (cs->c[i], c_exp, tol, "c[%d] for T_1(x)", i);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i<cs->order; i++)
    {
      double c_exp = (i == 2) ? 1.0 : 0.0;
      gsl_test_abs (cs->c[i], c_exp, tol, "c[%d] for T_2(x)", i);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(x=-M_PI; x<M_PI; x += M_PI/100.0) {
    double r = gsl_cheb_eval(cs, x);
    gsl_test_abs(r, sin(x), tol, "gsl_cheb_eval, sin(%.3g)", x);
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(x=-M_PI; x<M_PI; x += M_PI/100.0) {
    double r, e;
    gsl_cheb_eval_err(cs, x, &r, &e);
    gsl_test_abs(r, sin(x), tol, "gsl_cheb_eval_err, sin(%.3g)", x);
    gsl_test_factor(fabs(r-sin(x)) + GSL_DBL_EPSILON, e, ftol, 
                    "gsl_cheb_eval_err, error sin(%.3g)", x);
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(x=-M_PI; x<M_PI; x += M_PI/100.0) {
    double r = gsl_cheb_eval_n(cs, 25, x);
    gsl_test_abs(r, sin(x), tol, "gsl_cheb_eval_n, sin(%.3g)", x);
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(x=-M_PI; x<M_PI; x += M_PI/100.0) {
    double r, e;
    gsl_cheb_eval_n_err(cs, 25, x, &r, &e);
    gsl_test_abs(r, sin(x), 100.0 * tol, "gsl_cheb_eval_n_err, deriv sin(%.3g)", x);
    gsl_test_factor(fabs(r-sin(x)) + GSL_DBL_EPSILON, e, ftol, 
                    "gsl_cheb_eval_n_err, error sin(%.3g)", x);
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(x=-M_PI; x<M_PI; x += M_PI/100.0) {
    double r = gsl_cheb_eval(csd, x);
    gsl_test_abs(r, cos(x), 1600 * tol, "gsl_cheb_eval, deriv sin(%.3g)", x);
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(x=-M_PI; x<M_PI; x += M_PI/100.0) {
    double r, e;
    gsl_cheb_eval_err(csd, x, &r, &e);
    gsl_test_abs(r, cos(x), tol, "gsl_cheb_eval_err, deriv sin(%.3g)", x);
    gsl_test_factor(fabs(r-cos(x)) + GSL_DBL_EPSILON, e, ftol, 
                    "gsl_cheb_eval_err, deriv error sin(%.3g)", x);
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(x=-M_PI; x<M_PI; x += M_PI/100.0) {
    double r = gsl_cheb_eval_n(csd, 25, x);
    gsl_test_abs(r, cos(x), 1600 * tol, "gsl_cheb_eval_n, deriv sin(%.3g)", x);
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(x=-M_PI; x<M_PI; x += M_PI/100.0) {
    double r, e;
    gsl_cheb_eval_n_err(csd, 25, x, &r, &e);
    gsl_test_abs(r, cos(x), 100.0 * tol, "gsl_cheb_eval_n_err, deriv sin(%.3g)", x);
    gsl_test_factor(fabs(r-cos(x)) + GSL_DBL_EPSILON, e, ftol, 
                    "gsl_cheb_eval_n_err, deriv error sin(%.3g)", x);
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(x=-M_PI; x<M_PI; x += M_PI/100.0) {
    double r = gsl_cheb_eval(csi, x);
    gsl_test_abs(r, -(1+cos(x)), tol, "gsl_cheb_eval, integ sin(%.3g)", x);
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(x=-M_PI; x<M_PI; x += M_PI/100.0) {
    double r, e;
    gsl_cheb_eval_err(csi, x, &r, &e);
    gsl_test_abs(r, -(1+cos(x)), tol, "gsl_cheb_eval_err, integ sin(%.3g)", x);
    gsl_test_factor(fabs(r-(-1-cos(x))) + GSL_DBL_EPSILON, e, ftol, 
                    "gsl_cheb_eval_err, integ error sin(%.3g)", x);
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(x=-M_PI; x<M_PI; x += M_PI/100.0) {
    double r = gsl_cheb_eval_n(csi, 25, x);
    gsl_test_abs(r, -(1+cos(x)), tol, "gsl_cheb_eval_n, integ sin(%.3g)", x);
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(x=-M_PI; x<M_PI; x += M_PI/100.0) {
    double r, e;
    gsl_cheb_eval_n_err(csi, 25, x, &r, &e);
    gsl_test_abs(r, -(1+cos(x)), 100.0 * tol, "gsl_cheb_eval_n_err, integ sin(%.3g)", x);
    gsl_test_factor(fabs(r-(-1-cos(x))) + GSL_DBL_EPSILON, e, ftol, 
                    "gsl_cheb_eval_n_err, integ error sin(%.3g)", x);
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=1; i<=n-2; i++) {
      integ->c[i] = con * (f->c[i-1] - f->c[i+1])/((double)i);
      sum += fac * integ->c[i];
      fac = -fac;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 0; k<=cs->order; k++) {
      double y = cos(M_PI * (k+0.5)/(cs->order+1));
      cs->f[k] = GSL_FN_EVAL(func, (y*bma + bpa));
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j<=cs->order; j++) {
      double sum = 0.0;
      for(k = 0; k<=cs->order; k++) 
        sum += cs->f[k]*cos(M_PI * j*(k+0.5)/(cs->order+1));
      cs->c[j] = fac * sum;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = n-3; i>0; i--) 
      deriv->c[i] = deriv->c[i+2] + 2.0 *(i+1.0) * f->c[i+1];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0  ; i<n ; i++) 
      deriv->c[i] *= con;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < dim; i++)
    {
      ytmp[i] = y[i] + 0.5 * h * k1[i];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < dim; i++)
    {
      ytmp[i] = y[i] + h * (-k1[i] + 2.0 * k2[i]);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < dim; i++)
    {
      
      ytmp[i] = y[i];

      {
	const double ksum3 = (k1[i] + 4.0 * k2[i] + k3[i]) / 6.0;
	y[i] += h * ksum3;
      }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < dim; i++)
    {
      const double ksum3 = (k1[i] + 4.0 * k2[i] + k3[i]) / 6.0;
      yerr[i] = h * (k2[i] - ksum3);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < ne; i++)
    { 
      gsl_test_rel (y[i], yfin[i], relerr, 
		    "%s %s step(%d)",
		    gsl_odeiv_step_name (step), desc,i);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < sys->dimension; i++)
    {
      gsl_test_abs (y[i], yfin[i], factor * e->count * err_target,
		    "%s %s evolve(%d)",
		    gsl_odeiv_step_name (step), desc, i);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < ns; i++) 
    {
      y[i][0] = 1.0;
      y[i][1] = 0.0;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < ns; i++)
    for(j = i+1; j < ns; j++)
      for(k = 0; k < sd; k++)
	{
	  const double val1 = yp[sd * i + k];
	  const double val2 = yp[sd * j + k];
	  gsl_test_abs (val1, val2, 
			( GSL_MAX(err_target[i], err_target[j]) ),
			"%s/%s vanderpol",
			T[i]->name, T[j]->name);
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < ns; i++) 
    {
      y[i][0] = 1.0;
      y[i][1] = 2.0;
      y[i][2] = 3.0;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < ns; i++)
    for(j = i+1; j < ns; j++)
      for(k = 0; k < sd; k++)
	{
	  const double val1 = yp[sd * i + k];
	  const double val2 = yp[sd * j + k];
	  gsl_test_rel (val1, val2, 
			( GSL_MAX(err_target[i], err_target[j]) ),
			"%s/%s oregonator",
			T[i]->name, T[j]->name);
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; p[i].type != 0; i++)
    {
      test_stepper(p[i].type);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; p[i].type != 0; i++)
    {
      test_evolve_linear (p[i].type, p[i].h, 1e-10);
      test_evolve_exp (p[i].type, p[i].h, 1e-6);
      test_evolve_sin (p[i].type, p[i].h, 1e-8);
      test_evolve_xsin (p[i].type, p[i].h, 1e-8);
      test_evolve_stiff1 (p[i].type, p[i].h, 1e-7);
      test_evolve_stiff5 (p[i].type, p[i].h, 1e-7);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<dim; i++) {
    const double D0 = 
      eps_rel * (a_y * fabs(y[i]) + a_dydt * fabs(h_old * yp[i])) 
      + eps_abs * scale_abs[i];
    const double r  = fabs(yerr[i]) / fabs(D0);
    rmax = GSL_MAX_DBL(r, rmax);
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(nu = 0; nu < max_iter; nu++)
    {
      for(i = 0; i < dim; i++)
        {
          ytmp[i] = y0[i] + 0.5 * h * Y1[i];
        }

      {
	int s = GSL_ODEIV_FN_EVAL (sys, t + 0.5 * h, ytmp, Y1);
	
	if (s != GSL_SUCCESS)
	  {
	    return s;
	  }    
      }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < dim; i++)
    {
      y[i] = y0[i] + h * Y1[i];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < dim; i++) 
    {
      yerr[i] = 4.0 * (y[i] - y_onestep[i]) / 3.0;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < dim; i++)
    {
      y[i] += h / 6.0 * k[i];
      ytmp[i] = y0[i] + 0.5 * h * k[i];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < dim; i++)
    {
      y[i] += h / 3.0 * k[i];
      ytmp[i] = y0[i] + 0.5 * h * k[i];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < dim; i++)
    {
      y[i] += h / 3.0 * k[i];
      ytmp[i] = y0[i] + h * k[i];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < dim; i++)
    {
      y[i] += h / 6.0 * k[i];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < dim; i++)
    {
      yerr[i] = 4.0 * (y[i] - y_onestep[i]) / 15.0;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 13; i++)
    {
      state->k[i] = (double *) malloc (dim * sizeof (double));

      if (state->k[i] == 0)
        {
          for(j = 0; j < i; j++)
            {
              free (state->k[j]);
            }
          free (state->y0);
          free (state->ytmp);
          free (state);
          GSL_ERROR_NULL ("failed to allocate space for k's", GSL_ENOMEM);
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < dim; i++)
    ytmp[i] = y[i] + b21 * h * k1[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < dim; i++)
    ytmp[i] = y[i] + h * (b3[0] * k1[i] + b3[1] * k2[i]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < dim; i++)
    ytmp[i] = y[i] + h * (b4[0] * k1[i] + b4[2] * k3[i]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < dim; i++)
    ytmp[i] = y[i] + h * (b5[0] * k1[i] + b5[2] * k3[i] + b5[3] * k4[i]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < dim; i++)
    ytmp[i] = y[i] + h * (b6[0] * k1[i] + b6[3] * k4[i] + b6[4] * k5[i]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < dim; i++)
    ytmp[i] =



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < dim; i++)
    ytmp[i] =



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < dim; i++)
    ytmp[i] =



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < dim; i++)
    ytmp[i] =



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < dim; i++)
    ytmp[i] =



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < dim; i++)
    ytmp[i] =



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < dim; i++)
    ytmp[i] =



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < dim; i++)
    {
      const double ksum8 =
        Abar[0] * k1[i] + Abar[5] * k6[i] + Abar[6] * k7[i] +
        Abar[7] * k8[i] + Abar[8] * k9[i] + Abar[9] * k10[i] +
        Abar[10] * k11[i] + Abar[11] * k12[i] + Abar[12] * k13[i];
      y[i] += h * ksum8;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < dim; i++)
    {
      const double ksum8 =
        Abar[0] * k1[i] + Abar[5] * k6[i] + Abar[6] * k7[i] +
        Abar[7] * k8[i] + Abar[8] * k9[i] + Abar[9] * k10[i] +
        Abar[10] * k11[i] + Abar[11] * k12[i] + Abar[12] * k13[i];
      const double ksum7 =
        A[0] * k1[i] + A[5] * k6[i] + A[6] * k7[i] + A[7] * k8[i] +
        A[8] * k9[i] + A[9] * k10[i] + A[10] * k11[i] + A[11] * k12[i];
      yerr[i] = h * (ksum7 - ksum8);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 13; i++)
    {
      DBL_ZERO_MEMSET (state->k[i], dim);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 13; i++)
    {
      free (state->k[i]);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(nu = 0; nu < iter_steps; nu++) 
    {
      int s = GSL_ODEIV_FN_EVAL(sys, t + h, y, k);

      if (s != GSL_SUCCESS)
	{
	  return s;
	}     

      for(i=0; i<dim; i++) 
	{
	  y[i] = y0[i] + h * k[i];
	}
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < dim; i++) 
    {
      yerr[i] = 4.0 * (y[i] - y_onestep[i]);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < dim; i++)
    {
      double u = fabs(y[i]);
      w[i] = (u > 0.0) ? u : 1.0;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 0; k < SEQUENCE_MAX; k++)
    {
      a_work[k + 1] = a_work[k] + bd_sequence[k + 1];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < SEQUENCE_MAX; i++)
    {
      alpha[i][i] = 1.0;
      for(k = 0; k < i; k++)
        {
          const double tmp1 = a_work[k + 1] - a_work[i + 1];
          const double tmp2 = (a_work[i + 1] - a_work[0] + 1.0) * (2 * k + 1);
          alpha[k][i] = pow (small_eps, tmp1 / tmp2);
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 0; k < SEQUENCE_MAX; k++)
    {
      a_work[k + 1] = a_work[k] + bd_sequence[k + 1];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 0; k < SEQUENCE_MAX - 1; k++)
    {
      if (a_work[k + 2] > a_work[k + 1] * alpha[k][k + 1])
        break;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < dim; j++)
        {
          gsl_matrix_set (d, 0, j, y_i[j]);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 0; k < i_step; k++)
        {
          double delta = 1.0 / (x[i_step - k - 1] - x_i);
          const double f1 = delta * x_i;
          const double f2 = delta * x[i_step - k - 1];

          for(j = 0; j < dim; j++)
            {
              const double q_kj = gsl_matrix_get (d, k, j);
              gsl_matrix_set (d, k, j, y_0_err[j]);
              delta = work[j] - q_kj;
              y_0_err[j] = f1 * delta;
              work[j] = f2 * delta;
              y_0[j] += y_0_err[j];
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < dim; j++)
        {
          gsl_matrix_set (d, i_step, j, y_0_err[j]);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < dim; i++)
    {
      for(j = 0; j < dim; j++)
        {
          gsl_matrix_set (a_mat, i, j, -h * gsl_matrix_get (dfdy, i, j));
        }
      gsl_matrix_set (a_mat, i, i, gsl_matrix_get (a_mat, i, i) + 1.0);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < dim; i++)
    {
      y_temp[i] = h * (yp[i] + h * dfdt[i]);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < dim; i++)
    {
      const double di = delta_temp[i];
      delta[i] = di;
      y_temp[i] = y[i] + di;
      sum += fabs(di) / w[i];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(n_inter = 1; n_inter < n_step; n_inter++)
    {
      for(i = 0; i < dim; i++)
        {
          rhs_temp[i] = h * y_out[i] - delta[i];
        }

      gsl_linalg_LU_solve (a_mat, p_vec, &rhs_temp_vec.vector, &delta_temp_vec.vector);

      sum = 0.0;

      for(i = 0; i < dim; i++)
        {
          delta[i] += 2.0 * delta_temp[i];
          y_temp[i] += delta[i];
          sum += fabs(delta[i]) / w[i];
        }

      if (sum > max_sum) 
        {
          return GSL_EFAILED ;
        }

      t += h;

      status = GSL_ODEIV_FN_EVAL (sys, t, y_temp, y_out);

      if (status)
        {
          return status;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < dim; i++)
    {
      rhs_temp[i] = h * y_out[i] - delta[i];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < dim; i++)
    {
      y_out[i] = y_temp[i] + delta_temp[i];
      sum += fabs(delta_temp[i]) / w[i];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 0; k <= state->k_current; k++)
    {
      const unsigned int N = bd_sequence[k];
      const double r = (h / N);
      const double x_k = r * r;

      int status = bsimp_step_local (state,
                                     dim, t_local, h, N,
                                     y_extrap_save, yp,
                                     dfdt, dfdy,
                                     y_extrap_sequence, 
                                     sys);

      if (status == GSL_EFAILED)
        {
          

	  
          for(i = 0; i < dim; i++)
            {
              yerr[i] = GSL_POSINF;
            }

          break;
        }
      
      else if (status != GSL_SUCCESS)
	{
	  return status;
	}
      
      x[k] = x_k;

      poly_extrap (d, x, k, x_k, y_extrap_sequence, y, yerr, extrap_work, dim);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < dim; i++)
    {
      y[i] = y0[i] + h * ytmp[i];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < dim; i++)
    {
      yerr[i] = 4.0 * (y[i] - y_onestep[i]) / 3.0;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < dim; i++)
    ytmp[i] = y[i] + b21 * h * k1[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < dim; i++)
    ytmp[i] = y[i] + h * (b3[0] * k1[i] + b3[1] * k2[i]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < dim; i++)
    ytmp[i] = y[i] + h * (b4[0] * k1[i] + b4[1] * k2[i] + b4[2] * k3[i]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < dim; i++)
    ytmp[i] =



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < dim; i++)
    ytmp[i] =



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < dim; i++)
    {
      const double d_i = c1 * k1[i] + c3 * k3[i] + c4 * k4[i] + c6 * k6[i];
      y[i] += h * d_i;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < dim; i++)
    {
      yerr[i] = h * (ec[1] * k1[i] + ec[3] * k3[i] + ec[4] * k4[i] 
                     + ec[5] * k5[i] + ec[6] * k6[i]);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<dim; i++) {
    const double D0 = 
      eps_rel * (a_y * fabs(y[i]) + a_dydt * fabs(h_old * yp[i])) + eps_abs;
    const double r  = fabs(yerr[i]) / fabs(D0);
    rmax = GSL_MAX_DBL(r, rmax);
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(nu = 0; nu < iter_steps; nu++)
    {
      int s = GSL_ODEIV_FN_EVAL (sys, t + h, y, k);

      if (s != GSL_SUCCESS)
        {
          return s;
        }

      for(i = 0; i < dim; i++)
        {
          y[i] = ((4.0 * y0[i] - yim1[i]) + 2.0 * h * k[i]) / 3.0;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < dim; i++)
        {
          yerr[i] = 4.0 * (y[i] - y_onestep[i]);
          yim1[i] = y0[i];
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(nu = 0; nu < iter_steps; nu++)
    {
      for(i = 0; i < dim; i++)
        {
          ytmp1[i] =
            y[i] + h * (0.25 * k1nu[i] + 0.5 * (0.5 - ir3) * k2nu[i]);
          ytmp2[i] =
            y[i] + h * (0.25 * k2nu[i] + 0.5 * (0.5 + ir3) * k1nu[i]);
        }
      {
        int s =
	  GSL_ODEIV_FN_EVAL (sys, t + 0.5 * h * (1.0 - ir3), ytmp1, k1nu);
	
	if (s != GSL_SUCCESS)
	  {
	    return s;
	  }    
      }
      {
        int s =
	  GSL_ODEIV_FN_EVAL (sys, t + 0.5 * h * (1.0 + ir3), ytmp2, k2nu);
	
	if (s != GSL_SUCCESS)
	  {
	    return s;
	  }    
      }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < dim; i++)
    {
      const double d_i = 0.5 * (k1nu[i] + k2nu[i]);
      y[i] += h * d_i;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < dim; i++) 
    {
      yerr[i] = 8.0 * 0.5 * (y[i] - y_onestep[i]) / 15.0;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < dim; i++)
    ytmp[i] = y[i] +  ah[0] * h * k1[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < dim; i++)
    ytmp[i] = y[i] + h * (b3[0] * k1[i] + b3[1] * k2[i]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < dim; i++)
    ytmp[i] = y[i] + h * (b4[0] * k1[i] + b4[1] * k2[i] + b4[2] * k3[i]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < dim; i++)
    ytmp[i] =



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < dim; i++)
    ytmp[i] =



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < dim; i++)
    {
      const double d_i = c1 * k1[i] + c3 * k3[i] + c4 * k4[i] + c5 * k5[i] + c6 * k6[i];
      y[i] += h * d_i;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < dim; i++)
    {
      yerr[i] = h * (ec[1] * k1[i] + ec[3] * k3[i] + ec[4] * k4[i] 
                     + ec[5] * k5[i] + ec[6] * k6[i]);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < src_size1 ; i++)
      {
        for(j = 0; j < MULTIPLICITY * src_size2; j++)
          {
            dest->data[MULTIPLICITY * dest_tda * i + j] 
              = src->data[MULTIPLICITY * src_tda * i + j];
          }
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < src_size1 ; i++)
      {
        for(j = 0; j < MULTIPLICITY * src_size2; j++)
          {
            ATOMIC tmp = src->data[MULTIPLICITY * src_tda * i + j];
            src->data[MULTIPLICITY * src_tda * i + j] 
              = dest->data[MULTIPLICITY * dest_tda * i + j];
            dest->data[MULTIPLICITY * dest_tda * i + j] = tmp ;
          }
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < M; i++)
    {
      for(j = 0; j < N; j++)
        {
          BASE x = m->data[i * tda + j];
          if (x > max)
            max = x;
#ifdef FP
          if (isnan (x))
            return x;
#endif
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < M; i++)
    {
      for(j = 0; j < N; j++)
        {
          BASE x = m->data[i * tda + j];
          if (x < min)
            min = x;
#ifdef FP
          if (isnan (x))
            return x;
#endif
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < M; i++)
    {
      for(j = 0; j < N; j++)
        {
          BASE x = m->data[i * tda + j];
          if (x < min)
            {
              min = x;
            }
          if (x > max)
            {
              max = x;
            }
#ifdef FP
          if (isnan (x))
            {
              *min_out = x;
              *max_out = x;
              return;
            }
#endif
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < M; i++)
    {
      for(j = 0; j < N; j++)
        {
          BASE x = m->data[i * tda + j];
          if (x > max)
            {
              max = x;
              imax = i;
              jmax = j;
            }
#ifdef FP
          if (isnan (x))
            {
              *imax_out = i;
              *jmax_out = j;
              return;
            }
#endif
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < M; i++)
    {
      for(j = 0; j < N; j++)
        {
          BASE x = m->data[i * tda + j];
          if (x < min)
            {
              min = x;
              imin = i;
              jmin = j;
            }
#ifdef FP
          if (isnan (x))
            {
              *imin_out = i;
              *jmin_out = j;
              return;
            }
#endif
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < M; i++)
    {
      for(j = 0; j < N; j++)
        {
          BASE x = m->data[i * tda + j];
          if (x < min)
            {
              min = x;
              imin = i;
              jmin = j;
            }
          if (x > max)
            {
              max = x;
              imax = i;
              jmax = j;
            }
#ifdef FP
          if (isnan (x))
            {
              *imin_out = i;
              *jmin_out = j;
              *imax_out = i;
              *jmax_out = j;
              return;
            }
#endif
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 0; k < MULTIPLICITY * size2; k++)
        {
          ATOMIC tmp = row1[k] ;
          row1[k] = row2[k] ;
          row2[k] = tmp ;
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(p = 0; p < size1; p++)
        {
          size_t k;
          size_t n = p * MULTIPLICITY * m->tda;
 
          for(k = 0; k < MULTIPLICITY; k++)
            {
              ATOMIC tmp = col1[n+k] ;
              col1[n+k] = col2[n+k] ;
              col2[n+k] = tmp ;
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(p = 0; p < size1; p++)
      {
        size_t k;

        size_t r = p * MULTIPLICITY;
        size_t c = p * MULTIPLICITY * m->tda;
        
          for(k = 0; k < MULTIPLICITY; k++)
            {
              ATOMIC tmp = col[c+k] ;
              col[c+k] = row[r+k] ;
              row[r+k] = tmp ;
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < size1; i++)
    {
      for(j = i + 1 ; j < size2 ; j++) 
        {
          for(k = 0; k < MULTIPLICITY; k++)
            {
              size_t e1 = (i *  m->tda + j) * MULTIPLICITY + k ;
              size_t e2 = (j *  m->tda + i) * MULTIPLICITY + k ;
              {
                ATOMIC tmp = m->data[e1] ;
                m->data[e1] = m->data[e2] ;
                m->data[e2] = tmp ;
              }
            }
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < dest_size1; i++)
    {
      for(j = 0 ; j < dest_size2; j++) 
        {
          for(k = 0; k < MULTIPLICITY; k++)
            {
              size_t e1 = (i *  dest->tda + j) * MULTIPLICITY + k ;
              size_t e2 = (j *  src->tda + i) * MULTIPLICITY + k ;

              dest->data[e1] = src->data[e2] ;
            }
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < N; j++)
      {
        unsigned int k;

        for(k = 0; k < MULTIPLICITY; k++)
          {
            v_data[MULTIPLICITY * stride * j + k] 
              = row_data[MULTIPLICITY * j + k];
          }
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < M; i++)
      {
        unsigned int k;

        for(k = 0; k < MULTIPLICITY; k++)
          {
            v_data[stride * MULTIPLICITY * i + k] =
              column_data[MULTIPLICITY * i * tda + k];
          }
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < N; j++)
      {
        unsigned int k;

        for(k = 0; k < MULTIPLICITY; k++)
          {
            row_data[MULTIPLICITY*j + k] 
              = v_data[MULTIPLICITY * stride * j + k];
          }
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < M; i++)
      {
        unsigned int k;

        for(k = 0; k < MULTIPLICITY; k++)
          {
            column_data[MULTIPLICITY * i * tda + k] 
              = v_data[MULTIPLICITY * stride * i + k];
          }
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < M; i++)
    {
      for(j = 0; j < N; j++)
        {
          k++;
          FUNCTION (gsl_matrix, set) (m, i, j, (BASE) k);
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < M; i++)
      {
        for(j = 0; j < N; j++)
          {
            k++;
            if (m->data[i * N + j] != (BASE) k)
              status = 1;
          };
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < M; i++)
      {
        for(j = 0; j < N; j++)
          {
            k++;
            if (FUNCTION (gsl_matrix, get) (m, i, j) != (BASE) k)
              status = 1;
          };
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < M; i++)
    {
      for(j = 0; j < N; j++)
        {
          k++;
          FUNCTION (gsl_matrix, set) (m, i, j, (BASE) k);
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < M; i++)
      {
        FUNCTION (gsl_matrix, get_row) (v, m, i);

        for(j = 0; j < N; j++)
          {
            k++;
            if (v->data[j] != (BASE) k)
              status = 1;
          }
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < M; i++)
      {
        for(j = 0; j < N; j++)
          {
            BASE k = FUNCTION(gsl_matrix, get) (m, i, j);
            if (k > exp_max) {
              exp_max =  FUNCTION(gsl_matrix, get) (m, i, j);
              exp_imax = i;
              exp_jmax = j;
            }
            if (k < exp_min) {
              exp_min =  FUNCTION(gsl_matrix, get) (m, i, j);
              exp_imin = i;
              exp_jmin = j;
            }
          }
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < M; i++)
    {
      for(j = 0; j < N; j++)
        {
          FUNCTION (gsl_matrix, set) (m, i, j, (ATOMIC) 0);
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < M; i++)
    {
      for(j = 0; j < N; j++)
        {
          k++;
          FUNCTION (gsl_matrix, set) (m, i, j, (ATOMIC) (k % 10));
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < M; i++)
    {
      for(j = 0; j < N; j++)
        {
          k++;
          FUNCTION (gsl_matrix, set) (m, i, j, (ATOMIC) ((k % 10) - 5));
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < M; i++)
    {
      for(j = 0; j < N; j++)
        {
          k++;
          FUNCTION (gsl_matrix, set) (m, i, j, -(ATOMIC) (k % 10));
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < M; i++)
    {
      for(j = 0; j < N; j++)
        {
          k++;
          FUNCTION (gsl_matrix, set) (m, i, j, (ATOMIC) (k % 10 + 1));
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < M; i++)
    {
      for(j = 0; j < N; j++)
        {
          k++;
          FUNCTION (gsl_matrix, set) (m, i, j, -(ATOMIC) (k % 10 + 1));
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < M; i++)
      {
        for(j = 0; j < N; j++)
          {
            FUNCTION (gsl_matrix, set) (a, i, j, (BASE)(3 + i +  5 * j));
            FUNCTION (gsl_matrix, set) (b, i, j, (BASE)(3 + 2 * i + 4 * j));
          }
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < M; i++)
        {
          for(j = 0; j < N; j++)
            {
              BASE r = FUNCTION(gsl_matrix,get) (m,i,j);
              BASE x = FUNCTION(gsl_matrix,get) (a,i,j);
              BASE y = FUNCTION(gsl_matrix,get) (b,i,j);
              BASE z = x + y;
              if (r != z)
                status = 1;
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < M; i++)
        {
          for(j = 0; j < N; j++)
            {
              BASE r = FUNCTION(gsl_matrix,get) (m,i,j);
              BASE x = FUNCTION(gsl_matrix,get) (a,i,j);
              BASE y = FUNCTION(gsl_matrix,get) (b,i,j);
              BASE z = x - y;
              if (r != z)
                status = 1;
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < M; i++)
        {
          for(j = 0; j < N; j++)
            {
              BASE r = FUNCTION(gsl_matrix,get) (m,i,j);
              BASE x = FUNCTION(gsl_matrix,get) (a,i,j);
              BASE y = FUNCTION(gsl_matrix,get) (b,i,j);
              BASE z = x * y;
              if (r != z)
                status = 1;
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < M; i++)
        {
          for(j = 0; j < N; j++)
            {
              BASE r = FUNCTION(gsl_matrix,get) (m,i,j);
              BASE x = FUNCTION(gsl_matrix,get) (a,i,j);
              BASE y = FUNCTION(gsl_matrix,get) (b,i,j);
              BASE z = x / y;
              if (fabs(r - z) > 2 * GSL_FLT_EPSILON * fabs(z))
                status = 1;
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < M; i++)
      {
        for(j = 0; j < N; j++)
          {
            k++;
            FUNCTION (gsl_matrix, set) (m, i, j, (BASE) k);
          }
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < M; i++)
      {
        for(j = 0; j < N; j++)
          {
            k++;
            if (mm->data[i * N + j] != (BASE) k)
              status = 1;
          }
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < M; i++)
      {
        for(j = 0; j < N; j++)
          {
            k++;
            FUNCTION (gsl_matrix, set) (m, i, j, (BASE) k);
          }
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < M; i++)
      {
        for(j = 0; j < N; j++)
          {
            k++;
            if (mm->data[i * N + j] != (BASE) k)
              status = 1;
          }
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < size1 ; i++)
    {
      for(j = 0; j < size2; j++)
        {
          for(k = 0; k < MULTIPLICITY; k++) 
            {
              if (m->data[(i * tda + j) * MULTIPLICITY + k] != 0.0)
                {
                  return 0;
                }
            }
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < size1 ; i++)
    {
      for(j = 0; j < size2; j++)
        {
          for(k = 0; k < MULTIPLICITY; k++) 
            {
              if (m->data[(i * tda + j) * MULTIPLICITY + k] <= 0.0)
                {
                  return 0;
                }
            }
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < size1 ; i++)
    {
      for(j = 0; j < size2; j++)
        {
          for(k = 0; k < MULTIPLICITY; k++) 
            {
              if (m->data[(i * tda + j) * MULTIPLICITY + k] >= 0.0)
                {
                  return 0;
                }
            }
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < M; i++)
        {
          for(j = 0; j < N; j++)
            {
              const size_t aij = 2 * (i * tda_a + j);
              const size_t bij = 2 * (i * tda_b + j);

              a->data[aij] += b->data[bij];
              a->data[aij + 1] += b->data[bij + 1];
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < M; i++)
        {
          for(j = 0; j < N; j++)
            {
              const size_t aij = 2 * (i * tda_a + j);
              const size_t bij = 2 * (i * tda_b + j);

              a->data[aij] -= b->data[bij];
              a->data[aij + 1] -= b->data[bij + 1];
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < M; i++)
        {
          for(j = 0; j < N; j++)
            {
              const size_t aij = 2 * (i * tda_a + j);
              const size_t bij = 2 * (i * tda_b + j);

              ATOMIC ar = a->data[aij];
              ATOMIC ai = a->data[aij + 1];

              ATOMIC br = b->data[bij];
              ATOMIC bi = b->data[bij + 1];

              a->data[aij] = ar * br - ai * bi;
              a->data[aij + 1] = ar * bi + ai * br;
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < M; i++)
        {
          for(j = 0; j < N; j++)
            {
              const size_t aij = 2 * (i * tda_a + j);
              const size_t bij = 2 * (i * tda_b + j);

              ATOMIC ar = a->data[aij];
              ATOMIC ai = a->data[aij + 1];

              ATOMIC br = b->data[bij];
              ATOMIC bi = b->data[bij + 1];

              ATOMIC s = 1.0 / hypot(br, bi);

              ATOMIC sbr = s * br;
              ATOMIC sbi = s * bi;
              
              a->data[aij] = (ar * sbr + ai * sbi) * s;
              a->data[aij + 1] = (ai * sbr - ar * sbi) * s;
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < M; i++)
    {
      for(j = 0; j < N; j++)
        {
          const size_t aij = 2 * (i * tda + j);

          ATOMIC ar = a->data[aij];
          ATOMIC ai = a->data[aij + 1];
          
          a->data[aij] = ar * xr - ai * xi;
          a->data[aij + 1] = ar * xi + ai * xr;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < M; i++)
    {
      for(j = 0; j < N; j++)
        {
          a->data[2 * (i * tda + j)] += GSL_REAL (x);
          a->data[2 * (i * tda + j) + 1] += GSL_IMAG (x);
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < loop_lim; i++)
    {
      a->data[2 * (i * tda + i)] += GSL_REAL (x);
      a->data[2 * (i * tda + i) + 1] += GSL_IMAG (x);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < M; i++)
    {
      for(j = 0; j < N; j++)
        {
          BASE z = ZERO;
          k++;
          GSL_REAL (z) = (ATOMIC) k;
          GSL_IMAG (z) = (ATOMIC) (k + 1000);
          FUNCTION (gsl_matrix, set) (m, i, j, z);
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < M; i++)
    {
      for(j = 0; j < N; j++)
        {
          k++;
          if (m->data[2 * (i * N + j)] != k ||
              m->data[2 * (i * N + j) + 1] != k + 1000)
            status = 1;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < M; i++)
    {
      for(j = 0; j < N; j++)
        {
          BASE z = FUNCTION (gsl_matrix, get) (m, i, j);
          k++;
          if (GSL_REAL (z) != k || GSL_IMAG (z) != k + 1000)
            status = 1;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < M; i++)
    {
      for(j = 0; j < N; j++)
        {
          BASE z = ZERO;
          FUNCTION (gsl_matrix, set) (m, i, j, z);
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < M; i++)
    {
      for(j = 0; j < N; j++)
        {
          BASE z = ZERO;
          k++;
          GSL_REAL (z) = (ATOMIC) (k % 10);
          GSL_IMAG (z) = (ATOMIC) ((k + 5) % 10);
          FUNCTION (gsl_matrix, set) (m, i, j, z);
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < M; i++)
    {
      for(j = 0; j < N; j++)
        {
          BASE z = ZERO;
          k++;
          GSL_REAL (z) = (ATOMIC) ((k % 10) - 5);
          GSL_IMAG (z) = (ATOMIC) (((k + 5) % 10) - 5);
          FUNCTION (gsl_matrix, set) (m, i, j, z);
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < M; i++)
    {
      for(j = 0; j < N; j++)
        {
          BASE z = ZERO;
          k++;
          GSL_REAL (z) = -(ATOMIC) (k % 10);
          GSL_IMAG (z) = -(ATOMIC) ((k + 5) % 10);
          FUNCTION (gsl_matrix, set) (m, i, j, z);
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < M; i++)
    {
      for(j = 0; j < N; j++)
        {
          BASE z = ZERO;
          k++;
          GSL_REAL (z) = (ATOMIC) (k % 10 + 1);
          GSL_IMAG (z) = (ATOMIC) ((k + 5) % 10 + 1);
          FUNCTION (gsl_matrix, set) (m, i, j, z);
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < M; i++)
    {
      for(j = 0; j < N; j++)
        {
          BASE z = ZERO;
          k++;
          GSL_REAL (z) = -(ATOMIC) (k % 10 + 1);
          GSL_IMAG (z) = -(ATOMIC) ((k + 5) % 10 + 1);
          FUNCTION (gsl_matrix, set) (m, i, j, z);
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < M; i++)
      {
        for(j = 0; j < N; j++)
          {
            BASE z;
            k++;
            GSL_REAL (z) = (ATOMIC) k;
            GSL_IMAG (z) = (ATOMIC) (k + 1000);
            FUNCTION (gsl_matrix, set) (m, i, j, z);
          }
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < M; i++)
      {
        for(j = 0; j < N; j++)
          {
            k++;
            if (mm->data[2 * (i * N + j)] != k
                || mm->data[2 * (i * N + j) + 1] != k + 1000)
              status = 1;
          }
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < M; i++)
      {
        for(j = 0; j < N; j++)
          {
            BASE z = ZERO;
            k++;
            GSL_REAL (z) = (ATOMIC) k;
            GSL_IMAG (z) = (ATOMIC) (k + 1000);
            FUNCTION (gsl_matrix, set) (m, i, j, z);
          }
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < M; i++)
      {
        for(j = 0; j < N; j++)
          {
            k++;
            if (mm->data[2 * (i * N + j)] != k
                || mm->data[2 * (i * N + j) + 1] != k + 1000)
              status = 1;
          }
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < P; i++)
    {
      for(j = 0; j < Q; j++)
        {
          BASE z, z1;
          GSL_REAL (z) = (ATOMIC) k;
          GSL_IMAG (z) = (ATOMIC) (k + 10);
          GSL_REAL (z1) = (ATOMIC) (k + 5);
          GSL_IMAG (z1) = (ATOMIC) (k + 20);

          FUNCTION (gsl_matrix, set) (a, i, j, z);
          FUNCTION (gsl_matrix, set) (b, i, j, z1);
          k++;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < P; i++)
      {
        for(j = 0; j < Q; j++)
          {
            BASE z = FUNCTION (gsl_matrix, get) (m, i, j);
            if (GSL_REAL (z) != (ATOMIC) (2 * k + 5) ||
                GSL_IMAG (z) != (ATOMIC) (2 * k + 30))
              status = 1;
            k++;
          }
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < P; i++)
      {
        for(j = 0; j < Q; j++)
          {
            BASE z = FUNCTION (gsl_matrix, get) (m, i, j);
            if (GSL_REAL (z) != (ATOMIC) (-5)
                || GSL_IMAG (z) != (ATOMIC) (-10))
              status = 1;
            k++;
          }
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < P; i++)
      {
        for(j = 0; j < Q; j++)
          {
            ATOMIC real = -(ATOMIC) (25 * k + 200);
            ATOMIC imag = (ATOMIC) (2 * k * k + 35 * k + 50);
            BASE z = FUNCTION (gsl_matrix, get) (m, i, j);
            if (fabs (GSL_REAL (z) - real) > 100 * BASE_EPSILON ||
                fabs (GSL_IMAG (z) - imag) > 100 * BASE_EPSILON)
              {
                status = 1;
#ifdef DEBUG
                printf ("%d\t%d\n", i, j);
                printf (OUT_FORMAT "\n",
                        GSL_REAL (z) + (ATOMIC) (25 * (ATOMIC) k + 200));
                printf (OUT_FORMAT "\n",
                        GSL_IMAG (z) - (ATOMIC) (2 * k * k + 35 * k + 50));
                printf ("\n");
#endif
              }
            k++;
          }
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < P; i++)
      {
        for(j = 0; j < Q; j++)
          {
            ATOMIC denom = (2 * k * k + 50 * k + 425);
            ATOMIC real = (ATOMIC) (2 * k * k + 35 * k + 200) / denom;
            ATOMIC imag = ((ATOMIC) (50) - (ATOMIC) (5 * k)) / denom;
            BASE z = FUNCTION (gsl_matrix, get) (m, i, j);
            if (fabs (GSL_REAL (z) - real) > 100 * BASE_EPSILON ||
                fabs (GSL_IMAG (z) - imag) > 100 * BASE_EPSILON)
              {
#ifdef DEBUG
                printf (OUT_FORMAT "\t",
                        GSL_REAL (z) - (ATOMIC) (2 * k * k + 35 * k +
                                                 200) / denom);
                printf (OUT_FORMAT "\n",
                        GSL_IMAG (z) - ((ATOMIC) (50) -
                                        (ATOMIC) (5 * k)) / denom);
#endif
                status = 1;
              }
            k++;
          }
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0 ; i < size1 ; i++)  
        {
          status = FUNCTION (gsl_block, raw_fread) (stream, 
                                                    m->data + i * tda, 
                                                    size2, 1);
          if (status)
            break;
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0 ; i < size1 ; i++)  
        {
          status = FUNCTION (gsl_block, raw_fwrite) (stream, 
                                                     m->data + i * tda, 
                                                     size2, 1);
          if (status)
            break;
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0 ; i < size1 ; i++)  
        {
          status = FUNCTION (gsl_block, raw_fprintf) (stream, 
                                                      m->data + i * tda, 
                                                      size2, 1,
                                                      format);
          if (status)
            break;
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0 ; i < size1 ; i++)  
        {
          status = FUNCTION (gsl_block, raw_fscanf) (stream, 
                                                     m->data + i * tda, 
                                                     size2, 1);
          if (status)
            break;
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < MULTIPLICITY * n1 * n2; i++)
    {
      m->data[i] = 0;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < p; i++)
    {
      for(j = 0; j < q; j++)
        {
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = ((i == j) ? one : zero);
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < p; i++)
    {
      for(j = 0; j < q; j++)
        {
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = zero;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < p; i++)
    {
      for(j = 0; j < q; j++)
        {
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = x;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < M; i++)
        {
          for(j = 0; j < N; j++)
            {
              a->data[i * tda_a + j] += b->data[i * tda_b + j];
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < M; i++)
        {
          for(j = 0; j < N; j++)
            {
              a->data[i * tda_a + j] -= b->data[i * tda_b + j];
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < M; i++)
        {
          for(j = 0; j < N; j++)
            {
              a->data[i * tda_a + j] *= b->data[i * tda_b + j];
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < M; i++)
        {
          for(j = 0; j < N; j++)
            {
              a->data[i * tda_a + j] /= b->data[i * tda_b + j];
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < M; i++)
    {
      for(j = 0; j < N; j++)
        {
          a->data[i * tda + j] *= x;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < M; i++)
    {
      for(j = 0; j < N; j++)
        {
          a->data[i * tda + j] += x;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < loop_lim; i++)
  {
    a->data[i * tda + i] += x;
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
        {
          gsl_vector_set (x, i, factor);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
        {
          double xi = gsl_vector_get(x, i);
          gsl_vector_set(x, i, factor * xi);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
      for(j = 0; j< n ; j++)
        {
          double u = gsl_matrix_get(J,i,j);
          double su = gsl_matrix_get(s->J, i, j);
          r = fabs(u - su)/(1e-6 + 1e-6 * fabs(u)); sum+=r;
          if (fabs(u - su) > 1e-6 + 1e-6 * fabs(u))
            printf("broken jacobian %g\n", r);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n ; i++)
    {
      residual += fabs(gsl_vector_get(s->f, i));
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n ; i++)
    {
      residual += fabs(gsl_vector_get(s->f, i));
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0 ; i < n ; i++)
    {
      double xi = gsl_vector_get(x,i);
      double dxi = gsl_vector_get(dx,i);
      double tolerance = epsabs + epsrel * fabs(xi)  ;

      if (fabs(dxi) < tolerance)
        {
          ok = 1;
        }
      else
        {
          ok = 0;
          break;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0 ; i < n ; i++)
    {
      double fi = gsl_vector_get(f, i);
      
      residual += fabs(fi);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
    {
      gsl_vector_set (dx, i, 0.0);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
    {
      double di = gsl_vector_get (state->d, i);
      double xi = gsl_vector_get (x, i);
      gsl_vector_set (state->x_trial, i, xi - t*di);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
    {
      double di = gsl_vector_get (state->d, i);
      gsl_vector_set (dx, i, -t*di);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n ; i++) {
    double fi= gsl_vector_get(f, i);
    e2 += fi * fi ;
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n ; i++) {
    double fi= gsl_vector_get(f, i);
    double di= gsl_vector_get(d, i);
    double u = di * fi;
    e2 += u * u ;
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n ; i++) {
    double ai= gsl_vector_get(a, i);
    double bi= gsl_vector_get(b, i);
    double u = ai + bi;
    e2 += u * u ;
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
    {
      double qtdfi = gsl_vector_get (qtdf, i);
      double rdxi = gsl_vector_get (rdx, i);
      double dxi = gsl_vector_get (dx, i);
      double diagi = gsl_vector_get (diag, i);

      gsl_vector_set (w, i, (qtdfi - rdxi) / pnorm);
      gsl_vector_set (v, i, diagi * diagi * dxi / pnorm);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
    {
      double dfi = gsl_vector_get (f_trial, i) - gsl_vector_get (f, i);
      gsl_vector_set (df, i, dfi);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < n; j++)
    {
      double sum = 0;
      for(i = 0; i < n; i++)
        {
          double Jij = gsl_matrix_get (J, i, j);
          sum += Jij * Jij;
        }
      if (sum == 0)
        sum = 1.0;

      gsl_vector_set (diag, j, sqrt (sum));
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < n; j++)
    {
      double cnorm, diagj, sum = 0;
      for(i = 0; i < n; i++)
        {
          double Jij = gsl_matrix_get (J, i, j);
          sum += Jij * Jij;
        }
      if (sum == 0)
        sum = 1.0;

      cnorm = sqrt (sum);
      diagj = gsl_vector_get (diag, j);

      if (cnorm > diagj)
        gsl_vector_set (diag, j, cnorm);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < N; j++)
    {
      double sum = 0;
      for(i = 0; i < N; i++)
        sum += gsl_matrix_get (q, i, j) * gsl_vector_get (f, i);

      gsl_vector_set (qtf, j, sum);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
    {
      double sum = 0;

      for(j = i; j < N; j++)
        {
          sum += gsl_matrix_get (r, i, j) * gsl_vector_get (dx, j);
        }

      gsl_vector_set (rdx, i, sum);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
    {
      double pi = gsl_vector_get (dx, i);
      double xi = gsl_vector_get (x, i);
      gsl_vector_set (x_trial, i, xi + pi);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
    {
      double pi = gsl_vector_get (p, i);
      gsl_vector_set (p, i, -pi);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < M; j++)
    {
      double sum = 0;
      double dj;

      for(i = 0; i < N; i++)
        {
          sum += gsl_matrix_get (r, i, j) * gsl_vector_get (qtf, i);
        }

      dj = gsl_vector_get (diag, j);
      gsl_vector_set (g, j, -sum / dj);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
    {
      double gi = gsl_vector_get (g, i);
      double di = gsl_vector_get (diag, i);
      gsl_vector_set (g, i, (gi / gnorm) / di);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
    {
      double sum = 0;

      for(j = i; j < N; j++)
        {
          double gj = gsl_vector_get (gradient, j);
          double rij = gsl_matrix_get (r, i, j);
          sum += rij * gj;
        }

      gsl_vector_set (Rg, i, sum);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
    {
      double ni = gsl_vector_get (newton, i);
      double gi = gsl_vector_get (gradient, i);
      gsl_vector_set (p, i, alpha * ni + beta * gi);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
    for(j = 0; j < n; j++)
      gsl_matrix_set(state->H,i,j,-gsl_matrix_get(state->H,i,j));



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
    {
      gsl_vector_set (dx, i, 0.0);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
    {
      double sum = 0;

      for(j = 0; j < n; j++)
        {
          sum += gsl_matrix_get (H, i, j) * gsl_vector_get (f, j);
        }
      gsl_vector_set (p, i, sum);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
    {
      double pi = gsl_vector_get (p, i);
      double xi = gsl_vector_get (x, i);
      gsl_vector_set (x_trial, i, xi + t * pi);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
        for(j = 0; j < n; j++)
          gsl_matrix_set(lu,i,j,-gsl_matrix_get(lu,i,j));



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
        {
          double pi = gsl_vector_get (p, i);
          double xi = gsl_vector_get (x, i);
          gsl_vector_set (x_trial, i, xi + t * pi);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
    {
      double yi = gsl_vector_get (fnew, i) - gsl_vector_get (f, i);
      gsl_vector_set (y, i, yi);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
    {
      double sum = 0;

      for(j = 0; j < n; j++)
        {
          sum += gsl_matrix_get (H, i, j) * gsl_vector_get (y, j);
        }

      gsl_vector_set (v, i, sum);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
    {
      lambda += gsl_vector_get (p, i) * gsl_vector_get (v, i);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
    {
      double vi = gsl_vector_get (v, i) + t * gsl_vector_get (p, i);
      gsl_vector_set (v, i, vi);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
    {
      double sum = 0;

      for(j = 0; j < n; j++)
        {
          sum += gsl_matrix_get (H, j, i) * gsl_vector_get (p, j);
        }

      gsl_vector_set (w, i, sum);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
    {
      double vi = gsl_vector_get (v, i);

      for(j = 0; j < n; j++)
        {
          double wj = gsl_vector_get (w, j);
          double Hij = gsl_matrix_get (H, i, j) - vi * wj / lambda;
          gsl_matrix_set (H, i, j, Hij);
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
    {
      double pi = gsl_vector_get (p, i);
      gsl_vector_set (dx, i, t * pi);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
    {
      gsl_vector_set (dx, i, 0.0);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
    {
      double e = gsl_vector_get (dx, i);
      double y = gsl_vector_get (x, i);
      gsl_vector_set (dx, i, -e);
      gsl_vector_set (x, i, y - e);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
    {
      double t = (i + 1) * h;
      double z = t * (t - 1);
      gsl_vector_set (x, i, z);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
    {
      double z, ti = (i + 1) * h;
      double xi = 0, xim1 = 0, xip1 = 0;

      xi = gsl_vector_get (x, i);
      
      if (i > 0)
        xim1 = gsl_vector_get (x, i - 1);

      if (i < N - 1)
        xip1 = gsl_vector_get (x, i + 1);

      z = 2 * xi - xim1 - xip1 + h * h * pow(xi + ti + 1, 3.0) / 2.0;

      gsl_vector_set (f, i, z);

    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
    for(j = 0; j < N; j++)
      gsl_matrix_set (df, i, j, 0.0);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
    {
      double dz_dxi, ti = (i + 1) * h;

      double xi = gsl_vector_get (x, i);
      
      dz_dxi = 2.0 + (3.0 / 2.0) * h * h * pow(xi + ti + 1, 2.0) ;
      
      gsl_matrix_set (df, i, i, dz_dxi);

      if (i > 0)
        gsl_matrix_set (df, i, i-1, -1.0);

      if (i < N - 1)
        gsl_matrix_set (df, i, i+1, -1.0);

    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)       
    {
      gsl_vector_set (x, i, 0.05);   
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
    {
      sum += cos(gsl_vector_get(x,i));
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
    {
      double xi = gsl_vector_get (x,i);
      double z = N - sum + (i + 1) * (1 - cos(xi)) - sin(xi);

      gsl_vector_set (f, i, z);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
    {
      for(j = 0; j < N; j++)
        {
          double dz;
          double xi = gsl_vector_get(x, i);
          double xj = gsl_vector_get(x, j);

          if (j == i)
            dz = sin(xi) + (i + 1) * sin(xi) - cos(xi);
          else
            dz = sin(xj);
          
          gsl_matrix_set(df, i, j, dz);
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < n; j++)
      {
        double xj = gsl_vector_get (x, j);
        double dx = epsrel * fabs (xj);

        if (dx == 0)
          {
            dx = epsrel;
          }

        gsl_vector_set (x1, j, xj + dx);
        
        {
          int status = GSL_MULTIROOT_FN_EVAL (F, x1, f1);

          if (status != GSL_SUCCESS) 
            {
              return GSL_EBADFUNC;
            }
        }

        gsl_vector_set (x1, j, xj);

        for(i = 0; i < m; i++)
          {
            double g1 = gsl_vector_get (f1, i);
            double g0 = gsl_vector_get (f, i);
            gsl_matrix_set (jacobian, i, j, (g1 - g0) / dx);
          }
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
    {
      gsl_vector_set (dx, i, 0.0);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
    {
      double e = gsl_vector_get (dx, i);
      double y = gsl_vector_get (x, i);
      gsl_vector_set (dx, i, -e);
      gsl_vector_set (x, i, y - e);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(n=0; n<128; n++) {
    const double x = gsl_dht_x_sample(t, n);
    f_in[n] = 1.0/(1.0+x*x);
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(n=0; n<128; n++) {
    const double x = gsl_dht_x_sample(t, n);
    f_in[n] = exp(-x);
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(n=0; n<128; n++) {
    const double x = gsl_dht_x_sample(t, n);
    f_in[n] = x * (1.0 - x*x);
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(s=1; s < t->size + 2; s++) {
    stat_z += gsl_sf_bessel_zero_Jnu_e(t->nu, s, &z);
    t->j[s] = z.val;
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(m=1; m<t->size+1; m++) {
      gsl_sf_result J;
      stat_J += gsl_sf_bessel_Jnu_e(nu + 1.0, t->j[m], &J);
      t->J2[m] = J.val * J.val;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(n=1; n<t->size+1; n++) {
      for(m=1; m<=n; m++) {
        double arg = t->j[n] * t->j[m] / jN;
        gsl_sf_result J;
        stat_J += gsl_sf_bessel_Jnu_e(nu, arg, &J);
        t->Jjj[n*(n-1)/2 + m - 1] = J.val;
      }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(m=0; m<t->size; m++) {
    double sum = 0.0;
    double Y;
    for(i=0; i<t->size; i++) {
      





      size_t m_local; 
      size_t n_local;
      if(i < m) {
        m_local = i;
        n_local = m;
      }
      else {
        m_local = m;
        n_local = i;
      }
      Y = t->Jjj[n_local*(n_local+1)/2 + m_local] / t->J2[i+1];
      sum += Y * f_in[i];
    }
    f_out[m] = sum * 2.0 * r*r;
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k=0; k<SOBOL_BIT_COUNT; k++) s_state->v_direction[k][0] = 1;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i_dim=1; i_dim<dimension; i_dim++) {

    const int poly_index = i_dim;
    const int degree_i = degree_table[poly_index];
    int includ[8];

    


    int p_i = primitive_polynomials[poly_index];
    for(k = degree_i-1; k >= 0; k--) {
      includ[k] = ((p_i % 2) == 1);
      p_i /= 2;
    }

    
    for(j=0; j<degree_i; j++) s_state->v_direction[j][i_dim] = v_init[j][i_dim];

    


    for(j=degree_i; j<SOBOL_BIT_COUNT; j++) {
      int newv = s_state->v_direction[j-degree_i][i_dim];
      ell = 1;
      for(k=0; k<degree_i; k++) {
        ell *= 2;
        if(includ[k]) newv ^= (ell * s_state->v_direction[j-k-1][i_dim]);
      }
      s_state->v_direction[j][i_dim] = newv;
    }
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=SOBOL_BIT_COUNT-1-1; j>=0; j--) {
    ell *= 2;
    for(i_dim=0; i_dim<dimension; i_dim++) {
      s_state->v_direction[j][i_dim] *= ell;
    }
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i_dim=0; i_dim<dimension; i_dim++) s_state->last_numerator_vec[i_dim] = 0;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i_dimension=0; i_dimension<dimension; i_dimension++) {
    const int direction_i     = s_state->v_direction[ell-1][i_dimension];
    const int old_numerator_i = s_state->last_numerator_vec[i_dimension];
    const int new_numerator_i = old_numerator_i ^ direction_i;
    s_state->last_numerator_vec[i_dimension] = new_numerator_i;
    v[i_dimension] = new_numerator_i * s_state->last_denominator_inv;
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k=0; k<=pt_degree; k++) {
    int term = 0;
    for(j=0; j<=k; j++) {
      const int conv_term = NIED2_MUL(pa[k-j], pb[j]);
      term = NIED2_ADD(term, conv_term);
    }
    pt[k] = term;
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k=0; k<=pt_degree; k++) {
    pc[k] = pt[k];
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k=pt_degree+1; k<=NIED2_MAX_DEGREE; k++) {
    pc[k] = 0;
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k=0; k<=NIED2_MAX_DEGREE; k++) {
    ph[k] = pb[k];
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(r=0; r<kj; r++) {
    v[r] = 0;
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(r=kj+1; r<m; r++) {
      v[r] = arbitrary_element;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(r=kj+1; r<bigm; r++) {
      v[r] = arbitrary_element;

      


      term = NIED2_SUB(term, NIED2_MUL(ph[r], v[r]));
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(r=bigm+1; r<m; r++) {
      v[r] = arbitrary_element;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(r=0; r<=maxv-m; r++) {
    int term = 0;
    for(k=0; k<m; k++) {
      term = NIED2_SUB(term, NIED2_MUL(pb[k], v[r+k]));
    }
    v[r+m] = term;
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i_dim=0; i_dim<dimension; i_dim++) {

    const int poly_index = i_dim + 1;
    int j, k;

    



    int u = 0;

    







    int pb[NIED2_MAX_DEGREE+1];
    int px[NIED2_MAX_DEGREE+1];
    int px_degree = poly_degree[poly_index];
    int pb_degree = 0;

    for(k=0; k<=px_degree; k++) {
      px[k] = primitive_poly[poly_index][k];
      pb[k] = 0;
    }

    for(;k<NIED2_MAX_DEGREE+1;k++) {
      px[k] = 0;
      pb[k] = 0;
    }

    pb[0] = 1;

    for(j=0; j<NIED2_NBITS; j++) {

      


      if(u == 0) calculate_v(px, px_degree, pb, &pb_degree, v, MAXV);

      





      for(r=0; r<NIED2_NBITS; r++) {
        ci[r][j] = v[r+u];
      }

      
      ++u;
      if(u == px_degree) u = 0;
    }

    



    for(r=0; r<NIED2_NBITS; r++) {
      int term = 0;
      for(j=0; j<NIED2_NBITS; j++) {
        term = 2*term + ci[r][j];
      }
      ns->cj[r][i_dim] = term;
    }

  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i_dim=0; i_dim<dimension; i_dim++) n_state->nextq[i_dim] = 0;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i_dim=0; i_dim<dimension; i_dim++) {
    v[i_dim] = n_state->nextq[i_dim] * recip;
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i_dim=0; i_dim<dimension; i_dim++) {
    n_state->nextq[i_dim] ^= n_state->cj[r][i_dim];
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = n - 1; i > 0; i--)
    {
      size_t j = gsl_rng_uniform_int(r, i+1); 

      swap (base, size, i, j) ;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n && j < k; i++)
    {
      if ((n - i) * gsl_rng_uniform (r) < k - j)
        {
          copy (dest, j, src, i, size) ;
          j++ ;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < k; i++)
    {
      j = gsl_rng_uniform_int (r, n);  

      copy (dest, i, src, j, size) ;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 10; i++)
    {
      for(j = 0; j < 10; j++)
        {
          count[i][j] = 0;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
    {
      for(j = 0; j < 10; j++)
        x[j] = j;

      gsl_ran_shuffle (r_global, x, 10, sizeof (int));

      for(j = 0; j < 10; j++)
        count[x[j]][j]++;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 10; i++)
    {
      for(j = 0; j < 10; j++)
        {
          double expected = N / 10.0;
          double d = fabs (count[i][j] - expected);
          double sigma = d / sqrt (expected);
          if (sigma > 5 && d > 1)
            {
              status = 1;
              gsl_test (status,
                        "gsl_ran_shuffle %d,%d (%g observed vs %g expected)",
                        i, j, count[i][j] / N, 0.1);
            }
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 10; i++)
    {
      count[i] = 0;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
    {
      for(j = 0; j < 10; j++)
        x[j] = j;

      gsl_ran_choose (r_global, y, 3, x, 10, sizeof (int));

      for(j = 0; j < 3; j++)
        count[y[j]]++;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 10; i++)
    {
      double expected = 3.0 * N / 10.0;
      double d = fabs (count[i] - expected);
      double sigma = d / sqrt (expected);
      if (sigma > 5 && d > 1)
        {
          status = 1;
          gsl_test (status,
                    "gsl_ran_choose %d (%g observed vs %g expected)",
                    i, count[i] / N, 0.1);
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
    {
      double r = f ();
      if (r < b && r > a)
        count++;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < BINS; i++)
    count[i] = 0;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
    {
      double r = f ();
      if (r < b && r > a)
        {
          j = (int) ((r - a) / dx);
          count[j]++;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < BINS; i++)
    {
      


      double x = a + i * dx;
#define STEPS 100
      double sum = 0;

      if (fabs (x) < 1e-10)     
        x = 0.0;

      for(j = 1; j < STEPS; j++)
        sum += pdf (x + j * dx / STEPS);

      p[i] = 0.5 * (pdf (x) + 2 * sum + pdf (x + dx - 1e-7)) * dx / STEPS;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < BINS; i++)
    {
      double x = a + i * dx;
      double d = fabs (count[i] - N * p[i]);
      if (p[i] != 0)
        {
          double s = d / sqrt (N * p[i]);
          status_i = (s > 5) && (d > 2);
        }
      else
        {
          status_i = (count[i] != 0);
        }
      status |= status_i;
      if (status_i)
        gsl_test (status_i, "%s [%g,%g) (%g/%d=%g observed vs %g expected)",
                  name, x, x + dx, count[i], N, count[i] / N, p[i]);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < BINS; i++)
    count[i] = 0;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
    {
      int r = (int) (f ());
      if (r >= 0 && r < BINS)
        count[r]++;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < BINS; i++)
    p[i] = pdf (i);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < BINS; i++)
    {
      double d = fabs (count[i] - N * p[i]);
      if (p[i] != 0)
        {
          double s = d / sqrt (N * p[i]);
          status_i = (s > 5) && (d > 1);
        }
      else
        {
          status_i = (count[i] != 0);
        }
      status |= status_i;
      if (status_i)
        gsl_test (status_i, "%s i=%d (%g observed vs %g expected)",
                  name, i, count[i] / N, p[i]);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 0; k < DIRICHLET_K; k++)
    {
      alpha[k] = gsl_ran_exponential (r_global, 0.1);
      alpha_sum += alpha[k];
      theta_sum[k] = 0.0;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(n = 0; n < N; n++)
    {
      gsl_ran_dirichlet (r_global, DIRICHLET_K, alpha, theta);
      for(k = 0; k < DIRICHLET_K; k++)
        theta_sum[k] += theta[k];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 0; k < DIRICHLET_K; k++)
    {
      mean = alpha[k] / alpha_sum;
      sd =
        sqrt ((alpha[k] * (1. - alpha[k] / alpha_sum)) /
              (alpha_sum * (alpha_sum + 1.)));
      obs_mean = theta_sum[k] / N;
      sigma = sqrt ((double) N) * fabs (mean - obs_mean) / sd;

      status = (sigma > 3.0);

      gsl_test (status,
                "test gsl_ran_dirichlet: mean (%g observed vs %g expected)",
                obs_mean, mean);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 0; k < MULTI_DIM; k++)
    x_sum[k] =0.0;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(n = 0; n < N; n++)
    {
      gsl_ran_multinomial (r_global, MULTI_DIM, sum_n, p, x);
      for(k = 0; k < MULTI_DIM; k++)
        x_sum[k] += x[k];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 0; k < MULTI_DIM; k++)
    {
      mean = p[k] * sum_n;
      sd = p[k] * (1.-p[k]) * sum_n;

      obs_mean = x_sum[k] / N;
      sigma = sqrt ((double) N) * fabs (mean - obs_mean) / sd;

      status = (sigma > 3.0);

      gsl_test (status,
                "test gsl_ran_multinomial: mean (%g observed vs %g expected)",
                obs_mean, mean);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<20; ++i) P[i]=1.0/20;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
    {
      double x = a + i * dx;
      sum += gsl_ran_bivariate_gaussian_pdf (x, y, 3.0, 2.0, 0.3) * dx;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < a; i++)
        {
          prod *= gsl_rng_uniform_pos (r);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k=0; k<Kevents; ++k) {
        if (ProbArray[k] < 0) {
          GSL_ERROR_VAL ("probabilities must be non-negative",
                            GSL_EINVAL, 0) ;
        }
        pTotal += ProbArray[k];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k=0; k<Kevents; ++k) {
        E[k] = ProbArray[k]/pTotal;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k=0; k<Kevents; ++k) {
        if (E[k] < mean) ++nSmalls;
        else             ++nBigs;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k=0; k<Kevents; ++k) {
        if (E[k] < mean) {
            push_stack(Smalls,k);
        }
        else {
            push_stack(Bigs,k);
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k=0; k<Kevents; ++k) {
        (g->F)[k] = 1.0;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k=0; k<Kevents; ++k) {
        (g->F)[k] += k;
        (g->F)[k] /= Kevents;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<K; ++i) {
        f = (g->F)[i];
#if KNUTH_CONVENTION
        f = K*f-i;
#endif        
        if (i==k) {
            p += f;
        } else if (k == (g->A)[i]) {
            p += 1.0 - f;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
    {
      array[i] = gsl_ran_poisson (r, mu);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < K; i++)
    {
      theta[i] = gsl_ran_gamma (r, alpha[i], 1.0);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < K; i++)
    {
      norm += theta[i];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < K; i++)
    {
      theta[i] /= norm;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < K; i++)
    {
      log_p += (alpha[i] - 1.0) * log (theta[i]);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < K; i++)
    {
      sum_alpha += alpha[i];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < K; i++)
    {
      log_p -= gsl_sf_lngamma (alpha[i]);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; ++i)
        {
          x[i] = gsl_ran_gaussian (r, 1.0);
          d += x[i] * x[i];
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; ++i)
    {
      x[i] /= d;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
    {
      double u = gsl_rng_uniform (r);
      if (u < p)
        k++;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0 ; i < t ; i++)
        {
          double u = gsl_rng_uniform(r) ;
          
          if (b * u < a)
            {
              k++ ;
              if (k == n1)
                return k ;
              a-- ;
            }
          b-- ;
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0 ; i < n - t ; i++)
        {
          double u = gsl_rng_uniform(r) ;
          
          if (b * u < a)
            {
              k++ ;
              if (k == n1)
                return n1 - k ;
              a-- ;
            }
          b-- ;
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 0; k < K; k++)
    {
      norm += p[k];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 0; k < K; k++)
    {
      if (p[k] > 0.0)
        {
          n[k] = gsl_ran_binomial (r, p[k] / (norm - sum_p), N - sum_n);
        }
      else
        {
          n[k] = 0;
        }

      sum_p += p[k];
      sum_n += n[k];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 0; k < K; k++)
    {
      N += n[k];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 0; k < K; k++)
    {
      norm += p[k];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 0; k < K; k++)
    {
      log_pdf -= gsl_sf_lnfact (n[k]);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 0; k < K; k++)
    {
      log_pdf += log (p[k] / norm) * n[k];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ix = 0; ix <= BINV_CUTOFF; ++ix)
            {
              if (u < f)
                goto Finish;
              u -= f;
              
              f *= s * (n - ix) / (ix + 1);
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = m + 1; i <= ix; i++)
                {
                  f *= (g / i - s);
                }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = ix + 1; i <= m; i++)
                {
                  f /= (g / i - s);
                }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<size; i++) {
    for(j=0; j<size; j++) {
      gsl_matrix_set(m, i, j, 1.0/(i+j+1.0));
    }
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<size; i++) {
    for(j=i; j<size; j++) {
      double x;
      k = (69069 * k + 1) & 0xffffffffUL;
      x = k / 4294967296.0;
      gsl_matrix_set(m, i, j, x);
      gsl_matrix_set(m, j, i, x);
    }
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<size; i++) {
    for(j=i; j<size; j++) {
      gsl_complex z;
      k = (69069 * k + 1) & 0xffffffffUL;
      GSL_REAL(z) = k / 4294967296.0;
      k = (69069 * k + 1) & 0xffffffffUL;
      GSL_IMAG(z) = (i == j) ? 0 : k / 4294967296.0;
      gsl_matrix_complex_set(m, i, j, z);
      gsl_matrix_complex_set(m, j, i, gsl_complex_conjugate(z));
    }
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<size; i++) {
    for(j=0; j<size; j++) {
      k = (69069 * k + 1) & 0xffffffffUL;
      gsl_matrix_set(m, i, j, k / 4294967296.0);
    }
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
    {
      double ei = gsl_vector_get (eval, i);
      gsl_vector_const_view vi = gsl_matrix_const_column(evec, i);
      gsl_vector_memcpy(x, &vi.vector);
      
      gsl_blas_dgemv (CblasNoTrans, 1.0, m, x, 0.0, y);
      for(j = 0; j < N; j++)
        {
          double xj = gsl_vector_get (x, j);
          double yj = gsl_vector_get (y, j);
          gsl_test_rel(yj, ei * xj,  1e8 * GSL_DBL_EPSILON, 
                       "%s, eigenvalue(%d,%d), %s", desc, i, j, desc2);
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
    {
      gsl_vector_const_view vi = gsl_matrix_const_column(evec, i);
      double nrm_v = gsl_blas_dnrm2(&vi.vector);
      gsl_test_rel (nrm_v, 1.0, N * GSL_DBL_EPSILON, "%s, normalized(%d), %s", 
                    desc, i, desc2);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
    {
      gsl_vector_const_view vi = gsl_matrix_const_column(evec, i);
      for(j = i + 1; j < N; j++)
        {
          gsl_vector_const_view vj = gsl_matrix_const_column(evec, j);
          double vivj;
          gsl_blas_ddot (&vi.vector, &vj.vector, &vivj);
          gsl_test_abs (vivj, 0.0, N * GSL_DBL_EPSILON, 
                        "%s, orthogonal(%d,%d), %s", desc, i, j, desc2);
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
    {
      double ei = gsl_vector_get (eval, i);
      double e2i = gsl_vector_get (eval2, i);
      gsl_test_rel(ei, e2i, 10*N*GSL_DBL_EPSILON, 
                   "%s, direct eigenvalue(%d), %s",
                   desc, i, desc2);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
    {
      gsl_complex ei = gsl_vector_complex_get (eval, i);
      gsl_complex e2i = gsl_vector_complex_get (eval2, i);
      gsl_test_rel(GSL_REAL(ei), GSL_REAL(e2i), 10*N*GSL_DBL_EPSILON, 
                   "%s, direct eigenvalue(%d) real, %s",
                   desc, i, desc2);
      gsl_test_rel(GSL_IMAG(ei), GSL_IMAG(e2i), 10*N*GSL_DBL_EPSILON, 
                   "%s, direct eigenvalue(%d) imag, %s",
                   desc, i, desc2);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
    {
      double ei = gsl_vector_get (eval, i);
      gsl_vector_complex_const_view vi = gsl_matrix_complex_const_column(evec, i);
      gsl_vector_complex_memcpy(x, &vi.vector);
      
      gsl_blas_zgemv (CblasNoTrans, GSL_COMPLEX_ONE, m, x, 
                      GSL_COMPLEX_ZERO, y);
      for(j = 0; j < N; j++)
        {
          gsl_complex xj = gsl_vector_complex_get (x, j);
          gsl_complex yj = gsl_vector_complex_get (y, j);
          gsl_test_rel(GSL_REAL(yj), ei * GSL_REAL(xj), 1e8*GSL_DBL_EPSILON, 
                       "%s, eigenvalue(%d,%d), real, %s", desc, i, j, desc2);
          gsl_test_rel(GSL_IMAG(yj), ei * GSL_IMAG(xj), 1e8*GSL_DBL_EPSILON, 
                       "%s, eigenvalue(%d,%d), imag, %s", desc, i, j, desc2);
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
    {
      gsl_vector_complex_const_view vi = gsl_matrix_complex_const_column(evec, i);
      double nrm_v = gsl_blas_dznrm2(&vi.vector);
      gsl_test_rel (nrm_v, 1.0, N * GSL_DBL_EPSILON, "%s, normalized(%d), %s", 
                    desc, i, desc2);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
    {
      gsl_vector_complex_const_view vi = gsl_matrix_complex_const_column(evec, i);
      for(j = i + 1; j < N; j++)
        {
          gsl_vector_complex_const_view vj 
            = gsl_matrix_complex_const_column(evec, j);
          gsl_complex vivj;
          gsl_blas_zdotc (&vi.vector, &vj.vector, &vivj);
          gsl_test_abs (gsl_complex_abs(vivj), 0.0, N * GSL_DBL_EPSILON, 
                        "%s, orthogonal(%d,%d), %s", desc, i, j, desc2);
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; ++i)
    {
      for(j = 0; j < N; ++j)
        {
          gsl_complex z;
          GSL_SET_COMPLEX(&z, gsl_matrix_get(m, i, j), 0.0);
          gsl_matrix_complex_set(A, i, j, z);
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
    {
      gsl_complex ei = gsl_vector_complex_get (eval, i);
      gsl_vector_complex_const_view vi = gsl_matrix_complex_const_column(evec, i);
      double norm = gsl_blas_dznrm2(&vi.vector);

      
      gsl_test_rel(norm, 1.0, N * GSL_DBL_EPSILON,
                   "%s, normalized(%d), %s", desc, i, desc2);

      gsl_vector_complex_memcpy(x, &vi.vector);

      
      gsl_blas_zgemv (CblasNoTrans, GSL_COMPLEX_ONE, A, x, 
                      GSL_COMPLEX_ZERO, y);

      
      gsl_blas_zscal(ei, x);

      
      for(j = 0; j < N; j++)
        {
          gsl_complex xj = gsl_vector_complex_get (x, j);
          gsl_complex yj = gsl_vector_complex_get (y, j);

          
          gsl_test_abs(GSL_REAL(yj), GSL_REAL(xj), 1e8*GSL_DBL_EPSILON, 
                       "%s, eigenvalue(%d,%d), real, %s", desc, i, j, desc2);
          gsl_test_abs(GSL_IMAG(yj), GSL_IMAG(xj), 1e8*GSL_DBL_EPSILON, 
                       "%s, eigenvalue(%d,%d), imag, %s", desc, i, j, desc2);
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; ++i)
    {
      for(j = 0; j < N; ++j)
        {
          double x = gsl_matrix_get(T1, i, j);
          double y = gsl_matrix_get(T2, i, j);

          gsl_test_rel(x, y, 1.0e8 * GSL_DBL_EPSILON,
                       "%s, schur(%d,%d)", desc, i, j);
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<10; i++) {
    for(j=0; j<10; j++) {
      double delta_ij = ( i == j ? 1.0 : 0.0 );
      double id_ij    = gsl_matrix_get(id, i, j);
      
      int rs = ( fabs(id_ij - delta_ij) > 5.0e-3 );
      s += rs;
      gsl_test_abs(id_ij, delta_ij, 5e-3, "invert hilbert(10) %d,%d", i,j);
    }
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < (int) N - 3; ++j)
        {
          gsl_matrix_set(H, (size_t) j + 2, (size_t) j, 0.0);
          gsl_matrix_set(H, (size_t) j + 3, (size_t) j, 0.0);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N - 2; ++i)
    {
      gsl_vector_set(w->hv3, 0, x);
      gsl_vector_set(w->hv3, 1, y);
      gsl_vector_set(w->hv3, 2, z);
      tau_i = gsl_linalg_householder_transform(w->hv3);

      if (tau_i != 0.0)
        {
          
          q = (1 > ((int)i - 1)) ? 0 : (i - 1);

          
          r = ((i + 3) < (N - 1)) ? (i + 3) : (N - 1);

          if (w->compute_t)
            {
              








              
              m = gsl_matrix_submatrix(w->H,
                                       top + i,
                                       top + q,
                                       3,
                                       w->size - top - q);
              gsl_linalg_householder_hm(tau_i, w->hv3, &m.matrix);

              
              m = gsl_matrix_submatrix(w->H,
                                       0,
                                       top + i,
                                       top + r + 1,
                                       3);
              gsl_linalg_householder_mh(tau_i, w->hv3, &m.matrix);
            }
          else
            {
              




              
              m = gsl_matrix_submatrix(H, i, q, 3, N - q);
              gsl_linalg_householder_hm(tau_i, w->hv3, &m.matrix);

              
              m = gsl_matrix_submatrix(H, 0, i, r + 1, 3);
              gsl_linalg_householder_mh(tau_i, w->hv3, &m.matrix);
            }

          if (w->Z)
            {
              
              m = gsl_matrix_submatrix(w->Z, 0, top + i, w->size, 3);
              gsl_linalg_householder_mh(tau_i, w->hv3, &m.matrix);
            }
        } 

      x = gsl_matrix_get(H, i + 1, i);
      y = gsl_matrix_get(H, i + 2, i);
      if (i < (N - 3))
        {
          z = gsl_matrix_get(H, i + 3, i);
        }

      scale = fabs(x) + fabs(y) + fabs(z);
      if (scale != 0.0)
        {
          
          x /= scale;
          y /= scale;
          z /= scale;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = N - 1; i > 0; --i)
    {
      double sel = gsl_matrix_get(A, i, i - 1);
      double del = gsl_matrix_get(A, i, i);

      if ((sel == 0.0) ||
          (fabs(sel) < GSL_DBL_EPSILON * (fabs(del) + fabs(dpel))))
        {
          gsl_matrix_set(A, i, i - 1, 0.0);
          return (i);
        }

      dpel = del;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N - 1; i++)
        {
          size_t j;
          size_t k = i;

          double ek = gsl_vector_get (eval, i);

          
          for(j = i + 1; j < N; j++)
            {
              int test;
              const double ej = gsl_vector_get (eval, j);

              switch (sort_type)
                {       
                case GSL_EIGEN_SORT_VAL_ASC:
                  test = (ej < ek);
                  break;
                case GSL_EIGEN_SORT_VAL_DESC:
                  test = (ej > ek);
                  break;
                case GSL_EIGEN_SORT_ABS_ASC:
                  test = (fabs (ej) < fabs (ek));
                  break;
                case GSL_EIGEN_SORT_ABS_DESC:
                  test = (fabs (ej) > fabs (ek));
                  break;
                default:
                  GSL_ERROR ("unrecognized sort type", GSL_EINVAL);
                }

              if (test)
                {
                  k = j;
                  ek = ej;
                }
            }

          if (k != i)
            {
              
              gsl_vector_swap_elements (eval, i, k);

              
              gsl_matrix_swap_columns (evec, i, k);
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N - 1; i++)
        {
          size_t j;
          size_t k = i;

          double ek = gsl_vector_get (eval, i);

          
          for(j = i + 1; j < N; j++)
            {
              int test;
              const double ej = gsl_vector_get (eval, j);

              switch (sort_type)
                {       
                case GSL_EIGEN_SORT_VAL_ASC:
                  test = (ej < ek);
                  break;
                case GSL_EIGEN_SORT_VAL_DESC:
                  test = (ej > ek);
                  break;
                case GSL_EIGEN_SORT_ABS_ASC:
                  test = (fabs (ej) < fabs (ek));
                  break;
                case GSL_EIGEN_SORT_ABS_DESC:
                  test = (fabs (ej) > fabs (ek));
                  break;
                default:
                  GSL_ERROR ("unrecognized sort type", GSL_EINVAL);
                }

              if (test)
                {
                  k = j;
                  ek = ej;
                }
            }

          if (k != i)
            {
              
              gsl_vector_swap_elements (eval, i, k);

              
              gsl_matrix_complex_swap_columns (evec, i, k);
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N - 1; i++)
        {
          size_t j;
          size_t k = i;

          gsl_complex ek = gsl_vector_complex_get (eval, i);

          
          for(j = i + 1; j < N; j++)
            {
              int test;
              const gsl_complex ej = gsl_vector_complex_get (eval, j);

              switch (sort_type)
                {       
                case GSL_EIGEN_SORT_ABS_ASC:
                  test = (gsl_complex_abs (ej) < gsl_complex_abs (ek));
                  break;
                case GSL_EIGEN_SORT_ABS_DESC:
                  test = (gsl_complex_abs (ej) > gsl_complex_abs (ek));
                  break;
                case GSL_EIGEN_SORT_VAL_ASC:
                case GSL_EIGEN_SORT_VAL_DESC:
                default:
                  GSL_ERROR ("invalid sort type", GSL_EINVAL);
                }

              if (test)
                {
                  k = j;
                  ek = ej;
                }
            }

          if (k != i)
            {
              
              gsl_vector_complex_swap_elements (eval, i, k);

              
              gsl_matrix_complex_swap_columns (evec, i, k);
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n_block - 1; i++)
              {
                const double c = gc[i], s = gs[i];
                size_t k;
                
                for(k = 0; k < N; k++)
                  {
                    gsl_complex qki = gsl_matrix_complex_get (evec, k, a + i);
                    gsl_complex qkj = gsl_matrix_complex_get (evec, k, a + i + 1);
                    
                    
                    gsl_complex x1 = gsl_complex_mul_real(qki, c);
                    gsl_complex y1 = gsl_complex_mul_real(qkj, -s);
                    
                    gsl_complex x2 = gsl_complex_mul_real(qki, s);
                    gsl_complex y2 = gsl_complex_mul_real(qkj, c);
                    
                    gsl_complex qqki = gsl_complex_add(x1, y1);
                    gsl_complex qqkj = gsl_complex_add(x2, y2);
                    
                    gsl_matrix_complex_set (evec, k, a + i, qqki);
                    gsl_matrix_complex_set (evec, k, a + i + 1, qqkj);
                  }
              }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ju = 1; ju < N; ++ju)
    {
      gsl_vector_set(w->work3, ju, 0.0);
      for(iu = 0; iu < ju; ++iu)
        {
          gsl_vector_set(w->work3, ju,
                         gsl_vector_get(w->work3, ju) +
                         fabs(gsl_matrix_get(T, iu, ju)));
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = (int) N - 1; i >= 0; --i)
    {
      iu = (size_t) i;

      
      lambda_re = gsl_matrix_get(T, iu, iu);

      if (iu != 0 && gsl_matrix_get(T, iu, iu - 1) != 0.0)
        {
          lambda_im = sqrt(fabs(gsl_matrix_get(T, iu, iu - 1))) *
                      sqrt(fabs(gsl_matrix_get(T, iu - 1, iu)));
        }
      else
        {
          lambda_im = 0.0;
        }

      GSL_SET_COMPLEX(&lambda, lambda_re, lambda_im);

      smin = GSL_MAX(GSL_DBL_EPSILON * (fabs(lambda_re) + fabs(lambda_im)),
                     smlnum);
      smin = GSL_MAX(smin, GSL_NONSYMMV_SMLNUM);

      if (lambda_im == 0.0)
        {
          int k, l;
          gsl_vector_view bv, xv;

          

          





          gsl_vector_complex_set(eval, iu, lambda);

          





          
          for(k = 0; k < i; ++k)
            {
              gsl_vector_set(w->work,
                             (size_t) k,
                             -gsl_matrix_get(T, (size_t) k, iu));
            }

          gsl_vector_set(w->work, iu, 1.0);

          for(l = i - 1; l >= 0; --l)
            {
              size_t lu = (size_t) l;

              if (lu == 0)
                complex_pair = 0;
              else
                complex_pair = gsl_matrix_get(T, lu, lu - 1) != 0.0;

              if (!complex_pair)
                {
                  double x;

                  





                  Tv = gsl_matrix_submatrix(T, lu, lu, 1, 1);
                  bv = gsl_vector_view_array(dat, 1);
                  gsl_vector_set(&bv.vector, 0,
                                 gsl_vector_get(w->work, lu));
                  xv = gsl_vector_view_array(dat_X, 1);

                  nonsymmv_solve_equation(&Tv.matrix,
                                          lambda_re,
                                          &bv.vector,
                                          &xv.vector,
                                          &scale,
                                          &xnorm,
                                          smin);

                  
                  x = gsl_vector_get(&xv.vector, 0);
                  if (xnorm > 1.0)
                    {
                      if (gsl_vector_get(w->work3, lu) > bignum / xnorm)
                        {
                          x /= xnorm;
                          scale /= xnorm;
                        }
                    }

                  if (scale != 1.0)
                    {
                      gsl_vector_view wv;

                      wv = gsl_vector_subvector(w->work, 0, iu + 1);
                      gsl_blas_dscal(scale, &wv.vector);
                    }

                  gsl_vector_set(w->work, lu, x);

                  if (lu > 0)
                    {
                      gsl_vector_view v1, v2;

                      

                      v1 = gsl_matrix_column(T, lu);
                      v1 = gsl_vector_subvector(&v1.vector, 0, lu);

                      v2 = gsl_vector_subvector(w->work, 0, lu);

                      gsl_blas_daxpy(-x, &v1.vector, &v2.vector);
                    } 
                } 
              else
                {
                  double x11, x21;

                  



                  Tv = gsl_matrix_submatrix(T, lu - 1, lu - 1, 2, 2);
                  bv = gsl_vector_view_array(dat, 2);
                  gsl_vector_set(&bv.vector, 0,
                                 gsl_vector_get(w->work, lu - 1));
                  gsl_vector_set(&bv.vector, 1,
                                 gsl_vector_get(w->work, lu));
                  xv = gsl_vector_view_array(dat_X, 2);

                  nonsymmv_solve_equation(&Tv.matrix,
                                          lambda_re,
                                          &bv.vector,
                                          &xv.vector,
                                          &scale,
                                          &xnorm,
                                          smin);

                  
                  x11 = gsl_vector_get(&xv.vector, 0);
                  x21 = gsl_vector_get(&xv.vector, 1);

                  if (xnorm > 1.0)
                    {
                      double beta;

                      beta = GSL_MAX(gsl_vector_get(w->work3, lu - 1),
                                     gsl_vector_get(w->work3, lu));
                      if (beta > bignum / xnorm)
                        {
                          x11 /= xnorm;
                          x21 /= xnorm;
                          scale /= xnorm;
                        }
                    }

                  
                  if (scale != 1.0)
                    {
                      gsl_vector_view wv;

                      wv = gsl_vector_subvector(w->work, 0, iu + 1);
                      gsl_blas_dscal(scale, &wv.vector);
                    }

                  gsl_vector_set(w->work, lu - 1, x11);
                  gsl_vector_set(w->work, lu, x21);

                  
                  if (lu > 1)
                    {
                      gsl_vector_view v1, v2;

                      v1 = gsl_matrix_column(T, lu - 1);
                      v1 = gsl_vector_subvector(&v1.vector, 0, lu - 1);
                      v2 = gsl_vector_subvector(w->work, 0, lu - 1);
                      gsl_blas_daxpy(-x11, &v1.vector, &v2.vector);

                      v1 = gsl_matrix_column(T, lu);
                      v1 = gsl_vector_subvector(&v1.vector, 0, lu - 1);
                      gsl_blas_daxpy(-x21, &v1.vector, &v2.vector);
                    }

                  --l;
                } 
            } 

          






          ecol = gsl_matrix_complex_column(evec, iu);
          y = gsl_matrix_column(Z, iu);

          if (iu > 0)
            {
              gsl_vector_view x;

              Zv = gsl_matrix_submatrix(Z, 0, 0, N, iu);

              x = gsl_vector_subvector(w->work, 0, iu);

              
              gsl_blas_dgemv(CblasNoTrans,
                             1.0,
                             &Zv.matrix,
                             &x.vector,
                             gsl_vector_get(w->work, iu),
                             &y.vector);
            } 

          

          ev = gsl_vector_complex_real(&ecol.vector);
          ev2 = gsl_vector_complex_imag(&ecol.vector);

          scale = 0.0;
          for(ii = 0; ii < N; ++ii)
            {
              double a = gsl_vector_get(&y.vector, ii);

              
              gsl_vector_set(&ev.vector, ii, a);

              
              gsl_vector_set(&ev2.vector, ii, 0.0);

              if (fabs(a) > scale)
                scale = fabs(a);
            }

          if (scale != 0.0)
            scale = 1.0 / scale;

          
          gsl_blas_dscal(scale, &ev.vector);
        } 
      else
        {
          gsl_vector_complex_view bv, xv;
          size_t k;
          int l;
          gsl_complex lambda2;

          

          



          GSL_SET_REAL(&lambda2, GSL_REAL(lambda));
          GSL_SET_IMAG(&lambda2, -GSL_IMAG(lambda));
          gsl_vector_complex_set(eval, iu - 1, lambda);
          gsl_vector_complex_set(eval, iu, lambda2);

          





          if (fabs(gsl_matrix_get(T, iu - 1, iu)) >=
              fabs(gsl_matrix_get(T, iu, iu - 1)))
            {
              gsl_vector_set(w->work, iu - 1, 1.0);
              gsl_vector_set(w->work2, iu,
                             lambda_im / gsl_matrix_get(T, iu - 1, iu));
            }
          else
            {
              gsl_vector_set(w->work, iu - 1,
                             -lambda_im / gsl_matrix_get(T, iu, iu - 1));
              gsl_vector_set(w->work2, iu, 1.0);
            }
          gsl_vector_set(w->work, iu, 0.0);
          gsl_vector_set(w->work2, iu - 1, 0.0);

          
          for(k = 0; k < iu - 1; ++k)
            {
              gsl_vector_set(w->work, k,
                             -gsl_vector_get(w->work, iu - 1) *
                             gsl_matrix_get(T, k, iu - 1));
              gsl_vector_set(w->work2, k,
                             -gsl_vector_get(w->work2, iu) *
                             gsl_matrix_get(T, k, iu));
            }

          





          for(l = i - 2; l >= 0; --l)
            {
              size_t lu = (size_t) l;

              if (lu == 0)
                complex_pair = 0;
              else
                complex_pair = gsl_matrix_get(T, lu, lu - 1) != 0.0;

              if (!complex_pair)
                {
                  gsl_complex bval;
                  gsl_complex x;

                  





                  Tv = gsl_matrix_submatrix(T, lu, lu, 1, 1);
                  bv = gsl_vector_complex_view_array(dat, 1);
                  xv = gsl_vector_complex_view_array(dat_X, 1);

                  GSL_SET_COMPLEX(&bval,
                                  gsl_vector_get(w->work, lu),
                                  gsl_vector_get(w->work2, lu));
                  gsl_vector_complex_set(&bv.vector, 0, bval);

                  nonsymmv_solve_equation_z(&Tv.matrix,
                                            &lambda,
                                            &bv.vector,
                                            &xv.vector,
                                            &scale,
                                            &xnorm,
                                            smin);

                  if (xnorm > 1.0)
                    {
                      if (gsl_vector_get(w->work3, lu) > bignum / xnorm)
                        {
                          gsl_blas_zdscal(1.0/xnorm, &xv.vector);
                          scale /= xnorm;
                        }
                    }

                  
                  if (scale != 1.0)
                    {
                      gsl_vector_view wv;

                      wv = gsl_vector_subvector(w->work, 0, iu + 1);
                      gsl_blas_dscal(scale, &wv.vector);
                      wv = gsl_vector_subvector(w->work2, 0, iu + 1);
                      gsl_blas_dscal(scale, &wv.vector);
                    }

                  x = gsl_vector_complex_get(&xv.vector, 0);
                  gsl_vector_set(w->work, lu, GSL_REAL(x));
                  gsl_vector_set(w->work2, lu, GSL_IMAG(x));

                  
                  if (lu > 0)
                    {
                      gsl_vector_view v1, v2;

                      v1 = gsl_matrix_column(T, lu);
                      v1 = gsl_vector_subvector(&v1.vector, 0, lu);
                      v2 = gsl_vector_subvector(w->work, 0, lu);
                      gsl_blas_daxpy(-GSL_REAL(x), &v1.vector, &v2.vector);

                      v2 = gsl_vector_subvector(w->work2, 0, lu);
                      gsl_blas_daxpy(-GSL_IMAG(x), &v1.vector, &v2.vector);
                    } 
                } 
              else
                {
                  gsl_complex b1, b2, x1, x2;

                  



                  Tv = gsl_matrix_submatrix(T, lu - 1, lu - 1, 2, 2);
                  bv = gsl_vector_complex_view_array(dat, 2);
                  xv = gsl_vector_complex_view_array(dat_X, 2);

                  GSL_SET_COMPLEX(&b1,
                                  gsl_vector_get(w->work, lu - 1),
                                  gsl_vector_get(w->work2, lu - 1));
                  GSL_SET_COMPLEX(&b2,
                                  gsl_vector_get(w->work, lu),
                                  gsl_vector_get(w->work2, lu));
                  gsl_vector_complex_set(&bv.vector, 0, b1);
                  gsl_vector_complex_set(&bv.vector, 1, b2);

                  nonsymmv_solve_equation_z(&Tv.matrix,
                                            &lambda,
                                            &bv.vector,
                                            &xv.vector,
                                            &scale,
                                            &xnorm,
                                            smin);

                  x1 = gsl_vector_complex_get(&xv.vector, 0);
                  x2 = gsl_vector_complex_get(&xv.vector, 1);

                  if (xnorm > 1.0)
                    {
                      double beta;

                      beta = GSL_MAX(gsl_vector_get(w->work3, lu - 1),
                                     gsl_vector_get(w->work3, lu));
                      if (beta > bignum / xnorm)
                        {
                          gsl_blas_zdscal(1.0/xnorm, &xv.vector);
                          scale /= xnorm;
                        }
                    }

                  
                  if (scale != 1.0)
                    {
                      gsl_vector_view wv;

                      wv = gsl_vector_subvector(w->work, 0, iu + 1);
                      gsl_blas_dscal(scale, &wv.vector);
                      wv = gsl_vector_subvector(w->work2, 0, iu + 1);
                      gsl_blas_dscal(scale, &wv.vector);
                    }
                  gsl_vector_set(w->work, lu - 1, GSL_REAL(x1));
                  gsl_vector_set(w->work, lu, GSL_REAL(x2));
                  gsl_vector_set(w->work2, lu - 1, GSL_IMAG(x1));
                  gsl_vector_set(w->work2, lu, GSL_IMAG(x2));

                  
                  if (lu > 1)
                    {
                      gsl_vector_view v1, v2, v3, v4;

                      v1 = gsl_matrix_column(T, lu - 1);
                      v1 = gsl_vector_subvector(&v1.vector, 0, lu - 1);
                      v4 = gsl_matrix_column(T, lu);
                      v4 = gsl_vector_subvector(&v4.vector, 0, lu - 1);
                      v2 = gsl_vector_subvector(w->work, 0, lu - 1);
                      v3 = gsl_vector_subvector(w->work2, 0, lu - 1);

                      gsl_blas_daxpy(-GSL_REAL(x1), &v1.vector, &v2.vector);
                      gsl_blas_daxpy(-GSL_REAL(x2), &v4.vector, &v2.vector);
                      gsl_blas_daxpy(-GSL_IMAG(x1), &v1.vector, &v3.vector);
                      gsl_blas_daxpy(-GSL_IMAG(x2), &v4.vector, &v3.vector);
                    } 

                  --l;
                } 
            } 

          





          y = gsl_matrix_column(Z, iu - 1);
          y2 = gsl_matrix_column(Z, iu);

          if (iu > 1)
            {
              gsl_vector_view x;

              

              Zv = gsl_matrix_submatrix(Z, 0, 0, N, iu - 1);
              x = gsl_vector_subvector(w->work, 0, iu - 1);

              gsl_blas_dgemv(CblasNoTrans,
                             1.0,
                             &Zv.matrix,
                             &x.vector,
                             gsl_vector_get(w->work, iu - 1),
                             &y.vector);


              
              x = gsl_vector_subvector(w->work2, 0, iu - 1);

              gsl_blas_dgemv(CblasNoTrans,
                             1.0,
                             &Zv.matrix,
                             &x.vector,
                             gsl_vector_get(w->work2, iu),
                             &y2.vector);
            }
          else
            {
              gsl_blas_dscal(gsl_vector_get(w->work, iu - 1), &y.vector);
              gsl_blas_dscal(gsl_vector_get(w->work2, iu), &y2.vector);
            }

          





          
          ecol = gsl_matrix_complex_column(evec, iu - 1);
          ecol2 = gsl_matrix_complex_column(evec, iu);

          




          ev = gsl_vector_complex_imag(&ecol.vector);
          ev2 = gsl_vector_complex_imag(&ecol2.vector);
          scale = 0.0;
          for(ii = 0; ii < N; ++ii)
            {
              double a = gsl_vector_get(&y2.vector, ii);

              scale = GSL_MAX(scale,
                              fabs(a) + fabs(gsl_vector_get(&y.vector, ii)));

              gsl_vector_set(&ev.vector, ii, a);
              gsl_vector_set(&ev2.vector, ii, -a);
            }

          
          ev = gsl_vector_complex_real(&ecol.vector);
          ev2 = gsl_vector_complex_real(&ecol2.vector);
          for(ii = 0; ii < N; ++ii)
            {
              double a = gsl_vector_get(&y.vector, ii);

              gsl_vector_set(&ev.vector, ii, a);
              gsl_vector_set(&ev2.vector, ii, a);
            }

          if (scale != 0.0)
            scale = 1.0 / scale;

          

          gsl_blas_zdscal(scale, &ecol.vector);
          gsl_blas_zdscal(scale, &ecol2.vector);

          



          --i;
        } 
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < 4; ++j)
        {
          if (fabs(crv[j]) > cmax)
            {
              cmax = fabs(crv[j]);
              icmax = j;
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < 4; ++j)
        {
          if (fabs(crv[j]) + fabs(civ[j]) > cmax)
            {
              cmax = fabs(crv[j]) + fabs(civ[j]);
              icmax = j;
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; ++i)
    {
      ei = gsl_vector_complex_get(eval, i);
      vi = gsl_matrix_complex_column(evec, i);

      re = gsl_vector_complex_real(&vi.vector);

      if (GSL_IMAG(ei) == 0.0)
        {
          scale = 1.0 / gsl_blas_dnrm2(&re.vector);
          gsl_blas_dscal(scale, &re.vector);
        }
      else if (GSL_IMAG(ei) > 0.0)
        {
          im = gsl_vector_complex_imag(&vi.vector);

          scale = 1.0 / gsl_hypot(gsl_blas_dnrm2(&re.vector),
                                  gsl_blas_dnrm2(&im.vector));
          gsl_blas_zdscal(scale, &vi.vector);

          vi = gsl_matrix_complex_column(evec, i + 1);
          gsl_blas_zdscal(scale, &vi.vector);
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n_block - 1; i++)
              {
                const double c = gc[i], s = gs[i];
                size_t k;
                
                for(k = 0; k < N; k++)
                  {
                    double qki = gsl_matrix_get (evec, k, a + i);
                    double qkj = gsl_matrix_get (evec, k, a + i + 1);
                    gsl_matrix_set (evec, k, a + i, qki * c - qkj * s);
                    gsl_matrix_set (evec, k, a + i + 1, qki * s + qkj * c);
                  }
              }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N - 1; i++)
    {
      double sd_i = sd[i];
      double d_ip1 = d[i + 1];

      if (fabs (sd_i) < GSL_DBL_EPSILON * (fabs (d_i) + fabs (d_ip1)))
        {
          sd[i] = 0.0;
        }
      d_i = d_ip1;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 0; k < n - 1; k++)
    {
      double c, s;
      create_givens (x, z, &c, &s);

      
      if (gc != NULL)
        gc[k] = c; 
      if (gs != NULL)
        gs[k] = s;

      

      {
        double bk1 = c * bk - s * zk;

        double ap1 = c * (c * ap - s * bp) + s * (s * aq - c * bp);
        double bp1 = c * (s * ap + c * bp) - s * (s * bp + c * aq);
        double zp1 = -s * bq;

        double aq1 = s * (s * ap + c * bp) + c * (s * bp + c * aq);
        double bq1 = c * bq;

        ak = ap1;
        bk = bp1;
        zk = zp1;

        ap = aq1;
        bp = bq1;

        if (k < n - 2)
          aq = d[k + 2];
        if (k < n - 3)
          bq = sd[k + 2];

        d[k] = ak;

        if (k > 0)
          sd[k - 1] = bk1;

        if (k < n - 2)
          sd[k + 1] = bp;

        x = bk;
        z = zk;
      }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < N; j++)
    {
      double Apj = gsl_matrix_get (A, p, j);
      double Aqj = gsl_matrix_get (A, q, j);
      gsl_matrix_set (A, p, j, Apj * c - Aqj * s);
      gsl_matrix_set (A, q, j, Apj * s + Aqj * c);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < M; i++)
    {
      double Aip = gsl_matrix_get (A, i, p);
      double Aiq = gsl_matrix_get (A, i, q);
      gsl_matrix_set (A, i, p, Aip * c - Aiq * s);
      gsl_matrix_set (A, i, q, Aip * s + Aiq * c);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < M; i++)
    {
      for(j = 0; j < N; j++)
        {
          double Aij = gsl_matrix_get (A, i, j);

          if (Aij != 0.0)
            {
              double ax = fabs (Aij);

              if (scale < ax)
                {
                  ssq = 1.0 + ssq * (scale / ax) * (scale / ax);
                  scale = ax;
                }
              else
                {
                  ssq += (ax / scale) * (ax / scale);
                }
            }

        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < max_rot; i++)
    {
      double nrm = norm (a);

      if (nrm == 0.0)
        break;

      for(p = 0; p < N; p++)
        {
          for(q = p + 1; q < N; q++)
            {
              double c, s;

              red = symschur2 (a, p, q, &c, &s);
              redsum += red;

              
              apply_jacobi_L (a, p, q, c, s);
              apply_jacobi_R (a, p, q, c, s);

              
              apply_jacobi_R (evec, p, q, c, s);
            }
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(p = 0; p < N; p++)
    {
      double ep = gsl_matrix_get (a, p, p);
      gsl_vector_set (eval, p, ep);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<n; i++) 
      {
        for(j=0; j<n; j++) 
          {
            double ainv_ij = 0.0;
            
            for(k = 0; k<n; k++)
              {
                double f = 1.0 / gsl_vector_get(eval, k);
                double vik = gsl_matrix_get (evec, i, k);
                double vjk = gsl_matrix_get (evec, j, k);
                ainv_ij += vik * vjk * f;
              }
            gsl_matrix_set (ainv, i, j, ainv_ij);
          }
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 100; i++) f[i] = 0;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1000; i++)
      {
        double xi = 1.0 / (i + 1.5);
        double yi = xi * xi ;
        double zi = xi * xi * xi;
        
        ntuple_row.x = xi;
        ntuple_row.y = yi;
        ntuple_row.z = zi;
        ntuple_row.num = i;
        
        x[i] = xi; y[i] = yi; z[i] = zi;
        
        if (xi * scale < 0.1)
          {
            double v = xi + yi + zi;
            int k = (int)(100.0*v*scale);
            f[k]++;
          }

        

        
        {
          int s = gsl_ntuple_bookdata (ntuple);

          if (s != GSL_SUCCESS)
            {
              status = 1;
            }
        }
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1000; i++)
      {
        gsl_ntuple_read (ntuple);

        status = (ntuple_row.num != i);
        status |= (ntuple_row.x != x[i]);
        status |= (ntuple_row.y != y[i]);
        status |= (ntuple_row.z != z[i]);

        

      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 100; i++)
      {
        

        if (h->bin[i] != f[i])
          {
            status = 1;
          }
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++)
    {
      a[i] = x + (i - 2.0) * h;
      d[i] = GSL_FN_EVAL (f, a[i]);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 1; k < 4; k++)
    {
      for(i = 0; i < 3 - k; i++)
        {
          d[i] = (d[i + 1] - d[i]) / (a[i + k] - a[i]);
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++)
    {
      a[i] = x + i * h;
      d[i] = GSL_FN_EVAL (f, a[i]);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 1; k < 4; k++)
    {
      for(i = 0; i < 3 - k; i++)
        {
          d[i] = (d[i + 1] - d[i]) / (a[i + k] - a[i]);
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 4; i++)
    {
      a[i] = x + (i - 2.0) * h;
      d[i] = GSL_FN_EVAL (f, a[i]);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 1; k < 5; k++)
    {
      for(i = 0; i < 4 - k; i++)
        {
          d[i] = (d[i + 1] - d[i]) / (a[i + k] - a[i]);
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i <= n; i++)
    {
      double f1 = ((double) (n-i) / (double) n);
      double f2 = ((double) i / (double) n);
      range[i] = f1 * xmin +  f2 * xmax;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nx + 1; i++)
      {
        h->xrange[i] = i;
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < ny + 1; i++)
      {
        h->yrange[i] = i;
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nx * ny; i++)
      {
        h->bin[i] = 0;
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nx * ny; i++)
    {
      h->bin[i] = 0;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i <= nx; i++)
    {
      h->xrange[i] = xrange[i];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i <= ny; i++)
    {
      h->yrange[i] = yrange[i];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nx * ny; i++)
    {
      h->bin[i] = 0;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
    {
      if (h->bin[i] < 0)
        {
          GSL_ERROR ("histogram bins must be non-negative to compute"
                     "a probability distribution", GSL_EDOM);
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n + 1; i++)
    {
      p->range[i] = h->range[i];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
      {
        mean += (h->bin[i] - mean) / ((double) (i + 1));
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
      {
        sum += (h->bin[i] / mean) / n;
        p->sum[i + 1] = sum;
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nx; i++)
    {
      if (xrange[i] >= xrange[i + 1])
        {
          GSL_ERROR_VAL ("histogram xrange not in increasing order",
                            GSL_EDOM, 0);
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < ny; j++)
    {
      if (yrange[j] >= yrange[j + 1])
        {
          GSL_ERROR_VAL ("histogram yrange not in increasing order"
                            ,GSL_EDOM, 0);
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i <= nx; i++)
    {
      h->xrange[i] = xrange[i];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j <= ny; j++)
    {
      h->yrange[j] = yrange[j];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nx; i++)
    {
      for(j = 0; j < ny; j++)
        {
          h->bin[i * ny + j] = 0;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 100000; i++)
      {
        double u = urand();
        double x = gsl_histogram_pdf_sample (p, u);
        gsl_histogram_increment (hh, x);
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 100; i++)
      {
        double y = gsl_histogram_get (hh, i) / 2500;
        double x, xmax;
        size_t k;
        double ya;

        gsl_histogram_get_range (hh, i, &x, &xmax);

        gsl_histogram_find (h, x, &k);
        ya = gsl_histogram_get (h, k);

        if (ya == 0)
          {
            if (y != 0)
              {
                printf ("%d: %g vs %g\n", (int) i, y, ya);
                status = 1;
              }
          }
        else
          {
            double err = 1 / sqrt (gsl_histogram_get (hh, i));
            double sigma = fabs ((y - ya) / (ya * err));
            if (sigma > 3)
              {
                status = 1;
                printf ("%g vs %g err=%g sigma=%g\n", y, ya, err, sigma);
              }
          }
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i <= h1->n; i++)
      {
        if (h1->range[i] != h2->range[i])
          {
            return 0;
          }
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < h1->n; i++)
    {
      h1->bin[i] += h2->bin[i];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < h1->n; i++)
    {
      h1->bin[i] -= h2->bin[i];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < h1->n; i++)
    {
      h1->bin[i] *= h2->bin[i];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < h1->n; i++)
    {
      h1->bin[i] /= h2->bin[i];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < h->n; i++)
    {
      h->bin[i] *= scale;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < h->n; i++)
    {
      h->bin[i] += shift;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
    {
      if (h->bin[i] < 0)
        {
          GSL_ERROR ("histogram bins must be non-negative to compute"
                     "a probability distribution", GSL_EDOM);
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nx + 1; i++)
    {
      p->xrange[i] = h->xrange[i];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < ny + 1; i++)
    {
      p->yrange[i] = h->yrange[i];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
      {
        mean += (h->bin[i] - mean) / ((double) (i + 1));
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
      {
        sum += (h->bin[i] / mean) / n;
        p->sum[i + 1] = sum;
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
    {
      double xi = (h->range[i + 1] + h->range[i]) / 2;
      double wi = h->bin[i];

      if (wi > 0)
        {
          W += wi;
          wmean += (xi - wmean) * (wi / W);
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
    {
      double xi = (h->range[i + 1] + h->range[i]) / 2;
      double wi = h->bin[i];

      if (wi > 0)
        {
          W += wi;
          wmean += (xi - wmean) * (wi / W);
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
    {
      double xi = ((h->range[i + 1]) + (h->range[i])) / 2;
      double wi = h->bin[i];

      if (wi > 0) {
        const long double delta = (xi - wmean);
        W += wi ;
        wvariance += (delta * delta - wvariance) * (wi / W);
      }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i <= nx; i++)
    {
      dest->xrange[i] = src->xrange[i];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i <= ny; i++)
    {
      dest->yrange[i] = src->yrange[i];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nx * ny; i++)
    {
      dest->bin[i] = src->bin[i];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nx * ny; i++)
    {
      h->bin[i] = src->bin[i];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i <= NR; i++)
      {
        if (hr->range[i] != xr[i])
          {
            status = 1;
          }
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i <= NR; i++)
    {
      hr->range[i] = 0.0;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i <= NR; i++)
      {
        if (hr->range[i] != xr[i])
          {
            status = 1;
          }
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
    {
      gsl_histogram_accumulate (h, (double) i, (double) i);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
      {
        if (h->bin[i] != (double) i)
          {
            status = 1;
          }
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
      {
        if (gsl_histogram_get (h, i) != i)
          status = 1;
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i <= N; i++)
    {
      h1->range[i] = 100.0 + i;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i <= N; i++)
      {
        if (h1->range[i] != h->range[i])
          status = 1;
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
      {
        if (gsl_histogram_get (h1, i) != gsl_histogram_get (h, i))
          status = 1;
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i <= N; i++)
      {
        if (h1->range[i] != h->range[i])
          status = 1;
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
      {
        if (gsl_histogram_get (h1, i) != gsl_histogram_get (h, i))
          status = 1;
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
      {
        if (h->bin[i] != 0)
          status = 1;
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
      {
        gsl_histogram_increment (h, (double) i);

        for(j = 0; j <= i; j++)
          {
            if (h->bin[j] != 1)
              {
                status = 1;
              }
          }

        for(j = i + 1; j < N; j++)
          {
            if (h->bin[j] != 0)
              {
                status = 1;
              }
          }
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
      {
        double x0 = 0, x1 = 0;

        gsl_histogram_get_range (h, i, &x0, &x1);

        if (x0 != i || x1 != i + 1)
          {
            status = 1;
          }
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
    {
      h->bin[i] = i + 27;
      g->bin[i] = (i + 27) * (i + 1);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
      {
        if (h1->bin[i] != g->bin[i] + h->bin[i])
          status = 1;
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
      {
        if (h1->bin[i] != g->bin[i] - h->bin[i])
          status = 1;
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
      {
        if (h1->bin[i] != g->bin[i] * h->bin[i])
          status = 1;
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
      {
        if (h1->bin[i] != g->bin[i] / h->bin[i])
          status = 1;
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
      {
        if (h1->bin[i] != 0.5 * g->bin[i])
          status = 1;
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
      {
        if (h1->bin[i] != 0.25 + g->bin[i])
          status = 1;
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
      {
        if (i == i1)
          {
            expected = 1.0;
          }
        else if (i == i2)
          {
            expected = 2.0;
          }
        else if (i == i3)
          {
            expected = 3.0;
          }
        else if (i == i4)
          {
            expected = 4.0;
          }
        else
          {
            expected = 0.0;
          }

        if (h->bin[i] != expected)
          {
            status = 1;
          }

      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
      {
        if (h->range[i] != hh->range[i])
          status = 1;
        if (h->bin[i] != hh->bin[i])
          status = 1;
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
      {
        if (h->range[i] != hh->range[i])
          status = 1;
        if (h->bin[i] != hh->bin[i])
          status = 1;
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
    {
      h->bin[i] = 0;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i <= MR; i++)
      {
        if (hr->xrange[i] != xr[i])
          {
            status = 1;
          }
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i <= NR; i++)
      {
        if (hr->yrange[i] != yr[i])
          {
            status = 1;
          }
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i <= MR; i++)
    {
      hr->xrange[i] = 0.0;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i <= NR; i++)
    {
      hr->yrange[i] = 0.0;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i <= MR; i++)
      {
        if (hr->xrange[i] != xr[i])
          {
            status = 1;
          }
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i <= NR; i++)
      {
        if (hr->yrange[i] != yr[i])
          {
            status = 1;
          }
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < M; i++)
    {
      for(j = 0; j < N; j++)
        {
          k++;
          gsl_histogram2d_accumulate (h, (double) i, (double) j, (double) k);
        };
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < M; i++)
      {
        for(j = 0; j < N; j++)
          {
            k++;
            if (h->bin[i * N + j] != (double) k)
              {
                status = 1;
              }
          }
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < M; i++)
      {
        for(j = 0; j < N; j++)
          {
            k++;
            if (gsl_histogram2d_get (h, i, j) != (double) k)
              status = 1;
          };
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i <= M; i++)
    {
      h1->xrange[i] = 100.0 + i;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i <= N; i++)
    {
      h1->yrange[i] = 900.0 + i * i;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i <= M; i++)
      {
        if (h1->xrange[i] != h->xrange[i])
          status = 1;
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i <= N; i++)
      {
        if (h1->yrange[i] != h->yrange[i])
          status = 1;
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < M; i++)
      {
        for(j = 0; j < N; j++)
          {
            if (gsl_histogram2d_get (h1, i, j) !=
                gsl_histogram2d_get (h, i, j))
              status = 1;
          }
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i <= M; i++)
      {
        if (h1->xrange[i] != h->xrange[i])
          status = 1;
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i <= N; i++)
      {
        if (h1->yrange[i] != h->yrange[i])
          status = 1;
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < M; i++)
      {
        for(j = 0; j < N; j++)
          {
            if (gsl_histogram2d_get (h1, i, j) !=
                gsl_histogram2d_get (h, i, j))
              status = 1;
          }
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < M * N; i++)
      {
        if (h->bin[i] != 0)
          status = 1;
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < M1; i++)
      {
        for(j = 0; j < N1; j++)
          {
            gsl_histogram2d_increment (h, (double) i, (double) j);

            for(k = 0; k <= i * N1 + j; k++)
              {
                if (h->bin[k] != 1)
                  {
                    status = 1;
                  }
              }

            for(k = i * N1 + j + 1; k < M1 * N1; k++)
              {
                if (h->bin[k] != 0)
                  {
                    status = 1;
                  }
              }
          }
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < M; i++)
      {
        double x0 = 0, x1 = 0;
        gsl_histogram2d_get_xrange (h, i, &x0, &x1);

        if (x0 != i || x1 != i + 1)
          {
            status = 1;
          }
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
      {
        double y0 = 0, y1 = 0;
        gsl_histogram2d_get_yrange (h, i, &y0, &y1);

        if (y0 != i || y1 != i + 1)
          {
            status = 1;
          }
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < M * N; i++)
    {
      h->bin[i] = i + 27;
      g->bin[i] = (i + 27) * (i + 1);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(xbin = 0; xbin < M; xbin++)
      {
        double xi =
          ((h3->xrange[xbin] + h3->xrange[xbin + 1]) / 2.0 - xmean) / xsigma;
        for(ybin = 0; ybin < N; ybin++)
          {
            double yi =
              ((h3->yrange[ybin] + h3->yrange[ybin + 1]) / 2.0 -
               ymean) / ysigma;
            double prob =
              norm * exp (-(xi * xi - 2.0 * correl * xi * yi + yi * yi) /
                          2.0 / (1 - correl * correl));
            h3->bin[xbin * N + ybin] = prob;
          }
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < M * N; i++)
      {
        if (h1->bin[i] != g->bin[i] + h->bin[i])
          status = 1;
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < M * N; i++)
      {
        if (h1->bin[i] != g->bin[i] - h->bin[i])
          status = 1;
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < M * N; i++)
      {
        if (h1->bin[i] != g->bin[i] * h->bin[i])
          status = 1;
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < M * N; i++)
      {
        if (h1->bin[i] != g->bin[i] / h->bin[i])
          status = 1;
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < M * N; i++)
      {
        if (h1->bin[i] != 0.5 * g->bin[i])
          status = 1;
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < M * N; i++)
      {
        if (h1->bin[i] != 0.25 + g->bin[i])
          status = 1;
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < M1; i++)
      {
        for(j = 0; j < N1; j++)
          {
            if (i == i1 && j == j1)
              {
                expected = 1.0;
              }
            else if (i == i2 && j == j2)
              {
                expected = 2.0;
              }
            else if (i == i3 && j == j3)
              {
                expected = 3.0;
              }
            else if (i == i4 && j == j4)
              {
                expected = 4.0;
              }
            else
              {
                expected = 0.0;
              }

            if (h->bin[i * N1 + j] != expected)
              {
                status = 1;
              }
          }
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i <= M1; i++)
      {
        if (h->xrange[i] != hh->xrange[i])
          {
            printf ("xrange[%d] : %g orig vs %g\n",
                    (int) i, h->xrange[i], hh->xrange[i]);
            status = 1;
          }
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j <= N1; j++)
      {
        if (h->yrange[j] != hh->yrange[j])
          {
            printf ("yrange[%d] : %g orig vs %g\n",
                    (int) j, h->yrange[j], hh->yrange[j]);
            status = 1;
          }
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < M1 * N1; i++)
      {
        if (h->bin[i] != hh->bin[i])
          {
            printf ("bin[%d] : %g orig vs %g\n",
                    (int) i, h->bin[i], hh->bin[i]);
            status = 1;
          }
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i <= M1; i++)
      {
        if (h->xrange[i] != hh->xrange[i])
          {
            printf ("xrange[%d] : %g orig vs %g\n",
                    (int) i, h->xrange[i], hh->xrange[i]);
            status = 1;
          }
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j <= N1; j++)
      {
        if (h->yrange[j] != hh->yrange[j])
          {
            printf ("yrange[%d] : %g orig vs %g\n",
                    (int) j, h->yrange[j], hh->yrange[j]);
            status = 1;
          }
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < M1 * N1; i++)
      {
        if (h->bin[i] != hh->bin[i])
          {
            printf ("bin[%d] : %g orig vs %g\n",
                    (int) i, h->bin[i], hh->bin[i]);
            status = 1;
          }
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
    {
      if (range[i] >= range[i + 1])
        {
          GSL_ERROR_VAL ("histogram bin extremes  must be "
                            "in increasing order", GSL_EDOM, 0);
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i <= n; i++)
    {
      h->range[i] = range[i];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
    {
      h->bin[i] = 0;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 10; i++)
    {
      for(j = 0; j < 10; j++)
        {
          double w = 10.0 * i + j;
          total += w;
          gsl_histogram2d_accumulate (h, 0.1 * i, 0.1 * i, w);
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
      {
        double u = urand();
        double v = urand();
        double x, y;
        status = gsl_histogram2d_pdf_sample (p, u, v, &x, &y);
        status = gsl_histogram2d_increment (hh, x, y);
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 20; i++)
      {
        for(j = 0; j < 20; j++)
          {
            double z = 4 * total * gsl_histogram2d_get (hh, i, j) / (double) N;
            size_t k1, k2;
            double ya;
            double x, xmax, y, ymax;

            gsl_histogram2d_get_xrange (hh, i, &x, &xmax);
            gsl_histogram2d_get_yrange (hh, j, &y, &ymax);

            gsl_histogram2d_find (h, x, y, &k1, &k2);
            ya = gsl_histogram2d_get (h, k1, k2);

            if (ya == 0)
              {
                if (z != 0)
                  {
                    status = 1;
                    printf ("(%d,%d): %g vs %g\n", (int)i, (int)j, z, ya);
                  }
              }
            else
              {
                double err = 1 / sqrt (gsl_histogram2d_get (hh, i, j));
                double sigma = fabs ((z - ya) / (ya * err));
                if (sigma > 3)
                  {
                    status = 1;
                    printf ("%g vs %g err=%g sigma=%g\n", z, ya, err, sigma);
                  }
              }
          }
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i <= (h1->nx); i++)
      {
        if (h1->xrange[i] != h2->xrange[i])
          {
            return 0;
          }
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i <= (h1->ny); i++)
      {
        if (h1->yrange[i] != h2->yrange[i])
          {
            return 0;
          }
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < (h1->nx) * (h1->ny); i++)
    {
      h1->bin[i] += h2->bin[i];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < (h1->nx) * (h1->ny); i++)
    {
      h1->bin[i] -= h2->bin[i];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < (h1->nx) * (h1->ny); i++)
    {
      h1->bin[i] *= h2->bin[i];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < (h1->nx) * (h1->ny); i++)
    {
      h1->bin[i] /= h2->bin[i];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < (h->nx) * (h->ny); i++)
    {
      h->bin[i] *= scale;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < (h->nx) * (h->ny); i++)
    {
      h->bin[i] += shift;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i <= n; i++)
    {
      dest->range[i] = src->range[i];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
    {
      dest->bin[i] = src->bin[i];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
    {
      h->bin[i] = src->bin[i];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i <= n; i++)
    {
      double f1 = ((double) (n-i) / (double) n);
      double f2 = ((double) i / (double) n);
      range[i] = f1 * xmin +  f2 * xmax;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n + 1; i++)
      {
        h->range[i] = i;
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
      {
        h->bin[i] = 0;
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
    {
      h->bin[i] = 0;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i <= n; i++)
    {
      h->range[i] = range[i];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
    {
      h->bin[i] = 0;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
    {
      int status = fprintf (stream, range_format, h->range[i]);

      if (status < 0)
        {
          GSL_ERROR ("fprintf failed", GSL_EFAILED);
        }

      status = putc (' ', stream);

      if (status == EOF)
        {
          GSL_ERROR ("putc failed", GSL_EFAILED);
        }

      status = fprintf (stream, range_format, h->range[i + 1]);

      if (status < 0)
        {
          GSL_ERROR ("fprintf failed", GSL_EFAILED);
        }

      status = putc (' ', stream);

      if (status == EOF)
        {
          GSL_ERROR ("putc failed", GSL_EFAILED);
        }

      status = fprintf (stream, bin_format, h->bin[i]);

      if (status < 0)
        {
          GSL_ERROR ("fprintf failed", GSL_EFAILED);
        }

      status = putc ('\n', stream);

      if (status == EOF)
        {
          GSL_ERROR ("putc failed", GSL_EFAILED);
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
    {
      int status = fscanf (stream,
                           "%lg %lg %lg", h->range + i, &upper,
                           h->bin + i);

      if (status != 3)
        {
          GSL_ERROR ("fscanf failed", GSL_EFAILED);
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nx * ny; i++)
    {
      if (h->bin[i] > max)
        {
          max = h->bin[i];
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nx; i++)
    {
      for(j = 0; j < ny; j++)
        {
          double x = h->bin[i * ny + j];

          if (x > max)
            {
              max = x;
              imax = i;
              jmax = j;
            }
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nx * ny; i++)
    {
      if (h->bin[i] < min)
        {
          min = h->bin[i];
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nx; i++)
    {
      for(j = 0; j < ny; j++)
        {
          double x = h->bin[i * ny + j];

          if (x < min)
            {
              min = x;
              imin = i;
              jmin = j;
            }
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nx; i++)
    {
      for(j = 0; j < ny; j++)
        {
          status = fprintf (stream, range_format, h->xrange[i]);

          if (status < 0)
            {
              GSL_ERROR ("fprintf failed", GSL_EFAILED);
            }

          status = putc (' ', stream);

          if (status == EOF)
            {
              GSL_ERROR ("putc failed", GSL_EFAILED);
            }

          status = fprintf (stream, range_format, h->xrange[i + 1]);

          if (status < 0)
            {
              GSL_ERROR ("fprintf failed", GSL_EFAILED);
            }

          status = putc (' ', stream);

          if (status == EOF)
            {
              GSL_ERROR ("putc failed", GSL_EFAILED);
            }

          status = fprintf (stream, range_format, h->yrange[j]);

          if (status < 0)
            {
              GSL_ERROR ("fprintf failed", GSL_EFAILED);
            }

          status = putc (' ', stream);

          if (status == EOF)
            {
              GSL_ERROR ("putc failed", GSL_EFAILED);
            }

          status = fprintf (stream, range_format, h->yrange[j + 1]);

          if (status < 0)
            {
              GSL_ERROR ("fprintf failed", GSL_EFAILED);
            }

          status = putc (' ', stream);

          if (status == EOF)
            {
              GSL_ERROR ("putc failed", GSL_EFAILED);
            }

          status = fprintf (stream, bin_format, h->bin[i * ny + j]);

          if (status < 0)
            {
              GSL_ERROR ("fprintf failed", GSL_EFAILED);
            }

          status = putc ('\n', stream);

          if (status == EOF)
            {
              GSL_ERROR ("putc failed", GSL_EFAILED);
            }
        }
      status = putc ('\n', stream);

      if (status == EOF)
        {
          GSL_ERROR ("putc failed", GSL_EFAILED);
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nx; i++)
    {
      for(j = 0; j < ny; j++)
        {
          int status = fscanf (stream,
                               "%lg %lg %lg %lg %lg",
                               h->xrange + i, &xupper,
                               h->yrange + j, &yupper,
                               h->bin + i * ny + j);

          if (status != 5)
            {
              GSL_ERROR ("fscanf failed", GSL_EFAILED);
            }
        }
      h->yrange[ny] = yupper;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nx * ny; i++)
    {
      h->bin[i] = 0;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nx; i++)
    {
      double xi = (h->xrange[i + 1] + h->xrange[i]) / 2.0;
      double wi = 0;

      for(j = 0; j < ny; j++)
        {
          double wij = h->bin[i * ny + j];
          if (wij > 0)
            wi += wij;
        }
      if (wi > 0)
        {
          W += wi;
          wmean += (xi - wmean) * (wi / W);
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < ny; j++)
    {
      double yj = (h->yrange[j + 1] + h->yrange[j]) / 2.0;
      double wj = 0;

      for(i = 0; i < nx; i++)
        {
          double wij = h->bin[i * ny + j];
          if (wij > 0)
            wj += wij;
        }

      if (wj > 0)
        {
          W += wj;
          wmean += (yj - wmean) * (wj / W);
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nx; i++)
    {
      double xi = (h->xrange[i + 1] + h->xrange[i]) / 2 - xmean;
      double wi = 0;

      for(j = 0; j < ny; j++)
        {
          double wij = h->bin[i * ny + j];
          if (wij > 0)
            wi += wij;
        }

      if (wi > 0)
        {
          W += wi;
          wvariance += ((xi * xi) - wvariance) * (wi / W);
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < ny; j++)
    {
      double yj = (h->yrange[j + 1] + h->yrange[j]) / 2.0 - ymean;
      double wj = 0;

      for(i = 0; i < nx; i++)
        {
          double wij = h->bin[i * ny + j];
          if (wij > 0)
            wj += wij;
        }
      if (wj > 0)
        {
          W += wj;
          wvariance += ((yj * yj) - wvariance) * (wj / W);
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < ny; j++)
    {
      for(i = 0; i < nx; i++)
        {
          double xi = (h->xrange[i + 1] + h->xrange[i]) / 2.0 - xmean;
          double yj = (h->yrange[j + 1] + h->yrange[j]) / 2.0 - ymean;
          double wij = h->bin[i * ny + j];

          if (wij > 0)
            {
              W += wij;
              wcovariance += ((xi * yj) - wcovariance) * (wij / W);
            }
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
    {
      if (h->bin[i] > max)
        {
          max = h->bin[i];
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < h->n; i++)
    {
      if (h->bin[i] > max)
        {
          max = h->bin[i];
          imax = i;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < h->n; i++)
    {
      if (h->bin[i] < min)
        {
          min = h->bin[i];
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < h->n; i++)
    {
      if (h->bin[i] < min)
        {
          min = h->bin[i];
          imin = i;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(n = -9; n < 10; n++)
      {
        y = gsl_pow_int (-3.14, n);
        y_expected = pow (-3.14, n);
        gsl_test_rel (y, y_expected, 1e-15, "gsl_pow_n(-3.14,%d)", n);
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 10; i++)
      {
        double tol = pow (10, -i);
        int res = gsl_fcmp (x, y, tol);
        gsl_test_int (res, -(i >= 4), "gsl_fcmp(%.5f,%.5f,%g)", x, y, tol);
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 10; i++)
      {
        double tol = pow (10, -i);
        int res = gsl_fcmp (y, x, tol);
        gsl_test_int (res, (i >= 4), "gsl_fcmp(%.5f,%.5f,%g)", y, x, tol);
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLibAddin/Clients/CppInstrumentIn/instrument_in.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for(int i = 4; i < argc; i += 1) {
    vecMaketfiles.push_back(argv[i]);
}

for(unsigned int index = 0; index < vecMaketfiles.size(); ++index) {
    ohObjectLoad("MarketData", vecMaketfiles[index],
        false, OH_NULL, OH_NULL);
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLibAddin/qlo/basketlossmodels.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for(QuantLib::Size i=0; i<recoveryRates.size(); i++)
    usedFactors.push_back(std::vector<QuantLib::Real>(1, 
       std::sqrt(correlation)));

for(QuantLib::Size i=0; i<recoveryRates.size(); i++)
    usedFactors.push_back(std::vector<QuantLib::Real>(1, 
       std::sqrt(correlation)));

for(QuantLib::Size i=0; i< copulaInitVals.size(); i++) 
    initTT.tOrders.push_back(static_cast<QuantLib::Integer>(
        copulaInitVals[i]));

        for(QuantLib::Size i=0; i<recoveryRates.size(); i++)
            usedFactors.push_back(std::vector<QuantLib::Real>(1, 
               factorWeights[0][0]));

        for(QuantLib::Size i=0; i<recoveryRates.size(); i++)
            usedFactors.push_back(std::vector<QuantLib::Real>(1, 
               factorWeights[0][0]));

for(QuantLib::Size i=0; i< copulaInitVals.size(); i++) 
    initTT.tOrders.push_back(static_cast<QuantLib::Integer>(
        copulaInitVals[i]));

        for(QuantLib::Size i=0; i< copulaInitVals.size(); i++) 
            initTT.tOrders.push_back(static_cast<QuantLib::Integer>(
                copulaInitVals[i]));

        for(QuantLib::Size i=0; i<recoveryRates.size(); i++)
            usedFactors.push_back(std::vector<QuantLib::Real>(1, 
               factorWeights[0][0]));

        for(QuantLib::Size i=0; i<2*recoveryRates.size(); i++)
            usedFactors.push_back(std::vector<QuantLib::Real>(1, 
               factorWeights[0][0]));

        for(QuantLib::Size i=0; i<recoveryRates.size(); i++)
            usedFactors.push_back(std::vector<QuantLib::Real>(1, 
               factorWeights[0][0]));

for(QuantLib::Size i=0; i< copulaInitVals.size(); i++) 
    initTT.tOrders.push_back(static_cast<QuantLib::Integer>(
        copulaInitVals[i]));

        for(QuantLib::Size i=0; i<recoveryRates.size(); i++)
            usedFactors.push_back(std::vector<QuantLib::Real>(1, 
               factorWeights[0][0]));

for(QuantLib::Size i=0; i< copulaInitVals.size(); i++) 
    initTT.tOrders.push_back(static_cast<QuantLib::Integer>(
        copulaInitVals[i]));

        for(QuantLib::Size i=0; i<recoveryRates.size(); i++)
            usedFactors.push_back(std::vector<QuantLib::Real>(1, 
               factorWeights[0][0]));

        for(QuantLib::Size i=0; i<recoveryRates.size(); i++)
            usedFactors.push_back(std::vector<QuantLib::Real>(1, 
               factorWeights[0][0]));

for(QuantLib::Size i=0; i< copulaInitVals.size(); i++) 
    initTT.tOrders.push_back(static_cast<QuantLib::Integer>(
        copulaInitVals[i]));

        for(QuantLib::Size i=0; i<recoveryRates.size(); i++)
            usedFactors.push_back(std::vector<QuantLib::Real>(1, 
               factorWeights[0][0]));

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLibAddin/qlo/swaptionvolstructure.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for(QuantLib::Size i=0; i<sabrParameters.rows(); ++i) {
    std::vector<ObjectHandler::property_t> par(numberOfColumn, std::string("N/A"));
    for(QuantLib::Size j=0; j<sabrParameters.columns()-1; ++j) {
       par[j] = sabrParameters[i][j];
    }
    std::ostringstream endCriteria;
    endCriteria << QuantLib::EndCriteria::Type(static_cast<QuantLib::Integer>(sabrParameters[i][numberOfColumn-1]));
    par[numberOfColumn-1] = endCriteria.str();

    sparseSabrParameters.push_back(par);
}

for(QuantLib::Size i=0; i<volCube.rows(); ++i)
{
    std::vector<ObjectHandler::property_t> vol(numberOfColumn, std::string("N/A"));
    for(QuantLib::Size j=0; j<volCube.columns(); ++j)
    {
       vol[j] = volCube[i][j];
    }
    volatilityCube.push_back(vol);
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLibAddin/qlo/bonds.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i<coupons.size(); ++i)
	couponRate[i] = *coupons[i];

for (Size i=0; i<n; ++i) {
    bonds[i]->getLibraryObject(qlBond);
    settlement = qlBond->settlementDate(refDate);
    maturity = qlBond->maturityDate();
    if (settlement<maturity) {
        id = convert2<string>(bonds[i]->propertyValue("OBJECTID"));
        result.push_back(id);
    }
}

for (Size i=0; i<bonds.size(); ++i) {
    bonds[i]->getLibraryObject(qlBond);
    if (maturity==qlBond->maturityDate())
        return convert2<string>(bonds[i]->propertyValue("OBJECTID"));
}

for (Size i=0; i<n; ++i) {
    bonds[i]->getLibraryObject(qlBond);
    maturity = qlBond->maturityDate() ;
    id = convert2<string>(bonds[i]->propertyValue("OBJECTID"));
    bondItems[i] = BondItem(id, maturity);
}

for (Size i=0; i<n; ++i)
    result[i] = bondItems[i].objectID;

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLibAddin/qlo/smilesection.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for(QuantLib::Size i = 0; i<temp.size(); ++i)
    temp[i] = stdDevs[i];

for(QuantLib::Size i = 0; i<temp.size(); ++i)
    temp[i] = stdDevs[i];

   for(QuantLib::Size i = 0; i<temp.size(); ++i)
        temp[i] = volHandles[i];

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLibAddin/qlo/couponvectors.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (QuantLib::Size i=0; i<couponRates.size(); ++i)
	coupons[i] = *couponRates[i];

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLibAddin/qlo/defaultbasket.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for(QuantLib::Size i=0; i<names.size(); i++)
        pool->add(names[i], *issuers[i], contractTriggers[i]);

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLibAddin/qlo/timeseries.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i<values.size(); ++i) {
    // skip null fixings
    if (values[i]!= QuantLib::Null<Real>()) {
        d.push_back(dates[i]);
        v.push_back(values[i]);
    }
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLibAddin/qlo/leg.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (QuantLib::Size i=0; i<amounts.size(); ++i) {
    if (dates[i]!=Date())
        libraryObject_->push_back(shared_ptr<CashFlow>(new
            QuantLib::SimpleCashFlow(amounts[i], dates[i])));
    else
        QL_REQUIRE(amounts[i]==0 || amounts[i]==Null<Real>(),
                   "non-null amount (" << amounts[i] << ") on null date");
}

for (i = pricers.begin(); i != pricers.end(); ++i) {
    ids.push_back((*i)->properties()->objectId());
    shared_ptr<QuantLib::FloatingRateCouponPricer> p;
    (*i)->getLibraryObject(p);
    ql_pricers.push_back(p);
}

for (QuantLib::Size i=0; i<legs.size(); ++i) {
    legs[i]->getLibraryObject(leg);
    libraryObject_->insert(libraryObject_->end(),
                           leg->begin(), leg->end());
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLibAddin/qlo/date.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=1; i<n; ++i)
    out.push_back(IMM::nextDate(out[i-1]+1*Days, mainCycle[i]));

for (Size i=0; i<n; ++i)
    out.push_back(IMM::code(immDates[i]));

for (Size i = 1; i<n; ++i)
    out.push_back(ASX::nextDate(out[i - 1] + 1 * Days, mainCycle[i]));

for (Size i = 0; i<n; ++i)
    out.push_back(ASX::code(asxDates[i]));

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLibAddin/qlo/sequencestatistics.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        for (QuantLib::Size i=0; i<values.rows(); ++i)
            libraryObject_->add(values.row_begin(i),
                                values.row_end(i),
                                w[i]);

        for (QuantLib::Size i=0; i<values.rows(); ++i)
            libraryObject_->add(values.row_begin(i),
                                values.row_end(i));

        for (QuantLib::Size i=0; i<values.rows(); ++i)
            libraryObject_->add(values.row_begin(i),
                                values.row_end(i),
                                w[i]);

        for (QuantLib::Size i=0; i<values.rows(); ++i)
            libraryObject_->add(values.row_begin(i),
                                values.row_end(i));

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLibAddin/qlo/piecewiseyieldcurve.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    for (CallerMap::const_iterator i = callerMap_.begin(); i != callerMap_.end(); ++i)
        delete i->second;

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLibAddin/qlo/quotes.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (QuantLib::Size i=0; i<q.size(); ++i) {
    sq[i] = vector<QuantLib::Handle<QuantLib::SimpleQuote> >(q[i].size());
    for (QuantLib::Size j=0; j<q[i].size(); ++j) {
        boost::shared_ptr<QuantLib::Quote> t(q[i][j].currentLink());
        boost::shared_ptr<QuantLib::SimpleQuote> tt =
            boost::dynamic_pointer_cast<QuantLib::SimpleQuote>(t);
        sq[i][j] = QuantLib::Handle<QuantLib::SimpleQuote>(tt);
    }
}

for (QuantLib::Size i=0; i<n;  ++i) {
    boost::shared_ptr<QuantLib::SimpleQuote> sq = 
        boost::dynamic_pointer_cast<QuantLib::SimpleQuote>(quotes[i].currentLink());
    simpleQuotes[i] = QuantLib::Handle<QuantLib::SimpleQuote>(sq);
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLibAddin/qlo/ratehelpers.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (QuantLib::Size i=0; i<nInstruments; ++i) {
    qlarh = qlarhs[i];
    qlarh->getLibraryObject(qlrh);
    string qlarh_id = convert2<string>(
        qlarh->propertyValue("OBJECTID"));
    bool isFutures = bool(dynamic_pointer_cast<FuturesRateHelper>(qlarh));
    bool isMainFutures = false, isSerialFutures = false;
    if (isFutures) {
        isMainFutures = (qlrh->earliestDate().month() % 3 == 0);
        isSerialFutures = !isMainFutures;
    }
    bool isDepo = bool(dynamic_pointer_cast<DepositRateHelper>(qlarh));
    rhsAll.push_back(RateHelperItem(isMainFutures,
                                    isSerialFutures,
                                    isDepo,
                                    qlarh_id,
                                    priority[i],
                                    qlrh->earliestDate(),
                                    qlrh->latestDate(),
                                    minDist.size()==1 ? minDist[0] : minDist[i]));
}

for (QuantLib::Size i=0; i<nInstruments; ++i) {
    if (rhsAll[i].earliestDate >= evalDate) {
        if (rhsAll[i].isDepo) {                 // Check Depo conditions
            switch (depoInclusionCriteria) {
                case RateHelper::AllDepos:
               // Include all depos
                    rhs.push_back(rhsAll[i]);
                    break;
                case RateHelper::DeposBeforeFirstFuturesStartDate:
                // Include only depos with maturity date before
                // the front Futures start date
                    if (rhsAll[i].latestDate < frontFuturesEarliestDate)
                        rhs.push_back(rhsAll[i]);
                    break;
                case RateHelper::DeposBeforeFirstFuturesStartDatePlusOne:
                // Include only depos with maturity date before
                // the front Futures start date + 1 more Futures
                    if (rhsAll[i].latestDate < frontFuturesEarliestDate) {
                        rhs.push_back(rhsAll[i]);
                    } else {
                        if (depoAfterFrontFuturesAlreadyIncluded == false) {
                            rhs.push_back(rhsAll[i]);
                            depoAfterFrontFuturesAlreadyIncluded = true;
                        }
                    }
                    break;
                case RateHelper::DeposBeforeFirstFuturesExpiryDate:
                // Include only depos with maturity date before
                // the front Futures expiry date
                    if (rhsAll[i].latestDate < frontFuturesLatestDate)
                        rhs.push_back(rhsAll[i]);
                    break;
                default:
                    QL_FAIL("unknown/illegal DepoInclusionCriteria");
            }
        } else if (rhsAll[i].isSerialFutures) {       // Check Serial Futures conditions
            if (serialFuturesCounter<nSerialFutures &&
                   (rhsAll[i].earliestDate-frontFuturesRollingDays >= evalDate)) {
                ++serialFuturesCounter;
                rhs.push_back(rhsAll[i]);
            }
        } else if (rhsAll[i].isMainFutures) {       // Check Main Cycle Futures conditions
            if (mainFuturesCounter<nMainFutures &&
                   (rhsAll[i].earliestDate-frontFuturesRollingDays >= evalDate)) {
                ++mainFuturesCounter;
                rhs.push_back(rhsAll[i]);
            }
        } else {                                // No conditions for other instruments
            rhs.push_back(rhsAll[i]);
        }
    }
}

for (k = rhs.begin(); k != rhs.end(); ++k)
    result.push_back(k->objectID);

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLibAddin/qlo/randomsequencegenerator.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (long i=0 ; i < samples ; ++i)
    rtn.push_back(nextSequence());

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLibAddin/qlo/interpolation.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i<n; ++i)
    pairs[i] = std::make_pair(x[i], yh[i]);

for (j=pairs.begin()+1; j<pairs.end(); ++j) {
    if (x_.back() == j->first) {
        QL_ENSURE(yh_.back() == j->second,
                  "duplicated x value (" << j->first <<
                  ") with different y values");
    } else {
        x_.push_back(j->first);
        yh_.push_back(j->second);
        registerWith(yh_.back());
        yh_.back()->isValid() ? y_.push_back(yh_.back()->value())
                              : y_.push_back(1.0);
    }
}

for (Size i=0; i<n_; ++i)
    y_[i] = yh_[i]->value();

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLibAddin/qlo/cmsmarket.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i<cmsMarket.rows(); ++i)
    for(Size j=0; j<cmsMarket.columns(); ++j)
       result[i+1][j] = cmsMarket[i][j];

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLibAddin/qlo/flowanalysis.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (QuantLib::Size i=0; i<leg.size(); ++i) {
    if (leg[i]->date()>d)
    leg[i]->accept(generator);
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLibAddin/qlo/swap.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (QuantLib::Size i=0; i<legPtrs.size(); ++i) {
    legPtrs[i]->getLibraryObject(qlLeg);
    legs[i] = *qlLeg;
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLibAddin/qlo/index.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (QuantLib::Size i=0; i<values.size(); ++i) {
    // skip null fixings
    if (values[i]!=QuantLib::Null<QuantLib::Real>()) {
        d.push_back(dates[i]);
        v.push_back(values[i]);
    }
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLibAddin/qlo/serialization/processor.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for(ObjectHandler::HandlesList::iterator i = handles.begin(); i != handles.end(); ++i) {
    boost::dynamic_pointer_cast<QuantLibAddin::RelinkableHandle>(i->second)->linkTo(i->first);
}

    for (std::vector<std::string>::const_iterator i = legs.begin(); i!= legs.end(); ++i) {
        OH_GET_OBJECT(leg, *i, QuantLibAddin::FloatingRateCouponPricer)
        legs2.push_back(leg);
    }

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLibAddin/qlo/conversions/conversions.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (std::vector<QuantLib::Date>::const_iterator i = v.begin(); i != v.end(); ++i)
    ret.push_back(i->serialNumber());

for (std::vector<QuantLib::Period>::const_iterator i = v.begin(); i != v.end(); ++i)
    ret.push_back(libraryToScalar(*i));

for (std::vector<QuantLib::Real>::const_iterator i = v.begin(); i != v.end(); ++i)
    ret.push_back(*i);

for (int i=0; i<rows; ++i)
    for (int j=0; j<cols; ++j)
        m[i][j] = vv[i][j];

for(unsigned int r=0; r<m.rows(); ++r) {
    std::vector<double> v;
    for(unsigned int c=0; c<m.columns(); ++c) {
        v.push_back(m[r][c]);
    }
    vv.push_back(v);
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLibAddin/Addins/Guile/guileutils.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (std::size_t i=v.size() ; --i != std::size_t(-1) ; )
    value = gh_cons(gh_long2scm(v[i]), value);

for (std::size_t i=v.size() ; --i != std::size_t(-1) ; )
    value = gh_cons(gh_double2scm(v[i]), value);

for (std::size_t i = properties.size() ; --i != std::size_t(-1) ; ) {
SCM dottedPair = anyToDottedPair(properties[i]);
rtn = gh_cons(dottedPair, rtn);
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLibAddin/Addins/Calc_old/conversions.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (int i=0; i<in.getLength(); ++i)
for (int j=0; j<in[i].getLength(); ++j)
    ret.push_back(QuantLib::Date(in[i][j]));

for (int i=0; i<in.getLength(); ++i) {
for (int j=0; j<in[i].getLength(); ++j) {
    std::string s;
    calcToScalar(s, in[i][j]);
    ret.push_back(s);
}
}

for (int i=0; i<rows; ++i) {
SEQ(double) row = in[i];
for (int j=0; j<cols; ++j) {
    m[i][j] = row[j];
}
}

for (unsigned int i=0; i<v.size(); ++i) {
SEQ(sal_Int32) s(1);
s[0] = v[i].serialNumber();
ret[i] = s;
}

for (unsigned int i=0; i<in.size(); ++i) {
SEQ(double) s(1);
s[0] = in[i];
ret[i] = s;
}

for (unsigned int i=0; i<in.rows(); ++i) {
SEQ(double) s(in.columns());
for (unsigned int j=0; j<in.columns(); ++j) {
    s[j] = in[i][j];
}
ret[i] = s;
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLibAddin/Addins/Calc_old/calcutils.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (unsigned int i=0; i<v.size(); ++i) {
    SEQ( ANY ) s(1);
    s[0] = CSS::uno::makeAny(v[i]);
    ss[i] = s;
}

for (unsigned int i=0; i<v.size(); ++i) {
    SEQ( ANY ) s(1);
    s[0] = CSS::uno::makeAny(v[i]);
    ss[i] = s;
}

for (unsigned int i=0; i<v.size(); ++i) {
    SEQ( ANY ) s(1);
    sal_Int32 b = static_cast< sal_Int32 >(v[i]);
    s[0] = CSS::uno::makeAny(b);
    ss[i] = s;
}

for (unsigned int i=0; i<v.size(); ++i) {
    SEQ( ANY ) s(1);
    s[0] = CSS::uno::makeAny(STRFROMASCII(v[i].c_str()));
    ss[i] = s;
}

for (unsigned int i=0; i<v.size(); ++i) {
    SEQ( ANY ) s(1);
    scalarToCalc(s[0], v[i]);
    ss[i] = s;
}

for (unsigned int i=0; i<vv.size(); ++i) {
    std::vector< long > v = vv[i];
    SEQ( ANY ) s(v.size());
    for (unsigned int j=0; j<v.size(); ++j)
        s[j] = CSS::uno::makeAny(v[j]);
    ss[i] = s;
}

for (unsigned int i=0; i<vv.size(); ++i) {
    std::vector< double > v = vv[i];
    SEQ( ANY ) s(v.size());
    for (unsigned int j=0; j<v.size(); ++j)
        s[j] = CSS::uno::makeAny(v[j]);
    ss[i] = s;
}

for (unsigned int i=0; i<vv.size(); ++i) {
    std::vector< bool > v = vv[i];
    SEQ( ANY ) s(v.size());
    for (unsigned int j=0; j<v.size(); ++j) {
        sal_Int32 b = static_cast< sal_Int32 >(v[j]);
        s[j] = CSS::uno::makeAny(b);
    }
    ss[i] = s;
}

for (unsigned int i=0; i<vv.size(); ++i) {
    std::vector< std::string > v = vv[i];
    SEQ( ANY ) s(v.size());
    for (unsigned int j=0; j<v.size(); ++j)
        s[j] = CSS::uno::makeAny(STRFROMASCII(v[j].c_str()));
    ss[i] = s;
}

for (unsigned int i=0; i<vv.size(); ++i) {
    std::vector< boost::any > v = vv[i];
    SEQ( ANY ) s(v.size());
    for (unsigned int j=0; j<v.size(); ++j)
        scalarToCalc(s[j], v[j]);
    ss[i] = s;
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLibAddin/Addins/Calc/conversions.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (unsigned int i=0; i<v.size(); ++i) {
    SEQ( ANY ) s(1);
    s[0] = CSS::uno::makeAny(v[i]);
    ss[i] = s;
}

for (unsigned int i=0; i<v.size(); ++i) {
    SEQ( ANY ) s(1);
    s[0] = CSS::uno::makeAny(v[i]);
    ss[i] = s;
}

for (unsigned int i=0; i<v.size(); ++i) {
    SEQ( ANY ) s(1);
    sal_Int32 b = static_cast< sal_Int32 >(v[i]);
    s[0] = CSS::uno::makeAny(b);
    ss[i] = s;
}

for (unsigned int i=0; i<v.size(); ++i) {
    SEQ( ANY ) s(1);
    s[0] = CSS::uno::makeAny(STRFROMASCII(v[i].c_str()));
    ss[i] = s;
}

for (unsigned int i=0; i<v.size(); ++i) {
    SEQ( ANY ) s(1);
    scalarToCalc(s[0], v[i]);
    ss[i] = s;
}

for (unsigned int i=0; i<vv.size(); ++i) {
    std::vector< long > v = vv[i];
    SEQ( ANY ) s(v.size());
    for (unsigned int j=0; j<v.size(); ++j)
        s[j] = CSS::uno::makeAny(v[j]);
    ss[i] = s;
}

for (unsigned int i=0; i<vv.size(); ++i) {
    std::vector< double > v = vv[i];
    SEQ( ANY ) s(v.size());
    for (unsigned int j=0; j<v.size(); ++j)
        s[j] = CSS::uno::makeAny(v[j]);
    ss[i] = s;
}

for (unsigned int i=0; i<vv.size(); ++i) {
    std::vector< bool > v = vv[i];
    SEQ( ANY ) s(v.size());
    for (unsigned int j=0; j<v.size(); ++j) {
        sal_Int32 b = static_cast< sal_Int32 >(v[j]);
        s[j] = CSS::uno::makeAny(b);
    }
    ss[i] = s;
}

for (unsigned int i=0; i<vv.size(); ++i) {
    std::vector< std::string > v = vv[i];
    SEQ( ANY ) s(v.size());
    for (unsigned int j=0; j<v.size(); ++j)
        s[j] = CSS::uno::makeAny(STRFROMASCII(v[j].c_str()));
    ss[i] = s;
}

for (unsigned int i=0; i<vv.size(); ++i) {
    std::vector< boost::any > v = vv[i];
    SEQ( ANY ) s(v.size());
    for (unsigned int j=0; j<v.size(); ++j)
        scalarToCalc(s[j], v[j]);
    ss[i] = s;
}

for (int i=0; i<ss.getLength(); ++i) {
for (int j=0; j<ss[i].getLength(); ++j) {
    QuantLib::Date temp;
    calcToScalar(temp, ss[i][j]);
    ret.push_back(temp);
}
}

for (int i=0; i<ss.getLength(); ++i) {
for (int j=0; j<ss[i].getLength(); ++j) {
    bool temp;
    calcToScalar(temp, ss[i][j]);
    ret.push_back(temp);
}
}

for (int i=0; i<ss.getLength(); ++i) {
for (int j=0; j<ss[i].getLength(); ++j) {
    double temp;
    calcToScalar(temp, ss[i][j]);
    ret.push_back(temp);
}
}

for (int i=0; i<ss.getLength(); ++i) {
for (int j=0; j<ss[i].getLength(); ++j) {
    ObjectHandler::property_t temp;
    calcToScalar(temp, ss[i][j]);
    ret.push_back(temp);
}
}

for (int i=0; i<ss.getLength(); ++i) {
for (int j=0; j<ss[i].getLength(); ++j) {
    std::string temp;
    calcToScalar(temp, ss[i][j]);
    ret.push_back(temp);
}
}

for (unsigned int i=0; i<v.size(); ++i) {
SEQ( sal_Int32 ) s(1);
scalarToCalc(s[0], v[i]);
ret[i] = s;
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLibAddin/Addins/Calc/calcutils.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (unsigned int i=0; i<v.size(); ++i) {
    SEQ( ANY ) s(1);
    s[0] = CSS::uno::makeAny(v[i]);
    ss[i] = s;
}

for (unsigned int i=0; i<v.size(); ++i) {
    SEQ( ANY ) s(1);
    s[0] = CSS::uno::makeAny(v[i]);
    ss[i] = s;
}

for (unsigned int i=0; i<v.size(); ++i) {
    SEQ( ANY ) s(1);
    sal_Int32 b = static_cast< sal_Int32 >(v[i]);
    s[0] = CSS::uno::makeAny(b);
    ss[i] = s;
}

for (unsigned int i=0; i<v.size(); ++i) {
    SEQ( ANY ) s(1);
    s[0] = CSS::uno::makeAny(STRFROMASCII(v[i].c_str()));
    ss[i] = s;
}

for (unsigned int i=0; i<v.size(); ++i) {
    SEQ( ANY ) s(1);
    scalarToCalc(s[0], v[i]);
    ss[i] = s;
}

for (unsigned int i=0; i<vv.size(); ++i) {
    std::vector< long > v = vv[i];
    SEQ( ANY ) s(v.size());
    for (unsigned int j=0; j<v.size(); ++j)
        s[j] = CSS::uno::makeAny(v[j]);
    ss[i] = s;
}

for (unsigned int i=0; i<vv.size(); ++i) {
    std::vector< double > v = vv[i];
    SEQ( ANY ) s(v.size());
    for (unsigned int j=0; j<v.size(); ++j)
        s[j] = CSS::uno::makeAny(v[j]);
    ss[i] = s;
}

for (unsigned int i=0; i<vv.size(); ++i) {
    std::vector< bool > v = vv[i];
    SEQ( ANY ) s(v.size());
    for (unsigned int j=0; j<v.size(); ++j) {
        sal_Int32 b = static_cast< sal_Int32 >(v[j]);
        s[j] = CSS::uno::makeAny(b);
    }
    ss[i] = s;
}

for (unsigned int i=0; i<vv.size(); ++i) {
    std::vector< std::string > v = vv[i];
    SEQ( ANY ) s(v.size());
    for (unsigned int j=0; j<v.size(); ++j)
        s[j] = CSS::uno::makeAny(STRFROMASCII(v[j].c_str()));
    ss[i] = s;
}

for (unsigned int i=0; i<vv.size(); ++i) {
    std::vector< boost::any > v = vv[i];
    SEQ( ANY ) s(v.size());
    for (unsigned int j=0; j<v.size(); ++j)
        scalarToCalc(s[j], v[j]);
    ss[i] = s;
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLibAddin/Addins/Calc/qladdin.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for( n1 = 0 ; n1 < nE1 ; n1++ ) {
Sequence<long> rList = temp[ n1 ];
nE2 = rList.getLength();
for( n2 = 0 ; n2 < nE2 ; n2++ )
    rList[ n2 ] += 4;
temp[n1]=rList;
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLibAddin/Addins/Calc/calcaddins.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for( n1 = 0 ; n1 < nE1 ; n1++ ) {
Sequence<long> rList = temp[ n1 ];
nE2 = rList.getLength();
for( n2 = 0 ; n2 < nE2 ; n2++ )
    rList[ n2 ] += 4;
temp[n1]=rList;
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/Docs/Examples/history_iterators.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (i++; i!=end; i++)
if (i->value() > max->value())
max = i;

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/inflationcapfloor.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i<N; i++) {
    Date maturity = iiData[i].date;
    Handle<Quote> quote(boost::shared_ptr<Quote>(
            new SimpleQuote(iiData[i].rate/100.0)));
    boost::shared_ptr<BootstrapHelper<T> > anInstrument(new U(
            quote, observationLag, maturity,
            calendar, bdc, dc, ii));
    instruments.push_back(anInstrument);
}

    for (Size i=0; i<rpiSchedule.size();i++) {
        iir->addFixing(rpiSchedule[i], fixData[i]);
    }

for (Size whichPricer = 0; whichPricer < 3; whichPricer++) {
for (Size i=0; i<LENGTH(lengths); i++) {
for (Size j=0; j<LENGTH(cap_rates); j++) {
    for (Size k=0; k<LENGTH(floor_rates); k++) {
        for (Size l=0; l<LENGTH(vols); l++) {

            Leg leg = vars.makeYoYLeg(vars.evaluationDate,lengths[i]);

            boost::shared_ptr<YoYInflationCapFloor> cap
            = vars.makeYoYCapFloor(YoYInflationCapFloor::Cap,
                                   leg, cap_rates[j], vols[l], whichPricer);

            boost::shared_ptr<YoYInflationCapFloor> floor
            = vars.makeYoYCapFloor(YoYInflationCapFloor::Floor,
                                   leg, floor_rates[k], vols[l], whichPricer);

            YoYInflationCollar collar(leg,std::vector<Rate>(1,cap_rates[j]),
                          std::vector<Rate>(1,floor_rates[k]));
            collar.setPricingEngine(vars.makeEngine(vols[l], whichPricer));

            if (std::fabs((cap->NPV()-floor->NPV())-collar.NPV()) > 1e-6) {
                BOOST_FAIL(
                           "inconsistency between cap, floor and collar:\n"
                           << "    length:       " << lengths[i] << " years\n"
                           << "    volatility:   " << io::volatility(vols[l]) << "\n"
                           << "    cap value:    " << cap->NPV()
                           << " at strike: " << io::rate(cap_rates[j]) << "\n"
                           << "    floor value:  " << floor->NPV()
                           << " at strike: " << io::rate(floor_rates[k]) << "\n"
                           << "    collar value: " << collar.NPV());


                // test re-composition by optionlets, N.B. ONE per year
                Real capletsNPV = 0.0;
                std::vector<boost::shared_ptr<YoYInflationCapFloor> > caplets;
                for (Integer m=0; m<lengths[i]*1; m++) {
                    caplets.push_back(cap->optionlet(m));
                    caplets[m]->setPricingEngine(vars.makeEngine(vols[l], whichPricer));
                    capletsNPV += caplets[m]->NPV();
                }

                if (std::fabs(cap->NPV() - capletsNPV) > 1e-6) {
                    BOOST_FAIL(
                               "sum of caplet NPVs does not equal cap NPV:\n"
                               << "    length:       " << lengths[i] << " years\n"
                               << "    volatility:   " << io::volatility(vols[l]) << "\n"
                               << "    cap value:    " << cap->NPV()
                               << " at strike: " << io::rate(cap_rates[j]) << "\n"
                               << "    sum of caplets value:  " << capletsNPV
                               << " at strike (first): " << io::rate(caplets[0]->capRates()[0]) << "\n"
                               );
                }

                Real floorletsNPV = 0.0;
                std::vector<boost::shared_ptr<YoYInflationCapFloor> > floorlets;
                for (Integer m=0; m<lengths[i]*1; m++) {
                    floorlets.push_back(floor->optionlet(m));
                    floorlets[m]->setPricingEngine(vars.makeEngine(vols[l], whichPricer));
                    floorletsNPV += floorlets[m]->NPV();
                }

                if (std::fabs(floor->NPV() - floorletsNPV) > 1e-6) {
                    BOOST_FAIL(
                               "sum of floorlet NPVs does not equal floor NPV:\n"
                               << "    length:       " << lengths[i] << " years\n"
                               << "    volatility:   " << io::volatility(vols[l]) << "\n"
                               << "    cap value:    " << floor->NPV()
                               << " at strike: " << io::rate(floor_rates[j]) << "\n"
                               << "    sum of floorlets value:  " << floorletsNPV
                               << " at strike (first): " << io::rate(floorlets[0]->floorRates()[0]) << "\n"
                               );
                }

                Real collarletsNPV = 0.0;
                std::vector<boost::shared_ptr<YoYInflationCapFloor> > collarlets;
                for (Integer m=0; m<lengths[i]*1; m++) {
                    collarlets.push_back(collar.optionlet(m));
                    collarlets[m]->setPricingEngine(vars.makeEngine(vols[l], whichPricer));
                    collarletsNPV += collarlets[m]->NPV();
                }

                if (std::fabs(collar.NPV() - collarletsNPV) > 1e-6) {
                    BOOST_FAIL(
                               "sum of collarlet NPVs does not equal floor NPV:\n"
                               << "    length:       " << lengths[i] << " years\n"
                               << "    volatility:   " << io::volatility(vols[l]) << "\n"
                               << "    cap value:    " << collar.NPV()
                               << " at strike floor: " << io::rate(floor_rates[j])
                               << " at strike cap: " << io::rate(cap_rates[j]) << "\n"
                               << "    sum of collarlets value:  " << collarletsNPV
                               << " at strike floor (first): " << io::rate(collarlets[0]->floorRates()[0])
                               << " at strike cap (first): " << io::rate(collarlets[0]->capRates()[0]) << "\n"
                               );
                }




            }
        }
    }
}
}
} // pricer loop

for (Size whichPricer = 0; whichPricer < 3; whichPricer++) {
for (Size i=0; i<LENGTH(lengths); i++) {
    for (Size j=0; j<LENGTH(strikes); j++) {
        for (Size k=0; k<LENGTH(vols); k++) {

            Leg leg = vars.makeYoYLeg(vars.evaluationDate,lengths[i]);

            boost::shared_ptr<Instrument> cap
            = vars.makeYoYCapFloor(YoYInflationCapFloor::Cap,
                               leg, strikes[j], vols[k], whichPricer);

            boost::shared_ptr<Instrument> floor
            = vars.makeYoYCapFloor(YoYInflationCapFloor::Floor,
                               leg, strikes[j], vols[k], whichPricer);

            Date from = vars.nominalTS->referenceDate();
            Date to = from+lengths[i]*Years;
            Schedule yoySchedule = MakeSchedule().from(from).to(to)
            .withTenor(1*Years)
            .withCalendar(UnitedKingdom())
            .withConvention(Unadjusted)
            .backwards()
            ;

            YearOnYearInflationSwap swap(YearOnYearInflationSwap::Payer,
                                        1000000.0,
                                        yoySchedule,//fixed schedule, but same as yoy
                                        strikes[j],
                                        vars.dc,
                                        yoySchedule,
                                        vars.iir,
                                        vars.observationLag,
                                        0.0,        //spread on index
                                        vars.dc,
                                        UnitedKingdom());

            Handle<YieldTermStructure> hTS(vars.nominalTS);
            boost::shared_ptr<PricingEngine> sppe(new DiscountingSwapEngine(hTS));
            swap.setPricingEngine(sppe);

            // N.B. nominals are 10e6
            if (std::fabs((cap->NPV()-floor->NPV()) - swap.NPV()) > 1.0e-6) {
                BOOST_FAIL(
                       "put/call parity violated:\n"
                       << "    length:      " << lengths[i] << " years\n"
                       << "    volatility:  " << io::volatility(vols[k]) << "\n"
                       << "    strike:      " << io::rate(strikes[j]) << "\n"
                       << "    cap value:   " << cap->NPV() << "\n"
                       << "    floor value: " << floor->NPV() << "\n"
                       << "    swap value:  " << swap.NPV());
            }
        }
    }
}
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/marketmodel_smmcapletcalibration.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=1; i<dates.size(); ++i)
    rateTimes_[i-1] = dayCounter_.yearFraction(todaysDate_, dates[i]);

for (Size i=1; i<rateTimes_.size(); ++i)
    accruals_[i-1] = rateTimes_[i] - rateTimes_[i-1];

for (Size i=0; i<todaysForwards_.size(); ++i) {
    todaysForwards_[i] = 0.03 + 0.0025*i;
    //todaysForwards_[i] = 0.03;
}

for (Size i=1; i<rateTimes_.size(); ++i)
    todaysDiscounts_[i] = todaysDiscounts_[i-1] /
        (1.0+todaysForwards_[i-1]*accruals_[i-1]);

for (Size i=0; i<todaysSwaps_.size(); i++) {
    //    swaptionDisplacedVols[i] = todaysSwaps[i]*mktSwaptionVols[i]/
    //                              (todaysSwaps[i]+displacement);
    //    swaptionVols[i]= mktSwaptionVols[i];
    //    capletDisplacedVols[i] = todaysForwards[i]*mktCapletVols[i]/
    //                            (todaysForwards[i]+displacement);
    capletVols_[i]= mktCapletVols[i];
}

for (Size i=0; i<numberOfRates; ++i) {
swapVariances[i] = boost::shared_ptr<PiecewiseConstantVariance>(new
    PiecewiseConstantAbcdVariance(a_, b_, c_, d_,
                                  i, rateTimes_));
}

for (Size i=0; i<numberOfRates; ++i) {
capletVols[i] = std::sqrt(capletTotCovariance[i][i]/rateTimes_[i]);
}

for (Size i=0; i<numberOfRates; ++i) {
Volatility expSwaptionVol = swapVariances[i]->totalVolatility(i);
swapTerminalCovariance += swapPseudoRoots[i] * transpose(swapPseudoRoots[i]);
Volatility swaptionVol = std::sqrt(swapTerminalCovariance[i][i]/rateTimes_[i]);
error = std::fabs(swaptionVol-expSwaptionVol);
if (error>swapTolerance)
    BOOST_ERROR("failed to reproduce " << io::ordinal(i+1) << " swaption vol:"
                "\n expected:  " << io::rate(expSwaptionVol) <<
                "\n realized:  " << io::rate(swaptionVol) <<
                "\n error:     " << error <<
                "\n tolerance: " << swapTolerance);
}

for (Size i=0; i<numberOfRates; ++i) {
error = std::fabs(capletVols[i]-capletVols_[i]);
if (error>capletTolerance)
    BOOST_ERROR("failed to reproduce " << io::ordinal(i+1) << " caplet vol:"
                "\n expected:         " << io::rate(capletVols_[i]) <<
                "\n realized:         " << io::rate(capletVols[i]) <<
                "\n percentage error: " << error/capletVols_[i] <<
                "\n error:            " << error <<
                "\n tolerance:        " << capletTolerance);
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/inflationcapflooredcoupon.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i<N; i++) {
    Date maturity = iiData[i].date;
    Handle<Quote> quote(boost::shared_ptr<Quote>(
                    new SimpleQuote(iiData[i].rate/100.0)));
    boost::shared_ptr<BootstrapHelper<T> > anInstrument(new U(
                    quote, observationLag, maturity,
                    calendar, bdc, dc, ii));
    instruments.push_back(anInstrument);
}

    for (Size i=0; i<rpiSchedule.size();i++) {
        iir->addFixing(rpiSchedule[i], fixData[i]);
    }

    for(Size i=0; i<yoyLeg.size(); i++) {
        boost::dynamic_pointer_cast<YoYInflationCoupon>(yoyLeg[i])->setPricer(pricer);
    }

for (Size whichPricer = 0; whichPricer < 3; whichPricer++) {
for (Size i=0; i<LENGTH(lengths); i++) {
    for (Size j=0; j<LENGTH(strikes); j++) {
        for (Size k=0; k<LENGTH(vols); k++) {

            Leg leg = vars.makeYoYLeg(vars.evaluationDate,lengths[i]);

            boost::shared_ptr<Instrument> cap
            = vars.makeYoYCapFloor(YoYInflationCapFloor::Cap,
                                   leg, strikes[j], vols[k], whichPricer);

            boost::shared_ptr<Instrument> floor
            = vars.makeYoYCapFloor(YoYInflationCapFloor::Floor,
                                   leg, strikes[j], vols[k], whichPricer);

            Date from = vars.nominalTS->referenceDate();
            Date to = from+lengths[i]*Years;
            Schedule yoySchedule = MakeSchedule().from(from).to(to)
            .withTenor(1*Years)
            .withCalendar(UnitedKingdom())
            .withConvention(Unadjusted)
            .backwards()
            ;

            YearOnYearInflationSwap swap(YearOnYearInflationSwap::Payer,
                                            1000000.0,
                                            yoySchedule,//fixed schedule, but same as yoy
                                            0.0,//strikes[j],
                                            vars.dc,
                                            yoySchedule,
                                            vars.iir,
                                            vars.observationLag,
                                            0.0,        //spread on index
                                            vars.dc,
                                            UnitedKingdom());

            Handle<YieldTermStructure> hTS(vars.nominalTS);
            boost::shared_ptr<PricingEngine> sppe(new DiscountingSwapEngine(hTS));
            swap.setPricingEngine(sppe);

            Leg leg2 = vars.makeYoYCapFlooredLeg(whichPricer, from,
                                                 lengths[i],
                                                 std::vector<Rate>(lengths[i],strikes[j]),//cap
                                                 std::vector<Rate>(),//floor
                                                 vols[k],
                                                 1.0,   // gearing
                                                 0.0);// spread

            Leg leg3 = vars.makeYoYCapFlooredLeg(whichPricer, from,
                                                 lengths[i],
                                                 std::vector<Rate>(),// cap
                                                 std::vector<Rate>(lengths[i],strikes[j]),//floor
                                                 vols[k],
                                                 1.0,   // gearing
                                                 0.0);// spread

            // N.B. nominals are 10e6
            Real capped = CashFlows::npv(leg2,(**vars.nominalTS),false);
            if ( fabs(capped - (swap.NPV() - cap->NPV())) > 1.0e-6) {
                BOOST_FAIL(
                           "capped coupon != swap(0) - cap:\n"
                           << "    length:      " << lengths[i] << " years\n"
                           << "    volatility:  " << io::volatility(vols[k]) << "\n"
                           << "    strike:      " << io::rate(strikes[j]) << "\n"
                           << "    cap value:   " << cap->NPV() << "\n"
                           << "    swap value:  " << swap.NPV() << "\n"
                           << "   capped coupon " << capped);
            }


            // N.B. nominals are 10e6
            Real floored = CashFlows::npv(leg3,(**vars.nominalTS),false);
            if ( fabs(floored - (swap.NPV() + floor->NPV())) > 1.0e-6) {
                BOOST_FAIL(
                           "floored coupon != swap(0) + floor :\n"
                           << "    length:      " << lengths[i] << " years\n"
                           << "    volatility:  " << io::volatility(vols[k]) << "\n"
                           << "    strike:      " << io::rate(strikes[j]) << "\n"
                           << "    floor value: " << floor->NPV() << "\n"
                           << "    swap value:  " << swap.NPV() << "\n"
                           << "  floored coupon " << floored);
            }

        }
    }
}
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/libormarketmodel.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i < 9; ++i) {
    capletVols.push_back(vols[i]/100);
    dates.push_back(process->fixingDates()[i+1]);
}

for (i=0; i<size; ++i) {
for (Size j=0; j<size; ++j) {
    if (std::fabs(recon[i][j]) > tolerance)
        BOOST_ERROR("Failed to reproduce correlation matrix"
                    << "\n    calculated: " << recon[i][j]
                    << "\n    expected:   " << 0);
}
}

for (i=0; i<size; ++i) {
fixingTimes[i] = 0.5*i;
}

for (Real t=0; t<4.6; t+=0.31) {
recon = covarProxy->covariance(t)
    - covarProxy->diffusion(t)*transpose(covarProxy->diffusion(t));

for (Size i=0; i<size; ++i) {
    for (Size j=0; j<size; ++j) {
        if (std::fabs(recon[i][j]) > tolerance)
            BOOST_ERROR("Failed to reproduce correlation matrix"
                        << "\n    calculated: " << recon[i][j]
                        << "\n    expected:   " << 0);
    }
}

Array volatility = volaModel->volatility(t);

for (Size k=0; k<size; ++k) {
    Real expected = 0;
    if (k>2*t) {
        const Real T = fixingTimes[k];
        expected=(a*(T-t)+d)*std::exp(-b*(T-t)) + c;
    }

    if (std::fabs(expected - volatility[k]) > tolerance)
        BOOST_ERROR("Failed to reproduce volatities"
                    << "\n    calculated: " << volatility[k]
                    << "\n    expected:   " << expected);
}
}

for (i=2; i < size; ++i) {
const Period maturity = i*index->tenor();
Handle<Quote> capVol(
    boost::shared_ptr<Quote>(new SimpleQuote(capVols[i-2])));

boost::shared_ptr<CalibrationHelper> caphelper(
    new CapHelper(maturity, capVol, index, Annual,
                  index->dayCounter(), true, termStructure,
                  CalibrationHelper::ImpliedVolError));

caphelper->setPricingEngine(boost::shared_ptr<PricingEngine>(
                   new AnalyticCapFloorEngine(model, termStructure)));

calibrationHelper.push_back(caphelper);

if (i<= size/2) {
    // add a few swaptions to test swaption calibration as well
    for (Size j=1; j <= size/2; ++j) {
        const Period len = j*index->tenor();
        Handle<Quote> swaptionVol(
            boost::shared_ptr<Quote>(
                new SimpleQuote(swaptionVols[swapVolIndex++])));

        boost::shared_ptr<CalibrationHelper> swaptionHelper(
            new SwaptionHelper(maturity, len, swaptionVol, index,
                               index->tenor(), dayCounter,
                               index->dayCounter(),
                               termStructure,
                               CalibrationHelper::ImpliedVolError));

        swaptionHelper->setPricingEngine(
             boost::shared_ptr<PricingEngine>(
                         new LfmSwaptionEngine(model,termStructure)));

        calibrationHelper.push_back(swaptionHelper);
    }
}
}

for (i=0; i<calibrationHelper.size(); ++i) {
Real diff = calibrationHelper[i]->calibrationError();
calculated += diff*diff;
}

for (i=0; i < tmp.size(); ++i) {
location.push_back(
              std::find(grid.begin(),grid.end(),tmp[i])-grid.begin());
}

for (i=1; i < size; ++i) {
for (Size j=1; j <= size-i; ++j) {
    Date fwdStart    = settlement + Period(6*i, Months);
    Date fwdMaturity = fwdStart + Period(6*j, Months);

    Schedule schedule(fwdStart, fwdMaturity, index->tenor(), calendar,
                       convention, convention, DateGeneration::Forward, false);

    Rate swapRate  = 0.0404;
    boost::shared_ptr<VanillaSwap> forwardSwap(
        new VanillaSwap(VanillaSwap::Receiver, 1.0,
                        schedule, swapRate, dayCounter,
                        schedule, index, 0.0, index->dayCounter()));
    forwardSwap->setPricingEngine(boost::shared_ptr<PricingEngine>(
        new DiscountingSwapEngine(index->forwardingTermStructure())));

    // check forward pricing first
    const Real expected = forwardSwap->fairRate();
    const Real calculated = liborModel->S_0(i-1,i+j-1);

    if (std::fabs(expected - calculated) > tolerance)
        BOOST_ERROR("Failed to reproduce fair forward swap rate"
                    << "\n    calculated: " << calculated
                    << "\n    expected:   " << expected);

    swapRate = forwardSwap->fairRate();
    forwardSwap = boost::shared_ptr<VanillaSwap>(
        new VanillaSwap(VanillaSwap::Receiver, 1.0,
                        schedule, swapRate, dayCounter,
                        schedule, index, 0.0, index->dayCounter()));
    forwardSwap->setPricingEngine(boost::shared_ptr<PricingEngine>(
        new DiscountingSwapEngine(index->forwardingTermStructure())));

    if (i == j && i<=size/2) {
        boost::shared_ptr<PricingEngine> engine(
             new LfmSwaptionEngine(liborModel,
                                   index->forwardingTermStructure()));
        boost::shared_ptr<Exercise> exercise(
            new EuropeanExercise(process->fixingDates()[i]));

        boost::shared_ptr<Swaption> swaption(
            new Swaption(forwardSwap, exercise));
        swaption->setPricingEngine(engine);

        GeneralStatistics stat;

        for (Size n=0; n<nrTrails; ++n) {
            sample_type path = (n%2) ? generator.antithetic()
                                     : generator.next();

            std::vector<Rate> rates(size);
            for (Size k=0; k<process->size(); ++k) {
                rates[k] = path.value[k][location[i]];
            }
            std::vector<DiscountFactor> dis =
                process->discountBond(rates);

            Real npv=0.0;
            for (Size m=i; m < i+j; ++m) {
                npv += (swapRate - rates[m])
                       * (  process->accrualEndTimes()[m]
                          - process->accrualStartTimes()[m])*dis[m];
            }
            stat.add(std::max(npv, 0.0));
        }

        if (std::fabs(swaption->NPV() - stat.mean())
            > stat.errorEstimate()*2.35)
            BOOST_ERROR("Failed to reproduce swaption npv"
                        << "\n    calculated: " << stat.mean()
                        << "\n    expected:   " << swaption->NPV());
    }
}
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/vpp.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size n=0; n < nrTrails; ++n) {
Real plantValue = 0.0;
sample_type path = generator.next();

for (Size i=1; i <= steps; ++i) {
    const Time t = Real(i)/stepsPerYear;
    const DiscountFactor df = rTS->discount(t);

    const Real fuelPrice         = std::exp(path.value[1][i]);
    const Real electricityPrice = std::exp(path.value[0][i]);

    const Real sparkSpread = electricityPrice - heatRate*fuelPrice;
    plantValue += std::max(0.0, sparkSpread)*df;
    onTime.add((sparkSpread > 0.0) ? 1.0 : 0.0);
}

npv.add(plantValue);
}

for (Size i=0; i < nTrails; ++i) {
const sample_type path = generator.next();

Array p(2);
p[0] = path.value[0].back() + path.value[1].back();
p[1] = path.value[2].back();
npv.add((*basketPayoff)(Exp(p)));
}

for (Size i=0; i < LENGTH(efficiency); ++i) {
const Real heatRate = 1.0/efficiency[i];

VanillaVPPOption option(heatRate, pMin, pMax, tMinUp, tMinDown,
                        startUpFuel, startUpFixCost, exercise);

option.setPricingEngine(boost::shared_ptr<PricingEngine>(
    new DynProgVPPIntrinsicValueEngine(
        std::vector<Real>(fuelPrices,fuelPrices+LENGTH(fuelPrices)),
        std::vector<Real>(powerPrices,powerPrices+LENGTH(powerPrices)),
        fuelCostAddon, flatRate(0.0, dc))));

const Real calculated = option.NPV();

if (std::fabs(expected[i] - calculated) > 1e-4) {
    BOOST_ERROR("Failed to reproduce reference values"
               << "\n    calculated: " << calculated
               << "\n    expected:   " << expected[i]);

}
}

for (Size i=0; i < nHours; ++i) {
const Time t = (i+1)/(365*24.);

const Real fuelPrice = fuelPrices[i];
const Real gs = std::log(fuelPrice)-square<Real>()(volatility_u)
                       /(4*kappa)*(1-std::exp(-2*kappa*t));
(*fuelShape)[i] = Shape::value_type(t, gs);

const Real powerPrice = powerPrices[i];
const Real ps = std::log(powerPrice)-square<Real>()(volatility_x)
         /(4*alpha)*(1-std::exp(-2*alpha*t))
        -lambda/beta*std::log((eta-std::exp(-beta*t))/(eta-1.0));

(*powerShape)[i] = Shape::value_type(t, ps);
}

for (Size i=0; i < nTrails; ++i) {
const sample_type& path = generator.next();
const boost::shared_ptr<FdmVPPStepCondition> stepCondition(
    stepConditionFactory.build(
        vppMesh, fuelCostAddon,
        boost::shared_ptr<FdmInnerValueCalculator>(
            new PathFuelPrice(path.value, fuelShape)),
        boost::shared_ptr<FdmInnerValueCalculator>(
            new PathSparkSpreadPrice(heatRate, path.value,
                                     fuelShape, powerShape))));

Array state(nStates, 0.0);
for (Size j=exercise->dates().size(); j > 0; --j) {
    stepCondition->applyTo(state, grid.at(j));
    state*=rTS->discount(grid.at(j))/rTS->discount(grid.at(j-1));
}

npv.add(state.back());
}

for (Size i=0; i < nCalibrationTrails; ++i) {
calibrationPaths.push_back(generator.next());

sparkSpreads.push_back(boost::shared_ptr<FdmInnerValueCalculator>(
    new PathSparkSpreadPrice(heatRate, calibrationPaths.back().value,
                             fuelShape, powerShape)));
stepConditions.push_back(stepConditionFactory.build(
    vppMesh, fuelCostAddon,
    boost::shared_ptr<FdmInnerValueCalculator>(
        new PathFuelPrice(calibrationPaths.back().value, fuelShape)),
    sparkSpreads.back()));
}

for (Size i=exercise->dates().size(); i > 0u; --i) {
const Time t = grid.at(i);

std::vector<Array> x(nCalibrationTrails, Array(dim));

for (Size j=0; j < nCalibrationTrails; ++j) {
    x[j][0] = sparkSpreads[j]->innerValue(iter, t);
}

for (Size k=0; k < nStates; ++k) {
    std::vector<Real> y(nCalibrationTrails);

    for (Size j=0; j < nCalibrationTrails; ++j) {
        y[j] = prices[j][k];
    }
    coeff[k][i-1] = GeneralLinearLeastSquares(x, y, v).coefficients();

    for (Size j=0; j < nCalibrationTrails; ++j) {
        prices[j][k] = 0.0;
        for (Size l=0; l < v.size(); ++l) {
            prices[j][k] += coeff[k][i-1][l]*v[l](x[j]);
        }
    }
}

for (Size j=0; j < nCalibrationTrails; ++j) {
    stepConditions[j]->applyTo(prices[j], grid.at(i));
}
}

for (Size i=0; i < nTrails; ++i) {
Array x(dim), state(nStates, 0.0), contState(nStates, 0.0);

const sample_type& path = (i % 2) ? generator.antithetic()
                                  : generator.next();

const boost::shared_ptr<FdmInnerValueCalculator> fuelPrices(
    new PathFuelPrice(path.value, fuelShape));

const boost::shared_ptr<FdmInnerValueCalculator> sparkSpreads(
    new PathSparkSpreadPrice(heatRate, path.value,
                             fuelShape, powerShape));

for (Size j=exercise->dates().size(); j > 0u; --j) {
    const Time t = grid.at(j);
    const Real fuelPrice = fuelPrices->innerValue(iter, t);
    const Real sparkSpread = sparkSpreads->innerValue(iter, t);
    const Real startUpCost
            = startUpFixCost + (fuelPrice + fuelCostAddon)*startUpFuel;

    x[0] = sparkSpread;
    for (Size k=0; k < nStates; ++k) {
        contState[k] = 0.0;
        for (Size l=0; l < v.size(); ++l) {
            contState[k] += coeff[k][j-1][l]*v[l](x);
        }
    }

    const Real pMinFlow = pMin*(sparkSpread - heatRate*fuelCostAddon);
    const Real pMaxFlow = pMax*(sparkSpread - heatRate*fuelCostAddon);

    // rollback continuation states and the path states
    for (Size i=0; i < 2*tMinUp; ++i) {
        if (i < tMinUp) {
            state[i]    += pMinFlow;
            contState[i]+= pMinFlow;
        }
        else {
            state[i]    += pMaxFlow;
            contState[i]+= pMaxFlow;
        }
    }

    // dynamic programming using the continuation values
    Array retVal(nStates);
    for (Size i=0; i < tMinUp-1; ++i) {
        retVal[i] = retVal[tMinUp + i]
                  = (contState[i+1] > contState[tMinUp + i+1])?
                                  state[i+1] : state[tMinUp + i+1];
    }

    if (contState[2*tMinUp] >=
        std::max(contState[tMinUp-1], contState[2*tMinUp-1])) {
        retVal[tMinUp-1] = retVal[2*tMinUp-1] = state[2*tMinUp];
    }
    else if (contState[tMinUp-1] >= contState[2*tMinUp-1]) {
        retVal[tMinUp-1] = retVal[2*tMinUp-1] = state[tMinUp-1];
    }
    else {
        retVal[tMinUp-1] = retVal[2*tMinUp-1] = state[2*tMinUp-1];
    }

    for (Size i=0; i < tMinDown-1; ++i) {
        retVal[2*tMinUp + i] = state[2*tMinUp + i+1];
    }

    if (contState.back() >=
        std::max(contState.front(), contState[tMinUp]) - startUpCost) {
        retVal.back() = state.back();
    }
    else if (contState.front() >  contState[tMinUp]) {
        retVal.back() = state.front()-startUpCost;
    }
    else {
        retVal.back() = state[tMinUp]-startUpCost;
    }
    state = retVal;
}
tmpValue+=0.5*state.back();
if ((i%2)) {
    npv.add(tmpValue, 1.0);
    tmpValue = 0.0;
}
}

for (Size i=0; i < x.size(); ++i) {
x[i] = rng.next().value;
}

for (Size i=0; i < x.size(); ++i) {
const Real diffApply = std::fabs(applyExpected[i]-applyCalculated[i]);
if (diffApply > tol && diffApply > std::fabs(applyExpected[i])*tol) {
    BOOST_ERROR("Failed to reproduce apply operation" <<
             "\n    expected  : " << applyExpected[i] <<
             "\n    calculated: " << applyCalculated[i] <<
             "\n    diff      : " << diffApply);
}

const Real diffMixed = std::fabs(applyExpectedMixed[i]-applyCalculatedMixed[i]);
if (diffMixed > tol && diffMixed > std::fabs(applyExpected[i])*tol) {
    BOOST_ERROR("Failed to reproduce apply operation" <<
             "\n    expected  : " << applyExpectedMixed[i] <<
             "\n    calculated: " << applyCalculatedMixed[i] <<
             "\n    diff      : " << diffMixed);
}
}

for (Size i=0; i < 3; ++i) {
const Array applyExpectedDir = op->apply_direction(i, x);
const Array applyCalculatedDir = prod(matrixDecomp[i], x);

for (Size j=0; j < x.size(); ++j) {
    const Real diff
        = std::fabs((applyExpectedDir[j] - applyCalculatedDir[j]));

    if (diff > tol && diff > std::fabs(applyExpectedDir[j]*tol)) {
        BOOST_ERROR("Failed to reproduce apply operation" <<
                 "\n    expected  : " << applyExpectedDir[i] <<
                 "\n    calculated: " << applyCalculatedDir[i] <<
                 "\n    diff : " << diff);
    }
}
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/linearleastsquaresregression.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size k=0; k<3; ++k) {
Size i;
const Real a[] = {rng.next().value,
    rng.next().value,
    rng.next().value,
    rng.next().value};

std::vector<Real> x(nr), y(nr);
for (i=0; i<nr; ++i) {
    x[i] = rng.next().value;

    // regression in y = a_1 + a_2*x + a_3*x^2 + a_4*sin(x) + eps
    y[i] =  a[0]*v[0](x[i]) + a[1]*v[1](x[i]) + a[2]*v[2](x[i])
        + a[3]*v[3](x[i]) + rng.next().value;
}

LinearRegression m(x, y, v);

for (i=0; i<v.size(); ++i) {
    if (m.standardErrors()[i] > tolerance) {
        BOOST_ERROR("Failed to reproduce linear regression coef."
            << "\n    error:     " << m.standardErrors()[i]
        << "\n    tolerance: " << tolerance);
    }
    if (std::fabs(m.coefficients()[i]-a[i]) > 3*m.standardErrors()[i]) {
        BOOST_ERROR("Failed to reproduce linear regression coef."
            << "\n    calculated: " << m.coefficients()[i]
        << "\n    error:      " << m.standardErrors()[i]
        << "\n    expected:   " << a[i]);
    }
}

m = LinearRegression(x, y, w);

const Real ma[] = {m.coefficients()[0], m.coefficients()[1], 
    m.coefficients()[2]+m.coefficients()[4],
    m.coefficients()[3]};
const Real err[] = {m.standardErrors()[0], m.standardErrors()[1],
    std::sqrt( m.standardErrors()[2]*m.standardErrors()[2]
+m.standardErrors()[4]*m.standardErrors()[4]),
    m.standardErrors()[3]};
for (i=0; i<v.size(); ++i) {
    if (std::fabs(ma[i] - a[i]) > 3*err[i]) {
        BOOST_ERROR("Failed to reproduce linear regression coef."
            << "\n    calculated: " << ma[i]
        << "\n    error:      " << err[i]
        << "\n    expected:   " << a[i]);
    }
}
}

for (Size i=0; i < dims; ++i) {
v.push_back(boost::bind(f, _1, i));
}

for (Size i=0; i < v.size(); ++i) {
coeff[i] = rng.next().value;
}

for (Size i=0; i < nr; ++i) {
for (Size j=0; j < dims; ++j) {
    x[i][j] = rng.next().value;
}

for (Size j=0; j < v.size(); ++j) {
    y[i] += coeff[j]*v[j](x[i]);
}
y[i] += rng.next().value;
}

for (Size i=0; i < v.size(); ++i) {
if (m.standardErrors()[i] > tolerance) {
    BOOST_ERROR("Failed to reproduce linear regression coef."
        << "\n    error:     " << m.standardErrors()[i]
    << "\n    tolerance: " << tolerance);
}

if (std::fabs(m.coefficients()[i]-coeff[i]) > 3*tolerance) {
    BOOST_ERROR("Failed to reproduce linear regression coef."
        << "\n    calculated: " << m.coefficients()[i]
    << "\n    error:      " << m.standardErrors()[i]
    << "\n    expected:   " << coeff[i]);
}
}

for (Size i=0; i < m1.dim(); ++i) {
if (m1.standardErrors()[i] > tolerance) {
    BOOST_ERROR("Failed to reproduce linear regression coef."
        << "\n    error:     " << m1.standardErrors()[i]
    << "\n    tolerance: " << tolerance);
}

if (std::fabs(m1.coefficients()[i]-coeff[i]) > 3*tolerance) {
    BOOST_ERROR("Failed to reproduce linear regression coef."
        << "\n    calculated: " << m1.coefficients()[i]
    << "\n    error:      " << m1.standardErrors()[i]
    << "\n    expected:   " << coeff[i]);
}
}

for (Size i=0; i < 2; ++i) {
if (std::fabs(m.standardErrors()[i]-errorsExpected[i]) > tol) {
    BOOST_ERROR("Failed to reproduce linear regression standard errors"
        << "\n    calculated: " << m.standardErrors()[i]
    << "\n    expected:   " << errorsExpected[i]                                          
    << "\n    tolerance:  " << tol);
}

if (std::fabs(m.coefficients()[i]-coeffExpected[i]) > tol) {
    BOOST_ERROR("Failed to reproduce linear regression coef."
        << "\n    calculated: " << m.coefficients()[i]
    << "\n    expected:   " << coeffExpected[i]
    << "\n    tolerance:  " << tol);
}
}    

for (Size i=0; i < 2; ++i) {
if (std::fabs(m1.standardErrors()[i]-errorsExpected[i]) > tol) {
    BOOST_ERROR("Failed to reproduce linear regression standard errors"
        << "\n    calculated: " << m1.standardErrors()[i]
    << "\n    expected:   " << errorsExpected[i]                                          
    << "\n    tolerance:  " << tol);
}

if (std::fabs(m1.coefficients()[i]-coeffExpected[i]) > tol) {
    BOOST_ERROR("Failed to reproduce linear regression coef."
        << "\n    calculated: " << m1.coefficients()[i]
    << "\n    expected:   " << coeffExpected[i]
    << "\n    tolerance:  " << tol);
}
}    

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/covariance.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i<m.rows(); i++)
    for (Size j=0; j<m.columns(); j++)
        sum += m[i][j]*m[i][j];

for (Size i=0; i<n; i++) {
for (Size j=0; j<n; j++) {
    expected   = goodCorr[i][j];
    calculated = calcCorr[i][j];
    if (std::fabs(calculated-expected) > 1.0e-10)
        BOOST_ERROR("Salvaging correlation with spectral alg "
                    "through rankReducedSqrt "
                    << "cor[" << i << "][" << j << "]:\n"
                    << std::setprecision(10)
                    << "    calculated: " << calculated << "\n"
                    << "    expected:   " << expected);
}
}

for (Size i=0; i<n; i++) {
for (Size j=0; j<n; j++) {
    expected   = goodCorr[i][j];
    calculated = calcCorr[i][j];
    if (std::fabs(calculated-expected) > 1.0e-10)
        BOOST_ERROR("SalvagingCorrelation with spectral alg "
                    << "cor[" << i << "][" << j << "]:\n"
                    << std::setprecision(10)
                    << "    calculated: " << calculated << "\n"
                    << "    expected:   " << expected);
}
}

for (i = 0; i<LENGTH(data); i++) {
for (j=0; j<n; j++) {
    temp[j]= data[i][j];
}
s.add(temp, weights[i]);
}

for (i=0; i<n; i++) {
expCov[i][i] = std[i]*std[i];
for (j=0; j<i; j++) {
    expCov[i][j] = expCov[j][i] = expCor[i][j]*std[i]*std[j];
}
}

for (i=0; i<n; i++) {
for (j=0; j<n; j++) {
    expected   =  expCor[i][j];
    calculated = calcCor[i][j];
    if (std::fabs(calculated-expected) > 1.0e-10)
        BOOST_ERROR("SequenceStatistics "
                    << "cor[" << i << "][" << j << "]:\n"
                    << std::setprecision(10)
                    << "    calculated: " << calculated << "\n"
                    << "    expected:   " << expected);

    expected   =  expCov[i][j];
    calculated = calcCov[i][j];
    if (std::fabs(calculated-expected) > 1.0e-10)
        BOOST_ERROR("SequenceStatistics "
                    << "cov[" << i << "][" << j << "]:\n"
                    << std::setprecision(10)
                    << "    calculated: " << calculated << "\n"
                    << "    expected:   " << expected);
}
}

for (i=0; i<n; i++) {
for (j=0; j<n; j++) {
    Real calculated = calcCov[i][j],
         expected   = expCov[i][j];
    if (std::fabs(calculated-expected) > 1.0e-10) {
        BOOST_ERROR("getCovariance "
                    << "cov[" << i << "][" << j << "]:\n"
                    << std::setprecision(10)
                    << "    calculated: " << calculated << "\n"
                    << "    expected:   " << expected);
    }
}
}

for (i=0; i<n; i++) {
calculated = calcStd[i];
expected   = std[i];
if (std::fabs(calculated-expected) > 1.0e-16) {
    BOOST_ERROR("CovarianceDecomposition "
                << "standardDev[" << i << "]:\n"
                << std::setprecision(16) << QL_SCIENTIFIC
                << "    calculated: " << calculated << "\n"
                << "    expected:   " << expected);
}
for (j=0; j<n; j++) {
    calculated = calcCor[i][j];
    expected   = expCor[i][j];
    if (std::fabs(calculated-expected) > 1.0e-14) {
        BOOST_ERROR("\nCovarianceDecomposition "
                    << "corr[" << i << "][" << j << "]:\n"
                    << std::setprecision(14) << QL_SCIENTIFIC
                    << "    calculated: " << calculated << "\n"
                    << "    expected:   " << expected);
    }
}
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/mclongstaffschwartzengine.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    for (Size i=0; i<path.assetNumber(); ++i) {
        tmp[i]=path[i][t];
    }

for (Integer i=0; i<2; ++i) {
for (Integer j=0; j<3; ++j) {
    Handle<BlackVolTermStructure> flatVolTS(
        boost::shared_ptr<BlackVolTermStructure>(
            new BlackConstantVol(settlementDate, NullCalendar(),
                                 volatility+0.1*j, dayCounter)));

    boost::shared_ptr<StrikedTypePayoff> payoff(
        new PlainVanillaPayoff(type, underlying+4*i));

    Handle<Quote> underlyingH(
        boost::shared_ptr<Quote>(new SimpleQuote(underlying)));

    boost::shared_ptr<GeneralizedBlackScholesProcess>
        stochasticProcess(new GeneralizedBlackScholesProcess(
                              underlyingH, flatDividendTS,
                              flatTermStructure, flatVolTS));

    VanillaOption americanOption(payoff, americanExercise);

    boost::shared_ptr<PricingEngine> mcengine =
        MakeMCAmericanEngine<PseudoRandom>(stochasticProcess)
          .withSteps(75)
          .withAntitheticVariate()
          .withAbsoluteTolerance(0.02)
          .withSeed(42)
          .withPolynomOrder(3)
          .withBasisSystem(
               polynomTypes[0*(i*3+j)%LENGTH(polynomTypes)]);

    americanOption.setPricingEngine(mcengine);
    // FLOATING_POINT_EXCEPTION
    const Real calculated = americanOption.NPV();
    const Real errorEstimate = americanOption.errorEstimate();
    const Real exerciseProbability =
        americanOption.result<QuantLib::Real>("exerciseProbability");

    americanOption.setPricingEngine(boost::shared_ptr<PricingEngine>(
                new FDAmericanEngine<CrankNicolson>(stochasticProcess,
                                                    401, 200)));
    const Real expected = americanOption.NPV();

    // Check price
    if (std::fabs(calculated - expected) > 2.34*errorEstimate) {
        BOOST_ERROR("Failed to reproduce american option prices"
                    << "\n    expected: " << expected
                    << "\n    calculated:   " << calculated
                    << " +/- " << errorEstimate);
    }

    // Check exercise probability (tolerance 1.5%)
    if (std::fabs(exerciseProbability - expectedExProb[i][j]) > 0.015) {
        BOOST_ERROR("Failed to reproduce american option "
                    << "exercise probability"
                    << "\n    expected: " << expectedExProb[i][j]
                    << "\n    calculated:   " << exerciseProbability);
    }
}
}

for (Size i=0; i<numberAssets; ++i) {
v.push_back(stochasticProcess);
corr[i][i] = 1.0;
}

for (Size i = 0; i < 3; ++i) {

const Real underlying = 90.0 + i*10.0;
underlyingH.linkTo(
    boost::shared_ptr<Quote>(new SimpleQuote(underlying)));

const Real calculated  = americanMaxOption.NPV();
const Real errorEstimate = americanMaxOption.errorEstimate();
if (std::fabs(calculated - expected[i]) > 2.34*errorEstimate) {
        BOOST_ERROR("Failed to reproduce american option prices"
                    << "\n    expected: " << expected[i]
                    << "\n    calculated:   " << calculated
                    << " +/- " << errorEstimate);
}
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/bermudanswaption.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i<leg.size(); i++) {
boost::shared_ptr<Coupon> coupon =
    boost::dynamic_pointer_cast<Coupon>(leg[i]);
    exerciseDates.push_back(coupon->accrualStartDate());
}

for (Size j=0; j<exerciseDates.size(); j++)
exerciseDates[j] = vars.calendar.adjust(exerciseDates[j]-10);

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/termstructures.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    for (Size i=0; i<deposits; i++) {
        instruments[i] = boost::shared_ptr<RateHelper>(new
            DepositRateHelper(depositData[i].rate/100,
                              depositData[i].n*depositData[i].units,
                              settlementDays, calendar,
                              ModifiedFollowing, true,
                              Actual360()));
    }

    for (Size i=0; i<swaps; ++i) {
        instruments[i+deposits] = boost::shared_ptr<RateHelper>(new
            SwapRateHelper(swapData[i].rate/100,
                           swapData[i].n*swapData[i].units,
                           calendar,
                           Annual, Unadjusted, Thirty360(),
                           index));
    }

for (i=0; i<LENGTH(days); i++)
expected[i] = vars.termStructure->discount(today+days[i]);

for (i=0; i<LENGTH(days); i++)
calculated[i] = vars.termStructure->discount(today+30+days[i]);

for (i=0; i<LENGTH(days); i++) {
if (!close(expected[i],calculated[i]))
    BOOST_ERROR("\n  Discount at " << days[i] << " days:\n"
                << std::setprecision(12)
                << "    before date change: " << expected[i] << "\n"
                << "    after date change:  " << calculated[i]);
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/capfloor.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i<LENGTH(lengths); i++) {
for (Size j=0; j<LENGTH(vols); j++) {
    for (Size k=0; k<LENGTH(strikes); k++) {
        for (Size h=0; h<LENGTH(types); h++) {
            Leg leg = vars.makeLeg(startDate, lengths[i]);
            boost::shared_ptr<CapFloor> capFloor =
                vars.makeCapFloor(types[h],leg,
                                  strikes[k],vols[j]);
            boost::shared_ptr<CapFloor> shiftedCapFloor2 =
                vars.makeCapFloor(types[h],leg,
                                  strikes[k],vols[j]+shift);
             boost::shared_ptr<CapFloor> shiftedCapFloor1 =
                vars.makeCapFloor(types[h],leg,
                                  strikes[k],vols[j]-shift);
            Real value1 = shiftedCapFloor1->NPV();
            Real value2 = shiftedCapFloor2->NPV();
            Real numericalVega = (value2 - value1) / (2*shift);
            if (numericalVega>1.0e-4) {
                Real analyticalVega = capFloor->result<Real>("vega");
                Real discrepancy =
                    std::fabs(numericalVega - analyticalVega);
                discrepancy /= numericalVega;
                if (discrepancy > tolerance)
                    BOOST_FAIL(
                        "failed to compute cap/floor vega:" <<
                        "\n   lengths:     " << lengths[j]*Years <<
                        "\n   strike:      " << io::rate(strikes[k]) <<
                        //"\n   types:       " << types[h] <<
                        QL_FIXED << std::setprecision(12) <<
                        "\n   calculated:  " << analyticalVega <<
                        "\n   expected:    " << numericalVega <<
                        "\n   discrepancy: " << io::rate(discrepancy) <<
                        "\n   tolerance:   " << io::rate(tolerance));
             }
        }
    }
}
}

for (Size i=0; i<LENGTH(lengths); i++) {
for (Size j=0; j<LENGTH(vols); j++) {
    // store the results for different strikes...
    std::vector<Real> cap_values, floor_values;
    for (Size k=0; k<LENGTH(strikes); k++) {
        Leg leg = vars.makeLeg(startDate,lengths[i]);
        boost::shared_ptr<Instrument> cap =
            vars.makeCapFloor(CapFloor::Cap,leg,
                              strikes[k],vols[j]);
        cap_values.push_back(cap->NPV());
        boost::shared_ptr<Instrument> floor =
            vars.makeCapFloor(CapFloor::Floor,leg,
                              strikes[k],vols[j]);
        floor_values.push_back(floor->NPV());
    }
    // and check that they go the right way
    std::vector<Real>::iterator it =
        std::adjacent_find(cap_values.begin(),cap_values.end(),
                           std::less<Real>());
    if (it != cap_values.end()) {
        Size n = it - cap_values.begin();
        BOOST_FAIL(
            "NPV is increasing with the strike in a cap: \n"
            << std::setprecision(2)
            << "    length:     " << lengths[i] << " years\n"
            << "    volatility: " << io::volatility(vols[j]) << "\n"
            << "    value:      " << cap_values[n]
            << " at strike: " << io::rate(strikes[n]) << "\n"
            << "    value:      " << cap_values[n+1]
            << " at strike: " << io::rate(strikes[n+1]));
    }
    // same for floors
    it = std::adjacent_find(floor_values.begin(),floor_values.end(),
                            std::greater<Real>());
    if (it != floor_values.end()) {
        Size n = it - floor_values.begin();
        BOOST_FAIL(
            "NPV is decreasing with the strike in a floor: \n"
            << std::setprecision(2)
            << "    length:     " << lengths[i] << " years\n"
            << "    volatility: " << io::volatility(vols[j]) << "\n"
            << "    value:      " << floor_values[n]
            << " at strike: " << io::rate(strikes[n]) << "\n"
            << "    value:      " << floor_values[n+1]
            << " at strike: " << io::rate(strikes[n+1]));
    }
}
}

for (Size i=0; i<LENGTH(lengths); i++) {
for (Size j=0; j<LENGTH(cap_rates); j++) {
for (Size k=0; k<LENGTH(floor_rates); k++) {
  for (Size l=0; l<LENGTH(vols); l++) {

      Leg leg = vars.makeLeg(startDate,lengths[i]);
      boost::shared_ptr<CapFloor> cap =
          vars.makeCapFloor(CapFloor::Cap,leg,
                            cap_rates[j],vols[l]);
      boost::shared_ptr<CapFloor> floor =
          vars.makeCapFloor(CapFloor::Floor,leg,
                            floor_rates[k],vols[l]);
      Collar collar(leg,std::vector<Rate>(1,cap_rates[j]),
                    std::vector<Rate>(1,floor_rates[k]));
      collar.setPricingEngine(vars.makeEngine(vols[l]));

      if (std::fabs((cap->NPV()-floor->NPV())-collar.NPV()) > 1e-10) {
          BOOST_FAIL(
            "inconsistency between cap, floor and collar:\n"
            << "    length:       " << lengths[i] << " years\n"
            << "    volatility:   " << io::volatility(vols[l]) << "\n"
            << "    cap value:    " << cap->NPV()
            << " at strike: " << io::rate(cap_rates[j]) << "\n"
            << "    floor value:  " << floor->NPV()
            << " at strike: " << io::rate(floor_rates[k]) << "\n"
            << "    collar value: " << collar.NPV());


      // test re-composition by optionlets, N.B. two per year
      Real capletsNPV = 0.0;
      std::vector<boost::shared_ptr<CapFloor> > caplets;
      for (Integer m=0; m<lengths[i]*2; m++) {
        caplets.push_back(cap->optionlet(m));
        caplets[m]->setPricingEngine(vars.makeEngine(vols[l]));
        capletsNPV += caplets[m]->NPV();
      }

      if (std::fabs(cap->NPV() - capletsNPV) > 1e-10) {
        BOOST_FAIL(
          "sum of caplet NPVs does not equal cap NPV:\n"
            << "    length:       " << lengths[i] << " years\n"
            << "    volatility:   " << io::volatility(vols[l]) << "\n"
            << "    cap value:    " << cap->NPV()
            << " at strike: " << io::rate(cap_rates[j]) << "\n"
            << "    sum of caplets value:  " << capletsNPV
            << " at strike (first): " << io::rate(caplets[0]->capRates()[0]) << "\n"
        );
      }

      Real floorletsNPV = 0.0;
      std::vector<boost::shared_ptr<CapFloor> > floorlets;
      for (Integer m=0; m<lengths[i]*2; m++) {
        floorlets.push_back(floor->optionlet(m));
        floorlets[m]->setPricingEngine(vars.makeEngine(vols[l]));
        floorletsNPV += floorlets[m]->NPV();
      }

      if (std::fabs(floor->NPV() - floorletsNPV) > 1e-10) {
        BOOST_FAIL(
          "sum of floorlet NPVs does not equal floor NPV:\n"
            << "    length:       " << lengths[i] << " years\n"
            << "    volatility:   " << io::volatility(vols[l]) << "\n"
            << "    cap value:    " << floor->NPV()
            << " at strike: " << io::rate(floor_rates[j]) << "\n"
            << "    sum of floorlets value:  " << floorletsNPV
            << " at strike (first): " << io::rate(floorlets[0]->floorRates()[0]) << "\n"
        );
      }

      Real collarletsNPV = 0.0;
      std::vector<boost::shared_ptr<CapFloor> > collarlets;
      for (Integer m=0; m<lengths[i]*2; m++) {
        collarlets.push_back(collar.optionlet(m));
        collarlets[m]->setPricingEngine(vars.makeEngine(vols[l]));
        collarletsNPV += collarlets[m]->NPV();
      }

      if (std::fabs(collar.NPV() - collarletsNPV) > 1e-10) {
        BOOST_FAIL(
          "sum of collarlet NPVs does not equal floor NPV:\n"
            << "    length:       " << lengths[i] << " years\n"
            << "    volatility:   " << io::volatility(vols[l]) << "\n"
            << "    cap value:    " << collar.NPV()
            << " at strike floor: " << io::rate(floor_rates[j])
            << " at strike cap: " << io::rate(cap_rates[j]) << "\n"
            << "    sum of collarlets value:  " << collarletsNPV
            << " at strike floor (first): " << io::rate(collarlets[0]->floorRates()[0])
            << " at strike cap (first): " << io::rate(collarlets[0]->capRates()[0]) << "\n"
        );
      }




      }
  }
}
}
}

for (Size i=0; i<LENGTH(lengths); i++) {
for (Size j=0; j<LENGTH(strikes); j++) {
for (Size k=0; k<LENGTH(vols); k++) {

    Leg leg = vars.makeLeg(startDate,lengths[i]);
    boost::shared_ptr<Instrument> cap =
        vars.makeCapFloor(CapFloor::Cap,leg,
                          strikes[j],vols[k]);
    boost::shared_ptr<Instrument> floor =
        vars.makeCapFloor(CapFloor::Floor,leg,
                          strikes[j],vols[k]);
    Date maturity = vars.calendar.advance(startDate,lengths[i],Years,
                                      vars.convention);
    Schedule schedule(startDate,maturity,
                      Period(vars.frequency),vars.calendar,
                      vars.convention,vars.convention,
                      DateGeneration::Forward,false);
    VanillaSwap swap(VanillaSwap::Payer, vars.nominals[0],
                     schedule, strikes[j], vars.index->dayCounter(),
                     schedule, vars.index, 0.0,
                     vars.index->dayCounter());
    swap.setPricingEngine(boost::shared_ptr<PricingEngine>(
                      new DiscountingSwapEngine(vars.termStructure)));
    // FLOATING_POINT_EXCEPTION
    if (std::fabs((cap->NPV()-floor->NPV()) - swap.NPV()) > 1.0e-10) {
        BOOST_FAIL(
            "put/call parity violated:\n"
            << "    length:      " << lengths[i] << " years\n"
            << "    volatility:  " << io::volatility(vols[k]) << "\n"
            << "    strike:      " << io::rate(strikes[j]) << "\n"
            << "    cap value:   " << cap->NPV() << "\n"
            << "    floor value: " << floor->NPV() << "\n"
            << "    swap value:  " << swap.NPV());
    }
}
}
}

for (Size i=0; i<LENGTH(lengths); i++) {
Leg leg = vars.makeLeg(startDate,lengths[i]);
Date maturity = vars.calendar.advance(startDate,lengths[i],Years,
                          vars.convention);
Schedule schedule(startDate,maturity,
                  Period(vars.frequency),vars.calendar,
                  vars.convention,vars.convention,
                  DateGeneration::Forward,false);

for (Size j=0; j<LENGTH(strikes); j++) {
    for (Size k=0; k<LENGTH(vols); k++) {
        boost::shared_ptr<CapFloor> cap =
            vars.makeCapFloor(CapFloor::Cap, leg, strikes[j],vols[k]);
        boost::shared_ptr<CapFloor> floor =
            vars.makeCapFloor(CapFloor::Floor, leg, strikes[j],vols[k]);
        Rate capATMRate = cap->atmRate(**vars.termStructure);
        Rate floorATMRate = floor->atmRate(**vars.termStructure);
        if (!checkAbsError(floorATMRate, capATMRate, 1.0e-10))
            BOOST_FAIL(
              "Cap ATM Rate and floor ATM Rate should be equal :\n"
              << "   length:        " << lengths[i] << " years\n"
              << "   volatility:    " << io::volatility(vols[k]) << "\n"
              << "   strike:        " << io::rate(strikes[j]) << "\n"
              << "   cap ATM rate:  " << capATMRate << "\n"
              << "   floor ATM rate:" << floorATMRate << "\n"
              << "   relative Error:"
              << relativeError(capATMRate, floorATMRate,
                               capATMRate)*100 << "%" );
        VanillaSwap swap(VanillaSwap::Payer, vars.nominals[0],
                         schedule, floorATMRate,
                         vars.index->dayCounter(),
                         schedule, vars.index, 0.0,
                         vars.index->dayCounter());
        swap.setPricingEngine(boost::shared_ptr<PricingEngine>(
                      new DiscountingSwapEngine(vars.termStructure)));
        Real swapNPV = swap.NPV();
        if (!checkAbsError(swapNPV, 0, 1.0e-10))
            BOOST_FAIL(
              "the NPV of a Swap struck at ATM rate "
              "should be equal to 0:\n"
              << "   length:        " << lengths[i] << " years\n"
              << "   volatility:    " << io::volatility(vols[k]) << "\n"
              << "   ATM rate:      " << io::rate(floorATMRate) << "\n"
              << "   swap NPV:      " << swapNPV);
}
}
}

for (Size k=0; k<LENGTH(lengths); k++) {
Leg leg = vars.makeLeg(vars.settlement, lengths[k]);

for (Size i=0; i<LENGTH(types); i++) {
    for (Size j=0; j<LENGTH(strikes); j++) {

        boost::shared_ptr<CapFloor> capfloor =
            vars.makeCapFloor(types[i], leg, strikes[j], 0.0);

        for (Size n=0; n<LENGTH(rRates); n++) {
            for (Size m=0; m<LENGTH(vols); m++) {

                Rate r = rRates[n];
                Volatility v = vols[m];
                vars.termStructure.linkTo(flatRate(vars.settlement,r,
                                               Actual360()));
                capfloor->setPricingEngine(vars.makeEngine(v));

                Real value = capfloor->NPV();
                Volatility implVol = 0.0;
                try {
                    implVol =
                        capfloor->impliedVolatility(value,
                                                    vars.termStructure,
                                                    0.10,
                                                    tolerance,
                                                    maxEvaluations,
                                                    10.0e-7, 4.0, 0.0);
                } catch (std::exception& e) {
                    // couldn't bracket?
                    capfloor->setPricingEngine(vars.makeEngine(0.0));
                    Real value2 = capfloor->NPV();
                    if (std::fabs(value-value2) < tolerance) {
                        // ok, just skip:
                        continue;
                    }
                    // otherwise, report error
                    BOOST_ERROR("implied vol failure: " <<
                                typeToString(types[i]) <<
                                "\n  strike:     " << io::rate(strikes[j]) <<
                                "\n  risk-free:  " << io::rate(r) <<
                                "\n  length:     " << lengths[k] << "Y" <<
                                "\n  volatility: " << io::volatility(v) <<
                                "\n  price:      " << value <<
                                "\n" << e.what());
                }
                if (std::fabs(implVol-v) > tolerance) {
                    // the difference might not matter
                    capfloor->setPricingEngine(
                                            vars.makeEngine(implVol));
                    Real value2 = capfloor->NPV();
                    if (std::fabs(value-value2) > tolerance) {
                    BOOST_FAIL("implied vol failure: " <<
                               typeToString(types[i]) <<
                               "\n  strike:        " << io::rate(strikes[j]) <<
                               "\n  risk-free:     " << io::rate(r) <<
                               "\n  length:        " << lengths[k] << "Y" <<
                               "\n  volatility:    " << io::volatility(v) <<
                               "\n  price:         " << value <<
                               "\n  implied vol:   " << io::volatility(implVol) <<
                               "\n  implied price: " << value2);
                    }
                }
            }
        }
    }
}
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/rangeaccrual.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    for (i=0; i<nRowsAtmVols; i++){
        atmVolsHandle[i] = std::vector<Handle<Quote> >(nColsAtmVols);
        for (Size j=0; j<nColsAtmVols; j++) {
            atmVolsHandle[i][j] =
                Handle<Quote>(boost::shared_ptr<Quote>(new
                    SimpleQuote(atmVolMatrix[i][j])));
        }
    }

    for (i=0; i<optionTenors.size()*swapTenors.size(); i++) {
        parametersGuess[i] = std::vector<Handle<Quote> >(4);
        parametersGuess[i][0] =
            Handle<Quote>(boost::shared_ptr<Quote>(
                                               new SimpleQuote(0.2)));
        parametersGuess[i][1] =
            Handle<Quote>(boost::shared_ptr<Quote>(
                                               new SimpleQuote(0.5)));
        parametersGuess[i][2] =
            Handle<Quote>(boost::shared_ptr<Quote>(
                                               new SimpleQuote(0.4)));
        parametersGuess[i][3] =
            Handle<Quote>(boost::shared_ptr<Quote>(
                                               new SimpleQuote(0.0)));
    }

    for (i=0; i<optionTenors.size()*swapTenors.size(); i++){
        nullVolSpreads[i] = std::vector<Handle<Quote> >(nCols);
        for (Size j=0; j<strikeSpreads.size(); j++) {
            nullVolSpreads[i][j] =
                Handle<Quote>(boost::shared_ptr<Quote>(
                                                new SimpleQuote(0.)));
        }
    }

    for (i=0; i<optionTenors.size()*swapTenors.size(); i++){
        volSpreads[i] = std::vector<Handle<Quote> >(nCols);
        for (Size j=0; j<strikeSpreads.size(); j++) {
            volSpreads[i][j] =
                Handle<Quote>(boost::shared_ptr<Quote>(new
                    SimpleQuote(volSpreadsMatrix[i][j])));
        }
    }

for (Size z = 0; z < vars.smilesOnPayment.size(); z++) {
for (Size i = 0; i < vars.byCallSpread.size(); i++){
    boost::shared_ptr<RangeAccrualPricer> bgmPricer(new
        RangeAccrualPricerByBgm(vars.correlation,
                                vars.smilesOnExpiry[z],
                                vars.smilesOnPayment[z],
                                true,
                                vars.byCallSpread[i]));

        coupon.setPricer(bgmPricer);

        //Computation
        const Rate rate = coupon.rate();
        const Rate indexfixing = vars.iborIndex->fixing(fixingDate);
        const Rate difference =  rate-indexfixing;

        if (std::fabs(difference) > vars.rateTolerance) {
            BOOST_ERROR("\n" <<
                        "i:\t" << i << "\n"
                        "fixingDate:\t" << fixingDate << "\n"
                        "startDate:\t" << vars.startDate << "\n"
                        "range accrual rate:\t" << io::rate(rate) << "\n"
                        "index fixing:\t" << io::rate(indexfixing) << "\n"
                        "difference:\t" << io::rate(difference) << "\n"
                        "tolerance: \t" << io::rate(vars.rateTolerance));
        }
}
}

for (Size z = 0; z < vars.smilesOnPayment.size(); z++) {
for (Size i = 0; i < vars.byCallSpread.size(); i++){
    boost::shared_ptr<RangeAccrualPricer> bgmPricer(new
        RangeAccrualPricerByBgm(vars.correlation,
                                vars.smilesOnExpiry[z],
                                vars.smilesOnPayment[z],
                                true,
                                vars.byCallSpread[i]));

    Real effectiveLowerStrike;
    Real previousPrice = 100.;

    for (Size k = 1; k < 100; k++){
        effectiveLowerStrike = 0.005 + k*0.001;
        RangeAccrualFloatersCoupon coupon(
                                    vars.paymentDate,
                                    1.,
                                    vars.iborIndex,
                                    vars.startDate,
                                    vars.endDate,
                                    vars.fixingDays,
                                    vars.rangeCouponDayCount,
                                    vars.gearing, vars.spread,
                                    vars.startDate, vars.endDate,
                                    vars.observationSchedule,
                                    effectiveLowerStrike,
                                    vars.infiniteUpperStrike);

        coupon.setPricer(bgmPricer);

        //Computation
        const Rate price = coupon.price(vars.termStructure);

        if (previousPrice <= price) {
            BOOST_ERROR("\n" <<
                        "i:\t" << i << "\n"
                        "k:\t" << k << "\n"
                        "Price at lower strike\t" << effectiveLowerStrike-0.001 <<
                        ": \t" << previousPrice << "\n"
                        "Price at lower strike\t" << effectiveLowerStrike <<
                        ": \t" << price << "\n");
        }
        previousPrice = price;
    }
}
}

for (Size z = 0; z < vars.smilesOnPayment.size(); z++) {
for (Size i = 0; i < vars.byCallSpread.size(); i++){
    boost::shared_ptr<RangeAccrualPricer> bgmPricer(new
        RangeAccrualPricerByBgm(vars.correlation,
                                vars.smilesOnExpiry[z],
                                vars.smilesOnPayment[z],
                                true,
                                vars.byCallSpread[i]));

    Real effectiveUpperStrike;
    Real previousPrice = 0.;

    for (Size k = 1; k < 95; k++){
        effectiveUpperStrike = 0.006 + k*0.001;
        RangeAccrualFloatersCoupon coupon(
                                    vars.paymentDate,
                                    1.,
                                    vars.iborIndex,
                                    vars.startDate,
                                    vars.endDate,
                                    vars.fixingDays,
                                    vars.rangeCouponDayCount,
                                    vars.gearing, vars.spread,
                                    vars.startDate, vars.endDate,
                                    vars.observationSchedule,
                                    .004,
                                    effectiveUpperStrike);

        coupon.setPricer(bgmPricer);

        //Computation
        const Rate price = coupon.price(vars.termStructure);

        if (previousPrice > price) {
            BOOST_ERROR("\n" <<
                        "i:\t" << i << "\n"
                        "k:\t" << k << "\n"
                        "Price at upper strike\t" << effectiveUpperStrike-0.001 <<
                        ": \t" << previousPrice << "\n"
                        "Price at upper strike\t" << effectiveUpperStrike <<
                        ": \t" << price << "\n");
        }
        previousPrice = price;
    }
}
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/marketmodel_cms.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=1; i<dates.size(); ++i)
    rateTimes[i-1] = dayCounter.yearFraction(todaysDate, dates[i]);

for (Size i=1; i<rateTimes.size(); ++i)
    accruals[i-1] = rateTimes[i] - rateTimes[i-1];

for (Size i=0; i<todaysForwards.size(); ++i)
    todaysForwards[i] = 0.03 + 0.0010*i;

for (Size i=1; i<rateTimes.size(); ++i)
    todaysDiscounts[i] = todaysDiscounts[i-1] /
        (1.0+todaysForwards[i-1]*accruals[i-1]);

for (Size i=0; i<todaysCMSwapRates.size(); i++) {
    volatilities[i] = todaysCMSwapRates[i]*mktVols[i]/
        (todaysCMSwapRates[i]+displacement);
    blackVols[i]= mktVols[i];
}

for (Size i=0; i<N; ++i) {
    Real expectedNPV = curveState_lmm.cmSwapAnnuity(i, i, spanningForwards)
        * (todaysCMSwapRates[i]-fixedRate) * todaysDiscounts[i];
    expectedNPVs[i] = expectedNPV;
    discrepancies[i] = (results[i]-expectedNPVs[i])/errors[i];
    maxError = std::max(std::fabs(discrepancies[i]), maxError);
}

    for (Size i=0; i<N; ++i) {
        BOOST_TEST_MESSAGE(io::ordinal(i+1) << " CMS NPV: "
                           << io::rate(results[i])
                           << " +- " << io::rate(errors[i])
                           << "; expected: " << io::rate(expectedNPVs[i])
                           << "; discrepancy/error = "
                           << discrepancies[N-1-i]
                           << " standard errors");
    }

for (Size i=0; i<N; ++i) {
    Real expectedSwaption =
        BlackCalculator(displacedPayoff[i],
                        todaysCMSwapRates[i]+displacement,
                        volatilities[i]*std::sqrt(rateTimes[i]),
                        curveState_lmm.cmSwapAnnuity(i,i, spanningForwards)
                        * todaysDiscounts[i]).value();
    expectedSwaptions[i] = expectedSwaption;
    discrepancies[i] = (results[N+i]-expectedSwaptions[i])/errors[N+i];
    maxError = std::max(std::fabs(discrepancies[i]), maxError);
}

    for (Size i=1; i<=N; ++i) {
        BOOST_TEST_MESSAGE(io::ordinal(i) << " Swaption: "
                           << io::rate(results[2*N-i])
                           << " +- " << io::rate(errors[2*N-i])
                           << "; expected: " << io::rate(expectedSwaptions[N-i])
                           << "; discrepancy/error = "
                           << io::percent(discrepancies[N-i])
                           << " standard errors");
    }

for (Size i=0; i<undisplacedPayoff.size(); ++i) {
displacedPayoff[i] = boost::shared_ptr<StrikedTypePayoff>(new
    PlainVanillaPayoff(Option::Call, fixedRate+displacement));

undisplacedPayoff[i] = boost::shared_ptr<StrikedTypePayoff>(new
    PlainVanillaPayoff(Option::Call, fixedRate));
}

for (Size j=0; j<LENGTH(marketModels); j++) {

Size testedFactors[] = { /*4, 8,*/ todaysForwards.size()};
for (Size m=0; m<LENGTH(testedFactors); ++m) {
    Size factors = testedFactors[m];

    // Composite's ProductSuggested is the Terminal one
    MeasureType measures[] = { // ProductSuggested,
                               Terminal,
                              // MoneyMarketPlus,
                               MoneyMarket};
    for (Size k=0; k<LENGTH(measures); k++) {
        std::vector<Size> numeraires = makeMeasure(product, measures[k]);

        boost::shared_ptr<MarketModel> marketModel =
            makeMarketModel(evolution, factors, marketModels[j]);

        EvolverType evolvers[] = { Pc/*, Ipc*/ };

        boost::shared_ptr<MarketModelEvolver> evolver;
        Size stop = isInTerminalMeasure(evolution, numeraires) ? 0 : 1;
        for (Size i=0; i<LENGTH(evolvers)-stop; i++) {
            for (Size n=0; n<1; n++) {
                //MTBrownianGeneratorFactory generatorFactory(seed_);
                SobolBrownianGeneratorFactory generatorFactory(
                             SobolBrownianGenerator::Diagonal, seed_);
                evolver = makeMarketModelEvolver(marketModel,
                                                 numeraires,
                                                 generatorFactory,
                                                 evolvers[i]);
                std::ostringstream config;
                config <<
                    marketModelTypeToString(marketModels[j]) << ", " <<
                    factors << (factors>1 ? (factors==todaysForwards.size() ? " (full) factors, " : " factors, ") : " factor,") <<
                    measureTypeToString(measures[k]) << ", " <<
                    evolverTypeToString(evolvers[i]) << ", " <<
                    "MT BGF";
                if (printReport_)
                    BOOST_TEST_MESSAGE("    " << config.str());

                boost::shared_ptr<SequenceStatisticsInc> stats = simulate(evolver, product);
                checkCMSAndSwaptions(*stats, fixedRate,
                                     displacedPayoff, marketModel,config.str());

            }
        }
    }
}
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/inflationvolatility.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i = 0; i < nTimesEUR; i++) {
    r.push_back(ratesEUR[i]);
    Size ys = (Size)floor(timesEUR[i]);
    Size ds = (Size)((timesEUR[i]-(Real)ys)*365);
    Date dd = eval + Period(ys,Years) + Period(ds,Days);
    d.push_back( dd );
}

for (Size i = 0; i < nTimesGBP; i++) {
    r.push_back(ratesGBP[i]);
    Size ys = (Size)floor(timesGBP[i]);
    Size ds = (Size)((timesGBP[i]-(Real)ys)*365);
    Date dd = eval + Period(ys,Years) + Period(ds,Days);
    d.push_back( dd );
}

for (Size i = 0; i < LENGTH(yoyEUrates); i++) {
    Date dd = TARGET().advance(baseDate, i, Years, ModifiedFollowing);
    d.push_back(dd);
    r.push_back(yoyEUrates[i]);
}

for(Size i = 0; i < ncStrikesEU; i++) cStrikesEU.push_back(capStrikesEU[i]);

for(Size i = 0; i < nfStrikesEU; i++) fStrikesEU.push_back(floorStrikesEU[i]);

for(Size i = 0; i < ncfMaturitiesEU; i++) cfMaturitiesEU.push_back(capMaturitiesEU[i]);

for(Size i = 0; i < ncStrikesEU; i++) {
    for(Size j = 0; j < ncfMaturitiesEU; j++) {
        (*tcPriceEU)[i][j] = capPricesEU[i][j];
    }
}

for(Size i = 0; i < nfStrikesEU; i++) {
    for(Size j = 0; j < ncfMaturitiesEU; j++) {
        (*tfPriceEU)[i][j] = floorPricesEU[i][j];
    }
}

for(Size i = 0; i < n; i++){
QL_REQUIRE( fabs(someSlice.second[i] - volATyear1[i]) < eps,
           " could not recover 1yr vol: " << someSlice.second[i]
           << " vs " << volATyear1[i] );
}

for(Size i = 0; i < n; i++){
QL_REQUIRE(fabs(someOtherSlice.second[i]-volATyear3[i]) < eps,
                "could not recover 3yr vol: "
                << someOtherSlice.second[i]<< " vs " << volATyear3[i] );
}

for(Size i = 0; i < yyATMt.first.size(); i++) {
QL_REQUIRE(fabs( yyATMt.second[i] - crv[i] ) < eps,
           "could not recover cached yoy swap curve "
           << yyATMt.second[i]<< " vs " << crv[i]);
}

for(Size i = 0; i < yyATMd.first.size(); i++) {
QL_REQUIRE(fabs( priceSurfEU->atmYoYSwapRate(yyATMd.first[i])  - swaps[i] ) < eps,
           "could not recover yoy swap curve "
           << priceSurfEU->atmYoYSwapRate(yyATMd.first[i]) << " vs " << swaps[i]);
}

for(Size i = 0; i < yyATMd.first.size(); i++) {
QL_REQUIRE(fabs( priceSurfEU->atmYoYRate(yyATMd.first[i])  - ayoy[i] ) < eps,
           " could not recover cached yoy curve "
           << priceSurfEU->atmYoYRate(yyATMd.first[i]) << " vs " << ayoy[i]
           <<" at "<<yyATMd.first[i]);
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/varianceswaps.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i<LENGTH(values); i++) {
Date exDate = today + Integer(values[i].t*365+0.5);
std::vector<Date> dates(1);
dates[0] = exDate;

spot ->setValue(values[i].s);
qRate->setValue(values[i].q);
rRate->setValue(values[i].r);

Size options = LENGTH(replicatingOptionData);
std::vector<Real> callStrikes, putStrikes, callVols, putVols;

// Assumes ascending strikes and same min call and max put strikes
Size j;
for (j=0; j<options; j++) {
    if (replicatingOptionData[j].type == Option::Call) {
        callStrikes.push_back(replicatingOptionData[j].strike);
        callVols.push_back(replicatingOptionData[j].v);
    } else if (replicatingOptionData[j].type == Option::Put) {
        putStrikes.push_back(replicatingOptionData[j].strike);
        putVols.push_back(replicatingOptionData[j].v);
    } else {
        QL_FAIL("unknown option type");
    }
}

Matrix vols(options-1, 1);
std::vector<Real> strikes;
for (j=0; j<putVols.size(); j++) {
    vols[j][0] = putVols[j];
    strikes.push_back(putStrikes[j]);
}

for (Size k=1; k<callVols.size(); k++) {
    Size j = putVols.size()-1;
    vols[j+k][0] = callVols[k];
    strikes.push_back(callStrikes[k]);
}

boost::shared_ptr<BlackVolTermStructure> volTS(new
    BlackVarianceSurface(today, NullCalendar(),
                         dates, strikes, vols, dc));

boost::shared_ptr<GeneralizedBlackScholesProcess> stochProcess(
                     new BlackScholesMertonProcess(
                               Handle<Quote>(spot),
                               Handle<YieldTermStructure>(qTS),
                               Handle<YieldTermStructure>(rTS),
                               Handle<BlackVolTermStructure>(volTS)));


boost::shared_ptr<PricingEngine> engine(
                  new ReplicatingVarianceSwapEngine(stochProcess, 5.0,
                                                    callStrikes,
                                                    putStrikes));

VarianceSwap varianceSwap(values[i].type,
                          values[i].varStrike,
                          values[i].nominal,
                          today,
                          exDate);
varianceSwap.setPricingEngine(engine);

Real calculated = varianceSwap.variance();
Real expected = values[i].result;
Real error = std::fabs(calculated-expected);
if (error>values[i].tol)
    REPORT_FAILURE("value", values[i].type, values[i].varStrike,
                   values[i].nominal, values[i].s, values[i].q,
                   values[i].r, today, exDate, values[i].v, expected,
                   calculated, error, values[i].tol);
}

for (Size i=0; i<LENGTH(values); i++) {
Date exDate = today + Integer(values[i].t*365+0.5);
Date intermDate = today + Integer(values[i].t1*365+0.5);
boost::shared_ptr<Exercise> exercise(new EuropeanExercise(exDate));
dates[0] = intermDate;
dates[1] = exDate;

spot ->setValue(values[i].s);
qRate->setValue(values[i].q);
rRate->setValue(values[i].r);
vols[0] = values[i].v1;
vols[1] = values[i].v;

boost::shared_ptr<BlackVolTermStructure> volTS(
                new BlackVarianceCurve(today, dates, vols, dc, true));

boost::shared_ptr<GeneralizedBlackScholesProcess> stochProcess(
            new BlackScholesMertonProcess(
                               Handle<Quote>(spot),
                               Handle<YieldTermStructure>(qTS),
                               Handle<YieldTermStructure>(rTS),
                               Handle<BlackVolTermStructure>(volTS)));

boost::shared_ptr<PricingEngine> engine;
engine =
    MakeMCVarianceSwapEngine<PseudoRandom>(stochProcess)
    .withStepsPerYear(250)
    .withSamples(1023)
    .withSeed(42);

VarianceSwap varianceSwap(values[i].type,
                          values[i].varStrike,
                          values[i].nominal,
                          today,
                          exDate);
varianceSwap.setPricingEngine(engine);

Real calculated = varianceSwap.variance();
Real expected = values[i].result;
Real error = std::fabs(calculated-expected);
if (error>values[i].tol)
    REPORT_FAILURE("value", values[i].type, values[i].varStrike,
                   values[i].nominal, values[i].s, values[i].q,
                   values[i].r, today, exDate, values[i].v, expected,
                   calculated, error, values[i].tol);
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/blackdeltacalculator.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i<LENGTH(values); i++) {

currOt      =values[i].ot;
currDt      =values[i].dt;
currSpot    =values[i].spot;
currdDf     =values[i].dDf;
currfDf     =values[i].fDf;
currStdDev  =values[i].stdDev;
currStrike  =values[i].strike;
currDelta   =values[i].value;

BlackDeltaCalculator myCalc(currOt, currDt, currSpot,
                            currdDf, currfDf, currStdDev);

tolerance=1.0e-3;

expected    =currDelta;
calculated  =myCalc.deltaFromStrike(currStrike);
error       =std::fabs(calculated-expected);

if (error>tolerance) {
    BOOST_ERROR("\n Delta-from-strike calculation failed for delta. \n"
                << "Iteration: "<< i << "\n"
                << "Calculated Strike:" << calculated << "\n"
                << "Expected   Strike:" << expected << "\n"
                << "Error: " << error);
}

tolerance=1.0e-2;
// tolerance not that small, but sufficient for strikes in
// particular since they might be results of a numerical
// procedure

expected    =currStrike;
calculated  =myCalc.strikeFromDelta(currDelta);
error       =std::fabs(calculated-expected);

if (error>tolerance) {
    BOOST_ERROR("\n Strike-from-delta calculation failed for delta. \n"
                << "Iteration: "<< i << "\n"
                << "Calculated Strike:" << calculated << "\n"
                << "Expected   Strike:" << expected << "\n"
                << "Error: " << error);
}
}

for(Size i=0; i<LENGTH(values);++i){

payoff = boost::shared_ptr<StrikedTypePayoff>(
            new PlainVanillaPayoff(values[i].type, values[i].strike));
exDate = today + timeToDays(values[i].t);
exercise = boost::shared_ptr<Exercise>(new EuropeanExercise(exDate));

spotQuote   ->setValue(values[i].s);
volQuote    ->setValue(values[i].v);
rQuote      ->setValue(values[i].r);
qQuote      ->setValue(values[i].q);

discDom =rTS->discount(exDate);
discFor =qTS->discount(exDate);
implVol =sqrt(volTS->blackVariance(exDate,0.0));

BlackDeltaCalculator myCalc(values[i].type, DeltaVolQuote::PaSpot,
                            spotQuote->value(),
                            discDom, discFor, implVol);

stochProcess=boost::shared_ptr<BlackScholesMertonProcess> (new
    BlackScholesMertonProcess(spotHandle,
                              Handle<YieldTermStructure>(qTS),
                              Handle<YieldTermStructure>(rTS),
                              Handle<BlackVolTermStructure>(volTS)));

engine = boost::shared_ptr<PricingEngine>(
                            new AnalyticEuropeanEngine(stochProcess));

EuropeanOption option(payoff, exercise);
option.setPricingEngine(engine);

calculatedVal=myCalc.deltaFromStrike(values[i].strike);
expectedVal=option.delta()-option.NPV()/spotQuote->value();
error=std::fabs(expectedVal-calculatedVal);

if(error>tolerance){
    BOOST_ERROR("\n Premium-adjusted spot delta test failed. \n" \
                << "Calculated Delta: " << calculatedVal << "\n"
                << "Expected Value:   " << expectedVal << "\n"
                << "Error: "<< error);
}

myCalc.setDeltaType(DeltaVolQuote::PaFwd);

calculatedVal=myCalc.deltaFromStrike(values[i].strike);
expectedVal=expectedVal/discFor; // Premium adjusted Fwd Delta is PA spot without discount
error=std::fabs(expectedVal-calculatedVal);

if(error>tolerance){
    BOOST_ERROR("\n Premium-adjusted forward delta test failed. \n"
                << "Calculated Delta: " << calculatedVal << "\n"
                << "Expected Value:   " << expectedVal << "\n"
                << "Error: "<< error);
}


// Test consistency with BlackScholes Calculator for Spot Delta
myCalc.setDeltaType(DeltaVolQuote::Spot);

calculatedVal=myCalc.deltaFromStrike(values[i].strike);
expectedVal=option.delta();
error=std::fabs(calculatedVal-expectedVal);

if(error>tolerance){
    BOOST_ERROR("\n spot delta in BlackDeltaCalculator differs "
                "from delta in BlackScholesCalculator. \n"
                << "Calculated Value: " << calculatedVal << "\n"
                << "Expected Value:   " << expectedVal << "\n"
                << "Error: " << error);
}
}

for(Size i=0; i<LENGTH(values);++i){

payoff = boost::shared_ptr<StrikedTypePayoff>(new
                    PlainVanillaPayoff(Option::Call, values[i].strike));
exDate = today + timeToDays(values[i].t);
exercise = boost::shared_ptr<Exercise>(new EuropeanExercise(exDate));

spotQuote->setValue(values[i].s);
volQuote->setValue(values[i].v);
rQuote->setValue(values[i].r);
qQuote->setValue(values[i].q);
discDom=rTS->discount(exDate);
discFor=qTS->discount(exDate);
implVol=sqrt(volTS->blackVariance(exDate,0.0));
forward=spotQuote->value()*discFor/discDom;

BlackDeltaCalculator myCalc(Option::Call, DeltaVolQuote::Spot,
                            spotQuote->value(),
                            discDom, discFor, implVol);

deltaCall=myCalc.deltaFromStrike(values[i].strike);;
myCalc.setOptionType(Option::Put);
deltaPut=myCalc.deltaFromStrike(values[i].strike);;
myCalc.setOptionType(Option::Call);

expectedDiff=discFor;
calculatedDiff=deltaCall-deltaPut;
error=std::fabs(expectedDiff-calculatedDiff);

if(error>tolerance){
    BOOST_ERROR("\n Put-call parity failed for spot delta. \n"
                << "Calculated Call Delta: " << deltaCall << "\n"
                << "Calculated Put Delta:  " << deltaPut << "\n"
                << "Expected Difference:   " << expectedDiff << "\n"
                << "Calculated Difference: " << calculatedDiff);
}
myCalc.setDeltaType(DeltaVolQuote::Fwd);

deltaCall=myCalc.deltaFromStrike(values[i].strike);;
myCalc.setOptionType(Option::Put);
deltaPut=myCalc.deltaFromStrike(values[i].strike);;
myCalc.setOptionType(Option::Call);

expectedDiff=1.0;
calculatedDiff=deltaCall-deltaPut;
error=std::fabs(expectedDiff-calculatedDiff);

if(error>tolerance){
    BOOST_ERROR("\n Put-call parity failed for forward delta. \n"
                << "Calculated Call Delta: " << deltaCall << "\n"
                << "Calculated Put Delta:  " << deltaPut << "\n"
                << "Expected Difference:   " << expectedDiff << "\n"
                << "Calculated Difference: " << calculatedDiff );
}

myCalc.setDeltaType(DeltaVolQuote::PaSpot);

deltaCall=myCalc.deltaFromStrike(values[i].strike);;
myCalc.setOptionType(Option::Put);
deltaPut=myCalc.deltaFromStrike(values[i].strike);;
myCalc.setOptionType(Option::Call);

expectedDiff=discFor*values[i].strike/forward;
calculatedDiff=deltaCall-deltaPut;
error=std::fabs(expectedDiff-calculatedDiff);

if(error>tolerance){
    BOOST_ERROR("\n Put-call parity failed for "
                "premium-adjusted spot delta. \n"
                << "Calculated Call Delta: " << deltaCall << "\n"
                << "Calculated Put Delta:  " << deltaPut << "\n"
                << "Expected Difference:   " << expectedDiff << "\n"
                << "Calculated Difference: " << calculatedDiff);
}

myCalc.setDeltaType(DeltaVolQuote::PaFwd);

deltaCall=myCalc.deltaFromStrike(values[i].strike);;
myCalc.setOptionType(Option::Put);
deltaPut=myCalc.deltaFromStrike(values[i].strike);;
myCalc.setOptionType(Option::Call);

expectedDiff = values[i].strike/forward;
calculatedDiff=deltaCall-deltaPut;
error=std::fabs(expectedDiff-calculatedDiff);

if(error>tolerance){
    BOOST_ERROR("\n Put-call parity failed for premium-adjusted "
                "forward delta. \n"
                << "Calculated Call Delta: " << deltaCall << "\n"
                << "Calculated Put Delta:  " << deltaPut << "\n"
                << "Expected Difference:   " << expectedDiff << "\n"
                << "Calculated Difference: " << calculatedDiff);
}
}

for (Size i=0; i<LENGTH(values); i++) {

currDt      =values[i].dt;
currSpot    =values[i].spot;
currdDf     =values[i].dDf;
currfDf     =values[i].fDf;
currStdDev  =values[i].stdDev;
currFwd     =currSpot*currfDf/currdDf;

BlackDeltaCalculator myCalc(Option::Call, currDt, currSpot, currdDf,
                            currfDf, currStdDev);

currAtmStrike=myCalc.atmStrike(DeltaVolQuote::AtmDeltaNeutral);
currCallDelta=myCalc.deltaFromStrike(currAtmStrike);
myCalc.setOptionType(Option::Put);
currPutDelta=myCalc.deltaFromStrike(currAtmStrike);
myCalc.setOptionType(Option::Call);

expected    =0.0;
calculated  =currCallDelta+currPutDelta;
error       =std::fabs(calculated-expected);

if(error>tolerance){
    BOOST_ERROR("\n Delta neutrality failed for spot delta "
                "in Delta Calculator. \n"
                << "Iteration: "<< i << "\n"
                << "Calculated Delta Sum: " << calculated << "\n"
                << "Expected Delta Sum:   " << expected << "\n"
                << "Error: "                << error);
}

myCalc.setDeltaType(DeltaVolQuote::Fwd);
currAtmStrike=myCalc.atmStrike(DeltaVolQuote::AtmDeltaNeutral);
currCallDelta=myCalc.deltaFromStrike(currAtmStrike);
myCalc.setOptionType(Option::Put);
currPutDelta=myCalc.deltaFromStrike(currAtmStrike);
myCalc.setOptionType(Option::Call);

expected    =0.0;
calculated  =currCallDelta+currPutDelta;
error       =std::fabs(calculated-expected);

if(error>tolerance){
    BOOST_ERROR("\n Delta neutrality failed for forward delta "
                "in Delta Calculator. \n"
                << "Iteration: " << i << "\n"
                << "Calculated Delta Sum: " << calculated << "\n"
                << "Expected Delta Sum:   " << expected << "\n"
                << "Error: "                << error);
}

myCalc.setDeltaType(DeltaVolQuote::PaSpot);
currAtmStrike=myCalc.atmStrike(DeltaVolQuote::AtmDeltaNeutral);
currCallDelta=myCalc.deltaFromStrike(currAtmStrike);
myCalc.setOptionType(Option::Put);
currPutDelta=myCalc.deltaFromStrike(currAtmStrike);
myCalc.setOptionType(Option::Call);

expected    =0.0;
calculated  =currCallDelta+currPutDelta;
error       =std::fabs(calculated-expected);

if(error>tolerance){
    BOOST_ERROR("\n Delta neutrality failed for premium-adjusted "
                "spot delta in Delta Calculator. \n"
                << "Iteration: " << i << "\n"
                << "Calculated Delta Sum: " << calculated << "\n"
                << "Expected Delta Sum:   " << expected << "\n"
                << "Error: "                << error);
}


myCalc.setDeltaType(DeltaVolQuote::PaFwd);
currAtmStrike=myCalc.atmStrike(DeltaVolQuote::AtmDeltaNeutral);
currCallDelta=myCalc.deltaFromStrike(currAtmStrike);
myCalc.setOptionType(Option::Put);
currPutDelta=myCalc.deltaFromStrike(currAtmStrike);
myCalc.setOptionType(Option::Call);

expected    =0.0;
calculated  =currCallDelta+currPutDelta;
error       =std::fabs(calculated-expected);

if(error>tolerance){
    BOOST_ERROR("\n Delta neutrality failed for premium-adjusted "
                "forward delta in Delta Calculator. \n"
                << "Iteration: " << i << "\n"
                << "Calculated Delta Sum: " << calculated << "\n"
                << "Expected Delta Sum:   " << expected << "\n"
                << "Error: " << error);
}

// Test ATM forward Calculations
calculated=myCalc.atmStrike(DeltaVolQuote::AtmFwd);
expected=currFwd;
error=std::fabs(expected-calculated);

if(error>tolerance){
    BOOST_ERROR("\n Atm forward test failed. \n"
                << "Calculated Value: " << calculated << "\n"
                << "Expected   Value: " << expected << "\n"
                << "Error: " << error);
}

// Test ATM 0.50 delta calculations
myCalc.setDeltaType(DeltaVolQuote::Fwd);
Real atmFiftyStrike=myCalc.atmStrike(DeltaVolQuote::AtmPutCall50);
calculated=std::fabs(myCalc.deltaFromStrike(atmFiftyStrike));
expected=0.50;
error=std::fabs(expected-calculated);

if(error>tolerance){
    BOOST_ERROR("\n Atm 0.50 delta strike test failed. \n"
                << "Iteration:" << i << "\n"
                << "Calculated Value: " << calculated << "\n"
                << "Expected   Value: " << expected << "\n"
                << "Error: "    << error);
}
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/distributions.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i<LENGTH(values); i++) {
    Bivariate bcd(values[i].rho);
    Real value = bcd(values[i].a, values[i].b);

    Real tolerance = 1.0e-6;
    if (std::fabs(value-values[i].result) >= tolerance) {
        BOOST_ERROR(tag << " bivariate cumulative distribution\n"
                    << "    case: " << i+1 << "\n"
                    << QL_FIXED
                    << "    a:    " << values[i].a << "\n"
                    << "    b:    " << values[i].b << "\n"
                    << "    rho:  " << values[i].rho <<"\n"
                    << QL_SCIENTIFIC
                    << "    tabulated value:  "
                    << values[i].result << "\n"
                    << "    result:           " << value);
    }
}

for (Size i=0;i<LENGTH(rho);i++) {
    for (Integer sgn=-1; sgn < 2; sgn+=2) {
        Bivariate bvn(sgn*rho[i]);
        Real expected = 0.25 + std::asin(sgn*rho[i]) / (2*M_PI) ;
        Real realised = bvn(x,y);

        if (std::fabs(realised-expected)>=tolerance) {
            BOOST_ERROR(tag << " bivariate cumulative distribution\n"
                        << QL_SCIENTIFIC
                        << "    rho: " << sgn*rho[i] << "\n"
                        << "    expected:  " << expected << "\n"
                        << "    realised:  " << realised << "\n"
                        << "    tolerance: " << tolerance);
        }
    }
}

for (int i = 0; i<10;i++) {
    Real cdf0 = bvn(x,y);
    y = y + tolerance;
    Real cdf1 = bvn(x,y);
    if (cdf0 > cdf1) {
        BOOST_ERROR(tag << " cdf must be decreasing in the tails\n"
                    << QL_SCIENTIFIC
                    << "    cdf0: " << cdf0 << "\n"
                    << "    cdf1: " << cdf1 << "\n"
                    << "    x: " << x << "\n"
                    << "    y: " << y << "\n"
                    << "    rho: " << corr);
    }
}

for (i=0; i<N; i++)
x[i] = xMin+h*i;

for (i=0; i<x.size(); i++)
temp[i] = cum.derivative(x[i]);

for (i=0; i<x.size(); i++)
temp[i] = normal.derivative(x[i]);

for (Real mean=0.0; mean<=10.0; mean+=0.5) {
BigNatural i = 0;
PoissonDistribution pdf(mean);
Real calculated = pdf(i);
Real logHelper = -mean;
Real expected = std::exp(logHelper);
Real error = std::fabs(calculated-expected);
if (error > 1.0e-16)
    BOOST_ERROR("Poisson pdf(" << mean << ")(" << i << ")\n"
                << std::setprecision(16)
                << "    calculated: " << calculated << "\n"
                << "    expected:   " << expected << "\n"
                << "    error:      " << error);

for (i=1; i<25; i++) {
    calculated = pdf(i);
    if (mean == 0.0) {
        expected = 0.0;
    } else {
        logHelper = logHelper+std::log(mean)-std::log(Real(i));
        expected = std::exp(logHelper);
    }
    error = std::fabs(calculated-expected);
    if (error>1.0e-13)
        BOOST_ERROR("Poisson pdf(" << mean << ")(" << i << ")\n"
                    << std::setprecision(13)
                    << "    calculated: " << calculated << "\n"
                    << "    expected:   " << expected << "\n"
                    << "    error:      " << error);
}
}

for (Real mean=0.0; mean<=10.0; mean+=0.5) {
BigNatural i = 0;
CumulativePoissonDistribution cdf(mean);
Real cumCalculated = cdf(i);
Real logHelper = -mean;
Real cumExpected = std::exp(logHelper);
Real error = std::fabs(cumCalculated-cumExpected);
if (error>1.0e-13)
    BOOST_ERROR("Poisson cdf(" << mean << ")(" << i << ")\n"
                << std::setprecision(13)
                << "    calculated: " << cumCalculated << "\n"
                << "    expected:   " << cumExpected << "\n"
                << "    error:      " << error);
for (i=1; i<25; i++) {
    cumCalculated = cdf(i);
    if (mean == 0.0) {
        cumExpected = 1.0;
    } else {
        logHelper = logHelper+std::log(mean)-std::log(Real(i));
        cumExpected += std::exp(logHelper);
    }
    error = std::fabs(cumCalculated-cumExpected);
    if (error>1.0e-12)
        BOOST_ERROR("Poisson cdf(" << mean << ")(" << i << ")\n"
                    << std::setprecision(12)
                    << "    calculated: " << cumCalculated << "\n"
                    << "    expected:   " << cumExpected << "\n"
                    << "    error:      " << error);
}
}

for (Size i=0; i<LENGTH(data); i++) {
if (!close(icp(data[i]), static_cast<Real>(i))) {
    BOOST_ERROR(std::setprecision(8)
                << "failed to reproduce known value for x = "
                << data[i] << "\n"
                << "    calculated: " << icp(data[i]) << "\n"
                << "    expected:   " << Real(i));
}
}

for (Size i=0; i < LENGTH(ns); ++i) {
BivariateCumulativeStudentDistribution f1(ns[i],  0.5);
BivariateCumulativeStudentDistribution f2(ns[i], -0.5);
for (Size j=0; j < LENGTH(xs); ++j) {
	Real calculated1 = f1(xs[j], xs[j]);
    Real reference1 = expected1[i*LENGTH(xs)+j];
	Real calculated2 = f2(xs[j], xs[j]);
    Real reference2 = expected2[i*LENGTH(xs)+j];
    if (std::fabs(calculated1 - reference1) > tolerance)
        BOOST_ERROR("Failed to reproduce CDF value at " << xs[j] <<
                    "\n    calculated: " << calculated1 <<
                    "\n    expected:   " << reference1);
    if (std::fabs(calculated2 - reference2) > tolerance)
        BOOST_ERROR("Failed to reproduce CDF value at " << xs[j] <<
                    "\n    calculated: " << calculated2 <<
                    "\n    expected:   " << reference1);
}
}

for (Size i=0; i < LENGTH(cases); ++i) {
BivariateCumulativeStudentDistribution f(cases[i].n,  cases[i].rho);
Real calculated = f(cases[i].x, cases[i].y);
Real expected = cases[i].result;
if (std::fabs(calculated - expected) > tolerance)
    BOOST_ERROR("Failed to reproduce CDF value:" <<
                "\n    n:   " << cases[i].n <<
                "\n    rho: " << cases[i].rho <<
                "\n    x:   " << cases[i].x <<
                "\n    y:   " << cases[i].y <<
                "\n    calculated: " << calculated <<
                "\n    expected:   " << expected);
}

for (Real rho = -1.0; rho < 1.01; rho += 0.25) {
BivariateCumulativeStudentDistribution T(n, rho);
BivariateCumulativeNormalDistribution N(rho);

Real avgDiff = 0.0;
Size m = 0;
Real tolerance = 4.0e-5;
for (Real x = -10; x < 10.1; x += 0.25) {
	for (Real y = -10; y < 10.1; y += 0.25) {
        Real calculated = T(x, y);
        Real expected = N(x, y);
		Real diff = std::fabs(calculated - expected);
        if (diff > tolerance)
            BOOST_ERROR("Failed to reproduce limit value:" <<
                        "\n    rho: " << rho <<
                        "\n    x:   " << x <<
                        "\n    y:   " << y <<
                        "\n    calculated: " << calculated <<
                        "\n    expected:   " << expected);
        
		avgDiff += diff;
		++m;
	}
}
avgDiff /= m;
if (avgDiff > 3.0e-6)
    BOOST_ERROR("Failed to reproduce average limit value:" <<
                "\n    rho: " << rho <<
                "\n    average error: " << avgDiff);
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/tqreigendecomposition.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i < diag.size(); ++i) {
const Real expected(ev[i]);
const Real calculated(tqre.eigenvalues()[i]);
if (std::fabs(expected-calculated) > tolerance) {
    BOOST_FAIL(std::string("wrong eigenvalue \n")
               << "calculated: "
               << calculated
               <<" expected  : "
               << expected);
}
}

for (Size i=0; i < diag.size(); ++i) {
const Real expected(tqre2.eigenvalues()[i]);
const Real calculated(tqre1.eigenvalues()[i]);
if (std::fabs(expected-calculated) > tolerance) {
    BOOST_FAIL(std::string("wrong eigenvalue \n")
               << "calculated: "
               << calculated
               << " expected  : "
               << expected);
}
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/marketmodel.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=1; i<dates.size(); ++i)
    rateTimes[i-1] = dayCounter.yearFraction(todaysDate, dates[i]);

for (Size i=1; i<rateTimes.size(); ++i)
    accruals[i-1] = rateTimes[i] - rateTimes[i-1];

for (Size i=0; i<todaysForwards.size(); ++i)
{
    // FLOATING_POINT_EXCEPTION
    todaysForwards[i] = 0.03 + 0.0010*i;
    meanForward+= todaysForwards[i];
}

for (Size i=1; i<rateTimes.size(); ++i)
    todaysDiscounts[i] = todaysDiscounts[i-1] /
    (1.0+todaysForwards[i-1]*accruals[i-1]);

for (Size i=1; i<=N; ++i) {
    if (i==1) {
        coterminalAnnuity[N-1] = accruals[N-1]*todaysDiscounts[N];
    } else {
        coterminalAnnuity[N-i] = coterminalAnnuity[N-i+1] +
            accruals[N-i]*todaysDiscounts[N-i+1];
    }
    floatingLeg = todaysDiscounts[N-i]-todaysDiscounts[N];
    todaysCoterminalSwapRates[N-i] = floatingLeg/coterminalAnnuity[N-i];
}

for (Size i=0; i<std::min(LENGTH(mktVols),todaysForwards.size()); i++) {
    volatilities[i] = todaysForwards[i]*mktVols[i]/
        (todaysForwards[i]+displacement);
    blackVols[i]= mktVols[i];
    normalVols[i]= mktVols[i]*todaysForwards[i];
}

    for (Size i=0; i<subProductExpectedValues.size(); ++i) {
        for (Size j=0; j<subProductExpectedValues[i].values.size(); ++j)
            ++nbOfResults;
    }

            for (Size j=0; j<subProductExpectedValue->values.size(); ++j) {
                Real stdDev =
                    (results[currentResultIndex]-subProductExpectedValue->values[j])
                    /errors[currentResultIndex];
                stdDevs.push_back(stdDev);
                maxError = std::max(maxError, stdDev);
                minError = std::min(minError, stdDev);
                ++currentResultIndex;
            }

                    for (Size j=0; j<subProductExpectedValue->values.size(); ++j) {
                        BOOST_TEST_MESSAGE(io::ordinal(j+1)
                            << " "  << subProductExpectedValue->description
                            << ": " << io::rate(results[currentResultIndex])
                            << "\t" << io::rate(subProductExpectedValue->values[j])
                            << "\t" << io::rate(errors[currentResultIndex])
                            << "; discrepancy = "
                            << stdDevs[currentResultIndex]
                        << "\n");
                        ++currentResultIndex;
                    }

    for (Size i=0; i<N; ++i) {
        expectedForwards[i] = (todaysForwards[i]-forwardStrikes[i])
            *accruals[i]*todaysDiscounts[i+1];
        forwardStdDevs[i] = (results[i]-expectedForwards[i])/errors[i];
        if (forwardStdDevs[i]>maxError)
            maxError = forwardStdDevs[i];
        else if (forwardStdDevs[i]<minError)
            minError = forwardStdDevs[i];
        Time expiry = rateTimes[i];
        expectedCaplets[i] =
            BlackCalculator(displacedPayoffs[i],
            todaysForwards[i]+displacement,
            volatilities[i]*std::sqrt(expiry),
            todaysDiscounts[i+1]*accruals[i]).value();
        capletStdDev[i] = (results[i+N]-expectedCaplets[i])/errors[i+N];
        if (capletStdDev[i]>maxError)
            maxError = capletStdDev[i];
        else if (capletStdDev[i]<minError)
            minError = capletStdDev[i];
    }

            for (i=0; i<N; ++i) {
                BOOST_TEST_MESSAGE(io::ordinal(i+1) << " forward: "
                    << io::rate(results[i])
                    << "\t" << io::rate(expectedForwards[i])
                    << "\t" << io::rate(errors[i])
                    << "; discrepancy = "
                    << forwardStdDevs[i]
                << "\n");
            }

            for (i=0; i<N; ++i) {
                BOOST_TEST_MESSAGE(
                    io::ordinal(i+1) << "\t"
                    << io::rate(results[i+N])
                    << " +- " << io::rate(errors[i+N])
                    << "\t" << io::rate(expectedCaplets[i])
                    << "\t" << io::rate(errors[i+N])
                    << "; discrepancy = "
                    << (results[i+N]-expectedCaplets[i])/(errors[i+N] == 0.0 ?
                    1.0 : errors[i+N])
                    << "\n");
            }

    for (Size i=0; i<N; ++i) {
        expectedForwards[i] = (todaysForwards[i]-forwardStrikes[i])
            *accruals[i]*todaysDiscounts[i+1];
        forwardStdDevs[i] = (results[i]-expectedForwards[i])/errors[i];
        if (forwardStdDevs[i]>maxError)
            maxError = forwardStdDevs[i];
        else if (forwardStdDevs[i]<minError)
            minError = forwardStdDevs[i];
        Time expiry = rateTimes[i];
        expectedCaplets[i] =
            bachelierBlackFormula(displacedPayoffs[i],
            todaysForwards[i]+displacement,
            normalVols[i]*std::sqrt(expiry),
            todaysDiscounts[i+1]*accruals[i]);
        capletStdDev[i] = (results[i+N]-expectedCaplets[i])/errors[i+N];
        if (capletStdDev[i]>maxError)
            maxError = capletStdDev[i];
        else if (capletStdDev[i]<minError)
            minError = capletStdDev[i];
    }

            for (i=0; i<N; ++i) {
                BOOST_TEST_MESSAGE(io::ordinal(i+1) << " forward: "
                    << io::rate(results[i])
                    << " +- " << io::rate(errors[i])
                    << "; expected: " << io::rate(expectedForwards[i])
                    << "; discrepancy = "
                    << forwardStdDevs[i]
                << " standard errors");
            }

            for (i=0; i<N; ++i) {
                BOOST_TEST_MESSAGE(
                    io::ordinal(i+1) << " caplet: "
                    << io::rate(results[i+N])
                    << " +- " << io::rate(errors[i+N])
                    << "; expected: " << io::rate(expectedCaplets[i])
                    << "; discrepancy = "
                    << (results[i+N]-expectedCaplets[i])/(errors[i+N] == 0.0 ?
                    1.0 : errors[i+N])
                    << " standard errors");
            }

for (Size i=0; i<todaysForwards.size(); ++i) {
forwardStrikes[i] = todaysForwards[i] + 0.01;
optionletPayoffs[i] = boost::shared_ptr<Payoff>(new
    PlainVanillaPayoff(Option::Call, todaysForwards[i]));
displacedPayoffs[i] = boost::shared_ptr<StrikedTypePayoff>(new
    PlainVanillaPayoff(Option::Call, todaysForwards[i]+displacement));
}

for (Size j=0; j<LENGTH(marketModels); j++) {

    // one step must be always full factors
    Size testedFactors[] = { todaysForwards.size()};
    for (Size m=0; m<LENGTH(testedFactors); ++m) {
        Size factors = testedFactors[m];

        // for one step product ProductSuggested is equal to Terminal
        // for one step product MoneyMarketPlus is equal to Terminal
        MeasureType measures[] = { MoneyMarket,
            Terminal };
        for (Size k=0; k<LENGTH(measures); k++) {
            std::vector<Size> numeraires = makeMeasure(product, measures[k]);

            bool logNormal = true;
            boost::shared_ptr<MarketModel> marketModel =
                makeMarketModel(logNormal, evolution, factors, marketModels[j]);

            EvolverType evolvers[] = { Pc,  Balland, Ipc};
            boost::shared_ptr<MarketModelEvolver> evolver;
            Size stop =
                isInTerminalMeasure(evolution, numeraires) ? 0 : 1;
            for (Size i=0; i<LENGTH(evolvers)-stop; i++) {

                for (Size n=0; n<1; n++) {
                    MTBrownianGeneratorFactory generatorFactory(seed_);
                    //SobolBrownianGeneratorFactory generatorFactory(
                    //    SobolBrownianGenerator::Diagonal, seed_);

                    evolver = makeMarketModelEvolver(marketModel,
                        numeraires,
                        generatorFactory,
                        evolvers[i]);
                    std::ostringstream config;
                    config <<
                        marketModelTypeToString(marketModels[j]) << ", " <<
                        factors << (factors>1 ? (factors==todaysForwards.size() ? " (full) factors, " : " factors, ") : " factor,") <<
                        measureTypeToString(measures[k]) << ", " <<
                        evolverTypeToString(evolvers[i]) << ", " <<
                        "MT BGF";
                    if (printReport_)
                        BOOST_TEST_MESSAGE("    " << config.str());

                    boost::shared_ptr<SequenceStatisticsInc> stats =
                        simulate(evolver, product);
                    checkForwardsAndOptionlets(*stats,
                        forwardStrikes,
                        displacedPayoffs,
                        config.str());
                }
            }
        }
    }
}

for (Size i=0; i<todaysForwards.size(); ++i) {
forwardStrikes[i] = todaysForwards[i] + 0.01;
optionletPayoffs[i] = boost::shared_ptr<Payoff>(new
    PlainVanillaPayoff(Option::Call, todaysForwards[i]));
displacedPayoffs[i] = boost::shared_ptr<PlainVanillaPayoff>(new
    PlainVanillaPayoff(Option::Call, todaysForwards[i]+displacement));
}

for (Size j=0; j<LENGTH(marketModels); j++) {

    // one step must be always full factors
    Size testedFactors[] = { todaysForwards.size()};
    for (Size m=0; m<LENGTH(testedFactors); ++m) {
        Size factors = testedFactors[m];

        // for one step product ProductSuggested is equal to Terminal
        // for one step product MoneyMarketPlus is equal to Terminal
        MeasureType measures[] = { MoneyMarket,
            Terminal };
        for (Size k=0; k<LENGTH(measures); k++) {
            std::vector<Size> numeraires = makeMeasure(product, measures[k]);

            bool logNormal = false;
            boost::shared_ptr<MarketModel> marketModel =
                makeMarketModel(logNormal, evolution, factors, marketModels[j]);

            EvolverType evolvers[] = { NormalPc};
            boost::shared_ptr<MarketModelEvolver> evolver;
            Size stop =
                isInTerminalMeasure(evolution, numeraires) ? 0 : 1;
            for (Size i=0; i<LENGTH(evolvers)-stop; i++) {

                for (Size n=0; n<1; n++) {
                    MTBrownianGeneratorFactory generatorFactory(seed_);
                    //SobolBrownianGeneratorFactory generatorFactory(
                    //    SobolBrownianGenerator::Diagonal, seed_);

                    evolver = makeMarketModelEvolver(marketModel,
                        numeraires,
                        generatorFactory,
                        evolvers[i]);
                    std::ostringstream config;
                    config <<
                        marketModelTypeToString(marketModels[j]) << ", " <<
                        factors << (factors>1 ? (factors==todaysForwards.size() ? " (full) factors, " : " factors, ") : " factor,") <<
                        measureTypeToString(measures[k]) << ", " <<
                        evolverTypeToString(evolvers[i]) << ", " <<
                        "MT BGF";
                    if (printReport_)
                        BOOST_TEST_MESSAGE("    " << config.str());

                    boost::shared_ptr<SequenceStatisticsInc> stats =
                        simulate(evolver, product);
                    checkNormalForwardsAndOptionlets(*stats,
                        forwardStrikes,
                        displacedPayoffs,
                        config.str());
                }
            }
        }
    }
}

for (Size j=0; j<LENGTH(marketModels); j++)
{

    Size testedFactors[] = { std::min<Size>(todaysForwards.size(),3)};
    for (Size m=0; m<LENGTH(testedFactors); ++m) 
    {
        Size factors = testedFactors[m];

        MeasureType measures[] = { MoneyMarket};
        for (Size k=0; k<LENGTH(measures); k++) 
        {
            std::vector<Size> numeraires = makeMeasure(product, measures[k]);

            bool logNormal = false;
            boost::shared_ptr<MarketModel> marketModel =
                makeMarketModel(logNormal, evolution, factors, marketModels[j]);

            EvolverType evolvers[] = {Pc};
            boost::shared_ptr<MarketModelEvolver> evolver;

            for (Size i=0; i<LENGTH(evolvers); i++)
            {

              
                    MTBrownianGeneratorFactory generatorFactory(seed_);
                    //SobolBrownianGeneratorFactory generatorFactory(
                    //    SobolBrownianGenerator::Diagonal, seed_);

                    evolver = makeMarketModelEvolver(marketModel,
                        numeraires,
                        generatorFactory,
                        evolvers[i]);
                    std::ostringstream config;
                    config <<
                        marketModelTypeToString(marketModels[j]) << ", " <<
                        factors << (factors>1 ? (factors==todaysForwards.size() ? " (full) factors, " : " factors, ") : " factor,") <<
                        measureTypeToString(measures[k]) << ", " <<
                        evolverTypeToString(evolvers[i]) << ", " <<
                        "MT BGF";
                    if (printReport_)
                        BOOST_TEST_MESSAGE("    " << config.str());

                    boost::shared_ptr<SequenceStatisticsInc> stats =
                        simulate(evolver, productComposite);

                    std::vector<Real> modelVolatilities(accruals.size());
                    for (Size i=0; i <  accruals.size(); ++i)
                            modelVolatilities[i] = sqrt(marketModel->totalCovariance(i)[i][i]);
                   


                     Real truePrice =0.0;

                     for (Size i=0; i < accruals.size(); ++i)
                     {
                                Real floatingCouponPV = floatingAccruals[i] *(todaysForwards[i]+floatingSpreads[i])*todaysDiscounts[i+1];
                                Real inverseCouponPV =  2*fixedAccruals[i] *todaysDiscounts[i+1]* blackFormula(Option::Put,
                                fixedStrikes[i]/2.0,
                                todaysForwards[i],
                                modelVolatilities[i]);

                                truePrice += floatingCouponPV - inverseCouponPV;
                      }

                                   



                    Real priceError = stats->mean()[0] - truePrice;
                    Real priceSD = stats->errorEstimate()[0];

                    Real errorInSds = priceError/priceSD;
                    if (fabs(errorInSds) > 4.0)
                        BOOST_FAIL("Inverse floater product has price error equal to " <<errorInSds << " sds . Price " <<truePrice << " MC price " << stats->mean()[0] <<  " \n" );

                    Real numericalTolerance = 1E-12;

                    if (fabs(stats->mean()[0] - stats->mean()[1]) > numericalTolerance)
                        BOOST_FAIL("Inverse floater and wrapper pathwise inverse floater do not agree:" << stats->mean()[0]  << "  " << stats->mean()[1] );
               



                
            } // evolvers
        } // measures
    } // factors 
}

                               for (Size j=0; j<LENGTH(marketModels); j++) {

                                   Size testedFactors[] = { 4, 8,
                                       todaysForwards.size()};
                                   for (Size m=0; m<LENGTH(testedFactors); ++m) {
                                       Size factors = testedFactors[m];

                                       // Composite's ProductSuggested is the Terminal one
                                       MeasureType measures[] = { // ProductSuggested,
                                           Terminal,
                                           MoneyMarketPlus,
                                           MoneyMarket};
                                           for (Size k=0; k<LENGTH(measures); k++) {
                                               std::vector<Size> numeraires = makeMeasure(product, measures[k]);

                                               bool logNormal = true;
                                               boost::shared_ptr<MarketModel> marketModel =
                                                   makeMarketModel(logNormal, evolution, factors, marketModels[j]);


                                               EvolverType evolvers[] = { Pc, Balland, Ipc };
                                               boost::shared_ptr<MarketModelEvolver> evolver;
                                               Size stop =
                                                   isInTerminalMeasure(evolution, numeraires) ? 0 : 1;
                                               for (Size i=0; i<LENGTH(evolvers)-stop; i++) {

                                                   for (Size n=0; n<1; n++) {
                                                       //MTBrownianGeneratorFactory generatorFactory(seed_);
                                                       SobolBrownianGeneratorFactory generatorFactory(
                                                           SobolBrownianGenerator::Diagonal, seed_);

                                                       evolver = makeMarketModelEvolver(marketModel,
                                                           numeraires,
                                                           generatorFactory,
                                                           evolvers[i]);
                                                       std::ostringstream config;
                                                       config <<
                                                           marketModelTypeToString(marketModels[j]) << ", " <<
                                                           factors << (factors>1 ? (factors==todaysForwards.size() ? " (full) factors, " : " factors, ") : " factor,") <<
                                                           measureTypeToString(measures[k]) << ", " <<
                                                           evolverTypeToString(evolvers[i]) << ", " <<
                                                           "MT BGF";
                                                       if (printReport_)
                                                           BOOST_TEST_MESSAGE("    " << config.str());

                                                       boost::shared_ptr<SequenceStatisticsInc> stats =
                                                           simulate(evolver, product);
                                                       checkMultiProductCompositeResults(*stats,
                                                           subProductExpectedValues,
                                                           config.str());
                                                   }
                                               }
                                           }
                                   }
                               }

             for (Size i=0; i<todaysForwards.size(); ++i)
                 forwardStrikes[i] = todaysForwards[i] + 0.01;

             for (Size i=0; i<todaysForwards.size(); ++i) {
                 subProductExpectedValues.back().values.push_back(
                     (todaysForwards[i]-forwardStrikes[i])
                     *accruals[i]*todaysDiscounts[i+1]);
             }

               for (Size i=0; i<todaysForwards.size(); ++i) {
                   optionletPayoffs[i] = boost::shared_ptr<Payoff>(new
                       PlainVanillaPayoff(Option::Call, todaysForwards[i]));
                   //CashOrNothingPayoff(Option::Call, todaysForwards[i], 0.01));
                   displacedPayoffs[i] = boost::shared_ptr<StrikedTypePayoff>(new
                       PlainVanillaPayoff(Option::Call, todaysForwards[i]+displacement));
                   //CashOrNothingPayoff(Option::Call, todaysForwards[i]+displacement, 0.01));
               }

               for (Size i=0; i<todaysForwards.size(); ++i) {
                   subProductExpectedValues.back().values.push_back(
                       BlackCalculator(displacedPayoffs[i],
                       todaysForwards[i]+displacement,
                       volatilities[i]*std::sqrt(rateTimes[i]),
                       todaysDiscounts[i+1]*accruals[i]).value());
               }

                   for (Size i=0; i<todaysForwards.size(); ++i) {
                       coinitialSwapValue += (todaysForwards[i]-fixedRate)
                           *accruals[i]*todaysDiscounts[i+1];
                       subProductExpectedValues.back().values.push_back(coinitialSwapValue);
                   }

                                for (Size i = 0; i < payoffs.size(); ++i)
                                    payoffs[i] = boost::shared_ptr<StrikedTypePayoff>(new
                                    PlainVanillaPayoff(Option::Call, todaysForwards[i]));

                                for (Size i=0; i<todaysForwards.size(); ++i) {
                                    Real expectedNPV = curveState.coterminalSwapAnnuity(0, i) * (atmRates[i]-fixedRate) *
                                        todaysDiscounts.front();
                                    subProductExpectedValues.back().values.push_back(expectedNPV);
                                }

                                for (Size i=0; i<todaysForwards.size(); ++i) {
                                    const Matrix& forwardsCovariance = marketModel->totalCovariance(i);
                                    Matrix cotSwapsCovariance =
                                        jacobian * forwardsCovariance * transpose(jacobian);
                                    boost::shared_ptr<PlainVanillaPayoff> payoff(
                                        new PlainVanillaPayoff(Option::Call, todaysForwards[i]+displacement));

                                    Real expectedSwaption =
                                        BlackCalculator(payoff,
                                        todaysCoterminalSwapRates[i]+displacement,
                                        std::sqrt(cotSwapsCovariance[i][i]),
                                        curveState.coterminalSwapAnnuity(0,i) *
                                        todaysDiscounts[0]).value();
                                    subProductExpectedValues.back().values.push_back(expectedSwaption);
                                }

for (Size i=0; i<numberBigRates; ++i)
{
optionletPayoffs[i] = boost::shared_ptr<StrikedTypePayoff>(new
    PlainVanillaPayoff(Option::Call, bigRateCS.forwardRate(i)));
swaptionPayoffs[i] = boost::shared_ptr<StrikedTypePayoff>(new
    PlainVanillaPayoff(Option::Call, bigRateCS.coterminalSwapRate(i)));
displacedOptionletPayoffs[i] = boost::shared_ptr<StrikedTypePayoff>(new
    PlainVanillaPayoff(Option::Call, bigRateCS.forwardRate(i)+displacement));
displacedSwaptionPayoffs[i] = boost::shared_ptr<StrikedTypePayoff>(new
    PlainVanillaPayoff(Option::Call, bigRateCS.coterminalSwapRate(i)+displacement));

}

for (Size j=0; j < adaptedSwapModel->numberOfRates(); ++j)
{
adaptedForwardSds[j] = sqrt(finalForwardCovariances[j][j]);
adaptedSwapSds[j] = sqrt(finalSwapCovariances[j][j]);

Real capletAnnuity = todaysDiscounts[0]*bigRateCS.discountRatio(j+1,0)
    *bigRateCS.rateTaus()[j];

approxCapletPrices[j] = BlackCalculator(displacedOptionletPayoffs[j],
    bigRateCS.forwardRate(j)+displacement,
    adaptedForwardSds[j],
    capletAnnuity).value();

Real swaptionAnnuity = todaysDiscounts[0]
*bigRateCS.coterminalSwapAnnuity(0,j);

approxSwaptionPrices[j] = BlackCalculator(displacedSwaptionPayoffs[j],
    bigRateCS.coterminalSwapRate(j)+displacement,
    adaptedSwapSds[j],
    swaptionAnnuity).value();
}

for (Size i=0; i < numberBigRates; ++i)
{
capletErrorsInSds[i]= (results[i]-approxCapletPrices[i])/errors[i];
swaptionErrorsInSds[i]= (results[i+numberBigRates]-approxSwaptionPrices[i])/errors[i+numberBigRates];
}

for (Size i=0; i < numberBigRates; ++i) {
if (fabs(capletErrorsInSds[i]) > capletTolerance) {
    BOOST_FAIL(io::ordinal(i+1) << "caplet , approx price " <<
        approxCapletPrices[i] <<
        ", \t simulation price " << results[i] <<
        ", \t error in sds " << capletErrorsInSds[i]);
}
}

for (Size i=0; i < numberBigRates; ++i) {
if (fabs(swaptionErrorsInSds[i]) > swaptionTolerance) {
    BOOST_FAIL(io::ordinal(i+1) << "swaption, approx price " <<
        approxSwaptionPrices[i] <<
        ", \t simulation price " << results[i+numberBigRates] <<
        ", \t error in sds " << swaptionErrorsInSds[i]);
}
}

for (Size j=0; j<LENGTH(marketModels); j++) {

    Size testedFactors[] = { 4, // 8,
        todaysForwards.size()};
    for (Size m=0; m<LENGTH(testedFactors); ++m) {
        Size factors = testedFactors[m];

        // Composite's ProductSuggested is the Terminal one
        MeasureType measures[] = { // ProductSuggested,
            MoneyMarketPlus
            // MoneyMarket,
            // Terminal
        };
        for (Size k=0; k<LENGTH(measures); k++) {
            std::vector<Size> numeraires = makeMeasure(dummyProduct, measures[k]);

            bool logNormal = true;
            boost::shared_ptr<MarketModel> marketModel =
                makeMarketModel(logNormal, evolution, factors, marketModels[j]);


            EvolverType evolvers[] = { Pc, Balland, Ipc };
            boost::shared_ptr<MarketModelEvolver> evolver;
            Size stop =
                isInTerminalMeasure(evolution, numeraires) ? 0 : 1;
            for (Size i=0; i<LENGTH(evolvers)-stop; i++) {

                for (Size n=0; n<1; n++) {
                    //MTBrownianGeneratorFactory generatorFactory(seed_);
                    SobolBrownianGeneratorFactory generatorFactory(
                        SobolBrownianGenerator::Diagonal, seed_);

                    evolver = makeMarketModelEvolver(marketModel,
                        numeraires,
                        generatorFactory,
                        evolvers[i]);
                    std::ostringstream config;
                    config <<
                        marketModelTypeToString(marketModels[j]) << ", " <<
                        factors << (factors>1 ? (factors==todaysForwards.size() ? " (full) factors, " : " factors, ") : " factor,") <<
                        measureTypeToString(measures[k]) << ", " <<
                        evolverTypeToString(evolvers[i]) << ", " <<
                        "MT BGF";
                    if (printReport_)
                        BOOST_TEST_MESSAGE("    " << config.str());

                    // use the naif strategy

                    // 2. bermudan swaption to enter into the payer swap
                    CallSpecifiedMultiProduct bermudanProduct =
                        CallSpecifiedMultiProduct(
                        MultiStepNothing(evolution),
                        naifStrategy, payerSwap);

                    // 3. callable receiver swap
                    CallSpecifiedMultiProduct callableProduct =
                        CallSpecifiedMultiProduct(
                        receiverSwap, naifStrategy,
                        ExerciseAdapter(nullRebate));

                    // lower bound: evolve all 4 products togheter
                    MultiProductComposite allProducts;
                    allProducts.add(payerSwap);
                    allProducts.add(receiverSwap);
                    allProducts.add(bermudanProduct);
                    allProducts.add(callableProduct);
                    allProducts.finalize();

                    boost::shared_ptr<SequenceStatisticsInc> stats =
                        simulate(evolver, allProducts);
                    checkCallableSwap(*stats, config.str());


                    // upper bound

                    //MTBrownianGeneratorFactory uFactory(seed_+142);
                    SobolBrownianGeneratorFactory uFactory(
                        SobolBrownianGenerator::Diagonal, seed_+142);
                    evolver = makeMarketModelEvolver(marketModel,
                        numeraires,
                        uFactory,
                        evolvers[i]);

                    std::vector<boost::shared_ptr<MarketModelEvolver> >
                        innerEvolvers;

                    std::valarray<bool> isExerciseTime =
                        isInSubset(evolution.evolutionTimes(),
                                   naifStrategy.exerciseTimes());
                    for (Size s=0; s < isExerciseTime.size(); ++s) {
                        if (isExerciseTime[s]) {
                            MTBrownianGeneratorFactory iFactory(seed_+s);
                            boost::shared_ptr<MarketModelEvolver> e =
                                makeMarketModelEvolver(marketModel,
                                numeraires,
                                iFactory,
                                evolvers[i],
                                s);
                            innerEvolvers.push_back(e);
                        }
                    }

                    Size initialNumeraire = evolver->numeraires().front();
                    Real initialNumeraireValue =
                        todaysDiscounts[initialNumeraire];

                    UpperBoundEngine uEngine(evolver, innerEvolvers,
                        receiverSwap, nullRebate,
                        receiverSwap, nullRebate,
                        naifStrategy,
                        initialNumeraireValue);
                    Statistics uStats;
                    uEngine.multiplePathValues(uStats,255,256);
                    Real delta = uStats.mean();
                    Real deltaError = uStats.errorEstimate();
                    if (printReport_)
                        BOOST_TEST_MESSAGE("    upper bound delta: " << io::rate(delta) << " +- " << io::rate(deltaError));

                }
            }
        }
    }
}

for (Size j=0; j<LENGTH(marketModels); j++) {

    Size testedFactors[] = { 4, // 8,
        todaysForwards.size()};
    for (Size m=0; m<LENGTH(testedFactors); ++m) {
        Size factors = testedFactors[m];

        // Composite's ProductSuggested is the Terminal one
        MeasureType measures[] = { // ProductSuggested,
            // MoneyMarketPlus,
            MoneyMarket
            //Terminal
        };
        for (Size k=0; k<LENGTH(measures); k++) {
            std::vector<Size> numeraires = makeMeasure(dummyProduct, measures[k]);

            bool logNormal = true;
            boost::shared_ptr<MarketModel> marketModel =
                makeMarketModel(logNormal, evolution, factors, marketModels[j]);


            EvolverType evolvers[] = { Pc, Balland, Ipc };
            boost::shared_ptr<MarketModelEvolver> evolver;
            Size stop =
                isInTerminalMeasure(evolution, numeraires) ? 0 : 1;
            for (Size i=0; i<LENGTH(evolvers)-stop; i++) {

                for (Size n=0; n<1; n++) {
                    //MTBrownianGeneratorFactory generatorFactory(seed_);
                    SobolBrownianGeneratorFactory generatorFactory(
                        SobolBrownianGenerator::Diagonal, seed_);

                    evolver = makeMarketModelEvolver(marketModel,
                        numeraires,
                        generatorFactory,
                        evolvers[i]);
                    std::ostringstream config;
                    config <<
                        marketModelTypeToString(marketModels[j]) << ", " <<
                        factors << (factors>1 ? (factors==todaysForwards.size() ? " (full) factors, " : " factors, ") : " factor,") <<
                        measureTypeToString(measures[k]) << ", " <<
                        evolverTypeToString(evolvers[i]) << ", " <<
                        "MT BGF";
                    if (printReport_)
                        BOOST_TEST_MESSAGE("    " << config.str());

                    // calculate the exercise strategy
                    collectNodeData(*evolver,
                        receiverSwap, basisSystem, nullRebate,
                        control, trainingPaths_, collectedData);
                    genericLongstaffSchwartzRegression(collectedData,
                        basisCoefficients);
                    LongstaffSchwartzExerciseStrategy exerciseStrategy(
                        basisSystem, basisCoefficients,
                        evolution, numeraires,
                        nullRebate, control);

                    // 2. bermudan swaption to enter into the payer swap
                    CallSpecifiedMultiProduct bermudanProduct =
                        CallSpecifiedMultiProduct(
                        MultiStepNothing(evolution),
                        exerciseStrategy, payerSwap);

                    // 3. callable receiver swap
                    CallSpecifiedMultiProduct callableProduct =
                        CallSpecifiedMultiProduct(
                        receiverSwap, exerciseStrategy,
                        ExerciseAdapter(nullRebate));

                    // lower bound: evolve all 4 products togheter
                    MultiProductComposite allProducts;
                    allProducts.add(payerSwap);
                    allProducts.add(receiverSwap);
                    allProducts.add(bermudanProduct);
                    allProducts.add(callableProduct);
                    allProducts.finalize();

                    boost::shared_ptr<SequenceStatisticsInc> stats =
                        simulate(evolver, allProducts);
                    checkCallableSwap(*stats, config.str());


                    // upper bound

                    //MTBrownianGeneratorFactory uFactory(seed_+142);
                    SobolBrownianGeneratorFactory uFactory(
                        SobolBrownianGenerator::Diagonal, seed_+142);
                    evolver = makeMarketModelEvolver(marketModel,
                        numeraires,
                        uFactory,
                        evolvers[i]);

                    std::vector<boost::shared_ptr<MarketModelEvolver> >
                        innerEvolvers;

                    std::valarray<bool> isExerciseTime =
                        isInSubset(evolution.evolutionTimes(),
                                   exerciseStrategy.exerciseTimes());
                    for (Size s=0; s < isExerciseTime.size(); ++s) {
                        if (isExerciseTime[s]) {
                            MTBrownianGeneratorFactory iFactory(seed_+s);
                            boost::shared_ptr<MarketModelEvolver> e =
                                makeMarketModelEvolver(marketModel,
                                numeraires,
                                iFactory,
                                evolvers[i],
                                s);
                            innerEvolvers.push_back(e);
                        }
                    }

                    Size initialNumeraire = evolver->numeraires().front();
                    Real initialNumeraireValue =
                        todaysDiscounts[initialNumeraire];

                    UpperBoundEngine uEngine(evolver, innerEvolvers,
                        receiverSwap, nullRebate,
                        receiverSwap, nullRebate,
                        exerciseStrategy,
                        initialNumeraireValue);
                    Statistics uStats;
                    uEngine.multiplePathValues(uStats,255,256);
                    Real delta = uStats.mean();
                    Real deltaError = uStats.errorEstimate();
                    if (printReport_)
                        BOOST_TEST_MESSAGE("    upper bound delta: " << io::rate(delta) << " +- " << io::rate(deltaError));

                }
            }
        }
    }
}

for (Size j=0; j<LENGTH(marketModels); j++) {

    Size testedFactors[] = { 4, 8,
        todaysForwards.size()};
    for (Size m=0; m<LENGTH(testedFactors); ++m) {
        Size factors = testedFactors[m];

        // Composite's ProductSuggested is the Terminal one
        MeasureType measures[] = { // ProductSuggested,
            // MoneyMarketPlus,
            // MoneyMarket,
            Terminal
        };
        for (Size k=0; k<LENGTH(measures); k++) {
            std::vector<Size> numeraires = makeMeasure(dummyProduct, measures[k]);
            bool logNormal = true;
            boost::shared_ptr<MarketModel> marketModel =
                makeMarketModel(logNormal, evolution, factors, marketModels[j]);
            EvolverType evolvers[] = { Pc, Balland, Ipc };
            boost::shared_ptr<MarketModelEvolver> evolver;
            Size stop =
                isInTerminalMeasure(evolution, numeraires) ? 0 : 1;
            for (Size i=0; i<LENGTH(evolvers)-stop; i++) {
                for (Size n=0; n<1; n++) {
                    //MTBrownianGeneratorFactory generatorFactory(seed_);
                    SobolBrownianGeneratorFactory generatorFactory(
                        SobolBrownianGenerator::Diagonal, seed_);
                    evolver = makeMarketModelEvolver(marketModel,
                        numeraires,
                        generatorFactory,
                        evolvers[i]);
                    std::ostringstream config;
                    config <<
                        marketModelTypeToString(marketModels[j]) << ", " <<
                        factors << (factors>1 ? (factors==todaysForwards.size() ? " (full) factors, " : " factors, ") : " factor,") <<
                        measureTypeToString(measures[k]) << ", " <<
                        evolverTypeToString(evolvers[i]) << ", " <<
                        "MT BGF";
                    if (printReport_)
                        BOOST_TEST_MESSAGE("    " << config.str());
                    // 1. calculate the exercise strategy
                    collectNodeData(*evolver,
                        receiverSwap, parametricForm, nullRebate,
                        control, trainingPaths_, collectedData);
                    Simplex om(0.01);
                    EndCriteria ec(1000, 100, 1e-8, 1e-16, 1e-8);
                    Size initialNumeraire = evolver->numeraires().front();
                    Real initialNumeraireValue = todaysDiscounts[initialNumeraire];
                    Real firstPassValue = genericEarlyExerciseOptimization(
                        collectedData, parametricForm, parameters, ec, om) *
                        initialNumeraireValue;
                    if (printReport_)
                        BOOST_TEST_MESSAGE("    initial estimate:  " << io::rate(firstPassValue));
                    ParametricExerciseAdapter exerciseStrategy(parametricForm, parameters);

                    // 2. bermudan swaption to enter into the payer swap
                    CallSpecifiedMultiProduct bermudanProduct =
                        CallSpecifiedMultiProduct(
                        MultiStepNothing(evolution),
                        exerciseStrategy, payerSwap);

                    // 3. callable receiver swap
                    CallSpecifiedMultiProduct callableProduct =
                        CallSpecifiedMultiProduct(
                        receiverSwap, exerciseStrategy,
                        ExerciseAdapter(nullRebate));
                    // lower bound: evolve all 4 products togheter
                    MultiProductComposite allProducts;
                    allProducts.add(payerSwap);
                    allProducts.add(receiverSwap);
                    allProducts.add(bermudanProduct);
                    allProducts.add(callableProduct);
                    allProducts.finalize();
                    boost::shared_ptr<SequenceStatisticsInc> stats =
                        simulate(evolver, allProducts);
                    checkCallableSwap(*stats, config.str());

                    // upper bound
                    //MTBrownianGeneratorFactory uFactory(seed_+142);
                    SobolBrownianGeneratorFactory uFactory(
                        SobolBrownianGenerator::Diagonal, seed_+142);
                    evolver = makeMarketModelEvolver(marketModel,
                        numeraires,
                        uFactory,
                        evolvers[i]);
                    std::vector<boost::shared_ptr<MarketModelEvolver> >
                        innerEvolvers;
                    std::valarray<bool> isExerciseTime =
                        isInSubset(evolution.evolutionTimes(),
                                   exerciseStrategy.exerciseTimes());
                    for (Size s=0; s < isExerciseTime.size(); ++s) {
                        if (isExerciseTime[s]) {
                            MTBrownianGeneratorFactory iFactory(seed_+s);
                            boost::shared_ptr<MarketModelEvolver> e =
                                makeMarketModelEvolver(marketModel,
                                numeraires,
                                iFactory,
                                evolvers[i],
                                s);
                            innerEvolvers.push_back(e);
                        }
                    }
                    UpperBoundEngine uEngine(evolver, innerEvolvers,
                        receiverSwap, nullRebate,
                        receiverSwap, nullRebate,
                        exerciseStrategy,
                        initialNumeraireValue);
                    Statistics uStats;
                    uEngine.multiplePathValues(uStats,255,256);
                    Real delta = uStats.mean();
                    Real deltaError = uStats.errorEstimate();
                    if (printReport_)
                        BOOST_TEST_MESSAGE("    upper bound delta: " << io::rate(delta) << " +- " << io::rate(deltaError));

                }
            }
        }
    }
}

for (Size i=0; i<todaysForwards.size(); ++i) {
payoffs[i] = boost::shared_ptr<Payoff>(new
    //PlainVanillaPayoff(Option::Call, todaysForwards[i]));
    CashOrNothingPayoff(Option::Call, todaysForwards[i], 0.01));
displacedPayoffs[i] = boost::shared_ptr<StrikedTypePayoff>(new
    //PlainVanillaPayoff(Option::Call, todaysForwards[i]+displacement));
    CashOrNothingPayoff(Option::Call, todaysForwards[i]+displacement, 0.01));
}

for (Size j=0; j<LENGTH(marketModels); j++) {

    Size testedFactors[] = { 4, 8, todaysForwards.size() };
    for (Size m=0; m<LENGTH(testedFactors); ++m) {
        Size factors = testedFactors[m];

        MeasureType measures[] = { //MoneyMarketPlus,
            MoneyMarket//,
            //Terminal
        };
        for (Size k=0; k<LENGTH(measures); k++) {
            std::vector<Size> numeraires = makeMeasure(product, measures[k]);

            for (Size n=0; n<1; n++) {
                //MTBrownianGeneratorFactory generatorFactory(seed_);
                SobolBrownianGeneratorFactory generatorFactory(
                    SobolBrownianGenerator::Diagonal,
                    seed_);

                bool logNormal = true;
                boost::shared_ptr<MarketModel> marketModel =
                    makeMarketModel(logNormal, evolution, factors,
                    marketModels[j]);

                boost::shared_ptr<MarketModelEvolver> evolver(new
                    LogNormalFwdRateEuler(marketModel,
                    generatorFactory,
                    numeraires));
                SequenceStatisticsInc stats(product.numberOfProducts());


                std::vector<Size> startIndexOfConstraint;
                std::vector<Size> endIndexOfConstraint;

                for (Size i=0; i<evolution.evolutionTimes().size(); ++i) {
                    startIndexOfConstraint.push_back(i);
                    endIndexOfConstraint.push_back(i+1);
                }


                std::vector<
                    std::vector<boost::shared_ptr<ConstrainedEvolver> > >
                    constrainedEvolvers;
                std::vector<std::vector<std::vector<Real> > > diffWeights;
                std::vector<std::vector<SequenceStatisticsInc> > greekStats;

                std::vector<boost::shared_ptr<ConstrainedEvolver> >
                    deltaGammaEvolvers;
                std::vector<std::vector<Real> > deltaGammaWeights(
                    2, std::vector<Real>(3));
                std::vector<SequenceStatisticsInc> deltaGammaStats(2,stats);


                Spread forwardBump = 1.0e-6;
                marketModel =
                    makeMarketModel(logNormal, evolution, factors,
                    marketModels[j], -forwardBump);
                deltaGammaEvolvers.push_back(
                    boost::shared_ptr<ConstrainedEvolver>(new
                    LogNormalFwdRateEulerConstrained(marketModel,
                    generatorFactory,
                    numeraires)));
                deltaGammaEvolvers.back()->setConstraintType(
                    startIndexOfConstraint, endIndexOfConstraint);
                marketModel =
                    makeMarketModel(logNormal, evolution, factors,
                    marketModels[j], forwardBump);
                deltaGammaEvolvers.push_back(
                    boost::shared_ptr<ConstrainedEvolver>(new
                    LogNormalFwdRateEulerConstrained(marketModel,
                    generatorFactory,
                    numeraires)));
                deltaGammaEvolvers.back()->setConstraintType(
                    startIndexOfConstraint, endIndexOfConstraint);

                deltaGammaWeights[0][0] = 0.0;
                deltaGammaWeights[0][1] = -1.0/(2.0*forwardBump);
                deltaGammaWeights[0][2] = 1.0/(2.0*forwardBump);

                deltaGammaWeights[1][0] = -2.0/(forwardBump*forwardBump);
                deltaGammaWeights[1][1] = 1.0/(forwardBump*forwardBump);
                deltaGammaWeights[1][2] = 1.0/(forwardBump*forwardBump);


                std::vector<boost::shared_ptr<ConstrainedEvolver> >
                    vegaEvolvers;
                std::vector<std::vector<Real> > vegaWeights(
                    1, std::vector<Real>(3));
                std::vector<SequenceStatisticsInc> vegaStats(1,stats);

                Volatility volBump = 1.0e-4;
                marketModel =
                    makeMarketModel(logNormal, evolution, factors,
                    marketModels[j], 0.0, -volBump);
                vegaEvolvers.push_back(
                    boost::shared_ptr<ConstrainedEvolver>(new
                    LogNormalFwdRateEulerConstrained(marketModel,
                    generatorFactory,
                    numeraires)));
                vegaEvolvers.back()->setConstraintType(
                    startIndexOfConstraint, endIndexOfConstraint);
                marketModel =
                    makeMarketModel(logNormal, evolution, factors,
                    marketModels[j], 0.0, volBump);
                vegaEvolvers.push_back(
                    boost::shared_ptr<ConstrainedEvolver>(new
                    LogNormalFwdRateEulerConstrained(marketModel,
                    generatorFactory,
                    numeraires)));
                vegaEvolvers.back()->setConstraintType(
                    startIndexOfConstraint, endIndexOfConstraint);

                vegaWeights[0][0] = 0.0;
                vegaWeights[0][1] = -1.0/(2.0*volBump);
                vegaWeights[0][2] = 1.0/(2.0*volBump);



                constrainedEvolvers.push_back(deltaGammaEvolvers);
                diffWeights.push_back(deltaGammaWeights);
                greekStats.push_back(deltaGammaStats);

                constrainedEvolvers.push_back(vegaEvolvers);
                diffWeights.push_back(vegaWeights);
                greekStats.push_back(vegaStats);

                std::ostringstream config;
                config <<
                    marketModelTypeToString(marketModels[j]) << ", " <<
                    factors << (factors>1 ? (factors==todaysForwards.size() ? " (full) factors, " : " factors, ") : " factor,") <<
                    measureTypeToString(measures[k]) << ", " <<
                    "MT BGF";
                if (printReport_)
                    BOOST_TEST_MESSAGE("    " << config.str());

                Size initialNumeraire = evolver->numeraires().front();
                Real initialNumeraireValue =
                    todaysDiscounts[initialNumeraire];

                ProxyGreekEngine engine(evolver,
                    constrainedEvolvers, diffWeights,
                    startIndexOfConstraint,
                    endIndexOfConstraint,
                    product,
                    initialNumeraireValue);

                engine.multiplePathValues(stats, greekStats, paths_);

                std::vector<Real> values = stats.mean();
                std::vector<Real> errors = stats.errorEstimate();
                std::vector<Real> deltas = greekStats[0][0].mean();
                std::vector<Real> deltaErrors = greekStats[0][0].errorEstimate();
                std::vector<Real> gammas = greekStats[0][1].mean();
                std::vector<Real> gammaErrors = greekStats[0][1].errorEstimate();
                std::vector<Real> vegas = greekStats[1][0].mean();
                std::vector<Real> vegaErrors = greekStats[1][0].errorEstimate();

                std::vector<DiscountFactor> discPlus(todaysForwards.size()+1, todaysDiscounts[0]);
                std::vector<DiscountFactor> discMinus(todaysForwards.size()+1, todaysDiscounts[0]);
                std::vector<Rate> fwdPlus(todaysForwards.size());
                std::vector<Rate> fwdMinus(todaysForwards.size());
                std::vector<Rate> pricePlus(todaysForwards.size());
                std::vector<Rate> price0(todaysForwards.size());
                std::vector<Rate> priceMinus(todaysForwards.size());
                for (Size i=0; i<todaysForwards.size(); ++i) {
                    Time tau = rateTimes[i+1]-rateTimes[i];
                    fwdPlus[i]=todaysForwards[i]+forwardBump;
                    fwdMinus[i]=todaysForwards[i]-forwardBump;
                    discPlus[i+1]=discPlus[i]/(1.0+fwdPlus[i]*tau);
                    discMinus[i+1]=discMinus[i]/(1.0+fwdMinus[i]*tau);
                    pricePlus[i]=BlackCalculator(displacedPayoffs[i], fwdPlus[i],
                        volatilities[i]*sqrt(rateTimes[i]),
                        discPlus[i+1]*tau).value();
                    price0[i]=BlackCalculator(displacedPayoffs[i], todaysForwards[i],
                        volatilities[i]*sqrt(rateTimes[i]),
                        todaysDiscounts[i+1]*tau).value();
                    priceMinus[i]=BlackCalculator(displacedPayoffs[i], fwdMinus[i],
                        volatilities[i]*sqrt(rateTimes[i]),
                        discMinus[i+1]*tau).value();
                }

                for (Size i=0; i<product.numberOfProducts(); ++i) {
                    Real numDelta = (pricePlus[i]-priceMinus[i])/(2.0*forwardBump);
                    Real numGamma = (pricePlus[i]-2*price0[i]+priceMinus[i])/(forwardBump*forwardBump);
                    if (printReport_) {
                        BOOST_TEST_MESSAGE(io::ordinal(i+1) << " caplet: "
                            << "value = " << price0[i] << ", "
                            << "delta = " << numDelta << ", "
                            << "gamma = " << numGamma);
                        BOOST_TEST_MESSAGE(io::ordinal(i+1) << " caplet: "
                            << "value = " << values[i]
                        << " +- " << errors[i]
                        << " (" << (values[i]-price0[i])/errors[i] << " s.e.), "
                            << "delta = " << deltas[i]
                        << " +- " << deltaErrors[i]
                        << " (" << (deltas[i]-numDelta)/deltaErrors[i] << " s.e.), "
                            << "gamma = " << gammas[i]
                        << " +- " << gammaErrors[i]
                        << " (" << (gammas[i]-numGamma)/gammaErrors[i] << " s.e.), "
                            << "vega = " << vegas[i]
                        << " +- " << vegaErrors[i]);
                    }
                }
            }
        }
    }
}

for (Size i=0; i<todaysForwards.size(); ++i) {
payoffs[i] = boost::shared_ptr<Payoff>(new
    PlainVanillaPayoff(Option::Call, todaysForwards[i]));
//CashOrNothingPayoff(Option::Call, todaysForwards[i], 0.01));
displacedPayoffs[i] = boost::shared_ptr<StrikedTypePayoff>(new
    PlainVanillaPayoff(Option::Call, todaysForwards[i]+displacement));
//CashOrNothingPayoff(Option::Call, todaysForwards[i]+displacement, 0.01));
}

for (Size whichProduct=0; whichProduct<2; ++whichProduct)
{
MarketModelPathwiseMultiDeflatedCaplet product1(rateTimes, accruals,
    paymentTimes, todaysForwards);

MarketModelPathwiseMultiCaplet product2(rateTimes, accruals,
    paymentTimes, todaysForwards);

std::auto_ptr<MarketModelPathwiseMultiProduct> product;

if (whichProduct == 0)
    product = product2.clone();
else
    product = product1.clone();


MultiStepOptionlets productDummy(rateTimes, accruals,
    paymentTimes, payoffs);



EvolutionDescription evolution = product->evolution();

MarketModelType marketModels[] = {
    // CalibratedMM,
    // ExponentialCorrelationFlatVolatility,
    ExponentialCorrelationAbcdVolatility };

    for (Size j=0; j<LENGTH(marketModels); j++)
    {

        Size testedFactors[] = { 2
            //, 4, 8, todaysForwards.size()
        };

        for (Size m=0; m<LENGTH(testedFactors); ++m)
        {
            Size factors = testedFactors[m];

            MeasureType measures[] = {
                MoneyMarket
            };

            for (Size k=0; k<LENGTH(measures); k++)
            {
                std::vector<Size> numeraires = makeMeasure(productDummy, measures[k]);

                for (Size n=0; n<1; n++)
                {
                    MTBrownianGeneratorFactory generatorFactory(seed_);

                    bool logNormal = true;
                    boost::shared_ptr<MarketModel> marketModel =
                        makeMarketModel(logNormal, evolution, factors,
                        marketModels[j]);

                    LogNormalFwdRateEuler evolver(marketModel,
                        generatorFactory,
                        numeraires);
                    SequenceStatisticsInc stats(product->numberOfProducts()*(todaysForwards.size()+1));







                    Spread forwardBump = 1.0e-6;

                    std::ostringstream config;
                    config <<
                        marketModelTypeToString(marketModels[j]) << ", " <<
                        factors << (factors>1 ? (factors==todaysForwards.size() ? " (full) factors, " : " factors, ") : " factor,") <<
                        measureTypeToString(measures[k]) << ", " <<
                        "MT BGF";
                    if (printReport_)
                        BOOST_TEST_MESSAGE("    " << config.str());

                    Size initialNumeraire = evolver.numeraires().front();
                    Real initialNumeraireValue =
                        todaysDiscounts[initialNumeraire];



                    {

                        PathwiseAccountingEngine accountingengine(boost::shared_ptr<LogNormalFwdRateEuler>(new LogNormalFwdRateEuler(evolver)), // method relies heavily on LMM Euler
                            *product,
                            marketModel, // we need pseudo-roots and displacements
                            initialNumeraireValue);



                        accountingengine.multiplePathValues(stats,paths_);
                    }


                    std::vector<Real> valuesAndDeltas = stats.mean();
                    std::vector<Real> errors = stats.errorEstimate();

                    std::vector<Real> prices(product->numberOfProducts());
                    std::vector<Real> priceErrors(product->numberOfProducts());

                    Matrix deltas( product->numberOfProducts(), todaysForwards.size());
                    Matrix deltasErrors( product->numberOfProducts(), todaysForwards.size());
                    std::vector<Real> modelPrices(product->numberOfProducts());


                    for (Size i=0; i < product->numberOfProducts(); ++i)
                    {
                        prices[i] = valuesAndDeltas[i];

                        priceErrors[i] = errors[i];

                        modelPrices[i] = BlackCalculator(displacedPayoffs[i], todaysForwards[i],
                            volatilities[i]*sqrt(rateTimes[i]),
                            todaysDiscounts[i+1]*(rateTimes[i+1]-rateTimes[i])).value();


                        for (Size j=0; j <  todaysForwards.size(); ++j)
                        {
                            deltas[i][j] = valuesAndDeltas[(i+1)*product->numberOfProducts()+j];
                            deltasErrors[i][j]  = errors[(i+1)* product->numberOfProducts()+j];

                        }

                    }

                    Matrix modelDeltas(product->numberOfProducts(), todaysForwards.size());


                    std::vector<DiscountFactor> discPlus(todaysForwards.size()+1, todaysDiscounts[0]);
                    std::vector<DiscountFactor> discMinus(todaysForwards.size()+1, todaysDiscounts[0]);
                    std::vector<Rate> fwdPlus(todaysForwards.size());
                    std::vector<Rate> fwdMinus(todaysForwards.size());


                    for (Size i=0; i < todaysForwards.size(); ++i)
                    {
                        for (Size j=0; j < todaysForwards.size(); ++j)
                        {
                            if (i != j)
                            {
                                fwdPlus[j] = todaysForwards[j];
                                fwdMinus[j] = todaysForwards[j];

                            }
                            else
                            {
                                fwdPlus[j] = todaysForwards[j]+forwardBump;
                                fwdMinus[j] = todaysForwards[j]-forwardBump;
                            }

                            Time tau = rateTimes[j+1]-rateTimes[j];
                            discPlus[j+1]=discPlus[j]/(1.0+fwdPlus[j]*tau);
                            discMinus[j+1]=discMinus[j]/(1.0+fwdMinus[j]*tau);

                        }

                        for (Size k=0; k  < product->numberOfProducts(); ++k)
                        {
                            Real tau = rateTimes[k+1] - rateTimes[k];
                            Real priceUp = BlackCalculator(displacedPayoffs[k], fwdPlus[k],
                                volatilities[k]*sqrt(rateTimes[k]),
                                discPlus[k+1]*tau).value();
                            Real priceDown = BlackCalculator(displacedPayoffs[k], fwdMinus[k],
                                volatilities[k]*sqrt(rateTimes[k]),
                                discMinus[k+1]*tau).value();

                            modelDeltas[k][i] = (priceUp-priceDown)/(2*forwardBump);

                        }
                    }


                    Integer numberErrors =0;

                    for (Size i=0; i<product->numberOfProducts(); ++i)
                    {

                        Real thisPrice = prices[i];
                        Real thisModelPrice =  modelPrices[i];
                        Real priceErrorInSds = ((thisPrice - thisModelPrice)/priceErrors[i]);

                        Real errorTheshold = 3.5;

                        if (fabs(priceErrorInSds) > errorTheshold)
                        {
                            BOOST_TEST_MESSAGE("Caplet " << i << " price " << prices[i] << " model price " << modelPrices[i]
                            << "   Standard error: " <<priceErrors[i] << " errors in sds: " << priceErrorInSds);

                            ++numberErrors;

                        }

                        Real threshold =1e-10;

                        for (Size j =0; j < todaysForwards.size(); ++j)
                        {
                            Real delta = deltas[i][j];
                            Real modelDelta = modelDeltas[i][j];

                            Real deltaErrorInSds =100;

                            if (deltasErrors[i][j] > 0.0)
                                deltaErrorInSds = (( delta  - modelDelta )/deltasErrors[i][j]);
                            else
                                if (fabs(modelDelta -delta) < threshold) // to cope with zero over zero
                                    deltaErrorInSds =0.0;

                            if (fabs(deltaErrorInSds) > errorTheshold)
                            {

                                BOOST_TEST_MESSAGE("Caplet " << i << " delta " << j << "has value " << deltas[i][j] << " model value " << modelDeltas[i][j]
                                << "   Standard error: " <<deltasErrors[i][j] << " errors in sds: " << deltaErrorInSds);

                                ++numberErrors;
                            }


                        }


                    }

                    if (numberErrors >0)
                        BOOST_FAIL("Pathwise greeks test has " << numberErrors <<"\n");
                }
            }
        }
    }
}

for (Size i=0; i<todaysForwards.size(); ++i) {
payoffs[i] = boost::shared_ptr<Payoff>(new
    PlainVanillaPayoff(Option::Call, todaysForwards[i]));
//CashOrNothingPayoff(Option::Call, todaysForwards[i], 0.01));
displacedPayoffs[i] = boost::shared_ptr<StrikedTypePayoff>(new
    PlainVanillaPayoff(Option::Call, todaysForwards[i]+displacement));
//CashOrNothingPayoff(Option::Call, todaysForwards[i]+displacement, 0.01));
}

for (Size j=0; j<LENGTH(marketModels); j++)
{

Size testedFactors[] = { std::min<Size>(3UL,todaysForwards.size())
    //    todaysForwards.size()
    //, 4, 8,
};




for (Size m=0; m<LENGTH(testedFactors); ++m)
{
    Size factors = testedFactors[m];


    bool logNormal = true;

    boost::shared_ptr<MarketModel> marketModel =
        makeMarketModel(logNormal, evolution, factors,
        marketModels[j]);

    Size startIndex = std::min<Size>(1,evolution.numberOfRates()-2) ;
    Size endIndex = evolution.numberOfRates()-1;

    SwaptionPseudoDerivative derivative(marketModel,
        startIndex,
        endIndex);

    std::vector<Matrix> pseudoRoots;
    for (Size k=0; k < marketModel->numberOfSteps(); ++k)
        pseudoRoots.push_back( marketModel->pseudoRoot(k));

 // test that the derivative of swaption implied vols to the pseudo-root elements are correct, finite differencing versus analytic value

    for (Size step=0; step < evolution.numberOfSteps(); ++ step)
    {
        for (Size l=0; l < evolution.numberOfRates(); ++l)
            for (Size f=0; f < factors; ++f)
            {

                // change one pseudo root element in the calibration by adding a bump to it 

                pseudoRoots[step][l][f] += numericalBumpSizeForSwaptionPseudo;


                // create new market model with the pseudo root bumped

                PseudoRootFacade bumpedUp(pseudoRoots,rateTimes,marketModel->initialRates(),marketModel->displacements());


                // compute the implied vol of the swaption with the bumped pseudo roots 

                Real upImpVol = SwapForwardMappings::swaptionImpliedVolatility(bumpedUp,
                    startIndex,
                    endIndex);


                // undo the bump

                pseudoRoots[step][l][f] -= numericalBumpSizeForSwaptionPseudo;


                // bump down

                pseudoRoots[step][l][f] -= numericalBumpSizeForSwaptionPseudo;


                // create facade for the bumped down pseudo roots

                PseudoRootFacade bumpedDown(pseudoRoots,rateTimes,marketModel->initialRates(),marketModel->displacements());

               // compute the implied vol of the swaption with the bumped down pseudo roots 

                Real downImpVol = SwapForwardMappings::swaptionImpliedVolatility(bumpedDown,
                    startIndex,
                    endIndex);

                // undo bumping

                pseudoRoots[step][l][f] += numericalBumpSizeForSwaptionPseudo;

                // use symmetric finite differencing to compute the change in the swaptions implied vol for changes in this pseudo-root element

                Real volDeriv = (upImpVol-downImpVol)/(2.0*numericalBumpSizeForSwaptionPseudo);

                Real modelVal = derivative.volatilityDerivative(step)[l][f];

                Real error = volDeriv - modelVal;

                if (fabs(error) > swaptionPseudoTolerance)
                    ++numberSwaptionPseudoFailures;



            }

    }

    if (numberSwaptionPseudoFailures >0)
        BOOST_ERROR("swaption pseudo test failed " << numberSwaptionPseudoFailures << " times" );
}
}

for (Size j=0; j<LENGTH(marketModels); j++)
{

Size testedFactors[] = { std::min<Size>(3UL,todaysForwards.size())
    //    todaysForwards.size()
    //, 4, 8,
                                                  };




for (Size m=0; m<LENGTH(testedFactors); ++m)
{
    Size factors = testedFactors[m];


    bool logNormal = true;

    boost::shared_ptr<MarketModel> marketModel =
        makeMarketModel(logNormal, evolution, factors,
        marketModels[j]);

    for (Size startIndex = 1; startIndex < evolution.numberOfRates()-1; ++startIndex)
        for (Size endIndex = startIndex+1; endIndex < evolution.numberOfRates(); ++endIndex)
        {

            CapPseudoDerivative derivative(marketModel,
                capStrike,
                startIndex,
                endIndex, initialNumeraireValue);

            std::vector<Matrix> pseudoRoots;
            for (Size k=0; k < marketModel->numberOfSteps(); ++k)
                pseudoRoots.push_back( marketModel->pseudoRoot(k));

            // test cap price derivatives with respect to pseudo-root elements

            for (Size step=0; step < evolution.numberOfSteps(); ++ step)
            {
                for (Size l=0; l < evolution.numberOfRates(); ++l)
                    for (Size f=0; f < factors; ++f)
                    {

                        // similar to swaption pseudo derivative test but with prices not implied vols

                        pseudoRoots[step][l][f] += numericalBumpSizeForSwaptionPseudo;

                        PseudoRootFacade bumpedUp(pseudoRoots,rateTimes,marketModel->initialRates(),marketModel->displacements());

                        // get total covariances of rates with bumped up pseudo-roots , we really only need the variances
                        Matrix totalCovUp(bumpedUp.totalCovariance( marketModel->numberOfSteps()-1));


                        pseudoRoots[step][l][f] -= numericalBumpSizeForSwaptionPseudo;

                        pseudoRoots[step][l][f] -= numericalBumpSizeForSwaptionPseudo;

                        PseudoRootFacade bumpedDown(pseudoRoots,rateTimes,marketModel->initialRates(),marketModel->displacements());

                        // get total covariances of rates with bumped down pseudo-roots , we really only need the variances
                        Matrix totalCovDown(bumpedDown.totalCovariance( marketModel->numberOfSteps()-1));


                        pseudoRoots[step][l][f] += numericalBumpSizeForSwaptionPseudo;


                        // we have to loop through all the caplets underlying the cap to get the price

                        Real priceDeriv=0.0;
                        for (Size k=startIndex; k < endIndex; ++k)
                        {
                            Real upSd = sqrt(totalCovUp[k][k]);
                            Real downSd = sqrt(totalCovDown[k][k]);

                            Real annuity =  todaysDiscounts[k+1]* marketModel->evolution().rateTaus()[k];
                            Real forward = todaysForwards[k];


                            Real upPrice = blackFormula(Option::Call,
                                capStrike,
                                forward,
                                upSd,
                                annuity,
                                marketModel->displacements()[k]);


                            Real downPrice = blackFormula(Option::Call,
                                capStrike,
                                forward,
                                downSd,
                                annuity,
                                marketModel->displacements()[k]);


                            priceDeriv += (upPrice-downPrice)/(2.0*numericalBumpSizeForSwaptionPseudo);

                        }

                        Real modelVal = derivative.priceDerivative(step)[l][f];

                        Real error = priceDeriv - modelVal;

                        if (fabs(error) > swaptionPseudoTolerance)
                            ++numberCapPseudoFailures;



                    }

            }

            // test the implied vol of the cap, each underlying caplet has a different implied vol and the cap's is different again

            Real impVol = derivative.impliedVolatility();

            Matrix totalCov(marketModel->totalCovariance(evolution.numberOfSteps()-1 ) );
            Real priceConstVol =0.0;
            Real priceVarVol =0.0;

            for (Size m= startIndex; m < endIndex; ++m)
            {
                Real annuity = todaysDiscounts[m+1]* marketModel->evolution().rateTaus()[m];
                Real expiry = rateTimes[m];
                Real forward = todaysForwards[m];

                priceConstVol += blackFormula(Option::Call,
                    capStrike,
                    forward,
                    impVol*sqrt(expiry),
                    annuity,
                    marketModel->displacements()[m]);

                priceVarVol += blackFormula(Option::Call,
                    capStrike,
                    forward,
                    sqrt(totalCov[m][m]),
                    annuity,
                    marketModel->displacements()[m]);

            }

            if (fabs(priceVarVol - priceConstVol) > impVolTolerance)
                ++numberCapImpVolFailures;


        }

        if (numberCapPseudoFailures >0)
            BOOST_ERROR("cap pseudo test failed for prices " << numberCapPseudoFailures << " times" );

        if (numberCapImpVolFailures >0)
            BOOST_ERROR("cap pseudo test failed for implied vols " << numberCapImpVolFailures << " times" );

}

// we have tested the price derivative and the implied vol function, now the derivative of the cap implied vols
// with respect to pseudo-root elements  

// since we have already tested the imp vol function we use it here


for (Size m=0; m<LENGTH(testedFactors); ++m)
{
    Size factors = testedFactors[m];


    bool logNormal = true;

    boost::shared_ptr<MarketModel> marketModel =
        makeMarketModel(logNormal, evolution, factors,
        marketModels[j]);

    for (Size startIndex = 1; startIndex < evolution.numberOfRates()-1; ++startIndex)
        for (Size endIndex = startIndex+1; endIndex < evolution.numberOfRates(); ++endIndex)
        {

            CapPseudoDerivative derivative(marketModel,
                capStrike,
                startIndex,
                endIndex,initialNumeraireValue);

            std::vector<Matrix> pseudoRoots;
            for (Size k=0; k < marketModel->numberOfSteps(); ++k)
                pseudoRoots.push_back( marketModel->pseudoRoot(k));


            for (Size step=0; step < evolution.numberOfSteps(); ++ step)
            {
                for (Size l=0; l < evolution.numberOfRates(); ++l)
                    for (Size f=0; f < factors; ++f)
                    {
                        pseudoRoots[step][l][f] += numericalBumpSizeForSwaptionPseudo;

                        PseudoRootFacade bumpedUp(pseudoRoots,rateTimes,marketModel->initialRates(),marketModel->displacements());

                        CapPseudoDerivative upDerivative(boost::shared_ptr<MarketModel>(new PseudoRootFacade(bumpedUp)),
                            capStrike,
                            startIndex,
                            endIndex,initialNumeraireValue);

                        Real volUp = upDerivative.impliedVolatility();




                        pseudoRoots[step][l][f] -= numericalBumpSizeForSwaptionPseudo;

                        pseudoRoots[step][l][f] -= numericalBumpSizeForSwaptionPseudo;

                        PseudoRootFacade bumpedDown(pseudoRoots,rateTimes,marketModel->initialRates(),marketModel->displacements());

                        CapPseudoDerivative downDerivative(boost::shared_ptr<MarketModel>(new PseudoRootFacade(bumpedDown)),
                            capStrike,
                            startIndex,
                            endIndex,initialNumeraireValue);


                        Real volDown = downDerivative.impliedVolatility();




                        pseudoRoots[step][l][f] += numericalBumpSizeForSwaptionPseudo;


                        Real volDeriv = (volUp-volDown)/(2.0*numericalBumpSizeForSwaptionPseudo);

                        Real modelVal = derivative.volatilityDerivative(step)[l][f];

                        Real error = volDeriv - modelVal;

                        if (fabs(error) > impVolTolerance*10)
                            ++numberCapVolPseudoFailures;



                    }



            }



        }

        if (numberCapVolPseudoFailures >0)
            BOOST_ERROR("cap pseudo test failed for implied vols " << numberCapVolPseudoFailures << " times" );

}
}

for (Size j=0; j<LENGTH(marketModels); j++)
{

Size testedFactors[] = { 
                                                        std::min<Size>(1UL,todaysForwards.size())
    //    todaysForwards.size()
    //, 4, 8,
                                                
                                                    };




for (Size m=0; m<LENGTH(testedFactors); ++m)
{
    Size factors = testedFactors[m];
    Size factorsToTest = std::min<Size>(2,factors); // doing all possible vegas is combinatorially explosive


    MeasureType measures[] = {
                                                                       MoneyMarket
                                                               };

    std::vector<Matrix> pseudoBumps;
    std::vector<Matrix> pseudoBumpsDown;

    for (Size k=0; k < evolution.numberOfRates(); ++k)
    {
        for (Size f=0; f < factors; ++f)
        {
            Matrix modelBump(evolution.numberOfRates(), factors,0.0);
            modelBump[k][f] =bumpSizeNumericalDifferentiation;
            pseudoBumps.push_back(modelBump);
            modelBump[k][f] =-bumpSizeNumericalDifferentiation;
            pseudoBumpsDown.push_back(modelBump);
        }
    }

    std::vector<std::vector<Matrix> > vegaBumps;

    Matrix modelBump(evolution.numberOfRates(), factors,0.0);


    for (Size l = 0; l < evolution.numberOfSteps(); ++l)
    {
        vegaBumps.push_back(std::vector<Matrix>());
        for (Size k=0; k < evolution.numberOfRates(); k=k+bumpIncrement)
        {
            for (Size f=0; f < factorsToTest; ++f)
            {

                for (Size m=0; m < evolution.numberOfSteps(); ++m)
                {
                    if (l ==m && k >= l)
                        modelBump[k][f] = vegaBumpSize;

                    vegaBumps[l].push_back(modelBump);

                    modelBump[k][f] =0.0;
                }
            }
        }

    }





    for (Size k=0; k<LENGTH(measures); k++)
    {

        std::vector<Size> numeraires = makeMeasure(product, measures[k]);

        std::vector<RatePseudoRootJacobian> testees;
        std::vector<RatePseudoRootJacobianAllElements> testees2;

        std::vector<RatePseudoRootJacobianNumerical> testers;
        std::vector<RatePseudoRootJacobianNumerical> testersDown;


        MTBrownianGeneratorFactory generatorFactory(seed_);

        bool logNormal = true;
        boost::shared_ptr<MarketModel> marketModel =
            makeMarketModel(logNormal, evolution, factors,
            marketModels[j]);

        for (Size l=0; l < evolution.numberOfSteps(); ++l)
        {
            const Matrix& pseudoRoot = marketModel->pseudoRoot(l);
            testees.push_back(RatePseudoRootJacobian(pseudoRoot,
                evolution.firstAliveRate()[l],
                numeraires[l],
                evolution.rateTaus(),
                pseudoBumps,
                marketModel->displacements()
                ));

              testees2.push_back(RatePseudoRootJacobianAllElements(pseudoRoot,
                evolution.firstAliveRate()[l],
                numeraires[l],
                evolution.rateTaus(),
                marketModel->displacements()
                ));


            testers.push_back(RatePseudoRootJacobianNumerical(pseudoRoot,
                evolution.firstAliveRate()[l],
                numeraires[l],
                evolution.rateTaus(),
                pseudoBumps,
                marketModel->displacements()
                ));
            testersDown.push_back(RatePseudoRootJacobianNumerical(pseudoRoot,
                evolution.firstAliveRate()[l],
                numeraires[l],
                evolution.rateTaus(),
                pseudoBumpsDown,
                marketModel->displacements()
                ));

        }




        boost::shared_ptr<BrownianGenerator> generator(generatorFactory.create(factors,
            steps));
        LogNormalFwdRateEuler evolver(marketModel,
            generatorFactory,
            numeraires);


        std::vector<Real> oldRates(evolution.numberOfRates());
        std::vector<Real> newRates(evolution.numberOfRates());
        std::vector<Real> gaussians(factors);

        std::vector<Size> numberCashFlowsThisStep(product.numberOfProducts());

        std::vector<std::vector<MarketModelMultiProduct::CashFlow> > cashFlowsGenerated(product.numberOfProducts());

        for (Size i=0; i < product.numberOfProducts(); ++i)
            cashFlowsGenerated[i].resize(product.maxNumberOfCashFlowsPerProductPerStep());

        Matrix B(pseudoBumps.size(),evolution.numberOfRates());
        Matrix B2(pseudoBumps.size(),evolution.numberOfRates());
        Matrix B3(pseudoBumps.size(),evolution.numberOfRates());
        Matrix B4(pseudoBumps.size(),evolution.numberOfRates());

        std::vector<Matrix> globalB;
        {
            Matrix modelB(evolution.numberOfRates(), factors);
            for (Size i=0; i < steps; ++i)
                globalB.push_back(modelB);
        }

        std::vector<Real> oneStepDFs(evolution.numberOfRates()+1);
        oneStepDFs[0] = 1.0;


        Size numberFailures=0;
        Size numberFailures2=0;

        for (Size l=0; l < pathsToDo; ++l)
        {
            evolver.startNewPath();
            product.reset();
            generator->nextPath();

            bool done;
            newRates = marketModel->initialRates();
            Size currentStep =0;

            do
            {
                oldRates = newRates;


                evolver.advanceStep();
                done = product.nextTimeStep(evolver.currentState(),
                    numberCashFlowsThisStep,
                    cashFlowsGenerated);

                newRates = evolver.currentState().forwardRates();

                for (Size i=1; i <= evolution.numberOfRates(); ++i)
                    oneStepDFs[i] = 1.0/(1+oldRates[i-1]*evolution.rateTaus()[i-1]);


                generator->nextStep(gaussians);

                testees[currentStep].getBumps(oldRates, oneStepDFs, newRates, gaussians, B);
                testees2[currentStep].getBumps(oldRates, oneStepDFs, newRates, gaussians, globalB);
        

                testers[currentStep].getBumps(oldRates, oneStepDFs, newRates, gaussians, B2);
                testersDown[currentStep].getBumps(oldRates, oneStepDFs, newRates, gaussians, B3);

                // now do make out put of allElements class into same form 

                for (Size i1 =0; i1 < pseudoBumps.size(); ++i1)
                {
                    Size j1=0;

                    for (; j1 < evolution.firstAliveRate()[i1]; ++j1)
                    {
                        B4[i1][j1]=0.0;
                    }
                    for (; j1 < numberRates; ++j1)
                    {
                        Real sum =0.0;

                        for (Size k1=evolution.firstAliveRate()[i1]; k1 < numberRates; ++k1)
                            for (Size f1=0; f1 < factors; ++f1)
                                sum += pseudoBumps[i1][k1][f1]*globalB[j1][k1][f1];

                        B4[i1][j1] =sum;

                    }
                }



                for (Size j=0; j < B.rows(); ++j)
                    for (Size k=0; k < B.columns(); ++k)
                    {
                        Real analytic = B[j][k]/bumpSizeNumericalDifferentiation;
                        Real analytic2 = B4[j][k]/bumpSizeNumericalDifferentiation;
                        Real numerical = (B2[j][k]-B3[j][k])/(2*bumpSizeNumericalDifferentiation);
                        Real errorSize = (analytic - numerical)/ ( bumpSizeNumericalDifferentiation*bumpSizeNumericalDifferentiation);
                        Real errorSize2 = (analytic2 - numerical)/ ( bumpSizeNumericalDifferentiation*bumpSizeNumericalDifferentiation);

                        maxError = std::max(maxError,fabs(errorSize));

                        if ( fabs( errorSize  ) > multiplier  )
                        {
                            ++numberFailures;
                            if (printReport_)
                                BOOST_TEST_MESSAGE("path " << l << " step "
                                << currentStep << " j " << j
                                << " k " << k << " B " << B[j][k] << "  B2 " << B2[j][k]);

                        }

                        if ( fabs( errorSize2  ) > multiplier  )
                        {
                            ++numberFailures2;
                            if (printReport_)
                                BOOST_TEST_MESSAGE("path " << l << " step "
                                << currentStep << " j " << j
                                << " k " << k << " B4 " << B4[j][k] << "  B2 " << B2[j][k]);

                        }

                    }
                    ++currentStep;
            }
            while (!done);

        }

        if (numberFailures >0)
            BOOST_FAIL("Pathwise rate pseudoroot jacobian test fails : " << numberFailures <<"\n");

        
        if (numberFailures2 >0)
            BOOST_FAIL("Pathwise rate pseudoroot jacobian all elements test fails : " << numberFailures2 <<"\n");
    } // end of k loop over measures


    // the quick test done now do a simulation test for the vegas for caplets

    Size numberDeflatedErrors =0;
    Size numberUndeflatedErrors =0;
    Real biggestError=0.0;


    for (Size deflate =0; deflate <2; ++deflate)
    {
        std::auto_ptr<MarketModelPathwiseMultiProduct> productToUse;

        if (deflate ==0)
            productToUse = caplets.clone();
        else
            productToUse = capletsDeflated.clone();

        for (Size k=0; k<LENGTH(measures); k++)
        {

            std::vector<Size> numeraires = makeMeasure(product, measures[k]);

            MTBrownianGeneratorFactory generatorFactory(seed_);

            bool logNormal = true;
            boost::shared_ptr<MarketModel> marketModel =
                makeMarketModel(logNormal, evolution, factors,
                marketModels[j]);

            LogNormalFwdRateEuler evolver(marketModel,
                generatorFactory,
                numeraires);

            //      SequenceStatistics stats(product.numberOfProducts()*(todaysForwards.size()+1+vegaBumps[0].size()));


            std::ostringstream config;
            config <<
                marketModelTypeToString(marketModels[j]) << ", " <<
                factors << (factors>1 ? (factors==todaysForwards.size() ? " (full) factors, " : " factors, ") : " factor,") <<
                measureTypeToString(measures[k]) << ", " <<
                "MT BGF";
            if (printReport_)
                BOOST_TEST_MESSAGE("    " << config.str());

            Size initialNumeraire = evolver.numeraires().front();
            Real initialNumeraireValue =
                todaysDiscounts[initialNumeraire];

            std::vector<Real> values;

            std::vector<Real> errors;

            {

                PathwiseVegasAccountingEngine accountingengine(boost::shared_ptr<LogNormalFwdRateEuler>(new LogNormalFwdRateEuler(evolver)), // method relies heavily on LMM Euler
                    productToUse,
                    marketModel, // we need pseudo-roots and displacements
                    vegaBumps,
                    initialNumeraireValue);

                accountingengine.multiplePathValues(values,errors,pathsToDoSimulation);
            }

            // we have computed the vegas now we have to test them against the analytic values

            // extract into easier format




            Matrix vegasMatrix(caplets.numberOfProducts(), vegaBumps[0].size());
            Matrix standardErrors(vegasMatrix);
            Matrix deltasMatrix(caplets.numberOfProducts(), numberRates);
            Matrix deltasErrors(deltasMatrix);
            std::vector<Real> prices(caplets.numberOfProducts());
            std::vector<Real> priceErrors(caplets.numberOfProducts());

            Size entriesPerProduct = 1+numberRates+vegaBumps[0].size();

            for (Size i=0; i < caplets.numberOfProducts(); ++i)
            {
                prices[i] =  values[i*entriesPerProduct];
                priceErrors[i] = errors[i*entriesPerProduct];

                for (Size j=0; j < vegaBumps[0].size(); ++j)
                {
                    vegasMatrix[i][j] = values[i*entriesPerProduct + numberRates+1 + j];
                    standardErrors[i][j] = errors[i*entriesPerProduct + numberRates+1 + j];
                }
                for (Size j=0; j < numberRates; ++j)
                {
                    deltasMatrix[i][j] = values[i*entriesPerProduct +1 + j];
                    deltasErrors[i][j] = errors[i*entriesPerProduct +1 + j];
                }
            }



            // first get the terminal vols

            Matrix totalCovariance(marketModel->totalCovariance(marketModel->numberOfSteps()-1));


            std::vector<Real> truePrices(caplets.numberOfProducts());

            for (Size r =0; r < truePrices.size(); ++r)
            {
                truePrices[r] = BlackCalculator(displacedPayoffs[r], todaysForwards[r], sqrt(totalCovariance[r][r]),
                    todaysDiscounts[r+1]*(rateTimes[r+1]-rateTimes[r])).value();
            }


            for (Size b =0; b < vegaBumps[0].size(); ++b)
            {


                std::vector<Real> bumpedPrices(truePrices.size());
                std::vector<Real> variances(truePrices.size(),0.0);
                std::vector<Real> vegas(truePrices.size());


                for (Size step = 0; step < marketModel->numberOfSteps(); ++step)
                {
                    Matrix pseudoRoot( marketModel->pseudoRoot(step));
                    pseudoRoot += vegaBumps[step][b];

                    for (Size rate=step; rate<marketModel->numberOfRates(); ++rate)
                    {
                        Real variance = 0.0;
                        for (Size f=0; f < marketModel->numberOfFactors(); ++f)
                            variance+= pseudoRoot[rate][f]* pseudoRoot[rate][f];

                        variances[rate]+=variance;
                    }
                }

                for (Size r =0; r < truePrices.size(); ++r)
                {

                    bumpedPrices[r] = BlackCalculator(displacedPayoffs[r], todaysForwards[r], sqrt(variances[r]),
                        todaysDiscounts[r+1]*(rateTimes[r+1]-rateTimes[r])).value();

                    vegas[r] = bumpedPrices[r] - truePrices[r];

                }


                for (Size s=0; s  < truePrices.size(); ++s)
                {
                    Real mcVega = vegasMatrix[s][b];
                    Real analyticVega = vegas[s];
                    Real thisError =  mcVega - analyticVega;
                    Real thisSE = standardErrors[s][b];

                    if (fabs(thisError) >  0.0)
                    {
                        Real errorInSEs = thisError/thisSE;
                        biggestError = std::max(fabs(errorInSEs),biggestError);

                        if (fabs(errorInSEs) > 4.5)
                        {
                            if (deflate==0)
                                ++numberUndeflatedErrors;
                            else
                                ++numberDeflatedErrors;
                        }
                    }

                }


            }



            // for deltas and prices the pathwise vega engine should agree precisely with the pathwiseaccounting engine
            // so lets see if it does

            std::auto_ptr<MarketModelPathwiseMultiProduct> productToUse2;

            if (deflate ==0)
                productToUse2 = caplets.clone();
            else
                productToUse2 = capletsDeflated.clone();


            SequenceStatisticsInc stats(productToUse2->numberOfProducts()*(todaysForwards.size()+1));
            {
                PathwiseAccountingEngine accountingengine(boost::shared_ptr<LogNormalFwdRateEuler>(new LogNormalFwdRateEuler(evolver)), // method relies heavily on LMM Euler
                    *productToUse2,
                    marketModel, // we need pseudo-roots and displacements
                    initialNumeraireValue);

                accountingengine.multiplePathValues(stats,pathsToDoSimulation);
            }

            std::vector<Real> valuesAndDeltas2 = stats.mean();
            std::vector<Real> errors2 = stats.errorEstimate();

            std::vector<Real> prices2(productToUse2->numberOfProducts());
            std::vector<Real> priceErrors2(productToUse2->numberOfProducts());

            Matrix deltas2( productToUse2->numberOfProducts(), todaysForwards.size());
            Matrix deltasErrors2( productToUse2->numberOfProducts(), todaysForwards.size());
            std::vector<Real> modelPrices2(productToUse2->numberOfProducts());


            for (Size i=0; i < productToUse2->numberOfProducts(); ++i)
            {
                prices2[i] = valuesAndDeltas2[i];
                priceErrors2[i] = errors2[i];

                for (Size j=0; j <  todaysForwards.size(); ++j)
                {
                    deltas2[i][j] = valuesAndDeltas2[(i+1)*productToUse2->numberOfProducts()+j];
                    deltasErrors2[i][j]  = errors2[(i+1)* productToUse2->numberOfProducts()+j];
                }
            }

            for (Size i=0; i < productToUse2->numberOfProducts(); ++i)
            {

                Real priceDiff = prices2[i] - prices[i];

                if (fabs(priceDiff) > 5*priceErrors2[i])  // two sets of standard error
                    BOOST_FAIL("pathwise accounting engine and pathwise vegas accounting engine not in perfect agreement for price.\n product " << i << ",  vega computed price: " << prices[j] << " previous price " << prices2[j] << ", deflate " << deflate << "\n" );

                for (Size j=0; j <  todaysForwards.size(); ++j)
                {
                    Real error = deltas2[i][j] - deltasMatrix[i][j];
                    if (fabs(error)> 5* deltasErrors2[i][j] ) // two sets of standard error
                        BOOST_FAIL("pathwise accounting engine and pathwise vegas accounting engine not in perfect agreement for dealts.\n product " << i << ", rate " << j << " vega computed delta: " << deltasMatrix[i][j] << " previous delta " << deltas2[i][j] << "\n" );
                }
            }
        } // end of k loop over measures
    } // end of loop over deflation


    if (numberDeflatedErrors+numberUndeflatedErrors >0)
        BOOST_FAIL("Model pathwise vega test for caplets fails : " << numberDeflatedErrors <<" deflated errors and " <<numberUndeflatedErrors <<  " undeflated errors , biggest error in SEs is " << biggestError << "\n");


    {
        //  now do a simulation test for the vegas for caps

        std::vector<VolatilityBumpInstrumentJacobian::Cap> caps;

        Rate capStrike = todaysForwards[0];

        for (Size i=0; i +2 < numberRates; i=i+3)
        {
            VolatilityBumpInstrumentJacobian::Cap nextCap;
            //            nextCap.startIndex_ = i;
            //            nextCap.endIndex_ = i+3;
            //             nextCap.strike_ = capStrike;
            //             caps.push_back(nextCap);

            //        nextCap.startIndex_ = i+1;
            //      nextCap.endIndex_ = i+3;
            //    nextCap.strike_ = capStrike;
            //  caps.push_back(nextCap);

            nextCap.startIndex_ = i+2;
            nextCap.endIndex_ = i+3;
            nextCap.strike_ = capStrike;
            caps.push_back(nextCap);

        }

        std::vector<std::pair<Size,Size> > startsAndEnds(caps.size());

        for (Size r=0; r < caps.size(); ++r)
        {
            startsAndEnds[r].first = caps[r].startIndex_;
            startsAndEnds[r].second = caps[r].endIndex_;
        }

        MarketModelPathwiseMultiDeflatedCap capsDeflated(
            rateTimes,
            accruals,
            paymentTimes,
            capStrike,
            startsAndEnds);

        // define  productToUse = capletsDeflated.clone();

        for (Size k=0; k<LENGTH(measures); k++)
        {

            std::vector<Size> numeraires = makeMeasure(product, measures[k]);

            MTBrownianGeneratorFactory generatorFactory(seed_);
            MTBrownianGeneratorFactory generatorFactory2(seed_);

            bool logNormal = true;
            boost::shared_ptr<MarketModel> marketModel =
                makeMarketModel(logNormal, evolution, factors,
                marketModels[j]);

            LogNormalFwdRateEuler evolver(marketModel,
                generatorFactory,
                numeraires);

             LogNormalFwdRateEuler evolver2(marketModel,
                generatorFactory2,
                numeraires);

            //      SequenceStatistics stats(product.numberOfProducts()*(todaysForwards.size()+1+vegaBumps[0].size()));


            std::ostringstream config;
            config <<
                marketModelTypeToString(marketModels[j]) << ", " <<
                factors << (factors>1 ? (factors==todaysForwards.size() ? " (full) factors, " : " factors, ") : " factor,") <<
                measureTypeToString(measures[k]) << ", " <<
                "MT BGF";
            if (printReport_)
                BOOST_TEST_MESSAGE("    " << config.str());

            Size initialNumeraire = evolver.numeraires().front();
            Real initialNumeraireValue =
                todaysDiscounts[initialNumeraire];

            std::vector<Real> values;
            std::vector<Real> errors;

            std::vector<Real> values2;
            std::vector<Real> errors2;


            {

                PathwiseVegasOuterAccountingEngine accountingengine(boost::shared_ptr<LogNormalFwdRateEuler>(new LogNormalFwdRateEuler(evolver2)), // method relies heavily on LMM Euler
                    capsDeflated,
                    marketModel, // we need pseudo-roots and displacements
                    vegaBumps,
                    initialNumeraireValue);

                accountingengine.multiplePathValues(values2,errors2,pathsToDoSimulation);
            }

            {

                PathwiseVegasAccountingEngine accountingengine(boost::shared_ptr<LogNormalFwdRateEuler>(new LogNormalFwdRateEuler(evolver)), // method relies heavily on LMM Euler
                    capsDeflated,
                    marketModel, // we need pseudo-roots and displacements
                    vegaBumps,
                    initialNumeraireValue);

                accountingengine.multiplePathValues(values,errors,pathsToDoSimulation);
            }

            // first test to see that the two implementation give the same results

            {
                Real tol = 1E-8;

                Size numberMeanFailures =0;

                for (Size i=0; i <values.size(); ++i)
                    if (fabs(values[i]-values2[i]) > tol)
                        ++numberMeanFailures;

                      if (numberMeanFailures >0)
                          BOOST_FAIL("Comparison of Pathwise vegas accounting engine and PathwiseVegasOuterAccountingEngine yields discrepancies:" 
                                                         << numberMeanFailures 
                                                         << "  out of " 
                                                         << values.size() );

            }

            // we have computed the vegas now we have to test them against the analytic values

            // extract into easier format




            Matrix vegasMatrix(capsDeflated.numberOfProducts(), vegaBumps[0].size());
            Matrix standardErrors(vegasMatrix);
            Size entriesPerProduct = 1+numberRates+vegaBumps[0].size();

            for (Size i=0; i < capsDeflated.numberOfProducts(); ++i)
                for (Size j=0; j < vegaBumps[0].size(); ++j)
                {
                    vegasMatrix[i][j] = values[i*entriesPerProduct + numberRates+1 + j];
                    standardErrors[i][j] = errors[i*entriesPerProduct + numberRates+1 + j];
                }


                // first get the terminal vols

                Matrix totalCovariance(marketModel->totalCovariance(marketModel->numberOfSteps()-1));

                std::vector<Real> trueCapletPrices(numberRates);
                boost::shared_ptr<StrikedTypePayoff> dispayoff( new
                    PlainVanillaPayoff(Option::Call, capStrike+displacement));

                for (Size r =0; r < trueCapletPrices.size(); ++r)
                    trueCapletPrices[r] = BlackCalculator(dispayoff, todaysForwards[r], sqrt(totalCovariance[r][r]),
                    todaysDiscounts[r+1]*(rateTimes[r+1]-rateTimes[r])).value();

                std::vector<Real> trueCapPrices(capsDeflated.numberOfProducts());
                std::vector<Real> vegaCaps(capsDeflated.numberOfProducts());


                for (Size s=0; s < capsDeflated.numberOfProducts(); ++s)
                {

                    trueCapPrices[s]=0.0;

                    for (Size t= caps[s].startIndex_; t <  caps[s].endIndex_; ++t)
                        trueCapPrices[s] += trueCapletPrices[t];
                }

                Size numberErrors =0;


                for (Size b =0; b < vegaBumps[0].size(); ++b)

                {


                    std::vector<Real> bumpedCapletPrices(trueCapletPrices.size());
                    //                  std::vector<Real> bumpedCapPrices(trueCapPrices.size());

                    std::vector<Real> variances(trueCapletPrices.size(),0.0);
                    std::vector<Real> vegasCaplets(trueCapletPrices.size());



                    for (Size step = 0; step < marketModel->numberOfSteps(); ++step)
                    {
                        Matrix pseudoRoot( marketModel->pseudoRoot(step));
                        pseudoRoot += vegaBumps[step][b];

                        for (Size rate=step; rate<marketModel->numberOfRates(); ++rate)
                        {
                            Real variance = 0.0;
                            for (Size f=0; f < marketModel->numberOfFactors(); ++f)
                                variance+= pseudoRoot[rate][f]* pseudoRoot[rate][f];

                            variances[rate]+=variance;
                        }
                    }

                    for (Size r =0; r < trueCapletPrices.size(); ++r)
                    {

                        bumpedCapletPrices[r] = BlackCalculator(dispayoff, todaysForwards[r], sqrt(variances[r]),
                            todaysDiscounts[r+1]*(rateTimes[r+1]-rateTimes[r])).value();

                        vegasCaplets[r] = bumpedCapletPrices[r] - trueCapletPrices[r];

                    }

                    for (Size s=0; s < capsDeflated.numberOfProducts(); ++s)
                    {

                        vegaCaps[s]=0.0;

                        for (Size t= caps[s].startIndex_; t <  caps[s].endIndex_; ++t)
                            vegaCaps[s] += vegasCaplets[t];
                    }


                    for (Size s=0; s  < capsDeflated.numberOfProducts(); ++s)
                    {
                        Real mcVega = vegasMatrix[s][b];
                        Real analyticVega = vegaCaps[s];
                        Real thisError =  mcVega - analyticVega;
                        Real thisSE = standardErrors[s][b];

                        if (fabs(thisError) >  0.0)
                        {
                            Real errorInSEs = fabs(thisError/thisSE);

                            if (errorInSEs > 3.5)
                                ++numberErrors;
                        }

                    }


                }


                if (numberErrors >0)
                    BOOST_FAIL("caps Pathwise vega test fails : " << numberErrors <<"\n");

        } // end of k loop over measures
    }

}
}

for (Size i=0; i<todaysForwards.size(); ++i) {
payoffs[i] = boost::shared_ptr<Payoff>(new
    PlainVanillaPayoff(Option::Call, cs.coterminalSwapRate(i)));

displacedPayoffs[i] = boost::shared_ptr<StrikedTypePayoff>(new
    PlainVanillaPayoff(Option::Call, cs.coterminalSwapRate(i)+displacement));

}

for (Size i=0; i +2 < numberRates; i=i+3)
{
VolatilityBumpInstrumentJacobian::Cap nextCap;
nextCap.startIndex_ = i;
nextCap.endIndex_ = i+3;
nextCap.strike_ = capStrike;
caps.push_back(nextCap);
}

for (Size j=0; j < caps.size(); ++j)
{
startsAndEnds[j].first = caps[j].startIndex_;
startsAndEnds[j].second = caps[j].endIndex_;


}

for (Size i=0; i < numberRates; ++i)
{
swaptions[i].startIndex_ = i;
swaptions[i].endIndex_ = numberRates;

}

for (Size j=0; j<LENGTH(marketModels); j++)
{

Size testedFactors[] = { std::min<Size>(1UL,todaysForwards.size())
    //    todaysForwards.size()
    //, 4, 8,
};



for (Size m=0; m<LENGTH(testedFactors); ++m)
{
    Size factors = testedFactors[m];

    bool logNormal = true;

    boost::shared_ptr<MarketModel> marketModel =
        makeMarketModel(logNormal, evolution, factors,
        marketModels[j]);


    // we need to work out our bumps

    VegaBumpCollection possibleBumps(marketModel,
        allowFactorwiseBumping);

    OrthogonalizedBumpFinder  bumpFinder(possibleBumps,
        swaptions,
        caps,
        multiplier, // if vector length grows by more than this discard
        tolerance);      // if vector projection before scaling less than this discard
    std::vector<std::vector<Matrix> > theBumps;

    bumpFinder.GetVegaBumps(theBumps);

    // the bumps is now the bumps required to get a one percent implied vol in each instrumnet
    // indexed by step, instrument, pseudo-root matrix
    // if we dot product with swaption derivatives, we should get a 1% change in imp vol on the diagonal
    // and zero off it
    {
        Matrix swaptionVegasMatrix(swaptionsDeflated.numberOfProducts(), theBumps[0].size());

        for (Size i=0; i < swaptionsDeflated.numberOfProducts(); ++i)
        {
            SwaptionPseudoDerivative thisPseudoDerivative(marketModel,
                swaptions[i].startIndex_,
                swaptions[i].endIndex_);


            for (Size j=0; j <  theBumps[0].size(); ++j)
            {
                swaptionVegasMatrix[i][j] = 0;

                for (Size k=0; k < steps; ++k)
                    for (Size l=0; l < numberRates; ++l)
                        for (Size m=0; m < factors; ++m)
                            swaptionVegasMatrix[i][j] += theBumps[k][j][l][m]*thisPseudoDerivative.volatilityDerivative(k)[l][m];
            }
        }

        Size numberDiagonalFailures = 0;
        Size offDiagonalFailures=0;

        for (Size i=0; i < swaptions.size(); ++i)
        {
            for (Size j=0; j <  theBumps[0].size(); ++j)
            {
                if (i == j)
                {
                    Real thisError = swaptionVegasMatrix[i][i] - 0.01;

                    if (fabs(thisError) > 1e-8)
                        ++numberDiagonalFailures;
                }
                else
                {
                    Real thisError = swaptionVegasMatrix[i][j];
                    if (fabs(thisError) > 1e-8)
                        ++offDiagonalFailures;
                }
            }
        }

        if (numberDiagonalFailures + offDiagonalFailures>0 )
            BOOST_FAIL("Pathwise market vega analytic test fails for  swaptions : " << offDiagonalFailures <<" off diagonal failures \n "
            << " and " << numberDiagonalFailures << " on the diagonal." );
    }
    // now do the caps

    Matrix capsVegasMatrix(caps.size(), theBumps[0].size());

    for (Size i=0; i < caps.size(); ++i)
    {
        CapPseudoDerivative thisPseudoDerivative(marketModel,
            caps[i].strike_,
            caps[i].startIndex_,
            caps[i].endIndex_, initialNumeraireValue
            );


        for (Size j=0; j <  theBumps[0].size(); ++j)
        {
            capsVegasMatrix[i][j] = 0;

            for (Size k=0; k < steps; ++k)
                for (Size l=0; l < numberRates; ++l)
                    for (Size m=0; m < factors; ++m)
                        capsVegasMatrix[i][j] += theBumps[k][j][l][m]*thisPseudoDerivative.volatilityDerivative(k)[l][m];
        }
    }

    Size numberDiagonalFailures = 0;
    Size offDiagonalFailures=0;

    for (Size i=0; i < caps.size(); ++i)
    {
        for (Size j=0; j <  theBumps[0].size(); ++j)
        {
            if (i +swaptions.size()== j)
            {
                Real thisError = capsVegasMatrix[i][j] - 0.01;

                if (fabs(thisError) > 1e-8)
                    ++numberDiagonalFailures;
            }
            else
            {
                Real thisError = capsVegasMatrix[i][j];
                if (fabs(thisError) > 1e-8)
                    ++offDiagonalFailures;
            }
        }
    }

    if (numberDiagonalFailures + offDiagonalFailures>0 )
        BOOST_FAIL("Pathwise market vega analytic test fails for caps : " << offDiagonalFailures <<" off diagonal failures \n "
        << " and " << numberDiagonalFailures << " on the diagonal." );


} // end of  for (Size m=0; m<LENGTH(testedFactors); ++m)
} // end of   for (Size j=0; j<LENGTH(marketModels); j++)


for (Size i=0; i < swaptionsDeflated.numberOfProducts(); ++i)
{
cashFlowsGenerated1[i].resize(swaptionsDeflated.maxNumberOfCashFlowsPerProductPerStep());
for (Size j=0; j < swaptionsDeflated.maxNumberOfCashFlowsPerProductPerStep(); ++j)
    cashFlowsGenerated1[i][j].amount.resize(numberRates+1);
}

for (Size j=0; j<LENGTH(marketModels); j++)
{

Size testedFactors[] = { std::min<Size>(1UL,todaysForwards.size())
    //    todaysForwards.size()
    //, 4, 8,
};




for (Size m=0; m<LENGTH(testedFactors); ++m)
{
    Size factors = testedFactors[m];

    MTBrownianGeneratorFactory generatorFactory(seed_);

    bool logNormal = true;

    boost::shared_ptr<MarketModel> marketModel =
        makeMarketModel(logNormal, evolution, factors,
        marketModels[j]);

    LogNormalFwdRateEuler evolver1(marketModel,
        generatorFactory,swaptionsDeflated.suggestedNumeraires()
        );

    LogNormalFwdRateEuler evolver2(marketModel,
        generatorFactory,swaptionsDeflated.suggestedNumeraires()
        );

    for (Size p=0; p < pathsToDo; ++p)
    {
        evolver1.startNewPath();
        swaptionsDeflated.reset();
        evolver2.startNewPath();
        swaptionsDeflated2.reset();
        Size step =0;

        bool done,done2;

        do
        {
            evolver1.advanceStep();
            done = swaptionsDeflated.nextTimeStep(evolver1.currentState(),
                numberCashFlowsThisStep1,
                cashFlowsGenerated1);

            evolver2.advanceStep();
            done2 = swaptionsDeflated2.nextTimeStep(evolver2.currentState(),
                numberCashFlowsThisStep2,
                cashFlowsGenerated2);

            if (done != done2)
                BOOST_FAIL("numerical swaptions derivative and swaptions disagree on termination");

            for (Size prod = 0; prod <  swaptionsDeflated.numberOfProducts(); ++prod)
            {
                if (numberCashFlowsThisStep1[prod] != numberCashFlowsThisStep2[prod])
                    BOOST_FAIL("numerical swaptions derivative and swaptions disagree on number of cash flows");

                for (Size cf =0; cf < numberCashFlowsThisStep1[prod]; ++cf)
                    for (Size rate=0; rate<= numberRates; ++rate)
                        if ( fabs(cashFlowsGenerated1[prod][cf].amount[rate] -  cashFlowsGenerated2[prod][cf].amount[rate]) > tolerance )
                            BOOST_FAIL("numerical swaptions derivative and swaptions disagree on cash flow size. cf = " << cf <<
                            "step " << step << ", rate " << rate << ", amount1 " << cashFlowsGenerated1[prod][cf].amount[rate]
                        << " ,amount2 " << cashFlowsGenerated2[prod][cf].amount[rate] << "\n");





            }

            ++step;


        }
        while (!done);



    }


} // end of  for (Size m=0; m<LENGTH(testedFactors); ++m)
} // end of   for (Size j=0; j<LENGTH(marketModels); j++)

for (Size j=0; j<LENGTH(marketModels); j++)
{

Size testedFactors[] = { std::min<Size>(1UL,todaysForwards.size())
    //    todaysForwards.size()
    //, 4, 8,
};




for (Size m=0; m<LENGTH(testedFactors); ++m)
{
    Size factors = testedFactors[m];

    MTBrownianGeneratorFactory generatorFactory(seed_);

    bool logNormal = true;

    boost::shared_ptr<MarketModel> marketModel =
        makeMarketModel(logNormal, evolution, factors,
        marketModels[j]);

    LogNormalFwdRateEuler evolver(marketModel,
        generatorFactory,swaptionsDeflated.suggestedNumeraires()
        );

    Size initialNumeraire = evolver.numeraires().front();
    Real initialNumeraireValue =
        todaysDiscounts[initialNumeraire];


    // we need to work out our bumps

    VegaBumpCollection possibleBumps(marketModel,
        allowFactorwiseBumping);


    OrthogonalizedBumpFinder  bumpFinder(possibleBumps,
        swaptions,
        caps,
        multiplier, // if vector length grows by more than this discard
        tolerance);      // if vector projection before scaling less than this discard
    std::vector<std::vector<Matrix> > theBumps;

    bumpFinder.GetVegaBumps(theBumps);


    std::vector<Real> values;

    std::vector<Real> errors;

    {

        PathwiseVegasAccountingEngine
            accountingEngine(boost::shared_ptr<LogNormalFwdRateEuler>(new LogNormalFwdRateEuler(evolver)),
            swaptionsDeflated,
            marketModel,
            theBumps,initialNumeraireValue);


        accountingEngine.multiplePathValues(values,errors,pathsToDoSimulation);

    }

    // we now have the simulation vegas, put them in more convenient form


    Matrix vegasMatrix(swaptionsDeflated.numberOfProducts(), theBumps[0].size());
    Matrix standardErrors(vegasMatrix);
    Size entriesPerProduct = 1+numberRates+theBumps[0].size();

    for (Size i=0; i < swaptionsDeflated.numberOfProducts(); ++i)
        for (Size j=0; j < theBumps[0].size(); ++j)
        {
            vegasMatrix[i][j] = values[i*entriesPerProduct + numberRates+1+j];
            standardErrors[i][j] = errors[i*entriesPerProduct + numberRates+1 +j];
        }

        // we next get the model vegas for comparison

        std::vector<Real> impliedVols_(swaptions.size());

        for (Size i=0; i < swaptions.size(); ++i)
            impliedVols_[i] = SwapForwardMappings::swaptionImpliedVolatility(*marketModel,
            swaptions[i].startIndex_,
            swaptions[i].endIndex_);

        std::vector<Real> analyticVegas(swaptions.size());
        for (Size i=0; i < swaptions.size(); ++i)
        {
            Real swapRate = cs.coterminalSwapRates()[i];
            Real annuity =  cs.coterminalSwapAnnuity(0,i)*initialNumeraireValue;
            Real expiry = rateTimes[i];
            Real sd = impliedVols_[i]*sqrt(expiry);
            Real swapDisplacement=0.0;

            Real vega = blackFormulaVolDerivative(swapRate,
                swapRate,
                sd,
                expiry,
                annuity,
                swapDisplacement);

            analyticVegas[i] = vega*0.01; // one percent move

        }

        // diagonal vegas should agree up to standard errors
        // off diagonal vegas should be zero

        Size numberDiagonalFailures = 0;
        Size offDiagonalFailures=0;


        for (Size i=0; i < swaptions.size(); ++i)
        {
            Real thisError = vegasMatrix[i][i] - analyticVegas[i];
            Real thisErrorInSds = thisError /  (standardErrors[i][i]+1E-6); // silly to penalize for tiny standard error

            if (fabs(thisErrorInSds) > 4)
                ++numberDiagonalFailures;

        }

        for (Size i=0; i < swaptions.size(); ++i)
            for (Size j=0; j < theBumps[0].size(); ++j)
            {
                if ( i !=j )
                {
                    Real thisError = vegasMatrix[i][j]; // true value is zero

                    Real thisErrorInSds = thisError /  (standardErrors[i][j]+1E-6);

                    if (fabs(thisErrorInSds) > 3.5)
                        ++offDiagonalFailures;
                }
            }

            if (offDiagonalFailures + numberDiagonalFailures >0)
                BOOST_FAIL("Pathwise market vega test fails for coterminal swaptions : " << offDiagonalFailures <<" off diagonal failures \n "
                << " and " << numberDiagonalFailures << " on the diagonal." );




} // end of  for (Size m=0; m<LENGTH(testedFactors); ++m)
} // end of   for (Size j=0; j<LENGTH(marketModels); j++)

for (Size j=0; j<LENGTH(marketModels); j++)
{

Size testedFactors[] = { std::min<Size>(2UL,todaysForwards.size())
    //    todaysForwards.size()
    //, 4, 8,
};




for (Size m=0; m<LENGTH(testedFactors); ++m)
{
    Size factors = testedFactors[m];

    MTBrownianGeneratorFactory generatorFactory(seed_);

    bool logNormal = true;

    boost::shared_ptr<MarketModel> marketModel =
        makeMarketModel(logNormal, evolution, factors,
        marketModels[j]);

    LogNormalFwdRateEuler evolver(marketModel,
        generatorFactory,capsDeflated.suggestedNumeraires()
        );

    Size initialNumeraire = evolver.numeraires().front();
    Real initialNumeraireValue =
        todaysDiscounts[initialNumeraire];


    // we need to work out our bumps

    VegaBumpCollection possibleBumps(marketModel,
        allowFactorwiseBumping);


    OrthogonalizedBumpFinder  bumpFinder(possibleBumps,
        swaptions,
        caps,
        multiplier, // if vector length grows by more than this discard
        tolerance);      // if vector projection before scaling less than this discard
    std::vector<std::vector<Matrix> > theBumps;

    bumpFinder.GetVegaBumps(theBumps);


    std::vector<Real> values;

    std::vector<Real> errors;

    {

        PathwiseVegasAccountingEngine
            accountingEngine(boost::shared_ptr<LogNormalFwdRateEuler>(new LogNormalFwdRateEuler(evolver)),
            capsDeflated,
            marketModel,
            theBumps,initialNumeraireValue);


        accountingEngine.multiplePathValues(values,errors,pathsToDoSimulation);

    }

    // we now have the simulation vegas, put them in more convenient form


    Matrix vegasMatrix(capsDeflated.numberOfProducts(), theBumps[0].size());
    Matrix standardErrors(vegasMatrix);
    Size entriesPerProduct = 1+numberRates+theBumps[0].size();


    for (Size i=0; i < capsDeflated.numberOfProducts(); ++i)
        for (Size j=0; j < theBumps[0].size(); ++j)
        {
            vegasMatrix[i][j] = values[i*entriesPerProduct +numberRates+j+1];
            standardErrors[i][j] = errors[i*entriesPerProduct +numberRates+j+1];
        }

        // we next get the model vegas for comparison

        std::vector<Real> impliedVols_(caps.size());


        std::vector<Real> analyticVegas(caps.size());
        for (Size i=0; i < caps.size(); ++i)
        {

            CapPseudoDerivative capPseudo(marketModel,
                caps[i].strike_,
                caps[i].startIndex_,
                caps[i].endIndex_, initialNumeraireValue);

            impliedVols_[i] = capPseudo.impliedVolatility();

            Real vega=0.0;

            for (Size j= caps[i].startIndex_; j< caps[i].endIndex_; ++j)
            {


                Real forward  = cs.forwardRates()[j];
                Real annuity =  cs.discountRatio(j+1,0)*initialNumeraireValue*accruals[j];
                Real expiry = rateTimes[j];
                Real sd = impliedVols_[i]*sqrt(expiry);
                Real displacement=0.0;

                Real capletVega = blackFormulaVolDerivative(caps[i].strike_,forward,
                    sd,
                    expiry,
                    annuity,
                    displacement);

                vega += capletVega;
            }



            analyticVegas[i] = vega*0.01; // one percent move

        }

        // diagonal vegas should agree up to standard errors
        // off diagonal vegas should be zero

        Size numberDiagonalFailures = 0;
        Size offDiagonalFailures=0;


        for (Size i=0; i < caps.size(); ++i)
        {
            Real thisError = vegasMatrix[i][i+swaptions.size()] - analyticVegas[i];
            Real thisErrorInSds = thisError /  (standardErrors[i][i+swaptions.size()]+1E-6); // silly to penalize for tiny standard error

            if (fabs(thisErrorInSds) > 4)
            {
                BOOST_TEST_MESSAGE(" MC cap vega: " <<vegasMatrix[i][i+swaptions.size()] << " Analytic cap vega:" << analyticVegas[i] << " Error in sds:" << thisErrorInSds << "\n");
                ++numberDiagonalFailures;
            }

        }

        for (Size i=0; i < caps.size(); ++i)
            for (Size j=0; j < theBumps[0].size(); ++j)
            {
                if ( i+swaptions.size() !=j )
                {
                    Real thisError = vegasMatrix[i][j]; // true value is zero

                    Real thisErrorInSds = thisError /  (standardErrors[i][j]+1E-6);

                    if (fabs(thisErrorInSds) > 3.5)
                        ++offDiagonalFailures;
                }
            }

            if (offDiagonalFailures + numberDiagonalFailures >0)
                BOOST_FAIL("Pathwise market vega test fails for caps: " << offDiagonalFailures <<" off diagonal failures \n "
                << " and " << numberDiagonalFailures << " on the diagonal." );




} // end of  for (Size m=0; m<LENGTH(testedFactors); ++m)
} // end of   for (Size j=0; j<LENGTH(marketModels); j++)

for (Size i=0; i<N; i++) {
Time T1 = 0.5*(1+i);     // expiry of forward 1: after T1 AbcdVol = 0
for (Size k=0; k<N-i; k++) {
    Time T2 = 0.5*(1+k); // expiry of forward 2: after T2 AbcdVol = 0
    //Integration
    for(Size j=0; j<N; j++) {
        Real xMin = 0.5*j;
        for (Size l=0; l<N-j; l++) {
            Real xMax = xMin + 0.5*l;
            AbcdSquared abcd2(a,b,c,d,T1,T2);
            Real numerical = SI(abcd2,xMin,xMax);
            Real analytical = instVol->covariance(xMin,xMax,T1,T2);
            if (std::abs(analytical-numerical)>precision) {
                BOOST_ERROR("     T1=" << T1 << "," <<
                    "T2=" << T2 << ",\t\t" <<
                    "xMin=" << xMin << "," <<
                    "xMax=" << xMax << ",\t\t" <<
                    "analytical: " << analytical << ",\t" <<
                    "numerical:   " << numerical);
            }
            if (T1==T2) {
                Real variance = instVol->variance(xMin,xMax,T1);
                if (std::abs(analytical-variance)>1e-14) {
                    BOOST_ERROR("     T1=" << T1 << "," <<
                        "T2=" << T2 << ",\t\t" <<
                        "xMin=" << xMin << "," <<
                        "xMax=" << xMax << ",\t\t" <<
                        "variance: " << variance << ",\t" <<
                        "analytical: " << analytical);
                }
            }
        }
    }
}
}

for (i1=0; i1<rateTimes.size(); i1++ ) {
for (i2=0; i2<rateTimes.size(); i2++ ) {
    Time T = 0.;
    do {
        Real lmCovariance = lmAbcd->integratedVariance(i1,i2,T);
        Real abcdCovariance =
            abcd->covariance(0,T,rateTimes[i1],rateTimes[i2]);
        if(std::abs(lmCovariance-abcdCovariance)>1e-10) {
            BOOST_FAIL(" T1="   << rateTimes[i1] << ","     <<
                "T2="   << rateTimes[i2] << ",\t\t" <<
                "xMin=" << 0  << ","     <<
                "xMax=" << T  << ",\t\t" <<
                "abcd: " << abcdCovariance << ",\t" <<
                "lm: "   << lmCovariance);
        }
        T += 0.5;
    } while (T<std::min(rateTimes[i1],rateTimes[i2])) ;
}
}

for (Size i=0; i<blackVols.size(); i++) {
if (std::abs(k[i]-1.0)>tol) {
    Real modelVol =
        abcd.volatility(0.0, rateTimes[i], rateTimes[i]);
    BOOST_FAIL("\n EndCriteria = " << ec <<
        "\n Fixing Time = " << rateTimes[i] <<
        "\n MktVol      = " << io::rate(blackVols[i]) <<
        "\n ModVol      = " << io::rate(modelVol) <<
        "\n k           = " << k[i] <<
        "\n error       = " << std::abs(k[i]-1.0) <<
        "\n tol         = " << tol);
}
}

for (Size i=0; i<todaysForwards.size(); ++i)
{
forwardStrikes[i] = todaysForwards[i] + 0.01;
optionletPayoffs[i] = boost::shared_ptr<Payoff>(new
    PlainVanillaPayoff(Option::Call, todaysForwards[i]));
displacedPayoffs[i] = boost::shared_ptr<PlainVanillaPayoff>(new
    PlainVanillaPayoff(Option::Call, todaysForwards[i]+displacement));
}

for (Size j=0; j<LENGTH(marketModels); j++)
{

Size testedFactors[] = {1, 2, todaysForwards.size()};
for (Size m=0; m<LENGTH(testedFactors); ++m) {
    Size factors = testedFactors[m];

    MeasureType measures[] = { MoneyMarket, Terminal };

    for (Size k=0; k<LENGTH(measures); k++)
    {
        std::vector<Size> numeraires = makeMeasure(product, measures[k]);

        bool logNormal = true;
        boost::shared_ptr<MarketModel> marketModel =
            makeMarketModel(logNormal, evolution, factors, marketModels[j]);


        for (Size n=0; n<1; n++)
        {
            MTBrownianGeneratorFactory generatorFactory(seed_);

            boost::shared_ptr<MarketModelEvolver> evolver(new SVDDFwdRatePc(marketModel,
                                  generatorFactory,
                                  volProcess,
                                  firstVolatilityFactor,
                                  volatilityFactorStep,
                                  numeraires
                                  ));


            std::ostringstream config;
            config <<
                marketModelTypeToString(marketModels[j]) << ", " <<
                factors << (factors>1 ? (factors==todaysForwards.size() ? " (full) factors, " : " factors, ") : " factor,") <<
                measureTypeToString(measures[k]) << ", " <<
                "SVDDFwdRatePc" << ", " <<
                "MT BGF";
            if (printReport_)
                BOOST_TEST_MESSAGE("    " << config.str());

            boost::shared_ptr<SequenceStatisticsInc> stats =
                simulate(evolver, product);

            std::vector<Real> results = stats->mean();
            std::vector<Real> errors = stats->errorEstimate();


            // check forwards


               for (Size i=0; i < accruals.size(); ++i)
               {
                   Real trueValue =  todaysDiscounts[i]- todaysDiscounts[i+1]*(1+ forwardStrikes[i]*accruals[i]);
                   Real error = results[i] - trueValue;
                   Real errorSds = error/ errors[i];

                   if (fabs(errorSds) > 3.5)
                       BOOST_FAIL("error in sds: " << errorSds << " for forward " << i << " in SV LMM test. True value:" << trueValue << ", actual value: " << results[i] << " , standard error " << errors[i]);



               }

               for (Size i=0; i < accruals.size(); ++i)
               {

                      Real volCoeff =  volatilities[i];
//                                  sqrt(marketModel->totalCovariance(i)[i][i]/evolution.evolutionTimes()[i]);
                      Real theta = volCoeff*volCoeff*meanLevel;
                      Real kappa = reversionSpeed;
                      Real sigma = volCoeff*volVar;
                      Real rho = 0.0;
                      Real v1 = v0*volCoeff*volCoeff;




                      boost::shared_ptr<StrikedTypePayoff> payoff(
                                      new PlainVanillaPayoff(Option::Call, forwardStrikes[i]));



                      Real trueValue =0.0;
                      Size evaluations =0;

                      AnalyticHestonEngine::doCalculation(1.0, // no discounting
                                     1.0 ,// no discounting
                                     todaysForwards[i]+displacement,
                                     todaysForwards[i]+displacement,
                                     rateTimes[i],
                                     kappa,
                                     theta,
                                     sigma,
                                     v1,
                                     rho,
                                     *payoff,
                                     AnalyticHestonEngine::Integration::gaussLaguerre(),
//                                             AnalyticHestonEngine::Integration::gaussLobatto(1e-8, 1e-8),
                                     AnalyticHestonEngine::Gatheral,
                                     0,
                                     trueValue,
                                     evaluations);


                        trueValue *= accruals[i]*todaysDiscounts[i+1];

               //        trueValue =
              //                              BlackCalculator(displacedPayoffs[i],
              //                                                todaysForwards[i]+displacement,
              //                                             volatilities[i]*std::sqrt(rateTimes[i]),
             //                                              todaysDiscounts[i+1]*accruals[i]).value();


                        Real error = results[i+ accruals.size()] - trueValue;
                        Real errorSds = error/ errors[i];

                        if (fabs(errorSds) > 4)
                            BOOST_FAIL("error in sds: " << errorSds << " for caplet " << i << " in SV LMM test. True value:" << trueValue << ", actual value: " << results[i+ accruals.size()] << " , standard error " << errors[i]);




               }






        }
    }
}
}

for (Size k=0; k<LENGTH(marketModels); ++k) {   // loop over market models
bool logNormal = true;
boost::shared_ptr<MarketModel> marketModel =
    makeMarketModel(logNormal, evolution, factors, marketModels[k]);
std::vector<Rate> displacements = marketModel->displacements();
for (Size j=0; j<numberOfSteps; ++j) {     // loop over steps
    const Matrix& A = marketModel->pseudoRoot(j);
    //BOOST_TEST_MESSAGE(io::ordinal(j+1) << " pseudoroot:\n" << A);
    Size inf = std::max(0,static_cast<Integer>(alive[j]));
    for (Size h=inf; h<numeraires.size(); ++h) {     // loop over numeraires
        LMMDriftCalculator driftcalculator(A, displacements, rateTaus,
            numeraires[h], alive[j]);
        driftcalculator.computePlain(todaysForwards, drifts);
        driftcalculator.computeReduced(todaysForwards,
            driftsReduced);
        for (Size i=0; i<drifts.size(); ++i) {
            Real error = std::abs(driftsReduced[i]-drifts[i]);
            if (error>tolerance)
                BOOST_ERROR("MarketModel: " <<
                marketModelTypeToString(marketModels[k]) <<
                ", " << io::ordinal(j+1) << " step, " <<
                ", " << io::ordinal(h+1) << " numeraire, " <<
                ", " << io::ordinal(i+1) << " drift, " <<
                "\ndrift        =" << drifts[i] <<
                "\ndriftReduced =" << driftsReduced[i] <<
                "\n       error =" << error <<
                "\n   tolerance =" << tolerance);
        }
    }
}
}

for (Size i=0; i<dim; i++) set.push_back(i*1.0);

for (Size i=0; i<dim; i++) subset.push_back(dim+i*1.0);

for (Size i=0; i<dim; i++) {
    BOOST_TEST_MESSAGE(io::ordinal(i+1) << ":" <<
        " set[" << i << "] =  " << set[i] <<
        ", subset[" << i << "] =  " << subset[i] <<
        ", result[" << i << "] =  " << result[i]);
}

for(Size i=1;i<=n;i++) rateTimes.push_back(static_cast<Time>(i));

for(Size i=1;i<=n-1;i++) evolTimes2.push_back(static_cast<Time>(i));

for(Size i=1;i<=2*n-2;i++) evolTimes3.push_back(0.5*i);

for(Size k=0;k<modelNames.size();k++) {
for(Size l=0;l<evolNames.size();l++) {
    EvolutionDescription evolution(rateTimes,evolTimes[l]);
    boost::shared_ptr<MarketModel> model;
    switch(k) {
      case 0:
        model = boost::shared_ptr<MarketModel>(
                    new FlatVol(vols,corr,evolution,n-1,rates,displ));
        break;
      case 1:
        model = boost::shared_ptr<MarketModel>(
                         new AbcdVol(1.0,0.0,0.0,0.0,ks,
                                     corr,evolution,n-1,rates,displ));
        break;
      default:
        BOOST_FAIL("Unknown model " << modelNames[k]);
    }
    if (model) {
        for(Size i=0;i<evolTimes[l].size();i++) {
            Matrix cov = model->covariance(i);
            Real dt = evolTimes[l][i] - (i>0 ? evolTimes[l][i-1] : 0.0);
            for(Size x=0;x<n-1;x++) {
                for(Size y=0;y<n-1;y++) {
                    if(std::min(rateTimes[x],rateTimes[y])>=evolTimes[l][i]
                       && fabs(cov[x][y]-c[x][y]*dt)>1.0E-14) 
                        BOOST_FAIL("Model " << modelNames[k]
                                   << " with " << evolNames[l]
                                   << ": covariance matrix in step " << i
                                   << ": true value at (" << x << "," << y
                                   << ") is " << c[x][y]*dt
                                   << " actual value is " << cov[x][y]);
                }
            }
        }
    }
}
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/marketmodel_smmcapletalphacalibration.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=1; i<dates.size(); ++i)
    rateTimes_[i-1] = dayCounter_.yearFraction(todaysDate_, dates[i]);

for (Size i=1; i<rateTimes_.size(); ++i)
    accruals_[i-1] = rateTimes_[i] - rateTimes_[i-1];

for (Size i=0; i<todaysForwards_.size(); ++i) {
    todaysForwards_[i] = 0.03 + 0.0025*i;
    //    todaysForwards_[i] = 0.03;
}

for (Size i=1; i<rateTimes_.size(); ++i)
    todaysDiscounts_[i] = todaysDiscounts_[i-1] /
        (1.0+todaysForwards_[i-1]*accruals_[i-1]);

for (Size i=0; i<todaysSwaps_.size(); i++) {
    //    swaptionDisplacedVols[i] = todaysSwaps[i]*mktSwaptionVols[i]/
    //                              (todaysSwaps[i]+displacement);
    //    swaptionVols[i]= mktSwaptionVols[i];
    //    capletDisplacedVols[i] = todaysForwards[i]*mktCapletVols[i]/
    //                            (todaysForwards[i]+displacement);
    capletVols_[i]= mktCapletVols[i];
}

for (Size i=0; i<numberOfRates; ++i) {
swapVariances[i] = boost::shared_ptr<PiecewiseConstantVariance>(new
    PiecewiseConstantAbcdVariance(a_, b_, c_, d_,
                                  i, rateTimes_));
}

for (Size i=0; i<numberOfRates; ++i) {
capletVols[i] = std::sqrt(capletTotCovariance[i][i]/rateTimes_[i]);
}

for (Size i=0; i<numberOfRates; ++i) {
Volatility expSwaptionVol = swapVariances[i]->totalVolatility(i);
swapTerminalCovariance += swapPseudoRoots[i] * transpose(swapPseudoRoots[i]);
Volatility swaptionVol = std::sqrt(swapTerminalCovariance[i][i]/rateTimes_[i]);
error = std::fabs(swaptionVol-expSwaptionVol);
if (error>swapTolerance)
    BOOST_ERROR("failed to reproduce " << io::ordinal(i+1) << " swaption vol:"
                "\n expected:  " << io::rate(expSwaptionVol) <<
                "\n realized:  " << io::rate(swaptionVol) <<
                "\n error:     " << error <<
                "\n tolerance: " << swapTolerance);
}

for (Size i=0; i<numberOfRates; ++i) {
error = std::fabs(capletVols[i]-capletVols_[i]);
if (error>capletTolerance)
    BOOST_ERROR("failed to reproduce " << io::ordinal(i+1) << " caplet vol:"
                "\n expected:         " << io::rate(capletVols_[i]) <<
                "\n realized:         " << io::rate(capletVols[i]) <<
                "\n percentage error: " << error/capletVols_[i] <<
                "\n error:            " << error <<
                "\n tolerance:        " << capletTolerance);
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/blackformula.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for(Size i=0;i<LENGTH(d);++i){


Real strike = forward - d[i] * bpvol * std::sqrt(tte);

Real callPrem = bachelierBlackFormula(optionType, strike, forward, stdDev, discount);

Real impliedBpVol = bachelierBlackFormulaImpliedVol(optionType,strike, forward, tte, callPrem, discount);

if (std::fabs(bpvol-impliedBpVol)>1.0e-12){
    BOOST_ERROR("Failed, expected " << bpvol << " realised " << impliedBpVol );
}
}

for (Size i1 = 0; i1 < LENGTH(types); ++i1) {
for (Size i2 = 0; i2 < LENGTH(displacements); ++i2) {
    for (Size i3 = 0; i3 < LENGTH(forwards); ++i3) {
        for (Size i4 = 0; i4 < LENGTH(strikes); ++i4) {
            for (Size i5 = 0; i5 < LENGTH(stdDevs); ++i5) {
                for (Size i6 = 0; i6 < LENGTH(discounts); ++i6) {
                    if (forwards[i3] + displacements[i2] > 0.0 &&
                        strikes[i4] + displacements[i2] > 0.0) {
                        Real premium = blackFormula(
                            types[i1], strikes[i4], forwards[i3],
                            stdDevs[i5], discounts[i6],
                            displacements[i2]);
                        Real atmPremium = blackFormula(
                            types[i1], forwards[i3], forwards[i3],
                            stdDevs[i5], discounts[i6],
                            displacements[i2]);
                        Real iStdDev =
                            blackFormulaImpliedStdDevChambers(
                                types[i1], strikes[i4], forwards[i3],
                                premium, atmPremium, discounts[i6],
                                displacements[i2]);
                        Real moneyness = (strikes[i4] + displacements[i2]) /
                                     (forwards[i3] + displacements[i2]);
                        if(moneyness > 1.0) moneyness = 1.0 / moneyness;
                        Real error = (iStdDev - stdDevs[i5]) / stdDevs[i5] * moneyness;
                        if(error > tol)
                            BOOST_ERROR(
                                "Failed to verify Chambers-Nawalkha "
                                "approximation for "
                                << types[i1]
                                << " displacement=" << displacements[i2]
                                << " forward=" << forwards[i3]
                                << " strike=" << strikes[i4]
                                << " discount=" << discounts[i6]
                                << " stddev=" << stdDevs[i5]
                                << " result=" << iStdDev
                                << " exceeds maximum error tolerance");
                    }
                }
            }
        }
    }
}
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/functions.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Natural i=1; i<171; ++i) {
expected *= i;
calculated = Factorial::get(i);
if (std::fabs(calculated-expected)/expected > 1.0e-9)
    BOOST_FAIL("Factorial(" << i << ")" <<
               std::setprecision(16) << QL_SCIENTIFIC <<
               "\n calculated: " << calculated <<
               "\n   expected: " << expected <<
               "\n rel. error: " <<
               std::fabs(calculated-expected)/expected);
}

for (Size i=2; i<9000; i++) {
expected  += std::log(Real(i));
calculated = GammaFunction().logValue(static_cast<Real>(i+1));
if (std::fabs(calculated-expected)/expected > 1.0e-9)
    BOOST_ERROR("GammaFunction(" << i << ")\n"
                << std::setprecision(16) << QL_SCIENTIFIC
                << "    calculated: " << calculated << "\n"
                << "    expected:   " << expected << "\n"
                << "    rel. error: "
                << std::fabs(calculated-expected)/expected);
}

for (Size i=0; i < LENGTH(tasks); ++i) {
const Real x = tasks[i][0];
const Real expected = tasks[i][1];
const Real calculated = GammaFunction().value(x);
const Real tol = tasks[i][2] * QL_EPSILON*std::fabs(expected);

if (std::fabs(calculated - expected) > tol) {
    BOOST_ERROR("GammaFunction(" << x << ")\n"
                << std::setprecision(16) << QL_SCIENTIFIC
                << "    calculated: " << calculated << "\n"
                << "    expected:   " << expected << "\n"
                << "    rel. error: "
                << std::fabs(calculated-expected)/expected);
}
}

for (Size i=0; i < LENGTH(r); ++i) {
const Real nu = r[i][0];
const Real x  = r[i][1];
const Real expected_i = r[i][2];
const Real expected_k = r[i][3];
const Real tol_i = 5e4 * QL_EPSILON*std::fabs(expected_i);
const Real tol_k = 5e4 * QL_EPSILON*std::fabs(expected_k);

const Real calculated_i = modifiedBesselFunction_i(nu, x);
const Real calculated_k = modifiedBesselFunction_k(nu, x);

if (std::fabs(expected_i - calculated_i) > tol_i) {
    BOOST_ERROR("failed to reproduce modified Bessel "
               << "function of first kind"
               << "\n order     : " << nu
               << "\n argument  : " << x
               << "\n calculated: " << calculated_i
               << "\n expected  : " << expected_i);
}
if (std::fabs(expected_k - calculated_k) > tol_k) {
    BOOST_ERROR("failed to reproduce modified Bessel "
               << "function of second kind"
               << "\n order     : " << nu
               << "\n argument  : " << x
               << "\n calculated: " << calculated_k
               << "\n expected  : " << expected_k);
}
}

for (Size i=0; i < LENGTH(c); ++i) {
const Real nu = c[i][0];
const std::complex<Real> z  = std::complex<Real>(c[i][1], c[i][2]);
const std::complex<Real> expected_i
    = std::complex<Real>(c[i][3],c[i][4]);
const std::complex<Real> expected_k
    = std::complex<Real>(c[i][5],c[i][6]);

const Real tol_i = 5e4*QL_EPSILON*std::abs(expected_i);
const Real tol_k = 1e6*QL_EPSILON*std::abs(expected_k);

const std::complex<Real> calculated_i=modifiedBesselFunction_i(nu, z);
const std::complex<Real> calculated_k=modifiedBesselFunction_k(nu, z);

if (std::abs(expected_i - calculated_i) > tol_i) {
    BOOST_ERROR("failed to reproduce modified Bessel "
               << "function of first kind"
               << "\n order     : " << nu
               << "\n argument  : " << z
               << "\n calculated: " << calculated_i
               << "\n expected  : " << expected_i);
}
if (   std::abs(expected_k) > 1e-4 // do not check small values
    && std::abs(expected_k - calculated_k) > tol_k) {
    BOOST_ERROR("failed to reproduce modified Bessel "
               << "function of second kind"
               << "\n order     : " << nu
               << "\n argument  : " << z
               << "\n diff      : " << calculated_k-expected_k
               << "\n calculated: " << calculated_k
               << "\n expected  : " << expected_k);
}
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/forwardoption.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i<LENGTH(values); i++) {

boost::shared_ptr<StrikedTypePayoff> payoff(
                         new PlainVanillaPayoff(values[i].type, 0.0));
Date exDate = today + Integer(values[i].t*360+0.5);
boost::shared_ptr<Exercise> exercise(new EuropeanExercise(exDate));
Date reset = today + Integer(values[i].start*360+0.5);

spot ->setValue(values[i].s);
qRate->setValue(values[i].q);
rRate->setValue(values[i].r);
vol  ->setValue(values[i].v);

ForwardVanillaOption option(values[i].moneyness, reset,
                            payoff, exercise);
option.setPricingEngine(engine);

Real calculated = option.NPV();
Real error = std::fabs(calculated-values[i].result);
Real tolerance = 1e-4;
if (error>tolerance) {
    REPORT_FAILURE("value", payoff, exercise, values[i].s,
                   values[i].q, values[i].r, today,
                   values[i].v, values[i].moneyness, reset,
                   values[i].result, calculated,
                   error, tolerance);
}
}

for (Size i=0; i<LENGTH(values); i++) {

boost::shared_ptr<StrikedTypePayoff> payoff(
                         new PlainVanillaPayoff(values[i].type, 0.0));
Date exDate = today + Integer(values[i].t*360+0.5);
boost::shared_ptr<Exercise> exercise(new EuropeanExercise(exDate));
Date reset = today + Integer(values[i].start*360+0.5);

spot ->setValue(values[i].s);
qRate->setValue(values[i].q);
rRate->setValue(values[i].r);
vol  ->setValue(values[i].v);

ForwardVanillaOption option(values[i].moneyness, reset,
                            payoff, exercise);
option.setPricingEngine(engine);

Real calculated = option.NPV();
Real error = std::fabs(calculated-values[i].result);
Real tolerance = 1e-4;
if (error>tolerance) {
    REPORT_FAILURE("value", payoff, exercise, values[i].s,
                   values[i].q, values[i].r, today,
                   values[i].v, values[i].moneyness, reset,
                   values[i].result, calculated,
                   error, tolerance);
}
}

for (Size i=0; i<LENGTH(types); i++) {
  for (Size j=0; j<LENGTH(moneyness); j++) {
    for (Size k=0; k<LENGTH(lengths); k++) {
      for (Size h=0; h<LENGTH(startMonths); h++) {

        Date exDate = today + lengths[k]*Years;
        boost::shared_ptr<Exercise> exercise(
                                        new EuropeanExercise(exDate));

        Date reset = today + startMonths[h]*Months;

        boost::shared_ptr<StrikedTypePayoff> payoff(
                               new PlainVanillaPayoff(types[i], 0.0));

        ForwardVanillaOption option(moneyness[j], reset,
                                    payoff, exercise);
        option.setPricingEngine(engine);

        for (Size l=0; l<LENGTH(underlyings); l++) {
          for (Size m=0; m<LENGTH(qRates); m++) {
            for (Size n=0; n<LENGTH(rRates); n++) {
              for (Size p=0; p<LENGTH(vols); p++) {

                Real u = underlyings[l];
                Rate q = qRates[m],
                     r = rRates[n];
                Volatility v = vols[p];
                spot->setValue(u);
                qRate->setValue(q);
                rRate->setValue(r);
                vol->setValue(v);

                Real value = option.NPV();
                calculated["delta"]   = option.delta();
                calculated["gamma"]   = option.gamma();
                calculated["theta"]   = option.theta();
                calculated["rho"]     = option.rho();
                calculated["divRho"]  = option.dividendRho();
                calculated["vega"]    = option.vega();

                if (value > spot->value()*1.0e-5) {
                  // perturb spot and get delta and gamma
                  Real du = u*1.0e-4;
                  spot->setValue(u+du);
                  Real value_p = option.NPV(),
                       delta_p = option.delta();
                  spot->setValue(u-du);
                  Real value_m = option.NPV(),
                       delta_m = option.delta();
                  spot->setValue(u);
                  expected["delta"] = (value_p - value_m)/(2*du);
                  expected["gamma"] = (delta_p - delta_m)/(2*du);

                  // perturb rates and get rho and dividend rho
                  Spread dr = r*1.0e-4;
                  rRate->setValue(r+dr);
                  value_p = option.NPV();
                  rRate->setValue(r-dr);
                  value_m = option.NPV();
                  rRate->setValue(r);
                  expected["rho"] = (value_p - value_m)/(2*dr);

                  Spread dq = q*1.0e-4;
                  qRate->setValue(q+dq);
                  value_p = option.NPV();
                  qRate->setValue(q-dq);
                  value_m = option.NPV();
                  qRate->setValue(q);
                  expected["divRho"] = (value_p - value_m)/(2*dq);

                  // perturb volatility and get vega
                  Volatility dv = v*1.0e-4;
                  vol->setValue(v+dv);
                  value_p = option.NPV();
                  vol->setValue(v-dv);
                  value_m = option.NPV();
                  vol->setValue(v);
                  expected["vega"] = (value_p - value_m)/(2*dv);

                  // perturb date and get theta
                  Time dT = dc.yearFraction(today-1, today+1);
                  Settings::instance().evaluationDate() = today-1;
                  value_m = option.NPV();
                  Settings::instance().evaluationDate() = today+1;
                  value_p = option.NPV();
                  Settings::instance().evaluationDate() = today;
                  expected["theta"] = (value_p - value_m)/dT;

                  // compare
                  std::map<std::string,Real>::iterator it;
                  for (it = calculated.begin();
                       it != calculated.end(); ++it) {
                      std::string greek = it->first;
                      Real expct = expected  [greek],
                           calcl = calculated[greek],
                           tol   = tolerance [greek];
                      Real error = relativeError(expct,calcl,u);
                      if (error>tol) {
                          REPORT_FAILURE(greek, payoff, exercise,
                                         u, q, r, today, v,
                                         moneyness[j], reset,
                                         expct, calcl, error, tol);
                      }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/asianoptions.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i<fixingDates.size(); i++) {
fixingDates[i] = today + i;
}

for (Size i=0; i<LENGTH(types); i++) {
for (Size j=0; j<LENGTH(strikes); j++) {
for (Size k=0; k<LENGTH(lengths); k++) {

    boost::shared_ptr<EuropeanExercise> maturity(
                      new EuropeanExercise(today + lengths[k]*Years));

    boost::shared_ptr<PlainVanillaPayoff> payoff(
                        new PlainVanillaPayoff(types[i], strikes[j]));

    boost::shared_ptr<PricingEngine> engine(new
         AnalyticContinuousGeometricAveragePriceAsianEngine(process));

    ContinuousAveragingAsianOption option(Average::Geometric,
                                          payoff, maturity);
    option.setPricingEngine(engine);

    Size pastFixings = Null<Size>();
    Real runningAverage = Null<Real>();

    for (Size l=0; l<LENGTH(underlyings); l++) {
      for (Size m=0; m<LENGTH(qRates); m++) {
        for (Size n=0; n<LENGTH(rRates); n++) {
          for (Size p=0; p<LENGTH(vols); p++) {

              Real u = underlyings[l];
              Rate q = qRates[m],
                   r = rRates[n];
              Volatility v = vols[p];
              spot->setValue(u);
              qRate->setValue(q);
              rRate->setValue(r);
              vol->setValue(v);

              Real value = option.NPV();
              calculated["delta"]  = option.delta();
              calculated["gamma"]  = option.gamma();
              calculated["theta"]  = option.theta();
              calculated["rho"]    = option.rho();
              calculated["divRho"] = option.dividendRho();
              calculated["vega"]   = option.vega();

              if (value > spot->value()*1.0e-5) {
                  // perturb spot and get delta and gamma
                  Real du = u*1.0e-4;
                  spot->setValue(u+du);
                  Real value_p = option.NPV(),
                       delta_p = option.delta();
                  spot->setValue(u-du);
                  Real value_m = option.NPV(),
                       delta_m = option.delta();
                  spot->setValue(u);
                  expected["delta"] = (value_p - value_m)/(2*du);
                  expected["gamma"] = (delta_p - delta_m)/(2*du);

                  // perturb rates and get rho and dividend rho
                  Spread dr = r*1.0e-4;
                  rRate->setValue(r+dr);
                  value_p = option.NPV();
                  rRate->setValue(r-dr);
                  value_m = option.NPV();
                  rRate->setValue(r);
                  expected["rho"] = (value_p - value_m)/(2*dr);

                  Spread dq = q*1.0e-4;
                  qRate->setValue(q+dq);
                  value_p = option.NPV();
                  qRate->setValue(q-dq);
                  value_m = option.NPV();
                  qRate->setValue(q);
                  expected["divRho"] = (value_p - value_m)/(2*dq);

                  // perturb volatility and get vega
                  Volatility dv = v*1.0e-4;
                  vol->setValue(v+dv);
                  value_p = option.NPV();
                  vol->setValue(v-dv);
                  value_m = option.NPV();
                  vol->setValue(v);
                  expected["vega"] = (value_p - value_m)/(2*dv);

                  // perturb date and get theta
                  Time dT = dc.yearFraction(today-1, today+1);
                  Settings::instance().evaluationDate() = today-1;
                  value_m = option.NPV();
                  Settings::instance().evaluationDate() = today+1;
                  value_p = option.NPV();
                  Settings::instance().evaluationDate() = today;
                  expected["theta"] = (value_p - value_m)/dT;

                  // compare
                  std::map<std::string,Real>::iterator it;
                  for (it = calculated.begin();
                       it != calculated.end(); ++it) {
                      std::string greek = it->first;
                      Real expct = expected  [greek],
                           calcl = calculated[greek],
                           tol   = tolerance [greek];
                      Real error = relativeError(expct,calcl,u);
                      if (error>tol) {
                          REPORT_FAILURE(greek, Average::Geometric,
                                         runningAverage, pastFixings,
                                         std::vector<Date>(),
                                         payoff, maturity,
                                         u, q, r, today, v,
                                         expct, calcl, tol);
                      }
                  }
              }
          }
        }
      }
    }
}
}
}

for (Size j=1; j<futureFixings; j++)
fixingDates[j] = fixingDates[j-1] + dt;

for (Size j=1; j<futureFixings; j++)
fixingDates[j] = fixingDates[j-1] + dt;

for (Size j=1; j<futureFixings; j++)
fixingDates[j] = fixingDates[j-1] + dt;

for (Size l=0; l<LENGTH(cases4); l++) {

boost::shared_ptr<StrikedTypePayoff> payoff(new
    PlainVanillaPayoff(cases4[l].type, cases4[l].strike));

Time dt = cases4[l].length/(cases4[l].fixings-1);
std::vector<Time> timeIncrements(cases4[l].fixings);
std::vector<Date> fixingDates(cases4[l].fixings);
timeIncrements[0] = cases4[l].first;
fixingDates[0] = today + Integer(timeIncrements[0]*360+0.5);
for (Size i=1; i<cases4[l].fixings; i++) {
    timeIncrements[i] = i*dt + cases4[l].first;
    fixingDates[i] = today + Integer(timeIncrements[i]*360+0.5);
}
boost::shared_ptr<Exercise> exercise(new
    EuropeanExercise(fixingDates[cases4[l].fixings-1]));

spot ->setValue(cases4[l].underlying);
qRate->setValue(cases4[l].dividendYield);
rRate->setValue(cases4[l].riskFreeRate);
vol  ->setValue(cases4[l].volatility);

boost::shared_ptr<BlackScholesMertonProcess> stochProcess(new
    BlackScholesMertonProcess(Handle<Quote>(spot),
                              Handle<YieldTermStructure>(qTS),
                              Handle<YieldTermStructure>(rTS),
                              Handle<BlackVolTermStructure>(volTS)));


boost::shared_ptr<PricingEngine> engine =
    MakeMCDiscreteArithmeticAPEngine<LowDiscrepancy>(stochProcess)
    .withSamples(2047)
    .withControlVariate();

DiscreteAveragingAsianOption option(averageType, runningSum,
                                    pastFixings, fixingDates,
                                    payoff, exercise);
option.setPricingEngine(engine);

Real calculated = option.NPV();
Real expected = cases4[l].result;
Real tolerance = 2.0e-2;
if (std::fabs(calculated-expected) > tolerance) {
    REPORT_FAILURE("value", averageType, runningSum, pastFixings,
                fixingDates, payoff, exercise, spot->value(),
                qRate->value(), rRate->value(), today,
                vol->value(), expected, calculated, tolerance);
}

if(cases4[l].fixings < 100) {
    engine = boost::shared_ptr<PricingEngine>(
            new FdBlackScholesAsianEngine(stochProcess, 100, 100, 100));
    option.setPricingEngine(engine);
    calculated = option.NPV();
    if (std::fabs(calculated-expected) > tolerance) {
        REPORT_FAILURE("value", averageType, runningSum, pastFixings,
                    fixingDates, payoff, exercise, spot->value(),
                    qRate->value(), rRate->value(), today,
                    vol->value(), expected, calculated, tolerance);
    }
}
}

for (Size l=0; l<LENGTH(cases5); l++) {

boost::shared_ptr<StrikedTypePayoff> payoff(new
    PlainVanillaPayoff(cases5[l].type, cases5[l].strike));

Time dt = cases5[l].length/(cases5[l].fixings-1);
std::vector<Time> timeIncrements(cases5[l].fixings);
std::vector<Date> fixingDates(cases5[l].fixings);
timeIncrements[0] = cases5[l].first;
fixingDates[0] = today + Integer(timeIncrements[0]*360+0.5);
for (Size i=1; i<cases5[l].fixings; i++) {
    timeIncrements[i] = i*dt + cases5[l].first;
    fixingDates[i] = today + Integer(timeIncrements[i]*360+0.5);
}
boost::shared_ptr<Exercise> exercise(new
    EuropeanExercise(fixingDates[cases5[l].fixings-1]));

spot ->setValue(cases5[l].underlying);
qRate->setValue(cases5[l].dividendYield);
rRate->setValue(cases5[l].riskFreeRate);
vol  ->setValue(cases5[l].volatility);

boost::shared_ptr<BlackScholesMertonProcess> stochProcess(new
    BlackScholesMertonProcess(Handle<Quote>(spot),
                              Handle<YieldTermStructure>(qTS),
                              Handle<YieldTermStructure>(rTS),
                              Handle<BlackVolTermStructure>(volTS)));

boost::shared_ptr<PricingEngine> engine =
    MakeMCDiscreteArithmeticASEngine<LowDiscrepancy>(stochProcess)
    .withSeed(3456789)
    .withSamples(1023);

DiscreteAveragingAsianOption option(averageType, runningSum,
                                    pastFixings, fixingDates,
                                    payoff, exercise);
option.setPricingEngine(engine);

Real calculated = option.NPV();
Real expected = cases5[l].result;
Real tolerance = 2.0e-2;
if (std::fabs(calculated-expected) > tolerance) {
    REPORT_FAILURE("value", averageType, runningSum, pastFixings,
                   fixingDates, payoff, exercise, spot->value(),
                   qRate->value(), rRate->value(), today,
                   vol->value(), expected, calculated, tolerance);
}
}

for (Size i=0; i<LENGTH(types); i++) {
for (Size j=0; j<LENGTH(strikes); j++) {
for (Size k=0; k<LENGTH(lengths); k++) {

    boost::shared_ptr<EuropeanExercise> maturity(
                      new EuropeanExercise(today + lengths[k]*Years));

    boost::shared_ptr<PlainVanillaPayoff> payoff(
                        new PlainVanillaPayoff(types[i], strikes[j]));

    Real runningAverage = 120;
    Size pastFixings = 1;

    std::vector<Date> fixingDates;
    for (Date d = today + 3*Months;
              d <= maturity->lastDate();
              d += 3*Months)
        fixingDates.push_back(d);


    boost::shared_ptr<PricingEngine> engine(
       new AnalyticDiscreteGeometricAveragePriceAsianEngine(process));

    DiscreteAveragingAsianOption option(Average::Geometric,
                                        runningAverage, pastFixings,
                                        fixingDates, payoff, maturity);
    option.setPricingEngine(engine);

    for (Size l=0; l<LENGTH(underlyings); l++) {
      for (Size m=0; m<LENGTH(qRates); m++) {
        for (Size n=0; n<LENGTH(rRates); n++) {
          for (Size p=0; p<LENGTH(vols); p++) {

              Real u = underlyings[l];
              Rate q = qRates[m],
                   r = rRates[n];
              Volatility v = vols[p];
              spot->setValue(u);
              qRate->setValue(q);
              rRate->setValue(r);
              vol->setValue(v);

              Real value = option.NPV();
              calculated["delta"]  = option.delta();
              calculated["gamma"]  = option.gamma();
              calculated["theta"]  = option.theta();
              calculated["rho"]    = option.rho();
              calculated["divRho"] = option.dividendRho();
              calculated["vega"]   = option.vega();

              if (value > spot->value()*1.0e-5) {
                  // perturb spot and get delta and gamma
                  Real du = u*1.0e-4;
                  spot->setValue(u+du);
                  Real value_p = option.NPV(),
                       delta_p = option.delta();
                  spot->setValue(u-du);
                  Real value_m = option.NPV(),
                       delta_m = option.delta();
                  spot->setValue(u);
                  expected["delta"] = (value_p - value_m)/(2*du);
                  expected["gamma"] = (delta_p - delta_m)/(2*du);

                  // perturb rates and get rho and dividend rho
                  Spread dr = r*1.0e-4;
                  rRate->setValue(r+dr);
                  value_p = option.NPV();
                  rRate->setValue(r-dr);
                  value_m = option.NPV();
                  rRate->setValue(r);
                  expected["rho"] = (value_p - value_m)/(2*dr);

                  Spread dq = q*1.0e-4;
                  qRate->setValue(q+dq);
                  value_p = option.NPV();
                  qRate->setValue(q-dq);
                  value_m = option.NPV();
                  qRate->setValue(q);
                  expected["divRho"] = (value_p - value_m)/(2*dq);

                  // perturb volatility and get vega
                  Volatility dv = v*1.0e-4;
                  vol->setValue(v+dv);
                  value_p = option.NPV();
                  vol->setValue(v-dv);
                  value_m = option.NPV();
                  vol->setValue(v);
                  expected["vega"] = (value_p - value_m)/(2*dv);

                  // perturb date and get theta
                  Time dT = dc.yearFraction(today-1, today+1);
                  Settings::instance().evaluationDate() = today-1;
                  value_m = option.NPV();
                  Settings::instance().evaluationDate() = today+1;
                  value_p = option.NPV();
                  Settings::instance().evaluationDate() = today;
                  expected["theta"] = (value_p - value_m)/dT;

                  // compare
                  std::map<std::string,Real>::iterator it;
                  for (it = calculated.begin();
                       it != calculated.end(); ++it) {
                      std::string greek = it->first;
                      Real expct = expected  [greek],
                           calcl = calculated[greek],
                           tol   = tolerance [greek];
                      Real error = relativeError(expct,calcl,u);
                      if (error>tol) {
                          REPORT_FAILURE(greek, Average::Geometric,
                                         runningAverage, pastFixings,
                                         std::vector<Date>(),
                                         payoff, maturity,
                                         u, q, r, today, v,
                                         expct, calcl, tol);
                      }
                  }
              }
          }
        }
      }
    }
}
}
}

for (Integer i=0; i<=12; ++i)
fixingDates1.push_back(today + i*Months);

for (Integer i=-2; i<=12; ++i)
fixingDates2.push_back(today + i*Months);

for (Size l=0; l<LENGTH(cases); l++) {

boost::shared_ptr<SimpleQuote> spot(new SimpleQuote(cases[l].spot));
boost::shared_ptr<YieldTermStructure> qTS =
    flatRate(today, cases[l].dividendYield, dc);
boost::shared_ptr<YieldTermStructure> rTS =
    flatRate(today, cases[l].riskFreeRate, dc);
boost::shared_ptr<BlackVolTermStructure> volTS =
    flatVol(today, cases[l].volatility, dc);

Average::Type averageType = Average::Arithmetic;
boost::shared_ptr<Quote> average(
                            new SimpleQuote(cases[l].currentAverage));

boost::shared_ptr<StrikedTypePayoff> payoff(
              new PlainVanillaPayoff(cases[l].type, cases[l].strike));

Date startDate = today - cases[l].elapsed;
Date maturity = startDate + cases[l].length;

boost::shared_ptr<Exercise> exercise(new EuropeanExercise(maturity));

boost::shared_ptr<BlackScholesMertonProcess> stochProcess(new
    BlackScholesMertonProcess(Handle<Quote>(spot),
                              Handle<YieldTermStructure>(qTS),
                              Handle<YieldTermStructure>(rTS),
                              Handle<BlackVolTermStructure>(volTS)));

boost::shared_ptr<PricingEngine> engine(
    new ContinuousArithmeticAsianLevyEngine(
             stochProcess, Handle<Quote>(average), startDate));

ContinuousAveragingAsianOption option(averageType,
                                      payoff, exercise);
option.setPricingEngine(engine);

Real calculated = option.NPV();
Real expected = cases[l].result;
Real tolerance = 1.0e-4;
Real error = std::fabs(expected-calculated);
if (error > tolerance) {
    BOOST_ERROR("Asian option with Levy engine:"
                << "\n    spot:            " << cases[l].spot
                << "\n    current average: " << cases[l].currentAverage
                << "\n    strike:          " << cases[l].strike
                << "\n    dividend yield:  " << cases[l].dividendYield
                << "\n    risk-free rate:  " << cases[l].riskFreeRate
                << "\n    volatility:      " << cases[l].volatility
                << "\n    reference date:  " << today
                << "\n    length:          " << cases[l].length
                << "\n    elapsed:         " << cases[l].elapsed
                << "\n    expected value:  " << expected
                << "\n    calculated:      " << calculated
                << "\n    error:           " << error);
}
}

for (Size i=0; i<LENGTH(cases); ++i) {
Handle<Quote> u(boost::make_shared<SimpleQuote>(cases[i].spot));
Handle<YieldTermStructure> r(flatRate(today,
                                      cases[i].riskFreeRate,
                                      dayCounter));
Handle<BlackVolTermStructure> sigma(flatVol(today,
                                            cases[i].volatility,
                                            dayCounter));
boost::shared_ptr<BlackScholesMertonProcess> process =
    boost::make_shared<BlackScholesMertonProcess>(u, q, r, sigma);

Date maturity = today + cases[i].length*360;
boost::shared_ptr<Exercise> exercise =
    boost::make_shared<EuropeanExercise>(maturity);
boost::shared_ptr<StrikedTypePayoff> payoff =
    boost::make_shared<PlainVanillaPayoff>(type, cases[i].strike);
Handle<Quote> average(boost::make_shared<SimpleQuote>(0.0));

ContinuousAveragingAsianOption option(Average::Arithmetic,
                                      payoff, exercise);
option.setPricingEngine(
    boost::make_shared<ContinuousArithmeticAsianVecerEngine>(
        process,average,today,timeSteps,assetSteps,-1.0,1.0));

Real calculated = option.NPV();
Real error = std::fabs(calculated - cases[i].result);
if (error > cases[i].tolerance)
    BOOST_ERROR("Failed to reproduce expected NPV"
                << "\n    calculated: " << calculated
                << "\n    expected:   " << cases[i].result
                << "\n    expected:   " << cases[i].result
                << "\n    error:      " << error
                << "\n    tolerance:  " << cases[i].tolerance);
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/defaultprobabilitycurves.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for(Size i=0; i<n; i++){
startDate = endDate;
endDate = calendar.advance(endDate, 1, Years);

Probability pStart = flatHazardRate.defaultProbability(startDate);
Probability pEnd = flatHazardRate.defaultProbability(endDate);

Probability pBetweenComputed =
    flatHazardRate.defaultProbability(startDate, endDate);

Probability pBetween = pEnd - pStart;

if (std::fabs(pBetween - pBetweenComputed) > tolerance)
    BOOST_ERROR(
        "Failed to reproduce probability(d1, d2) "
        << "for default probability structure\n"
        << std::setprecision(12)
        << "    calculated probability: " << pBetweenComputed << "\n"
        << "    expected probability:   " << pBetween);

Time t2 = dayCounter.yearFraction(today, endDate);
Probability timeProbability = flatHazardRate.defaultProbability(t2);
Probability dateProbability =
    flatHazardRate.defaultProbability(endDate);

if (std::fabs(timeProbability - dateProbability) > tolerance)
    BOOST_ERROR(
        "single-time probability and single-date probability do not match\n"
        << std::setprecision(10)
        << "    time probability: " << timeProbability << "\n"
        << "    date probability: " << dateProbability);

Time t1 = dayCounter.yearFraction(today, startDate);
timeProbability = flatHazardRate.defaultProbability(t1, t2);
dateProbability = flatHazardRate.defaultProbability(startDate, endDate);

if (std::fabs(timeProbability - dateProbability) > tolerance)
    BOOST_ERROR(
        "double-time probability and double-date probability do not match\n"
        << std::setprecision(10)
        << "    time probability: " << timeProbability << "\n"
        << "    date probability: " << dateProbability);
}

for(Size i=0; i<n; i++){
endDate = calendar.advance(endDate, 1, Years);
Time t = dayCounter.yearFraction(startDate, endDate);
Probability probability = 1.0 - std::exp(-hazardRate * t);
Probability computedProbability = flatHazardRate.defaultProbability(t);

if (std::fabs(probability - computedProbability) > tolerance)
    BOOST_ERROR(
        "Failed to reproduce probability for flat hazard rate\n"
        << std::setprecision(10)
        << "    calculated probability: " << computedProbability << "\n"
        << "    expected probability:   " << probability);
}

for(Size i=0; i<n.size(); i++)
    helpers.push_back(
        boost::shared_ptr<DefaultProbabilityHelper>(
            new SpreadCdsHelper(quote[i], Period(n[i], Years),
                                settlementDays, calendar,
                                frequency, convention, rule,
                                dayCounter, recoveryRate,
                                discountCurve)));

for (Size i=0; i<n.size(); i++) {
    Date protectionStart = today + settlementDays;
    Date startDate = calendar.adjust(protectionStart, convention);
    Date endDate = today + n[i]*Years;

    Schedule schedule(startDate, endDate, Period(frequency), calendar,
                      convention, Unadjusted, rule, false);

    CreditDefaultSwap cds(Protection::Buyer, notional, quote[i],
                          schedule, convention, dayCounter,
                          true, true, protectionStart);
    cds.setPricingEngine(boost::shared_ptr<PricingEngine>(
                   new MidPointCdsEngine(piecewiseCurve, recoveryRate,
                                         discountCurve)));

    // test
    Rate inputRate = quote[i];
    Rate computedRate = cds.fairSpread();
    if (std::fabs(inputRate - computedRate) > tolerance)
        BOOST_ERROR(
            "\nFailed to reproduce fair spread for " << n[i] <<
            "Y credit-default swaps\n"
            << std::setprecision(10)
            << "    computed rate: " << io::rate(computedRate) << "\n"
            << "    input rate:    " << io::rate(inputRate));
}

for(Size i=0; i<n.size(); i++)
    helpers.push_back(
        boost::shared_ptr<DefaultProbabilityHelper>(
            new UpfrontCdsHelper(quote[i], fixedRate,
                                 Period(n[i], Years),
                                 settlementDays, calendar,
                                 frequency, convention, rule,
                                 dayCounter, recoveryRate,
                                 discountCurve)));

for (Size i=0; i<n.size(); i++) {
    Date protectionStart = today + settlementDays;
    Date startDate = calendar.adjust(protectionStart, convention);
    Date endDate = today + n[i]*Years;

    Schedule schedule(startDate, endDate, Period(frequency), calendar,
                      convention, Unadjusted, rule, false);

    CreditDefaultSwap cds(Protection::Buyer, notional,
                          quote[i], fixedRate,
                          schedule, convention, dayCounter,
                          true, true, protectionStart);
    cds.setPricingEngine(boost::shared_ptr<PricingEngine>(
                   new MidPointCdsEngine(piecewiseCurve, recoveryRate,
                                         discountCurve, true)));

    // test
    Rate inputUpfront = quote[i];
    Rate computedUpfront = cds.fairUpfront();
    if (std::fabs(inputUpfront - computedUpfront) > tolerance)
        BOOST_ERROR(
            "\nFailed to reproduce fair upfront for " << n[i] <<
            "Y credit-default swaps\n"
            << std::setprecision(10)
            << "    computed: " << io::rate(computedUpfront) << "\n"
            << "    expected: " << io::rate(inputUpfront));
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/schedule.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i<expected.size(); ++i) {
    if (s[i] != expected[i]) {
        BOOST_ERROR("expected " << expected[i]
                    << " at index " << i << ", "
                    "found " << s[i]);
    }
}

for (Size i = 0; i < dates.size(); ++i)
if (schedule1[i] != dates[i])
    BOOST_ERROR("schedule1 has " << schedule1[i] << " at position " << i
                                 << ", expected " << dates[i]);

for (Size i = 1; i < dates.size(); ++i)
if (schedule2.isRegular(i) != regular[i - 1])
    BOOST_ERROR("schedule2 has a "
                << (schedule2.isRegular(i) ? "regular" : "irregular")
                << " period at position " << i << ", expected "
                << (regular[i - 1] ? "regular" : "irregular"));

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/rounding.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i<LENGTH(testData); i++) {
Integer digits = testData[i].precision;
ClosestRounding closest(digits);
Real calculated = closest(testData[i].x);
Real expected = testData[i].closest;
if (!close(calculated,expected,1))
    BOOST_ERROR(QL_FIXED << std::setprecision(8)
                << "Original number: " << testData[i].x << "\n"
                << std::setprecision(digits)
                << "Expected:        " << expected << "\n"
                << "Calculated:      " << calculated);
}

for (Size i=0; i<LENGTH(testData); i++) {
Integer digits = testData[i].precision;
UpRounding up(digits);
Real calculated = up(testData[i].x);
Real expected = testData[i].up;
if (!close(calculated,expected,1))
    BOOST_ERROR(QL_FIXED << std::setprecision(8)
                << "Original number: " << testData[i].x << "\n"
                << std::setprecision(digits)
                << "Expected:        " << expected << "\n"
                << "Calculated:      " << calculated);
}

for (Size i=0; i<LENGTH(testData); i++) {
Integer digits = testData[i].precision;
DownRounding down(digits);
Real calculated = down(testData[i].x);
Real expected = testData[i].down;
if (!close(calculated,expected,1))
    BOOST_ERROR(QL_FIXED << std::setprecision(8)
                << "Original number: " << testData[i].x << "\n"
                << std::setprecision(digits)
                << "Expected:        " << expected << "\n"
                << "Calculated:      " << calculated);
}

for (Size i=0; i<LENGTH(testData); i++) {
Integer digits = testData[i].precision;
FloorTruncation floor(digits);
Real calculated = floor(testData[i].x);
Real expected = testData[i].floor;
if (!close(calculated,expected,1))
    BOOST_ERROR(QL_FIXED << std::setprecision(8)
                << "Original number: " << testData[i].x << "\n"
                << std::setprecision(digits)
                << "Expected:        " << expected << "\n"
                << "Calculated:      " << calculated);
}

for (Size i=0; i<LENGTH(testData); i++) {
Integer digits = testData[i].precision;
CeilingTruncation ceiling(digits);
Real calculated = ceiling(testData[i].x);
Real expected = testData[i].ceiling;
if (!close(calculated,expected,1))
    BOOST_ERROR(QL_FIXED << std::setprecision(8)
                << "Original number: " << testData[i].x << "\n"
                << std::setprecision(digits)
                << "Expected:        " << expected << "\n"
                << "Calculated:      " << calculated);
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/bonds.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i<LENGTH(issueMonths); i++) {
for (Size j=0; j<LENGTH(lengths); j++) {
for (Size k=0; k<LENGTH(coupons); k++) {
  for (Size l=0; l<LENGTH(frequencies); l++) {
    for (Size n=0; n<LENGTH(compounding); n++) {

      Date dated = vars.calendar.advance(vars.today,
                                         issueMonths[i], Months);
      Date issue = dated;
      Date maturity = vars.calendar.advance(issue,
                                            lengths[j], Years);

      Schedule sch(dated, maturity,
                   Period(frequencies[l]), vars.calendar,
                   accrualConvention, accrualConvention,
                   DateGeneration::Backward, false);

      FixedRateBond bond(settlementDays, vars.faceAmount, sch,
                         std::vector<Rate>(1, coupons[k]),
                         bondDayCount, paymentConvention,
                         redemption, issue);

      for (Size m=0; m<LENGTH(yields); m++) {

        Real price = BondFunctions::cleanPrice(bond, yields[m],
                                         bondDayCount,
                                         compounding[n],
                                         frequencies[l]);
        Rate calculated = BondFunctions::yield(bond, price,
                                     bondDayCount, compounding[n],
                                     frequencies[l],
                                     Date(),
                                     tolerance, maxEvaluations);

        if (std::fabs(yields[m]-calculated) > tolerance) {
          // the difference might not matter
          Real price2 = BondFunctions::cleanPrice(bond, calculated,
                                            bondDayCount,
                                            compounding[n],
                                            frequencies[l]);
          if (std::fabs(price-price2)/price > tolerance) {
              BOOST_FAIL("\nyield recalculation failed:"
                  "\n    issue:     " << issue <<
                  "\n    maturity:  " << maturity <<
                  "\n    coupon:    " << io::rate(coupons[k]) <<
                  "\n    frequency: " << frequencies[l] <<
                  "\n    yield:   " << io::rate(yields[m]) <<
                  (compounding[n] == Compounded ?
                        " compounded" : " continuous") <<
                  std::setprecision(7) <<
                  "\n    price:   " << price <<
                  "\n    yield': " << io::rate(calculated) <<
                  "\n    price': " << price2);
          }
        }
      }
    }
  }
}
}
}

for (Size i=0; i<LENGTH(issueMonths); i++) {
for (Size j=0; j<LENGTH(lengths); j++) {
for (Size k=0; k<LENGTH(coupons); k++) {
  for (Size l=0; l<LENGTH(frequencies); l++) {
    Date dated = vars.calendar.advance(vars.today,
                                       issueMonths[i], Months);
    Date issue = dated;
    Date maturity = vars.calendar.advance(issue,
                                          lengths[j], Years);

    Schedule sch(dated, maturity,
                 Period(frequencies[l]), vars.calendar,
                 accrualConvention, accrualConvention,
                 DateGeneration::Backward, false);

    FixedRateBond bond(settlementDays, vars.faceAmount, sch,
                     std::vector<Rate>(1, coupons[k]),
                     bondDayCount, paymentConvention,
                     redemption, issue);

    bond.setPricingEngine(bondEngine);
    Real price = bond.cleanPrice();
    Rate calculated = BondFunctions::atmRate(bond,
                                             **disc,
                                             bond.settlementDate(),
                                             price);

    if (std::fabs(coupons[k]-calculated) > tolerance) {
          BOOST_FAIL("\natm rate recalculation failed:"
              "\n today:           " << vars.today <<
              "\n settlement date: " << bond.settlementDate() <<
              "\n issue:           " << issue <<
              "\n maturity:        " << maturity <<
              "\n coupon:          " << io::rate(coupons[k]) <<
              "\n frequency:       " << frequencies[l] <<
              "\n clean price:     " << price <<
              "\n dirty price:     " << price + bond.accruedAmount() <<
              "\n atm rate:        " << io::rate(calculated));
    }
  }
}
}
}

for (Size i=0; i<LENGTH(issueMonths); i++) {
for (Size j=0; j<LENGTH(lengths); j++) {
for (Size k=0; k<LENGTH(coupons); k++) {
  for (Size l=0; l<LENGTH(frequencies); l++) {
    for (Size n=0; n<LENGTH(compounding); n++) {

      Date dated = vars.calendar.advance(vars.today,
                                         issueMonths[i], Months);
      Date issue = dated;
      Date maturity = vars.calendar.advance(issue,
                                            lengths[j], Years);

      Schedule sch(dated, maturity,
                   Period(frequencies[l]), vars.calendar,
                   accrualConvention, accrualConvention,
                   DateGeneration::Backward, false);

      FixedRateBond bond(settlementDays, vars.faceAmount, sch,
                         std::vector<Rate>(1, coupons[k]),
                         bondDayCount, paymentConvention,
                         redemption, issue);

      for (Size m=0; m<LENGTH(spreads); m++) {

        Real price = BondFunctions::cleanPrice(bond, *discountCurve,
                                           spreads[m],
                                           bondDayCount,
                                           compounding[n],
                                           frequencies[l]);
        Spread calculated = BondFunctions::zSpread(bond, price,
                                                   *discountCurve,
                                                   bondDayCount,
                                                   compounding[n],
                                                   frequencies[l],
                                                   Date(),
                                                   tolerance,
                                                   maxEvaluations);

        if (std::fabs(spreads[m]-calculated) > tolerance) {
          // the difference might not matter
          Real price2 = BondFunctions::cleanPrice(bond, *discountCurve,
                                              calculated,
                                              bondDayCount,
                                              compounding[n],
                                              frequencies[l]);
          if (std::fabs(price-price2)/price > tolerance) {
              BOOST_FAIL("\nZ-spread recalculation failed:"
                  "\n    issue:     " << issue <<
                  "\n    maturity:  " << maturity <<
                  "\n    coupon:    " << io::rate(coupons[k]) <<
                  "\n    frequency: " << frequencies[l] <<
                  "\n    Z-spread:  " << io::rate(spreads[m]) <<
                  (compounding[n] == Compounded ?
                        " compounded" : " continuous") <<
                  std::setprecision(7) <<
                  "\n    price:     " << price <<
                  "\n    Z-spread': " << io::rate(calculated) <<
                  "\n    price':    " << price2);
          }
        }
      }
    }
  }
}
}
}

for (Size j=0; j<LENGTH(lengths); j++) {
for (Size k=0; k<LENGTH(coupons); k++) {
for (Size l=0; l<LENGTH(frequencies); l++) {

    Date dated = vars.today;
    Date issue = dated;
    Date maturity = vars.calendar.advance(issue, lengths[j], Years);

    shared_ptr<SimpleQuote> rate(new SimpleQuote(0.0));
    Handle<YieldTermStructure> discountCurve(flatRate(vars.today,
                                                      rate,
                                                      bondDayCount));

    Schedule sch(dated, maturity,
                 Period(frequencies[l]), vars.calendar,
                 accrualConvention, accrualConvention,
                 DateGeneration::Backward, false);

    FixedRateBond bond(settlementDays, vars.faceAmount, sch,
                       std::vector<Rate>(1, coupons[k]),
                       bondDayCount, paymentConvention,
                       redemption, issue);

    shared_ptr<PricingEngine> bondEngine(
                            new DiscountingBondEngine(discountCurve));
    bond.setPricingEngine(bondEngine);

    for (Size m=0; m<LENGTH(yields); m++) {

        rate->setValue(yields[m]);

        Real price = BondFunctions::cleanPrice(bond, yields[m],
                                         bondDayCount, Continuous,
                                         frequencies[l]);
        Real calculatedPrice = bond.cleanPrice();

        if (std::fabs(price-calculatedPrice) > tolerance) {
            BOOST_FAIL("price calculation failed:" <<
                "\n    issue:     " << issue <<
                "\n    maturity:  " << maturity <<
                "\n    coupon:    " << io::rate(coupons[k]) <<
                "\n    frequency: " << frequencies[l] <<
                "\n    yield:  " << io::rate(yields[m]) <<
                std::setprecision(7) <<
                "\n    expected:    " << price <<
                "\n    calculated': " << calculatedPrice <<
                "\n    error':      " << price-calculatedPrice);
        }

        Rate calculatedYield = BondFunctions::yield(bond, calculatedPrice,
            bondDayCount, Continuous, frequencies[l],
            bond.settlementDate(),
            tolerance, maxEvaluations);
        if (std::fabs(yields[m]-calculatedYield) > tolerance) {
            BOOST_FAIL("yield calculation failed:" <<
                "\n    issue:     " << issue <<
                "\n    maturity:  " << maturity <<
                "\n    coupon:    " << io::rate(coupons[k]) <<
                "\n    frequency: " << frequencies[l] <<
                "\n    yield:  " << io::rate(yields[m]) <<
                std::setprecision(7) <<
                "\n    price:  " << price <<
                "\n    yield': " << io::rate(calculatedYield));
        }
    }
}
}
}

for (Size bondIndex = 0; bondIndex < maturityDates.size(); bondIndex++) {

InterestRate yield(yields[bondIndex],
                   Business252(Brazil()),
                   Compounded, Annual);

Schedule schedule(Date(1,January,2007),
                  maturityDates[bondIndex], Period(Semiannual),
                  Brazil(Brazil::Settlement),
                  Unadjusted, Unadjusted,
                  DateGeneration::Backward, false);

FixedRateBond bond(settlementDays,
    faceAmount,
    schedule,
    couponRates,
    Following,
    redemption,
    issueDate);

Real cachedPrice = prices[bondIndex];
Real price = faceAmount *
    (BondFunctions::cleanPrice(bond, yield.rate(), yield.dayCounter(),
                         yield.compounding(), yield.frequency(),
                         today) + bond.accruedAmount(today)) / 100.0;

if (std::fabs(price-cachedPrice) > tolerance) {
    BOOST_ERROR("failed to reproduce Andima cached price:\n"
                << QL_FIXED
                << "    calculated: " << price << "\n"
                << "    expected:   " << cachedPrice << "\n"
                << "    error:      " << price-cachedPrice  << "\n"
                );
}
}

for (Size i=0; i<LENGTH(cases); ++i) {
Real accrued = bond.accruedAmount(cases[i].settlementDate);
ASSERT_CLOSE("accrued amount", cases[i].settlementDate,
             accrued, cases[i].accruedAmount, 1e-6);

Real npv = cases[i].testPrice + accrued;
ASSERT_CLOSE("NPV", cases[i].settlementDate,
             npv, cases[i].NPV, 1e-6);

Rate yield = CashFlows::yield(leg, npv, dc, comp, freq,
                              false, cases[i].settlementDate);
ASSERT_CLOSE("yield", cases[i].settlementDate,
             yield, cases[i].yield, 1e-6);

Time duration = CashFlows::duration(leg, yield, dc, comp, freq,
                                    Duration::Modified, false,
                                    cases[i].settlementDate);
ASSERT_CLOSE("duration", cases[i].settlementDate,
             duration, cases[i].duration, 1e-6);

Real convexity = CashFlows::convexity(leg, yield, dc, comp, freq,
                                      false, cases[i].settlementDate);
ASSERT_CLOSE("convexity", cases[i].settlementDate,
             convexity, cases[i].convexity, 1e-6);

Real calcnpv = CashFlows::npv(leg, yield, dc, comp, freq,
                              false, cases[i].settlementDate);
ASSERT_CLOSE("NPV from yield", cases[i].settlementDate,
             calcnpv, cases[i].NPV, 1e-6);

Real calcprice = calcnpv - accrued;
ASSERT_CLOSE("price from yield", cases[i].settlementDate,
             calcprice, cases[i].testPrice, 1e-6);
}

for (Size i=0; i<LENGTH(cases); ++i) {
Real accrued = bond.accruedAmount(cases[i].settlementDate);
ASSERT_CLOSE("accrued amount", cases[i].settlementDate,
             accrued, cases[i].accruedAmount, 1e-3);

Real npv = cases[i].testPrice + accrued;
ASSERT_CLOSE("NPV", cases[i].settlementDate,
             npv, cases[i].NPV, 1e-3);

Rate yield = CashFlows::yield(leg, npv, dc, comp, freq,
                              false, cases[i].settlementDate);
ASSERT_CLOSE("yield", cases[i].settlementDate,
             yield, cases[i].yield, 1e-5);

Time duration = CashFlows::duration(leg, yield, dc, comp, freq,
                                    Duration::Modified, false,
                                    cases[i].settlementDate);
ASSERT_CLOSE("duration", cases[i].settlementDate,
             duration, cases[i].duration, 1e-5);

Real convexity = CashFlows::convexity(leg, yield, dc, comp, freq,
                                      false, cases[i].settlementDate);
ASSERT_CLOSE("convexity", cases[i].settlementDate,
             convexity, cases[i].convexity, 1e-4);

Real calcnpv = CashFlows::npv(leg, yield, dc, comp, freq,
                              false, cases[i].settlementDate);
ASSERT_CLOSE("NPV from yield", cases[i].settlementDate,
             calcnpv, cases[i].NPV, 1e-3);

Real calcprice = calcnpv - accrued;
ASSERT_CLOSE("price from yield", cases[i].settlementDate,
             calcprice, cases[i].testPrice, 1e-3);
}

for (Size i = 0; i < schedule.size(); ++i) {
Date d = schedule.date(i);
if (d.month() == February && d.dayOfMonth() == 29)
    dates.push_back(Date(28, February, d.year()));
else
    dates.push_back(d);
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/gjrgarchmodel.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size k = 0; k < 3; ++k) {
Real lambda = Lambda[k];
Real m1 = beta+(alpha+gamma*CumulativeNormalDistribution()(lambda))
    *(1.0+lambda*lambda)+gamma*lambda*std::exp(-lambda*lambda/2.0)
    /std::sqrt(2.0*M_PI);
Real v0 = omega/(1.0-m1);
Handle<Quote> q(boost::shared_ptr<Quote>(new SimpleQuote(s0)));
boost::shared_ptr<GJRGARCHProcess> process(new GJRGARCHProcess(
    riskFreeTS, dividendTS, q, v0, omega, alpha, beta, gamma, lambda, daysPerYear));
boost::shared_ptr<PricingEngine> engine1 =
    MakeMCEuropeanGJRGARCHEngine<PseudoRandom>(process)
    .withStepsPerYear(20)
    .withAbsoluteTolerance(0.02)
    .withSeed(1234);

boost::shared_ptr<PricingEngine> engine2(
    new AnalyticGJRGARCHEngine(boost::shared_ptr<GJRGARCHModel>(
                                       new GJRGARCHModel(process))));
for (Size i = 0; i < 2; ++i) {
    for (Size j = 0; j < 6; ++j) {
        Real x = strike[j];

        boost::shared_ptr<StrikedTypePayoff> payoff(
                             new PlainVanillaPayoff(Option::Call, x));
        Date exDate = today + maturity[i];
        boost::shared_ptr<Exercise> exercise(
                                        new EuropeanExercise(exDate));

        VanillaOption option(payoff, exercise);

        option.setPricingEngine(engine1);
        Real calculated = option.NPV();

        option.setPricingEngine(engine2);
        Real expected = option.NPV();
        Real tolerance = 7.5e-2;

        if (std::fabs(expected - analytic[k][i][j]) > 2.0*tolerance) {
            BOOST_ERROR("failed to match results from engines"
                        << "\n    correct value:    "
                        << analytic[k][i][j]
                        << "\n    Analytic Approx.: "
                        << expected
                        << " +/- " << tolerance);
        }
        if (std::fabs(calculated-mcValues[k][i][j]) > 2.0*tolerance) {
            BOOST_ERROR("failed to match results from engines"
                        << "\n    correct value:    "
                        << mcValues[k][i][j]
                        << "\n    Monte Carlo: " << calculated
                        << " +/- " << tolerance);
        }
    }
}
}

for (i = 0; i < 8; ++i) {
dates.push_back(settlementDate + t[i]);
rates.push_back(r[i]);
}

for (Size s = 3; s < 10; ++s) {
for (Size m = 0; m < 3; ++m) {
    Handle<Quote> vol(boost::shared_ptr<Quote>(
                                          new SimpleQuote(v[s*8+m])));

    Period maturity((int)((t[m]+3)/7.), Weeks); // round to weeks
    options.push_back(boost::shared_ptr<CalibrationHelper>(
            new HestonModelHelper(maturity, calendar,
                                  s0->value(), strike[s], vol,
                                  riskFreeTS, dividendTS, 
                                  CalibrationHelper::ImpliedVolError)));
}
}

for (i = 0; i < options.size(); ++i)
options[i]->setPricingEngine(engine);

for (i = 0; i < options.size(); ++i) {
const Real diff = options[i]->calibrationError()*100.0;
sse += diff*diff;
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/doublebarrieroption.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i<LENGTH(values); i++) {
Date exDate = today + Integer(values[i].t*360+0.5);
boost::shared_ptr<Exercise> exercise(new EuropeanExercise(exDate));

spot ->setValue(values[i].s);
qRate->setValue(values[i].q); 
rRate->setValue(values[i].r);
vol  ->setValue(values[i].v);

boost::shared_ptr<StrikedTypePayoff> payoff(new
    PlainVanillaPayoff(values[i].type, values[i].strike));

boost::shared_ptr<BlackScholesMertonProcess> stochProcess(new
    BlackScholesMertonProcess(Handle<Quote>(spot),
                              Handle<YieldTermStructure>(qTS),
                              Handle<YieldTermStructure>(rTS),
                              Handle<BlackVolTermStructure>(volTS)));

DoubleBarrierOption opt(
        values[i].barrierType,
        values[i].barrierlo,
        values[i].barrierhi,
        0,   // no rebate
        payoff,
        exercise);

// Ikeda/Kunitomo engine
boost::shared_ptr<PricingEngine> engine(
                             new AnalyticDoubleBarrierEngine(stochProcess));
opt.setPricingEngine(engine);

Real calculated = opt.NPV();
Real expected = values[i].result;
Real error = std::fabs(calculated-expected);
if (error>values[i].tol) {
    REPORT_FAILURE("Ikeda/Kunitomo value", values[i].barrierType, values[i].barrierlo,
                   values[i].barrierhi, payoff, exercise, values[i].s,
                   values[i].q, values[i].r, today, values[i].v,
                   expected, calculated, error, values[i].tol);
}

// Wulin Suo/Yong Wang engine
engine = boost::shared_ptr<PricingEngine>(
                             new WulinYongDoubleBarrierEngine(stochProcess));
opt.setPricingEngine(engine);

calculated = opt.NPV();
expected = values[i].result;
error = std::fabs(calculated-expected);
if (error>values[i].tol) {
    REPORT_FAILURE("Wulin/Yong value", values[i].barrierType, values[i].barrierlo,
                   values[i].barrierhi, payoff, exercise, values[i].s,
                   values[i].q, values[i].r, today, values[i].v,
                   expected, calculated, error, values[i].tol);
}

engine = boost::shared_ptr<PricingEngine>(
      new BinomialDoubleBarrierEngine<CoxRossRubinstein,
                      DiscretizedDoubleBarrierOption>(stochProcess, 
                                                         300));
opt.setPricingEngine(engine);
calculated = opt.NPV();
expected = values[i].result;
error = std::fabs(calculated-expected);
double tol = 0.28;
if (error>tol) {
    REPORT_FAILURE("Binomial value", values[i].barrierType, 
                   values[i].barrierlo, values[i].barrierhi, payoff, 
                   exercise, values[i].s, values[i].q, values[i].r, 
                   today, values[i].v, expected, calculated, error, 
                   tol);
}

engine = boost::shared_ptr<PricingEngine>(
      new BinomialDoubleBarrierEngine<CoxRossRubinstein,
                   DiscretizedDermanKaniDoubleBarrierOption>(
                                        stochProcess, 300));
opt.setPricingEngine(engine);
calculated = opt.NPV();
expected = values[i].result;
error = std::fabs(calculated-expected);
tol = 0.033; // error one order of magnitude lower than plain binomial
if (error>tol) {
    REPORT_FAILURE("Binomial (Derman) value", values[i].barrierType, 
                   values[i].barrierlo, values[i].barrierhi, payoff, 
                   exercise, values[i].s, values[i].q, values[i].r, 
                   today, values[i].v, expected, calculated, error, 
                   tol);
}
}

for (Size i=0; i<LENGTH(values); i++) {

spot->setValue(values[i].s);
qRate->setValue(values[i].q);
rRate->setValue(values[i].r);
vol25Put->setValue(values[i].vol25Put);
volAtm->setValue(values[i].volAtm);
vol25Call->setValue(values[i].vol25Call);

boost::shared_ptr<StrikedTypePayoff> payoff =
    boost::make_shared<PlainVanillaPayoff>(values[i].type,
                                           values[i].strike);

Date exDate = today + Integer(values[i].t*365+0.5);
boost::shared_ptr<Exercise> exercise =
    boost::make_shared<EuropeanExercise>(exDate);

Handle<DeltaVolQuote> volAtmQuote = Handle<DeltaVolQuote>(
				boost::make_shared<DeltaVolQuote>(
					Handle<Quote>(volAtm),
					DeltaVolQuote::Fwd,
					values[i].t,
					DeltaVolQuote::AtmDeltaNeutral));

					//always delta neutral atm
Handle<DeltaVolQuote> vol25PutQuote(Handle<DeltaVolQuote>(
				boost::make_shared<DeltaVolQuote>(
					-0.25,
					Handle<Quote>(vol25Put),
					values[i].t,
					DeltaVolQuote::Fwd)));

Handle<DeltaVolQuote> vol25CallQuote(Handle<DeltaVolQuote>(
				boost::make_shared<DeltaVolQuote>(
					0.25,
					Handle<Quote>(vol25Call),
					values[i].t,
					DeltaVolQuote::Fwd)));

DoubleBarrierOption doubleBarrierOption(values[i].barrierType,
                                        values[i].barrier1,
                                        values[i].barrier2,
                                        values[i].rebate,
                                        payoff,
                                        exercise);

Real bsVanillaPrice =
    blackFormula(values[i].type, values[i].strike,
				 spot->value()*qTS->discount(values[i].t)/rTS->discount(values[i].t),
				 values[i].v * sqrt(values[i].t), rTS->discount(values[i].t));
boost::shared_ptr<PricingEngine> vannaVolgaEngine =
    boost::make_shared<VannaVolgaDoubleBarrierEngine<WulinYongDoubleBarrierEngine> >(
                    volAtmQuote,
					vol25PutQuote,
					vol25CallQuote,
					Handle<Quote> (spot),
					Handle<YieldTermStructure> (rTS),
					Handle<YieldTermStructure> (qTS),
					true,
					bsVanillaPrice);
doubleBarrierOption.setPricingEngine(vannaVolgaEngine);

Real calculated = doubleBarrierOption.NPV();
Real expected = values[i].result;
Real error = std::fabs(calculated-expected);
if (error>values[i].tol) {
    REPORT_FAILURE_VANNAVOLGA(
        "value", values[i].barrierType,
        values[i].barrier1, values[i].barrier2,
        values[i].rebate, payoff, exercise, values[i].s,
        values[i].q, values[i].r, today, values[i].vol25Put,
        values[i].volAtm, values[i].vol25Call, values[i].v,
        expected, calculated, error, values[i].tol);
}

vannaVolgaEngine =
    boost::make_shared<VannaVolgaDoubleBarrierEngine<AnalyticDoubleBarrierEngine> >(
                    volAtmQuote,
					vol25PutQuote,
					vol25CallQuote,
					Handle<Quote> (spot),
					Handle<YieldTermStructure> (rTS),
					Handle<YieldTermStructure> (qTS),
					true,
					bsVanillaPrice);
doubleBarrierOption.setPricingEngine(vannaVolgaEngine);

calculated = doubleBarrierOption.NPV();
expected = values[i].result;
error = std::fabs(calculated-expected);
Real maxtol = 5.0e-3; // different engines have somewhat different results
if (error>maxtol) {
    REPORT_FAILURE_VANNAVOLGA(
        "value", values[i].barrierType,
        values[i].barrier1, values[i].barrier2,
        values[i].rebate, payoff, exercise, values[i].s,
        values[i].q, values[i].r, today, values[i].vol25Put,
        values[i].volAtm, values[i].vol25Call, values[i].v,
        expected, calculated, error, values[i].tol);
}

}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/rngtraits.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i<values.size(); i++)
sum += values[i];

for (Size i=0; i<values.size(); i++)
sum += values[i];

for (Size i=0; i<values.size(); i++)
sum += values[i];

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/inflationcpiswap.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i<N; i++) {
    Date maturity = iiData[i].date;
    Handle<Quote> quote(boost::shared_ptr<Quote>(
                        new SimpleQuote(iiData[i].rate/100.0)));
    boost::shared_ptr<BootstrapHelper<T> > anInstrument(new U(
                        quote, observationLag, maturity,
                        calendar, bdc, dc, ii));
    instruments.push_back(anInstrument);
}

    for (Size i=0; i<rpiSchedule.size();i++) {
        ii->addFixing(rpiSchedule[i], fixData[i], true);// force overwrite in case multiple use
    };

    for (Size i = 0; i < nominalDataLength; i++) {
        nomD.push_back(nominalData[i].date);
        nomR.push_back(nominalData[i].rate/100.0);
    }

    for (Size i = 0; i < zciisDataLength; i++) {
        zciisD.push_back(zciisData[i].date);
        zciisR.push_back(zciisData[i].rate);
    }

for(Size i=0;i<floatSchedule.size(); i++){
if (floatSchedule[i] < common.evaluationDate) {
    floatIndex->addFixing(floatSchedule[i], floatFix[i],true);//true=overwrite
}

boost::shared_ptr<CPICoupon>
zic = boost::dynamic_pointer_cast<CPICoupon>(zisV.cpiLeg()[i]);
if (zic) {
    if (zic->fixingDate() < (common.evaluationDate - Period(1,Months))) {
        fixedIndex->addFixing(zic->fixingDate(), cpiFix[i],true);
    }
}
}

for(Size i=0;i<zisV.leg(0).size(); i++){

Date zicPayDate = (zisV.leg(0))[i]->date();
if(zicPayDate > asofDate) {
    testInfLegNPV += (zisV.leg(0))[i]->amount()*common.nominalTS->discount(zicPayDate);
}

boost::shared_ptr<CPICoupon>
    zicV = boost::dynamic_pointer_cast<CPICoupon>(zisV.cpiLeg()[i]);
if (zicV) {
    Real diff = fabs( zicV->rate() - (fixedRate*(zicV->indexFixing()/baseCPI)) );
    QL_REQUIRE(diff<1e-8,"failed "<<i<<"th coupon reconstruction as "
               << (fixedRate*(zicV->indexFixing()/baseCPI)) << " vs rate = "
               <<zicV->rate() << ", with difference: " << diff);
}
}

for (Size i=0; i<2; i++) {
QL_REQUIRE(fabs(cS.legNPV(i)-zciis.legNPV(i))<1e-3,"zciis leg does not equal CPISwap leg");
}

for(Size i=0;i<floatSchedule.size(); i++){
if (floatSchedule[i] < common.evaluationDate) {
    floatIndex->addFixing(floatSchedule[i], floatFix[i],true);//true=overwrite
}

boost::shared_ptr<CPICoupon>
zic = boost::dynamic_pointer_cast<CPICoupon>(zisV.cpiLeg()[i]);
if (zic) {
    if (zic->fixingDate() < (common.evaluationDate - Period(1,Months))) {
        fixedIndex->addFixing(zic->fixingDate(), cpiFix[i],true);
    }
}
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/mersennetwister.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (i=0; i<1000; i++) {
if (referenceLongValues[i] != mt19937.nextInt32()) {
    BOOST_FAIL("Mersenne Twister test failed at index " << i);
}
}

for (i=0; i<1000; i++) {
Real e = std::fabs(referenceValues[i] -
                     mt19937.next().value);
if (e > 1.0e-8) {
    BOOST_FAIL("Mersenne Twister test failed at index: " << i << "\n"
               "error: " << e);
}
}

for (i=0; i<1000; i++)
mt1.nextInt32();

for (i=0; i<999; i++)
mt2.nextInt32();

for (i=0; i<999; i++) {
mt3.nextInt32();
mt4.nextInt32();
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/inflationcpibond.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i<N; i++) {
    Date maturity = iiData[i].date;
    Handle<Quote> quote(boost::shared_ptr<Quote>(
                        new SimpleQuote(iiData[i].rate/100.0)));
    boost::shared_ptr<Helper> h(
              new ZeroCouponInflationSwapHelper(quote, observationLag,
                                                maturity, calendar,
                                                bdc, dc, ii));
    instruments.push_back(h);
}

    for (Size i=0; i<LENGTH(fixData); ++i) {
        ii->addFixing(rpiSchedule[i], fixData[i]);
    }

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/extendedtrees.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i<LENGTH(types); i++) {
  for (Size j=0; j<LENGTH(strikes); j++) {
    for (Size k=0; k<LENGTH(lengths); k++) {
      Date exDate = today + lengths[k]*360;
      boost::shared_ptr<Exercise> exercise(
                                        new EuropeanExercise(exDate));
      boost::shared_ptr<StrikedTypePayoff> payoff(new
                            PlainVanillaPayoff(types[i], strikes[j]));
      // reference option
      boost::shared_ptr<VanillaOption> refOption =
          makeOption(payoff, exercise, spot, qTS, rTS, volTS,
                     Analytic, Null<Size>());
      // option to check
      boost::shared_ptr<VanillaOption> option =
          makeOption(payoff, exercise, spot, qTS, rTS, volTS,
                     engine, binomialSteps);

      for (Size l=0; l<LENGTH(underlyings); l++) {
        for (Size m=0; m<LENGTH(qRates); m++) {
          for (Size n=0; n<LENGTH(rRates); n++) {
            for (Size p=0; p<LENGTH(vols); p++) {
              Real u = underlyings[l];
              Rate q = qRates[m],
                   r = rRates[n];
              Volatility v = vols[p];
              spot->setValue(u);
              qRate->setValue(q);
              rRate->setValue(r);
              vol->setValue(v);

              expected.clear();
              calculated.clear();

              // FLOATING_POINT_EXCEPTION
              expected["value"] = refOption->NPV();
              calculated["value"] = option->NPV();

              if (option->NPV() > spot->value()*1.0e-5) {
                   expected["delta"] = refOption->delta();
                   expected["gamma"] = refOption->gamma();
                   expected["theta"] = refOption->theta();
                   calculated["delta"] = option->delta();
                   calculated["gamma"] = option->gamma();
                   calculated["theta"] = option->theta();
              }
              std::map<std::string,Real>::iterator it;
              for (it = calculated.begin();
                   it != calculated.end(); ++it) {
                  std::string greek = it->first;
                  Real expct = expected  [greek],
                       calcl = calculated[greek],
                       tol   = tolerance [greek];
                  Real error = relativeError(expct,calcl,u);
                  if (error > tol) {
                      REPORT_FAILURE(greek, payoff, exercise,
                                     u, q, r, today, v,
                                     expct, calcl, error, tol);
                  }
              }
            }
          }
        }
      }
    }
  }
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/timeseries.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (int i = 0; d < d1; ++i, d = calendar.advance(d, 1, Days)) {
ts1[d] = i;
}

for (int i = 0; d < d1; ++i, d = calendar.advance(d, 1, Days)) {
if (ts1[d] != int(i)) {
    BOOST_ERROR("value does not match");
}
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/riskstats.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (i=0; i<LENGTH(averages); i++) {
for (j=0; j<LENGTH(sigmas); j++) {

    NormalDistribution normal(averages[i],sigmas[j]);
    CumulativeNormalDistribution cumulative(averages[i],sigmas[j]);
    InverseCumulativeNormal inverseCum(averages[i],sigmas[j]);

    SobolRsg rng(1);
    dataMin = QL_MAX_REAL;
    dataMax = QL_MIN_REAL;
    for (k=0; k<N; k++) {
        data[k] = inverseCum(rng.nextSequence().value[0]);
        dataMin = std::min(dataMin, data[k]);
        dataMax = std::max(dataMax, data[k]);
        weights[k]=1.0;
    }

    igs.addSequence(data.begin(),data.end(),weights.begin());
    s.addSequence(data.begin(),data.end(),weights.begin());

    // checks
    Real calculated, expected;
    Real tolerance;

    if (igs.samples() != N)
        BOOST_FAIL("IncrementalGaussianStatistics: "
                   << "wrong number of samples\n"
                   << "    calculated: " << igs.samples() << "\n"
                   << "    expected:   " << N);
    if (s.samples() != N)
        BOOST_FAIL("RiskStatistics: wrong number of samples\n"
                   << "    calculated: " << s.samples() << "\n"
                   << "    expected:   " << N);


    // weightSum()
    tolerance = 1e-10;
    expected = std::accumulate(weights.begin(),weights.end(),Real(0.0));
    calculated = igs.weightSum();
    if (std::fabs(calculated-expected) > tolerance)
        BOOST_FAIL("IncrementalGaussianStatistics: "
                   << "wrong sum of weights\n"
                   << std::setprecision(16)
                   << "    calculated: " << calculated << "\n"
                   << "    expected:   " << expected << "\n"
                   << "    tolerance:  " << tolerance);
    calculated = s.weightSum();
    if (std::fabs(calculated-expected) > tolerance)
        BOOST_FAIL("RiskStatistics: wrong sum of weights\n"
                   << std::setprecision(16)
                   << "    calculated: " << calculated << "\n"
                   << "    expected:   " << expected << "\n"
                   << "    tolerance:  " << tolerance);


    // min
    tolerance = 1e-12;
    expected = dataMin;
    calculated = igs.min();
    if (std::fabs(calculated-expected)>tolerance)
        BOOST_FAIL("IncrementalGaussianStatistics: "
                   << "wrong minimum value\n"
                   << std::setprecision(16)
                   << "    calculated: " << calculated << "\n"
                   << "    expected:   " << expected << "\n"
                   << "    tolerance:  " << tolerance);
    calculated = s.min();
    if (std::fabs(calculated-expected)>tolerance)
        BOOST_FAIL("RiskStatistics: "
                   << "wrong minimum value\n"
                   << std::setprecision(16)
                   << "    calculated: " << calculated << "\n"
                   << "    expected:   " << expected << "\n"
                   << "    tolerance:  " << tolerance);


    // max
    expected = dataMax;
    calculated = igs.max();
    if (std::fabs(calculated-expected)>tolerance)
        BOOST_FAIL("IncrementalGaussianStatistics: "
                   << "wrong maximum value\n"
                   << std::setprecision(16)
                   << "    calculated: " << calculated << "\n"
                   << "    expected:   " << expected << "\n"
                   << "    tolerance:  " << tolerance);
    calculated = s.max();
    if (std::fabs(calculated-expected)>tolerance)
        BOOST_FAIL("RiskStatistics: "
                   << "wrong maximum value\n"
                   << std::setprecision(16)
                   << "    calculated: " << calculated << "\n"
                   << "    expected:   " << expected << "\n"
                   << "    tolerance:  " << tolerance);


    // mean
    expected = averages[i];
    tolerance = (expected == 0.0 ? 1.0e-13 :
                                   std::fabs(expected)*1.0e-13);
    calculated = igs.mean();
    if (std::fabs(calculated-expected) > tolerance)
        BOOST_FAIL("IncrementalGaussianStatistics: "
                   << "wrong mean value"
                   << " for N(" << averages[i] << ", "
                   << sigmas[j] << ")\n"
                   << std::setprecision(16)
                   << "    calculated: " << calculated << "\n"
                   << "    expected:   " << expected << "\n"
                   << "    tolerance:  " << tolerance);
    calculated = s.mean();
    if (std::fabs(calculated-expected) > tolerance)
        BOOST_FAIL("RiskStatistics: wrong mean value"
                   << " for N(" << averages[i] << ", "
                   << sigmas[j] << ")\n"
                   << std::setprecision(16)
                   << "    calculated: " << calculated << "\n"
                   << "    expected:   " << expected << "\n"
                   << "    tolerance:  " << tolerance);


    // variance
    expected = sigmas[j]*sigmas[j];
    tolerance = expected*1.0e-1;
    calculated = igs.variance();
    if (std::fabs(calculated-expected) > tolerance)
        BOOST_FAIL("IncrementalGaussianStatistics: "
                   << "wrong variance"
                   << " for N(" << averages[i] << ", "
                   << sigmas[j] << ")\n"
                   << std::setprecision(16)
                   << "    calculated: " << calculated << "\n"
                   << "    expected:   " << expected << "\n"
                   << "    tolerance:  " << tolerance);
    calculated = s.variance();
    if (std::fabs(calculated-expected) > tolerance)
        BOOST_FAIL("RiskStatistics: wrong variance"
                   << " for N(" << averages[i] << ", "
                   << sigmas[j] << ")\n"
                   << std::setprecision(16)
                   << "    calculated: " << calculated << "\n"
                   << "    expected:   " << expected << "\n"
                   << "    tolerance:  " << tolerance);


    // standardDeviation
    expected = sigmas[j];
    tolerance = expected*1.0e-1;
    calculated = igs.standardDeviation();
    if (std::fabs(calculated-expected) > tolerance)
        BOOST_FAIL("IncrementalGaussianStatistics: "
                   << "wrong standard deviation"
                   << " for N(" << averages[i] << ", "
                   << sigmas[j] << ")\n"
                   << std::setprecision(16)
                   << "    calculated: " << calculated << "\n"
                   << "    expected:   " << expected << "\n"
                   << "    tolerance:  " << tolerance);
    calculated = s.standardDeviation();
    if (std::fabs(calculated-expected) > tolerance)
        BOOST_FAIL("RiskStatistics: wrong standard deviation"
                   << " for N(" << averages[i] << ", "
                   << sigmas[j] << ")\n"
                   << std::setprecision(16)
                   << "    calculated: " << calculated << "\n"
                   << "    expected:   " << expected << "\n"
                   << "    tolerance:  " << tolerance);


    // missing errorEstimate() test

    // skewness
    expected = 0.0;
    tolerance = 1.0e-4;
    calculated = igs.skewness();
    if (std::fabs(calculated-expected) > tolerance)
        BOOST_FAIL("IncrementalGaussianStatistics: "
                   << "wrong skewness"
                   << " for N(" << averages[i] << ", "
                   << sigmas[j] << ")\n"
                   << std::setprecision(16)
                   << "    calculated: " << calculated << "\n"
                   << "    expected:   " << expected << "\n"
                   << "    tolerance:  " << tolerance);
    calculated = s.skewness();
    if (std::fabs(calculated-expected) > tolerance)
        BOOST_FAIL("RiskStatistics: wrong skewness"
                   << " for N(" << averages[i] << ", "
                   << sigmas[j] << ")\n"
                   << std::setprecision(16)
                   << "    calculated: " << calculated << "\n"
                   << "    expected:   " << expected << "\n"
                   << "    tolerance:  " << tolerance);


    // kurtosis
    expected = 0.0;
    tolerance = 1.0e-1;
    calculated = igs.kurtosis();
    if (std::fabs(calculated-expected) > tolerance)
        BOOST_FAIL("IncrementalGaussianStatistics: "
                   << "wrong kurtosis"
                   << " for N(" << averages[i] << ", "
                   << sigmas[j] << ")\n"
                   << std::setprecision(16)
                   << "    calculated: " << calculated << "\n"
                   << "    expected:   " << expected << "\n"
                   << "    tolerance:  " << tolerance);
    calculated = s.kurtosis();
    if (std::fabs(calculated-expected) > tolerance)
        BOOST_FAIL("RiskStatistics: wrong kurtosis"
                   << " for N(" << averages[i] << ", "
                   << sigmas[j] << ")\n"
                   << std::setprecision(16)
                   << "    calculated: " << calculated << "\n"
                   << "    expected:   " << expected << "\n"
                   << "    tolerance:  " << tolerance);


    // percentile
    expected = averages[i];
    tolerance = (expected == 0.0 ? 1.0e-3 :
                                   std::fabs(expected*1.0e-3));
    calculated = igs.gaussianPercentile(0.5);
    if (std::fabs(calculated-expected) > tolerance)
        BOOST_FAIL("IncrementalGaussianStatistics: "
                   << "wrong Gaussian percentile"
                   << " for N(" << averages[i] << ", "
                   << sigmas[j] << ")\n"
                   << std::setprecision(16)
                   << "    calculated: " << calculated << "\n"
                   << "    expected:   " << expected << "\n"
                   << "    tolerance:  " << tolerance);
    calculated = s.gaussianPercentile(0.5);
    if (std::fabs(calculated-expected) > tolerance)
        BOOST_FAIL("RiskStatistics: wrong Gaussian percentile"
                   << " for N(" << averages[i] << ", "
                   << sigmas[j] << ")\n"
                   << std::setprecision(16)
                   << "    calculated: " << calculated << "\n"
                   << "    expected:   " << expected << "\n"
                   << "    tolerance:  " << tolerance);
    calculated = s.percentile(0.5);
    if (std::fabs(calculated-expected) > tolerance)
        BOOST_FAIL("RiskStatistics: wrong percentile"
                   << " for N(" << averages[i] << ", "
                   << sigmas[j] << ")\n"
                   << std::setprecision(16)
                   << "    calculated: " << calculated << "\n"
                   << "    expected:   " << expected << "\n"
                   << "    tolerance:  " << tolerance);



    // potential upside
    Real upper_tail = averages[i]+2.0*sigmas[j],
         lower_tail = averages[i]-2.0*sigmas[j];
    Real twoSigma = cumulative(upper_tail);

    expected = std::max<Real>(upper_tail,0.0);
    tolerance = (expected == 0.0 ? 1.0e-3 :
                                   std::fabs(expected*1.0e-3));
    calculated = igs.gaussianPotentialUpside(twoSigma);
    if (std::fabs(calculated-expected) > tolerance)
        BOOST_FAIL("IncrementalGaussianStatistics: "
                   << "wrong Gaussian potential upside"
                   << " for N(" << averages[i] << ", "
                   << sigmas[j] << ")\n"
                   << std::setprecision(16)
                   << "    calculated: " << calculated << "\n"
                   << "    expected:   " << expected << "\n"
                   << "    tolerance:  " << tolerance);
    calculated = s.gaussianPotentialUpside(twoSigma);
    if (std::fabs(calculated-expected) > tolerance)
        BOOST_FAIL("RiskStatistics: wrong Gaussian potential upside"
                   << " for N(" << averages[i] << ", "
                   << sigmas[j] << ")\n"
                   << std::setprecision(16)
                   << "    calculated: " << calculated << "\n"
                   << "    expected:   " << expected << "\n"
                   << "    tolerance:  " << tolerance);
    calculated = s.potentialUpside(twoSigma);
    if (std::fabs(calculated-expected) > tolerance)
        BOOST_FAIL("RiskStatistics: wrong potential upside"
                   << " for N(" << averages[i] << ", "
                   << sigmas[j] << ")\n"
                   << std::setprecision(16)
                   << "    calculated: " << calculated << "\n"
                   << "    expected:   " << expected << "\n"
                   << "    tolerance:  " << tolerance);


    // just to check that GaussianStatistics<StatsHolder> does work
    StatsHolder h(s.mean(), s.standardDeviation());
    GenericGaussianStatistics<StatsHolder> test(h);
    expected = s.gaussianPotentialUpside(twoSigma);
    calculated = test.gaussianPotentialUpside(twoSigma);
    if (!close(calculated,expected))
        BOOST_FAIL("GenericGaussianStatistics<StatsHolder> fails"
                   << std::setprecision(16)
                   << "\n  calculated: " << calculated
                   << "\n  expected: " << expected);

    // value-at-risk
    expected = -std::min<Real>(lower_tail,0.0);
    tolerance = (expected == 0.0 ? 1.0e-3 :
                                   std::fabs(expected*1.0e-3));
    calculated = igs.gaussianValueAtRisk(twoSigma);
    if (std::fabs(calculated-expected) > tolerance)
        BOOST_FAIL("IncrementalGaussianStatistics: "
                   << "wrong Gaussian value-at-risk"
                   << " for N(" << averages[i] << ", "
                   << sigmas[j] << ")\n"
                   << std::setprecision(16)
                   << "    calculated: " << calculated << "\n"
                   << "    expected:   " << expected << "\n"
                   << "    tolerance:  " << tolerance);
    calculated = s.gaussianValueAtRisk(twoSigma);
    if (std::fabs(calculated-expected) > tolerance)
        BOOST_FAIL("RiskStatistics: wrong Gaussian value-at-risk"
                   << " for N(" << averages[i] << ", "
                   << sigmas[j] << ")\n"
                   << std::setprecision(16)
                   << "    calculated: " << calculated << "\n"
                   << "    expected:   " << expected << "\n"
                   << "    tolerance:  " << tolerance);
    calculated = s.valueAtRisk(twoSigma);
    if (std::fabs(calculated-expected) > tolerance)
        BOOST_FAIL("RiskStatistics: wrong value-at-risk"
                   << " for N(" << averages[i] << ", "
                   << sigmas[j] << ")\n"
                   << std::setprecision(16)
                   << "    calculated: " << calculated << "\n"
                   << "    expected:   " << expected << "\n"
                   << "    tolerance:  " << tolerance);

    if (averages[i] > 0.0 && sigmas[j] < averages[i]) {
        // no data will miss the targets:
        // skip the rest of this iteration
        igs.reset();
        s.reset();
        continue;
    }


    // expected shortfall
    expected = -std::min<Real>(averages[i]
                               - sigmas[j]*sigmas[j]
                               * normal(lower_tail)/(1.0-twoSigma),
                               0.0);
    tolerance = (expected == 0.0 ? 1.0e-4
                                 : std::fabs(expected)*1.0e-2);
    calculated = igs.gaussianExpectedShortfall(twoSigma);
    if (std::fabs(calculated-expected) > tolerance)
        BOOST_FAIL("IncrementalGaussianStatistics: "
                   << "wrong Gaussian expected shortfall"
                   << " for N(" << averages[i] << ", "
                   << sigmas[j] << ")\n"
                   << std::setprecision(16)
                   << "    calculated: " << calculated << "\n"
                   << "    expected:   " << expected << "\n"
                   << "    tolerance:  " << tolerance);
    calculated = s.gaussianExpectedShortfall(twoSigma);
    if (std::fabs(calculated-expected) > tolerance)
        BOOST_FAIL("RiskStatistics: wrong Gaussian expected shortfall"
                   << " for N(" << averages[i] << ", "
                   << sigmas[j] << ")\n"
                   << std::setprecision(16)
                   << "    calculated: " << calculated << "\n"
                   << "    expected:   " << expected << "\n"
                   << "    tolerance:  " << tolerance);
    calculated = s.expectedShortfall(twoSigma);
    if (std::fabs(calculated-expected) > tolerance)
        BOOST_FAIL("RiskStatistics: wrong expected shortfall"
                   << " for N(" << averages[i] << ", "
                   << sigmas[j] << ")\n"
                   << std::setprecision(16)
                   << "    calculated: " << calculated << "\n"
                   << "    expected:   " << expected << "\n"
                   << "    tolerance:  " << tolerance);


    // shortfall
    expected = 0.5;
    tolerance = (expected == 0.0 ? 1.0e-3 :
                                   std::fabs(expected*1.0e-3));
    calculated = igs.gaussianShortfall(averages[i]);
    if (std::fabs(calculated-expected) > tolerance)
        BOOST_FAIL("IncrementalGaussianStatistics: "
                   << "wrong Gaussian shortfall"
                   << " for N(" << averages[i] << ", "
                   << sigmas[j] << ")\n"
                   << std::setprecision(16)
                   << "    calculated: " << calculated << "\n"
                   << "    expected:   " << expected << "\n"
                   << "    tolerance:  " << tolerance);
    calculated = s.gaussianShortfall(averages[i]);
    if (std::fabs(calculated-expected) > tolerance)
        BOOST_FAIL("RiskStatistics: wrong Gaussian shortfall"
                   << " for N(" << averages[i] << ", "
                   << sigmas[j] << ")\n"
                   << std::setprecision(16)
                   << "    calculated: " << calculated << "\n"
                   << "    expected:   " << expected << "\n"
                   << "    tolerance:  " << tolerance);
    calculated = s.shortfall(averages[i]);
    if (std::fabs(calculated-expected) > tolerance)
        BOOST_FAIL("RiskStatistics: wrong shortfall"
                   << " for N(" << averages[i] << ", "
                   << sigmas[j] << ")\n"
                   << std::setprecision(16)
                   << "    calculated: " << calculated << "\n"
                   << "    expected:   " << expected << "\n"
                   << "    tolerance:  " << tolerance);


    // average shortfall
    expected = sigmas[j]/std::sqrt(2.0*M_PI)*2.0;
    tolerance = expected*1.0e-3;
    calculated = igs.gaussianAverageShortfall(averages[i]);
    if (std::fabs(calculated-expected) > tolerance)
        BOOST_FAIL("IncrementalGaussianStatistics: "
                   << "wrong Gaussian average shortfall"
                   << " for N(" << averages[i] << ", "
                   << sigmas[j] << ")\n"
                   << std::setprecision(16)
                   << "    calculated: " << calculated << "\n"
                   << "    expected:   " << expected << "\n"
                   << "    tolerance:  " << tolerance);
    calculated = s.gaussianAverageShortfall(averages[i]);
    if (std::fabs(calculated-expected) > tolerance)
        BOOST_FAIL("RiskStatistics: wrong Gaussian average shortfall"
                   << " for N(" << averages[i] << ", "
                   << sigmas[j] << ")\n"
                   << std::setprecision(16)
                   << "    calculated: " << calculated << "\n"
                   << "    expected:   " << expected << "\n"
                   << "    tolerance:  " << tolerance);
    calculated = s.averageShortfall(averages[i]);
    if (std::fabs(calculated-expected) > tolerance)
        BOOST_FAIL("RiskStatistics: wrong average shortfall"
                   << " for N(" << averages[i] << ", "
                   << sigmas[j] << ")\n"
                   << std::setprecision(16)
                   << "    calculated: " << calculated << "\n"
                   << "    expected:   " << expected << "\n"
                   << "    tolerance:  " << tolerance);


    // regret
    expected = sigmas[j]*sigmas[j];
    tolerance = expected*1.0e-1;
    calculated = igs.gaussianRegret(averages[i]);
    if (std::fabs(calculated-expected) > tolerance)
        BOOST_FAIL("IncrementalGaussianStatistics: "
                   << "wrong Gaussian regret(" << averages[i] << ") "
                   << "for N(" << averages[i] << ", "
                   << sigmas[j] << ")\n"
                   << std::setprecision(16)
                   << "    calculated: " << calculated << "\n"
                   << "    expected:   " << expected << "\n"
                   << "    tolerance:  " << tolerance);
    calculated = s.gaussianRegret(averages[i]);
    if (std::fabs(calculated-expected) > tolerance)
        BOOST_FAIL("RiskStatistics: "
                   << "wrong Gaussian regret(" << averages[i] << ") "
                   << "for N(" << averages[i] << ", "
                   << sigmas[j] << ")\n"
                   << std::setprecision(16)
                   << "    calculated: " << calculated << "\n"
                   << "    expected:   " << expected << "\n"
                   << "    tolerance:  " << tolerance);
    calculated = s.regret(averages[i]);
    if (std::fabs(calculated-expected) > tolerance)
        BOOST_FAIL("RiskStatistics: "
                   << "wrong regret(" << averages[i] << ") "
                   << "for N(" << averages[i] << ", "
                   << sigmas[j] << ")\n"
                   << std::setprecision(16)
                   << "    calculated: " << calculated << "\n"
                   << "    expected:   " << expected << "\n"
                   << "    tolerance:  " << tolerance);


    // downsideVariance
    expected = s.downsideVariance();
    tolerance = (expected == 0.0 ? 1.0e-3 :
                                   std::fabs(expected*1.0e-3));
    calculated = igs.downsideVariance();
    if (std::fabs(calculated-expected) > tolerance)
        BOOST_FAIL("IncrementalGaussianStatistics: "
                   << "wrong downside variance"
                   << "for N(" << averages[i] << ", "
                   << sigmas[j] << ")\n"
                   << std::setprecision(16)
                   << "    calculated: " << calculated << "\n"
                   << "    expected:   " << expected << "\n"
                   << "    tolerance:  " << tolerance);
    calculated = igs.gaussianDownsideVariance();
    if (std::fabs(calculated-expected) > tolerance)
        BOOST_FAIL("IncrementalGaussianStatistics: "
                   << "wrong Gaussian downside variance"
                   << "for N(" << averages[i] << ", "
                   << sigmas[j] << ")\n"
                   << std::setprecision(16)
                   << "    calculated: " << calculated << "\n"
                   << "    expected:   " << expected << "\n"
                   << "    tolerance:  " << tolerance);

    // downsideVariance
    if (averages[i]==0.0) {
        expected = sigmas[j]*sigmas[j];
        tolerance = expected*1.0e-3;
        calculated = igs.downsideVariance();
        if (std::fabs(calculated-expected) > tolerance)
            BOOST_FAIL("IncrementalGaussianStatistics: "
                       << "wrong downside variance"
                       << "for N(" << averages[i] << ", "
                       << sigmas[j] << ")\n"
                       << std::setprecision(16)
                       << "    calculated: " << calculated << "\n"
                       << "    expected:   " << expected << "\n"
                       << "    tolerance:  " << tolerance);
        calculated = igs.gaussianDownsideVariance();
        if (std::fabs(calculated-expected) > tolerance)
            BOOST_FAIL("IncrementalGaussianStatistics: "
                       << "wrong Gaussian downside variance"
                       << "for N(" << averages[i] << ", "
                       << sigmas[j] << ")\n"
                       << std::setprecision(16)
                       << "    calculated: " << calculated << "\n"
                       << "    expected:   " << expected << "\n"
                       << "    tolerance:  " << tolerance);
        calculated = s.downsideVariance();
        if (std::fabs(calculated-expected) > tolerance)
            BOOST_FAIL("RiskStatistics: wrong downside variance"
                       << "for N(" << averages[i] << ", "
                       << sigmas[j] << ")\n"
                       << std::setprecision(16)
                       << "    calculated: " << calculated << "\n"
                       << "    expected:   " << expected << "\n"
                       << "    tolerance:  " << tolerance);
        calculated = s.gaussianDownsideVariance();
        if (std::fabs(calculated-expected) > tolerance)
            BOOST_FAIL("RiskStatistics: wrong Gaussian downside variance"
                       << "for N(" << averages[i] << ", "
                       << sigmas[j] << ")\n"
                       << std::setprecision(16)
                       << "    calculated: " << calculated << "\n"
                       << "    expected:   " << expected << "\n"
                       << "    tolerance:  " << tolerance);
    }

    igs.reset();
    s.reset();

}
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/inflationcpicapfloor.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i<N; i++) {
    Date maturity = iiData[i].date;
    Handle<Quote> quote(boost::shared_ptr<Quote>(
                        new SimpleQuote(iiData[i].rate/100.0)));
    boost::shared_ptr<BootstrapHelper<T> > anInstrument(new U(
                        quote, observationLag, maturity,
                        calendar, bdc, dc, ii));
    instruments.push_back(anInstrument);
}

    for (Size i=0; i<rpiSchedule.size();i++) {
        ii->addFixing(rpiSchedule[i], fixData[i], true);// force overwrite in case multiple use
    };

    for (Size i = 0; i < nominalDataLength; i++) {
        nomD.push_back(nominalData[i].date);
        nomR.push_back(nominalData[i].rate/100.0);
    }

    for (Size i = 0; i < zciisDataLength; i++) {
        zciisD.push_back(zciisData[i].date);
        zciisR.push_back(zciisData[i].rate);
    }

    for(Size i = 0; i < ncStrikes; i++) cStrikesUK.push_back(cStrike[i]);

    for(Size i = 0; i < nfStrikes; i++) fStrikesUK.push_back(fStrike[i]);

    for(Size i = 0; i < ncfMaturities; i++) cfMaturitiesUK.push_back(cfMat[i]);

    for(Size i = 0; i < ncStrikes; i++) {
        for(Size j = 0; j < ncfMaturities; j++) {
            (*cPriceUK)[i][j] = cPrice[j][i]/10000.0;
        }
    }

    for(Size i = 0; i < nfStrikes; i++) {
        for(Size j = 0; j < ncfMaturities; j++) {
            (*fPriceUK)[i][j] = fPrice[j][i]/10000.0;
        }
    }

for (Size i =0; i<common.fStrikesUK.size(); i++){

 Real qK = common.fStrikesUK[i];
 Size nMat = common.cfMaturitiesUK.size();
 for (Size j=0; j<nMat; j++) {
     Period t = common.cfMaturitiesUK[j];
     Real a = (*(common.fPriceUK))[i][j];
     Real b = cpiSurf.floorPrice(t,qK);

     QL_REQUIRE(fabs(a-b)<1e-7,"cannot reproduce cpi floor data from surface: "
                << a << " vs constructed = " << b);
 }

}

for (Size i =0; i<common.cStrikesUK.size(); i++){

Real qK = common.cStrikesUK[i];
Size nMat = common.cfMaturitiesUK.size();
for (Size j=0; j<nMat; j++) {
    Period t = common.cfMaturitiesUK[j];
    Real a = (*(common.cPriceUK))[i][j];
    Real b = cpiSurf.capPrice(t,qK);

    QL_REQUIRE(fabs(a-b)<1e-7,"cannot reproduce cpi cap data from surface: "
               << a << " vs constructed = " << b);
}
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/marketmodel_smmcaplethomocalibration.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=1; i<dates.size(); ++i)
    rateTimes_[i-1] = dayCounter_.yearFraction(todaysDate_, dates[i]);

for (Size i=1; i<rateTimes_.size(); ++i)
    accruals_[i-1] = rateTimes_[i] - rateTimes_[i-1];

for (Size i=0; i<todaysForwards_.size(); ++i) {
    // FLOATING_POINT_EXCEPTION
    todaysForwards_[i] = 0.03 + 0.0025*i;
    //    todaysForwards_[i] = 0.03;
}

for (Size i=1; i<rateTimes_.size(); ++i)
    todaysDiscounts_[i] = todaysDiscounts_[i-1] /
        (1.0+todaysForwards_[i-1]*accruals_[i-1]);

for (Size i=0; i<todaysSwaps_.size(); i++) {
    //    swaptionDisplacedVols[i] = todaysSwaps[i]*mktSwaptionVols[i]/
    //                              (todaysSwaps[i]+displacement);
    //    swaptionVols[i]= mktSwaptionVols[i];
    //    capletDisplacedVols[i] = todaysForwards[i]*mktCapletVols[i]/
    //                            (todaysForwards[i]+displacement);
    capletVols_[i]= mktCapletVols[i];
}

for (Size i=0; i<numberOfRates; ++i) {
swapVariances[i] = boost::shared_ptr<PiecewiseConstantVariance>(new
    PiecewiseConstantAbcdVariance(a_, b_, c_, d_,
                                  i, rateTimes_));
}

for (Size i=0; i<numberOfRates; ++i) {
capletVols[i] = std::sqrt(capletTotCovariance[i][i]/rateTimes_[i]);
}

for (Size i=0; i<numberOfRates; ++i) {
Volatility expSwaptionVol = swapVariances[i]->totalVolatility(i);
swapTerminalCovariance += swapPseudoRoots[i] * transpose(swapPseudoRoots[i]);
Volatility swaptionVol = std::sqrt(swapTerminalCovariance[i][i]/rateTimes_[i]);
error = std::fabs(swaptionVol-expSwaptionVol);
if (error>swapTolerance)
    BOOST_ERROR("failed to reproduce " << io::ordinal(i+1) << " swaption vol:"
                "\n expected:  " << io::rate(expSwaptionVol) <<
                "\n realized:  " << io::rate(swaptionVol) <<
                "\n error:     " << error <<
                "\n tolerance: " << swapTolerance);
}

for (Size i=0; i<numberOfRates; ++i) {
error = std::fabs(capletVols[i]-capletVols_[i]);
if (error>capletTolerance)
    BOOST_ERROR("failed to reproduce " << io::ordinal(i+1) << " caplet vol:"
                "\n expected:         " << io::rate(capletVols_[i]) <<
                "\n realized:         " << io::rate(capletVols[i]) <<
                "\n percentage error: " << error/capletVols_[i] <<
                "\n error:            " << error <<
                "\n tolerance:        " << capletTolerance);
}

for (Size i=0; i <= numberBigRates; ++i)
bigRateTimes[i] = rateTimes_[i*period+offset];

for (Size i=0; i<numberBigRates; ++i) {
swapVariances.push_back(
    PiecewiseConstantAbcdVariance(a_, b_, c_, d_,
                                  i, bigRateTimes));
}

for (Size i=0; i<numberOfRates; ++i) {
capletVols[i] = std::sqrt(capletTotCovariance[i][i]/rateTimes_[i]);
}

for (Size i=0; i<numberOfRates; ++i) {
error = std::fabs(capletVols[i]-capletVols_[i]);
if (error>capletTolerance)
    BOOST_ERROR("failed to reproduce " << io::ordinal(i+1) << " caplet vol:"
                "\n expected:         " << io::rate(capletVols_[i]) <<
                "\n realized:         " << io::rate(capletVols[i]) <<
                "\n percentage error: " << error/capletVols_[i] <<
                "\n error:            " << error <<
                "\n tolerance:        " << capletTolerance);
}

for (Size i=0; i<numberBigRates; ++i) {
Volatility expSwaptionVol = swapVariances[i].totalVolatility(i);
// Real cov = swapTerminalCovariance[i][i];
Time time = adaptedsmm->evolution().rateTimes()[i];
Volatility swaptionVol =  sqrt(swapTerminalCovariance[i][i]/time);

error = std::fabs(swaptionVol-expSwaptionVol);
if (error>swapTolerance)
    BOOST_ERROR("failed to reproduce " << io::ordinal(i) << " swaption vol:"
                "\n expected:  " << io::rate(expSwaptionVol) <<
                "\n realized:  " << io::rate(swaptionVol) <<
                "\n error:     " << error <<
                "\n tolerance: " << swapTolerance);
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/interestrates.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i<LENGTH(cases); i++) {
ir = InterestRate(cases[i].r, Actual360(),
                  cases[i].comp, cases[i].freq);
d2 = d1+Integer(360*cases[i].t+0.5)*Days;
roundingPrecision = Rounding(cases[i].precision);

// check that the compound factor is the inverse of the discount factor
compoundf = ir.compoundFactor(d1, d2);
disc = ir.discountFactor(d1, d2);
error = std::fabs(disc-1.0/compoundf);
if (error>1e-15)
    BOOST_FAIL("\n  " << ir
               << std::setprecision(16)
               << "\n  1.0/compound_factor: " << 1.0/compoundf
               << "\n  discount_factor:     " << disc
               << "\n  error:               " << error);

// check that the equivalent InterestRate with *same* daycounter,
// compounding, and frequency is the *same* InterestRate
ir2 = ir.equivalentRate(ir.dayCounter(),
                        ir.compounding(),
                        ir.frequency(),
                        d1, d2);
error = std::fabs(ir.rate()-ir2.rate());
if (error>1e-15)
    BOOST_FAIL(std::setprecision(12)
               << "\n    original interest rate: " << ir
               << "\n  equivalent interest rate: " << ir2
               << "\n                rate error: " << error);
if (ir.dayCounter()!=ir2.dayCounter())
    BOOST_FAIL("\n day counter error"
               << "\n original interest rate:   " << ir
               << "\n equivalent interest rate: " << ir2);
if (ir.compounding()!=ir2.compounding())
    BOOST_FAIL("\n compounding error"
               << "\n original interest rate:   " << ir
               << "\n equivalent interest rate: " << ir2);
if (ir.frequency()!=ir2.frequency())
    BOOST_FAIL("\n frequency error"
               << "\n    original interest rate: " << ir
               << "\n  equivalent interest rate: " << ir2);

// check that the equivalent rate with *same* daycounter,
// compounding, and frequency is the *same* rate
r2 = ir.equivalentRate(ir.dayCounter(),
                       ir.compounding(),
                       ir.frequency(),
                       d1, d2);
error = std::fabs(ir.rate()-r2);
if (error>1e-15)
    BOOST_FAIL(std::setprecision(12)
               << "\n    original rate: " << ir
               << "\n  equivalent rate: " << io::rate(r2)
               << "\n            error: " << error);

// check that the equivalent InterestRate with *different*
// compounding, and frequency is the *expected* InterestRate
ir3 = ir.equivalentRate(ir.dayCounter(),
                        cases[i].comp2, cases[i].freq2,
                        d1, d2);
expectedIR = InterestRate(cases[i].expected, ir.dayCounter(),
                          cases[i].comp2, cases[i].freq2);
r3 = roundingPrecision(ir3.rate());
error = std::fabs(r3-expectedIR.rate());
if (error>1.0e-17)
    BOOST_FAIL(std::setprecision(cases[i].precision+1)
               << "\n               original interest rate: " << ir
               << "\n  calculated equivalent interest rate: " << ir3
               << "\n            truncated equivalent rate: "
               << io::rate(r3)
               << "\n    expected equivalent interest rate: "
               << expectedIR
               << "\n                           rate error: "
               << error);
if (ir3.dayCounter()!=expectedIR.dayCounter())
    BOOST_FAIL("\n day counter error"
               << "\n    original interest rate: " << ir3
               << "\n  equivalent interest rate: " << expectedIR);
if (ir3.compounding()!=expectedIR.compounding())
    BOOST_FAIL("\n compounding error"
               << "\n    original interest rate: " << ir3
               << "\n  equivalent interest rate: " << expectedIR);
if (ir3.frequency()!=expectedIR.frequency())
    BOOST_FAIL("\n frequency error"
               << "\n    original interest rate: " << ir3
               << "\n  equivalent interest rate: " << expectedIR);

// check that the equivalent rate with *different*
// compounding, and frequency is the *expected* rate
r3 = ir.equivalentRate(ir.dayCounter(),
                       cases[i].comp2, cases[i].freq2,
                       d1, d2);
r3 = roundingPrecision(r3);
error = std::fabs(r3-cases[i].expected);
if (error>1.0e-17)
    BOOST_FAIL(std::setprecision(cases[i].precision-2)
               << "\n  calculated equivalent rate: " << io::rate(r3)
               << "\n    expected equivalent rate: "
               << io::rate(cases[i].expected)
               << "\n                       error: " << error);
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/operators.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i<n; ++i) {
if (final[i]!=original[i])
    BOOST_FAIL("\n applyTo + solveFor does not equal identity:"
               "\n            original vector: " << original <<
               "\n         transformed vector: " << intermediate <<
               "\n inverse transformed vector: " << final);
}

for (Size i=0; i<n; ++i) {
if (temp[i]!=intermediate[i])
    BOOST_FAIL("\n solveFor altered rhs:"
               "\n            original vector: " << original <<
               "\n         transformed vector: " << intermediate <<
               "\n altered transformed vector: " << temp <<
               "\n inverse transformed vector: " << final);
}

for (Size i=0; i<n; ++i) {
if (final[i]!=original[i])
    BOOST_FAIL("\n applyTo + solveFor does not equal identity:"
               "\n            original vector: " << original <<
               "\n         transformed vector: " << intermediate <<
               "\n inverse transformed vector: " << final);
}

for (Size i=0; i<n; ++i) {
if (temp[i]!=intermediate[i])
    BOOST_FAIL("\n solveFor altered rhs:"
               "\n            original vector: " << original <<
               "\n         transformed vector: " << intermediate <<
               "\n altered transformed vector: " << temp <<
               "\n inverse transformed vector: " << final);
}

for (Size i=0; i<n; ++i) {
if (final[i]!=original[i])
    BOOST_FAIL("\n applyTo + solveFor does not equal identity:"
               "\n            original vector: " << original <<
               "\n         transformed vector: " << intermediate <<
               "\n inverse transformed vector: " << final);
}

for (Size i=0; i<n; ++i) {
delta = final[i]-original[i];
error += delta * delta;
if (temp[i]!=intermediate[i])
    BOOST_FAIL("\n SOR altered rhs:"
               "\n            original vector: " << original <<
               "\n         transformed vector: " << intermediate <<
               "\n altered transformed vector: " << temp <<
               "\n inverse transformed vector: " << final);
}

for (i=0; i<N; i++)
x[i] = xMin+h*i;

for (i=0; i<x.size(); i++)
yd[i] = normal.derivative(x[i]);

for (i = 0; i < grid.size(); i++) {
grid[i] = price;
// FLOATING_POINT_EXCEPTION
price *= factor;
}

for (i=2; i<grid.size()-2; i++) {
if (std::fabs(lderror[i]) > tolerance ||
    std::fabs(derror[i]) > tolerance ||
    std::fabs(uderror[i]) > tolerance) {
    BOOST_FAIL("inconsistency between BSM operators:\n"
               << io::ordinal(i) << " row:\n"
               << "expected:   "
               << ref.lowerDiagonal()[i] << ", "
               << ref.diagonal()[i] << ", "
               << ref.upperDiagonal()[i] << "\n"
               << "calculated: "
               << op1.lowerDiagonal()[i] << ", "
               << op1.diagonal()[i] << ", "
               << op1.upperDiagonal()[i]);
}
}

for (i=2; i<grid.size()-2; i++) {
if (std::fabs(lderror[i]) > tolerance ||
    std::fabs(derror[i]) > tolerance ||
    std::fabs(uderror[i]) > tolerance) {
    BOOST_FAIL("inconsistency between BSM operators:\n"
               << io::ordinal(i) << " row:\n"
               << "expected:   "
               << ref.lowerDiagonal()[i] << ", "
               << ref.diagonal()[i] << ", "
               << ref.upperDiagonal()[i] << "\n"
               << "calculated: "
               << op2.lowerDiagonal()[i] << ", "
               << op2.diagonal()[i] << ", "
               << op2.upperDiagonal()[i]);
}
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/basketoption.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i<LENGTH(values); i++) {

boost::shared_ptr<PlainVanillaPayoff> payoff(new
    PlainVanillaPayoff(values[i].type, values[i].strike));

Date exDate = today + Integer(values[i].t*360+0.5);
boost::shared_ptr<Exercise> exercise(new EuropeanExercise(exDate));

spot1 ->setValue(values[i].s1);
spot2 ->setValue(values[i].s2);
qRate1->setValue(values[i].q1);
qRate2->setValue(values[i].q2);
rRate ->setValue(values[i].r );
vol1  ->setValue(values[i].v1);
vol2  ->setValue(values[i].v2);


boost::shared_ptr<PricingEngine> analyticEngine;
boost::shared_ptr<GeneralizedBlackScholesProcess> p1, p2;
switch(values[i].basketType) {
  case MaxBasket: 
  case MinBasket:
    p1 = boost::shared_ptr<GeneralizedBlackScholesProcess>(
        new BlackScholesMertonProcess(
                                Handle<Quote>(spot1),
                                Handle<YieldTermStructure>(qTS1),
                                Handle<YieldTermStructure>(rTS),
                                Handle<BlackVolTermStructure>(volTS1)));
    p2 = boost::shared_ptr<GeneralizedBlackScholesProcess>(
        new BlackScholesMertonProcess(
                                Handle<Quote>(spot2),
                                Handle<YieldTermStructure>(qTS2),
                                Handle<YieldTermStructure>(rTS),
                                Handle<BlackVolTermStructure>(volTS2)));
    analyticEngine=boost::shared_ptr<PricingEngine>(
        new StulzEngine(p1, p2, values[i].rho));
    break;
  case SpreadBasket:
      p1 = boost::shared_ptr<GeneralizedBlackScholesProcess>(
          new BlackProcess(Handle<Quote>(spot1),
                           Handle<YieldTermStructure>(rTS),
                           Handle<BlackVolTermStructure>(volTS1)));
      p2 = boost::shared_ptr<GeneralizedBlackScholesProcess>(
          new BlackProcess(Handle<Quote>(spot2),
                           Handle<YieldTermStructure>(rTS),
                           Handle<BlackVolTermStructure>(volTS2)));
      
      analyticEngine=boost::shared_ptr<PricingEngine>(
          new KirkEngine(boost::dynamic_pointer_cast<BlackProcess>(p1), 
                         boost::dynamic_pointer_cast<BlackProcess>(p2), 
                         values[i].rho));
    break;
  default:
      QL_FAIL("unknown basket type");
}

std::vector<boost::shared_ptr<StochasticProcess1D> > procs;
procs.push_back(p1);
procs.push_back(p2);

Matrix correlationMatrix(2,2, values[i].rho);
for (Integer j=0; j < 2; j++) {
    correlationMatrix[j][j] = 1.0;
}

boost::shared_ptr<StochasticProcessArray> process(
                 new StochasticProcessArray(procs,correlationMatrix));

boost::shared_ptr<PricingEngine> mcEngine =
    MakeMCEuropeanBasketEngine<PseudoRandom, Statistics>(process)
    .withStepsPerYear(1)
    .withSamples(10000)
    .withSeed(42);

boost::shared_ptr<PricingEngine> fdEngine(
            new Fd2dBlackScholesVanillaEngine(p1, p2, values[i].rho,
                                              50, 50, 15));

BasketOption basketOption(basketTypeToPayoff(values[i].basketType,
                                             payoff),
                          exercise);

// analytic engine
basketOption.setPricingEngine(analyticEngine);
Real calculated = basketOption.NPV();
Real expected = values[i].result;
Real error = std::fabs(calculated-expected);
if (error > values[i].tol) {
    REPORT_FAILURE_2("value", values[i].basketType, payoff, exercise,
                     values[i].s1, values[i].s2, values[i].q1,
                     values[i].q2, values[i].r, today, values[i].v1,
                     values[i].v2, values[i].rho, values[i].result,
                     calculated, error, values[i].tol);
}

// fd engine
basketOption.setPricingEngine(fdEngine);
calculated = basketOption.NPV();
Real relError = relativeError(calculated, expected, expected);
if (relError > mcRelativeErrorTolerance ) {
    REPORT_FAILURE_2("FD value", values[i].basketType, payoff,
                     exercise, values[i].s1, values[i].s2,
                     values[i].q1, values[i].q2, values[i].r,
                     today, values[i].v1, values[i].v2, values[i].rho,
                     values[i].result, calculated, relError,
                     fdRelativeErrorTolerance);
}

// mc engine
basketOption.setPricingEngine(mcEngine);
calculated = basketOption.NPV();
relError = relativeError(calculated, expected, values[i].s1);
if (relError > mcRelativeErrorTolerance ) {
    REPORT_FAILURE_2("MC value", values[i].basketType, payoff,
                     exercise, values[i].s1, values[i].s2,
                     values[i].q1, values[i].q2, values[i].r,
                     today, values[i].v1, values[i].v2, values[i].rho,
                     values[i].result, calculated, relError,
                     mcRelativeErrorTolerance);
}

}

for (Size i=0; i<LENGTH(values); i++) {

boost::shared_ptr<PlainVanillaPayoff> payoff(new
    PlainVanillaPayoff(values[i].type, values[i].strike));

Date exDate = today + Integer(values[i].t)*30;
boost::shared_ptr<Exercise> exercise(new EuropeanExercise(exDate));
boost::shared_ptr<Exercise> amExercise(new AmericanExercise(today,
                                                            exDate));

spot1 ->setValue(values[i].s1);
spot2 ->setValue(values[i].s2);
spot3 ->setValue(values[i].s3);
rRate ->setValue(values[i].r );
vol1  ->setValue(values[i].v1);
vol2  ->setValue(values[i].v2);
vol3  ->setValue(values[i].v3);

boost::shared_ptr<StochasticProcess1D> stochProcess1(new
    BlackScholesMertonProcess(Handle<Quote>(spot1),
                              Handle<YieldTermStructure>(qTS),
                              Handle<YieldTermStructure>(rTS),
                              Handle<BlackVolTermStructure>(volTS1)));

boost::shared_ptr<StochasticProcess1D> stochProcess2(new
    BlackScholesMertonProcess(Handle<Quote>(spot2),
                              Handle<YieldTermStructure>(qTS),
                              Handle<YieldTermStructure>(rTS),
                              Handle<BlackVolTermStructure>(volTS2)));

boost::shared_ptr<StochasticProcess1D> stochProcess3(new
    BlackScholesMertonProcess(Handle<Quote>(spot3),
                              Handle<YieldTermStructure>(qTS),
                              Handle<YieldTermStructure>(rTS),
                              Handle<BlackVolTermStructure>(volTS3)));

std::vector<boost::shared_ptr<StochasticProcess1D> > procs;
procs.push_back(stochProcess1);
procs.push_back(stochProcess2);
procs.push_back(stochProcess3);

Matrix correlation(3,3, values[i].rho);
for (Integer j=0; j < 3; j++) {
    correlation[j][j] = 1.0;
}

// FLOATING_POINT_EXCEPTION
boost::shared_ptr<StochasticProcessArray> process(
                       new StochasticProcessArray(procs,correlation));

// use a 3D sobol sequence...
// Think long and hard before moving to more than 1 timestep....
boost::shared_ptr<PricingEngine> mcQuasiEngine =
    MakeMCEuropeanBasketEngine<LowDiscrepancy>(process)
    .withStepsPerYear(1)
    .withSamples(8091)
    .withSeed(42);

BasketOption euroBasketOption(basketTypeToPayoff(values[i].basketType,
                                                 payoff),
                              exercise);
euroBasketOption.setPricingEngine(mcQuasiEngine);

Real expected = values[i].euroValue;
Real calculated = euroBasketOption.NPV();
Real relError = relativeError(calculated, expected, values[i].s1);
Real mcRelativeErrorTolerance = 0.01;
if (relError > mcRelativeErrorTolerance ) {
    REPORT_FAILURE_3("MC Quasi value", values[i].basketType, payoff,
                     exercise, values[i].s1, values[i].s2,
                     values[i].s3, values[i].r, today, values[i].v1,
                     values[i].v2, values[i].v3, values[i].rho,
                     values[i].euroValue, calculated, relError,
                     mcRelativeErrorTolerance);
}


Size requiredSamples = 1000;
Size timeSteps = 500;
BigNatural seed = 1;
boost::shared_ptr<PricingEngine> mcLSMCEngine =
    MakeMCAmericanBasketEngine<>(process)
    .withSteps(timeSteps)
    .withAntitheticVariate()
    .withSamples(requiredSamples)
    .withCalibrationSamples(requiredSamples/4)
    .withSeed(seed);

BasketOption amBasketOption(basketTypeToPayoff(values[i].basketType,
                                               payoff),
                            amExercise);
amBasketOption.setPricingEngine(mcLSMCEngine);

expected = values[i].amValue;
calculated = amBasketOption.NPV();
relError = relativeError(calculated, expected, values[i].s1);
Real mcAmericanRelativeErrorTolerance = 0.01;
if (relError > mcAmericanRelativeErrorTolerance) {
    REPORT_FAILURE_3("MC LSMC Value", values[i].basketType, payoff,
                     exercise, values[i].s1, values[i].s2,
                     values[i].s3, values[i].r, today, values[i].v1,
                     values[i].v2, values[i].v3, values[i].rho,
                     values[i].amValue, calculated, relError,
                     mcRelativeErrorTolerance);
}

}

for (Integer j=0; j < 3; j++) {
correlation[j][j] = 1.0;
}

for (Size i=0; i<LENGTH(values); i++) {
boost::shared_ptr<PlainVanillaPayoff> payoff(new
    PlainVanillaPayoff(values[i].type, values[i].strike));

Date exDate = today + Integer(values[i].t*360+0.5);
boost::shared_ptr<Exercise> exercise(new AmericanExercise(today,
                                                          exDate));

spot1 ->setValue(values[i].s);
vol1  ->setValue(values[i].v);
rRate ->setValue(values[i].r);
qRate ->setValue(values[i].q);

BasketOption basketOption(// process,
                          basketTypeToPayoff(MaxBasket, payoff),
                          exercise);
basketOption.setPricingEngine(mcLSMCEngine);

Real calculated = basketOption.NPV();
Real expected = values[i].result;
// Real errorEstimate = basketOption.errorEstimate();
Real relError = relativeError(calculated, expected, values[i].s);
// Real error = std::fabs(calculated-expected);

if (relError > values[i].tol) {
    BOOST_FAIL("expected value: " << values[i].result << "\n"
               << "calculated:     " << calculated);
}

}

for (Size i=0; i<LENGTH(values); i++) {
boost::shared_ptr<PlainVanillaPayoff> payoff(new
    PlainVanillaPayoff(values[i].type, values[i].strike));

Date exDate = today + Integer(values[i].t*360+0.5);
boost::shared_ptr<Exercise> exercise(new AmericanExercise(today,
                                                          exDate));

spot1 ->setValue(values[i].s);
vol1  ->setValue(values[i].v);
rRate ->setValue(values[i].r);
qRate ->setValue(values[i].q);

BasketOption basketOption(// process,
                          basketTypeToPayoff(MaxBasket, payoff),
                          exercise);
basketOption.setPricingEngine(mcLSMCEngine);

Real calculated = basketOption.NPV();
Real expected = values[i].result;
// Real errorEstimate = basketOption.errorEstimate();
Real relError = relativeError(calculated, expected, values[i].s);
// Real error = std::fabs(calculated-expected);

if (relError > values[i].tol) {
    BOOST_FAIL("expected value: " << values[i].result << "\n"
               << "calculated:     " << calculated);
}

}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/ode.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Real t=0.01; t < 11; t+=t) {
const Matrix calculated = Expm(m, t, tol);

Matrix expected(3, 3);
expected[0][0] = -3*std::exp(t)+4*std::exp(2*t);
expected[0][1] =  6*std::exp(t)-6*std::exp(2*t);
expected[0][2] =  6*std::exp(t)-6*std::exp(2*t);
expected[1][0] =    std::exp(t)-  std::exp(2*t);
expected[1][1] = -2*std::exp(t)+3*std::exp(2*t);
expected[1][2] = -2*std::exp(t)+2*std::exp(2*t);
expected[2][0] = -3*std::exp(t)+3*std::exp(2*t);
expected[2][1] =  6*std::exp(t)-6*std::exp(2*t);
expected[2][2] =  6*std::exp(t)-5*std::exp(2*t);

Matrix diff = calculated - expected;
Real relDiffNorm = frobenuiusNorm(diff)/frobenuiusNorm(expected);

if ( std::fabs(relDiffNorm) > 100*tol) {
    BOOST_FAIL("Failed to reproduce expected matrix exponential."
            << "\n rel. difference norm: " << relDiffNorm
            << "\n tolerance           : " << 100*tol);
}

const Matrix negativeTime = Expm((-1)*m, -t, tol);
diff = negativeTime - expected;
relDiffNorm = frobenuiusNorm(diff)/frobenuiusNorm(expected);

if ( std::fabs(relDiffNorm) > 100*tol) {
    BOOST_FAIL("Failed to reproduce expected matrix exponential."
            << "\n rel. difference norm: " << relDiffNorm
            << "\n tolerance           : " << 100*tol);
}

}

for (Size i=0; i < calculated.rows(); ++i) {
for (Size j=0; j < calculated.columns(); ++j) {
    const Real kroneckerDelta = (i==j)? 1.0 : 0.0;
    if (std::fabs(calculated[i][j] -kroneckerDelta) > tol) {
        BOOST_FAIL("Failed to reproduce expected matrix exponential."
                << "\n tolerance           : " << tol);
    }
}
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/marketmodel_smm.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=1; i<dates.size(); ++i)
    rateTimes[i-1] = dayCounter.yearFraction(todaysDate, dates[i]);

for (Size i=1; i<rateTimes.size(); ++i)
    accruals[i-1] = rateTimes[i] - rateTimes[i-1];

for (Size i=0; i<todaysForwards.size(); ++i) {
    todaysForwards[i] = 0.03 + 0.0010*i;
    //todaysForwards[i] = 0.04;
}

for (Size i=1; i<rateTimes.size(); ++i)
    todaysDiscounts[i] = todaysDiscounts[i-1] /
        (1.0+todaysForwards[i-1]*accruals[i-1]);

for (Size i=0; i<todaysSwaps.size(); i++) {
    volatilities[i] = todaysSwaps[i]*mktVols[i]/
        (todaysSwaps[i]+displacement);
    blackVols[i]= mktVols[i];
}

for (Size i=0; i<N; ++i) {
    Real expectedNPV = curveState_lmm.coterminalSwapAnnuity(i, i)
        * (todaysSwaps[i]-fixedRate) * todaysDiscounts[i];
    expectedNPVs[i] = expectedNPV;
    discrepancies[i] = (results[i]-expectedNPVs[i])/errors[i];
    maxError = std::max(std::fabs(discrepancies[i]), maxError);
}

    for (Size i=0; i<N; ++i) {
        BOOST_TEST_MESSAGE(
                      io::ordinal(i+1) << " coterminal swap NPV: "
                      << io::rate(results[i])
                      << " +- " << io::rate(errors[i])
                      << "; expected: " << io::rate(expectedNPVs[i])
                      << "; discrepancy/error = "
                      << discrepancies[N-1-i]
                      << " standard errors");
    }

for (Size i=0; i<N; ++i) {
    Real expectedSwaption =
        BlackCalculator(displacedPayoff[i],
                        todaysSwaps[i]+displacement,
                        volatilities[i]*std::sqrt(rateTimes[i]),
                        curveState_lmm.coterminalSwapAnnuity(i,i) *
                        todaysDiscounts[i]).value();
    expectedSwaptions[i] = expectedSwaption;
    discrepancies[i] = (results[N+i]-expectedSwaptions[i])/errors[N+i];
    maxError = std::max(std::fabs(discrepancies[i]), maxError);
}

    for (Size i=1; i<=N; ++i) {
        BOOST_TEST_MESSAGE(
                      io::ordinal(i) << " Swaption: "
                      << io::rate(results[2*N-i])
                      << " +- " << io::rate(errors[2*N-i])
                      << "; expected: " << io::rate(expectedSwaptions[N-i])
                      << "; discrepancy/error = "
                      << io::percent(discrepancies[N-i])
                      << " standard errors");
    }

for (Size i=0; i<undisplacedPayoff.size(); ++i) {
displacedPayoff[i] = boost::shared_ptr<StrikedTypePayoff>(new
    PlainVanillaPayoff(Option::Call, fixedRate+displacement));

undisplacedPayoff[i] = boost::shared_ptr<StrikedTypePayoff>(new
    PlainVanillaPayoff(Option::Call, fixedRate));
}

for (Size j=0; j<LENGTH(marketModels); j++) {
Size testedFactors[] = { /*4, 8,*/ todaysForwards.size()};
for (Size m=0; m<LENGTH(testedFactors); ++m) {
    Size factors = testedFactors[m];
    // Composite's ProductSuggested is the Terminal one
    MeasureType measures[] = { // ProductSuggested,
                               Terminal,
                               //MoneyMarketPlus,
                               MoneyMarket};
    for (Size k=0; k<LENGTH(measures); k++) {
        std::vector<Size> numeraires = makeMeasure(product, measures[k]);
        boost::shared_ptr<MarketModel> marketModel =
            makeMarketModel(evolution, factors, marketModels[j]);
        EvolverType evolvers[] = { Pc /*, Ipc */};
        boost::shared_ptr<MarketModelEvolver> evolver;
        Size stop = isInTerminalMeasure(evolution, numeraires) ? 0 : 1;
        for (Size i=0; i<LENGTH(evolvers)-stop; i++) {
            for (Size n=0; n<1; n++) {
                //MTBrownianGeneratorFactory generatorFactory(seed_);
                SobolBrownianGeneratorFactory generatorFactory(
                            SobolBrownianGenerator::Diagonal, seed_);
                evolver = makeMarketModelEvolver(marketModel,
                                                 numeraires,
                                                 generatorFactory,
                                                 evolvers[i]);
                std::ostringstream config;
                config <<
                    marketModelTypeToString(marketModels[j]) << ", " <<
                    factors << (factors>1 ? (factors==todaysForwards.size() ? " (full) factors, " : " factors, ") : " factor,") <<
                    measureTypeToString(measures[k]) << ", " <<
                    evolverTypeToString(evolvers[i]) << ", " <<
                    "MT BGF";
                if (printReport_)
                    BOOST_TEST_MESSAGE("    " << config.str());
                boost::shared_ptr<SequenceStatisticsInc> stats = simulate(evolver, product);
                checkCoterminalSwapsAndSwaptions(*stats, fixedRate,
                                                 displacedPayoff, marketModel,config.str());
            }
        }
    }
}
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/inflation.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i<N; i++) {
    Date maturity = iiData[i].date;
    Handle<Quote> quote(boost::shared_ptr<Quote>(
        new SimpleQuote(iiData[i].rate/100.0)));
    boost::shared_ptr<BootstrapHelper<T> > anInstrument(new U(
        quote, observationLag, maturity,
        calendar, bdc, dc, ii));
    instruments.push_back(anInstrument);
}

for (Size i=0; i<LENGTH(fixData); i++) {
iir->addFixing(rpiSchedule[i], fixData[i]);
}

for (Size i=0; i<rpiSchedule.size()-1;i++) {
std::pair<Date,Date> lim = inflationPeriod(rpiSchedule[i],
                                           iir->frequency());
for (Date d=lim.first; d<=lim.second; d++) {
    if (d < inflationPeriod(todayMinusLag,iir->frequency()).first) {
        if (std::fabs(iir->fixing(d) - fixData[i]) > eps)
            BOOST_ERROR("Fixings not constant within a period: "
                        << iir->fixing(d)
                        << ", should be " << fixData[i]);
    }
}
}

for (Size i=0; i<LENGTH(fixData); i++) {
iiUKRPI->addFixing(rpiSchedule[i], fixData[i]);
}

for (Size i=0; i<LENGTH(zcData); i++) {
BOOST_REQUIRE_MESSAGE(std::fabs(zcData[i].rate/100.0
    - pZITS->zeroRate(zcData[i].date, observationLag, forceLinearInterpolation)) < eps,
    "ZITS zeroRate != instrument "
    << pZITS->zeroRate(zcData[i].date, observationLag, forceLinearInterpolation)
    << " vs " << zcData[i].rate/100.0
    << " interpolation: " << ii->interpolated()
    << " forceLinearInterpolation " << forceLinearInterpolation);
BOOST_REQUIRE_MESSAGE(std::fabs(helpers[i]->impliedQuote()
    - zcData[i].rate/100.0) < eps,
    "ZITS implied quote != instrument "
    << helpers[i]->impliedQuote()
    << " vs " << zcData[i].rate/100.0);
}

for (Size i=0; i<testIndex.size();i++) {
Date d = testIndex[i];
Real z = hz->zeroRate(d, Period(0,Days));
Real t = hz->dayCounter().yearFraction(bd, d);
if(!ii->interpolated()) // because fixing constant over period
    t = hz->dayCounter().yearFraction(bd,
        inflationPeriod(d, ii->frequency()).first);
Real calc = bf * pow( 1+z, t);
if (t<=0)
    calc = ii->fixing(d,false); // still historical
if (std::fabs(calc - ii->fixing(d,true))/10000.0 > eps)
    BOOST_ERROR("ZC index does not forecast correctly for date " << d
                << " from base date " << bd
                << " with fixing " << bf
                << ", correct:  " << calc
                << ", fix: " << ii->fixing(d,true)
                << ", t " << t);
}

for(int i=0;i<12;i++){
if(std::fabs(fixing[i] - seasonalityFixing_1[i]) > eps) {
    BOOST_ERROR("Seasonality doesn't work correctly when seasonality factors are set = 1");
}
}

for(int i=0;i<12;i++){
if(std::fabs(expectedFixing[i] - seasonalityFixing_real[i]) > 0.01) {
    BOOST_ERROR("Seasonality doesn't work correctly when considering seasonality factors != 1 "
                << expectedFixing[i] << " vs " << seasonalityFixing_real[i]);
}
}

for(int i=0;i<12;i++){
if(std::fabs(seasonalityFixing_unset[i] - seasonalityFixing_1[i]) > eps) {
    BOOST_ERROR("UnsetSeasonality doesn't work correctly "
                << seasonalityFixing_unset[i] << " vs " << seasonalityFixing_1[i]);
}
}

for (Size i=0; i<LENGTH(fixData);i++) {
iiUKRPIyes->addFixing(rpiSchedule[i], fixData[i]);
}

for (Size i=0; i<LENGTH(zcData); i++) {
BOOST_CHECK_MESSAGE(std::fabs(zcData[i].rate/100.0
            - pZITSyes->zeroRate(zcData[i].date, observationLagyes, forceLinearInterpolation)) < eps,
            "ZITS INTERPOLATED zeroRate != instrument "
            << pZITSyes->zeroRate(zcData[i].date, observationLagyes, forceLinearInterpolation)
            << " date " << zcData[i].date << " observationLagyes " << observationLagyes
            << " vs " << zcData[i].rate/100.0
            << " interpolation: " << iiyes->interpolated()
            << " forceLinearInterpolation " << forceLinearInterpolation);
BOOST_CHECK_MESSAGE(std::fabs(helpersyes[i]->impliedQuote()
                - zcData[i].rate/100.0) < eps,
            "ZITS INTERPOLATED implied quote != instrument "
            << helpersyes[i]->impliedQuote()
            << " vs " << zcData[i].rate/100.0);
}

for (Size i=0; i<testIndex.size();i++) {
Date d = testIndex[i];
Real z = hz->zeroRate(d, Period(0,Days));
Real t = hz->dayCounter().yearFraction(bd, d);
Real calc = bf * pow( 1+z, t);
if (t<=0) calc = iiyes->fixing(d); // still historical
if (std::fabs(calc - iiyes->fixing(d)) > eps)
    BOOST_ERROR("ZC INTERPOLATED index does not forecast correctly for date " << d
                << " from base date " << bd
                << " with fixing " << bf
                << ", correct:  " << calc
                << ", fix: " << iiyes->fixing(d)
                << ", t " << t
                << ", zero " << z);
}

for (Size i=0; i<LENGTH(fixData);i++) {
iir->addFixing(rpiSchedule[i], fixData[i]);
iirYES->addFixing(rpiSchedule[i], fixData[i]);
}

for (Size i=13; i<rpiSchedule.size();i++) {
std::pair<Date,Date> lim = inflationPeriod(rpiSchedule[i],
                                           iir->frequency());
std::pair<Date,Date> limBef = inflationPeriod(rpiSchedule[i-12],
                                              iir->frequency());
for (Date d=lim.first; d<=lim.second; d++) {
    if (d < todayMinusLag) {
        Rate expected = fixData[i]/fixData[i-12] - 1.0;
        Rate calculated = iir->fixing(d);
        BOOST_CHECK_MESSAGE(std::fabs(calculated - expected) < eps,
                            "Non-interpolated fixings not constant within a period: "
                            << calculated
                            << ", should be "
                            << expected);

        Real dp= lim.second + 1- lim.first;
        Real dpBef=limBef.second + 1 - limBef.first;
        Real dl = d-lim.first;
        // potentially does not work on 29th Feb
        Real dlBef = NullCalendar().advance(d, -1*Years, ModifiedFollowing)
        -limBef.first;

        Real linearNow = fixData[i] + (fixData[i+1]-fixData[i])*dl/dp;
        Real linearBef = fixData[i-12] + (fixData[i+1-12]-fixData[i-12])*dlBef/dpBef;
        Rate expectedYES = linearNow / linearBef - 1.0;
        Rate calculatedYES = iirYES->fixing(d);
        BOOST_CHECK_MESSAGE(fabs(expectedYES-calculatedYES)<eps,
                            "Error in interpolated fixings: expect "<<expectedYES
                            <<" see " << calculatedYES
                            <<" flat " << calculated
                            <<", data: "<< fixData[i-12] <<", "<< fixData[i+1-12]
                            <<", "<<    fixData[i] <<", "<< fixData[i+1]
                            <<", fac: "<< dp <<", "<< dl
                            <<", "<< dpBef <<", "<< dlBef
                            <<", to: "<<linearNow<<", "<<linearBef
                            );
    }
}
}

for (Size i=0; i<LENGTH(fixData); i++) {
iir->addFixing(rpiSchedule[i], fixData[i]);
}

for (Size j = 1; j < LENGTH(yyData); j++) {

from = nominalTS->referenceDate();
to = yyData[j].date;
Schedule yoySchedule = MakeSchedule().from(from).to(to)
.withConvention(Unadjusted) // fixed leg gets calendar from
.withCalendar(calendar)     // schedule
.withTenor(1*Years)
.backwards()
;

YearOnYearInflationSwap yyS2(YearOnYearInflationSwap::Payer,
                                1000000.0,
                                yoySchedule,//fixed schedule, but same as yoy
                                yyData[j].rate/100.0,
                                dc,
                                yoySchedule,
                                iir,
                                observationLag,
                                0.0,        //spread on index
                                dc,
                                UnitedKingdom());

yyS2.setPricingEngine(sppe);



BOOST_CHECK_MESSAGE(fabs(yyS2.NPV())<eps,"fresh yoy swap NPV!=0 from TS "
        <<"swap quote for pt " << j
        << ", is " << yyData[j].rate/100.0
        <<" vs YoY rate "<< pYYTS->yoyRate(yyData[j].date-observationLag)
        <<" at quote date "<<(yyData[j].date-observationLag)
        <<", NPV of a fresh yoy swap is " << yyS2.NPV()
        <<"\n      fair rate " << yyS2.fairRate()
        <<" payment "<<yyS2.paymentConvention());
}

for (Size k = 0; k < 14; k++) {

from = nominalTS->referenceDate() - k*Months;
to = yyData[jj].date - k*Months;
Schedule yoySchedule = MakeSchedule().from(from).to(to)
.withConvention(Unadjusted) // fixed leg gets calendar from
.withCalendar(calendar)     // schedule
.withTenor(1*Years)
.backwards()
;

YearOnYearInflationSwap yyS3(YearOnYearInflationSwap::Payer,
                            1000000.0,
                            yoySchedule,//fixed schedule, but same as yoy
                            yyData[jj].rate/100.0,
                            dc,
                            yoySchedule,
                            iir,
                            observationLag,
                            0.0,        //spread on index
                            dc,
                            UnitedKingdom());

yyS3.setPricingEngine(sppe);

BOOST_CHECK_MESSAGE(fabs(yyS3.NPV())< 20000.0,
                    "unexpected size of aged YoY swap, aged "
                    <<k<<" months: YY aged NPV = " << yyS3.NPV()
                    <<", legs "<< yyS3.legNPV(0) << " and " << yyS3.legNPV(1)
                    );
}

for (Size i=1; i<=12; i++){
d = Date(1,Month(i),2009);

f = Monthly;
res = inflationPeriod (d,f);

f = Quarterly;
res = inflationPeriod (d,f);

f = Semiannual;
res = inflationPeriod (d,f);

f = Annual;
res = inflationPeriod (d,f);
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/gsr.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i = 1; i < 60; i++)
stepDates1.push_back(refDate + (i * 6 * Months));

for (Size i = 1; i < 60; i++)
stepDates1.push_back(refDate + (i * 6 * Months));

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/cms.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    for (Size i=0; i<nRows; ++i){
        volSpreads[i] = std::vector<Handle<Quote> >(nCols);
        for (Size j=0; j<nCols; ++j) {
            volSpreads[i][j] = Handle<Quote>(shared_ptr<Quote>(
                            new SimpleQuote(volSpreadsMatrix[i][j])));
        }
    }

    for (Size i=0; i<nRows; ++i) {
        guess[i] = std::vector<Handle<Quote> >(4);
        guess[i][0] =
            Handle<Quote>(shared_ptr<Quote>(new SimpleQuote(0.2)));
        guess[i][1] =
            Handle<Quote>(shared_ptr<Quote>(new SimpleQuote(0.5)));
        guess[i][2] =
            Handle<Quote>(shared_ptr<Quote>(new SimpleQuote(0.4)));
        guess[i][3] =
            Handle<Quote>(shared_ptr<Quote>(new SimpleQuote(0.0)));
    }

    for (Size j = 0; j < yieldCurveModels.size(); ++j) {
        if (j < yieldCurveModels.size() - 1)
            numericalPricers.push_back(
                shared_ptr<CmsCouponPricer>(new NumericHaganPricer(
                    atmVol, yieldCurveModels[j], zeroMeanRev)));
        else
            numericalPricers.push_back(shared_ptr<CmsCouponPricer>(
                new LinearTsrPricer(atmVol, zeroMeanRev)));

        analyticPricers.push_back(shared_ptr<CmsCouponPricer>(new
            AnalyticHaganPricer(atmVol, yieldCurveModels[j],
                                zeroMeanRev)));
    }

for (Size j=0; j<vars.yieldCurveModels.size(); ++j) {
vars.numericalPricers[j]->setSwaptionVolatility(vars.atmVol);
coupon.setPricer(vars.numericalPricers[j]);
Rate rate0 = coupon.rate();

vars.analyticPricers[j]->setSwaptionVolatility(vars.atmVol);
coupon.setPricer(vars.analyticPricers[j]);
Rate rate1 = coupon.rate();

Spread difference =  std::fabs(rate1-rate0);
Spread tol = 2.0e-4;
bool linearTsr = j==vars.yieldCurveModels.size()-1;

if (difference > tol)
    BOOST_FAIL("\nCoupon payment date: " << paymentDate <<
               "\nCoupon start date:   " << startDate <<
               "\nCoupon floor:        " << io::rate(infiniteFloor) <<
               "\nCoupon gearing:      " << io::rate(gearing) <<
               "\nCoupon swap index:   " << swapIndex->name() <<
               "\nCoupon spread:       " << io::rate(spread) <<
               "\nCoupon cap:          " << io::rate(infiniteCap) <<
               "\nCoupon DayCounter:   " << vars.iborIndex->dayCounter()<<
               "\nYieldCurve Model:    " << vars.yieldCurveModels[j] <<
               "\nNumerical Pricer:    " << io::rate(rate0) <<
                           (linearTsr ? " (Linear TSR Model)" : "") <<
               "\nAnalytic Pricer:     " << io::rate(rate1) <<
               "\ndifference:          " << io::rate(difference) <<
               "\ntolerance:           " << io::rate(tol));
}

for (Size i=0; i<n; ++i)
// no cap, floor
// no gearing, spread
cms[i] = MakeCms(Period(swapLengths[i], Years),
                 swapIndex,
                 vars.iborIndex, spread,
                 10*Days);

for (Size j=0; j<vars.yieldCurveModels.size(); ++j) {
vars.numericalPricers[j]->setSwaptionVolatility(vars.atmVol);
vars.analyticPricers[j]->setSwaptionVolatility(vars.atmVol);
for (Size sl=0; sl<n; ++sl) {
    setCouponPricer(cms[sl]->leg(0), vars.numericalPricers[j]);
    Real priceNum = cms[sl]->NPV();
    setCouponPricer(cms[sl]->leg(0), vars.analyticPricers[j]);
    Real priceAn = cms[sl]->NPV();

    Real difference =  std::fabs(priceNum-priceAn);
    Real tol = 2.0e-4;
    bool linearTsr = j==vars.yieldCurveModels.size()-1;
    if (difference > tol)
        BOOST_FAIL("\nLength in Years:  " << swapLengths[sl] <<
                   //"\nfloor:            " << io::rate(infiniteFloor) <<
                   //"\ngearing:          " << io::rate(gearing) <<
                   "\nswap index:       " << swapIndex->name() <<
                   "\nibor index:       " << vars.iborIndex->name() <<
                   "\nspread:           " << io::rate(spread) <<
                   //"\ncap:              " << io::rate(infiniteCap) <<
                   "\nYieldCurve Model: " << vars.yieldCurveModels[j] <<
                   "\nNumerical Pricer: " << io::rate(priceNum) <<
                           (linearTsr ? " (Linear TSR Model)" : "") <<
                   "\nAnalytic Pricer:  " << io::rate(priceAn) <<
                   "\ndifference:       " << io::rate(difference) <<
                   "\ntolerance:        " << io::rate(tol));
}
}

for (Rate strike = .02; strike<.12; strike+=0.05) {
CappedFlooredCmsCoupon   caplet(paymentDate, nominal,
                                startDate, endDate,
                                swapIndex->fixingDays(),
                                swapIndex,
                                gearing, spread,
                                strike, infiniteFloor,
                                startDate, endDate,
                                vars.iborIndex->dayCounter());
CappedFlooredCmsCoupon floorlet(paymentDate, nominal,
                                startDate, endDate,
                                swapIndex->fixingDays(),
                                swapIndex,
                                gearing, spread,
                                infiniteCap, strike,
                                startDate, endDate,
                                vars.iborIndex->dayCounter());

for (Size i=0; i<swaptionVols.size(); ++i) {
    for (Size j=0; j<vars.yieldCurveModels.size(); ++j) {
        vars.numericalPricers[j]->setSwaptionVolatility(swaptionVols[i]);
        vars.analyticPricers[j]->setSwaptionVolatility(swaptionVols[i]);
        std::vector<shared_ptr<CmsCouponPricer> > pricers(2);
        pricers[0] = vars.numericalPricers[j];
        pricers[1] = vars.analyticPricers[j];
        for (Size k=0; k<pricers.size(); ++k) {
            swaplet.setPricer(pricers[k]);
            caplet.setPricer(pricers[k]);
            floorlet.setPricer(pricers[k]);
            Real swapletPrice = swaplet.price(vars.termStructure) +
                          nominal * swaplet.accrualPeriod() * strike * discount;
            Real capletPrice = caplet.price(vars.termStructure);
            Real floorletPrice = floorlet.price(vars.termStructure);
            Real difference = std::fabs(capletPrice + floorletPrice -
                                        swapletPrice);
            Real tol = 2.0e-5;
            bool linearTsr = k==0 && j==vars.yieldCurveModels.size()-1;
            if(linearTsr)
                tol = 1.0e-7;
            if (difference > tol)
                BOOST_FAIL("\nCoupon payment date: " << paymentDate <<
                           "\nCoupon start date:   " << startDate <<
                           "\nCoupon gearing:      " << io::rate(gearing) <<
                           "\nCoupon swap index:   " << swapIndex->name() <<
                           "\nCoupon spread:       " << io::rate(spread) <<
                           "\nstrike:              " << io::rate(strike) <<
                           "\nCoupon DayCounter:   " << vars.iborIndex->dayCounter() <<
                           "\nYieldCurve Model:    " << vars.yieldCurveModels[j] <<
                           (k==0 ? "\nNumerical Pricer" : "\nAnalytic Pricer") <<
                           (linearTsr ? " (Linear TSR Model)" : "") <<
                           "\nSwaplet price:       " << io::rate(swapletPrice) <<
                           "\nCaplet price:        " << io::rate(capletPrice) <<
                           "\nFloorlet price:      " << io::rate(floorletPrice) <<
                           "\ndifference:          " << difference <<
                           "\ntolerance:           " << io::rate(tol));
        }
    }
}
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/piecewisezerospreadedtermstructure.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    for (Size i = 0; i < 8; ++i) {
        dates.push_back(calendar.advance(today,ts[i],Days));
        rates.push_back(r[i]);
    }

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/pagodaoption.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=1; i<=4; ++i)
fixingDates.push_back(today+i*90);

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/cliquetoption.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i<LENGTH(types); i++) {
  for (Size j=0; j<LENGTH(moneyness); j++) {
    for (Size k=0; k<LENGTH(lengths); k++) {
      for (Size kk=0; kk<LENGTH(frequencies); kk++) {

        boost::shared_ptr<EuropeanExercise> maturity(
                      new EuropeanExercise(today + lengths[k]*Years));

        boost::shared_ptr<PercentageStrikePayoff> payoff(
                  new PercentageStrikePayoff(types[i], moneyness[j]));

        std::vector<Date> reset;
        for (Date d = today + Period(frequencies[kk]);
             d < maturity->lastDate();
             d += Period(frequencies[kk]))
            reset.push_back(d);

        boost::shared_ptr<PricingEngine> engine(new T(process));

        CliquetOption option(payoff, maturity, reset);
        option.setPricingEngine(engine);

        for (Size l=0; l<LENGTH(underlyings); l++) {
          for (Size m=0; m<LENGTH(qRates); m++) {
            for (Size n=0; n<LENGTH(rRates); n++) {
              for (Size p=0; p<LENGTH(vols); p++) {

                Real u = underlyings[l];
                Rate q = qRates[m],
                     r = rRates[n];
                Volatility v = vols[p];
                spot->setValue(u);
                qRate->setValue(q);
                rRate->setValue(r);
                vol->setValue(v);

                Real value = option.NPV();
                calculated["delta"]  = option.delta();
                calculated["gamma"]  = option.gamma();
                calculated["theta"]  = option.theta();
                calculated["rho"]    = option.rho();
                calculated["divRho"] = option.dividendRho();
                calculated["vega"]   = option.vega();

                if (value > spot->value()*1.0e-5) {
                  // perturb spot and get delta and gamma
                  Real du = u*1.0e-4;
                  spot->setValue(u+du);
                  Real value_p = option.NPV(),
                       delta_p = option.delta();
                  spot->setValue(u-du);
                  Real value_m = option.NPV(),
                       delta_m = option.delta();
                  spot->setValue(u);
                  expected["delta"] = (value_p - value_m)/(2*du);
                  expected["gamma"] = (delta_p - delta_m)/(2*du);

                  // perturb rates and get rho and dividend rho
                  Spread dr = r*1.0e-4;
                  rRate->setValue(r+dr);
                  value_p = option.NPV();
                  rRate->setValue(r-dr);
                  value_m = option.NPV();
                  rRate->setValue(r);
                  expected["rho"] = (value_p - value_m)/(2*dr);

                  Spread dq = q*1.0e-4;
                  qRate->setValue(q+dq);
                  value_p = option.NPV();
                  qRate->setValue(q-dq);
                  value_m = option.NPV();
                  qRate->setValue(q);
                  expected["divRho"] = (value_p - value_m)/(2*dq);

                  // perturb volatility and get vega
                  Volatility dv = v*1.0e-4;
                  vol->setValue(v+dv);
                  value_p = option.NPV();
                  vol->setValue(v-dv);
                  value_m = option.NPV();
                  vol->setValue(v);
                  expected["vega"] = (value_p - value_m)/(2*dv);

                  // perturb date and get theta
                  Time dT = dc.yearFraction(today-1, today+1);
                  Settings::instance().evaluationDate() = today-1;
                  value_m = option.NPV();
                  Settings::instance().evaluationDate() = today+1;
                  value_p = option.NPV();
                  Settings::instance().evaluationDate() = today;
                  expected["theta"] = (value_p - value_m)/dT;

                  // compare
                  std::map<std::string,Real>::iterator it;
                  for (it = calculated.begin();
                       it != calculated.end(); ++it) {
                      std::string greek = it->first;
                      Real expct = expected  [greek],
                           calcl = calculated[greek],
                           tol   = tolerance [greek];
                      Real error = relativeError(expct,calcl,u);
                      if (error>tol) {
                          REPORT_FAILURE(greek, payoff, maturity,
                                         u, q, r, today, v,
                                         expct, calcl, error, tol);
                      }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}

for (Size i=0; i<LENGTH(types); i++) {
for (Size j=0; j<LENGTH(moneyness); j++) {
for (Size k=0; k<LENGTH(lengths); k++) {
  for (Size kk=0; kk<LENGTH(frequencies); kk++) {

      Period tenor = Period(frequencies[kk]);
      boost::shared_ptr<EuropeanExercise> maturity(
                      new EuropeanExercise(today + lengths[k]*tenor));

      boost::shared_ptr<PercentageStrikePayoff> payoff(
                  new PercentageStrikePayoff(types[i], moneyness[j]));

      std::vector<Date> reset;
      for (Date d = today + tenor; d < maturity->lastDate(); d += tenor)
          reset.push_back(d);

      CliquetOption option(payoff, maturity, reset);

      boost::shared_ptr<PricingEngine> refEngine(
                              new AnalyticPerformanceEngine(process));

      boost::shared_ptr<PricingEngine> mcEngine =
          MakeMCPerformanceEngine<PseudoRandom>(process)
          .withBrownianBridge()
          .withAbsoluteTolerance(5.0e-3)
          .withSeed(42);

      for (Size l=0; l<LENGTH(underlyings); l++) {
        for (Size m=0; m<LENGTH(qRates); m++) {
          for (Size n=0; n<LENGTH(rRates); n++) {
            for (Size p=0; p<LENGTH(vols); p++) {

              Real u = underlyings[l];
              Rate q = qRates[m],
                   r = rRates[n];
              Volatility v = vols[p];
              spot->setValue(u);
              qRate->setValue(q);
              rRate->setValue(r);
              vol->setValue(v);

              option.setPricingEngine(refEngine);
              Real refValue = option.NPV();

              option.setPricingEngine(mcEngine);
              Real value = option.NPV();

              Real error = std::fabs(refValue-value);
              Real tolerance = 1.5e-2;
              if (error > tolerance) {
                  REPORT_FAILURE("value", payoff, maturity,
                                 u, q, r, today, v,
                                 refValue, value,
                                 error, tolerance);
              }
            }
          }
        }
      }
  }
}
}
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/partialtimebarrieroption.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i<LENGTH(cases); ++i) {
Date coverEventDate = today + cases[i].days;
boost::shared_ptr<StrikedTypePayoff> payoff =
    boost::make_shared<PlainVanillaPayoff>(type, cases[i].strike);
PartialTimeBarrierOption option(PartialBarrier::DownOut,
                                PartialBarrier::EndB1,
                                barrier, rebate,
                                coverEventDate,
                                payoff, exercise);
option.setPricingEngine(engine);

spot->setValue(cases[i].underlying);
Real calculated = option.NPV();
Real expected = cases[i].result;
Real error = std::fabs(calculated-expected);
Real tolerance = 1e-4;
if (error > tolerance)
    BOOST_ERROR("Failed to reproduce partial-time barrier option value"
                << "\n    expected:   " << expected
                << "\n    calculated: " << calculated
                << "\n    error:      " << error);
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/doublebinaryoption.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i<LENGTH(values); i++) {

boost::shared_ptr<StrikedTypePayoff> payoff(new CashOrNothingPayoff(
    Option::Call, 0, values[i].cash));

Date exDate = today + Integer(values[i].t*360+0.5);
boost::shared_ptr<Exercise> exercise;
if (values[i].barrierType == DoubleBarrier::KIKO ||
    values[i].barrierType == DoubleBarrier::KOKI)
    exercise.reset(new AmericanExercise(today, exDate));
else
    exercise.reset(new EuropeanExercise(exDate));

spot ->setValue(values[i].s);
qRate->setValue(values[i].q);
rRate->setValue(values[i].r);
vol  ->setValue(values[i].v);

boost::shared_ptr<BlackScholesMertonProcess> stochProcess(new
    BlackScholesMertonProcess(Handle<Quote>(spot),
                              Handle<YieldTermStructure>(qTS),
                              Handle<YieldTermStructure>(rTS),
                              Handle<BlackVolTermStructure>(volTS)));

// checking with analytic engine
boost::shared_ptr<PricingEngine> engine(
                     new AnalyticDoubleBarrierBinaryEngine(stochProcess));
DoubleBarrierOption opt(values[i].barrierType, 
                  values[i].barrier_lo, 
                  values[i].barrier_hi, 
                  0,
                  payoff,
                  exercise);
opt.setPricingEngine(engine);

Real calculated = opt.NPV();
Real expected = values[i].result;
Real error = std::fabs(calculated-expected);
if (error > values[i].tol) {
    REPORT_FAILURE("value", payoff, exercise, values[i].barrierType, 
                   values[i].barrier_lo, values[i].barrier_hi, values[i].s,
                   values[i].q, values[i].r, today, values[i].v,
                   values[i].result, calculated, error, values[i].tol);
}

Size steps = 500;
// checking with binomial engine
engine = boost::shared_ptr<PricingEngine>(
      new BinomialDoubleBarrierEngine<CoxRossRubinstein,
                      DiscretizedDoubleBarrierOption>(stochProcess, 
                                                         steps));
opt.setPricingEngine(engine);
calculated = opt.NPV();
expected = values[i].result;
error = std::fabs(calculated-expected);
double tol = 0.22;
if (error>tol) {
    REPORT_FAILURE("Binomial value", payoff, exercise, values[i].barrierType, 
                   values[i].barrier_lo, values[i].barrier_hi, values[i].s,
                   values[i].q, values[i].r, today, values[i].v,
                   values[i].result, calculated, error, tol);
}

}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/swaptionvolatilitycube.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    for (Size i=0; i<atm.tenors.options.size(); i++) {
      for (Size j=0; j<atm.tenors.swaps.size(); j++) {
        Rate strike = volCube.atmStrike(atm.tenors.options[i],
                                        atm.tenors.swaps[j]);
        Volatility expVol =
            atmVolMatrix->volatility(atm.tenors.options[i],
                                     atm.tenors.swaps[j],
                                     strike, true);
        Volatility actVol = volCube.volatility(atm.tenors.options[i],
                                               atm.tenors.swaps[j],
                                               strike, true);
        Volatility error = std::abs(expVol-actVol);
        if (error>tolerance)
          BOOST_ERROR("\nrecovery of atm vols failed:"
                      "\nexpiry time = " << atm.tenors.options[i] <<
                      "\nswap length = " << atm.tenors.swaps[j] <<
                      "\n atm strike = " << io::rate(strike) <<
                      "\n   exp. vol = " << io::volatility(expVol) <<
                      "\n actual vol = " << io::volatility(actVol) <<
                      "\n      error = " << io::volatility(error) <<
                      "\n  tolerance = " << tolerance);
      }
    }

    for (Size i=0; i<cube.tenors.options.size(); i++) {
      for (Size j=0; j<cube.tenors.swaps.size(); j++) {
        for (Size k=0; k<cube.strikeSpreads.size(); k++) {
          Rate atmStrike = volCube.atmStrike(cube.tenors.options[i],
                                             cube.tenors.swaps[j]);
          Volatility atmVol =
              atmVolMatrix->volatility(cube.tenors.options[i],
                                       cube.tenors.swaps[j],
                                       atmStrike, true);
          Volatility vol =
              volCube.volatility(cube.tenors.options[i],
                                 cube.tenors.swaps[j],
                                 atmStrike+cube.strikeSpreads[k], true);
          Volatility spread = vol-atmVol;
          Volatility expVolSpread =
              cube.volSpreads[i*cube.tenors.swaps.size()+j][k];
          Volatility error = std::abs(expVolSpread-spread);
          if (error>tolerance)
              BOOST_FAIL("\nrecovery of smile vol spreads failed:"
                         "\n    option tenor = " << cube.tenors.options[i] <<
                         "\n      swap tenor = " << cube.tenors.swaps[j] <<
                         "\n      atm strike = " << io::rate(atmStrike) <<
                         "\n   strike spread = " << io::rate(cube.strikeSpreads[k]) <<
                         "\n         atm vol = " << io::volatility(atmVol) <<
                         "\n      smiled vol = " << io::volatility(vol) <<
                         "\n      vol spread = " << io::volatility(spread) <<
                         "\n exp. vol spread = " << io::volatility(expVolSpread) <<
                         "\n           error = " << io::volatility(error) <<
                         "\n       tolerance = " << tolerance);
        }
      }
    }

for (Size i=0; i<vars.cube.tenors.options.size()*vars.cube.tenors.swaps.size(); i++) {
parametersGuess[i] = std::vector<Handle<Quote> >(4);
parametersGuess[i][0] =
    Handle<Quote>(boost::shared_ptr<Quote>(new SimpleQuote(0.2)));
parametersGuess[i][1] =
    Handle<Quote>(boost::shared_ptr<Quote>(new SimpleQuote(0.5)));
parametersGuess[i][2] =
    Handle<Quote>(boost::shared_ptr<Quote>(new SimpleQuote(0.4)));
parametersGuess[i][3] =
    Handle<Quote>(boost::shared_ptr<Quote>(new SimpleQuote(0.0)));
}

for (Size i=0; i<vars.cube.tenors.options.size()*vars.cube.tenors.swaps.size(); i++) {
parametersGuess[i] = std::vector<Handle<Quote> >(4);
parametersGuess[i][0] =
    Handle<Quote>(boost::shared_ptr<Quote>(new SimpleQuote(0.2)));
parametersGuess[i][1] =
    Handle<Quote>(boost::shared_ptr<Quote>(new SimpleQuote(0.5)));
parametersGuess[i][2] =
    Handle<Quote>(boost::shared_ptr<Quote>(new SimpleQuote(0.4)));
parametersGuess[i][3] =
    Handle<Quote>(boost::shared_ptr<Quote>(new SimpleQuote(0.0)));
}

for (Size k=1; k<100; k++)
strikes.push_back(k*.01);

for (Size i=0; i<vars.cube.tenors.options.size(); i++) {
for (Size j=0; j<vars.cube.tenors.swaps.size(); j++) {
    boost::shared_ptr<SmileSection> smileSectionByCube =
        volCube->smileSection(vars.cube.tenors.options[i], vars.cube.tenors.swaps[j]);
    boost::shared_ptr<SmileSection> smileSectionBySpreadedCube =
        spreadedVolCube->smileSection(vars.cube.tenors.options[i], vars.cube.tenors.swaps[j]);
    for (Size k=0; k<strikes.size(); k++) {
        Real strike = strikes[k];
        Real diff = spreadedVolCube->volatility(vars.cube.tenors.options[i], vars.cube.tenors.swaps[j], strike)
                    - volCube->volatility(vars.cube.tenors.options[i], vars.cube.tenors.swaps[j], strike);
        if (std::fabs(diff-spread->value())>1e-16)
            BOOST_ERROR("\ndiff!=spread in volatility method:"
                        "\nexpiry time = " << vars.cube.tenors.options[i] <<
                        "\nswap length = " << vars.cube.tenors.swaps[j] <<
                        "\n atm strike = " << io::rate(strike) <<
                        "\ndiff = " << diff <<
                        "\nspread = " << spread->value());

        diff = smileSectionBySpreadedCube->volatility(strike)
               - smileSectionByCube->volatility(strike);
        if (std::fabs(diff-spread->value())>1e-16)
            BOOST_ERROR("\ndiff!=spread in smile section method:"
                        "\nexpiry time = " << vars.cube.tenors.options[i] <<
                        "\nswap length = " << vars.cube.tenors.swaps[j] <<
                        "\n atm strike = " << io::rate(strike) <<
                        "\ndiff = " << diff <<
                        "\nspread = " << spread->value());

    }
}
}

for (Size i=0; i<vars.cube.tenors.options.size()*vars.cube.tenors.swaps.size(); i++) {
parametersGuess[i] = std::vector<Handle<Quote> >(4);
parametersGuess[i][0] =
    Handle<Quote>(boost::shared_ptr<Quote>(new SimpleQuote(0.2)));
parametersGuess[i][1] =
    Handle<Quote>(boost::shared_ptr<Quote>(new SimpleQuote(0.5)));
parametersGuess[i][2] =
    Handle<Quote>(boost::shared_ptr<Quote>(new SimpleQuote(0.4)));
parametersGuess[i][3] =
    Handle<Quote>(boost::shared_ptr<Quote>(new SimpleQuote(0.0)));
}

for (Size i=0;i<vars.cube.tenors.options.size(); i++ ) {
for (Size j=0; j<vars.cube.tenors.swaps.size(); j++) {
    for (Size k=0; k<vars.cube.strikeSpreads.size(); k++) {

        Volatility v0 = volCube1_0->volatility(vars.cube.tenors.options[i],
                                               vars.cube.tenors.swaps[j],
                                               dummyStrike + vars.cube.strikeSpreads[k],
                                               false);
        Volatility v1 = volCube1_1->volatility(vars.cube.tenors.options[i],
                                               vars.cube.tenors.swaps[j],
                                               dummyStrike + vars.cube.strikeSpreads[k],
                                               false);
        if (std::fabs(v0 - v1) > 1e-14)
            BOOST_ERROR(description <<
                        " option tenor = " << vars.cube.tenors.options[i] <<
                        " swap tenor = " << vars.cube.tenors.swaps[j] <<
                        " strike = " << io::rate(dummyStrike+vars.cube.strikeSpreads[k])<<
                        "  v0 = " << io::volatility(v0) <<
                        "  v1 = " << io::volatility(v1) <<
                        "  error = " << std::fabs(v1-v0));
    }
}
}

for (Size i=0;i<vars.cube.tenors.options.size(); i++ ) {
for (Size j=0; j<vars.cube.tenors.swaps.size(); j++) {
    for (Size k=0; k<vars.cube.strikeSpreads.size(); k++) {

        Volatility v0 = volCube2_0->volatility(vars.cube.tenors.options[i],
                                               vars.cube.tenors.swaps[j],
                                               dummyStrike + vars.cube.strikeSpreads[k],
                                               false);
        Volatility v1 = volCube2_1->volatility(vars.cube.tenors.options[i],
                                               vars.cube.tenors.swaps[j],
                                               dummyStrike + vars.cube.strikeSpreads[k],
                                               false);
        if (std::fabs(v0 - v1) > 1e-14)
            BOOST_ERROR(description <<
                        " option tenor = " << vars.cube.tenors.options[i] <<
                        " swap tenor = " << vars.cube.tenors.swaps[j] <<
                        " strike = " << io::rate(dummyStrike+vars.cube.strikeSpreads[k])<<
                        "  v0 = " << io::volatility(v0) <<
                        "  v1 = " << io::volatility(v1) <<
                        "  error = " << std::fabs(v1-v0));
    }
}
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/swaption.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i<LENGTH(exercises); i++) {
for (Size j=0; j<LENGTH(lengths); j++) {
    for (Size k=0; k<LENGTH(type); k++) {
        Date exerciseDate = vars.calendar.advance(vars.today,
                                                  exercises[i]);
        Date startDate =
            vars.calendar.advance(exerciseDate,
                                  vars.settlementDays,Days);
        // store the results for different rates...
        std::vector<Real> values;
        std::vector<Real> values_cash;
        Volatility vol = 0.20;
        for (Size l=0; l<LENGTH(strikes); l++) {
            boost::shared_ptr<VanillaSwap> swap =
                MakeVanillaSwap(lengths[j], vars.index, strikes[l])
                        .withEffectiveDate(startDate)
                        .withFixedLegTenor(1*Years)
                        .withFixedLegDayCount(vars.fixedDayCount)
                        .withFloatingLegSpread(0.0)
                        .withType(type[k]);
            boost::shared_ptr<Swaption> swaption =
                vars.makeSwaption(swap,exerciseDate,vol);
            // FLOATING_POINT_EXCEPTION
            values.push_back(swaption->NPV());
            boost::shared_ptr<Swaption> swaption_cash =
                vars.makeSwaption(swap,exerciseDate,vol,
                                  Settlement::Cash);
            values_cash.push_back(swaption_cash->NPV());
        }
        // and check that they go the right way
        if (type[k]==VanillaSwap::Payer) {
            std::vector<Real>::iterator it =
                std::adjacent_find(values.begin(), values.end(),
                                   std::less<Real>());
            if (it != values.end()) {
                Size n = it - values.begin();
                BOOST_ERROR("NPV of Payer swaption with delivery settlement"
                            "is increasing with the strike:" <<
                            "\noption tenor: " << exercises[i] <<
                            "\noption date:  " << exerciseDate <<
                            "\nvolatility:   " << io::rate(vol) <<
                            "\nswap tenor:   " << lengths[j] <<
                            "\nvalue:        " << values[n  ] <<" at strike: " << io::rate(strikes[n  ]) <<
                            "\nvalue:        " << values[n+1] << " at strike: " << io::rate(strikes[n+1]));
            }
            std::vector<Real>::iterator it_cash =
                std::adjacent_find(values_cash.begin(), values_cash.end(),
                                   std::less<Real>());
            if (it_cash != values_cash.end()) {
                Size n = it_cash - values_cash.begin();
                BOOST_ERROR("NPV of Payer swaption with cash settlement"
                            "is increasing with the strike:" <<
                            "\noption tenor: " << exercises[i] <<
                            "\noption date:  " << exerciseDate <<
                            "\nvolatility:   " << io::rate(vol) <<
                            "\nswap tenor:   " << lengths[j] <<
                            "\nvalue:        " << values_cash[n  ] << " at strike: " << io::rate(strikes[n  ]) <<
                            "\nvalue:        " << values_cash[n+1] << " at strike: " << io::rate(strikes[n+1]));
            }
        } else {
            std::vector<Real>::iterator it =
                std::adjacent_find(values.begin(), values.end(),
                                   std::greater<Real>());
            if (it != values.end()) {
                Size n = it - values.begin();
                BOOST_ERROR("NPV of Receiver swaption with delivery settlement"
                            "is increasing with the strike:" <<
                            "\noption tenor: " << exercises[i] <<
                            "\noption date:  " << exerciseDate <<
                            "\nvolatility:   " << io::rate(vol) <<
                            "\nswap tenor:   " << lengths[j] <<
                            "\nvalue:        " << values[n  ] << " at strike: " << io::rate(strikes[n  ]) <<
                            "\nvalue:        " << values[n+1] << " at strike: " << io::rate(strikes[n+1]));
            }
            std::vector<Real>::iterator it_cash =
                std::adjacent_find(values_cash.begin(), values_cash.end(),
                                   std::greater<Real>());
            if (it_cash != values_cash.end()) {
                Size n = it_cash - values_cash.begin();
                BOOST_ERROR("NPV of Receiver swaption with cash settlement"
                            "is increasing with the strike:" <<
                            "\noption tenor: " << exercises[i] <<
                            "\noption date:  " << exerciseDate <<
                            "\nvolatility:   " << io::rate(vol) <<
                            "\nswap tenor:   " << lengths[j] <<
                            "\nvalue:        " << values_cash[n  ] << " at strike: " << io::rate(strikes[n  ]) <<
                            "\nvalue:        " << values_cash[n+1] << " at strike: " << io::rate(strikes[n+1]));
            }
        }
    }
}
}

for (Size i=0; i<LENGTH(exercises); i++) {
for (Size j=0; j<LENGTH(lengths); j++) {
    for (Size k=0; k<LENGTH(type); k++) {
        Date exerciseDate = vars.calendar.advance(vars.today,
                                                  exercises[i]);
        Date startDate =
            vars.calendar.advance(exerciseDate,
                                  vars.settlementDays,Days);
        // store the results for different rates...
        std::vector<Real> values;
        std::vector<Real> values_cash;
        for (Size l=0; l<LENGTH(spreads); l++) {
            boost::shared_ptr<VanillaSwap> swap =
                MakeVanillaSwap(lengths[j], vars.index, 0.06)
                        .withFixedLegTenor(1*Years)
                        .withFixedLegDayCount(vars.fixedDayCount)
                        .withEffectiveDate(startDate)
                        .withFloatingLegSpread(spreads[l])
                        .withType(type[k]);
            boost::shared_ptr<Swaption> swaption =
                vars.makeSwaption(swap,exerciseDate,0.20);
            // FLOATING_POINT_EXCEPTION
            values.push_back(swaption->NPV());
            boost::shared_ptr<Swaption> swaption_cash =
                vars.makeSwaption(swap,exerciseDate,0.20,
                                  Settlement::Cash);
            values_cash.push_back(swaption_cash->NPV());
        }
        // and check that they go the right way
        if (type[k]==VanillaSwap::Payer) {
            std::vector<Real>::iterator it =
                std::adjacent_find(values.begin(), values.end(),
                                   std::greater<Real>());
            if (it != values.end()) {
                Size n = it - values.begin();
                BOOST_ERROR("NPV is decreasing with the spread " <<
                    "in a payer swaption (physical delivered):" <<
                    "\nexercise date: " << exerciseDate <<
                    "\nlength:        " << lengths[j] <<
                    "\nvalue:         " << values[n  ] << " for spread: " << io::rate(spreads[n]) <<
                    "\nvalue:         " << values[n+1] << " for spread: " << io::rate(spreads[n+1]));
            }
            std::vector<Real>::iterator it_cash =
                std::adjacent_find(values_cash.begin(), values_cash.end(),
                                   std::greater<Real>());
            if (it_cash != values_cash.end()) {
                Size n = it_cash - values_cash.begin();
                BOOST_ERROR("NPV is decreasing with the spread " <<
                    "in a payer swaption (cash delivered):" <<
                    "\nexercise date: " << exerciseDate <<
                    "\nlength: " << lengths[j] <<
                    "\nvalue:  " << values_cash[n  ] << " for spread: " << io::rate(spreads[n]) <<
                    "\nvalue:  " << values_cash[n+1] << " for spread: " << io::rate(spreads[n+1]));
            }
        } else {
            std::vector<Real>::iterator it =
                std::adjacent_find(values.begin(), values.end(),
                                   std::less<Real>());
            if (it != values.end()) {
                Size n = it - values.begin();
                BOOST_ERROR("NPV is increasing with the spread " <<
                    "in a receiver swaption (physical delivered):"
                    "\nexercise date: " << exerciseDate <<
                    "\nlength: " << lengths[j] <<
                    "\nvalue:  " << values[n  ] << " for spread: " << io::rate(spreads[n]) <<
                    "\nvalue:  " << values[n+1] << " for spread: " << io::rate(spreads[n+1]));
            }
            std::vector<Real>::iterator it_cash =
                std::adjacent_find(values_cash.begin(), values_cash.end(),
                                   std::less<Real>());
            if (it_cash != values_cash.end()) {
                Size n = it_cash - values_cash.begin();
                BOOST_ERROR("NPV is increasing with the spread " <<
                    "in a receiver swaption (cash delivered):"
                    "\nexercise date: " << exerciseDate <<
                    "\nlength: " << lengths[j] <<
                    "\nvalue:  " << values_cash[n  ] << " for spread: " << io::rate(spreads[n]) <<
                    "\nvalue:  " << values_cash[n+1] << " for spread: " << io::rate(spreads[n+1]));
            }
        }
    }
}
}

for (Size i=0; i<LENGTH(exercises); i++) {
for (Size j=0; j<LENGTH(lengths); j++) {
    for (Size k=0; k<LENGTH(type); k++) {
        Date exerciseDate = vars.calendar.advance(vars.today,
                                                  exercises[i]);
        Date startDate =
            vars.calendar.advance(exerciseDate,
                                  vars.settlementDays,Days);
        for (Size l=0; l<LENGTH(spreads); l++) {
            boost::shared_ptr<VanillaSwap> swap =
                MakeVanillaSwap(lengths[j], vars.index, 0.06)
                        .withFixedLegTenor(1*Years)
                        .withFixedLegDayCount(vars.fixedDayCount)
                        .withEffectiveDate(startDate)
                        .withFloatingLegSpread(spreads[l])
                        .withType(type[k]);
            // FLOATING_POINT_EXCEPTION
            Spread correction = spreads[l] *
                                swap->floatingLegBPS() /
                                swap->fixedLegBPS();
            boost::shared_ptr<VanillaSwap> equivalentSwap =
                MakeVanillaSwap(lengths[j], vars.index, 0.06+correction)
                        .withFixedLegTenor(1*Years)
                        .withFixedLegDayCount(vars.fixedDayCount)
                        .withEffectiveDate(startDate)
                        .withFloatingLegSpread(0.0)
                        .withType(type[k]);
            boost::shared_ptr<Swaption> swaption1 =
                vars.makeSwaption(swap,exerciseDate,0.20);
            boost::shared_ptr<Swaption> swaption2 =
                vars.makeSwaption(equivalentSwap,exerciseDate,0.20);
            boost::shared_ptr<Swaption> swaption1_cash =
                vars.makeSwaption(swap,exerciseDate,0.20,
                                  Settlement::Cash);
            boost::shared_ptr<Swaption> swaption2_cash =
                vars.makeSwaption(equivalentSwap,exerciseDate,0.20,
                                  Settlement::Cash);
            if (std::fabs(swaption1->NPV()-swaption2->NPV()) > 1.0e-6)
                BOOST_ERROR("wrong spread treatment:" <<
                    "\nexercise: " << exerciseDate <<
                    "\nlength:   " << lengths[j] <<
                    "\ntype      " << type[k] <<
                    "\nspread:   " << io::rate(spreads[l]) <<
                    "\noriginal swaption value:   " << swaption1->NPV() <<
                    "\nequivalent swaption value: " << swaption2->NPV());

            if (std::fabs(swaption1_cash->NPV()-swaption2_cash->NPV()) > 1.0e-6)
                BOOST_ERROR("wrong spread treatment:" <<
                    "\nexercise date: " << exerciseDate <<
                    "\nlength: " << lengths[j] <<
                    "\npay " << (type[k] ? "fixed" : "floating") <<
                    "\nspread: " << io::rate(spreads[l]) <<
                    "\nvalue of original swaption:   "  << swaption1_cash->NPV() <<
                    "\nvalue of equivalent swaption: "  << swaption2_cash->NPV());
        }

    }
}
}

for (Size i=0; i<LENGTH(exercises); i++) {
Date exerciseDate = vars.calendar.advance(vars.today, exercises[i]);
Date startDate = vars.calendar.advance(exerciseDate,
                                   vars.settlementDays*Days);
for (Size j=0; j<LENGTH(lengths); j++) {
    for (Size t=0; t<LENGTH(strikes); t++) {
        for (Size h=0; h<LENGTH(type); h++) {
            boost::shared_ptr<VanillaSwap> swap =
                MakeVanillaSwap(lengths[j], vars.index, strikes[t])
                        .withEffectiveDate(startDate)
                        .withFixedLegTenor(1*Years)
                        .withFixedLegDayCount(vars.fixedDayCount)
                        .withFloatingLegSpread(0.0)
                        .withType(type[h]);
            for (Size u=0; u<LENGTH(vols); u++) {
                boost::shared_ptr<Swaption> swaption =
                    vars.makeSwaption(swap, exerciseDate,
                                      vols[u], types[h]);
                // FLOATING_POINT_EXCEPTION
                boost::shared_ptr<Swaption> swaption1 =
                    vars.makeSwaption(swap, exerciseDate,
                                      vols[u]-shift, types[h]);
                boost::shared_ptr<Swaption> swaption2 =
                    vars.makeSwaption(swap, exerciseDate,
                                      vols[u]+shift, types[h]);

                Real swaptionNPV = swaption->NPV();
                Real numericalVegaPerPoint =
                    (swaption2->NPV()-swaption1->NPV())/(200.0*shift);
                // check only relevant vega
                if (numericalVegaPerPoint/swaptionNPV>1.0e-7) {
                    Real analyticalVegaPerPoint =
                        swaption->result<Real>("vega")/100.0;
                    Real discrepancy = std::fabs(analyticalVegaPerPoint
                        - numericalVegaPerPoint);
                    discrepancy /= numericalVegaPerPoint;
                    Real tolerance = 0.015;
                    if (discrepancy > tolerance)
                        BOOST_FAIL("failed to compute swaption vega:" <<
                            "\n  option tenor:    " << exercises[i] <<
                            "\n  volatility:      " << io::rate(vols[u]) <<
                            "\n  option type:     " << swaption->type() <<
                            "\n  swap tenor:      " << lengths[j] <<
                            "\n  strike:          " << io::rate(strikes[t]) <<
                            "\n  settlement:      " << types[h] <<
                            "\n  nominal:         " << swaption->underlyingSwap()->nominal() <<
                            "\n  npv:             " << swaptionNPV <<
                            "\n  calculated vega: " << analyticalVegaPerPoint <<
                            "\n  expected vega:   " << numericalVegaPerPoint <<
                            "\n  discrepancy:     " << io::rate(discrepancy) <<
                            "\n  tolerance:       " << io::rate(tolerance));
                }
            }
        }
    }
}
}

for (Size i=0; i<LENGTH(exercises); i++) {
for (Size j=0; j<LENGTH(lengths); j++) {

    Date exerciseDate = vars.calendar.advance(vars.today,exercises[i]);
    Date startDate = vars.calendar.advance(exerciseDate,
                                           vars.settlementDays,Days);
    Date maturity =
        vars.calendar.advance(startDate,lengths[j],
                              vars.floatingConvention);
    Schedule floatSchedule(startDate, maturity, vars.floatingTenor,
                           vars.calendar,vars.floatingConvention,
                           vars.floatingConvention,
                           DateGeneration::Forward, false);
    // Swap with fixed leg conventions: Business Days = Unadjusted, DayCount = 30/360
    Schedule fixedSchedule_u(startDate, maturity,
                             Period(vars.fixedFrequency),
                             vars.calendar, Unadjusted, Unadjusted,
                             DateGeneration::Forward, true);
    boost::shared_ptr<VanillaSwap> swap_u360(
        new VanillaSwap(type[0], vars.nominal,
                        fixedSchedule_u,strike,Thirty360(),
                        floatSchedule,vars.index,0.0,
                        vars.index->dayCounter()));

    // Swap with fixed leg conventions: Business Days = Unadjusted, DayCount = Act/365
    boost::shared_ptr<VanillaSwap> swap_u365(
        new VanillaSwap(type[0],vars.nominal,
                        fixedSchedule_u,strike,Actual365Fixed(),
                        floatSchedule,vars.index,0.0,
                        vars.index->dayCounter()));

    // Swap with fixed leg conventions: Business Days = Modified Following, DayCount = 30/360
    Schedule fixedSchedule_a(startDate,maturity,
                             Period(vars.fixedFrequency),
                             vars.calendar,ModifiedFollowing,
                             ModifiedFollowing,
                             DateGeneration::Forward, true);
    boost::shared_ptr<VanillaSwap> swap_a360(
        new VanillaSwap(type[0],vars.nominal,
                        fixedSchedule_a,strike,Thirty360(),
                        floatSchedule,vars.index,0.0,
                        vars.index->dayCounter()));

    // Swap with fixed leg conventions: Business Days = Modified Following, DayCount = Act/365
    boost::shared_ptr<VanillaSwap> swap_a365(
        new VanillaSwap(type[0],vars.nominal,
                        fixedSchedule_a,strike,Actual365Fixed(),
                        floatSchedule,vars.index,0.0,
                        vars.index->dayCounter()));

    boost::shared_ptr<PricingEngine> swapEngine(
                       new DiscountingSwapEngine(vars.termStructure));

    swap_u360->setPricingEngine(swapEngine);
    swap_a360->setPricingEngine(swapEngine);
    swap_u365->setPricingEngine(swapEngine);
    swap_a365->setPricingEngine(swapEngine);

    const Leg& swapFixedLeg_u360 = swap_u360->fixedLeg();
    const Leg& swapFixedLeg_a360 = swap_a360->fixedLeg();
    const Leg& swapFixedLeg_u365 = swap_u365->fixedLeg();
    const Leg& swapFixedLeg_a365 = swap_a365->fixedLeg();

    // FlatForward curves
    // FLOATING_POINT_EXCEPTION
    Handle<YieldTermStructure> termStructure_u360(
        boost::shared_ptr<YieldTermStructure>(
            new FlatForward(vars.settlement,swap_u360->fairRate(),
                            Thirty360(),Compounded,
                            vars.fixedFrequency)));
    Handle<YieldTermStructure> termStructure_a360(
        boost::shared_ptr<YieldTermStructure>(
            new FlatForward(vars.settlement,swap_a360->fairRate(),
                            Thirty360(),Compounded,
                            vars.fixedFrequency)));
    Handle<YieldTermStructure> termStructure_u365(
        boost::shared_ptr<YieldTermStructure>(
            new FlatForward(vars.settlement,swap_u365->fairRate(),
                            Actual365Fixed(),Compounded,
                            vars.fixedFrequency)));
    Handle<YieldTermStructure> termStructure_a365(
        boost::shared_ptr<YieldTermStructure>(
            new FlatForward(vars.settlement,swap_a365->fairRate(),
                            Actual365Fixed(),Compounded,
                            vars.fixedFrequency)));

    // Annuity calculated by swap method fixedLegBPS().
    // Fixed leg conventions: Unadjusted, 30/360
    Real annuity_u360 = swap_u360->fixedLegBPS() / 0.0001;
    annuity_u360 = swap_u360->type()==VanillaSwap::Payer ?
        -annuity_u360 : annuity_u360;
    // Fixed leg conventions: ModifiedFollowing, act/365
    Real annuity_a365 = swap_a365->fixedLegBPS() / 0.0001;
    annuity_a365 = swap_a365->type()==VanillaSwap::Payer ?
        -annuity_a365 : annuity_a365;
    // Fixed leg conventions: ModifiedFollowing, 30/360
    Real annuity_a360 = swap_a360->fixedLegBPS() / 0.0001;
    annuity_a360 = swap_a360->type()==VanillaSwap::Payer ?
        -annuity_a360 : annuity_a360;
    // Fixed leg conventions: Unadjusted, act/365
    Real annuity_u365 = swap_u365->fixedLegBPS() / 0.0001;
    annuity_u365 = swap_u365->type()==VanillaSwap::Payer ?
        -annuity_u365 : annuity_u365;

    // Calculation of Modified Annuity (cash settlement)
    // Fixed leg conventions of swap: unadjusted, 30/360
    Real cashannuity_u360 = 0.;
    Size i;
    for (i=0; i<swapFixedLeg_u360.size(); i++) {
        cashannuity_u360 += swapFixedLeg_u360[i]->amount()/strike
                          * termStructure_u360->discount(
                            swapFixedLeg_u360[i]->date());
    }
    // Fixed leg conventions of swap: unadjusted, act/365
    Real cashannuity_u365 = 0.;
    for (i=0; i<swapFixedLeg_u365.size(); i++) {
        cashannuity_u365 += swapFixedLeg_u365[i]->amount()/strike
                          * termStructure_u365->discount(
                            swapFixedLeg_u365[i]->date());
    }
    // Fixed leg conventions of swap: modified following, 30/360
    Real cashannuity_a360 = 0.;
    for (i=0; i<swapFixedLeg_a360.size(); i++) {
        cashannuity_a360 += swapFixedLeg_a360[i]->amount()/strike
                          * termStructure_a360->discount(
                            swapFixedLeg_a360[i]->date());
    }
    // Fixed leg conventions of swap: modified following, act/365
    Real cashannuity_a365 = 0.;
    for (i=0; i<swapFixedLeg_a365.size(); i++) {
        cashannuity_a365 += swapFixedLeg_a365[i]->amount()/strike
                          * termStructure_a365->discount(
                            swapFixedLeg_a365[i]->date());
    }

    // Swaptions: underlying swap fixed leg conventions:
    // unadjusted, 30/360

    // Physical settled swaption
    boost::shared_ptr<Swaption> swaption_p_u360 =
        vars.makeSwaption(swap_u360,exerciseDate,0.20);
    Real value_p_u360 = swaption_p_u360->NPV();
    // Cash settled swaption
    boost::shared_ptr<Swaption> swaption_c_u360 =
        vars.makeSwaption(swap_u360,exerciseDate,0.20,
                          Settlement::Cash);
    Real value_c_u360 = swaption_c_u360->NPV();
    // the NPV's ratio must be equal to annuities ratio
    Real npv_ratio_u360 = value_c_u360 / value_p_u360;
    Real annuity_ratio_u360 = cashannuity_u360 / annuity_u360;

    // Swaptions: underlying swap fixed leg conventions:
    // modified following, act/365

    // Physical settled swaption
    boost::shared_ptr<Swaption> swaption_p_a365 =
        vars.makeSwaption(swap_a365,exerciseDate,0.20);
    Real value_p_a365 = swaption_p_a365->NPV();
    // Cash settled swaption
    boost::shared_ptr<Swaption> swaption_c_a365 =
        vars.makeSwaption(swap_a365,exerciseDate,0.20,
                          Settlement::Cash);
    Real value_c_a365 = swaption_c_a365->NPV();
    // the NPV's ratio must be equal to annuities ratio
    Real npv_ratio_a365 = value_c_a365 / value_p_a365;
    Real annuity_ratio_a365 =  cashannuity_a365 / annuity_a365;

    // Swaptions: underlying swap fixed leg conventions:
    // modified following, 30/360

    // Physical settled swaption
    boost::shared_ptr<Swaption> swaption_p_a360 =
        vars.makeSwaption(swap_a360,exerciseDate,0.20);
    Real value_p_a360 = swaption_p_a360->NPV();
    // Cash settled swaption
    boost::shared_ptr<Swaption> swaption_c_a360 =
        vars.makeSwaption(swap_a360,exerciseDate,0.20,
                          Settlement::Cash);
    Real value_c_a360 = swaption_c_a360->NPV();
    // the NPV's ratio must be equal to annuities ratio
    Real npv_ratio_a360 = value_c_a360 / value_p_a360;
    Real annuity_ratio_a360 =  cashannuity_a360 / annuity_a360;

    // Swaptions: underlying swap fixed leg conventions:
    // unadjusted, act/365

    // Physical settled swaption
    boost::shared_ptr<Swaption> swaption_p_u365 =
        vars.makeSwaption(swap_u365,exerciseDate,0.20);
    Real value_p_u365 = swaption_p_u365->NPV();
    // Cash settled swaption
    boost::shared_ptr<Swaption> swaption_c_u365 =
        vars.makeSwaption(swap_u365,exerciseDate,0.20,
                          Settlement::Cash);
    Real value_c_u365 = swaption_c_u365->NPV();
    // the NPV's ratio must be equal to annuities ratio
    Real npv_ratio_u365 = value_c_u365 / value_p_u365;
    Real annuity_ratio_u365 =  cashannuity_u365 / annuity_u365;

    if (std::fabs(annuity_ratio_u360-npv_ratio_u360)>1e-10 ) {
        BOOST_ERROR("\n" <<
                    "    The npv's ratio must be equal to " <<
                    " annuities ratio" << "\n"
                    "    Swaption " <<
                    exercises[i].units() << "y x " << lengths[j].units() << "y" <<
                    " (underlying swap fixed leg Unadjusted, 30/360)" << "\n" <<
                    "    Today           : " <<
                    vars.today << "\n" <<
                    "    Settlement date : " <<
                    vars.settlement << "\n" <<
                    "    Exercise date   : " <<
                    exerciseDate << "\n"   <<
                    "    Swap start date : " <<
                    startDate << "\n"   <<
                    "    Swap end date   : " <<
                    maturity <<     "\n"   <<
                    "    physical delivered swaption npv : " <<
                    value_p_u360 << "\t\t\t" <<
                    "    annuity : " <<
                    annuity_u360 << "\n" <<
                    "    cash delivered swaption npv :     " <<
                    value_c_u360 << "\t\t\t" <<
                    "    annuity : " <<
                    cashannuity_u360 << "\n" <<
                    "    npv ratio : " <<
                    npv_ratio_u360 << "\n" <<
                    "    annuity ratio : " <<
                    annuity_ratio_u360 << "\n" <<
                    "    difference : " <<
                    (annuity_ratio_u360-npv_ratio_u360) );
    }
    if (std::fabs(annuity_ratio_a365-npv_ratio_a365)>1e-10) {
        BOOST_ERROR("\n" <<
                    "    The npv's ratio must be equal to " <<
                    " annuities ratio" << "\n"
                    "    Swaption " <<
                    exercises[i].units() << "y x " << lengths[j].units() << "y" <<
                    " (underlying swap fixed leg Modified Following, act/365" << "\n" <<
                    "    Today           : " <<
                    vars.today << "\n" <<
                    "    Settlement date : " <<
                    vars.settlement << "\n" <<
                    "    Exercise date   : " <<
                    exerciseDate <<  "\n"  <<
                    "    Swap start date : " <<
                    startDate << "\n"   <<
                    "    Swap end date   : " <<
                    maturity <<     "\n"   <<
                    "    physical delivered swaption npv : "  <<
                    value_p_a365 << "\t\t\t" <<
                    "    annuity : " <<
                    annuity_a365 << "\n" <<
                    "    cash delivered swaption npv :     "  <<
                    value_c_a365 << "\t\t\t" <<
                    "    annuity : " <<
                    cashannuity_a365 << "\n" <<
                    "    npv ratio : " <<
                    npv_ratio_a365 << "\n" <<
                    "    annuity ratio : " <<
                    annuity_ratio_a365 << "\n" <<
                    "    difference : " <<
                    (annuity_ratio_a365-npv_ratio_a365) );
        }
    if (std::fabs(annuity_ratio_a360-npv_ratio_a360)>1e-10) {
        BOOST_ERROR("\n" <<
                    "    The npv's ratio must be equal to " <<
                    " annuities ratio" << "\n"
                    "    Swaption " <<
                    exercises[i].units() << "y x " << lengths[j].units() << "y" <<
                    " (underlying swap fixed leg Unadjusted, 30/360)" << "\n" <<
                    "    Today           : " <<
                    vars.today << "\n" <<
                    "    Settlement date : " <<
                    vars.settlement << "\n" <<
                    "    Exercise date   : " <<
                    exerciseDate << "\n"   <<
                    "    Swap start date : " <<
                    startDate << "\n"   <<
                    "    Swap end date   : " <<
                    maturity <<     "\n"   <<
                    "    physical delivered swaption npv : " <<
                    value_p_a360 << "\t\t\t" <<
                    "    annuity : " <<
                    annuity_a360 << "\n" <<
                    "    cash delivered swaption npv :     " <<
                    value_c_a360 << "\t\t\t" <<
                    "    annuity : " <<
                    cashannuity_a360 << "\n" <<
                    "    npv ratio : " <<
                    npv_ratio_a360 << "\n" <<
                    "    annuity ratio : " <<
                    annuity_ratio_a360 << "\n" <<
                    "    difference : " <<
                    (annuity_ratio_a360-npv_ratio_a360) );
    }
    if (std::fabs(annuity_ratio_u365-npv_ratio_u365)>1e-10) {
        BOOST_ERROR("\n" <<
                    "    The npv's ratio must be equal to " <<
                    " annuities ratio" << "\n"
                    "    Swaption " <<
                    exercises[i].units() << "y x " << lengths[j].units() << "y" <<
                    " (underlying swap fixed leg Unadjusted, act/365)" << "\n" <<
                    "    Today           : " <<
                    vars.today << "\n" <<
                    "    Settlement date : " <<
                    vars.settlement << "\n" <<
                    "    Exercise date   : " <<
                    exerciseDate << "\n"   <<
                    "    Swap start date : " <<
                    startDate << "\n"   <<
                    "    Swap end date   : " <<
                    maturity <<     "\n"   <<
                    "    physical delivered swaption npv : " <<
                    value_p_u365 << "\t\t\t" <<
                    "    annuity : " <<
                    annuity_u365 << "\n" <<
                    "    cash delivered swaption npv :     " <<
                    value_c_u365 << "\t\t\t" <<
                    "    annuity : " <<
                    cashannuity_u365 << "\n" <<
                    "    npv ratio : " <<
                    npv_ratio_u365 << "\n" <<
                    "    annuity ratio : " <<
                    annuity_ratio_u365 << "\n" <<
                    "    difference : " <<
                    (annuity_ratio_u365-npv_ratio_u365) );
    }
}
}

for (Size i=0; i<LENGTH(exercises); i++) {
for (Size j=0; j<LENGTH(lengths); j++) {
    Date exerciseDate = vars.calendar.advance(vars.today,exercises[i]);
    Date startDate = vars.calendar.advance(exerciseDate,
                                           vars.settlementDays, Days);

    for (Size t=0; t<LENGTH(strikes); t++) {
        for (Size k=0; k<LENGTH(type); k++) {
            boost::shared_ptr<VanillaSwap> swap =
                MakeVanillaSwap(lengths[j], vars.index, strikes[t])
                        .withEffectiveDate(startDate)
                        .withFixedLegTenor(1*Years)
                        .withFixedLegDayCount(vars.fixedDayCount)
                        .withFloatingLegSpread(0.0)
                        .withType(type[k]);
            for (Size h=0; h<LENGTH(types); h++) {
                for (Size u=0; u<LENGTH(vols); u++) {
                    boost::shared_ptr<Swaption> swaption =
                        vars.makeSwaption(swap, exerciseDate,
                                          vols[u], types[h]);
                    // Black price
                    Real value = swaption->NPV();
                    Volatility implVol = 0.0;
                    try {
                        implVol =
                          swaption->impliedVolatility(value,
                                                      vars.termStructure,
                                                      0.10,
                                                      tolerance,
                                                      maxEvaluations,
                                                      1.0e-7,
                                                      4.0,
                                                      0.0);
                    } catch (std::exception& e) {
                        // couldn't bracket?
                        swaption->setPricingEngine(vars.makeEngine(0.0));
                        Real value2 = swaption->NPV();
                        if (std::fabs(value-value2) < tolerance) {
                            // ok, just skip:
                            continue;
                        }
                        // otherwise, report error
                        BOOST_ERROR("implied vol failure: " <<
                                    exercises[i] << "x" << lengths[j] << " " << type[k] <<
                                    "\nsettlement: " << types[h] <<
                                    "\nstrike      " << strikes[t] <<
                                    "\natm level:  " << io::rate(swap->fairRate()) <<
                                    "\nvol:        " << io::volatility(vols[u]) <<
                                    "\nprice:      " << value <<
                                    "\n" << e.what());
                    }
                    if (std::fabs(implVol-vols[u]) > tolerance) {
                        // the difference might not matter
                        swaption->setPricingEngine(vars.makeEngine(implVol));
                        Real value2 = swaption->NPV();
                        if (std::fabs(value-value2) > tolerance) {
                            BOOST_ERROR("implied vol failure: " <<
                                exercises[i] << "x" << lengths[j] << " " << type[k] <<
                                "\nsettlement:    " << types[h] <<
                                "\nstrike         " << strikes[t] <<
                                "\natm level:     " << io::rate(swap->fairRate()) <<
                                "\nvol:           " << io::volatility(vols[u]) <<
                                "\nprice:         " << value <<
                                "\nimplied vol:   " << io::volatility(implVol) <<
                                "\nimplied price: " << value2);
                        }
                     }
                }
            }
        }
    }
}
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/compoundoption.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i<LENGTH(values); i++) {

boost::shared_ptr<StrikedTypePayoff> payoffMotherCall(
        new PlainVanillaPayoff(Option::Call, values[i].strikeMother));

boost::shared_ptr<StrikedTypePayoff> payoffMotherPut(
        new PlainVanillaPayoff(Option::Put, values[i].strikeMother));

boost::shared_ptr<StrikedTypePayoff> payoffDaughter(
                    new PlainVanillaPayoff(values[i].typeDaughter,
                                           values[i].strikeDaughter));

Date matDateMom = todaysDate + timeToDays(values[i].tMother);
Date matDateDaughter = todaysDate + timeToDays(values[i].tDaughter);

boost::shared_ptr<Exercise> exerciseCompound(
                                    new EuropeanExercise(matDateMom));
boost::shared_ptr<Exercise> exerciseDaughter(
                               new EuropeanExercise(matDateDaughter));

spot ->setValue(values[i].s);
qRate->setValue(values[i].q);
rRate->setValue(values[i].r);
vol  ->setValue(values[i].v);

CompoundOption compoundOptionCall(payoffMotherCall,exerciseCompound,
                                  payoffDaughter, exerciseDaughter);

CompoundOption compoundOptionPut(payoffMotherPut,exerciseCompound,
                                 payoffDaughter, exerciseDaughter);

VanillaOption vanillaOption(EuropeanOption(payoffDaughter,
                                           exerciseDaughter));

boost::shared_ptr<BlackScholesMertonProcess> stochProcess(
    new BlackScholesMertonProcess(
              Handle<Quote>(spot),
              Handle<YieldTermStructure>(qTS),
              Handle<YieldTermStructure>(rTS),
              Handle<BlackVolTermStructure>(volTS)));


boost::shared_ptr<PricingEngine> engineCompound(
                      new AnalyticCompoundOptionEngine(stochProcess));

boost::shared_ptr<PricingEngine> engineEuropean(
                             new AnalyticEuropeanEngine(stochProcess));

compoundOptionCall.setPricingEngine(engineCompound);
compoundOptionPut.setPricingEngine(engineCompound);
vanillaOption.setPricingEngine(engineEuropean);

Real discFact=rTS->discount(matDateMom);
Real discStrike=values[i].strikeMother*discFact;

Real calculated =
    compoundOptionCall.NPV() + discStrike - compoundOptionPut.NPV()
    - vanillaOption.NPV();

Real expected=0.0;
Real error=std::abs(calculated-expected);
Real tolerance=1.0e-8;

if(error>tolerance){
    REPORT_FAILURE("put call parity", payoffMotherCall, payoffDaughter,
                   exerciseCompound, exerciseDaughter, values[i].s,
                   values[i].q, values[i].r, todaysDate,
                   values[i].v, values[i].delta, calculated,
                   error, tolerance);
}
}

for (Size i=0; i<LENGTH(values); i++) {

boost::shared_ptr<StrikedTypePayoff> payoffMother(
            new PlainVanillaPayoff(values[i].typeMother,
                                   values[i].strikeMother));

boost::shared_ptr<StrikedTypePayoff> payoffDaughter(
            new PlainVanillaPayoff(values[i].typeDaughter,
                                   values[i].strikeDaughter));

Date matDateMom = todaysDate + timeToDays(values[i].tMother);
Date matDateDaughter = todaysDate + timeToDays(values[i].tDaughter);

boost::shared_ptr<Exercise> exerciseMother(
                                    new EuropeanExercise(matDateMom));
boost::shared_ptr<Exercise> exerciseDaughter(
                               new EuropeanExercise(matDateDaughter));

spot ->setValue(values[i].s);
qRate->setValue(values[i].q);
rRate->setValue(values[i].r);
vol  ->setValue(values[i].v);

CompoundOption compoundOption(payoffMother,exerciseMother,
                              payoffDaughter, exerciseDaughter);

boost::shared_ptr<BlackScholesMertonProcess> stochProcess(
    new BlackScholesMertonProcess(
              Handle<Quote>(spot),
              Handle<YieldTermStructure>(qTS),
              Handle<YieldTermStructure>(rTS),
              Handle<BlackVolTermStructure>(volTS)));

boost::shared_ptr<PricingEngine> engineCompound(
                      new AnalyticCompoundOptionEngine(stochProcess));

compoundOption.setPricingEngine(engineCompound);

Real calculated = compoundOption.NPV();
Real error= std::fabs(calculated-values[i].npv); //-values[i].npv
Real tolerance = values[i].tol;

if (error>tolerance) {
    REPORT_FAILURE("value", payoffMother, payoffDaughter,
                   exerciseMother, exerciseDaughter, values[i].s,
                   values[i].q, values[i].r, todaysDate,
                   values[i].v, values[i].npv, calculated,
                   error, tolerance);
}

calculated = compoundOption.delta();
error= std::fabs(calculated-values[i].delta);
tolerance = values[i].tol;

if (error>tolerance) {
    REPORT_FAILURE("delta", payoffMother, payoffDaughter,
                   exerciseMother, exerciseDaughter, values[i].s,
                   values[i].q, values[i].r, todaysDate,
                   values[i].v, values[i].delta, calculated,
                   error, tolerance);
}

calculated = compoundOption.gamma();
error= std::fabs(calculated-values[i].gamma);
tolerance = values[i].tol;

if (error>tolerance) {
    REPORT_FAILURE("gamma", payoffMother, payoffDaughter,
                   exerciseMother, exerciseDaughter, values[i].s,
                   values[i].q, values[i].r, todaysDate,
                   values[i].v, values[i].gamma, calculated,
                   error, tolerance);
}

calculated = compoundOption.vega();
error= std::fabs(calculated-values[i].vega);
tolerance = values[i].tol;

if (error>tolerance) {
    REPORT_FAILURE("vega", payoffMother, payoffDaughter,
                   exerciseMother, exerciseDaughter, values[i].s,
                   values[i].q, values[i].r, todaysDate,
                   values[i].v, values[i].vega, calculated,
                   error, tolerance);
}

calculated = compoundOption.theta();
error= std::fabs(calculated-values[i].theta);
tolerance = values[i].tol;

if (error>tolerance) {
    REPORT_FAILURE("theta", payoffMother, payoffDaughter,
                   exerciseMother, exerciseDaughter, values[i].s,
                   values[i].q, values[i].r, todaysDate,
                   values[i].v, values[i].theta, calculated,
                   error, tolerance);
}
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/hestonmodel.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (i = 0; i < 8; ++i) {
    dates.push_back(settlementDate + t[i]);
    rates.push_back(r[i]);
}

for (Size s = 0; s < 13; ++s) {
    for (Size m = 0; m < 8; ++m) {
        Handle<Quote> vol(boost::shared_ptr<Quote>(
                                            new SimpleQuote(v[s*8+m])));

        Period maturity((int)((t[m]+3)/7.), Weeks); // round to weeks
        options.push_back(boost::shared_ptr<CalibrationHelper>(
                new HestonModelHelper(maturity, calendar,
                                      s0->value(), strike[s], vol,
                                      riskFreeTS, dividendYield,
                                  CalibrationHelper::ImpliedVolError)));
    }
}

for (Size i = 0; i < optionMaturities.size(); ++i) {
for (Real moneyness = -1.0; moneyness < 2.0; moneyness += 1.0) {
    // FLOATING_POINT_EXCEPTION
    const Time tau = dayCounter.yearFraction(
                         riskFreeTS->referenceDate(),
                         calendar.advance(riskFreeTS->referenceDate(),
                                          optionMaturities[i]));
const Real fwdPrice = s0->value()*dividendTS->discount(tau)
                    / riskFreeTS->discount(tau);
const Real strikePrice = fwdPrice * std::exp(-moneyness * volatility
                                             * std::sqrt(tau));

options.push_back(boost::shared_ptr<CalibrationHelper>(
                  new HestonModelHelper(optionMaturities[i], calendar,
                                        s0->value(), strikePrice, vol,
                                        riskFreeTS, dividendTS)));
}
}

for (Real sigma = 0.1; sigma < 0.7; sigma += 0.2) {
const Real v0=0.01;
const Real kappa=0.2;
const Real theta=0.02;
const Real rho=-0.75;

boost::shared_ptr<HestonProcess> process(
    new HestonProcess(riskFreeTS, dividendTS,
                      s0, v0, kappa, theta, sigma, rho));

boost::shared_ptr<HestonModel> model(new HestonModel(process));
boost::shared_ptr<PricingEngine> engine(
                                 new AnalyticHestonEngine(model, 96));

for (Size i = 0; i < options.size(); ++i)
    options[i]->setPricingEngine(engine);

LevenbergMarquardt om(1e-8, 1e-8, 1e-8);
model->calibrate(options, om, EndCriteria(400, 40, 1.0e-8,
                                          1.0e-8, 1.0e-8));

Real tolerance = 3.0e-3;

if (model->sigma() > tolerance) {
    BOOST_ERROR("Failed to reproduce expected sigma"
                << "\n    calculated: " << model->sigma()
                << "\n    expected:   " << 0.0
                << "\n    tolerance:  " << tolerance);
}

if (std::fabs(model->kappa()
          *(model->theta()-volatility*volatility)) > tolerance) {
    BOOST_ERROR("Failed to reproduce expected theta"
                << "\n    calculated: " << model->theta()
                << "\n    expected:   " << volatility*volatility);
}

if (std::fabs(model->v0()-volatility*volatility) > tolerance) {
    BOOST_ERROR("Failed to reproduce expected v0"
                << "\n    calculated: " << model->v0()
                << "\n    expected:   " << volatility*volatility);
}
}

for (Size i = 0; i < options.size(); ++i)
options[i]->setPricingEngine(engine);

for (Size i = 0; i < 13*8; ++i) {
const Real diff = options[i]->calibrationError()*100.0;
sse += diff*diff;
}

for (i = 0; i < 6; ++i) {
Date exerciseDate(8+i/3, September, 2005);

boost::shared_ptr<StrikedTypePayoff> payoff(
                        new PlainVanillaPayoff(Option::Call, K[i%3]));
boost::shared_ptr<Exercise> exercise(
                                  new EuropeanExercise(exerciseDate));

Handle<YieldTermStructure> riskFreeTS(flatRate(0.05, dayCounter));
Handle<YieldTermStructure> dividendTS(flatRate(0.02, dayCounter));

Real s = riskFreeTS->discount(0.7)/dividendTS->discount(0.7);
Handle<Quote> s0(boost::shared_ptr<Quote>(new SimpleQuote(s)));

boost::shared_ptr<HestonProcess> process(new HestonProcess(
           riskFreeTS, dividendTS, s0, 0.09, 1.2, 0.08, 1.8, -0.45));

VanillaOption option(payoff, exercise);

boost::shared_ptr<PricingEngine> engine(new AnalyticHestonEngine(
           boost::shared_ptr<HestonModel>(new HestonModel(process))));

option.setPricingEngine(engine);
calculated2[i] = option.NPV();
}

for (i = 0; i < 3; ++i) {
const Real interpolated =
    calculated2[i]+(calculated2[i+3]-calculated2[i])/(t2-t1)*(0.7-t1);

if (std::fabs(interpolated - expected2[i]) > 100*tolerance) {
    BOOST_ERROR("Failed to reproduce cached analytic prices:"
                << "\n    calculated: " << interpolated
                << "\n    expected:   " << expected2[i] );
}
}

for (Size i=0; i < LENGTH(descriptions); ++i) {
const boost::shared_ptr<HestonProcess> process(
    new HestonProcess(riskFreeTS, dividendTS, s0, v0,
                      kappa, theta, sigma, rho,
                      descriptions[i].discretization));

const boost::shared_ptr<PricingEngine> engine =
    MakeMCEuropeanHestonEngine<PseudoRandom>(process)
    .withSteps(descriptions[i].nSteps)
    .withAntitheticVariate()
    .withAbsoluteTolerance(tolerance)
    .withSeed(1234);
option.setPricingEngine(engine);

const Real calculated = option.NPV();
const Real errorEstimate = option.errorEstimate();

if (std::fabs(calculated - expected) > 2.34*errorEstimate) {
    BOOST_ERROR("Failed to reproduce cached price with MC engine"
                << "\n    discretization: " << descriptions[i].name
                << "\n    expected:       " << expected
                << "\n    calculated:     " << calculated
                << " +/- " << errorEstimate);
}

if (errorEstimate > tolerance) {
    BOOST_ERROR("failed to reproduce error estimate with MC engine"
                << "\n    discretization: " << descriptions[i].name
                << "\n    calculated    : " << errorEstimate
                << "\n    expected      :   " << tolerance);
}
}

for (Size i=0; i < LENGTH(maturities); ++i) {
    boost::shared_ptr<Exercise> exercise(
        new EuropeanExercise(settlementDate
                             + Period(maturities[i], Months)));

    for (Size j=0; j < LENGTH(strikes); ++j) {
        for (Size k=0; k < LENGTH(types); ++k) {

            boost::shared_ptr<StrikedTypePayoff> payoff(
                new PlainVanillaPayoff(types[k], strikes[j]));

            VanillaOption option(payoff, exercise);

            option.setPricingEngine(lobattoEngine);
            const Real lobattoNPV = option.NPV();

            option.setPricingEngine(laguerreEngine);
            const Real laguerre = option.NPV();

            option.setPricingEngine(legendreEngine);
            const Real legendre = option.NPV();

            option.setPricingEngine(chebyshevEngine);
            const Real chebyshev = option.NPV();

            option.setPricingEngine(chebyshev2ndEngine);
            const Real chebyshev2nd = option.NPV();

            maxLaguerreDiff
                = std::max(maxLaguerreDiff,
                           std::fabs(lobattoNPV-laguerre));
            maxLegendreDiff
                = std::max(maxLegendreDiff,
                           std::fabs(lobattoNPV-legendre));
            maxChebyshevDiff
                = std::max(maxChebyshevDiff,
                           std::fabs(lobattoNPV-chebyshev));
            maxChebyshev2ndDiff
                = std::max(maxChebyshev2ndDiff,
                           std::fabs(lobattoNPV-chebyshev2nd));

        }
    }
}

for (Size i=0; i < strikes.size(); ++i) {
boost::shared_ptr<StrikedTypePayoff> payoff(
                   new PlainVanillaPayoff(Option::Put, strikes[i]));

VanillaOption aOption(payoff, exercise);
aOption.setPricingEngine(multiStrikeEngine);

Real npvCalculated   = aOption.NPV();
Real deltaCalculated = aOption.delta();
Real gammaCalculated = aOption.gamma();
Real thetaCalculated = aOption.theta();

aOption.setPricingEngine(singleStrikeEngine);
Real npvExpected   = aOption.NPV();
Real deltaExpected = aOption.delta();
Real gammaExpected = aOption.gamma();
Real thetaExpected = aOption.theta();

if (std::fabs(npvCalculated-npvExpected)/npvExpected > relTol) {
    BOOST_FAIL("failed to reproduce price with FD multi strike engine"
               << "\n    calculated: " << npvCalculated
               << "\n    expected:   " << npvExpected
               << "\n    error:      " << QL_SCIENTIFIC << relTol);
}
if (std::fabs(deltaCalculated-deltaExpected)/deltaExpected > relTol) {
    BOOST_FAIL("failed to reproduce delta with FD multi strike engine"
               << "\n    calculated: " << deltaCalculated
               << "\n    expected:   " << deltaExpected
               << "\n    error:      " << QL_SCIENTIFIC << relTol);
}
if (std::fabs(gammaCalculated-gammaExpected)/gammaExpected > relTol) {
    BOOST_FAIL("failed to reproduce gamma with FD multi strike engine"
               << "\n    calculated: " << gammaCalculated
               << "\n    expected:   " << gammaExpected
               << "\n    error:      " << QL_SCIENTIFIC << relTol);
}
if (std::fabs(thetaCalculated-thetaExpected)/thetaExpected > relTol) {
    BOOST_FAIL("failed to reproduce theta with FD multi strike engine"
               << "\n    calculated: " << thetaCalculated
               << "\n    expected:   " << thetaExpected
               << "\n    error:      " << QL_SCIENTIFIC << relTol);
}
}

for (Size i=0; i < pTimes.size()+1; ++i) {
kappa.setParam(i, 10.0);
}

for (Size i = 0; i < options.size(); ++i)
options[i]->setPricingEngine(engine);

for (Size i = 0; i < 13*8; ++i) {
const Real diff = options[i]->calibrationError()*100.0;
sse += diff*diff;
}

for (Size i=0; i < LENGTH(strikes); ++i) {
const Real strike = strikes[i];

for (Size j=0; j < LENGTH(types); ++j) {
    const Option::Type type = types[j];

    for (Size k=0; k < LENGTH(engines); ++k) {
        const boost::shared_ptr<PricingEngine> engine = engines[k];

        const boost::shared_ptr<StrikedTypePayoff> payoff(
            new PlainVanillaPayoff(type, strike));

        VanillaOption option(payoff, exercise);
        option.setPricingEngine(engine);

        const Real expected = expectedResults[i][j];
        const Real calculated = option.NPV();
        const Real relError = std::fabs(calculated-expected)/expected;

        if (relError > tol) {
            BOOST_ERROR(
                   "failed to reproduce Alan Lewis Reference prices "
                << "\n    strike     : " << strike
                << "\n    option type: " << type
                << "\n    engine type: " << k
                << "\n    rel. error : " << relError);
        }
    }
}
}

for (Real strike=40; strike < 190; strike+=20) {
const boost::shared_ptr<StrikedTypePayoff> vanillaPayoff(
    new PlainVanillaPayoff(Option::Call, strike));

VanillaOption planVanillaOption(vanillaPayoff, exercise);

planVanillaOption.setPricingEngine(pdfEngine);
const Real calculated = planVanillaOption.NPV();

planVanillaOption.setPricingEngine(analyticEngine);
const Real expected = planVanillaOption.NPV();

if (std::fabs(calculated-expected) > 3*tol) {
    BOOST_FAIL(
           "failed to reproduce plain vanilla european prices with"
           " the analytic probability density engine"
        << "\n    strike     : " << strike
        << "\n    expected   : " << expected
        << "\n    calculated : " << calculated
        << "\n    diff       : " << std::fabs(calculated-expected)
        << "\n    tol        ; " << tol);
}
}

for (Real strike=40; strike < 190; strike+=10) {
VanillaOption digitalOption(
    boost::shared_ptr<StrikedTypePayoff>(
        new CashOrNothingPayoff(Option::Call, strike, 1.0)),
    exercise);
digitalOption.setPricingEngine(pdfEngine);
const Real calculated = digitalOption.NPV();

const Real eps = 0.01;
VanillaOption longCall(
    boost::shared_ptr<StrikedTypePayoff>(
        new PlainVanillaPayoff(Option::Call, strike-eps)),
    exercise);
longCall.setPricingEngine(analyticEngine);

VanillaOption shortCall(
    boost::shared_ptr<StrikedTypePayoff>(
        new PlainVanillaPayoff(Option::Call, strike+eps)),
    exercise);
shortCall.setPricingEngine(analyticEngine);

const Real expected = (longCall.NPV() - shortCall.NPV())/(2*eps);
if (std::fabs(calculated-expected) > tol) {
    BOOST_FAIL(
           "failed to reproduce european digital prices with"
           " the analytic probability density engine"
        << "\n    strike     : " << strike
        << "\n    expected   : " << expected
        << "\n    calculated : " << calculated
        << "\n    diff       : " << std::fabs(calculated-expected)
        << "\n    tol        : " << tol);
}

const DiscountFactor d = riskFreeTS->discount(maturityDate);
const Real expectedCDF = 1.0 - expected/d;
const Real calculatedCDF = pdfEngine->cdf(strike, maturity);

if (std::fabs(expectedCDF - calculatedCDF) > tol) {
    BOOST_FAIL(
           "failed to reproduce cumulative distribution function"
        << "\n    strike        : " << strike
        << "\n    expected CDF  : " << expectedCDF
        << "\n    calculated CDF: " << calculatedCDF
        << "\n    diff          : "
        << std::fabs(calculatedCDF-expectedCDF)
        << "\n    tol           : " << tol);

}
}

for (Size i=0; i < LENGTH(strikes); ++i) {
const Real strike = strikes[i];

for (Size j=0; j < LENGTH(types); ++j) {
    const Option::Type type = types[j];

    for (Size k=0; k < LENGTH(engines); ++k) {
        const boost::shared_ptr<PricingEngine> engine = engines[k];

        const boost::shared_ptr<StrikedTypePayoff> payoff =
            boost::make_shared<PlainVanillaPayoff>(type, strike);

        VanillaOption option(payoff, exercise);
        option.setPricingEngine(engine);

        const Real expected = expectedResults[i][j];
        const Real calculated = option.NPV();
        const Real relError = std::fabs(calculated-expected)/expected;

        if (relError > tol[k]) {
            BOOST_ERROR(
                   "failed to reproduce Alan Lewis Reference prices "
                << "\n    strike     : " << strike
                << "\n    option type: " << type
                << "\n    engine type: " << k
                << "\n    rel. error : " << relError);
        }
    }
}
}

for (Size j=0; j < LENGTH(terms); ++j) {
const Real term = terms[j];
const boost::shared_ptr<HestonExpansion> lpp2 =
    boost::make_shared<LPP2HestonExpansion>(kappa, theta, sigma,
                                            v0, rho, term);
const boost::shared_ptr<HestonExpansion> lpp3 =
    boost::make_shared<LPP3HestonExpansion>(kappa, theta, sigma,
                                            v0, rho, term);
const boost::shared_ptr<HestonExpansion> forde =
    boost::make_shared<FordeHestonExpansion>(kappa, theta, sigma,
                                             v0, rho, term);
const boost::shared_ptr<HestonExpansion> expansions[] = { lpp2, lpp3, forde };
for (Size i=0; i < LENGTH(strikes); ++i) {
    const Real strike = strikes[i];
    for (Size k=0; k < LENGTH(expansions); ++k) {
        const boost::shared_ptr<HestonExpansion> expansion = expansions[k];

        const Real expected = referenceVols[j][i];
        const Real calculated = expansion->impliedVolatility(strike, forward);
        const Real relError = std::fabs(calculated-expected)/expected;
        const Real refTol = strike == forward ? tolAtm[k][j] : tol[k][j];
        if (relError > refTol) {
            BOOST_ERROR(
                   "failed to reproduce Forde reference vols "
                << "\n    strike        : " << strike
                << "\n    expansion type: " << k
                << "\n    rel. error    : " << relError);
        }
    }
}
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/cdo.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i<poolSize; ++i) {
ostringstream o;
o << "issuer-" << i;
names.push_back(o.str());
basket.push_back(Handle<DefaultProbabilityTermStructure>(ptr));
issuers.push_back(Issuer(probabilities));
pool->add(names.back(), issuers.back(), NorthAmericaCorpDefaultKey(
        EURCurrency(), QuantLib::SeniorSec, Period(), 1.));
}

for (Size i = 0; i < LENGTH(hwData7); i++) {
correlation->setValue (hwData7[i].correlation);
QL_REQUIRE (LENGTH(hwAttachment) == LENGTH(hwData7[i].trancheSpread),
            "data length does not match");
std::vector<boost::shared_ptr<DefaultLossModel> > basketModels;
std::vector<std::string> modelNames;
std::vector<Real> relativeToleranceMidp, relativeTolerancePeriod,
    absoluteTolerance;

if (hwData7[i].nm == -1 && hwData7[i].nz == -1){
    boost::shared_ptr<GaussianConstantLossLM> gaussKtLossLM(new 
        GaussianConstantLossLM(hCorrelation, 
        std::vector<Real>(poolSize, recovery), 
        LatentModelIntegrationType::GaussianQuadrature, poolSize, 
        GaussianCopulaPolicy::initTraits()));

    // 1.-Inhomogeneous gaussian
    modelNames.push_back("Inhomogeneous gaussian");
    basketModels.push_back(boost::shared_ptr<DefaultLossModel>( new 
        IHGaussPoolLossModel(gaussKtLossLM, nBuckets, 5., -5, 15)));
    absoluteTolerance.push_back(1.);
    relativeToleranceMidp.push_back(0.04);
    relativeTolerancePeriod.push_back(0.04);
    // 2.-homogeneous gaussian
    modelNames.push_back("Homogeneous gaussian");
    basketModels.push_back(boost::shared_ptr<DefaultLossModel>( new 
        HomogGaussPoolLossModel(gaussKtLossLM, nBuckets, 5., -5, 15)));
    absoluteTolerance.push_back(1.);
    relativeToleranceMidp.push_back(0.04);
    relativeTolerancePeriod.push_back(0.04);
    // 3.-random default gaussian
    modelNames.push_back("Random default gaussian");
    basketModels.push_back(boost::shared_ptr<DefaultLossModel>(new 
        RandomDefaultLM<GaussianCopulaPolicy>(gaussKtLossLM, numSims)));
    absoluteTolerance.push_back(1.);
    relativeToleranceMidp.push_back(0.07);
    relativeTolerancePeriod.push_back(0.07);
    // SECOND MC
    // gaussian LHP
    modelNames.push_back("Gaussian LHP");
    basketModels.push_back(boost::shared_ptr<DefaultLossModel>(new 
        GaussianLHPLossModel(hCorrelation, 
            std::vector<Real>(poolSize, recovery))));
    absoluteTolerance.push_back(10.);
    relativeToleranceMidp.push_back(0.5);
    relativeTolerancePeriod.push_back(0.5);
    // Binomial...
    // Saddle point...
    // Recursive ...
}
else if (hwData7[i].nm > 0 && hwData7[i].nz > 0) {
    TCopulaPolicy::initTraits initTG;
    initTG.tOrders.push_back(hwData7[i].nm);
    initTG.tOrders.push_back(hwData7[i].nz);
    boost::shared_ptr<TConstantLossLM> TKtLossLM(new TConstantLossLM(
        hCorrelation, std::vector<Real>(poolSize, recovery), 
        LatentModelIntegrationType::GaussianQuadrature, 
        poolSize, 
        initTG));
    // 1.-inhomogeneous studentT
    modelNames.push_back("Inhomogeneous student");
    basketModels.push_back(boost::shared_ptr<DefaultLossModel>( new 
        IHStudentPoolLossModel(TKtLossLM, nBuckets, 5., -5., 15)));
    absoluteTolerance.push_back(1.);
    relativeToleranceMidp.push_back(0.04);
    relativeTolerancePeriod.push_back(0.04);
    // 2.-homogeneous student T
    modelNames.push_back("Homogeneous student");
    basketModels.push_back(boost::shared_ptr<DefaultLossModel>( new 
        HomogTPoolLossModel(TKtLossLM, nBuckets, 5., -5., 15)));
    absoluteTolerance.push_back(1.);
    relativeToleranceMidp.push_back(0.04);
    relativeTolerancePeriod.push_back(0.04);
    // 3.-random default student T
    modelNames.push_back("Random default studentT");
    basketModels.push_back(boost::shared_ptr<DefaultLossModel>(new 
        RandomDefaultLM<TCopulaPolicy>(TKtLossLM, numSims)));
    absoluteTolerance.push_back(1.);
    relativeToleranceMidp.push_back(0.07);
    relativeTolerancePeriod.push_back(0.07);
    // SECOND MC
    // Binomial...
    // Saddle point...
    // Recursive ...
}
else if (hwData7[i].nm > 0 && hwData7[i].nz == -1) {
    TCopulaPolicy::initTraits initTG;
    initTG.tOrders.push_back(hwData7[i].nm);
    initTG.tOrders.push_back(45);
    /* T_{55} is pretty close to a gaussian. Probably theres no need to
    be this conservative as the polynomial convolution gets shorter and
    faster as the order decreases.
    */
    boost::shared_ptr<TConstantLossLM> TKtLossLM(new TConstantLossLM(
        hCorrelation, 
        std::vector<Real>(poolSize, recovery), 
        LatentModelIntegrationType::GaussianQuadrature, 
        poolSize, 
        initTG));
    // 1.-inhomogeneous 
    modelNames.push_back("Inhomogeneous student-gaussian");
    basketModels.push_back(boost::shared_ptr<DefaultLossModel>( new 
        IHStudentPoolLossModel(TKtLossLM, nBuckets, 5., -5., 15)));
    absoluteTolerance.push_back(1.);
    relativeToleranceMidp.push_back(0.04);
    relativeTolerancePeriod.push_back(0.04);
    // 2.-homogeneous 
    modelNames.push_back("Homogeneous student-gaussian");
    basketModels.push_back(boost::shared_ptr<DefaultLossModel>( new 
        HomogTPoolLossModel(TKtLossLM, nBuckets, 5., -5., 15)));
    absoluteTolerance.push_back(1.);
    relativeToleranceMidp.push_back(0.04);
    relativeTolerancePeriod.push_back(0.04);
    // 3.-random default 
    modelNames.push_back("Random default student-gaussian");
    basketModels.push_back(boost::shared_ptr<DefaultLossModel>(new 
        RandomDefaultLM<TCopulaPolicy>(TKtLossLM, numSims)));
    absoluteTolerance.push_back(1.);
    relativeToleranceMidp.push_back(0.07);
    relativeTolerancePeriod.push_back(0.07);
    // SECOND MC
    // Binomial...
    // Saddle point...
    // Recursive ...
}
else if (hwData7[i].nm == -1 && hwData7[i].nz > 0) {
    TCopulaPolicy::initTraits initTG;
    initTG.tOrders.push_back(45);// pretty close to gaussian
    initTG.tOrders.push_back(hwData7[i].nz);
    boost::shared_ptr<TConstantLossLM> TKtLossLM(new TConstantLossLM(
        hCorrelation, 
        std::vector<Real>(poolSize, recovery), 
        LatentModelIntegrationType::GaussianQuadrature, 
        poolSize, 
        initTG));
    // 1.-inhomogeneous gaussian
    modelNames.push_back("Inhomogeneous gaussian-student");
    basketModels.push_back(boost::shared_ptr<DefaultLossModel>( new 
        IHStudentPoolLossModel(TKtLossLM, nBuckets, 5., -5., 15)));
    absoluteTolerance.push_back(1.);
    relativeToleranceMidp.push_back(0.04);
    relativeTolerancePeriod.push_back(0.04);
    // 2.-homogeneous gaussian
    modelNames.push_back("Homogeneous gaussian-student");
    basketModels.push_back(boost::shared_ptr<DefaultLossModel>( new 
        HomogTPoolLossModel(TKtLossLM, nBuckets, 5., -5., 15)));
    absoluteTolerance.push_back(1.);
    relativeToleranceMidp.push_back(0.04);
    relativeTolerancePeriod.push_back(0.04);
    // 3.-random default gaussian
    modelNames.push_back("Random default gaussian-student");
    basketModels.push_back(boost::shared_ptr<DefaultLossModel>(new 
        RandomDefaultLM<TCopulaPolicy>(TKtLossLM, numSims)));
    absoluteTolerance.push_back(1.);
    relativeToleranceMidp.push_back(0.07);
    relativeTolerancePeriod.push_back(0.07);
    // SECOND MC
    // Binomial...
    // Saddle point...
    // Recursive ...
}
else {
    continue;
}

for (Size j = 0; j < LENGTH(hwAttachment); j ++) {
    boost::shared_ptr<Basket> basketPtr (
        new Basket(asofDate, names, nominals, pool, 
            hwAttachment[j], hwDetachment[j]));
    ostringstream trancheId;
    trancheId << "[" << hwAttachment[j] << " , " << hwDetachment[j]
        << "]";
    SyntheticCDO cdoe(basketPtr, Protection::Seller,
                      schedule, 0.0, premium, daycount, Following);

    for(Size im=0; im<basketModels.size(); im++) {

        basketPtr->setLossModel(basketModels[im]);

        cdoe.setPricingEngine(midPCDOEngine);
        check(i, j, modelNames[im]
            +std::string(" with midp integration on ")+trancheId.str(), 
            cdoe.fairPremium() * 1e4, hwData7[i].trancheSpread[j], 
            absoluteTolerance[im], relativeToleranceMidp[im]);

        cdoe.setPricingEngine(integralCDOEngine);
        check(i, j, modelNames[im]
            +std::string(" with step integration on ")+trancheId.str(), 
            cdoe.fairPremium() * 1e4, hwData7[i].trancheSpread[j], 
            absoluteTolerance[im], relativeTolerancePeriod[im]);
    }
}
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/businessdayconventions.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i<n; i++) {
Calendar calendar(testCases[i].calendar);
Date result = calendar.advance(
    testCases[i].start,
    testCases[i].period,
    testCases[i].convention,
    testCases[i].endOfMonth);

BOOST_CHECK_MESSAGE(result == testCases[i].result,
                    "\ncase " << i << ":\n" //<< j << " ("<< desc << "): "
                    << "start date: " << testCases[i].start << "\n"
                    << "calendar: " << calendar << "\n"
                    << "period: " << testCases[i].period << ", end of month: " << testCases[i].endOfMonth << "\n"
                    << "convention: " << testCases[i].convention << "\n"
                    << "expected: " << testCases[i].result << " vs. actual: " << result);
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/spreadoption.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i<LENGTH(cases); ++i) {

// First step: preparing the test values
// Useful dates
DayCounter dc = Actual360();
Date today = Date::todaysDate();
Date exerciseDate = today  + cases[i].length;

// Futures values
boost::shared_ptr<SimpleQuote> F1(new SimpleQuote(cases[i].F1));
boost::shared_ptr<SimpleQuote> F2(new SimpleQuote(cases[i].F2));

// Risk-free interest rate
Rate riskFreeRate = cases[i].r;
boost::shared_ptr<YieldTermStructure> forwardRate =
    flatRate(today,riskFreeRate,dc);

// Correlation
boost::shared_ptr<Quote> rho(new SimpleQuote(cases[i].rho));

// Volatilities
Volatility vol1 = cases[i].sigma1;
Volatility vol2 = cases[i].sigma2;
boost::shared_ptr<BlackVolTermStructure> volTS1 =
    flatVol(today,vol1,dc);
boost::shared_ptr<BlackVolTermStructure> volTS2 =
    flatVol(today,vol2,dc);

// Black-Scholes Processes
// The BlackProcess is the relevant class for futures contracts
boost::shared_ptr<BlackProcess> stochProcess1(
             new BlackProcess(Handle<Quote>(F1),
                              Handle<YieldTermStructure>(forwardRate),
                              Handle<BlackVolTermStructure>(volTS1)));

boost::shared_ptr<BlackProcess> stochProcess2(
             new BlackProcess(Handle<Quote>(F2),
                              Handle<YieldTermStructure>(forwardRate),
                              Handle<BlackVolTermStructure>(volTS2)));

// Creating the pricing engine
boost::shared_ptr<PricingEngine> engine(
              new KirkSpreadOptionEngine(stochProcess1, stochProcess2,
                                         Handle<Quote>(rho)));

// Finally, create the option:
Option::Type type = Option::Call;
Real strike = cases[i].X;
boost::shared_ptr<PlainVanillaPayoff> payoff(
                                new PlainVanillaPayoff(type, strike));
boost::shared_ptr<Exercise> exercise(
                                  new EuropeanExercise(exerciseDate));

SpreadOption option(payoff, exercise);
option.setPricingEngine(engine);

// And test the data
Real calculated = option.NPV();
Real expected = cases[i].result;
Real tolerance = 1e-4;

if (std::fabs(calculated-expected) > tolerance) {
    REPORT_FAILURE("value",
                   payoff, exercise,
                   expected, calculated, tolerance);
}
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/americanoption.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i<LENGTH(values); i++) {

boost::shared_ptr<StrikedTypePayoff> payoff(new
    PlainVanillaPayoff(values[i].type, values[i].strike));
// FLOATING_POINT_EXCEPTION
Date exDate = today + Integer(values[i].t*360+0.5);
boost::shared_ptr<Exercise> exercise(
                                 new AmericanExercise(today, exDate));

spot ->setValue(values[i].s);
qRate->setValue(values[i].q);
rRate->setValue(values[i].r);
vol  ->setValue(values[i].v);

boost::shared_ptr<BlackScholesMertonProcess> stochProcess(new
    BlackScholesMertonProcess(Handle<Quote>(spot),
                              Handle<YieldTermStructure>(qTS),
                              Handle<YieldTermStructure>(rTS),
                              Handle<BlackVolTermStructure>(volTS)));

boost::shared_ptr<PricingEngine> engine(
              new BaroneAdesiWhaleyApproximationEngine(stochProcess));

VanillaOption option(payoff, exercise);
option.setPricingEngine(engine);

Real calculated = option.NPV();
Real error = std::fabs(calculated-values[i].result);
if (error > tolerance) {
    REPORT_FAILURE("value", payoff, exercise, values[i].s, values[i].q,
                   values[i].r, today, values[i].v, values[i].result,
                   calculated, error, tolerance);
}
}

for (Size i=0; i<LENGTH(values); i++) {

boost::shared_ptr<StrikedTypePayoff> payoff(new
    PlainVanillaPayoff(values[i].type, values[i].strike));
//FLOATING_POINT_EXCEPTION
Date exDate = today + Integer(values[i].t*360+0.5);
boost::shared_ptr<Exercise> exercise(
                                 new AmericanExercise(today, exDate));

spot ->setValue(values[i].s);
qRate->setValue(values[i].q);
rRate->setValue(values[i].r);
vol  ->setValue(values[i].v);

boost::shared_ptr<BlackScholesMertonProcess> stochProcess(new
    BlackScholesMertonProcess(Handle<Quote>(spot),
                              Handle<YieldTermStructure>(qTS),
                              Handle<YieldTermStructure>(rTS),
                              Handle<BlackVolTermStructure>(volTS)));

boost::shared_ptr<PricingEngine> engine(
             new BjerksundStenslandApproximationEngine(stochProcess));

VanillaOption option(payoff, exercise);
option.setPricingEngine(engine);

Real calculated = option.NPV();
Real error = std::fabs(calculated-values[i].result);
if (error > tolerance) {
    REPORT_FAILURE("value", payoff, exercise, values[i].s, values[i].q,
                   values[i].r, today, values[i].v, values[i].result,
                   calculated, error, tolerance);
}
}

for (Size i=0; i<LENGTH(juValues); i++) {

boost::shared_ptr<StrikedTypePayoff> payoff(new
    PlainVanillaPayoff(juValues[i].type, juValues[i].strike));
//FLOATING_POINT_EXCEPTION
Date exDate = today + Integer(juValues[i].t*360+0.5);
boost::shared_ptr<Exercise> exercise(
                                 new AmericanExercise(today, exDate));

spot ->setValue(juValues[i].s);
qRate->setValue(juValues[i].q);
rRate->setValue(juValues[i].r);
vol  ->setValue(juValues[i].v);

boost::shared_ptr<BlackScholesMertonProcess> stochProcess(new
    BlackScholesMertonProcess(Handle<Quote>(spot),
                              Handle<YieldTermStructure>(qTS),
                              Handle<YieldTermStructure>(rTS),
                              Handle<BlackVolTermStructure>(volTS)));

boost::shared_ptr<PricingEngine> engine(
                    new JuQuadraticApproximationEngine(stochProcess));

VanillaOption option(payoff, exercise);
option.setPricingEngine(engine);

Real calculated = option.NPV();
Real error = std::fabs(calculated-juValues[i].result);
if (error > tolerance) {
    REPORT_FAILURE("value", payoff, exercise, juValues[i].s,
                   juValues[i].q, juValues[i].r, today,
                   juValues[i].v, juValues[i].result,
                   calculated, error, tolerance);
}
}

for (Size i=0; i<LENGTH(juValues); i++) {

boost::shared_ptr<StrikedTypePayoff> payoff(new
    PlainVanillaPayoff(juValues[i].type, juValues[i].strike));

// FLOATING_POINT_EXCEPTION
Date exDate = today + Integer(juValues[i].t*360+0.5);
boost::shared_ptr<Exercise> exercise(
                                 new AmericanExercise(today, exDate));

spot ->setValue(juValues[i].s);
qRate->setValue(juValues[i].q);
rRate->setValue(juValues[i].r);
vol  ->setValue(juValues[i].v);

boost::shared_ptr<BlackScholesMertonProcess> stochProcess(new
    BlackScholesMertonProcess(Handle<Quote>(spot),
                              Handle<YieldTermStructure>(qTS),
                              Handle<YieldTermStructure>(rTS),
                              Handle<BlackVolTermStructure>(volTS)));

boost::shared_ptr<PricingEngine> engine(
          new FDAmericanEngine<CrankNicolson>(stochProcess, 100,100));

VanillaOption option(payoff, exercise);
option.setPricingEngine(engine);

Real calculated = option.NPV();
Real error = std::fabs(calculated-juValues[i].result);
if (error > tolerance) {
    REPORT_FAILURE("value", payoff, exercise, juValues[i].s,
                   juValues[i].q, juValues[i].r, today,
                   juValues[i].v, juValues[i].result,
                   calculated, error, tolerance);
}
}

for (Size i=0; i<LENGTH(types); i++) {
  for (Size j=0; j<LENGTH(strikes); j++) {
    for (Size k=0; k<LENGTH(years); k++) {
        Date exDate = today + years[k]*Years;
        boost::shared_ptr<Exercise> exercise(
                                 new AmericanExercise(today, exDate));
        boost::shared_ptr<StrikedTypePayoff> payoff(
                        new PlainVanillaPayoff(types[i], strikes[j]));
        boost::shared_ptr<BlackScholesMertonProcess> stochProcess(
                    new BlackScholesMertonProcess(Handle<Quote>(spot),
                                                  qTS, rTS, volTS));

        boost::shared_ptr<PricingEngine> engine(
                                            new Engine(stochProcess));

        VanillaOption option(payoff, exercise);
        option.setPricingEngine(engine);

        for (Size l=0; l<LENGTH(underlyings); l++) {
          for (Size m=0; m<LENGTH(qRates); m++) {
            for (Size n=0; n<LENGTH(rRates); n++) {
              for (Size p=0; p<LENGTH(vols); p++) {
                Real u = underlyings[l];
                Rate q = qRates[m],
                     r = rRates[n];
                Volatility v = vols[p];
                spot->setValue(u);
                qRate->setValue(q);
                rRate->setValue(r);
                vol->setValue(v);
                //FLOATING_POINT_EXCEPTION
                Real value = option.NPV();
                calculated["delta"]  = option.delta();
                calculated["gamma"]  = option.gamma();
                //calculated["theta"]  = option.theta();

                if (value > spot->value()*1.0e-5) {
                    // perturb spot and get delta and gamma
                    Real du = u*1.0e-4;
                    spot->setValue(u+du);
                    Real value_p = option.NPV(),
                         delta_p = option.delta();
                    spot->setValue(u-du);
                    Real value_m = option.NPV(),
                         delta_m = option.delta();
                    spot->setValue(u);
                    expected["delta"] = (value_p - value_m)/(2*du);
                    expected["gamma"] = (delta_p - delta_m)/(2*du);

                    /*
                    // perturb date and get theta
                    Time dT = dc.yearFraction(today-1, today+1);
                    Settings::instance().setEvaluationDate(today-1);
                    value_m = option.NPV();
                    Settings::instance().setEvaluationDate(today+1);
                    value_p = option.NPV();
                    Settings::instance().setEvaluationDate(today);
                    expected["theta"] = (value_p - value_m)/dT;
                    */

                    // compare
                    std::map<std::string,Real>::iterator it;
                    for (it = calculated.begin();
                         it != calculated.end(); ++it) {
                        std::string greek = it->first;
                        Real expct = expected  [greek],
                            calcl = calculated[greek],
                            tol   = tolerance [greek];
                        Real error = relativeError(expct,calcl,u);
                        if (error>tol) {
                            REPORT_FAILURE(greek, payoff, exercise,
                                           u, q, r, today, v,
                                           expct, calcl, error, tol);
                        }
                    }
                }
              }
            }
          }
        }
    }
  }
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/barrieroption.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i<LENGTH(values); i++) {
Date exDate = today + Integer(values[i].t*360+0.5);

spot ->setValue(values[i].s);
qRate->setValue(values[i].q);
rRate->setValue(values[i].r);
vol  ->setValue(values[i].v);

boost::shared_ptr<StrikedTypePayoff> payoff =
    boost::make_shared<PlainVanillaPayoff>(values[i].type,
                                           values[i].strike);

boost::shared_ptr<BlackScholesMertonProcess> stochProcess =
    boost::make_shared<BlackScholesMertonProcess>(
                              Handle<Quote>(spot),
                              Handle<YieldTermStructure>(qTS),
                              Handle<YieldTermStructure>(rTS),
                              Handle<BlackVolTermStructure>(volTS));

boost::shared_ptr<Exercise> exercise;
if (values[i].exType == Exercise::European)
    exercise = boost::make_shared<EuropeanExercise>(exDate);
else
    exercise = boost::make_shared<AmericanExercise>(exDate);

BarrierOption barrierOption(
        values[i].barrierType,
        values[i].barrier,
        values[i].rebate,
        payoff,
        exercise);

boost::shared_ptr<PricingEngine> engine;
Real calculated;
Real expected;
Real error;
if (values[i].exType == Exercise::European) {
   // these engines support only european options
   engine = boost::make_shared<AnalyticBarrierEngine>(stochProcess);

   barrierOption.setPricingEngine(engine);

   Real calculated = barrierOption.NPV();
   Real expected = values[i].result;
   Real error = std::fabs(calculated-expected);
   if (error>values[i].tol) {
       REPORT_FAILURE("value", values[i].barrierType, values[i].barrier,
                      values[i].rebate, payoff, exercise, values[i].s,
                      values[i].q, values[i].r, today, values[i].v,
                      expected, calculated, error, values[i].tol);
   }

   engine = boost::make_shared<FdBlackScholesBarrierEngine>(stochProcess, 200, 400);
   barrierOption.setPricingEngine(engine);

   calculated = barrierOption.NPV();
   expected = values[i].result;
   error = std::fabs(calculated-expected);
   if (error>5.0e-3) {
       REPORT_FAILURE("fd value", values[i].barrierType, values[i].barrier,
                      values[i].rebate, payoff, exercise, values[i].s,
                      values[i].q, values[i].r, today, values[i].v,
                      expected, calculated, error, values[i].tol);
   }
}

engine = boost::make_shared<BinomialBarrierEngine<CoxRossRubinstein,DiscretizedBarrierOption> >(stochProcess, 400);
barrierOption.setPricingEngine(engine);

calculated = barrierOption.NPV();
expected = values[i].result;
error = std::fabs(calculated-expected);
double tol = 1.1e-2;
if (error>tol) {
    REPORT_FAILURE("Binomial (Boyle-lau) value", values[i].barrierType, values[i].barrier,
                   values[i].rebate, payoff, exercise, values[i].s,
                   values[i].q, values[i].r, today, values[i].v,
                   expected, calculated, error, tol);
}

// Note: here, to test Derman convergence, we force maxTimeSteps to 
// timeSteps, effectively disabling Boyle-Lau barrier adjustment.
// Production code should always enable Boyle-Lau. In most cases it
// gives very good convergence with only a modest timeStep increment.
engine = boost::make_shared<BinomialBarrierEngine<CoxRossRubinstein,DiscretizedDermanKaniBarrierOption> >(stochProcess, 400);
barrierOption.setPricingEngine(engine);
calculated = barrierOption.NPV();
expected = values[i].result;
error = std::fabs(calculated-expected);
tol = 4e-2;
if (error>tol) {
    REPORT_FAILURE("Binomial (Derman) value", values[i].barrierType, values[i].barrier,
                   values[i].rebate, payoff, exercise, values[i].s,
                   values[i].q, values[i].r, today, values[i].v,
                   expected, calculated, error, tol);
}
}

for (Size i=0; i<LENGTH(values); i++) {
volatility->setValue(values[i].volatility);

boost::shared_ptr<StrikedTypePayoff> callPayoff =
    boost::make_shared<PlainVanillaPayoff>(Option::Call,
                                           values[i].strike);

boost::shared_ptr<BlackScholesMertonProcess> stochProcess =
    boost::make_shared<BlackScholesMertonProcess>(
                              Handle<Quote>(underlying),
                              Handle<YieldTermStructure>(qTS),
                              Handle<YieldTermStructure>(rTS),
                              Handle<BlackVolTermStructure>(volTS));


boost::shared_ptr<PricingEngine> engine =
    boost::make_shared<AnalyticBarrierEngine>(stochProcess);

// analytic
BarrierOption barrierCallOption(
        values[i].type,
        values[i].barrier,
        rebate,
        callPayoff,
        exercise);
barrierCallOption.setPricingEngine(engine);
Real calculated = barrierCallOption.NPV();
Real expected = values[i].callValue;
Real error = std::fabs(calculated-expected);
Real maxErrorAllowed = 1.0e-5;
if (error>maxErrorAllowed) {
    REPORT_FAILURE("value", values[i].type, values[i].barrier,
                   rebate, callPayoff, exercise, underlyingPrice,
                   q, r, today, values[i].volatility,
                   expected, calculated, error, maxErrorAllowed);
}

Real maxMcRelativeErrorAllowed = 2.0e-2;

boost::shared_ptr<PricingEngine> mcEngine =
    MakeMCBarrierEngine<LowDiscrepancy>(stochProcess)
    .withStepsPerYear(1)
    .withBrownianBridge()
    .withSamples(131071) // 2^17-1
    .withMaxSamples(1048575) // 2^20-1
    .withSeed(5);

barrierCallOption.setPricingEngine(mcEngine);
calculated = barrierCallOption.NPV();
error = std::fabs(calculated-expected)/expected;
if (error>maxMcRelativeErrorAllowed) {
    REPORT_FAILURE("value", values[i].type, values[i].barrier,
                   rebate, callPayoff, exercise, underlyingPrice,
                   q, r, today, values[i].volatility,
                   expected, calculated, error,
                   maxMcRelativeErrorAllowed);
}

}

for (Size i=0; i<LENGTH(values); i++) {
volatility->setValue(values[i].volatility);

boost::shared_ptr<StrikedTypePayoff> callPayoff =
    boost::make_shared<PlainVanillaPayoff>(Option::Call,
                                           values[i].strike);

boost::shared_ptr<BlackScholesMertonProcess> stochProcess =
    boost::make_shared<BlackScholesMertonProcess>(
                              Handle<Quote>(underlying),
                              Handle<YieldTermStructure>(qTS),
                              Handle<YieldTermStructure>(rTS),
                              Handle<BlackVolTermStructure>(volTS));

boost::shared_ptr<PricingEngine> engine =
    boost::make_shared<AnalyticBarrierEngine>(stochProcess);

BarrierOption barrierCallOption(
        values[i].type,
        values[i].barrier,
        rebate,
        callPayoff,
        exercise);
barrierCallOption.setPricingEngine(engine);
Real calculated = barrierCallOption.NPV();
Real expected = values[i].callValue;
Real maxErrorAllowed = 1.0e-3;
Real error = std::fabs(calculated-expected);
if (error > maxErrorAllowed) {
    REPORT_FAILURE("value", values[i].type, values[i].barrier,
                   rebate, callPayoff, exercise, underlyingPrice,
                   q, r, today, values[i].volatility,
                   expected, calculated, error, maxErrorAllowed);
}

Real maxMcRelativeErrorAllowed = 0.01;
boost::shared_ptr<PricingEngine> mcEngine =
    MakeMCBarrierEngine<LowDiscrepancy>(stochProcess)
    .withStepsPerYear(1)
    .withBrownianBridge()
    .withSamples(131071) // 2^17-1
    .withMaxSamples(1048575) // 2^20-1
    .withSeed(10);

barrierCallOption.setPricingEngine(mcEngine);
calculated = barrierCallOption.NPV();
error = std::fabs(calculated-expected)/expected;
if (error>maxMcRelativeErrorAllowed) {
    REPORT_FAILURE("value", values[i].type, values[i].barrier,
                   rebate, callPayoff, exercise, underlyingPrice,
                   q, r, today, values[i].volatility,
                   expected, calculated, error,
                   maxMcRelativeErrorAllowed);
}
}

for (Size i = 0; i < 8; ++i) {
dates.push_back(settlementDate + t[i]);
rates.push_back(r[i]);
}

for (Size i=0; i < strikes.size(); ++i)
for (Size j=1; j < dates.size(); ++j) {
    blackVolMatrix[i][j-1] = v[i*(dates.size()-1)+j-1];
}

for (Size i=0; i<LENGTH(values); i++) {

spot->setValue(values[i].s);
qRate->setValue(values[i].q);
rRate->setValue(values[i].r);
vol25Put->setValue(values[i].vol25Put);
volAtm->setValue(values[i].volAtm);
vol25Call->setValue(values[i].vol25Call);

boost::shared_ptr<StrikedTypePayoff> payoff =
    boost::make_shared<PlainVanillaPayoff>(values[i].type,
                                           values[i].strike);

Date exDate = today + Integer(values[i].t*365+0.5);
boost::shared_ptr<Exercise> exercise =
    boost::make_shared<EuropeanExercise>(exDate);

Handle<DeltaVolQuote> volAtmQuote = Handle<DeltaVolQuote>(
				boost::make_shared<DeltaVolQuote>(
					Handle<Quote>(volAtm),
					DeltaVolQuote::Fwd,
					values[i].t,
					DeltaVolQuote::AtmDeltaNeutral));

Handle<DeltaVolQuote> vol25PutQuote(Handle<DeltaVolQuote>(
				boost::make_shared<DeltaVolQuote>(
					-0.25,
					Handle<Quote>(vol25Put),
					values[i].t,
					DeltaVolQuote::Fwd
					)));

Handle<DeltaVolQuote> vol25CallQuote(Handle<DeltaVolQuote>(
				boost::make_shared<DeltaVolQuote>(
					0.25,
					Handle<Quote>(vol25Call),
					values[i].t,
					DeltaVolQuote::Fwd
					)));

BarrierOption barrierOption(values[i].barrierType,
                            values[i].barrier,
                            values[i].rebate,
                            payoff,
                            exercise);

Real bsVanillaPrice =
    blackFormula(values[i].type, values[i].strike,
                 spot->value()*qTS->discount(values[i].t)/rTS->discount(values[i].t),
				 values[i].v * sqrt(values[i].t), rTS->discount(values[i].t));
boost::shared_ptr<PricingEngine> vannaVolgaEngine =
    boost::make_shared<VannaVolgaBarrierEngine>(
                    volAtmQuote,
					vol25PutQuote,
					vol25CallQuote,
					Handle<Quote> (spot),
					Handle<YieldTermStructure> (rTS),
					Handle<YieldTermStructure> (qTS),
					true,
					bsVanillaPrice);
barrierOption.setPricingEngine(vannaVolgaEngine);

Real calculated = barrierOption.NPV();
Real expected = values[i].result;
Real error = std::fabs(calculated-expected);
if (error>values[i].tol) {
    REPORT_FX_FAILURE(
        "value", values[i].barrierType, values[i].barrier,
        values[i].rebate, payoff, exercise, values[i].s,
        values[i].q, values[i].r, today, values[i].vol25Put,
        values[i].volAtm, values[i].vol25Call, values[i].v,
        expected, calculated, error, values[i].tol);
}
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/gaussianquadratures.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i<LENGTH(order); i++) {
    quad.order(order[i]);
    Real realised = quad(f);
    if (std::fabs(realised-expected) > tolerance) {
        BOOST_ERROR(" integrating " << tag << "\n"
                    << "    order " << order[i] << "\n"
                    << "    realised: " << realised << "\n"
                    << "    expected: " << expected);
    }
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/amortizingbond.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for(Size i=0; i<LENGTH(rates); ++i) {

AmortizingFixedRateBond
	myBond(0, NullCalendar(), 100.0, refDate, Period(30, Years), freq, rates[i], ActualActual(ActualActual::ISMA));

Leg cashflows = myBond.cashflows();

std::vector<Real> notionals = myBond.notionals();

for(Size k=0; k < cashflows.size() / 2; ++k) {
	Real coupon = cashflows[2*k]->amount();
	Real principal = cashflows[2*k+1]->amount();
	Real totalAmount = coupon + principal;

	// Check the amount is same as pmt returned

	Real error = std::fabs(totalAmount-amounts[i]);
	if (error > tolerance) {
		BOOST_ERROR("\n" <<
			        " Rate: " << rates[i] <<
					" " << k << "th cash flow " 
					" Failed!" <<
					" Expected Amount: " << amounts[i] <<
					" Calculated Amount: " << totalAmount);
	}

	// Check the coupon result
	Real expectedCoupon = notionals[k] * rates[i] / freq;
	error = std::fabs(coupon- expectedCoupon);

	if(error > tolerance) {
		BOOST_ERROR("\n" <<
			" Rate: " << rates[i] <<
			" " << k << "th cash flow " 
			" Failed!" <<
			" Expected Coupon: " << expectedCoupon <<
			" Calculated Coupon: " << coupon);
	}

}
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/cashflows.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Integer i=0; i<3; ++i)
leg.push_back(shared_ptr<CashFlow>(new SimpleCashFlow(1.0, today+i)));

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/daycounters.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i<n; i++) {
ActualActual dayCounter(testCases[i].convention);
Date d1 = testCases[i].start,
    d2 = testCases[i].end,
    rd1 = testCases[i].refStart,
    rd2 = testCases[i].refEnd;
Time calculated = dayCounter.yearFraction(d1,d2,rd1,rd2);

if (std::fabs(calculated-testCases[i].result) > 1.0e-10) {
    std::ostringstream period, refPeriod;
    period << "period: " << d1 << " to " << d2;
    if (testCases[i].convention == ActualActual::ISMA)
        refPeriod << "referencePeriod: " << rd1 << " to " << rd2;
    BOOST_FAIL(dayCounter.name() << ":\n"
               << period.str() << "\n" << refPeriod.str() << "\n"
               << std::setprecision(10)
               << "    calculated: " << calculated << "\n"
               << "    expected:   " << testCases[i].result);
}
}

for (Date start = first; start <= last; start++) {
for (Size i=0; i<n; i++) {
    Date end = start + p[i];
    Time calculated = dayCounter.yearFraction(start,end);
    if (std::fabs(calculated-expected[i]) > 1.0e-12) {
        BOOST_FAIL("from " << start << " to " << end << ":\n"
                   << std::setprecision(12)
                   << "    calculated: " << calculated << "\n"
                   << "    expected:   " << expected[i]);
    }
}
}

for (Date start = first; start <= last; start++) {
for (Size i=0; i<n; i++) {
    Date end = start + p[i];
    Time calculated = dayCounter.yearFraction(start,end);
    if (std::fabs(calculated-expected[i]) > 1.0e-12) {
        BOOST_FAIL("from " << start << " to " << end << ":\n"
                   << std::setprecision(12)
                   << "    calculated: " << calculated << "\n"
                   << "    expected:   " << expected[i]);
    }
}
}

for (Size i=1; i<testDates.size(); i++) {
calculated = dayCounter1.yearFraction(testDates[i-1],testDates[i]);
if (std::fabs(calculated-expected[i-1]) > 1.0e-12) {
        BOOST_ERROR("from " << testDates[i-1]
                    << " to " << testDates[i] << ":\n"
                    << std::setprecision(14)
                    << "    calculated: " << calculated << "\n"
                    << "    expected:   " << expected[i-1]);
}
}

for (Size i=1; i<testDates.size(); i++) {
calculated = dayCounter2.yearFraction(testDates[i-1],testDates[i]);
if (std::fabs(calculated-expected[i-1]) > 1.0e-12) {
        BOOST_ERROR("from " << testDates[i-1]
                    << " to " << testDates[i] << ":\n"
                    << std::setprecision(14)
                    << "    calculated: " << calculated << "\n"
                    << "    expected:   " << expected[i-1]);
}
}

for (Size i = 0; i < testStartDates.size(); i++) {
calculated = dayCounter.dayCount(testStartDates[i], testEndDates[i]);
if (calculated != expected[i]) {
        BOOST_ERROR("from " << testStartDates[i]
                    << " to " << testEndDates[i] << ":\n"
                    << "    calculated: " << calculated << "\n"
                    << "    expected:   " << expected[i]);
}
}

for (Size i = 0; i < testStartDates.size(); i++) {
calculated = dayCounter.dayCount(testStartDates[i], testEndDates[i]);
if (calculated != expected[i]) {
        BOOST_ERROR("from " << testStartDates[i]
                    << " to " << testEndDates[i] << ":\n"
                    << "    calculated: " << calculated << "\n"
                    << "    expected:   " << expected[i]);
}
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/piecewiseyieldcurve.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    for (Size i=0; i<deposits; i++) {
        rates[i] = boost::shared_ptr<SimpleQuote>(
                            new SimpleQuote(depositData[i].rate/100));
    }

    for (Size i=0; i<swaps; i++) {
        rates[i+deposits] = boost::shared_ptr<SimpleQuote>(
                               new SimpleQuote(swapData[i].rate/100));
    }

    for (Size i=0; i<fras; i++) {
        fraRates[i] = boost::shared_ptr<SimpleQuote>(
                                new SimpleQuote(fraData[i].rate/100));
    }

    for (Size i = 0; i<bonds; i++) {
        prices[i] = boost::shared_ptr<SimpleQuote>(
                                  new SimpleQuote(bondData[i].price));
    }

    for (Size i = 0; i<immFuts; i++) {
        immFutPrices[i] = boost::shared_ptr<SimpleQuote>(
            new SimpleQuote(100.0 - immFutData[i].rate));
    }

    for (Size i = 0; i<asxFuts; i++) {
        asxFutPrices[i] = boost::shared_ptr<SimpleQuote>(
            new SimpleQuote(100.0 - asxFutData[i].rate));
    }

    for (Size i = 0; i<bmas; i++) {
        fractions[i] = boost::shared_ptr<SimpleQuote>(
                                new SimpleQuote(bmaData[i].rate/100));
    }

    for (Size i=0; i<deposits; i++) {
        Handle<Quote> r(rates[i]);
        instruments[i] = boost::shared_ptr<RateHelper>(new
            DepositRateHelper(r, depositData[i].n*depositData[i].units,
                              euribor6m->fixingDays(), calendar,
                              euribor6m->businessDayConvention(),
                              euribor6m->endOfMonth(),
                              euribor6m->dayCounter()));
    }

    for (Size i=0; i<swaps; i++) {
        Handle<Quote> r(rates[i+deposits]);
        instruments[i+deposits] = boost::shared_ptr<RateHelper>(new
            SwapRateHelper(r, swapData[i].n*swapData[i].units,
                           calendar,
                           fixedLegFrequency, fixedLegConvention,
                           fixedLegDayCounter, euribor6m));
    }

    for (Size i=0; i<fras; i++) {
        Handle<Quote> r(fraRates[i]);
        fraHelpers[i] = boost::shared_ptr<RateHelper>(new
            FraRateHelper(r, fraData[i].n, fraData[i].n + 3,
                          euribor3m->fixingDays(),
                          euribor3m->fixingCalendar(),
                          euribor3m->businessDayConvention(),
                          euribor3m->endOfMonth(),
                          euribor3m->dayCounter()));
    }

    for (Size i = 0; i<immFuts; i++) {
        Handle<Quote> r(immFutPrices[i]);
        immDate = IMM::nextDate(immDate, false);
        // if the fixing is before the evaluation date, we
        // just jump forward by one future maturity
        if (euribor3m->fixingDate(immDate) <
            Settings::instance().evaluationDate())
            immDate = IMM::nextDate(immDate, false);
        immFutHelpers[i] = boost::shared_ptr<RateHelper>(new
            FuturesRateHelper(r, immDate, euribor3m, Handle<Quote>(),
                              Futures::IMM));
    }

    for (Size i = 0; i<asxFuts; i++) {
        Handle<Quote> r(asxFutPrices[i]);
        asxDate = ASX::nextDate(asxDate, false);
        // if the fixing is before the evaluation date, we
        // just jump forward by one future maturity
        if (euribor3m->fixingDate(asxDate) <
            Settings::instance().evaluationDate())
            asxDate = ASX::nextDate(asxDate, false);
        asxFutHelpers[i] = boost::shared_ptr<RateHelper>(new
            FuturesRateHelper(r, asxDate, euribor3m, Handle<Quote>(),
                              Futures::ASX));
    }

    for (Size i=0; i<bonds; i++) {
        Handle<Quote> p(prices[i]);
        Date maturity =
            calendar.advance(today, bondData[i].n, bondData[i].units);
        Date issue =
            calendar.advance(maturity, -bondData[i].length, Years);
        std::vector<Rate> coupons(1, bondData[i].coupon/100.0);
        schedules[i] = Schedule(issue, maturity,
                                Period(bondData[i].frequency),
                                calendar,
                                bondConvention, bondConvention,
                                DateGeneration::Backward, false);
        bondHelpers[i] = boost::shared_ptr<RateHelper>(new
            FixedRateBondHelper(p,
                                bondSettlementDays,
                                bondRedemption, schedules[i],
                                coupons, bondDayCounter,
                                bondConvention,
                                bondRedemption, issue));
    }

for (Size i=0; i<vars.deposits; i++) {
    Euribor index(depositData[i].n*depositData[i].units,curveHandle);
    Rate expectedRate  = depositData[i].rate/100,
         estimatedRate = index.fixing(vars.today);
    if (std::fabs(expectedRate-estimatedRate) > tolerance) {
        BOOST_ERROR(
            depositData[i].n << " "
            << (depositData[i].units == Weeks ? "week(s)" : "month(s)")
            << " deposit:"
            << std::setprecision(8)
            << "\n    estimated rate: " << io::rate(estimatedRate)
            << "\n    expected rate:  " << io::rate(expectedRate));
    }
}

for (Size i=0; i<vars.swaps; i++) {
    Period tenor = swapData[i].n*swapData[i].units;

    VanillaSwap swap = MakeVanillaSwap(tenor, euribor6m, 0.0)
        .withEffectiveDate(vars.settlement)
        .withFixedLegDayCount(vars.fixedLegDayCounter)
        .withFixedLegTenor(Period(vars.fixedLegFrequency))
        .withFixedLegConvention(vars.fixedLegConvention)
        .withFixedLegTerminationDateConvention(vars.fixedLegConvention);

    Rate expectedRate = swapData[i].rate/100,
         estimatedRate = swap.fairRate();
    Spread error = std::fabs(expectedRate-estimatedRate);
    if (error > tolerance) {
        BOOST_ERROR(
            swapData[i].n << " year(s) swap:\n"
            << std::setprecision(8)
            << "\n estimated rate: " << io::rate(estimatedRate)
            << "\n expected rate:  " << io::rate(expectedRate)
            << "\n error:          " << io::rate(error)
            << "\n tolerance:      " << io::rate(tolerance));
    }
}

for (Size i=0; i<vars.bonds; i++) {
    Date maturity = vars.calendar.advance(vars.today,
                                          bondData[i].n,
                                          bondData[i].units);
    Date issue = vars.calendar.advance(maturity,
                                       -bondData[i].length,
                                       Years);
    std::vector<Rate> coupons(1, bondData[i].coupon/100.0);

    FixedRateBond bond(vars.bondSettlementDays, 100.0,
                       vars.schedules[i], coupons,
                       vars.bondDayCounter, vars.bondConvention,
                       vars.bondRedemption, issue);

    boost::shared_ptr<PricingEngine> bondEngine(
                              new DiscountingBondEngine(curveHandle));
    bond.setPricingEngine(bondEngine);

    Real expectedPrice = bondData[i].price,
         estimatedPrice = bond.cleanPrice();
    Real error = std::fabs(expectedPrice-estimatedPrice);
    if (error > tolerance) {
        BOOST_ERROR(io::ordinal(i+1) << " bond failure:" <<
                    std::setprecision(8) <<
                    "\n  estimated price: " << estimatedPrice <<
                    "\n  expected price:  " << expectedPrice <<
                    "\n  error:           " << error);
    }
}

for (Size i=0; i<vars.fras; i++) {
    Date start =
        vars.calendar.advance(vars.settlement,
                              fraData[i].n,
                              fraData[i].units,
                              euribor3m->businessDayConvention(),
                              euribor3m->endOfMonth());
    Date end = vars.calendar.advance(start, 3, Months,
                                     euribor3m->businessDayConvention(),
                                     euribor3m->endOfMonth());

    ForwardRateAgreement fra(start, end, Position::Long,
                             fraData[i].rate/100, 100.0,
                             euribor3m, curveHandle);
    Rate expectedRate = fraData[i].rate/100,
         estimatedRate = fra.forwardRate();
    if (std::fabs(expectedRate-estimatedRate) > tolerance) {
        BOOST_ERROR(io::ordinal(i+1) << " FRA failure:" <<
                    std::setprecision(8) <<
                    "\n  estimated rate: " << io::rate(estimatedRate) <<
                    "\n  expected rate:  " << io::rate(expectedRate));
    }
}

for (Size i = 0; i<vars.immFuts; i++) {
    immStart = IMM::nextDate(immStart, false);
    // if the fixing is before the evaluation date, we
    // just jump forward by one future maturity
    if (euribor3m->fixingDate(immStart) <
        Settings::instance().evaluationDate())
        immStart = IMM::nextDate(immStart, false);
    Date end = vars.calendar.advance(immStart, 3, Months,
        euribor3m->businessDayConvention(),
        euribor3m->endOfMonth());

    ForwardRateAgreement immFut(immStart, end, Position::Long,
        immFutData[i].rate / 100, 100.0,
        euribor3m, curveHandle);
    Rate expectedRate = immFutData[i].rate / 100,
        estimatedRate = immFut.forwardRate();
    if (std::fabs(expectedRate - estimatedRate) > tolerance) {
        BOOST_ERROR(io::ordinal(i + 1) << " IMM futures failure:" <<
            std::setprecision(8) <<
            "\n  estimated rate: " << io::rate(estimatedRate) <<
            "\n  expected rate:  " << io::rate(expectedRate));
    }
}

for (Size i = 0; i<vars.asxFuts; i++) {
    asxStart = ASX::nextDate(asxStart, false);
    // if the fixing is before the evaluation date, we
    // just jump forward by one future maturity
    if (euribor3m->fixingDate(asxStart) <
        Settings::instance().evaluationDate())
        asxStart = ASX::nextDate(asxStart, false);
    Date end = vars.calendar.advance(asxStart, 3, Months,
        euribor3m->businessDayConvention(),
        euribor3m->endOfMonth());

    ForwardRateAgreement asxFut(asxStart, end, Position::Long,
        asxFutData[i].rate / 100, 100.0,
        euribor3m, curveHandle);
    Rate expectedRate = asxFutData[i].rate / 100,
        estimatedRate = asxFut.forwardRate();
    if (std::fabs(expectedRate - estimatedRate) > tolerance) {
        BOOST_ERROR(io::ordinal(i + 1) << " ASX futures failure:" <<
            std::setprecision(8) <<
            "\n  estimated rate: " << io::rate(estimatedRate) <<
            "\n  expected rate:  " << io::rate(expectedRate));
    }
}

for (Size i=0; i<vars.bmas; ++i) {
    Handle<Quote> f(vars.fractions[i]);
    vars.bmaHelpers[i] = boost::shared_ptr<RateHelper>(
              new BMASwapRateHelper(f, bmaData[i].n*bmaData[i].units,
                                    vars.settlementDays,
                                    vars.calendar,
                                    Period(vars.bmaFrequency),
                                    vars.bmaConvention,
                                    vars.bmaDayCounter,
                                    bmaIndex,
                                    liborIndex));
}

for (Size i=0; i<vars.bmas; i++) {
    Period tenor = bmaData[i].n*bmaData[i].units;

    Schedule bmaSchedule =
        MakeSchedule().from(vars.settlement)
                      .to(vars.settlement+tenor)
                      .withFrequency(vars.bmaFrequency)
                      .withCalendar(bma->fixingCalendar())
                      .withConvention(vars.bmaConvention)
                      .backwards();
    Schedule liborSchedule =
        MakeSchedule().from(vars.settlement)
                      .to(vars.settlement+tenor)
                      .withTenor(libor3m->tenor())
                      .withCalendar(libor3m->fixingCalendar())
                      .withConvention(libor3m->businessDayConvention())
                      .endOfMonth(libor3m->endOfMonth())
                      .backwards();


    BMASwap swap(BMASwap::Payer, 100.0,
                 liborSchedule, 0.75, 0.0,
                 libor3m, libor3m->dayCounter(),
                 bmaSchedule, bma, vars.bmaDayCounter);
    swap.setPricingEngine(boost::shared_ptr<PricingEngine>(
      new DiscountingSwapEngine(libor3m->forwardingTermStructure())));

    Real expectedFraction = bmaData[i].rate/100,
         estimatedFraction = swap.fairLiborFraction();
    Real error = std::fabs(expectedFraction-estimatedFraction);
    if (error > tolerance) {
        BOOST_ERROR(bmaData[i].n << " year(s) BMA swap:\n"
                    << std::setprecision(8)
                    << "\n estimated libor fraction: " << estimatedFraction
                    << "\n expected libor fraction:  " << expectedFraction
                    << "\n error:          " << error
                    << "\n tolerance:      " << tolerance);
    }
}

for (Size i=0; i<vars.deposits+vars.swaps; i++) {
Time testTime =
    Actual360().yearFraction(vars.settlement,
                             vars.instruments[i]->latestDate());
DiscountFactor discount = vars.termStructure->discount(testTime);
f.lower();
vars.rates[i]->setValue(vars.rates[i]->value()*1.01);
if (!f.isUp())
    BOOST_FAIL("Observer was not notified of underlying rate change");
if (vars.termStructure->discount(testTime,true) == discount)
    BOOST_FAIL("rate change did not trigger recalculation");
vars.rates[i]->setValue(vars.rates[i]->value()/1.01);
}

for (Size i=0; i<vars.swaps; i++) {
Handle<Quote> r(vars.rates[i+vars.deposits]);
swapHelpers[i] = boost::shared_ptr<RateHelper>(new
    SwapRateHelper(r, Period(swapData[i].n, swapData[i].units),
                   vars.calendar,
                   vars.fixedLegFrequency, vars.fixedLegConvention,
                   vars.fixedLegDayCounter, euribor6m));
}

for (Size i=0; i<vars.swaps; i++) {
Period tenor = swapData[i].n*swapData[i].units;

VanillaSwap swap = MakeVanillaSwap(tenor, index, 0.0)
    .withEffectiveDate(vars.settlement)
    .withFixedLegDayCount(vars.fixedLegDayCounter)
    .withFixedLegTenor(Period(vars.fixedLegFrequency))
    .withFixedLegConvention(vars.fixedLegConvention)
    .withFixedLegTerminationDateConvention(vars.fixedLegConvention);

Rate expectedRate = swapData[i].rate/100,
     estimatedRate = swap.fairRate();
Real tolerance = 1.0e-9;
if (std::fabs(expectedRate-estimatedRate) > tolerance) {
    BOOST_ERROR("before LIBOR fixing:\n"
                << swapData[i].n << " year(s) swap:\n"
                << std::setprecision(8)
                << "    estimated rate: "
                << io::rate(estimatedRate) << "\n"
                << "    expected rate:  "
                << io::rate(expectedRate));
}
}

for (Size i=0; i<vars.swaps; i++) {
Period tenor = swapData[i].n*swapData[i].units;

VanillaSwap swap = MakeVanillaSwap(tenor, index, 0.0)
    .withEffectiveDate(vars.settlement)
    .withFixedLegDayCount(vars.fixedLegDayCounter)
    .withFixedLegTenor(Period(vars.fixedLegFrequency))
    .withFixedLegConvention(vars.fixedLegConvention)
    .withFixedLegTerminationDateConvention(vars.fixedLegConvention);

Rate expectedRate = swapData[i].rate/100,
     estimatedRate = swap.fairRate();
Real tolerance = 1.0e-9;
if (std::fabs(expectedRate-estimatedRate) > tolerance) {
    BOOST_ERROR("after LIBOR fixing:\n"
                << swapData[i].n << " year(s) swap:\n"
                << std::setprecision(8)
                << "    estimated rate: "
                << io::rate(estimatedRate) << "\n"
                << "    expected rate:  "
                << io::rate(expectedRate));
}
}

for (Size i=0; i<vars.swaps; i++) {
vars.rates[i] = boost::shared_ptr<SimpleQuote>(
                               new SimpleQuote(swapData[i].rate/100));
}

for (Size i=0; i<vars.swaps; i++) {
Handle<Quote> r(vars.rates[i]);
vars.instruments[i] = boost::shared_ptr<RateHelper>(
   new SwapRateHelper(r, swapData[i].n*swapData[i].units,
                      vars.calendar,
                      vars.fixedLegFrequency, vars.fixedLegConvention,
                      vars.fixedLegDayCounter, index));
}

for (Size i=0; i<vars.swaps; i++) {
Period tenor = swapData[i].n*swapData[i].units;

VanillaSwap swap = MakeVanillaSwap(tenor, jpylibor6m, 0.0)
    .withEffectiveDate(vars.settlement)
    .withFixedLegDayCount(vars.fixedLegDayCounter)
    .withFixedLegTenor(Period(vars.fixedLegFrequency))
    .withFixedLegConvention(vars.fixedLegConvention)
    .withFixedLegTerminationDateConvention(vars.fixedLegConvention)
    .withFixedLegCalendar(vars.calendar)
    .withFloatingLegCalendar(vars.calendar);

Rate expectedRate = swapData[i].rate/100,
     estimatedRate = swap.fairRate();
Spread error = std::fabs(expectedRate-estimatedRate);
Real tolerance = 1.0e-9;

if (error > tolerance) {
    BOOST_ERROR(swapData[i].n << " year(s) swap:\n"
                << std::setprecision(8)
                << "\n estimated rate: " << io::rate(estimatedRate)
                << "\n expected rate:  " << io::rate(expectedRate)
                << "\n error:          " << io::rate(error)
                << "\n tolerance:      " << io::rate(tolerance));
}
}

for (Size i=0; i<vars.rates.size(); ++i) {
    vars.rates[i]->setValue(vars.rates[i]->value() + 0.001);
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/interpolations.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i<points-1; i++)
    x[i] = start+i*dx;

for (Size i=0; i<x.size(); i++)
    y[i] = std::exp(-x[i]*x[i]);

for (Size i=0; i<x.size(); i++)
    y[i] = -x[i]*x[i];

for (Real x = xMin; x < 0.0; x += 0.1) {
    Real y1 = cubic(x), y2 = cubic(-x);
    if (std::fabs(y1-y2) > tolerance) {
        BOOST_ERROR(type << " interpolation not symmetric"
                    << "\n    x = " << x
                    << "\n    g(x)  = " << y1
                    << "\n    g(-x) = " << y2
                    << "\n    error:  " << std::fabs(y1-y2));
    }
}

for (Size i=0; i<LENGTH(points); i++) {
Size n = points[i];
std::vector<Real> x = xRange(-1.7, 1.9, n);
std::vector<Real> y = gaussian(x);

// Not-a-knot
CubicInterpolation f(x.begin(), x.end(), y.begin(),
                     CubicInterpolation::Spline, false,
                     CubicInterpolation::NotAKnot, Null<Real>(),
                     CubicInterpolation::NotAKnot, Null<Real>());
f.update();
Real result = std::sqrt(integral(make_error_function(f), -1.7, 1.9));
result /= scaleFactor;
if (std::fabs(result-tabulatedErrors[i]) > toleranceOnTabErr[i])
    BOOST_ERROR("Not-a-knot spline interpolation "
                << "\n    sample points:      " << n
                << "\n    norm of difference: " << result
                << "\n    it should be:       " << tabulatedErrors[i]);

// MC not-a-knot
f = CubicInterpolation(x.begin(), x.end(), y.begin(),
                       CubicInterpolation::Spline, true,
                       CubicInterpolation::NotAKnot, Null<Real>(),
                       CubicInterpolation::NotAKnot, Null<Real>());
f.update();
result = std::sqrt(integral(make_error_function(f), -1.7, 1.9));
result /= scaleFactor;
if (std::fabs(result-tabulatedMCErrors[i]) > toleranceOnTabMCErr[i])
    BOOST_ERROR("MC Not-a-knot spline interpolation "
                << "\n    sample points:      " << n
                << "\n    norm of difference: " << result
                << "\n    it should be:       "
                << tabulatedMCErrors[i]);
}

for (Real start = -1.9, j=0; j<2; start+=0.2, j++) {
x = xRange(start, start+3.6, n);
y = gaussian(x);

// Not-a-knot spline
CubicInterpolation f(x.begin(), x.end(), y.begin(),
                     CubicInterpolation::Spline, false,
                     CubicInterpolation::NotAKnot, Null<Real>(),
                     CubicInterpolation::NotAKnot, Null<Real>());
f.update();
checkValues("Not-a-knot spline", f,
            x.begin(), x.end(), y.begin());
checkNotAKnotCondition("Not-a-knot spline", f);
// bad performance
interpolated = f(x1_bad);
interpolated2= f(x2_bad);
if (interpolated>0.0 && interpolated2>0.0 ) {
    BOOST_ERROR("Not-a-knot spline interpolation "
                << "bad performance unverified"
                << "\nat x = " << x1_bad
                << " interpolated value: " << interpolated
                << "\nat x = " << x2_bad
                << " interpolated value: " << interpolated
                << "\n at least one of them was expected to be < 0.0");
}

// MC not-a-knot spline
f = CubicInterpolation(x.begin(), x.end(), y.begin(),
                       CubicInterpolation::Spline, true,
                       CubicInterpolation::NotAKnot, Null<Real>(),
                       CubicInterpolation::NotAKnot, Null<Real>());
f.update();
checkValues("MC not-a-knot spline", f,
            x.begin(), x.end(), y.begin());
// good performance
interpolated = f(x1_bad);
if (interpolated<0.0) {
    BOOST_ERROR("MC not-a-knot spline interpolation "
                << "good performance unverified\n"
                << "at x = " << x1_bad
                << "\ninterpolated value: " << interpolated
                << "\nexpected value > 0.0");
}
interpolated = f(x2_bad);
if (interpolated<0.0) {
    BOOST_ERROR("MC not-a-knot spline interpolation "
                << "good performance unverified\n"
                << "at x = " << x2_bad
                << "\ninterpolated value: " << interpolated
                << "\nexpected value > 0.0");
}
}

for (i=0; i<n; i++) {
interpolated = f.secondDerivative(generic_x[i]);
error = interpolated - generic_natural_y2[i];
if (std::fabs(error)>3e-16) {
    BOOST_ERROR("Natural spline interpolation "
                << "second derivative failed at x=" << generic_x[i]
                << "\ninterpolated value: " << interpolated
                << "\nexpected value:     " << generic_natural_y2[i]
                << "\nerror:              " << error);
}
}

for (i = 0; i < 5; ++i) {
Real temp = offsets[i];
for (j = 0; j < dim[i]; temp += r, ++j)
    grid[i].push_back(temp);
}

for (i = 0; i < dim[0]; ++i)
for (j = 0; j < dim[1]; ++j)
    for (k = 0; k < dim[2]; ++k)
        for (l = 0; l < dim[3]; ++l)
            for (m = 0; m < dim[4]; ++m)
                y5[i][j][k][l][m] =
                    multif(grid[0][i], grid[1][j], grid[2][k],
                           grid[3][l], grid[4][m]);

for (i = 0; i < dim[0]; ++i)
for (j = 0; j < dim[1]; ++j)
    for (k = 0; k < dim[2]; ++k)
        for (l = 0; l < dim[3]; ++l)
            for (m = 0; m < dim[4]; ++m) {
*/
for (i = 1; i < dim[0]-1; ++i)
for (j = 1; j < dim[1]-1; ++j)
    for (k = 1; k < dim[2]-1; ++k)
        for (l = 1; l < dim[3]-1; ++l)
            for (m = 1; m < dim[4]-1; ++m) {
                s = grid[0][i];
                t = grid[1][j];
                u = grid[2][k];
                v = grid[3][l];
                w = grid[4][m];
                Real interpolated = cs(args);
                Real expected = y5[i][j][k][l][m];
                Real error = std::fabs(interpolated-expected);
                Real tolerance = 1e-16;
                if (error > tolerance) {
                    BOOST_ERROR(
                        "\n  At ("
                        << s << "," << t << "," << u << ","
                                    << v << "," << w << "):"
                        << "\n    interpolated: " << interpolated
                        << "\n    actual value: " << expected
                        << "\n       error: " << error
                        << "\n    tolerance: " << tolerance);
                }
            }


unsigned long seed = 42;
SobolRsg rsg(5, seed);

Real tolerance = 1.7e-4;
// actually tested up to 2^21-1=2097151 Sobol draws
for (i = 0; i < 1023; ++i) {
const std::vector<Real>& next = rsg.nextSequence().value;
s = grid[0].front() + next[0]*(grid[0].back()-grid[0].front());
t = grid[1].front() + next[1]*(grid[1].back()-grid[1].front());
u = grid[2].front() + next[2]*(grid[2].back()-grid[2].front());
v = grid[3].front() + next[3]*(grid[3].back()-grid[3].front());
w = grid[4].front() + next[4]*(grid[4].back()-grid[4].front());
Real interpolated = cs(args), expected = multif(s, t, u, v, w);
Real error = std::fabs(interpolated-expected);
if (error > tolerance) {
    BOOST_ERROR(
        "\n  At ("
        << s << "," << t << "," << u << "," << v << "," << w << "):"
        << "\n    interpolated: " << interpolated
        << "\n    actual value: " << expected
        << "\n    error:        " << error
        << "\n    tolerance:    " << tolerance);
}
}
}

for (Size i=0; i<N; i++) {
Real expected = 5.0-x2[i];
if (std::fabs(y2[i]-expected) > tolerance)
    BOOST_ERROR(
        "failed to reproduce " << io::ordinal(i+1) << " expected datum"
        << QL_FIXED
        << "\n    expected:   " << expected
        << "\n    calculated: " << y2[i]
        << QL_SCIENTIFIC
        << "\n    error:      " << std::fabs(y2[i]-expected));
}

for (i=0; i<N; i++) {
Real p = x[i];
Real calculated = f(p);
Real expected = y[i];
if (std::fabs(expected-calculated) > tolerance)
    BOOST_ERROR(
        "failed to reproduce " << io::ordinal(i+1) << " datum"
        << QL_FIXED
        << "\n    expected:   " << expected
        << "\n    calculated: " << calculated
        << QL_SCIENTIFIC
        << "\n    error:      " << std::fabs(calculated-expected));
}

for (i=0; i<N-1; i++) {
Real p = (x[i]+x[i+1])/2;
Real calculated = f(p);
Real expected = y[i+1];
if (std::fabs(expected-calculated) > tolerance)
    BOOST_ERROR(
        "failed to interpolate correctly at " << p
        << QL_FIXED
        << "\n    expected:   " << expected
        << "\n    calculated: " << calculated
        << QL_SCIENTIFIC
        << "\n    error:      " << std::fabs(calculated-expected));
}

for (i=1; i<N; i++) {
sum += (x[i]-x[i-1])*y[i];
Real calculated = f.primitive(x[i]);
Real expected = sum;
if (std::fabs(expected-calculated) > tolerance)
    BOOST_ERROR(
        "failed to calculate primitive at " << x[i]
        << QL_FIXED
        << "\n    expected:   " << expected
        << "\n    calculated: " << calculated
        << QL_SCIENTIFIC
        << "\n    error:      " << std::fabs(calculated-expected));
}

for (i=0; i<N-1; i++) {
Real p = (x[i]+x[i+1])/2;
sum += (x[i+1]-x[i])*y[i+1]/2;
Real calculated = f.primitive(p);
Real expected = sum;
sum += (x[i+1]-x[i])*y[i+1]/2;
if (std::fabs(expected-calculated) > tolerance)
    BOOST_ERROR(
        "failed to calculate primitive at " << x[i]
        << QL_FIXED
        << "\n    expected:   " << expected
        << "\n    calculated: " << calculated
        << QL_SCIENTIFIC
        << "\n    error:      " << std::fabs(calculated-expected));
}

for (i=0; i<N; i++) {
Real p = x[i];
Real calculated = f(p);
Real expected = y[i];
if (std::fabs(expected-calculated) > tolerance)
    BOOST_ERROR(
        "failed to reproduce " << io::ordinal(i+1) << " datum"
        << QL_FIXED
        << "\n    expected:   " << expected
        << "\n    calculated: " << calculated
        << QL_SCIENTIFIC
        << "\n    error:      " << std::fabs(calculated-expected));
}

for (i=0; i<N-1; i++) {
Real p = (x[i]+x[i+1])/2;
Real calculated = f(p);
Real expected = y[i];
if (std::fabs(expected-calculated) > tolerance)
    BOOST_ERROR(
        "failed to interpolate correctly at " << p
        << QL_FIXED
        << "\n    expected:   " << expected
        << "\n    calculated: " << calculated
        << QL_SCIENTIFIC
        << "\n    error:      " << std::fabs(calculated-expected));
}

for (i=1; i<N; i++) {
sum += (x[i]-x[i-1])*y[i-1];
Real calculated = f.primitive(x[i]);
Real expected = sum;
if (std::fabs(expected-calculated) > tolerance)
    BOOST_ERROR(
        "failed to calculate primitive at " << x[i]
        << QL_FIXED
        << "\n    expected:   " << expected
        << "\n    calculated: " << calculated
        << QL_SCIENTIFIC
        << "\n    error:      " << std::fabs(calculated-expected));
}

for (i=0; i<N-1; i++) {
Real p = (x[i]+x[i+1])/2;
sum += (x[i+1]-x[i])*y[i]/2;
Real calculated = f.primitive(p);
Real expected = sum;
sum += (x[i+1]-x[i])*y[i]/2;
if (std::fabs(expected-calculated) > tolerance)
    BOOST_ERROR(
        "failed to calculate primitive at " << p
        << QL_FIXED
        << "\n    expected:   " << expected
        << "\n    calculated: " << calculated
        << QL_SCIENTIFIC
        << "\n    error:      " << std::fabs(calculated-expected));
}

for(Size i=0; i< strikes.size(); i++){
Real calculatedVol = sabrVolatility(strikes[i], forward, expiry,
                                    initialAlpha, initialBeta,
                                    initialNu, initialRho);
if (std::fabs(volatilities[i]-calculatedVol) > tolerance)
BOOST_ERROR(
    "failed to calculate Sabr function at strike " << strikes[i]
    << "\n    expected:   " << volatilities[i]
    << "\n    calculated: " << calculatedVol
    << "\n    error:      " << std::fabs(calculatedVol-volatilities[i]));
}

for (Size j=0; j<methods_.size(); ++j) {
for (Size i=0; i<LENGTH(vegaWeighted); ++i) {
for (Size k_a=0; k_a<LENGTH(isAlphaFixed); ++k_a) {
  for (Size k_b=0; k_b<LENGTH(isBetaFixed); ++k_b) {
    for (Size k_n=0; k_n<LENGTH(isNuFixed); ++k_n) {
      for (Size k_r=0; k_r<LENGTH(isRhoFixed); ++k_r) {
          // to meet the tough calibration tolerance we need to lower the default
          // error threshold for accepting a calibration (to be more specific, some
          // of the new test cases arising from fixing a subset of the model's
          // parameters do not calibrate with the desired error using the initial
          // guess (i.e. optimization runs into a local minimum) - then a series of
          // random start values for optimization is chosen until our tight custom
          // error threshold is satisfied.
          SABRInterpolation sabrInterpolation(
              strikes.begin(), strikes.end(), volatilities.begin(),
              expiry, forward, isAlphaFixed[k_a] ? initialAlpha : alphaGuess,
              isBetaFixed[k_b] ? initialBeta : betaGuess,
              isNuFixed[k_n] ? initialNu : nuGuess,
              isRhoFixed[k_r] ? initialRho : rhoGuess, isAlphaFixed[k_a],
              isBetaFixed[k_b], isNuFixed[k_n], isRhoFixed[k_r],
              vegaWeighted[i], endCriteria, methods_[j], 1E-10);
          sabrInterpolation.update();

        // Recover SABR calibration parameters
        bool failed = false;
        Real calibratedAlpha = sabrInterpolation.alpha();
        Real calibratedBeta = sabrInterpolation.beta();
        Real calibratedNu = sabrInterpolation.nu();
        Real calibratedRho = sabrInterpolation.rho();
        Real error;

        // compare results: alpha
        error = std::fabs(initialAlpha-calibratedAlpha);
        if (error > calibrationTolerance) {
            BOOST_ERROR("\nfailed to calibrate alpha Sabr parameter:" <<
                        "\n    expected:        " << initialAlpha <<
                        "\n    calibrated:      " << calibratedAlpha <<
                        "\n    error:           " << error);
            failed = true;
        }
        // Beta
        error = std::fabs(initialBeta-calibratedBeta);
        if (error > calibrationTolerance) {
            BOOST_ERROR("\nfailed to calibrate beta Sabr parameter:" <<
                        "\n    expected:        " << initialBeta <<
                        "\n    calibrated:      " << calibratedBeta <<
                        "\n    error:           " << error);
            failed = true;
        }
        // Nu
        error = std::fabs(initialNu-calibratedNu);
        if (error > calibrationTolerance) {
            BOOST_ERROR("\nfailed to calibrate nu Sabr parameter:" <<
                        "\n    expected:        " << initialNu <<
                        "\n    calibrated:      " << calibratedNu <<
                        "\n    error:           " << error);
            failed = true;
        }
        // Rho
        error = std::fabs(initialRho-calibratedRho);
        if (error > calibrationTolerance) {
            BOOST_ERROR("\nfailed to calibrate rho Sabr parameter:" <<
                        "\n    expected:        " << initialRho <<
                        "\n    calibrated:      " << calibratedRho <<
                        "\n    error:           " << error);
            failed = true;
        }

        if (failed)
            BOOST_FAIL("\nSabr calibration failure:" <<
                       "\n    isAlphaFixed:    " << isAlphaFixed[k_a] <<
                       "\n    isBetaFixed:     " << isBetaFixed[k_b] <<
                       "\n    isNuFixed:       " << isNuFixed[k_n] <<
                       "\n    isRhoFixed:      " << isRhoFixed[k_r] <<
                       "\n    vegaWeighted[i]: " << vegaWeighted[i]);

      }
    }
  }
}
}
}

for (Size i=0; i<lambdaVec.size(); ++i) {
GaussianKernel myKernel(0,lambdaVec[i]);

for (Size j=0; j<yd.size(); ++j) {

    std::vector<Real> currY = yd[j];
    KernelInterpolation f(deltaGrid.begin(), deltaGrid.end(),
                          currY.begin(), myKernel);
    f.update();

    for (Size dIt=0; dIt< deltaGrid.size(); ++dIt) {
        expectedVal=currY[dIt];
        calcVal=f(deltaGrid[dIt]);

        if (std::fabs(expectedVal-calcVal)>tolerance) {

            BOOST_ERROR("Kernel interpolation failed at x = "
                        << deltaGrid[dIt]
                        << QL_SCIENTIFIC
                        << "\n    interpolated value: " << calcVal
                        << "\n    expected value:     " << expectedVal
                        << "\n    error:              "
                        << std::fabs(expectedVal-calcVal));
        }
    }
}
}

for (Size j=0; j< ytd.size(); ++j) {
std::vector<Real> currY=yd[j];
std::vector<Real> currTY=ytd[j];

// Build interpolation according to original grid + y-values
KernelInterpolation f(deltaGrid.begin(), deltaGrid.end(),
                      currY.begin(), myKernel);
f.update();

// test values at test Grid
for (Size dIt=0; dIt< testDeltaGrid.size(); ++dIt) {

    expectedVal=currTY[dIt];
    f.enableExtrapolation();// allow extrapolation

    calcVal=f(testDeltaGrid[dIt]);
    if (std::fabs(expectedVal-calcVal)>tolerance) {

        BOOST_ERROR("Kernel interpolation failed at x = "
                    << deltaGrid[dIt]
                    << QL_SCIENTIFIC
                    << "\n    interpolated value: " << calcVal
                    << "\n    expected value:     " << expectedVal
                    << "\n    error:              "
                    << std::fabs(expectedVal-calcVal));
    }
}
}

for(Size i=0;i<M.rows();++i){
for(Size j=0;j<M.columns();++j){

    calcVal=kernel2D(xVec[i],yVec[j]);
    expectedVal=M[i][j];

    if(std::fabs(expectedVal-calcVal)>tolerance){

        BOOST_ERROR("2D Kernel interpolation failed at x = " << xVec[i]
                    << ", y = " << yVec[j]
                    << "\n    interpolated value: " << calcVal
                    << "\n    expected value:     " << expectedVal
                    << "\n    error:              "
                    << std::fabs(expectedVal-calcVal));
    }
}
}

for(Size i=0;i<M1.rows();++i){
for(Size j=0;j<M1.columns();++j){

    calcVal=kernel2DEp(xVec1[i],yVec1[j]);
    expectedVal=M1[i][j];

    if(std::fabs(expectedVal-calcVal)>tolerance){

        BOOST_ERROR("2D Epanechnkikov Kernel interpolation failed at x = " << xVec1[i]
                    << ", y = " << yVec1[j]
                    << "\n    interpolated value: " << calcVal
                    << "\n    expected value:     " << expectedVal
                    << "\n    error:              "
                    << std::fabs(expectedVal-calcVal));
    }
}
}

for(Size i=0;i<M1.rows();++i){
for(Size j=0;j<M1.columns();++j){

    calcVal=kernel2DEp(xVec1[i],yVec1[j]);
    expectedVal=M1[i][j];

    if(std::fabs(expectedVal-calcVal)>tolerance){

        BOOST_ERROR("2D Epanechnkikov Kernel updated interpolation failed at x = " << xVec1[i]
                    << ", y = " << yVec1[j]
                    << "\n    interpolated value: " << calcVal
                    << "\n    expected value:     " << expectedVal
                    << "\n    error:              "
                    << std::fabs(expectedVal-calcVal));
    }
}
}

for (Size i=0; i < 100; ++i) {
x[i] = y[i] = i/20.0;
}

for (Size i=0; i < 100; ++i)
for (Size j=0; j < 100; ++j)
    f[i][j] = y[i]/10*std::sin(x[j])+std::cos(y[i]);

for (Size i=5; i < 95; i+=10) {
for (Size j=5; j < 95; j+=10) {
    Real f_x  = spline.derivativeX(x[j],y[i]);
    Real f_xx = spline.secondDerivativeX(x[j],y[i]);
    Real f_y  = spline.derivativeY(x[j],y[i]);
    Real f_yy = spline.secondDerivativeY(x[j],y[i]);
    Real f_xy = spline.derivativeXY(x[j],y[i]);

    if (std::fabs(f_x - y[i]/10*std::cos(x[j])) > tol) {
        BOOST_ERROR("Failed to reproduce f_x");
    }
    if (std::fabs(f_xx + y[i]/10*std::sin(x[j])) > tol) {
        BOOST_ERROR("Failed to reproduce f_xx");
    }
    if (std::fabs(f_y - (std::sin(x[j])/10-std::sin(y[i]))) > tol) {
        BOOST_ERROR("Failed to reproduce f_y");
    }
    if (std::fabs(f_yy + std::cos(y[i])) > tol) {
        BOOST_ERROR("Failed to reproduce f_yy");
    }
    if (std::fabs(f_xy - std::cos(x[j])/10) > tol) {
        BOOST_ERROR("Failed to reproduce f_xy");
    }
}
}

for (Size i=0; i < N; ++i) {
x[i] = y[i] = i*0.2;
}

for (Size i=0; i < N; ++i)
for (Size j=0; j < N; ++j)
    f[i][j] = x[j]*(x[j] + y[i]);

for (Size i = 0; i < strikes.size(); i++) {
Real calculatedVol = noarbSabr.volatility(strikes[i]);
if (std::fabs(volatilities[i]-calculatedVol) > tolerance)
BOOST_ERROR(
    "failed to calculate noarb-Sabr function at strike " << strikes[i]
    << "\n    expected:   " << volatilities[i]
    << "\n    calculated: " << calculatedVol
    << "\n    error:      " << std::fabs(calculatedVol-volatilities[i]));
}

for (Size j=1; j<methods_.size(); ++j) { // skip simplex (gets caught in some cases)
for (Size i=0; i<LENGTH(vegaWeighted); ++i) {
    for (Size k_a=0; k_a<LENGTH(isAlphaFixed); ++k_a) {
        for (Size k_b=0; k_b<1/*LENGTH(isBetaFixed)*/; ++k_b) { // keep beta fixed (all 4 params free is a problem for this kind of test)
            for (Size k_n=0; k_n<LENGTH(isNuFixed); ++k_n) {
                for (Size k_r=0; k_r<LENGTH(isRhoFixed); ++k_r) {
                    NoArbSabrInterpolation noarbSabrInterpolation(
                                                                  strikes.begin(), strikes.end(),
                                                                  volatilities.begin(), expiry, forward,
                                                                  isAlphaFixed[k_a] ? initialAlpha
                                                                  : alphaGuess,
                                                                  isBetaFixed[k_b] ? initialBeta
                                                                  : betaGuess,
                                                                  isNuFixed[k_n] ? initialNu : nuGuess,
                                                                  isRhoFixed[k_r] ? initialRho : rhoGuess,
                                                                  isAlphaFixed[k_a], isBetaFixed[k_b],
                                                                  isNuFixed[k_n], isRhoFixed[k_r],
                                                                  vegaWeighted[i], endCriteria,
                                                                  methods_[j], 1E-10);
                    noarbSabrInterpolation.update();

                    // Recover SABR calibration parameters
                    bool failed = false;
                    Real calibratedAlpha = noarbSabrInterpolation.alpha();
                    Real calibratedBeta = noarbSabrInterpolation.beta();
                    Real calibratedNu = noarbSabrInterpolation.nu();
                    Real calibratedRho = noarbSabrInterpolation.rho();
                    Real error;

                    // compare results: alpha
                    error = std::fabs(initialAlpha-calibratedAlpha);
                    if (error > calibrationTolerance) {
                        BOOST_ERROR("\nfailed to calibrate alpha Sabr parameter:" <<
                                    "\n    expected:        " << initialAlpha <<
                                    "\n    calibrated:      " << calibratedAlpha <<
                                    "\n    error:           " << error);
                        failed = true;
                    }
                    // Beta
                    error = std::fabs(initialBeta-calibratedBeta);
                    if (error > calibrationTolerance) {
                        BOOST_ERROR("\nfailed to calibrate beta Sabr parameter:" <<
                                    "\n    expected:        " << initialBeta <<
                                    "\n    calibrated:      " << calibratedBeta <<
                                    "\n    error:           " << error);
                        failed = true;
                    }
                    // Nu
                    error = std::fabs(initialNu-calibratedNu);
                    if (error > calibrationTolerance) {
                        BOOST_ERROR("\nfailed to calibrate nu Sabr parameter:" <<
                                    "\n    expected:        " << initialNu <<
                                    "\n    calibrated:      " << calibratedNu <<
                                    "\n    error:           " << error);
                        failed = true;
                    }
                    // Rho
                    error = std::fabs(initialRho-calibratedRho);
                    if (error > calibrationTolerance) {
                        BOOST_ERROR("\nfailed to calibrate rho Sabr parameter:" <<
                                    "\n    expected:        " << initialRho <<
                                    "\n    calibrated:      " << calibratedRho <<
                                    "\n    error:           " << error);
                        failed = true;
                    }

                    if (failed)
                        BOOST_TEST_MESSAGE("\nnoarb-Sabr calibration failure:" <<
                                   "\n    isAlphaFixed:    " << isAlphaFixed[k_a] <<
                                   "\n    isBetaFixed:     " << isBetaFixed[k_b] <<
                                   "\n    isNuFixed:       " << isNuFixed[k_n] <<
                                   "\n    isRhoFixed:      " << isRhoFixed[k_r] <<
                                   "\n    vegaWeighted[i]: " << vegaWeighted[i]);
                }
            }
        }
    }
}
}

for (Size i = 0; i < 1E6; ++i) {

s = h.nextSequence().value;
for (Size j = 0; j < 4; ++j)
    x[j] = 2.0 * size * s[j] - size;

// sabr
y = detail::SABRSpecs().direct(x, fixed, params, forward);
validateSabrParameters(y[0], y[1], y[2], y[3]);
z = detail::SABRSpecs().inverse(y, fixed, params, forward);
z = detail::SABRSpecs().direct(z, fixed, params, forward);
if (!close(z[0], y[0], N) || !close(z[1], y[1], N) || !close(z[2], y[2], N) ||
    !close(z[3], y[3], N))
    BOOST_ERROR("SabrInterpolation: direct(inverse("
                << y[0] << "," << y[1] << "," << y[2] << "," << y[3]
                << ")) = (" << z[0] << "," << z[1] << "," << z[2] << ","
                << z[3] << "), difference is (" << z[0] - y[0] << ","
                << z[1] - y[1] << "," << z[2] - y[2] << ","
                << z[3] - y[3] << ")");

// noarb sabr
y = detail::NoArbSabrSpecs().direct(x, fixed, params, forward);

// we can not invoke the constructor, this would be too slow, so
// we copy the parameter check here ...
Real alpha = y[0];
Real beta = y[1];
Real nu = y[2];
Real rho = y[3];
QL_REQUIRE(beta >= detail::NoArbSabrModel::beta_min &&
               beta <= detail::NoArbSabrModel::beta_max,
           "beta (" << beta << ") out of bounds");
Real sigmaI = alpha * std::pow(forward, beta - 1.0);
QL_REQUIRE(sigmaI >= detail::NoArbSabrModel::sigmaI_min &&
               sigmaI <= detail::NoArbSabrModel::sigmaI_max,
           "sigmaI = alpha*forward^(beta-1.0) ("
               << sigmaI << ") out of bounds, alpha=" << alpha
               << " beta=" << beta << " forward=" << forward);
QL_REQUIRE(nu >= detail::NoArbSabrModel::nu_min &&
               nu <= detail::NoArbSabrModel::nu_max,
           "nu (" << nu << ") out of bounds");
QL_REQUIRE(rho >= detail::NoArbSabrModel::rho_min &&
               rho <= detail::NoArbSabrModel::rho_max,
           "rho (" << rho << ") out of bounds");

z = detail::NoArbSabrSpecs().inverse(y, fixed, params, forward);
z = detail::NoArbSabrSpecs().direct(z, fixed, params, forward);
if (!close(z[0], y[0], N) || !close(z[1], y[1], N) || !close(z[2], y[2], N) ||
    !close(z[3], y[3], N))
    BOOST_ERROR("NoArbSabrInterpolation: direct(inverse("
                << y[0] << "," << y[1] << "," << y[2] << "," << y[3]
                << ")) = (" << z[0] << "," << z[1] << "," << z[2] << ","
                << z[3] << "), difference is (" << z[0] - y[0] << ","
                << z[1] - y[1] << "," << z[2] - y[2] << ","
                << z[3] - y[3] << ")");
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/hybridhestonhullwhiteprocess.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i < LENGTH(corr); ++i) {
boost::shared_ptr<PricingEngine> bsmhwEngine(
                 new AnalyticBSMHullWhiteEngine(corr[i], stochProcess,
                                                hullWhiteModel));

option.setPricingEngine(bsmhwEngine);
const Real npv = option.NPV();

const Handle<BlackVolTermStructure> compVolTS(
                                flatVol(today, expectedVol[i], dc));

boost::shared_ptr<BlackScholesMertonProcess> bsProcess(
            new BlackScholesMertonProcess(spot, qTS, rTS, compVolTS));
boost::shared_ptr<PricingEngine> bsEngine(
                               new AnalyticEuropeanEngine(bsProcess));

EuropeanOption comp(payoff, exercise);
comp.setPricingEngine(bsEngine);

Volatility impliedVol =
    comp.impliedVolatility(npv, bsProcess, 1e-10, 100);

if (std::fabs(impliedVol - expectedVol[i]) > tol) {
    BOOST_FAIL("Failed to reproduce implied volatility"
               << "\n    calculated: " << impliedVol
               << "\n    expected  : " << expectedVol[i]);
}
if (std::fabs((comp.NPV() - npv)/npv) > tol) {
    BOOST_FAIL("Failed to reproduce NPV"
               << "\n    calculated: " << npv
               << "\n    expected  : " << comp.NPV());
}
if (std::fabs(comp.delta() - option.delta()) > tol) {
    BOOST_FAIL("Failed to reproduce NPV"
               << "\n    calculated: " << npv
               << "\n    expected  : " << comp.NPV());
}
if (std::fabs((comp.gamma() - option.gamma())/npv) > tol) {
    BOOST_FAIL("Failed to reproduce NPV"
               << "\n    calculated: " << npv
               << "\n    expected  : " << comp.NPV());
}
if (std::fabs((comp.theta() - option.theta())/npv) > tol) {
    BOOST_FAIL("Failed to reproduce NPV"
               << "\n    calculated: " << npv
               << "\n    expected  : " << comp.NPV());
}
if (std::fabs((comp.vega() - option.vega())/npv) > tol) {
    BOOST_FAIL("Failed to reproduce NPV"
               << "\n    calculated: " << npv
               << "\n    expected  : " << comp.NPV());
}
}

for (Size i=0; i <= 40; ++i) {
dates.push_back(today+Period(i, Years));
// FLOATING_POINT_EXCEPTION
rates.push_back(0.01 + 0.0002*std::exp(std::sin(i/4.0)));
divRates.push_back(0.02 + 0.0001*std::exp(std::sin(i/5.0)));
times.push_back(dc.yearFraction(today, dates.back()));
}

for (Size i=0; i < LENGTH(types); ++i) {
for (Size j=0; j < LENGTH(strike); ++j) {
    for (Size l=0; l < LENGTH(maturity); ++l) {
        const Date maturityDate = today + Period(maturity[l], Years);

        boost::shared_ptr<Exercise> exercise(
                                 new EuropeanExercise(maturityDate));

        Real fwd = strike[j] * spot->value()
            *qTS->discount(maturityDate)/rTS->discount(maturityDate);

        boost::shared_ptr<StrikedTypePayoff> payoff(new
                                  PlainVanillaPayoff(types[i], fwd));

        EuropeanOption option(payoff, exercise);

        option.setPricingEngine(bsmhwEngine);
        const Real calculated = option.NPV();

        option.setPricingEngine(hestonHwEngine);
        const Real expected = option.NPV();

        if (std::fabs(calculated-expected) > calculated*tol &&
            std::fabs(calculated-expected) > tol) {
            BOOST_ERROR("Failed to reproduce npvs"
                        << "\n    calculated: " << calculated
                        << "\n    expected  : " << expected
                        << "\n    strike    : " << strike[j]
                        << "\n    maturity  : " << maturity[l]
                        << "\n    type      : "
                        << ((types[i] == Option::Put)? "Put" : "Call")
                        );
        }
    }
}
}

for (Size i=120; i < 240; ++i) {
dates.push_back(today+Period(i, Months));
rates.push_back(0.02 + 0.0002*std::exp(std::sin(i/8.0)));
times.push_back(dc.yearFraction(today, dates.back()));
}

for (Size i=0; i < nrTrails; ++i) {
sample_type path =  generator.next();

for (Size j=1; j < m; ++j) {
    const Time t = grid[j];            // zero end and option maturity
    const Time T = grid[j+optionTenor];// maturity of zero bond
                                       // of option

    Array states(3);
    Array optionStates(3);
    for (Size k=0; k < jointProcess->size(); ++k) {
        states[k]       = path.value[k][j];
        optionStates[k] = path.value[k][j+optionTenor];
    }

    const DiscountFactor zeroBond
        = 1.0/jointProcess->numeraire(t, states);
    const DiscountFactor zeroOption = zeroBond
        * std::max(0.0, hwModel->discountBond(t, T, states[2])-strike);

    zeroStat[j].add(zeroBond);
    optionStat[j].add(zeroOption);
}
}

for (Size j=1; j < m; ++j) {
const Time t = grid[j];
Real calculated = zeroStat[j].mean();
Real expected = ts->discount(t);

if (std::fabs(calculated - expected) > 0.03) {
    BOOST_ERROR("Failed to reproduce expected zero bond prices"
                << "\n   t:          " << t
                << "\n   calculated: " << calculated
                << "\n   expected:   " << expected);
}

const Time T = grid[j+optionTenor];

calculated = optionStat[j].mean();
expected = hwModel->discountBondOption(Option::Call, strike, t, T);

if (std::fabs(calculated - expected) > 0.0035) {
    BOOST_ERROR("Failed to reproduce expected zero bond option prices"
                << "\n   t:          " << t
                << "\n   T:          " << T
                << "\n   calculated: " << calculated
                << "\n   expected:   " << expected);
}
}

for (Size i=0; i <= 40; ++i) {
dates.push_back(today+Period(i, Years));
// FLOATING_POINT_EXCEPTION
rates.push_back(0.03 + 0.0003*std::exp(std::sin(i/4.0)));
divRates.push_back(0.02 + 0.0001*std::exp(std::sin(i/5.0)));
times.push_back(dc.yearFraction(today, dates.back()));
}

for (Size i=0; i < LENGTH(corr); ++i) {
for (Size j=0; j < LENGTH(strike); ++j) {
    boost::shared_ptr<HybridHestonHullWhiteProcess> jointProcess(
        new HybridHestonHullWhiteProcess(hestonProcess,
                                         hwProcess, corr[i]));

    boost::shared_ptr<StrikedTypePayoff> payoff(
                       new PlainVanillaPayoff(Option::Put, strike[j]));
    boost::shared_ptr<Exercise> exercise(
                       new EuropeanExercise(maturity));

    VanillaOption optionHestonHW(payoff, exercise);
    boost::shared_ptr<PricingEngine> engine =
        MakeMCHestonHullWhiteEngine<PseudoRandom>(jointProcess)
        .withSteps(1)
        .withAntitheticVariate()
        .withControlVariate()
        .withAbsoluteTolerance(tol)
        .withSeed(42);

    optionHestonHW.setPricingEngine(engine);

    const boost::shared_ptr<HullWhite> hwModel(
                new HullWhite(Handle<YieldTermStructure>(rTS),
                              hwProcess->a(), hwProcess->sigma()));

    VanillaOption optionBsmHW(payoff, exercise);
    optionBsmHW.setPricingEngine(
        boost::shared_ptr<PricingEngine>(
                   new AnalyticBSMHullWhiteEngine(corr[i], bsmProcess,
                                                  hwModel)));

    const Real calculated = optionHestonHW.NPV();
    const Real error      = optionHestonHW.errorEstimate();
    const Real expected   = optionBsmHW.NPV();

    if (  (corr[i] != 0.0 && std::fabs(calculated - expected) > 3*error)
        ||(corr[i] == 0.0 &&  std::fabs(calculated - expected)> 1e-4)) {
        BOOST_ERROR("Failed to reproduce BSM-HW vanilla prices"
                << "\n   corr:       " << corr[i]
                << "\n   strike:     " << strike[j]
                << "\n   calculated: " << calculated
                << "\n   error:      " << error
                << "\n   expected:   " << expected);
    }
}
}

for (Size i=0; i <= 100; ++i) {
dates.push_back(today+Period(i, Months));
// FLOATING_POINT_EXCEPTION
rates.push_back(0.02 + 0.0002*std::exp(std::sin(i/10.0)));
divRates.push_back(0.02 + 0.0001*std::exp(std::sin(i/20.0)));
times.push_back(dc.yearFraction(today, dates.back()));
}

for (Size i=0; i < LENGTH(corr); ++i) {
for (Size j=0; j < LENGTH(strike); ++j) {
    boost::shared_ptr<HybridHestonHullWhiteProcess> jointProcess(
        new HybridHestonHullWhiteProcess(
                hestonProcess, hwProcess,
                corr[i], HybridHestonHullWhiteProcess::Euler));

    boost::shared_ptr<StrikedTypePayoff> payoff(
                       new PlainVanillaPayoff(Option::Put, strike[j]));
    boost::shared_ptr<Exercise> exercise(
                       new EuropeanExercise(maturity));

    VanillaOption optionHestonHW(payoff, exercise);
    VanillaOption optionPureHeston(payoff, exercise);
    optionPureHeston.setPricingEngine(
        boost::shared_ptr<PricingEngine>(
            new AnalyticHestonEngine(
                  boost::shared_ptr<HestonModel>(
                                   new HestonModel(hestonProcess)))));

    Real expected   = optionPureHeston.NPV();

    optionHestonHW.setPricingEngine(
        MakeMCHestonHullWhiteEngine<PseudoRandom>(jointProcess)
        .withSteps(2)
        .withAntitheticVariate()
        .withControlVariate()
        .withAbsoluteTolerance(tol)
        .withSeed(42));

    Real calculated = optionHestonHW.NPV();
    Real error      = optionHestonHW.errorEstimate();

    if (   std::fabs(calculated - expected) > 3*error
        && std::fabs(calculated - expected) > tol) {
        BOOST_ERROR("Failed to reproduce pure heston vanilla prices"
                << "\n   corr:       " << corr[i]
                << "\n   strike:     " << strike[j]
                << "\n   calculated: " << calculated
                << "\n   error:      " << error
                << "\n   expected:   " << expected);
    }
}
}

for (Size i=0; i <= 40; ++i) {
dates.push_back(today+Period(i, Years));
// FLOATING_POINT_EXCEPTION
rates.push_back(0.03 + 0.0001*std::exp(std::sin(i/4.0)));
divRates.push_back(0.02 + 0.0002*std::exp(std::sin(i/3.0)));
times.push_back(dc.yearFraction(today, dates.back()));
}

for (Size i=0; i < LENGTH(types); ++i) {
for (Size j=0; j < LENGTH(strike); ++j) {
    boost::shared_ptr<HybridHestonHullWhiteProcess> jointProcess(
        new HybridHestonHullWhiteProcess(
                hestonProcess, hwFwdProcess, 0.0,
                HybridHestonHullWhiteProcess::Euler));

    boost::shared_ptr<StrikedTypePayoff> payoff(
                       new PlainVanillaPayoff(types[i], strike[j]));
    boost::shared_ptr<Exercise> exercise(
                       new EuropeanExercise(maturity));

    VanillaOption optionHestonHW(payoff, exercise);
    optionHestonHW.setPricingEngine(
            MakeMCHestonHullWhiteEngine<PseudoRandom>(jointProcess)
            .withSteps(1)
            .withAntitheticVariate()
            .withControlVariate()
            .withAbsoluteTolerance(tol)
            .withSeed(42));

    VanillaOption optionPureHeston(payoff, exercise);
    optionPureHeston.setPricingEngine(
        boost::shared_ptr<PricingEngine>(
            new AnalyticHestonHullWhiteEngine(hestonModel,
                                              hullWhiteModel, 128)));

    Real calculated = optionHestonHW.NPV();
    Real error      = optionHestonHW.errorEstimate();
    Real expected   = optionPureHeston.NPV();

    if (   std::fabs(calculated - expected) > 3*error
        && std::fabs(calculated - expected) > tol) {
        BOOST_ERROR("Failed to reproduce hw heston vanilla prices"
                << "\n   strike:     " << strike[j]
                << "\n   calculated: " << calculated
                << "\n   error:      " << error
                << "\n   expected:   " << expected);
    }
}
}

for (Size i=0; i<=maturity; ++i)
times[i] = static_cast<Time>(i);

for (Size i=0; i < maturity; ++i) {
redemption[i] = 1.07 + 0.03*i;
}

for (Size i=0; i < nrTrails; ++i) {
const bool antithetic = (i%2)==0 ? false : true;

sample_type path = antithetic ? generator.antithetic()
                              : generator.next();

Real payoff=0;
for (Size j=1; j <= maturity; ++j) {
    if (path.value[0][j] > spot->value()) {
        Array states(3);
        for (Size k=0; k < 3; ++k) {
            states[k] = path.value[k][j];
        }
        payoff = redemption[j-1]
            / jointProcess->numeraire(grid[j], states);
        break;
    }
    else if (j == maturity) {
        Array states(3);
        for (Size k=0; k < 3; ++k) {
            states[k] = path.value[k][j];
        }
        payoff = 1.0 / jointProcess->numeraire(grid[j], states);
    }
}

if (antithetic){
    stat.add(0.5*(antitheticPayoff + payoff));
}
else {
    antitheticPayoff = payoff;
}
}

for (Size i=0; i <= 31; ++i) {
dates.push_back(today+Period(i, Years));
// FLOATING_POINT_EXCEPTION
rates.push_back(0.04 + 0.0001*std::exp(std::sin(double(i))));
divRates.push_back(0.04 + 0.0001*std::exp(std::sin(double(i))));
times.push_back(dc.yearFraction(today, dates.back()));
}

for (Size i=0; i < LENGTH(corr); ++i) {
for (Size j=0; j < LENGTH(strike); ++j) {
    boost::shared_ptr<StrikedTypePayoff> payoff(
                       new PlainVanillaPayoff(Option::Put, strike[j]));
    boost::shared_ptr<Exercise> exercise(
                       new EuropeanExercise(maturity));

    VanillaOption optionBsmHW(payoff, exercise);
    const boost::shared_ptr<HullWhite> hwModel(new HullWhite(
                       rTS, hwProcess->a(), hwProcess->sigma()));
    optionBsmHW.setPricingEngine(
        boost::shared_ptr<PricingEngine>(
                 new AnalyticBSMHullWhiteEngine(corr[i], bsmProcess,
                                                hwModel)));

    Real expected = optionBsmHW.NPV();

    VanillaOption optionHestonHW(payoff, exercise);
    boost::shared_ptr<HybridHestonHullWhiteProcess> jointProcess(
        new HybridHestonHullWhiteProcess(hestonProcess,
                                         hwProcess, corr[i]));
    optionHestonHW.setPricingEngine(
            MakeMCHestonHullWhiteEngine<PseudoRandom>(jointProcess)
            .withSteps(1)
            .withAntitheticVariate()
            .withAbsoluteTolerance(tol)
            .withSeed(42));

    Real calculated = optionHestonHW.NPV();
    Real error      = optionHestonHW.errorEstimate();

    if ((   std::fabs(calculated - expected) > 3*error
         && std::fabs(calculated - expected) > 1e-5)) {
        BOOST_ERROR("Failed to reproduce discretization error"
                << "\n   corr:       " << corr[i]
                << "\n   strike:     " << strike[j]
                << "\n   calculated: " << calculated
                << "\n   error:      " << error
                << "\n   expected:   " << expected);
    }
}
}

for (Size i=0; i < LENGTH(corr); ++i) {
for (Size j=0; j < LENGTH(strike); ++j) {
    boost::shared_ptr<StrikedTypePayoff> payoff(
                      new PlainVanillaPayoff(Option::Call, strike[j]));
    VanillaOption option(payoff, exercise);
    
    option.setPricingEngine(boost::shared_ptr<PricingEngine>(
        new FdHestonHullWhiteVanillaEngine(
            boost::shared_ptr<HestonModel>(
                new HestonModel(hestonProcess)),
                                hwProcess, corr[i], 50, 200, 10, 15)));
    const Real calculated = option.NPV();
    const Real calculatedDelta = option.delta();
    const Real calculatedGamma = option.gamma();
    
    option.setPricingEngine(boost::shared_ptr<PricingEngine>(
        new AnalyticBSMHullWhiteEngine(corr[i],
                                       stochProcess, hwModel)));
    const Real expected = option.NPV();
    const Real expectedDelta = option.delta();
    const Real expectedGamma = option.gamma();

    const Real npvTol = 0.01;
    if (std::fabs(calculated - expected) > npvTol) {
         BOOST_ERROR("Failed to reproduce analytic npv values"
                 << "\n   corr:       " << corr[i]
                 << "\n   strike:     " << strike[j]
                 << "\n   calculated: " << calculated
                 << "\n   expected:   " << expected);
    }
    const Real deltaTol = 0.001;
    if (std::fabs(calculatedDelta - expectedDelta) > deltaTol) {
         BOOST_ERROR("Failed to reproduce analytic delta values"
                 << "\n   corr:       " << corr[i]
                 << "\n   strike:     " << strike[j]
                 << "\n   calculated: " << calculated
                 << "\n   expected:   " << expected);
    }
    const Real gammaTol = 0.001;
    if (std::fabs(calculatedGamma - expectedGamma) > gammaTol) {
         BOOST_ERROR("Failed to reproduce analytic gamma values"
                 << "\n   corr:       " << corr[i]
                 << "\n   strike:     " << strike[j]
                 << "\n   calculated: " << calculated
                 << "\n   expected:   " << expected);
    }
}
}

for (Size l=0; l < LENGTH(schemes); ++l) {
SchemeData scheme = schemes[l];
for (Size i=0; i < LENGTH(controlVariate); ++i) {
    for (Size u=0; u < LENGTH(listOfTimeStepsPerYear); ++u) {
        Size tSteps = Size(maturity*listOfTimeStepsPerYear[u]);

        boost::shared_ptr<FdHestonHullWhiteVanillaEngine> fdEngine(
            new FdHestonHullWhiteVanillaEngine(
                            hestonModel, hwProcess, equityIrCorr,  
                            tSteps, 400, 2, 10, 0, controlVariate[i],
                            scheme.schemeDesc));
        fdEngine->enableMultipleStrikesCaching(
            std::vector<Real>(strikes, strikes + LENGTH(strikes)));

        Real avgPriceDiff = 0.0;
        for (Size k=0; k < LENGTH(strikes); ++k) {
            VanillaOptionData optionData 
                          = { strikes[k], maturity, Option::Call }; 
            boost::shared_ptr<VanillaOption> option 
                                = makeVanillaOption(optionData);
            option->setPricingEngine(bsmhwEngine);
            Real expected = option->NPV();

            option->setPricingEngine(fdEngine);
            Real calculated = option->NPV();
            avgPriceDiff
                +=std::fabs(expected-calculated)/LENGTH(strikes);
        }
        
        if (controlVariate[i] && tolWithCV[l] < avgPriceDiff) {
             BOOST_ERROR("Failed to reproduce BSM-Hull-White prices"
                     << "\n   scheme       : " << scheme.name
                     << "\n   model        : " << hestonModelData.name
                     << "\n   CV           : on");                     
        }
        
        
        if (!controlVariate[i] && tolWithOutCV[l] < avgPriceDiff) {
            BOOST_ERROR("Failed to reproduce BSM-Hull-White prices"
                    << "\n   scheme       : " << scheme.name
                    << "\n   model        : " << hestonModelData.name
                    << "\n   CV           : off");                     
        }
    }
}    
}

for (Size u=0; u < LENGTH(listOfTimeStepsPerYear); ++u) {
for (Size i=0; i < LENGTH(schemes); ++i) {
    for (Size j=0; j < LENGTH(hestonModels); ++j) {
        Real avgPriceDiff = 0;
        boost::shared_ptr<HestonProcess> hestonProcess(
                                makeHestonProcess(hestonModels[j]));
        boost::shared_ptr<HestonModel> hestonModel(
                                new HestonModel(hestonProcess));

        boost::shared_ptr<PricingEngine> analyticEngine(
                       new AnalyticHestonEngine(hestonModel, 172));

        Size tSteps = Size(maturity*listOfTimeStepsPerYear[u]);

        boost::shared_ptr<FdHestonVanillaEngine> fdEngine(
            new FdHestonVanillaEngine(
                hestonModel, tSteps, 200, 40, 0,
                schemes[i].schemeDesc));
        fdEngine->enableMultipleStrikesCaching(
            std::vector<Real>(strikes, strikes + LENGTH(strikes)));

        for (Size k=0; k < LENGTH(strikes); ++k) {
            VanillaOptionData optionData 
                          = { strikes[k], maturity, Option::Call }; 
            boost::shared_ptr<VanillaOption> option 
                                = makeVanillaOption(optionData);
            option->setPricingEngine(analyticEngine);
            Real expected = option->NPV();

            option->setPricingEngine(fdEngine);
            Real calculated = option->NPV();

            avgPriceDiff
                +=std::fabs(expected-calculated)/LENGTH(strikes);
        }

        if (avgPriceDiff > tol[i]) {
            BOOST_ERROR("\nFailed to reproduce Heston prices" <<
                "\n scheme    : " << schemes[i].name <<
                "\n model     : " << hestonModels[j].name <<
                "\n error     : " << avgPriceDiff <<
                "\n tolerance : " << tol[i]);
        }
    }
}
}

for (Size i=0; i < LENGTH(maturities); ++i) {
const Period maturity((int)(maturities[i]*12.0+0.5), Months);
boost::shared_ptr<Exercise> exercise(
                                new EuropeanExercise(today + maturity));

for (Size j=0; j < LENGTH(strikes); ++j) {
    boost::shared_ptr<StrikedTypePayoff> payoff(
                     new PlainVanillaPayoff(Option::Call, strikes[j]));
    RelinkableHandle<Quote> v(boost::shared_ptr<Quote>(
                           new SimpleQuote(vol[i*LENGTH(strikes)+j])));
    options.push_back(boost::shared_ptr<CalibrationHelper>(
        new HestonModelHelper(maturity, calendar,s0->value(), 
                              strikes[j], v, rTS, qTS,
                              CalibrationHelper::PriceError)));
    const Real marketValue = options.back()->marketValue();
    
    // Improve the quality of the starting point 
    // for the full Heston-Hull-White calibration 
    boost::shared_ptr<SimpleQuote> volQuote(new SimpleQuote);
    boost::shared_ptr<GeneralizedBlackScholesProcess> bsProcess =
        detail::ImpliedVolatilityHelper::clone(
            boost::shared_ptr<GeneralizedBlackScholesProcess>(
                new GeneralizedBlackScholesProcess(
                    s0, qTS, rTS, Handle<BlackVolTermStructure>(
                                            flatVol(v->value(), dc)))),
                volQuote);

    VanillaOption dummyOption(payoff, exercise);

    boost::shared_ptr<PricingEngine> bshwEngine(
        new AnalyticBSMHullWhiteEngine(equityShortRateCorr,
                                       bsProcess, hullWhiteModel));

    Volatility vt = detail::ImpliedVolatilityHelper::calculate(
        dummyOption, *bshwEngine, *volQuote,
        marketValue, 1e-8, 100, 0.0001, 10);

    v.linkTo(boost::shared_ptr<Quote>(new SimpleQuote(vt)));
    
    options.back()->setPricingEngine(
        boost::shared_ptr<PricingEngine>(analyticHestonEngine));
}
}    

for (Size i=0; i < LENGTH(maturities); ++i) {
const Size tGrid = static_cast<Size>(std::max(10.0, maturities[i]*10.0));
boost::shared_ptr<FdHestonHullWhiteVanillaEngine> engine(
    new FdHestonHullWhiteVanillaEngine(fdmHestonModel, hwProcess, 
                                       equityShortRateCorr, 
                                       tGrid, 61, 13, 9, 0, true));

engine->enableMultipleStrikesCaching(
             std::vector<Real>(strikes, strikes + LENGTH(strikes)));

const Period maturity((int)(maturities[i]*12.0+0.5), Months);

for (Size j=0; j < LENGTH(strikes); ++j) {
    // multiple strikes engine works best if the first option
    // per maturity has the average strike (because the first option
    // is priced first during the calibration and the first pricing
    // is used to calculate the prices for all strikes
    const Size js = (j + (LENGTH(strikes)-1)/2) % LENGTH(strikes);

    boost::shared_ptr<StrikedTypePayoff> payoff(
                     new PlainVanillaPayoff(Option::Call, strikes[js]));
    Handle<Quote> v(boost::shared_ptr<Quote>(
                           new SimpleQuote(vol[i*LENGTH(strikes)+js])));
    options.push_back(boost::shared_ptr<CalibrationHelper>(
        new HestonModelHelper(maturity, calendar, s0->value(), 
                              strikes[js], v, rTS, qTS,
                              CalibrationHelper::PriceError)));
    
    options.back()->setPricingEngine(engine);
}
}    

for (Size j=0; j < LENGTH(sigma_v); ++j) {
const boost::shared_ptr<HestonProcess> hestonProcess(
    new HestonProcess(rTS, qTS, s0, v0, kappa_v, theta,
                      sigma_v[j], rho_sv));
const boost::shared_ptr<HestonModel> hestonModel(
    new HestonModel(hestonProcess));

for (Size i=0; i < LENGTH(strikes); ++i) {
    const boost::shared_ptr<StrikedTypePayoff> payoff(
        new PlainVanillaPayoff(Option::Call, strikes[i]));

    VanillaOption option(payoff, exercise);

    const boost::shared_ptr<PricingEngine> analyticH1HWEngine(
        new AnalyticH1HWEngine(hestonModel, hullWhiteModel,
                               rho_sr, 144));
    option.setPricingEngine(analyticH1HWEngine);
    const Real impliedH1HW
        = option.impliedVolatility(option.NPV(), bsProcess);

    if (std::fabs(expected[j][i] - impliedH1HW) > tol) {
        BOOST_ERROR("Failed to reproduce H1HW implied volatility"
                << "\n   expected       : " << expected[j][i]
                << "\n   calculated     : " << impliedH1HW
                << "\n   tol            : " << tol
                << "\n   strike         : " << strikes[i]
                << "\n   sigma          : " << sigma_v[j]);
    }
}
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/margrabeoption.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i<LENGTH(values); i++) {

Date exDate = today + Integer(values[i].t*360+0.5);
boost::shared_ptr<Exercise> exercise(new EuropeanExercise(exDate));

spot1 ->setValue(values[i].s1);
spot2 ->setValue(values[i].s2);
qRate1->setValue(values[i].q1);
qRate2->setValue(values[i].q2);
rRate ->setValue(values[i].r );
vol1  ->setValue(values[i].v1);
vol2  ->setValue(values[i].v2);

boost::shared_ptr<BlackScholesMertonProcess> stochProcess1(new
    BlackScholesMertonProcess(Handle<Quote>(spot1),
                              Handle<YieldTermStructure>(qTS1),
                              Handle<YieldTermStructure>(rTS),
                              Handle<BlackVolTermStructure>(volTS1)));

boost::shared_ptr<BlackScholesMertonProcess> stochProcess2(new
    BlackScholesMertonProcess(Handle<Quote>(spot2),
                              Handle<YieldTermStructure>(qTS2),
                              Handle<YieldTermStructure>(rTS),
                              Handle<BlackVolTermStructure>(volTS2)));

std::vector<boost::shared_ptr<StochasticProcess1D> > procs;
procs.push_back(stochProcess1);
procs.push_back(stochProcess2);

Matrix correlationMatrix(2,2, values[i].rho);
for (Integer j=0; j < 2; j++) {
    correlationMatrix[j][j] = 1.0;
}

boost::shared_ptr<PricingEngine> engine(
                     new AnalyticEuropeanMargrabeEngine(stochProcess1,
                                                        stochProcess2,
                                                        values[i].rho));

MargrabeOption margrabeOption(values[i].Q1, values[i].Q2, exercise);

// analytic engine
margrabeOption.setPricingEngine(engine);

Real calculated = margrabeOption.NPV();
Real expected = values[i].result;
Real error = std::fabs(calculated-expected);
Real tolerance = values[i].tol;
if (error > tolerance) {
    REPORT_FAILURE("value", exercise,
                     values[i].s1, values[i].s2, values[i].Q1,
                     values[i].Q2, values[i].q1, values[i].q2,
                     values[i].r, today, values[i].v1,
                     values[i].v2, values[i].rho, expected,
                     calculated, error, tolerance);
}

calculated = margrabeOption.delta1();
expected = values[i].delta1;
error= std::fabs(calculated-expected);
if (error>tolerance) {
    REPORT_FAILURE("delta1", exercise,
                     values[i].s1, values[i].s2, values[i].Q1,
                     values[i].Q2, values[i].q1, values[i].q2,
                     values[i].r, today, values[i].v1,
                     values[i].v2, values[i].rho, expected,
                     calculated, error, tolerance);
}

calculated = margrabeOption.delta2();
expected = values[i].delta2;
error= std::fabs(calculated-expected);
if (error>tolerance) {
    REPORT_FAILURE("delta2", exercise,
                     values[i].s1, values[i].s2, values[i].Q1,
                     values[i].Q2, values[i].q1, values[i].q2,
                     values[i].r, today, values[i].v1,
                     values[i].v2, values[i].rho, expected,
                     calculated, error, tolerance);
}

calculated = margrabeOption.gamma1();
expected = values[i].gamma1;
error= std::fabs(calculated-expected);
if (error>tolerance) {
    REPORT_FAILURE("gamma1", exercise,
                     values[i].s1, values[i].s2, values[i].Q1,
                     values[i].Q2, values[i].q1, values[i].q2,
                     values[i].r, today, values[i].v1,
                     values[i].v2, values[i].rho, expected,
                     calculated, error, tolerance);
}

calculated = margrabeOption.gamma2();
expected = values[i].gamma2;
error= std::fabs(calculated-expected);
if (error>tolerance) {
    REPORT_FAILURE("gamma2", exercise,
                     values[i].s1, values[i].s2, values[i].Q1,
                     values[i].Q2, values[i].q1, values[i].q2,
                     values[i].r, today, values[i].v1,
                     values[i].v2, values[i].rho, expected,
                     calculated, error, tolerance);
}

calculated = margrabeOption.theta();
expected = values[i].theta;
error= std::fabs(calculated-expected);
if (error>tolerance) {
    REPORT_FAILURE("theta", exercise,
                     values[i].s1, values[i].s2, values[i].Q1,
                     values[i].Q2, values[i].q1, values[i].q2,
                     values[i].r, today, values[i].v1,
                     values[i].v2, values[i].rho, expected,
                     calculated, error, tolerance);
}

calculated = margrabeOption.rho();
expected = values[i].rho_greek;
error= std::fabs(calculated-expected);
if (error>tolerance) {
    REPORT_FAILURE("rho_greek", exercise,
                     values[i].s1, values[i].s2, values[i].Q1,
                     values[i].Q2, values[i].q1, values[i].q2,
                     values[i].r, today, values[i].v1,
                     values[i].v2, values[i].rho, expected,
                     calculated, error, tolerance);
}
}

for (Size k=0; k<LENGTH(residualTimes); k++) {
  Date exDate = today + timeToDays(residualTimes[k]);
  boost::shared_ptr<Exercise> exercise(new EuropeanExercise(exDate));

  // option to check
  boost::shared_ptr<BlackScholesMertonProcess> stochProcess1(new
      BlackScholesMertonProcess(Handle<Quote>(spot1),
                              Handle<YieldTermStructure>(qTS1),
                              Handle<YieldTermStructure>(rTS),
                              Handle<BlackVolTermStructure>(volTS1)));

  boost::shared_ptr<BlackScholesMertonProcess> stochProcess2(new
      BlackScholesMertonProcess(Handle<Quote>(spot2),
                              Handle<YieldTermStructure>(qTS2),
                              Handle<YieldTermStructure>(rTS),
                              Handle<BlackVolTermStructure>(volTS2)));

  std::vector<boost::shared_ptr<StochasticProcess1D> > procs;
  procs.push_back(stochProcess1);
  procs.push_back(stochProcess2);

  //The correlation -0.5 can be different real between -1 and 1 for more tests
  Real correlation = -0.5;
  Matrix correlationMatrix(2,2, correlation);
  for (Integer j=0; j < 2; j++) {
      correlationMatrix[j][j] = 1.0;

  boost::shared_ptr<PricingEngine> engine(
                     new AnalyticEuropeanMargrabeEngine(stochProcess1,
                                                        stochProcess2,
                                                        correlation));

  //The quantities of S1 and S2 can be different from 1 & 1 for more tests
  MargrabeOption margrabeOption(1, 1, exercise);

  // analytic engine
  margrabeOption.setPricingEngine(engine);

      for (Size l=0; l<LENGTH(underlyings1); l++) {
        for (Size m=0; m<LENGTH(qRates1); m++) {
          for (Size n=0; n<LENGTH(rRates); n++) {
            for (Size p=0; p<LENGTH(vols1); p++) {
              Real u1 = underlyings1[l],
                   u2 = underlyings2[l],
                   u;
              Rate q1 = qRates1[m],
                   q2 = qRates2[m],
                   r = rRates[n];
              Volatility v1 = vols1[p],
                         v2 = vols2[p];

              spot1 ->setValue(u1);
              spot2 ->setValue(u2);
              qRate1->setValue(q1);
              qRate2->setValue(q2);
              rRate ->setValue(r);
              vol1  ->setValue(v1);
              vol2  ->setValue(v2);

              Real value = margrabeOption.NPV();

              calculated["delta1"]  = margrabeOption.delta1();
              calculated["delta2"]  = margrabeOption.delta2();
              calculated["gamma1"]  = margrabeOption.gamma1();
              calculated["gamma2"]  = margrabeOption.gamma2();
              calculated["theta"]   = margrabeOption.theta();
              calculated["rho"]     = margrabeOption.rho();

              if (value > spot1->value()*1.0e-5) {
                  // perturb spot and get delta1 and gamma
                  u = u1;
                  Real du = u*1.0e-4;
                  spot1->setValue(u+du);
                  Real value_p = margrabeOption.NPV(),
                       delta_p = margrabeOption.delta1();
                  spot1->setValue(u-du);
                  Real value_m = margrabeOption.NPV(),
                       delta_m = margrabeOption.delta1();
                  spot1->setValue(u);
                  expected["delta1"] = (value_p - value_m)/(2*du);
                  expected["gamma1"] = (delta_p - delta_m)/(2*du);

                  u = u2;
                  spot2->setValue(u+du);
                       value_p = margrabeOption.NPV();
                       delta_p = margrabeOption.delta2();
                  spot2->setValue(u-du);
                       value_m = margrabeOption.NPV();
                       delta_m = margrabeOption.delta2();
                  spot2->setValue(u);
                  expected["delta2"] = (value_p - value_m)/(2*du);
                  expected["gamma2"] = (delta_p - delta_m)/(2*du);

                  // perturb rates and get rho
                  Spread dr = r*1.0e-4;
                  rRate->setValue(r+dr);
                       value_p = margrabeOption.NPV();
                  rRate->setValue(r-dr);
                       value_m = margrabeOption.NPV();
                  rRate->setValue(r);
                  expected["rho"] = (value_p - value_m)/(2*dr);

                  // perturb date and get theta
                  Time dT = dc.yearFraction(today-1, today+1);
                  Settings::instance().evaluationDate() = today-1;
                       value_m = margrabeOption.NPV();
                  Settings::instance().evaluationDate() = today+1;
                       value_p = margrabeOption.NPV();
                  Settings::instance().evaluationDate() = today;
                  expected["theta"] = (value_p - value_m)/dT;

                  // compare
                  std::map<std::string,Real>::iterator it;
                  for (it = calculated.begin();
                       it != calculated.end(); ++it) {
                      std::string greek = it->first;
                      Real expct = expected  [greek],
                           calcl = calculated[greek],
                           tol   = tolerance [greek];
                      Real error = relativeError(expct,calcl,u1);
                      if (error>tol) {
                          REPORT_FAILURE2(greek, exercise,
                                         u1, u2, q1, q2, r, today, v1, v2,
                                         expct, calcl, error, tol);
                      }
                  }
              }
            }
          }
        }
      }
  }
}

for (Size i=0; i<LENGTH(values); i++) {

Date exDate = today + Integer(values[i].t*360+0.5);
boost::shared_ptr<Exercise> exercise(new AmericanExercise(today, exDate));

spot1 ->setValue(values[i].s1);
spot2 ->setValue(values[i].s2);
qRate1->setValue(values[i].q1);
qRate2->setValue(values[i].q2);
rRate ->setValue(values[i].r );
vol1  ->setValue(values[i].v1);
vol2  ->setValue(values[i].v2);

boost::shared_ptr<BlackScholesMertonProcess> stochProcess1(new
    BlackScholesMertonProcess(Handle<Quote>(spot1),
                              Handle<YieldTermStructure>(qTS1),
                              Handle<YieldTermStructure>(rTS),
                              Handle<BlackVolTermStructure>(volTS1)));

boost::shared_ptr<BlackScholesMertonProcess> stochProcess2(new
    BlackScholesMertonProcess(Handle<Quote>(spot2),
                              Handle<YieldTermStructure>(qTS2),
                              Handle<YieldTermStructure>(rTS),
                              Handle<BlackVolTermStructure>(volTS2)));

std::vector<boost::shared_ptr<StochasticProcess1D> > procs;
procs.push_back(stochProcess1);
procs.push_back(stochProcess2);

Matrix correlationMatrix(2,2, values[i].rho);
for (Integer j=0; j < 2; j++) {
    correlationMatrix[j][j] = 1.0;
}

boost::shared_ptr<PricingEngine> engine(
                     new AnalyticAmericanMargrabeEngine(stochProcess1,
                                                        stochProcess2,
                                                        values[i].rho));

MargrabeOption margrabeOption(values[i].Q1, values[i].Q2, exercise);

// analytic engine
margrabeOption.setPricingEngine(engine);

Real calculated = margrabeOption.NPV();
Real expected = values[i].result;
Real error = std::fabs(calculated-expected);
Real tolerance = values[i].tol;
if (error > tolerance) {
    REPORT_FAILURE("value", exercise,
                     values[i].s1, values[i].s2, values[i].Q1,
                     values[i].Q2, values[i].q1, values[i].q2,
                     values[i].r, today, values[i].v1,
                     values[i].v2, values[i].rho, expected,
                     calculated, error, tolerance);
}
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/numericaldifferentiation.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Real x=0.0; x < 5.0; x+=0.1) {
const Real calculatedCentral = df_central(x);
const Real calculatedBackward = df_backward(x);
const Real calculatedForward = df_forward(x);
const Real expected = std::cos(x);

singleValueTest("central first", calculatedCentral, expected, 1e-8);
singleValueTest("backward first", calculatedBackward, expected, 1e-6);
singleValueTest("forward first", calculatedForward, expected, 1e-6);
}

for (Real x=0.0; x < 5.0; x+=0.1) {
const Real calculatedCentral = df4_central(x);
const Real calculatedBackward = df4_backward(x);
const Real calculatedForward = df4_forward(x);
const Real expected = std::sin(x);

singleValueTest("central 4th", calculatedCentral, expected, 1e-4);
singleValueTest("backward 4th", calculatedBackward, expected, 1e-4);
singleValueTest("forward 4th", calculatedForward, expected, 1e-4);
}

for (Real x=0.0; x < 5.0; x+=0.1) {
const Real calculatedIrregular = df3_irregular(x);
const Real expected = -std::cos(x);

singleValueTest("irregular 3th", calculatedIrregular, expected, 5e-5);
}

for (Size i=1; i < n; ++i) {
    const Real fact = Factorial::get(i);
    for (Size j=0; j < n; ++j)
        m[i][j] = std::pow(q[j], Integer(i)) / fact;
}

for (Natural order=0; order < 5; ++order) {
for (Natural nGridPoints = order + 1;
    nGridPoints < order + 3; ++nGridPoints) {

    Array gridPoints(nGridPoints);
    for (Natural i=0; i < nGridPoints; ++i) {
        const Real p = Real(i);
        gridPoints[i] = std::sin(p) + std::cos(p); // strange points
    }

    const Real x = 0.3902842; // strange points
    const Array weightsVandermonde
        = vandermondeCoefficients(order, x, gridPoints);
    const NumericalDifferentiation nd(f, order, gridPoints-x);

    checkTwoArraysAreTheSame(gridPoints, nd.offsets() + x);
    checkTwoArraysAreTheSame(weightsVandermonde, nd.weights());
}
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/binaryoption.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i<LENGTH(values); i++) {

boost::shared_ptr<StrikedTypePayoff> payoff(new CashOrNothingPayoff(
    values[i].type, values[i].strike, values[i].cash));

Date exDate = today + Integer(values[i].t*360+0.5);
boost::shared_ptr<Exercise> amExercise(new AmericanExercise(today,
                                                            exDate,
                                                            true));

spot ->setValue(values[i].s);
qRate->setValue(values[i].q);
rRate->setValue(values[i].r);
vol  ->setValue(values[i].v);

boost::shared_ptr<BlackScholesMertonProcess> stochProcess(new
    BlackScholesMertonProcess(Handle<Quote>(spot),
                              Handle<YieldTermStructure>(qTS),
                              Handle<YieldTermStructure>(rTS),
                              Handle<BlackVolTermStructure>(volTS)));
boost::shared_ptr<PricingEngine> engine(
                     new AnalyticBinaryBarrierEngine(stochProcess));

BarrierOption opt(values[i].barrierType, 
                  values[i].barrier, 
                  0,
                  payoff,
                  amExercise);

opt.setPricingEngine(engine);

Real calculated = opt.NPV();
Real error = std::fabs(calculated-values[i].result);
if (error > values[i].tol) {
    REPORT_FAILURE("value", payoff, amExercise, values[i].barrierType, 
                   values[i].barrier, values[i].s,
                   values[i].q, values[i].r, today, values[i].v,
                   values[i].result, calculated, error, values[i].tol);
}
}

for (Size i=0; i<LENGTH(values); i++) {

boost::shared_ptr<StrikedTypePayoff> payoff(new AssetOrNothingPayoff(
    values[i].type, values[i].strike));

Date exDate = today + Integer(values[i].t*360+0.5);
boost::shared_ptr<Exercise> amExercise(new AmericanExercise(today,
                                                            exDate,
                                                            true));

spot ->setValue(values[i].s);
qRate->setValue(values[i].q);
rRate->setValue(values[i].r);
vol  ->setValue(values[i].v);

boost::shared_ptr<BlackScholesMertonProcess> stochProcess(new
    BlackScholesMertonProcess(Handle<Quote>(spot),
                              Handle<YieldTermStructure>(qTS),
                              Handle<YieldTermStructure>(rTS),
                              Handle<BlackVolTermStructure>(volTS)));
boost::shared_ptr<PricingEngine> engine(
                     new AnalyticBinaryBarrierEngine(stochProcess));

BarrierOption opt(values[i].barrierType, 
                  values[i].barrier, 
                  0,
                  payoff,
                  amExercise);

opt.setPricingEngine(engine);

Real calculated = opt.NPV();
Real error = std::fabs(calculated-values[i].result);
if (error > values[i].tol) {
    REPORT_FAILURE("value", payoff, amExercise, values[i].barrierType, 
                   values[i].barrier, values[i].s,
                   values[i].q, values[i].r, today, values[i].v,
                   values[i].result, calculated, error, values[i].tol);
}
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/dates.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (i=knownDates.begin(); i!=knownDates.end(); ++i) {

currentEcbDate = *i;
if (!ECB::isECBdate(currentEcbDate))
    BOOST_FAIL("\n" << currentEcbDate << " fails isECBdate check");

ecbDateMinusOne = currentEcbDate-1;
if (ECB::isECBdate(ecbDateMinusOne))
    BOOST_FAIL("\n" << ecbDateMinusOne << " fails isECBdate check");

if (ECB::nextDate(ecbDateMinusOne)!=currentEcbDate)
    BOOST_FAIL("\n next EBC date following " << ecbDateMinusOne <<
               " must be " << currentEcbDate);

if (ECB::nextDate(previousEcbDate)!=currentEcbDate)
    BOOST_FAIL("\n next EBC date following " << previousEcbDate <<
               " must be " << currentEcbDate);

previousEcbDate = currentEcbDate;
}

for (int i=0; i<40; ++i) {
    if (IMM::date(IMMcodes[i], counter)<counter)
        BOOST_FAIL("\n  "
               << IMM::date(IMMcodes[i], counter)
               << " is wrong for " << IMMcodes[i]
               << " at reference date " << counter);
}

for (int i = 0; i<120; ++i) {
    if (ASX::date(ASXcodes[i], counter)<counter)
        BOOST_FAIL("\n  "
        << ASX::date(ASXcodes[i], counter)
        << " is wrong for " << ASXcodes[i]
        << " at reference date " << counter);
}

for (BigInteger i=minDate; i<=maxDate; i++) {
Date t(i);
BigInteger serial = t.serialNumber();

// check serial number consistency
if (serial != i)
    BOOST_FAIL("inconsistent serial number:\n"
               << "    original:      " << i << "\n"
               << "    date:          " << t << "\n"
               << "    serial number: " << serial);

Integer dy = t.dayOfYear(),
        d  = t.dayOfMonth(),
        m  = t.month(),
        y  = t.year(),
        wd = t.weekday();

// check if skipping any date
if (!((dy == dyold+1) ||
      (dy == 1 && dyold == 365 && !Date::isLeap(yold)) ||
      (dy == 1 && dyold == 366 && Date::isLeap(yold))))
    BOOST_FAIL("wrong day of year increment: \n"
               << "    date: " << t << "\n"
               << "    day of year: " << dy << "\n"
               << "    previous:    " << dyold);
dyold = dy;

if (!((d == dold+1 && m == mold   && y == yold) ||
      (d == 1      && m == mold+1 && y == yold) ||
      (d == 1      && m == 1      && y == yold+1)))
    BOOST_FAIL("wrong day,month,year increment: \n"
               << "    date: " << t << "\n"
               << "    day,month,year: "
               << d << "," << Integer(m) << "," << y << "\n"
               << "    previous:       "
               << dold<< "," << Integer(mold) << "," << yold);
dold = d; mold = m; yold = y;

// check month definition
if (m < 1 || m > 12)
    BOOST_FAIL("invalid month: \n"
               << "    date:  " << t << "\n"
               << "    month: " << Integer(m));

// check day definition
if (d < 1)
    BOOST_FAIL("invalid day of month: \n"
               << "    date:  " << t << "\n"
               << "    day: " << d);
if (!((m == 1  && d <= 31) ||
      (m == 2  && d <= 28) ||
      (m == 2  && d == 29 && Date::isLeap(y)) ||
      (m == 3  && d <= 31) ||
      (m == 4  && d <= 30) ||
      (m == 5  && d <= 31) ||
      (m == 6  && d <= 30) ||
      (m == 7  && d <= 31) ||
      (m == 8  && d <= 31) ||
      (m == 9  && d <= 30) ||
      (m == 10 && d <= 31) ||
      (m == 11 && d <= 30) ||
      (m == 12 && d <= 31)))
    BOOST_FAIL("invalid day of month: \n"
               << "    date:  " << t << "\n"
               << "    day: " << d);

// check weekday definition
if (!((Integer(wd) == Integer(wdold+1)) ||
      (Integer(wd) == 1 && Integer(wdold) == 7)))
    BOOST_FAIL("invalid weekday: \n"
               << "    date:  " << t << "\n"
               << "    weekday:  " << Integer(wd) << "\n"
               << "    previous: " << Integer(wdold));
wdold = wd;

// create the same date with a different constructor
Date s(d,Month(m),y);
// check serial number consistency
serial = s.serialNumber();
if (serial != i)
    BOOST_FAIL("inconsistent serial number:\n"
               << "    date:          " << t << "\n"
               << "    serial number: " << i << "\n"
               << "    cloned date:   " <<  s << "\n"
               << "    serial number: " << serial);
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/creditdefaultswap.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=1; i<dates.size(); ++i) {
Time t1 = dayCounter.yearFraction(dates[0], dates[i-1]);
Time t2 = dayCounter.yearFraction(dates[0], dates[i]);
Probability S1 = 1.0 - defaultProbabilities[i-1];
Probability S2 = 1.0 - defaultProbabilities[i];
hazardRates.push_back(std::log(S1/S2)/(t2-t1));
}

for (Integer n=6; n<=10; ++n) {

Date maturity = calendar.advance(issueDate, n, Years);
Schedule schedule(issueDate, maturity, Period(frequency), calendar,
                  convention, convention,
                  DateGeneration::Forward, false);

CreditDefaultSwap cds(Protection::Seller, notional, fixedRate,
                      schedule, convention, cdsDayCount,
                      true, true);
cds.setPricingEngine(boost::shared_ptr<PricingEngine>(
                 new MidPointCdsEngine(probabilityCurve,
                                       recoveryRate, discountCurve)));

Real NPV = cds.NPV();
Rate flatRate = cds.impliedHazardRate(NPV, discountCurve,
                                      dayCounter,
                                      recoveryRate);

if (flatRate < h1 || flatRate > h2) {
    BOOST_ERROR("implied hazard rate outside expected range\n"
                << "    maturity: " << n << " years\n"
                << "    expected minimum: " << h1 << "\n"
                << "    expected maximum: " << h2 << "\n"
                << "    implied rate:     " << flatRate);
}

if (n > 6 && flatRate < latestRate) {
    BOOST_ERROR("implied hazard rate decreasing with swap maturity\n"
                << "    maturity: " << n << " years\n"
                << "    previous rate: " << latestRate << "\n"
                << "    implied rate:  " << flatRate);
}

latestRate = flatRate;

RelinkableHandle<DefaultProbabilityTermStructure> probability;
probability.linkTo(boost::shared_ptr<DefaultProbabilityTermStructure>(
 new FlatHazardRate(
   today,
   Handle<Quote>(boost::shared_ptr<Quote>(new SimpleQuote(flatRate))),
   dayCounter)));

CreditDefaultSwap cds2(Protection::Seller, notional, fixedRate,
                       schedule, convention, cdsDayCount,
                       true, true);
cds2.setPricingEngine(boost::shared_ptr<PricingEngine>(
                       new MidPointCdsEngine(probability,recoveryRate,
                                             discountCurve)));

Real NPV2 = cds2.NPV();
Real tolerance = 1.0;
if (std::fabs(NPV-NPV2) > tolerance) {
    BOOST_ERROR("failed to reproduce NPV with implied rate\n"
                << "    expected:   " << NPV << "\n"
                << "    calculated: " << NPV2);
}
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/stats.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i<LENGTH(data); i++)
    s.add(data[i],weights[i]);

for (i = 0; i<LENGTH(data); i++) {
    std::vector<Real> temp(dimension, data[i]);
    ss.add(temp, weights[i]);
}

for (i=0; i<dimension; i++) {
    if (calculated[i] != expected)
        BOOST_FAIL("SequenceStatistics<" << name << ">: "
                   << io::ordinal(i+1) << " dimension: "
                   << "wrong minimum value\n"
                   << "    calculated: " << calculated[i] << "\n"
                   << "    expected:   " << expected);
}

for (i=0; i<dimension; i++) {
    if (calculated[i] != expected)
        BOOST_FAIL("SequenceStatistics<" << name << ">: "
                   << io::ordinal(i+1) << " dimension: "
                   << "wrong maximun value\n"
                   << "    calculated: " << calculated[i] << "\n"
                   << "    expected:   " << expected);
}

for (i=0; i<dimension; i++) {
    if (std::fabs(calculated[i]-expected) > tolerance)
        BOOST_FAIL("SequenceStatistics<" << name << ">: "
                   << io::ordinal(i+1) << " dimension: "
                   << "wrong mean value\n"
                   << "    calculated: " << calculated[i] << "\n"
                   << "    expected:   " << expected);
}

for (i=0; i<dimension; i++) {
    if (std::fabs(calculated[i]-expected) > tolerance)
        BOOST_FAIL("SequenceStatistics<" << name << ">: "
                   << io::ordinal(i+1) << " dimension: "
                   << "wrong variance\n"
                   << "    calculated: " << calculated[i] << "\n"
                   << "    expected:   " << expected);
}

for (i=0; i<dimension; i++) {
    if (std::fabs(calculated[i]-expected) > tolerance)
        BOOST_FAIL("SequenceStatistics<" << name << ">: "
                   << io::ordinal(i+1) << " dimension: "
                   << "wrong standard deviation\n"
                   << "    calculated: " << calculated[i] << "\n"
                   << "    expected:   " << expected);
}

for (i=0; i<dimension; i++) {
    if (std::fabs(calculated[i]-expected) > tolerance)
        BOOST_FAIL("SequenceStatistics<" << name << ">: "
                   << io::ordinal(i+1) << " dimension: "
                   << "wrong skewness\n"
                   << "    calculated: " << calculated[i] << "\n"
                   << "    expected:   " << expected);
}

for (i=0; i<dimension; i++) {
    if (std::fabs(calculated[i]-expected) > tolerance)
        BOOST_FAIL("SequenceStatistics<" << name << ">: "
                   << io::ordinal(i+1) << " dimension: "
                   << "wrong kurtosis\n"
                   << "    calculated: " << calculated[i] << "\n"
                   << "    expected:   " << expected);
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/twoassetbarrieroption.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i<LENGTH(values); i++) {

s1->setValue(values[i].s1);
q1->setValue(values[i].q1);
vol1->setValue(values[i].v1);

s2->setValue(values[i].s2);
q2->setValue(values[i].q2);
vol2->setValue(values[i].v2);

rho->setValue(values[i].correlation);

r->setValue(values[i].r);

boost::shared_ptr<StrikedTypePayoff> payoff(
            new PlainVanillaPayoff(values[i].type, values[i].strike));

TwoAssetBarrierOption barrierOption(values[i].barrierType,
                                    values[i].barrier,
                                    payoff,
                                    exercise);
barrierOption.setPricingEngine(engine);

Real calculated = barrierOption.NPV();
Real expected = values[i].result;
Real error = std::fabs(calculated-expected);
Real tolerance = 4.0e-3;
if (error > tolerance) {
    BOOST_ERROR("failed to reproduce expected price"
                << "\n    expected:   " << expected
                << "\n    calculated: " << calculated
                << "\n    tolerance:  " << tolerance
                << "\n    error:      " << error);
}
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/optimizers.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    for (Size i=0; i<=polynomialDegree_; ++i)
        y += coefficients_[i]*std::pow(x[0],static_cast<int>(i));

for (Size i=0; i<optimizationMethodNb; ++i) {
    NamedOptimizationMethod namedOptimizationMethod;
    namedOptimizationMethod.optimizationMethod = makeOptimizationMethod(
        optimizationMethodTypes[i],
        simplexLambda,
        levenbergMarquardtEpsfcn,
        levenbergMarquardtXtol,
        levenbergMarquardtGtol);
    namedOptimizationMethod.name
        = optimizationMethodTypeToString(optimizationMethodTypes[i]);
    results.push_back(namedOptimizationMethod);
}

for (Size i=0; i<diff.size(); ++i)
    maxDiff = std::max(maxDiff, std::fabs(diff[i]));

for (Size i=0; i<costFunctions_.size(); ++i) {
Problem problem(*costFunctions_[i], *constraints_[i],
                initialValues_[i]);
Array initialValues = problem.currentValue();
// Loop over optimizers
for (Size j=0; j<(optimizationMethods_[i]).size(); ++j) {
    Real rootEpsilon = endCriterias_[i]->rootEpsilon();
    Size endCriteriaTests = 1;
   // Loop over rootEpsilon
    for (Size k=0; k<endCriteriaTests; ++k) {
        problem.setCurrentValue(initialValues);
        EndCriteria endCriteria(
                    endCriterias_[i]->maxIterations(),
                    endCriterias_[i]->maxStationaryStateIterations(),
                    rootEpsilon,
                    endCriterias_[i]->functionEpsilon(),
                    endCriterias_[i]->gradientNormEpsilon());
        rootEpsilon *= .1;
        EndCriteria::Type endCriteriaResult =
            optimizationMethods_[i][j].optimizationMethod->minimize(
            problem, endCriteria);
        Array xMinCalculated = problem.currentValue();
        Array yMinCalculated = problem.values(xMinCalculated);

        // Check optimization results vs known solution
        bool completed;
        switch (endCriteriaResult) {
          case EndCriteria::None:
          case EndCriteria::MaxIterations:
          case EndCriteria::Unknown:
            completed = false;
            break;
          default:
            completed = true;
        }

        Real xError = maxDifference(xMinCalculated,xMinExpected_[i]);
        Real yError = maxDifference(yMinCalculated,yMinExpected_[i]);

        bool correct = (xError <= endCriteria.rootEpsilon() ||
                        yError <= endCriteria.functionEpsilon());

        if ((!completed) || (!correct))
            BOOST_ERROR("costFunction # = " << i <<
                        "\nOptimizer: " <<
                        optimizationMethods_[i][j].name <<
                        "\n    function evaluations: " <<
                        problem.functionEvaluation()  <<
                        "\n    gradient evaluations: " <<
                        problem.gradientEvaluation() <<
                        "\n    x expected:           " <<
                        xMinExpected_[i] <<
                        "\n    x calculated:         " <<
                        std::setprecision(9) << xMinCalculated <<
                        "\n    x difference:         " <<
                        xMinExpected_[i]- xMinCalculated <<
                        "\n    rootEpsilon:          " <<
                        std::setprecision(9) <<
                        endCriteria.rootEpsilon() <<
                        "\n    y expected:           " <<
                        yMinExpected_[i] <<
                        "\n    y calculated:         " <<
                        std::setprecision(9) << yMinCalculated <<
                        "\n    y difference:         " <<
                        yMinExpected_[i]- yMinCalculated <<
                        "\n    functionEpsilon:      " <<
                        std::setprecision(9) <<
                        endCriteria.functionEpsilon() <<
                        "\n    endCriteriaResult:    " <<
                        endCriteriaResult);
    }
}
}

    for (Size i=0; i<x.size(); ++i) {
        fx += std::floor(x[i])*std::floor(x[i]);
    }

    for (Size i=0; i<x.size(); ++i) {
        fx += (i+1.0)*pow(x[i],4.0) + uniformRng_.nextReal();
    }

    for (Size i=0; i<x.size(); ++i) {
        fx += x[i]*x[i]/4000.0;
    }

    for (Size i=0; i<x.size(); ++i) {
        p *= cos(x[i]/sqrt(i+1.0));
    }

for (Size i = 0; i < costFunctions.size(); ++i) {
Problem problem(*costFunctions[i], constraints[i], initialValues[i]);
diffEvolOptimisers[i].minimize(problem, endCriteria[i]);

if (i != 3) {
    // stable
    if (std::fabs(problem.functionValue() - minima[i]) > 1e-8) {
        BOOST_ERROR("costFunction # " << i
                    << "\ncalculated: " << problem.functionValue()
                    << "\nexpected:   " << minima[i]);
    }
} else {
    // this case is unstable due to randomness; we're good as
    // long as the result is below 15
    if (problem.functionValue() > 15) {
        BOOST_ERROR("costFunction # " << i
                    << "\ncalculated: " << problem.functionValue()
                    << "\nexpected:   " << "less than 15");
    }
}
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/calendars.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Date d = firstDate; d < endDate; d++) {

bool b1 = c1.isBusinessDay(d),
     b2 = c2.isBusinessDay(d),
     b3 = c3.isBusinessDay(d),
     b4 = c4.isBusinessDay(d);

if ((b1 && b2) != c12h.isBusinessDay(d))
    BOOST_FAIL("At date " << d << ":\n"
               << "    inconsistency between joint calendar "
               << c12h.name() << " (joining holidays)\n"
               << "    and its components");

if ((b1 || b2) != c12b.isBusinessDay(d))
    BOOST_FAIL("At date " << d << ":\n"
               << "    inconsistency between joint calendar "
               << c12b.name() << " (joining business days)\n"
               << "    and its components");

if ((b1 && b2 && b3) != c123h.isBusinessDay(d))
    BOOST_FAIL("At date " << d << ":\n"
               << "    inconsistency between joint calendar "
               << c123h.name() << " (joining holidays)\n"
               << "    and its components");

if ((b1 || b2 || b3) != c123b.isBusinessDay(d))
    BOOST_FAIL("At date " << d << ":\n"
               << "    inconsistency between joint calendar "
               << c123b.name() << " (joining business days)\n"
               << "    and its components");

if ((b1 && b2 && b3 && b4) != c1234h.isBusinessDay(d))
    BOOST_FAIL("At date " << d << ":\n"
               << "    inconsistency between joint calendar "
               << c1234h.name() << " (joining holidays)\n"
               << "    and its components");

if ((b1 || b2 || b3 || b4) != c1234b.isBusinessDay(d))
    BOOST_FAIL("At date " << d << ":\n"
               << "    inconsistency between joint calendar "
               << c1234b.name() << " (joining business days)\n"
               << "    and its components");

}

for (Size i=0; i<std::min<Size>(hol.size(), expectedHol.size()); i++) {
if (hol[i]!=expectedHol[i])
    BOOST_FAIL("expected holiday was " << expectedHol[i]
               << " while calculated holiday is " << hol[i]);
}

for (Size i=0; i<std::min<Size>(hol.size(), expectedHol.size()); i++) {
if (hol[i]!=expectedHol[i])
    BOOST_FAIL("expected holiday was " << expectedHol[i]
               << " while calculated holiday is " << hol[i]);
}

for (i=0; i<std::min<Size>(hol.size(), expectedHol.size()); i++) {
if (hol[i]!=expectedHol[i])
    BOOST_FAIL("expected holiday was " << expectedHol[i]
               << " while calculated holiday is " << hol[i]);
}

for (i=0; i<histClose.size(); i++) {
if (!c.isHoliday(histClose[i]))
    BOOST_FAIL(histClose[i]
               << " should be holiday (historical close)");
}

for (Size i=0; i<std::min<Size>(hol.size(), expectedHol.size()); i++) {
if (hol[i]!=expectedHol[i])
    BOOST_FAIL("expected holiday was " << expectedHol[i]
               << " while calculated holiday is " << hol[i]);
}

for (Size i=0; i<std::min<Size>(hol.size(), expectedHol.size()); i++) {
if (hol[i]!=expectedHol[i])
    BOOST_FAIL("expected holiday was " << expectedHol[i]
               << " while calculated holiday is " << hol[i]);
}

for (Size i=0; i<std::min<Size>(hol.size(), expectedHol.size()); i++) {
if (hol[i]!=expectedHol[i])
    BOOST_FAIL("expected holiday was " << expectedHol[i]
               << " while calculated holiday is " << hol[i]);
}

for (Size i=0; i<std::min<Size>(hol.size(), expectedHol.size()); i++) {
if (hol[i]!=expectedHol[i])
    BOOST_FAIL("expected holiday was " << expectedHol[i]
               << " while calculated holiday is " << hol[i]);
}

for (Size i=0; i<std::min<Size>(hol.size(), expectedHol.size()); i++) {
if (hol[i]!=expectedHol[i])
    BOOST_FAIL("expected holiday was " << expectedHol[i]
               << " while calculated holiday is " << hol[i]);
}

for (Size i=0; i<std::min<Size>(hol.size(), expectedHol.size()); i++) {
if (hol[i]!=expectedHol[i])
    BOOST_FAIL("expected holiday was " << expectedHol[i]
               << " while calculated holiday is " << hol[i]);
}

for (Size i=0; i<std::min<Size>(hol.size(), expectedHol.size()); i++) {
if (hol[i]!=expectedHol[i])
    BOOST_FAIL("expected holiday was " << expectedHol[i]
               << " while calculated holiday is " << hol[i]);
}

for (Size i=0; i<std::min<Size>(hol.size(), expectedHol.size()); i++) {
if (hol[i]!=expectedHol[i])
    BOOST_FAIL("expected holiday was " << expectedHol[i]
               << " while calculated holiday is " << hol[i]);
}

for (Size i=0; i<std::min<Size>(hol.size(), expectedHol.size()); i++) {
if (hol[i]!=expectedHol[i])
    BOOST_FAIL("expected holiday was " << expectedHol[i]
               << " while calculated holiday is " << hol[i]);
}

for (Size i=0; i<std::min<Size>(hol.size(), expectedHol.size()); i++) {
if (hol[i]!=expectedHol[i])
    BOOST_FAIL("expected holiday was " << expectedHol[i]
               << " while calculated holiday is " << hol[i]);
}

for (Size i=0; i<std::min<Size>(hol.size(), expectedHol.size()); i++) {
if (hol[i]!=expectedHol[i])
    BOOST_FAIL("expected holiday was " << expectedHol[i]
               << " while calculated holiday is " << hol[i]);
}

for (Size i=1; i<testDates.size(); i++) {
Integer calculated = calendar.businessDaysBetween(testDates[i-1],
                                                  testDates[i]);
if (calculated != expected[i-1]) {
    BOOST_ERROR("from " << testDates[i-1]
                << " to " << testDates[i] << ":\n"
                << "    calculated: " << calculated << "\n"
                << "    expected:   " << expected[i-1]);
}
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/fdheston.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i<LENGTH(values); i++) {
Date exDate = todaysDate + Integer(values[i].t*365+0.5);
boost::shared_ptr<Exercise> exercise(new EuropeanExercise(exDate));

boost::dynamic_pointer_cast<SimpleQuote>(spot .currentLink())
                                            ->setValue(values[i].s);
qRate->setValue(values[i].q);
rRate->setValue(values[i].r);
vol  ->setValue(values[i].v);

boost::shared_ptr<StrikedTypePayoff> payoff(new
            PlainVanillaPayoff(values[i].type, values[i].strike));

BarrierOption barrierOption(values[i].barrierType, values[i].barrier,
                            values[i].rebate, payoff, exercise);

const Real v0 = vol->value()*vol->value();
boost::shared_ptr<HestonProcess> hestonProcess(
     new HestonProcess(rTS, qTS, spot, v0, 1.0, v0, 0.00001, 0.0));

barrierOption.setPricingEngine(boost::shared_ptr<PricingEngine>(
    new FdHestonBarrierEngine(boost::shared_ptr<HestonModel>(
                      new HestonModel(hestonProcess)), 200, 400, 3)));

const Real calculatedHE = barrierOption.NPV();

barrierOption.setPricingEngine(analyticEngine);
const Real expected = barrierOption.NPV();

const Real tol = 0.002;
if (std::fabs(calculatedHE - expected)/expected > tol) {
    BOOST_ERROR("Failed to reproduce expected Heston npv"
                << "\n    calculated: " << calculatedHE
                << "\n    expected:   " << expected
                << "\n    tolerance:  " << tol); 
}
}

for (Size i=0; i < LENGTH(strikes); ++i) {
Handle<Quote> s0(boost::shared_ptr<Quote>(new SimpleQuote(strikes[i])));
boost::shared_ptr<HestonProcess> hestonProcess(
    new HestonProcess(rTS, qTS, s0, 0.0625, 5, 0.16, 0.9, 0.1));

boost::shared_ptr<PricingEngine> engine(
     new FdHestonVanillaEngine(boost::shared_ptr<HestonModel>(
                         new HestonModel(hestonProcess)), 100, 400));
option.setPricingEngine(engine);

Real calculated = option.NPV();
if (std::fabs(calculated - expected[i]) > tol) {
    BOOST_ERROR("Failed to reproduce expected npv"
                << "\n    strike:     " << strikes[i]
                << "\n    calculated: " << calculated
                << "\n    expected:   " << expected[i]
                << "\n    tolerance:  " << tol); 
}
}

for (Size i=0; i < LENGTH(strikes); ++i) {
Handle<Quote> s0(boost::shared_ptr<Quote>(new SimpleQuote(strikes[i])));

boost::shared_ptr<GeneralizedBlackScholesProcess> bsProcess(
               new GeneralizedBlackScholesProcess(s0, qTS, rTS, volTS));

option.setPricingEngine(boost::shared_ptr<PricingEngine>(
                                new AnalyticEuropeanEngine(bsProcess)));

const Real expected = option.NPV();

boost::shared_ptr<HestonProcess> hestonProcess(
    new HestonProcess(rTS, qTS, s0, 0.0625, 1, 0.0625, 0.0001, 0.0));

// Hundsdorfer scheme
option.setPricingEngine(boost::shared_ptr<PricingEngine>(
     new FdHestonVanillaEngine(boost::shared_ptr<HestonModel>(
                                   new HestonModel(hestonProcess)), 
                               100, 400)));

Real calculated = option.NPV();
if (std::fabs(calculated - expected) > tol) {
    BOOST_ERROR("Failed to reproduce expected npv"
                << "\n    strike:     " << strikes[i]
                << "\n    calculated: " << calculated
                << "\n    expected:   " << expected
                << "\n    tolerance:  " << tol); 
}

// Explicit scheme
option.setPricingEngine(boost::shared_ptr<PricingEngine>(
     new FdHestonVanillaEngine(boost::shared_ptr<HestonModel>(
                                   new HestonModel(hestonProcess)), 
                               10000, 400, 5, 0, 
                               FdmSchemeDesc::ExplicitEuler())));

calculated = option.NPV();
if (std::fabs(calculated - expected) > tol) {
    BOOST_ERROR("Failed to reproduce expected npv"
                << "\n    strike:     " << strikes[i]
                << "\n    calculated: " << calculated
                << "\n    expected:   " << expected
                << "\n    tolerance:  " << tol); 
}
}

for (Size l=0; l < LENGTH(schemes); ++l) {
for (Size i=0; i < LENGTH(values); ++i) {
    for (Size j=0; j < LENGTH(tn); ++j) {
        for (Size k=0; k < LENGTH(v0); ++k) {
            Handle<YieldTermStructure> rTS(
                flatRate(values[i].r, Actual365Fixed()));
            Handle<YieldTermStructure> qTS(
                flatRate(values[i].q, Actual365Fixed()));
        
            boost::shared_ptr<HestonProcess> hestonProcess(
                new HestonProcess(rTS, qTS, s0, 
                                  v0[k], 
                                  values[i].kappa, 
                                  values[i].theta, 
                                  values[i].sigma, 
                                  values[i].rho));
        
            Date exerciseDate = todaysDate 
                + Period(static_cast<Integer>(values[i].T*365), Days);
            boost::shared_ptr<Exercise> exercise(
                                  new EuropeanExercise(exerciseDate));
        
            boost::shared_ptr<StrikedTypePayoff> payoff(new
                       PlainVanillaPayoff(Option::Call, values[i].K));
    
            VanillaOption option(payoff, exercise);
            boost::shared_ptr<PricingEngine> engine(
                 new FdHestonVanillaEngine(
                     boost::shared_ptr<HestonModel>(
                         new HestonModel(hestonProcess)), 
                     tn[j], 400, 100, 0, 
                     schemes[l]));
            option.setPricingEngine(engine);
            
            const Real calculated = option.NPV();
            
            boost::shared_ptr<PricingEngine> analyticEngine(
                new AnalyticHestonEngine(
                    boost::shared_ptr<HestonModel>(
                        new HestonModel(hestonProcess)), 144));
            
            option.setPricingEngine(analyticEngine);
            const Real expected = option.NPV();
            if (   std::fabs(expected - calculated)/expected > 0.02
                && std::fabs(expected - calculated) > 0.002) {
                BOOST_ERROR("Failed to reproduce expected npv"
                            << "\n    calculated: " << calculated
                            << "\n    expected:   " << expected
                            << "\n    tolerance:  " << 0.01); 
            }
        }
    }
}
}

for (Time t=dt; t <= maturity+20*QL_EPSILON; t+=dt) {
    evolver.step(p, t);
}

for (Size i=0; i < x.size(); ++i) {
    payoffTimesDensity[i] = payoff->operator()(std::exp(x[i]))*p[i];
}

for (Size i=0; i < LENGTH(strikes); ++i) {
const boost::shared_ptr<StrikedTypePayoff> payoff(
    new PlainVanillaPayoff(Option::Call, strikes[i]));

VanillaOption option(payoff, exercise);
option.setPricingEngine(engine);

const Real expected = option.NPV()/rTS->discount(maturityDate);
const Real calcUniform
    = fokkerPlanckPrice1D(uniformMesher, uniformBSFwdOp,
                          payoff, x0, maturity, tGrid);
const Real calcConcentrated
    = fokkerPlanckPrice1D(concentratedMesher, concentratedBSFwdOp,
                          payoff, x0, maturity, tGrid);
const Real calcShifted
    = fokkerPlanckPrice1D(shiftedMesher, shiftedBSFwdOp,
                          payoff, x0, maturity, tGrid);
const Real tol = 0.02;

if (std::fabs(expected - calcUniform) > tol) {
    BOOST_FAIL("failed to reproduce european option price "
               << "with an uniform mesher"
               << "\n   strike:     " << strikes[i]
               << QL_FIXED << std::setprecision(8)
               << "\n   calculated: " << calcUniform
               << "\n   expected:   " << expected
               << "\n   tolerance:  " << tol);
}
if (std::fabs(expected - calcConcentrated) > tol) {
    BOOST_FAIL("failed to reproduce european option price "
               << "with a concentrated mesher"
               << "\n   strike:     " << strikes[i]
               << QL_FIXED << std::setprecision(8)
               << "\n   calculated: " << calcConcentrated
               << "\n   expected:   " << expected
               << "\n   tolerance:  " << tol);
}
if (std::fabs(expected - calcShifted) > tol) {
    BOOST_FAIL("failed to reproduce european option price "
               << "with a shifted mesher"
               << "\n   strike:     " << strikes[i]
               << QL_FIXED << std::setprecision(8)
               << "\n   calculated: " << calcShifted
               << "\n   expected:   " << expected
               << "\n   tolerance:  " << tol);
}
}

for (Size i=0; i < 5; ++i) {
const Real v = vmin + i*0.001;
const Real vm2 = v - 2*h;
const Real vm1 = v - h;
const Real v0  = v;
const Real v1  = v + h;
const Real v2  = v + 2*h;

const Real pm2= squareRootGreensFct(v_0, kappa, theta, sigma, t, vm2);
const Real pm1= squareRootGreensFct(v_0, kappa, theta, sigma, t, vm1);
const Real p0 = squareRootGreensFct(v_0, kappa, theta, sigma, t, v0);
const Real p1 = squareRootGreensFct(v_0, kappa, theta, sigma, t, v1);
const Real p2 = squareRootGreensFct(v_0, kappa, theta, sigma, t, v2);

// test derivatives
const Real flowSym2Order = sigma*sigma*v0/(4*h)*(p1-pm1)
                        + (kappa*(v0-theta)+sigma*sigma/2)*p0;

const Real flowSym4Order
    = sigma*sigma*v0/(24*h)*(-p2 + 8*p1 - 8*pm1 + pm2)
      + (kappa*(v0-theta)+sigma*sigma/2)*p0;

const Real fwd1Order = sigma*sigma*v0/(2*h)*(p1-p0)
                        + (kappa*(v0-theta)+sigma*sigma/2)*p0;

const Real fwd2Order = sigma*sigma*v0/(4*h)*(4*p1-3*p0-p2)
                        + (kappa*(v0-theta)+sigma*sigma/2)*p0;

const Real fwd3Order
    = sigma*sigma*v0/(12*h)*(-p2 + 6*p1 - 3*p0 - 2*pm1)
                        + (kappa*(v0-theta)+sigma*sigma/2)*p0;

const Real tol = 0.000002;
if (   std::fabs(expected[i][0] - flowSym2Order) > tol
    || std::fabs(expected[i][1] - flowSym4Order) > tol
    || std::fabs(expected[i][2] - fwd1Order) > tol
    || std::fabs(expected[i][3] - fwd2Order) > tol
    || std::fabs(expected[i][4] - fwd3Order) > tol ) {
    BOOST_ERROR("failed to reproduce Zero Flow BC at"
               << "\n   v:          " << v
               << "\n   tolerance:  " << tol);
}
}

for (Size i=0; i < vGrid; ++i) {
    v[i] = invStationaryDistributionFct(kappa, theta,
                                        sigma, qMin + i*dq);
}

for (Size i=0; i < v.size(); ++i)
p[i] =  stationaryProbabilityFct(kappa, theta, sigma, v[i]);

for (Size i=0; i < vGrid/2; ++i) {
const Real hm = v[i+1] - v[i];
const Real hp = v[i+2] - v[i+1];

const Real eta=1.0/(hm*(hm+hp)*hp);
const Real a = -eta*(square<Real>()(hm+hp) - hm*hm);
const Real b  = eta*square<Real>()(hm+hp);
const Real c = -eta*hm*hm;

const Real df = a*q[i] + b*q[i+1] + c*q[i+2];
const Real flow = 0.5*sigma*sigma*v[i]*df + kappa*v[i]*q[i];

const Real tol = 1e-6;
if (std::fabs(flow) > tol) {
    BOOST_ERROR("failed to reproduce Zero Flow BC at"
               << "\n v:          " << v
               << "\n flow:       " << flow
               << "\n tolerance:  " << tol);
}
}

for (Real sigma = 0.2; sigma < 2.01; sigma+=0.1) {
const Real vMin
    = invStationaryDistributionFct(kappa, theta, sigma, eps);
const Real vMax
    = invStationaryDistributionFct(kappa, theta, sigma, 1-eps);

const boost::shared_ptr<FdmMesher> mesher(
    new FdmMesherComposite(boost::shared_ptr<Fdm1dMesher>(
            new Uniform1dMesher(vMin, vMax, vGrid))));

const Array v = mesher->locations(0);

Array p(vGrid);
for (Size i=0; i < v.size(); ++i)
    p[i] =  stationaryProbabilityFct(kappa, theta, sigma, v[i]);

const boost::shared_ptr<FdmSquareRootFwdOp> op(
    new FdmSquareRootFwdOp(mesher, kappa, theta, sigma, 0,
                           (sigma < 0.75) ? FdmSquareRootFwdOp::Plain
                                                : FdmSquareRootFwdOp::Power));

const Array eP = p;

const Size n = 100;
const Time dt = 0.01;
DouglasScheme evolver(0.5, op);
evolver.setStep(dt);

for (Size i=1; i <= n; ++i) {
    evolver.step(p, i*dt);
}

const Real expected = 1-2*eps;
const Real alpha = 1-2*kappa*theta/(sigma*sigma);
const Real calculated = GaussLobattoIntegral(1000000, 1e-6)(
                                q_fct(v,p,alpha), v.front(), v.back());

const Real tol = 0.005;
if (std::fabs(calculated-expected) > tol) {
    BOOST_ERROR("failed to reproduce stationary probability function"
            << "\n    calculated: " << calculated
            << "\n    expected:   " << expected
            << "\n    tolerance:  " << tol);
}
}

for (Size i=0; i < p.size(); ++i) {
p[i] = squareRootGreensFct(v0, kappa, theta,
                           sigma, n*dt, x[i]);
}

for (Time t=(n+1)*dt; t <= maturity+20*QL_EPSILON; t+=dt) {
evolver.step(p, t);
evolver.step(q, t);
}

for (Size i=0; i < x.size(); ++i) {
const Real expected = squareRootGreensFct(v0, kappa, theta,
                                          sigma, maturity, x[i]);

const Real calculated = p[i];
if (std::fabs(expected - calculated) > tol) {
    BOOST_FAIL("failed to reproduce pdf at"
               << QL_FIXED << std::setprecision(5)
               << "\n   x:          " << x[i]
               << "\n   calculated: " << calculated
               << "\n   expected:   " << expected
               << "\n   tolerance:  " << tol);
}
}

for (Size i=0; i < tGrid; ++i, t+=dt) {
evolver.step(p, t);
}

for (Size i=0; i < LENGTH(strikes); ++i) {
const Real strike = strikes[i];
const boost::shared_ptr<StrikedTypePayoff> payoff(
    new PlainVanillaPayoff((strike > s0) ? Option::Call
    		                             : Option::Put, strike));

Array pd(p.size());
for (FdmLinearOpIterator iter = layout->begin();
    iter != layout->end(); ++iter) {
    const Size idx = iter.index();
    const Real s = std::exp(mesher->location(iter, 0));

    pd[idx] = payoff->operator()(s)*p[idx];
}

const Real calculated
    = fokkerPlanckPrice2D(pd, mesher)*rTS->discount(maturityDate);

VanillaOption option(payoff, exercise);
option.setPricingEngine(engine);
const Real expected = option.NPV();

const Real tol = 0.1;
if (std::fabs(expected - calculated ) > tol) {
    BOOST_FAIL("failed to reproduce Heston prices at"
               << "\n   strike      " << strike
               << QL_FIXED << std::setprecision(5)
               << "\n   calculated: " << calculated
               << "\n   expected:   " << expected
               << "\n   tolerance:  " << tol);
}
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/variancegamma.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i<LENGTH(processes); i++) {
boost::shared_ptr<SimpleQuote> spot(new SimpleQuote(processes[i].s));
boost::shared_ptr<SimpleQuote> qRate(new SimpleQuote(processes[i].q));
boost::shared_ptr<YieldTermStructure> qTS = flatRate(today, qRate, dc);
boost::shared_ptr<SimpleQuote> rRate(new SimpleQuote(processes[i].r));
boost::shared_ptr<YieldTermStructure> rTS = flatRate(today, rRate, dc);

boost::shared_ptr<VarianceGammaProcess> stochProcess(
    new VarianceGammaProcess(Handle<Quote>(spot),
    Handle<YieldTermStructure>(qTS),
    Handle<YieldTermStructure>(rTS),
    processes[i].sigma,
    processes[i].nu,
    processes[i].theta));

// Analytic engine
boost::shared_ptr<PricingEngine> analyticEngine(
    new VarianceGammaEngine(stochProcess));

// FFT engine
boost::shared_ptr<FFTVarianceGammaEngine> fftEngine(
    new FFTVarianceGammaEngine(stochProcess));

// which requires a list of options
std::vector<boost::shared_ptr<Instrument> > optionList;

std::vector<boost::shared_ptr<StrikedTypePayoff> > payoffs;
for (Size j=0; j<LENGTH(options); j++)
{
    Date exDate = today + Integer(options[j].t*360+0.5);
    boost::shared_ptr<Exercise> exercise(new EuropeanExercise(exDate));

    boost::shared_ptr<StrikedTypePayoff> payoff(new
        PlainVanillaPayoff(options[j].type, options[j].strike));
    payoffs.push_back(payoff);

    // Test analytic engine
    boost::shared_ptr<EuropeanOption> option(new EuropeanOption(payoff, exercise));
    option->setPricingEngine(analyticEngine);

    Real calculated = option->NPV();
    Real expected = results[i][j];
    Real error = std::fabs(calculated-expected);

    if (error>tol) {
        REPORT_FAILURE("analytic value", payoff, exercise,
            processes[i].s, processes[i].q, processes[i].r,
            today, processes[i].sigma, processes[i].nu,
            processes[i].theta, expected, calculated,
            error, tol);  
    }
    optionList.push_back(option);
}

// Test FFT engine
// FFT engine is extremely efficient when sent a list of options to calculate first
fftEngine->precalculate(optionList);
for (Size j=0; j<LENGTH(options); j++)
{
    boost::shared_ptr<VanillaOption> option = boost::static_pointer_cast<VanillaOption>(optionList[j]);
    option->setPricingEngine(fftEngine);

    Real calculated = option->NPV();
    Real expected = results[i][j];
    Real error = std::fabs(calculated-expected);
    if (error>tol) {
        boost::shared_ptr<StrikedTypePayoff> payoff = 
            boost::dynamic_pointer_cast<StrikedTypePayoff>(option->payoff());
        REPORT_FAILURE("fft value", payoff, option->exercise(),
            processes[i].s, processes[i].q, processes[i].r,
            today, processes[i].sigma, processes[i].nu,
            processes[i].theta, expected, calculated,
            error, tol);
    }
}
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/swapforwardmappings.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=1; i<nbRates_+2; ++i)
    rateTimes_[i-1] = dayCounter.yearFraction(todaysDate, dates[i]);

for (Size i=0; i<nbRates_; ++i){
    forwards_[i] = 0.03 + 0.0010*i;
    accruals_[i] = rateTimes_[i+1] - rateTimes_[i];
    discountFactors_[i+1] = discountFactors_[i]
    /(1+forwards_[i]*accruals_[i]);
}

for (Size i = 0; i < volatilities_.size(); ++i)
    volatilities_[i] =   mktVols[i];//.0;

    for (Size i = 0; i < payoffs.size(); ++i){
        payoffs[i] = boost::shared_ptr<StrikedTypePayoff>(new
            PlainVanillaPayoff(Option::Call, strike));
    }

for (Size i=0; i < nbRates; ++i)
    for (Size j=0; j < nbRates; ++j)
    {
        bumpedForwards = forwards;
        bumpedForwards[j]+= bumpSize;
        lmmCurveState.setOnForwardRates(bumpedForwards);
        Real upRate = lmmCurveState.cmSwapRate(0,i+1);
        bumpedForwards[j]-= 2.0*bumpSize;
        lmmCurveState.setOnForwardRates(bumpedForwards);
        Real downRate = lmmCurveState.cmSwapRate(0,i+1);
        Real deriv = (upRate-downRate)/(2.0*bumpSize);
        coinitialJacobian[i][j] = deriv;

    }

    for (Size i=0; i < nbRates; ++i)
        for (Size j=0; j < nbRates; ++j)
            if( fabs(modelJacobian[i][j]-coinitialJacobian[i][j]) > errorTolerance)
            {
                BOOST_TEST_MESSAGE(
                    "rate " << i
                    << ", sensitivity "  <<  j
                    << ", formula value " << modelJacobian[i][j]
                << " bumping value " << coinitialJacobian[i][j]
                <<  "\n");

                BOOST_ERROR("test failed");

            }

for( Size spanningForwards = 1; spanningForwards < nbRates; ++spanningForwards)
{

    std::vector<Rate> bumpedForwards(forwards);

    Matrix cmsJacobian(nbRates,nbRates);

    for (Size i=0; i < nbRates; ++i)
        for (Size j=0; j < nbRates; ++j)
        {
            bumpedForwards = forwards;
            bumpedForwards[j]+= bumpSize;
            lmmCurveState.setOnForwardRates(bumpedForwards);
            Real upRate = lmmCurveState.cmSwapRate(i,spanningForwards);
            bumpedForwards[j]-= 2.0*bumpSize;
            lmmCurveState.setOnForwardRates(bumpedForwards);
            Real downRate = lmmCurveState.cmSwapRate(i,spanningForwards);
            Real deriv = (upRate-downRate)/(2.0*bumpSize);
            cmsJacobian[i][j] = deriv;

        }

        Matrix modelJacobian(SwapForwardMappings::cmSwapForwardJacobian(lmmCurveState, spanningForwards));

        Real errorTolerance = 1e-5;


        for (Size i=0; i < nbRates; ++i)
            for (Size j=0; j < nbRates; ++j)
                if( fabs(modelJacobian[i][j]-cmsJacobian[i][j]) > errorTolerance)
                {
                    BOOST_TEST_MESSAGE(
                        "rate " << i
                        << ", sensitivity "  <<  j
                        << ", formula value " << modelJacobian[i][j]
                    << " bumping value " << cmsJacobian[i][j]
                    <<  "\n");

                    BOOST_ERROR("test failed");

                }
}

for (Size i=0; i<nbRates; ++i) {
const Matrix& cotSwapsCovariance = smmMarketModel->totalCovariance(i);
//Matrix cotSwapsCovariance= jacobian * forwardsCovariance * transpose(jacobian);
//Time expiry = rateTimes[i];
boost::shared_ptr<PlainVanillaPayoff> payoff(
    new PlainVanillaPayoff(Option::Call, strike+displacement));
//const std::vector<Time>&  taus = lmmCurveState.rateTaus();
Real expectedSwaption = BlackCalculator(payoff,
    todaysCoterminalSwapRates[i]+displacement,
    std::sqrt(cotSwapsCovariance[i][i]),
    lmmCurveState.coterminalSwapAnnuity(i,i) *
    todaysDiscounts[i]).value();
if (fabs(expectedSwaption-results[i]) > 0.0001)
    BOOST_ERROR(
    "expected\t" << expectedSwaption <<
    "\tLMM\t" << results[i]
<< "\tstdev:\t" << errors[i] <<
    "\t" <<std::fabs(results[i]- expectedSwaption)/errors[i]);
}

for (Size startIndex = 1; startIndex+2 < nbRates; startIndex = startIndex+5)
{

Size endIndex = nbRates-2;

boost::shared_ptr<StrikedTypePayoff> payoff(new   
    PlainVanillaPayoff(Option::Call, strike));
MultiStepSwaption product(rateTimes, startIndex, endIndex,payoff );

const EvolutionDescription evolution = product.evolution();
const Size numberOfFactors = nbRates;
Spread displacement = marketData.displacements().front();
Matrix jacobian =
    SwapForwardMappings::coterminalSwapZedMatrix(
    lmmCurveState, displacement);

Matrix correlations = exponentialCorrelations(evolution.rateTimes(),
    longTermCorr,
    beta);
boost::shared_ptr<PiecewiseConstantCorrelation> corr(new
    TimeHomogeneousForwardCorrelation(correlations,
    rateTimes));
boost::shared_ptr<MarketModel> lmmMarketModel(new
    FlatVol(marketData.volatilities(),
    corr,
    evolution,
    numberOfFactors,
    lmmCurveState.forwardRates(),
    marketData.displacements()));


SobolBrownianGeneratorFactory generatorFactory(SobolBrownianGenerator::Diagonal);
std::vector<Size> numeraires(nbRates,
    nbRates);
boost::shared_ptr<MarketModelEvolver> evolver(new LogNormalFwdRatePc
    (lmmMarketModel, generatorFactory, numeraires));

boost::shared_ptr<SequenceStatisticsInc> stats =
    simulate(marketData.discountFactors(), evolver, product);
std::vector<Real> results = stats->mean();
std::vector<Real> errors = stats->errorEstimate();


Real estimatedImpliedVol = SwapForwardMappings::swaptionImpliedVolatility(*lmmMarketModel,startIndex,endIndex);

Real swapRate = lmmCurveState.cmSwapRate(startIndex,endIndex-startIndex);
Real swapAnnuity = lmmCurveState.cmSwapAnnuity(startIndex,startIndex,endIndex-startIndex)*marketData.discountFactors()[startIndex];

boost::shared_ptr<PlainVanillaPayoff> payoffDis( new PlainVanillaPayoff(Option::Call, strike+displacement));

Real expectedSwaption = BlackCalculator(payoffDis,
    swapRate+displacement, estimatedImpliedVol *sqrt(rateTimes[startIndex]),
    swapAnnuity).value();

Real error = expectedSwaption - results[0];
Real errorInSds = error/errors[0];
if (fabs(errorInSds) > 3.5 )
    BOOST_ERROR(
    "expected\t" << expectedSwaption <<
    "\tLMM\t" << results[0]
<< "\tstdev:\t" << errors[0] <<
    "\t" <<errorInSds);
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/quotes.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Integer i=0; i<3; i++) {
DerivedQuote<unary_f> derived(h,funcs[i]);
Real x = derived.value(),
     y = funcs[i](me->value());
if (std::fabs(x-y) > 1.0e-10)
    BOOST_FAIL("derived quote yields " << x << "\n"
               << "function result is " << y);
}

for (Integer i=0; i<3; i++) {
CompositeQuote<binary_f> composite(h1,h2,funcs[i]);
Real x = composite.value(),
     y = funcs[i](me1->value(),me2->value());
if (std::fabs(x-y) > 1.0e-10)
    BOOST_FAIL("composite quote yields " << x << "\n"
               << "function result is " << y);
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/digitalcoupon.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i = 0; i< LENGTH(vols); i++) {
    Volatility capletVol = vols[i];
    RelinkableHandle<OptionletVolatilityStructure> vol;
    vol.linkTo(boost::shared_ptr<OptionletVolatilityStructure>(new
        ConstantOptionletVolatility(vars.today,
                                    vars.calendar, Following,
                                    capletVol, Actual360())));
for (Size j=0; j<LENGTH(strikes); j++) {
    Rate strike = strikes[j];
    for (Size k=9; k<10; k++) {
        Date startDate = vars.calendar.advance(vars.settlement,(k+1)*Years);
        Date endDate = vars.calendar.advance(vars.settlement,(k+2)*Years);
        Rate nullstrike = Null<Rate>();
        Date paymentDate = endDate;
        for (Size h=0; h<LENGTH(gearings); h++) {

            Real gearing = gearings[h];
            Rate spread = spreads[h];

            boost::shared_ptr<FloatingRateCoupon> underlying(new
                IborCoupon(paymentDate, vars.nominal,
                           startDate, endDate,
                           vars.fixingDays, vars.index,
                           gearing, spread));
            // Floating Rate Coupon - Call Digital option
            DigitalCoupon digitalCappedCoupon(underlying,
                                strike, Position::Short, false, nullstrike,
                                nullstrike, Position::Short, false, nullstrike,
                                replication);
            boost::shared_ptr<IborCouponPricer> pricer(new
                                                    BlackIborCouponPricer(vol));
            digitalCappedCoupon.setPricer(pricer);

            // Check digital option price vs N(d1) price
            Time accrualPeriod = underlying->accrualPeriod();
            Real discount = vars.termStructure->discount(endDate);
            Date exerciseDate = underlying->fixingDate();
            Rate forward = underlying->rate();
            Rate effFwd = (forward-spread)/gearing;
            Rate effStrike = (strike-spread)/gearing;
            Real stdDev = std::sqrt(vol->blackVariance(exerciseDate, effStrike));
            CumulativeNormalDistribution phi;
            Real d1 = std::log(effFwd/effStrike)/stdDev + 0.5*stdDev;
            Real d2 = d1 - stdDev;
            Real N_d1 = phi(d1);
            Real N_d2 = phi(d2);
            Real nd1Price = (gearing * effFwd * N_d1 + spread * N_d2)
                          * vars.nominal * accrualPeriod * discount;
            Real optionPrice = digitalCappedCoupon.callOptionRate() *
                               vars.nominal * accrualPeriod * discount;
            Real error = std::abs(nd1Price - optionPrice);
            if (error>vars.optionTolerance)
                BOOST_ERROR("\nDigital Call Option:" <<
                    "\nVolatility = " << io::rate(capletVol) <<
                    "\nStrike = " << io::rate(strike) <<
                    "\nExercise = " << k+1 << " years" <<
                    "\nOption price by replication = "  << optionPrice <<
                    "\nOption price by Cox-Rubinstein formula = " << nd1Price <<
                    "\nError " << error);

            // Check digital option price vs N(d1) price using Vanilla Option class
            if (spread==0.0) {
                boost::shared_ptr<Exercise>
                    exercise(new EuropeanExercise(exerciseDate));
                Real discountAtFixing = vars.termStructure->discount(exerciseDate);
                boost::shared_ptr<SimpleQuote>
                    fwd(new SimpleQuote(effFwd*discountAtFixing));
                boost::shared_ptr<SimpleQuote> qRate(new SimpleQuote(0.0));
                boost::shared_ptr<YieldTermStructure>
                    qTS = flatRate(vars.today, qRate, Actual360());
                boost::shared_ptr<SimpleQuote> vol(new SimpleQuote(0.0));
                boost::shared_ptr<BlackVolTermStructure>
                    volTS = flatVol(vars.today, capletVol, Actual360());
                boost::shared_ptr<StrikedTypePayoff>
                    callPayoff(new AssetOrNothingPayoff(Option::Call,effStrike));
                boost::shared_ptr<BlackScholesMertonProcess> stochProcess(new
                    BlackScholesMertonProcess(Handle<Quote>(fwd),
                                      Handle<YieldTermStructure>(qTS),
                                      Handle<YieldTermStructure>(vars.termStructure),
                                      Handle<BlackVolTermStructure>(volTS)));
                boost::shared_ptr<PricingEngine>
                    engine(new AnalyticEuropeanEngine(stochProcess));
                VanillaOption callOpt(callPayoff, exercise);
                callOpt.setPricingEngine(engine);
                Real callVO = vars.nominal * gearing
                                       * accrualPeriod * callOpt.NPV()
                                       * discount / discountAtFixing
                                       * forward / effFwd;
                error = std::abs(nd1Price - callVO);
                if (error>vars.blackTolerance)
                    BOOST_ERROR("\nDigital Call Option:" <<
                    "\nVolatility = " << io::rate(capletVol) <<
                    "\nStrike = " << io::rate(strike) <<
                    "\nExercise = " << k+1 << " years" <<
                    "\nOption price by Black asset-ot-nothing payoff = " << callVO <<
                    "\nOption price by Cox-Rubinstein = " << nd1Price <<
                    "\nError " << error );
            }

            // Floating Rate Coupon + Put Digital option
            DigitalCoupon digitalFlooredCoupon(underlying,
                                nullstrike, Position::Long, false, nullstrike,
                                strike, Position::Long, false, nullstrike,
                                replication);
            digitalFlooredCoupon.setPricer(pricer);

            // Check digital option price vs N(d1) price
            N_d1 = phi(-d1);
            N_d2 = phi(-d2);
            nd1Price = (gearing * effFwd * N_d1 + spread * N_d2)
                     * vars.nominal * accrualPeriod * discount;
            optionPrice = digitalFlooredCoupon.putOptionRate() *
                          vars.nominal * accrualPeriod * discount;
            error = std::abs(nd1Price - optionPrice);
            if (error>vars.optionTolerance)
                BOOST_ERROR("\nDigital Put Option:" <<
                            "\nVolatility = " << io::rate(capletVol) <<
                            "\nStrike = " << io::rate(strike) <<
                            "\nExercise = " << k+1 << " years" <<
                            "\nOption price by replication = "  << optionPrice <<
                            "\nOption price by Cox-Rubinstein = " << nd1Price <<
                            "\nError " << error );

            // Check digital option price vs N(d1) price using Vanilla Option class
            if (spread==0.0) {
                boost::shared_ptr<Exercise>
                    exercise(new EuropeanExercise(exerciseDate));
                Real discountAtFixing = vars.termStructure->discount(exerciseDate);
                boost::shared_ptr<SimpleQuote>
                    fwd(new SimpleQuote(effFwd*discountAtFixing));
                boost::shared_ptr<SimpleQuote> qRate(new SimpleQuote(0.0));
                boost::shared_ptr<YieldTermStructure>
                    qTS = flatRate(vars.today, qRate, Actual360());
                boost::shared_ptr<SimpleQuote> vol(new SimpleQuote(0.0));
                boost::shared_ptr<BlackVolTermStructure>
                    volTS = flatVol(vars.today, capletVol, Actual360());
                boost::shared_ptr<BlackScholesMertonProcess> stochProcess(new
                    BlackScholesMertonProcess(Handle<Quote>(fwd),
                                      Handle<YieldTermStructure>(qTS),
                                      Handle<YieldTermStructure>(vars.termStructure),
                                      Handle<BlackVolTermStructure>(volTS)));
                boost::shared_ptr<StrikedTypePayoff>
                    putPayoff(new AssetOrNothingPayoff(Option::Put, effStrike));
                boost::shared_ptr<PricingEngine> engine(new AnalyticEuropeanEngine(stochProcess));
                VanillaOption putOpt(putPayoff, exercise);
                putOpt.setPricingEngine(engine);
                Real putVO  = vars.nominal * gearing
                                       * accrualPeriod * putOpt.NPV()
                                       * discount / discountAtFixing
                                       * forward / effFwd;
                error = std::abs(nd1Price - putVO);
                if (error>vars.blackTolerance)
                    BOOST_ERROR("\nDigital Put Option:" <<
                    "\nVolatility = " << io::rate(capletVol) <<
                    "\nStrike = " << io::rate(strike) <<
                    "\nExercise = " << k+1 << " years" <<
                    "\nOption price by Black asset-ot-nothing payoff = " << putVO <<
                    "\nOption price by Cox-Rubinstein = " << nd1Price <<
                    "\nError " << error );
            }
        }
    }
}
}

for (Size k = 0; k<10; k++) {   // Loop on start and end dates
Date startDate = vars.calendar.advance(vars.settlement,(k+1)*Years);
Date endDate = vars.calendar.advance(vars.settlement,(k+2)*Years);
Rate nullstrike = Null<Rate>();
Date paymentDate = endDate;

boost::shared_ptr<FloatingRateCoupon> underlying(new
    IborCoupon(paymentDate, vars.nominal,
               startDate, endDate,
               vars.fixingDays, vars.index,
               gearing, spread));

// Floating Rate Coupon - Deep-in-the-money Call Digital option
Rate strike = 0.001;
DigitalCoupon digitalCappedCoupon(underlying,
                                  strike, Position::Short, false, nullstrike,
                                  nullstrike, Position::Short, false, nullstrike,
                                  replication);
boost::shared_ptr<IborCouponPricer> pricer(new
    BlackIborCouponPricer(volatility));
digitalCappedCoupon.setPricer(pricer);

// Check price vs its target price
Time accrualPeriod = underlying->accrualPeriod();
Real discount = vars.termStructure->discount(endDate);

Real targetOptionPrice = underlying->price(vars.termStructure);
Real targetPrice = 0.0;
Real digitalPrice = digitalCappedCoupon.price(vars.termStructure);
Real error = std::fabs(targetPrice - digitalPrice);
Real tolerance = 1e-08;
if (error>tolerance)
    BOOST_ERROR("\nFloating Coupon - Digital Call Option:" <<
                "\nVolatility = " << io::rate(capletVolatility) <<
                "\nStrike = " << io::rate(strike) <<
                "\nExercise = " << k+1 << " years" <<
                "\nCoupon Price = "  << digitalPrice <<
                "\nTarget price = " << targetPrice <<
                "\nError = " << error );

// Check digital option price
Real replicationOptionPrice = digitalCappedCoupon.callOptionRate() *
                              vars.nominal * accrualPeriod * discount;
error = std::abs(targetOptionPrice - replicationOptionPrice);
Real optionTolerance = 1e-08;
if (error>optionTolerance)
    BOOST_ERROR("\nDigital Call Option:" <<
                "\nVolatility = " << io::rate(capletVolatility) <<
                "\nStrike = " << io::rate(strike) <<
                "\nExercise = " << k+1 << " years" <<
                "\nPrice by replication = " << replicationOptionPrice <<
                "\nTarget price = " << targetOptionPrice <<
                "\nError = " << error);

// Floating Rate Coupon + Deep-in-the-money Put Digital option
strike = 0.99;
DigitalCoupon digitalFlooredCoupon(underlying,
                                   nullstrike, Position::Long, false, nullstrike,
                                   strike, Position::Long, false, nullstrike,
                                   replication);
digitalFlooredCoupon.setPricer(pricer);

// Check price vs its target price
targetOptionPrice = underlying->price(vars.termStructure);
targetPrice = underlying->price(vars.termStructure) + targetOptionPrice ;
digitalPrice = digitalFlooredCoupon.price(vars.termStructure);
error = std::fabs(targetPrice - digitalPrice);
tolerance = 2.5e-06;
if (error>tolerance)
    BOOST_ERROR("\nFloating Coupon + Digital Put Option:" <<
                "\nVolatility = " << io::rate(capletVolatility) <<
                "\nStrike = " << io::rate(strike) <<
                "\nExercise = " << k+1 << " years" <<
                "\nDigital coupon price = "  << digitalPrice <<
                "\nTarget price = " << targetPrice <<
                "\nError " << error);

// Check digital option
replicationOptionPrice = digitalFlooredCoupon.putOptionRate() *
                         vars.nominal * accrualPeriod * discount;
error = std::abs(targetOptionPrice - replicationOptionPrice);
optionTolerance = 2.5e-06;
if (error>optionTolerance)
    BOOST_ERROR("\nDigital Put Option:" <<
                "\nVolatility = " << io::rate(capletVolatility) <<
                "\nStrike = " << io::rate(strike) <<
                "\nExercise = " << k+1 << " years" <<
                "\nPrice by replication = " << replicationOptionPrice <<
                "\nTarget price = " << targetOptionPrice <<
                "\nError " << error);
}

for (Size k = 0; k<10; k++) { // loop on start and end dates
Date startDate = vars.calendar.advance(vars.settlement,(k+1)*Years);
Date endDate = vars.calendar.advance(vars.settlement,(k+2)*Years);
Rate nullstrike = Null<Rate>();
Date paymentDate = endDate;

boost::shared_ptr<FloatingRateCoupon> underlying(new
    IborCoupon(paymentDate, vars.nominal,
               startDate, endDate,
               vars.fixingDays, vars.index,
               gearing, spread));

// Floating Rate Coupon - Deep-out-of-the-money Call Digital option
Rate strike = 0.99;
DigitalCoupon digitalCappedCoupon(underlying,
                                  strike, Position::Short, false, nullstrike,
                                  nullstrike, Position::Long, false, nullstrike,
                                  replication/*Replication::Central, gap*/);
boost::shared_ptr<IborCouponPricer> pricer(new BlackIborCouponPricer(volatility));
digitalCappedCoupon.setPricer(pricer);

// Check price vs its target
Time accrualPeriod = underlying->accrualPeriod();
Real discount = vars.termStructure->discount(endDate);

Real targetPrice = underlying->price(vars.termStructure);
Real digitalPrice = digitalCappedCoupon.price(vars.termStructure);
Real error = std::fabs(targetPrice - digitalPrice);
Real tolerance = 1e-10;
if (error>tolerance)
    BOOST_ERROR("\nFloating Coupon - Digital Call Option :" <<
                "\nVolatility = " << io::rate(capletVolatility) <<
                "\nStrike = " << io::rate(strike) <<
                "\nExercise = " << k+1 << " years" <<
                "\nCoupon price = "  << digitalPrice <<
                "\nTarget price = " << targetPrice <<
                "\nError = " << error );

// Check digital option price
Real targetOptionPrice = 0.;
Real replicationOptionPrice = digitalCappedCoupon.callOptionRate() *
                              vars.nominal * accrualPeriod * discount;
error = std::abs(targetOptionPrice - replicationOptionPrice);
Real optionTolerance = 1e-08;
if (error>optionTolerance)
    BOOST_ERROR("\nDigital Call Option:" <<
                "\nVolatility = " << io::rate(capletVolatility) <<
                "\nStrike = " << io::rate(strike) <<
                "\nExercise = " << k+1 << " years" <<
                "\nPrice by replication = "  << replicationOptionPrice <<
                "\nTarget price = " << targetOptionPrice <<
                "\nError = " << error );

// Floating Rate Coupon - Deep-out-of-the-money Put Digital option
strike = 0.01;
DigitalCoupon digitalFlooredCoupon(underlying,
                                   nullstrike, Position::Long, false, nullstrike,
                                   strike, Position::Long, false, nullstrike,
                                   replication);
digitalFlooredCoupon.setPricer(pricer);

// Check price vs its target
targetPrice = underlying->price(vars.termStructure);
digitalPrice = digitalFlooredCoupon.price(vars.termStructure);
tolerance = 1e-08;
error = std::fabs(targetPrice - digitalPrice);
if (error>tolerance)
    BOOST_ERROR("\nFloating Coupon + Digital Put Coupon:" <<
                "\nVolatility = " << io::rate(capletVolatility) <<
                "\nStrike = " << io::rate(strike) <<
                "\nExercise = " << k+1 << " years" <<
                "\nCoupon price = "  << digitalPrice <<
                "\nTarget price = " << targetPrice <<
                "\nError = " << error );

// Check digital option
targetOptionPrice = 0.0;
replicationOptionPrice = digitalFlooredCoupon.putOptionRate() *
                         vars.nominal * accrualPeriod * discount;
error = std::abs(targetOptionPrice - replicationOptionPrice);
if (error>optionTolerance)
    BOOST_ERROR("\nDigital Put Coupon:" <<
                "\nVolatility = " << io::rate(capletVolatility) <<
                "\nStrike = " << io::rate(strike) <<
                "\nExercise = " << k+1 << " years" <<
                "\nPrice by replication = " << replicationOptionPrice <<
                "\nTarget price = " << targetOptionPrice <<
                "\nError = " << error );
}

for (Size i = 0; i< LENGTH(vols); i++) {
    Volatility capletVol = vols[i];
    RelinkableHandle<OptionletVolatilityStructure> vol;
    vol.linkTo(boost::shared_ptr<OptionletVolatilityStructure>(new
        ConstantOptionletVolatility(vars.today,
                                    vars.calendar, Following,
                                    capletVol, Actual360())));
for (Size j = 0; j< LENGTH(strikes); j++) {
    Rate strike = strikes[j];
    for (Size k = 0; k<10; k++) {
        Date startDate = vars.calendar.advance(vars.settlement,(k+1)*Years);
        Date endDate = vars.calendar.advance(vars.settlement,(k+2)*Years);
        Rate nullstrike = Null<Rate>();
        Rate cashRate = 0.01;

        Date paymentDate = endDate;
        boost::shared_ptr<FloatingRateCoupon> underlying(new
            IborCoupon(paymentDate, vars.nominal,
                       startDate, endDate,
                       vars.fixingDays, vars.index,
                       gearing, spread));
        // Floating Rate Coupon - Call Digital option
        DigitalCoupon digitalCappedCoupon(underlying,
                                  strike, Position::Short, false, cashRate,
                                  nullstrike, Position::Short, false, nullstrike,
                                  replication);
        boost::shared_ptr<IborCouponPricer> pricer(new BlackIborCouponPricer(vol));
        digitalCappedCoupon.setPricer(pricer);

        // Check digital option price vs N(d2) price
        Date exerciseDate = underlying->fixingDate();
        Rate forward = underlying->rate();
        Rate effFwd = (forward-spread)/gearing;
        Rate effStrike = (strike-spread)/gearing;
        Time accrualPeriod = underlying->accrualPeriod();
        Real discount = vars.termStructure->discount(endDate);
        Real stdDev = std::sqrt(vol->blackVariance(exerciseDate, effStrike));
        Real ITM = blackFormulaCashItmProbability(Option::Call, effStrike,
                                                  effFwd, stdDev);
        Real nd2Price = ITM * vars.nominal * accrualPeriod * discount * cashRate;
        Real optionPrice = digitalCappedCoupon.callOptionRate() *
                           vars.nominal * accrualPeriod * discount;
        Real error = std::abs(nd2Price - optionPrice);
        if (error>vars.optionTolerance)
            BOOST_ERROR("\nDigital Call Option:" <<
                        "\nVolatility = " << io::rate(capletVol) <<
                        "\nStrike = " << io::rate(strike) <<
                        "\nExercise = " << k+1 << " years" <<
                        "\nPrice by replication = " << optionPrice <<
                        "\nPrice by Reiner-Rubinstein = " << nd2Price <<
                        "\nError = " << error );

        // Check digital option price vs N(d2) price using Vanilla Option class
        boost::shared_ptr<Exercise> exercise(new EuropeanExercise(exerciseDate));
        Real discountAtFixing = vars.termStructure->discount(exerciseDate);
        boost::shared_ptr<SimpleQuote> fwd(new SimpleQuote(effFwd*discountAtFixing));
        boost::shared_ptr<SimpleQuote> qRate(new SimpleQuote(0.0));
        boost::shared_ptr<YieldTermStructure> qTS = flatRate(vars.today, qRate, Actual360());
        boost::shared_ptr<SimpleQuote> vol(new SimpleQuote(0.0));
        boost::shared_ptr<BlackVolTermStructure> volTS = flatVol(vars.today, capletVol,
                                                                 Actual360());
        boost::shared_ptr<StrikedTypePayoff> callPayoff(new CashOrNothingPayoff(
                                                Option::Call, effStrike, cashRate));
        boost::shared_ptr<BlackScholesMertonProcess> stochProcess(new
        BlackScholesMertonProcess(Handle<Quote>(fwd),
                                  Handle<YieldTermStructure>(qTS),
                                  Handle<YieldTermStructure>(vars.termStructure),
                                  Handle<BlackVolTermStructure>(volTS)));
        boost::shared_ptr<PricingEngine> engine(new AnalyticEuropeanEngine(stochProcess));
        VanillaOption callOpt(callPayoff, exercise);
        callOpt.setPricingEngine(engine);
        Real callVO = vars.nominal * accrualPeriod * callOpt.NPV()
                               * discount / discountAtFixing;
        error = std::abs(nd2Price - callVO);
        if (error>vars.blackTolerance)
            BOOST_ERROR("\nDigital Call Option:" <<
                "\nVolatility = " << io::rate(capletVol) <<
                "\nStrike = " << io::rate(strike) <<
                "\nExercise = " << k+1 << " years" <<
                "\nOption price by Black asset-ot-nothing payoff = " << callVO <<
                "\nOption price by Reiner-Rubinstein = " << nd2Price <<
                "\nError " << error );

        // Floating Rate Coupon + Put Digital option
        DigitalCoupon digitalFlooredCoupon(underlying,
                                  nullstrike, Position::Long, false, nullstrike,
                                  strike, Position::Long, false, cashRate,
                                  replication);
        digitalFlooredCoupon.setPricer(pricer);


        // Check digital option price vs N(d2) price
        ITM = blackFormulaCashItmProbability(Option::Put,
                                             effStrike,
                                             effFwd,
                                             stdDev);
        nd2Price = ITM * vars.nominal * accrualPeriod * discount * cashRate;
        optionPrice = digitalFlooredCoupon.putOptionRate() *
                      vars.nominal * accrualPeriod * discount;
        error = std::abs(nd2Price - optionPrice);
        if (error>vars.optionTolerance)
            BOOST_ERROR("\nPut Digital Option:" <<
                        "\nVolatility = " << io::rate(capletVol) <<
                        "\nStrike = " << io::rate(strike) <<
                        "\nExercise = " << k+1 << " years" <<
                        "\nPrice by replication = "  << optionPrice <<
                        "\nPrice by Reiner-Rubinstein = " << nd2Price <<
                        "\nError = " << error );

        // Check digital option price vs N(d2) price using Vanilla Option class
        boost::shared_ptr<StrikedTypePayoff> putPayoff(new
            CashOrNothingPayoff(Option::Put, effStrike, cashRate));
        VanillaOption putOpt(putPayoff, exercise);
        putOpt.setPricingEngine(engine);
        Real putVO  = vars.nominal * accrualPeriod * putOpt.NPV()
                               * discount / discountAtFixing;
        error = std::abs(nd2Price - putVO);
        if (error>vars.blackTolerance)
            BOOST_ERROR("\nDigital Put Option:" <<
                "\nVolatility = " << io::rate(capletVol) <<
                "\nStrike = " << io::rate(strike) <<
                "\nExercise = " << k+1 << " years" <<
                "\nOption price by Black asset-ot-nothing payoff = "  << putVO <<
                "\nOption price by Reiner-Rubinstein = " << nd2Price <<
                "\nError " << error );
    }
}
}

for (Size k = 0; k<10; k++) {   // Loop on start and end dates
Date startDate = vars.calendar.advance(vars.settlement,(k+1)*Years);
Date endDate = vars.calendar.advance(vars.settlement,(k+2)*Years);
Rate nullstrike = Null<Rate>();
Rate cashRate = 0.01;
Real gap = 1e-4;
boost::shared_ptr<DigitalReplication> replication(new
    DigitalReplication(Replication::Central, gap));
Date paymentDate = endDate;

boost::shared_ptr<FloatingRateCoupon> underlying(new
    IborCoupon(paymentDate, vars.nominal,
               startDate, endDate,
               vars.fixingDays, vars.index,
               gearing, spread));
// Floating Rate Coupon - Deep-in-the-money Call Digital option
Rate strike = 0.001;
DigitalCoupon digitalCappedCoupon(underlying,
                                  strike, Position::Short, false, cashRate,
                                  nullstrike, Position::Short, false, nullstrike,
                                  replication);
boost::shared_ptr<IborCouponPricer> pricer(new
    BlackIborCouponPricer(volatility));
digitalCappedCoupon.setPricer(pricer);

// Check price vs its target
Time accrualPeriod = underlying->accrualPeriod();
Real discount = vars.termStructure->discount(endDate);

Real targetOptionPrice = cashRate * vars.nominal * accrualPeriod * discount;
Real targetPrice = underlying->price(vars.termStructure) - targetOptionPrice;
Real digitalPrice = digitalCappedCoupon.price(vars.termStructure);

Real error = std::fabs(targetPrice - digitalPrice);
Real tolerance = 1e-07;
if (error>tolerance)
    BOOST_ERROR("\nFloating Coupon - Digital Call Coupon:" <<
                "\nVolatility = " << io::rate(capletVolatility) <<
                "\nStrike = " << io::rate(strike) <<
                "\nExercise = " << k+1 << " years" <<
                "\nCoupon price = "  << digitalPrice <<
                "\nTarget price = " << targetPrice <<
                "\nError " << error );

// Check digital option price
Real replicationOptionPrice = digitalCappedCoupon.callOptionRate() *
                              vars.nominal * accrualPeriod * discount;
error = std::abs(targetOptionPrice - replicationOptionPrice);
Real optionTolerance = 1e-07;
if (error>optionTolerance)
    BOOST_ERROR("\nDigital Call Option:" <<
                "\nVolatility = " << io::rate(capletVolatility) <<
                "\nStrike = " << io::rate(strike) <<
                "\nExercise = " << k+1 << " years" <<
                "\nPrice by replication = " << replicationOptionPrice <<
                "\nTarget price = " << targetOptionPrice <<
                "\nError = " << error);

// Floating Rate Coupon + Deep-in-the-money Put Digital option
strike = 0.99;
DigitalCoupon digitalFlooredCoupon(underlying,
                                   nullstrike, Position::Long, false, nullstrike,
                                   strike, Position::Long, false, cashRate,
                                   replication);
digitalFlooredCoupon.setPricer(pricer);

// Check price vs its target
targetPrice = underlying->price(vars.termStructure) + targetOptionPrice;
digitalPrice = digitalFlooredCoupon.price(vars.termStructure);
error = std::fabs(targetPrice - digitalPrice);
if (error>tolerance)
    BOOST_ERROR("\nFloating Coupon + Digital Put Option:" <<
                "\nVolatility = " << io::rate(capletVolatility) <<
                "\nStrike = " << io::rate(strike) <<
                "\nExercise = " << k+1 << " years" <<
                "\nCoupon price = "  << digitalPrice <<
                "\nTarget price  = " << targetPrice <<
                "\nError = " << error );

// Check digital option
replicationOptionPrice = digitalFlooredCoupon.putOptionRate() *
                         vars.nominal * accrualPeriod * discount;
error = std::abs(targetOptionPrice - replicationOptionPrice);
if (error>optionTolerance)
    BOOST_ERROR("\nDigital Put Coupon:" <<
                "\nVolatility = " << io::rate(capletVolatility) <<
                "\nStrike = " << io::rate(strike) <<
                "\nExercise = " << k+1 << " years" <<
                "\nPrice by replication = " << replicationOptionPrice <<
                "\nTarget price = " << targetOptionPrice <<
                "\nError = " << error );
}

for (Size k = 0; k<10; k++) { // loop on start and end dates
Date startDate = vars.calendar.advance(vars.settlement,(k+1)*Years);
Date endDate = vars.calendar.advance(vars.settlement,(k+2)*Years);
Rate nullstrike = Null<Rate>();
Rate cashRate = 0.01;
Real gap = 1e-4;
boost::shared_ptr<DigitalReplication> replication(new
    DigitalReplication(Replication::Central, gap));
Date paymentDate = endDate;

boost::shared_ptr<FloatingRateCoupon> underlying(new
    IborCoupon(paymentDate, vars.nominal,
               startDate, endDate,
               vars.fixingDays, vars.index,
               gearing, spread));
// Deep out-of-the-money Capped Digital Coupon
Rate strike = 0.99;
DigitalCoupon digitalCappedCoupon(underlying,
                                  strike, Position::Short, false, cashRate,
                                  nullstrike, Position::Short, false, nullstrike,
                                  replication);

boost::shared_ptr<IborCouponPricer> pricer(new BlackIborCouponPricer(volatility));
digitalCappedCoupon.setPricer(pricer);

// Check price vs its target
Time accrualPeriod = underlying->accrualPeriod();
Real discount = vars.termStructure->discount(endDate);

Real targetPrice = underlying->price(vars.termStructure);
Real digitalPrice = digitalCappedCoupon.price(vars.termStructure);
Real error = std::fabs(targetPrice - digitalPrice);
Real tolerance = 1e-10;
if (error>tolerance)
    BOOST_ERROR("\nFloating Coupon + Digital Call Option:" <<
                "\nVolatility = " << io::rate(capletVolatility) <<
                "\nStrike = " << io::rate(strike) <<
                "\nExercise = " << k+1 << " years" <<
                "\nCoupon price = "  << digitalPrice <<
                "\nTarget price  = " << targetPrice <<
                "\nError = " << error );

// Check digital option price
Real targetOptionPrice = 0.;
Real replicationOptionPrice = digitalCappedCoupon.callOptionRate() *
                              vars.nominal * accrualPeriod * discount;
error = std::abs(targetOptionPrice - replicationOptionPrice);
Real optionTolerance = 1e-10;
if (error>optionTolerance)
    BOOST_ERROR("\nDigital Call Option:" <<
                "\nVolatility = " << io::rate(capletVolatility) <<
                "\nStrike = " << io::rate(strike) <<
                "\nExercise = " << k+1 << " years" <<
                "\nPrice by replication = "  << replicationOptionPrice <<
                "\nTarget price = " << targetOptionPrice <<
                "\nError = " << error );

// Deep out-of-the-money Floored Digital Coupon
strike = 0.01;
DigitalCoupon digitalFlooredCoupon(underlying,
                                   nullstrike, Position::Long, false, nullstrike,
                                   strike, Position::Long, false, cashRate,
                                   replication);
digitalFlooredCoupon.setPricer(pricer);

// Check price vs its target
targetPrice = underlying->price(vars.termStructure);
digitalPrice = digitalFlooredCoupon.price(vars.termStructure);
tolerance = 1e-09;
error = std::fabs(targetPrice - digitalPrice);
if (error>tolerance)
    BOOST_ERROR("\nDigital Floored Coupon:" <<
                "\nVolatility = " << io::rate(capletVolatility) <<
                "\nStrike = " << io::rate(strike) <<
                "\nExercise = " << k+1 << " years" <<
                "\nCoupon price = "  << digitalPrice <<
                "\nTarget price  = " << targetPrice <<
                "\nError = " << error );

// Check digital option
targetOptionPrice = 0.0;
replicationOptionPrice = digitalFlooredCoupon.putOptionRate() *
                         vars.nominal * accrualPeriod * discount;
error = std::abs(targetOptionPrice - replicationOptionPrice);
if (error>optionTolerance)
    BOOST_ERROR("\nDigital Put Option:" <<
                "\nVolatility = " << io::rate(capletVolatility) <<
                "\nStrike = " << io::rate(strike) <<
                "\nExercise = " << k+1 << " years" <<
                "\nPrice by replication " << replicationOptionPrice <<
                "\nTarget price " << targetOptionPrice <<
                "\nError " << error );
}

for (Size i = 0; i< LENGTH(vols); i++) {
    Volatility capletVolatility = vols[i];
    RelinkableHandle<OptionletVolatilityStructure> volatility;
    volatility.linkTo(boost::shared_ptr<OptionletVolatilityStructure>(new
        ConstantOptionletVolatility(vars.today, vars.calendar, Following,
                                    capletVolatility, Actual360())));
for (Size j = 0; j< LENGTH(strikes); j++) {
    Rate strike = strikes[j];
    for (Size k = 0; k<10; k++) {
        Date startDate = vars.calendar.advance(vars.settlement,(k+1)*Years);
        Date endDate = vars.calendar.advance(vars.settlement,(k+2)*Years);
        Rate nullstrike = Null<Rate>();

        Date paymentDate = endDate;

        boost::shared_ptr<FloatingRateCoupon> underlying(new
            IborCoupon(paymentDate, vars.nominal,
                       startDate, endDate,
                       vars.fixingDays, vars.index,
                       gearing, spread));
        // Cash-or-Nothing
        Rate cashRate = 0.01;
        // Floating Rate Coupon + Call Digital option
        DigitalCoupon cash_digitalCallCoupon(underlying,
                                  strike, Position::Long, false, cashRate,
                                  nullstrike, Position::Long, false, nullstrike,
                                  replication);
        boost::shared_ptr<IborCouponPricer> pricer(new
            BlackIborCouponPricer(volatility));
        cash_digitalCallCoupon.setPricer(pricer);
        // Floating Rate Coupon - Put Digital option
        DigitalCoupon cash_digitalPutCoupon(underlying,
                                  nullstrike, Position::Long, false, nullstrike,
                                  strike, Position::Short, false, cashRate,
                                  replication);

        cash_digitalPutCoupon.setPricer(pricer);
        Real digitalPrice = cash_digitalCallCoupon.price(vars.termStructure) -
                            cash_digitalPutCoupon.price(vars.termStructure);
        // Target price
        Time accrualPeriod = underlying->accrualPeriod();
        Real discount = vars.termStructure->discount(endDate);
        Real targetPrice = vars.nominal * accrualPeriod *  discount * cashRate;

        Real error = std::fabs(targetPrice - digitalPrice);
        Real tolerance = 1.e-08;
        if (error>tolerance)
            BOOST_ERROR("\nCash-or-nothing:" <<
                        "\nVolatility = " << io::rate(capletVolatility) <<
                        "\nStrike = " << io::rate(strike) <<
                        "\nExercise = " << k+1 << " years" <<
                        "\nPrice = "  << digitalPrice <<
                        "\nTarget Price  = " << targetPrice <<
                        "\nError = " << error );

        // Asset-or-Nothing
        // Floating Rate Coupon + Call Digital option
        DigitalCoupon asset_digitalCallCoupon(underlying,
                                  strike, Position::Long, false, nullstrike,
                                  nullstrike, Position::Long, false, nullstrike,
                                  replication);
        asset_digitalCallCoupon.setPricer(pricer);
        // Floating Rate Coupon - Put Digital option
        DigitalCoupon asset_digitalPutCoupon(underlying,
                                  nullstrike, Position::Long, false, nullstrike,
                                  strike, Position::Short, false, nullstrike,
                                  replication);
        asset_digitalPutCoupon.setPricer(pricer);
        digitalPrice = asset_digitalCallCoupon.price(vars.termStructure) -
                       asset_digitalPutCoupon.price(vars.termStructure);
        // Target price
        targetPrice = vars.nominal *  accrualPeriod *  discount * underlying->rate();
        error = std::fabs(targetPrice - digitalPrice);
        tolerance = 1.e-07;
        if (error>tolerance)
            BOOST_ERROR("\nAsset-or-nothing:" <<
                        "\nVolatility = " << io::rate(capletVolatility) <<
                        "\nStrike = " << io::rate(strike) <<
                        "\nExercise = " << k+1 << " years" <<
                        "\nPrice = "  << digitalPrice <<
                        "\nTarget Price  = " << targetPrice <<
                        "\nError = " << error );
    }
}
}

for (Size i = 0; i< LENGTH(vols); i++) {
Volatility capletVolatility = vols[i];
RelinkableHandle<OptionletVolatilityStructure> volatility;
volatility.linkTo(boost::shared_ptr<OptionletVolatilityStructure>(new
ConstantOptionletVolatility(vars.today, vars.calendar, Following,
                            capletVolatility, Actual360())));
for (Size j = 0; j< LENGTH(strikes); j++) {
    Rate strike = strikes[j];
    for (Size k = 0; k<10; k++) {
        Date startDate = vars.calendar.advance(vars.settlement,(k+1)*Years);
        Date endDate = vars.calendar.advance(vars.settlement,(k+2)*Years);
        Rate nullstrike = Null<Rate>();

        Date paymentDate = endDate;

        boost::shared_ptr<FloatingRateCoupon> underlying(new
            IborCoupon(paymentDate, vars.nominal,
                       startDate, endDate,
                       vars.fixingDays, vars.index,
                       gearing, spread));
        // Cash-or-Nothing
        Rate cashRate = 0.005;
        // Floating Rate Coupon + Call Digital option
        DigitalCoupon sub_cash_longDigitalCallCoupon(underlying,
                                  strike, Position::Long, false, cashRate,
                                  nullstrike, Position::Long, false, nullstrike,
                                  subReplication);
        DigitalCoupon central_cash_longDigitalCallCoupon(underlying,
                                  strike, Position::Long, false, cashRate,
                                  nullstrike, Position::Long, false, nullstrike,
                                  centralReplication);
        DigitalCoupon over_cash_longDigitalCallCoupon(underlying,
                                  strike, Position::Long, false, cashRate,
                                  nullstrike, Position::Long, false, nullstrike,
                                  superReplication);
        boost::shared_ptr<IborCouponPricer> pricer(new
            BlackIborCouponPricer(volatility));
        sub_cash_longDigitalCallCoupon.setPricer(pricer);
        central_cash_longDigitalCallCoupon.setPricer(pricer);
        over_cash_longDigitalCallCoupon.setPricer(pricer);
        Real sub_digitalPrice = sub_cash_longDigitalCallCoupon.price(vars.termStructure);
        Real central_digitalPrice = central_cash_longDigitalCallCoupon.price(vars.termStructure);
        Real over_digitalPrice = over_cash_longDigitalCallCoupon.price(vars.termStructure);
        Real tolerance = 1.e-09;
        if ( ( (sub_digitalPrice > central_digitalPrice) &&
                std::abs(central_digitalPrice - sub_digitalPrice)>tolerance ) ||
             ( (central_digitalPrice>over_digitalPrice)  &&
                std::abs(central_digitalPrice - over_digitalPrice)>tolerance ) )  {
            BOOST_ERROR("\nCash-or-nothing: Floating Rate Coupon + Call Digital option" <<
                        "\nVolatility = " << io::rate(capletVolatility) <<
                        "\nStrike = " << io::rate(strike) <<
                        "\nExercise = " << k+1 << " years" <<
                        std::setprecision(20) <<
                        "\nSub-Replication Price = "  << sub_digitalPrice <<
                        "\nCentral-Replication Price = "  << central_digitalPrice <<
                        "\nOver-Replication Price = "  << over_digitalPrice);
        }

        // Floating Rate Coupon - Call Digital option
        DigitalCoupon sub_cash_shortDigitalCallCoupon(underlying,
                                  strike, Position::Short, false, cashRate,
                                  nullstrike, Position::Long, false, nullstrike,
                                  subReplication);
        DigitalCoupon central_cash_shortDigitalCallCoupon(underlying,
                                  strike, Position::Short, false, cashRate,
                                  nullstrike, Position::Long, false, nullstrike,
                                  centralReplication);
        DigitalCoupon over_cash_shortDigitalCallCoupon(underlying,
                                  strike, Position::Short, false, cashRate,
                                  nullstrike, Position::Long, false, nullstrike,
                                  superReplication);
        sub_cash_shortDigitalCallCoupon.setPricer(pricer);
        central_cash_shortDigitalCallCoupon.setPricer(pricer);
        over_cash_shortDigitalCallCoupon.setPricer(pricer);
        sub_digitalPrice = sub_cash_shortDigitalCallCoupon.price(vars.termStructure);
        central_digitalPrice = central_cash_shortDigitalCallCoupon.price(vars.termStructure);
        over_digitalPrice = over_cash_shortDigitalCallCoupon.price(vars.termStructure);
        if ( ( (sub_digitalPrice > central_digitalPrice) &&
                std::abs(central_digitalPrice - sub_digitalPrice)>tolerance ) ||
             ( (central_digitalPrice>over_digitalPrice)  &&
                std::abs(central_digitalPrice - over_digitalPrice)>tolerance ) )
            BOOST_ERROR("\nCash-or-nothing: Floating Rate Coupon - Call Digital option" <<
                        "\nVolatility = " << io::rate(capletVolatility) <<
                        "\nStrike = " << io::rate(strike) <<
                        "\nExercise = " << k+1 << " years" <<
                        std::setprecision(20) <<
                        "\nSub-Replication Price = "  << sub_digitalPrice <<
                        "\nCentral-Replication Price = "  << central_digitalPrice <<
                        "\nOver-Replication Price = "  << over_digitalPrice);
        // Floating Rate Coupon + Put Digital option
        DigitalCoupon sub_cash_longDigitalPutCoupon(underlying,
                                  nullstrike, Position::Long, false, nullstrike,
                                  strike, Position::Long, false, cashRate,
                                  subReplication);
        DigitalCoupon central_cash_longDigitalPutCoupon(underlying,
                                  nullstrike, Position::Long, false, nullstrike,
                                  strike, Position::Long, false, cashRate,
                                  centralReplication);
        DigitalCoupon over_cash_longDigitalPutCoupon(underlying,
                                  nullstrike, Position::Long, false, nullstrike,
                                  strike, Position::Long, false, cashRate,
                                  superReplication);
        sub_cash_longDigitalPutCoupon.setPricer(pricer);
        central_cash_longDigitalPutCoupon.setPricer(pricer);
        over_cash_longDigitalPutCoupon.setPricer(pricer);
        sub_digitalPrice = sub_cash_longDigitalPutCoupon.price(vars.termStructure);
        central_digitalPrice = central_cash_longDigitalPutCoupon.price(vars.termStructure);
        over_digitalPrice = over_cash_longDigitalPutCoupon.price(vars.termStructure);
        if ( ( (sub_digitalPrice > central_digitalPrice) &&
                std::abs(central_digitalPrice - sub_digitalPrice)>tolerance ) ||
             ( (central_digitalPrice>over_digitalPrice)  &&
                std::abs(central_digitalPrice - over_digitalPrice)>tolerance ) )
            BOOST_ERROR("\nCash-or-nothing: Floating Rate Coupon + Put Digital option" <<
                        "\nVolatility = " << io::rate(capletVolatility) <<
                        "\nStrike = " << io::rate(strike) <<
                        "\nExercise = " << k+1 << " years" <<
                        std::setprecision(20) <<
                        "\nSub-Replication Price = "  << sub_digitalPrice <<
                        "\nCentral-Replication Price = "  << central_digitalPrice <<
                        "\nOver-Replication Price = "  << over_digitalPrice);

        // Floating Rate Coupon - Put Digital option
        DigitalCoupon sub_cash_shortDigitalPutCoupon(underlying,
                                  nullstrike, Position::Long, false, nullstrike,
                                  strike, Position::Short, false, cashRate,
                                  subReplication);
        DigitalCoupon central_cash_shortDigitalPutCoupon(underlying,
                                  nullstrike, Position::Long, false, nullstrike,
                                  strike, Position::Short, false, cashRate,
                                  centralReplication);
        DigitalCoupon over_cash_shortDigitalPutCoupon(underlying,
                                  nullstrike, Position::Long, false, nullstrike,
                                  strike, Position::Short, false, cashRate,
                                  superReplication);
        sub_cash_shortDigitalPutCoupon.setPricer(pricer);
        central_cash_shortDigitalPutCoupon.setPricer(pricer);
        over_cash_shortDigitalPutCoupon.setPricer(pricer);
        sub_digitalPrice = sub_cash_shortDigitalPutCoupon.price(vars.termStructure);
        central_digitalPrice = central_cash_shortDigitalPutCoupon.price(vars.termStructure);
        over_digitalPrice = over_cash_shortDigitalPutCoupon.price(vars.termStructure);
        if ( ( (sub_digitalPrice > central_digitalPrice) &&
                std::abs(central_digitalPrice - sub_digitalPrice)>tolerance ) ||
             ( (central_digitalPrice>over_digitalPrice)  &&
                std::abs(central_digitalPrice - over_digitalPrice)>tolerance ) )
            BOOST_ERROR("\nCash-or-nothing: Floating Rate Coupon + Call Digital option" <<
                        "\nVolatility = " << io::rate(capletVolatility) <<
                        "\nStrike = " << io::rate(strike) <<
                        "\nExercise = " << k+1 << " years" <<
                        std::setprecision(20) <<
                        "\nSub-Replication Price = "  << sub_digitalPrice <<
                        "\nCentral-Replication Price = "  << central_digitalPrice <<
                        "\nOver-Replication Price = "  << over_digitalPrice);
    }
}
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/optionletstripper.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  for (Size i = 0; i < optionTenors.size(); ++i)
      optionTenors[i] = Period(i + 1, Years);

  for (Size i=0; i<optionTenors.size(); ++i)
      curveVHandle[i] = Handle<Quote>(boost::shared_ptr<Quote>(new
                                                SimpleQuote(flatVol)));

    for (Size i = 0; i < optionTenors.size(); ++i)
        optionTenors[i] = Period(i + 1, Years);

    for (Size j = 0; j < strikes.size(); ++j)
        strikes[j] = Real(j + 1) / 100.0;

  for (Size i=0; i<optionTenors.size(); ++i) {
    atmTermVolHandle[i] = Handle<Quote>(boost::shared_ptr<Quote>(new
                    SimpleQuote(atmTermV[i])));
  }

for (Size tenorIndex=0; tenorIndex<vars.optionTenors.size(); ++tenorIndex) {
for (Size strikeIndex=0; strikeIndex<vars.strikes.size(); ++strikeIndex) {
    cap = MakeCapFloor(CapFloor::Cap,
                       vars.optionTenors[tenorIndex],
                       iborIndex,
                       vars.strikes[strikeIndex],
                       0*Days)
          .withPricingEngine(strippedVolEngine);

    Real priceFromStrippedVolatility = cap->NPV();

    boost::shared_ptr<PricingEngine> blackCapFloorEngineConstantVolatility(new
        BlackCapFloorEngine(vars.yieldTermStructure,
                            vars.termV[tenorIndex][strikeIndex]));

    cap->setPricingEngine(blackCapFloorEngineConstantVolatility);
    Real priceFromConstantVolatility = cap->NPV();

    Real error = std::fabs(priceFromStrippedVolatility - priceFromConstantVolatility);
    if (error>vars.tolerance)
        BOOST_FAIL("\noption tenor:       " << vars.optionTenors[tenorIndex] <<
                   "\nstrike:             " << io::rate(vars.strikes[strikeIndex]) <<
                   "\nstripped vol price: " << io::rate(priceFromStrippedVolatility) <<
                   "\nconstant vol price: " << io::rate(priceFromConstantVolatility) <<
                   "\nerror:              " << io::rate(error) <<
                   "\ntolerance:          " << io::rate(vars.tolerance));
    }
}

for (Size tenorIndex=0; tenorIndex<vars.optionTenors.size(); ++tenorIndex) {
for (Size strikeIndex=0; strikeIndex<vars.strikes.size(); ++strikeIndex) {
    cap = MakeCapFloor(CapFloor::Cap,
                       vars.optionTenors[tenorIndex],
                       iborIndex,
                       vars.strikes[strikeIndex],
                       0*Days)
          .withPricingEngine(strippedVolEngine);

    Real priceFromStrippedVolatility = cap->NPV();

    boost::shared_ptr<PricingEngine> blackCapFloorEngineConstantVolatility(new
        BlackCapFloorEngine(vars.yieldTermStructure,
                            vars.termV[tenorIndex][strikeIndex]));

    cap->setPricingEngine(blackCapFloorEngineConstantVolatility);
    Real priceFromConstantVolatility = cap->NPV();

    Real error = std::fabs(priceFromStrippedVolatility - priceFromConstantVolatility);
    if (error>vars.tolerance)
        BOOST_FAIL("\noption tenor:       " << vars.optionTenors[tenorIndex] <<
                   "\nstrike:             " << io::rate(vars.strikes[strikeIndex]) <<
                   "\nstripped vol price: " << io::rate(priceFromStrippedVolatility) <<
                   "\nconstant vol price: " << io::rate(priceFromConstantVolatility) <<
                   "\nerror:              " << io::rate(error) <<
                   "\ntolerance:          " << io::rate(vars.tolerance));
    }
}

for (Size strikeIndex=0; strikeIndex<vars.strikes.size(); ++strikeIndex) {
for (Size tenorIndex=0; tenorIndex<vars.optionTenors.size(); ++tenorIndex) {

Volatility strippedVol1 = vol1->volatility(vars.optionTenors[tenorIndex],
                                         vars.strikes[strikeIndex], true);

Volatility strippedVol2 = vol2->volatility(vars.optionTenors[tenorIndex],
                                         vars.strikes[strikeIndex], true);

// vol from flat vol surface (for comparison only)
Volatility flatVol = vars.flatTermVolSurface->volatility(vars.optionTenors[tenorIndex],
                                                       vars.strikes[strikeIndex], true);

Real error = std::fabs(strippedVol1-strippedVol2);
if (error>vars.tolerance)
BOOST_FAIL("\noption tenor:  " << vars.optionTenors[tenorIndex] <<
         "\nstrike:        " << io::rate(vars.strikes[strikeIndex]) <<
         "\nstripped vol1: " << io::rate(strippedVol1) <<
         "\nstripped vol2: " << io::rate(strippedVol2) <<
         "\nflat vol:      " << io::rate(flatVol) <<
         "\nerror:         " << io::rate(error) <<
         "\ntolerance:     " << io::rate(vars.tolerance));
}
}

for (Size strikeIndex=0; strikeIndex<vars.strikes.size(); ++strikeIndex) {
for (Size tenorIndex=0; tenorIndex<vars.optionTenors.size(); ++tenorIndex) {

Volatility strippedVol1 = vol1->volatility(vars.optionTenors[tenorIndex],
                                         vars.strikes[strikeIndex], true);

Volatility strippedVol2 = vol2->volatility(vars.optionTenors[tenorIndex],
                                         vars.strikes[strikeIndex], true);

// vol from flat vol surface (for comparison only)
Volatility flatVol = vars.capFloorVolSurface->volatility(vars.optionTenors[tenorIndex],
                                                       vars.strikes[strikeIndex], true);

Real error = std::fabs(strippedVol1-strippedVol2);
if (error>vars.tolerance)
BOOST_FAIL("\noption tenor:  " << vars.optionTenors[tenorIndex] <<
         "\nstrike:        " << io::rate(vars.strikes[strikeIndex]) <<
         "\nstripped vol1: " << io::rate(strippedVol1) <<
         "\nstripped vol2: " << io::rate(strippedVol2) <<
         "\nflat vol:      " << io::rate(flatVol) <<
         "\nerror:         " << io::rate(error) <<
         "\ntolerance:     " << io::rate(vars.tolerance));
}
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/himalayaoption.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i<5; ++i)
fixingDates.push_back(today+i*90);

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/overnightindexedswap.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i<LENGTH(lengths); i++) {
for (Size j=0; j<LENGTH(spreads); j++) {

    shared_ptr<OvernightIndexedSwap> swap =
        vars.makeSwap(lengths[i],0.0,spreads[j]);
    swap = vars.makeSwap(lengths[i],swap->fairRate(),spreads[j]);
    if (std::fabs(swap->NPV()) > 1.0e-10) {
        BOOST_ERROR("recalculating with implied rate:\n"
                    << std::setprecision(2)
                    << "    length: " << lengths[i] << " \n"
                    << "    floating spread: "
                    << io::rate(spreads[j]) << "\n"
                    << "    swap value: " << swap->NPV());
    }
}
}

for (Size i=0; i<LENGTH(lengths); i++) {
for (Size j=0; j<LENGTH(rates); j++) {

    shared_ptr<OvernightIndexedSwap> swap =
        vars.makeSwap(lengths[i], rates[j], 0.0);
    Spread fairSpread = swap->fairSpread();
    swap = vars.makeSwap(lengths[i], rates[j], fairSpread);

    if (std::fabs(swap->NPV()) > 1.0e-10) {
        BOOST_ERROR("\nrecalculating with implied spread:" <<
                    std::setprecision(2) <<
                    "\n     length: " << lengths[i] <<
                    "\n fixed rate: " << io::rate(rates[j]) <<
                    "\nfair spread: " << io::rate(fairSpread) <<
                    "\n swap value: " << swap->NPV());
    }
}
}

for (Size i = 0; i < LENGTH(depositData); i++) {
Real rate = 0.01 * depositData[i].rate;
shared_ptr<SimpleQuote> simple = shared_ptr<SimpleQuote>(new SimpleQuote(rate));
shared_ptr<Quote> quote (simple);
Period term = depositData[i].n * depositData[i].unit;
shared_ptr<RateHelper> helper(new
            DepositRateHelper(Handle<Quote>(quote),
                              term,
                              depositData[i].settlementDays,
                              euribor3m->fixingCalendar(),
                              euribor3m->businessDayConvention(),
                              euribor3m->endOfMonth(),
                              euribor3m->dayCounter()));

if (term <= 2*Days)
    eoniaHelpers.push_back(helper);
if (term <= 3*Months)
    swap3mHelpers.push_back(helper);
}

for (Size i = 0; i < LENGTH(fraData); i++) {
Real rate = 0.01 * fraData[i].rate;
shared_ptr<SimpleQuote> simple = shared_ptr<SimpleQuote>(new SimpleQuote(rate));
shared_ptr<Quote> quote (simple);
shared_ptr<RateHelper> helper(new
                       FraRateHelper(Handle<Quote>(quote),
                                     fraData[i].nExpiry,
                                     fraData[i].nMaturity,
                                     fraData[i].settlementDays,
                                     euribor3m->fixingCalendar(),
                                     euribor3m->businessDayConvention(),
                                     euribor3m->endOfMonth(),
                                     euribor3m->dayCounter()));
swap3mHelpers.push_back(helper);
}

for (Size i = 0; i < LENGTH(eoniaSwapData); i++) {
Real rate = 0.01 * eoniaSwapData[i].rate;
shared_ptr<SimpleQuote> simple = shared_ptr<SimpleQuote>(new SimpleQuote(rate));
shared_ptr<Quote> quote (simple);
Period term = eoniaSwapData[i].n * eoniaSwapData[i].unit;
shared_ptr<RateHelper> helper(new
             OISRateHelper(eoniaSwapData[i].settlementDays,
                           term,
                           Handle<Quote>(quote),
                           eonia));
eoniaHelpers.push_back(helper);
}

for (Size i = 0; i < LENGTH(swapData); i++) {
Real rate = 0.01 * swapData[i].rate;
shared_ptr<SimpleQuote> simple = shared_ptr<SimpleQuote>(new SimpleQuote(rate));
shared_ptr<Quote> quote (simple);
Period tenor = swapData[i].nIndexUnits * swapData[i].indexUnit;
Period term = swapData[i].nTermUnits * swapData[i].termUnit;
shared_ptr<RateHelper> helper(new SwapRateHelper(
                       Handle<Quote>(quote),
                       term,
                       vars.calendar,
                       vars.fixedSwapFrequency,
                       vars.fixedSwapConvention,
                       vars.fixedSwapDayCount,
                       euribor3m));
if (tenor == 3*Months)
    swap3mHelpers.push_back(helper);
}

for (Size i = 0; i < LENGTH(eoniaSwapData); i++) {
Rate expected = eoniaSwapData[i].rate;
Period term = eoniaSwapData[i].n * eoniaSwapData[i].unit;
shared_ptr<OvernightIndexedSwap> swap = vars.makeSwap(term, 0.0, 0.0);
Rate calculated = 100.0 * swap->fairRate();
Rate error = std::fabs(expected-calculated);

if (error>tolerance)
    BOOST_FAIL("curve inconsistency:" << std::setprecision(10) <<
                "\n swap length:     " << term <<
                "\n quoted rate:     " << expected <<
                "\n calculated rate: " << calculated <<
                "\n error:           " << error <<
                "\n tolerance:       " << tolerance);
}

for (Size i = 1; i <= 10; i++) {
Date d = vars.today + i*Years;
Rate zero1d = eoniaTS->zeroRate(d, dc, Continuous, Annual,false).rate();
Rate zero3m = swapTS->zeroRate(d, dc, Continuous, Annual,false).rate();
std::cout << std::setw(2) << i << "y  " << io::iso_date(d) << "  "
          << std::setprecision(3)
          << zero3m * 100.0 << " "
          << zero1d * 100.0 << " "
          << std::setprecision(1)
          << (zero3m - zero1d) * 10000.0 << std::endl;
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/matrices.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i<m.rows(); i++)
    for (Size j=0; j<m.columns(); j++)
        sum += m[i][j]*m[i][j];

for (Size k=0; k<LENGTH(testMatrices); k++) {

Matrix& M = testMatrices[k];
SymmetricSchurDecomposition dec(M);
Array eigenValues = dec.eigenvalues();
Matrix eigenVectors = dec.eigenvectors();
Real minHolder = QL_MAX_REAL;

for (Size i=0; i<N; i++) {
    Array v(N);
    for (Size j=0; j<N; j++)
        v[j] = eigenVectors[j][i];
    // check definition
    Array a = M*v;
    Array b = eigenValues[i]*v;
    if (norm(a-b) > 1.0e-15)
        BOOST_FAIL("Eigenvector definition not satisfied");
    // check decreasing ordering
    if (eigenValues[i] >= minHolder) {
        BOOST_FAIL("Eigenvalues not ordered: " << eigenValues);
    } else
        minHolder = eigenValues[i];
}

// check normalization
Matrix m = eigenVectors * transpose(eigenVectors);
if (norm(m-I) > 1.0e-15)
    BOOST_FAIL("Eigenvector not normalized");
}

for (Size j = 0; j < LENGTH(testMatrices); j++) {
// m >= n required (rows >= columns)
Matrix& A = testMatrices[j];
SVD svd(A);
// U is m x n
Matrix U = svd.U();
// s is n long
Array s = svd.singularValues();
// S is n x n
Matrix S = svd.S();
// V is n x n
Matrix V = svd.V();

for (Size i=0; i < S.rows(); i++) {
    if (S[i][i] != s[i])
        BOOST_FAIL("S not consistent with s");
}

// tests
Matrix U_Utranspose = transpose(U)*U;
if (norm(U_Utranspose-I) > tol)
    BOOST_FAIL("U not orthogonal (norm of U^T*U-I = "
               << norm(U_Utranspose-I) << ")");

Matrix V_Vtranspose = transpose(V)*V;
if (norm(V_Vtranspose-I) > tol)
    BOOST_FAIL("V not orthogonal (norm of V^T*V-I = "
               << norm(V_Vtranspose-I) << ")");

Matrix A_reconstructed = U * S * transpose(V);
if (norm(A_reconstructed-A) > tol)
    BOOST_FAIL("Product does not recover A: (norm of U*S*V^T-A = "
               << norm(A_reconstructed-A) << ")");
}

for (Size j = 0; j < LENGTH(testMatrices); j++) {
Matrix Q, R;
bool pivot = true;
const Matrix& A = testMatrices[j];
const std::vector<Size> ipvt = qrDecomposition(A, Q, R, pivot);

Matrix P(A.columns(), A.columns(), 0.0);

// reverse column pivoting
for (Size i=0; i < P.columns(); ++i) {
    P[ipvt[i]][i] = 1.0;
}

if (norm(Q*R - A*P) > tol)
    BOOST_FAIL("Q*R does not match matrix A*P (norm = "
               << norm(Q*R-A*P) << ")");

pivot = false;
qrDecomposition(A, Q, R, pivot);

if (norm(Q*R - A) > tol)
    BOOST_FAIL("Q*R does not match matrix A (norm = "
               << norm(Q*R-A) << ")");
}

for (Size i=0; i < std::min(bigM.rows(), bigM.columns()); ++i) {
bigM[i][i] = i+1.0;
}

for (Size j = 0; j < LENGTH(testMatrices); j++) {
const Matrix& A = testMatrices[j];
Array b(A.rows());

for (Size k=0; k < 10; ++k) {
    for (Array::iterator iter = b.begin(); iter != b.end(); ++iter) {
        *iter = rng.next().value;
    }
    const Array x = qrSolve(A, b, true);

    if (A.columns() >= A.rows()) {
        if (norm(A*x - b) > tol)
            BOOST_FAIL("A*x does not match vector b (norm = "
                       << norm(A*x - b) << ")");
    }
    else {
        // use the SVD to calculate the reference values
        const Size n = A.columns();
        Array xr(n, 0.0);

        SVD svd(A);
        const Matrix& V = svd.V();
        const Matrix& U = svd.U();
        const Array&  w = svd.singularValues();
        const Real threshold = n*QL_EPSILON;

        for (Size i=0; i<n; ++i) {
            if (w[i] > threshold) {
                const Real u = std::inner_product(U.column_begin(i),
                                                  U.column_end(i),
                                                  b.begin(), 0.0)/w[i];

                for (Size j=0; j<n; ++j) {
                    xr[j]  +=u*V[j][i];
                }
            }
        }

        if (norm(xr-x) > tol) {
            BOOST_FAIL("least square solution does not match (norm = "
                       << norm(x - xr) << ")");

        }
    }
}
}

for (Size j = 0; j < LENGTH(testMatrices); j++) {
const Matrix& A = testMatrices[j];
const Matrix invA = inverse(A);

const Matrix I1 = invA*A;
const Matrix I2 = A*invA;

Matrix eins(A.rows(), A.rows(), 0.0);
for (Size i=0; i < A.rows(); ++i) eins[i][i] = 1.0;

if (norm(I1 - eins) > tol)
    BOOST_FAIL("inverse(A)*A does not recover unit matrix (norm = "
               << norm(I1-eins) << ")");

if (norm(I2 - eins) > tol)
    BOOST_FAIL("A*inverse(A) does not recover unit matrix (norm = "
               << norm(I1-eins) << ")");
}

for (Size j=0; j<LENGTH(testMatrices); ++j) {
const Real calculated = determinant(testMatrices[j]);
if (std::fabs(expected[j] - calculated) > tol)
    BOOST_FAIL("determinant calculation failed "
               << "\n matrix     :\n" << testMatrices[j]
               << "\n calculated : " << calculated
               << "\n expected   : " << expected[j]);
}

for (Size j=0; j<100; ++j) {
Matrix m(3, 3, 0.0);
for (Matrix::iterator iter = m.begin(); iter != m.end(); ++iter)
    *iter = rng.next().value;

if (!(j%3)) {
    // every third matrix is a singular matrix
    Size row = Size(3*rng.next().value);
    std::fill(m.row_begin(row), m.row_end(row), 0.0);
}

Real a=m[0][0];
Real b=m[0][1];
Real c=m[0][2];
Real d=m[1][0];
Real e=m[1][1];
Real f=m[1][2];
Real g=m[2][0];
Real h=m[2][1];
Real i=m[2][2];

const Real expected = a*e*i+b*f*g+c*d*h-(g*e*c+h*f*a+i*d*b);
const Real calculated = determinant(m);

if (std::fabs(expected-calculated) > tol)
    BOOST_FAIL("determinant calculation failed "
               << "\n matrix     :\n" << m
               << "\n calculated : " << calculated
               << "\n expected   : " << expected);
}

for (Size i=0; i < numberVectors; ++i)
for (Size j=0; j < dimension; ++j)
    test[i][j] = rng.next().value;

for (Size i=0; i < numberVectors; ++i)
{
// check output vector i is orthogonal to all other vectors

if (projector.validVectors()[i])
{
    for (Size j=0; j < numberVectors; ++j)
          if (projector.validVectors()[j] && i != j)
          {
              Real dotProduct=0.0;
              for (Size k=0; k < dimension; ++k)
                  dotProduct += test[j][k]*projector.GetVector(i)[k];

              if (fabs(dotProduct) > errorAcceptable)
                  ++numberFailures;

          }

   Real innerProductWithOriginal =0.0;
   Real normSq =0.0;

   for (Size j=0; j < dimension; ++j)
   {
        innerProductWithOriginal +=   projector.GetVector(i)[j]*test[i][j];
        normSq += test[i][j]*test[i][j];
   }

   if (fabs(innerProductWithOriginal-normSq) > errorAcceptable)
       ++failuresTwo;

}

}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/array.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (i=0; i<size; ++i) {
if (a3[i] != value)
    BOOST_ERROR(io::ordinal(i+1) << " element not with required value"
                << "\n    required:  " << value
                << "\n    resulting: " << a3[i]);
}

for (i=0; i<size; i++) {
if (a4[i] != value + i*increment)
    BOOST_ERROR(io::ordinal(i+1) << " element not with required value"
                << "\n    required:  " << value + i*increment
                << "\n    resulting: " << a4[i]);
}

for (i=0; i<a3.size(); i++) {
if (a6[i] != a3[i])
    BOOST_ERROR(io::ordinal(i+1) << " element of copy "
                "not with same value as original"
                << "\n    original:  " << a3[i]
                << "\n    copy:      " << a6[i]);
}

for (i=0; i<size; i++) {
if (temp2[i] != value)
    BOOST_ERROR(io::ordinal(i+1) << " element of disposable "
                "not moved correctly"
                << "\n    required:  " << value
                << "\n    resulting: " << temp2[i]);
}

for (i=0; i<size; i++) {
if (a7[i] != value)
    BOOST_ERROR(io::ordinal(i+1) << " element not moved correctly"
                << "\n    required:  " << value
                << "\n    resulting: " << a7[i]);
}

for (i=0; i<a7.size(); i++) {
if (a8[i] != a7[i])
    BOOST_ERROR(io::ordinal(i+1) << " element of copy "
                "not with same value as original"
                << "\n    original:  " << a7[i]
                << "\n    copy:      " << a8[i]);
}

for (i=0; i<size; i++) {
if (a9[i] != value)
    BOOST_ERROR(io::ordinal(i+1) << " element not moved correctly"
                << "\n    required:  " << value
                << "\n    resulting: " << a9[i]);
}

for (i=0; i < a10.size(); i++) {
a10[i] = static_cast<Real>(i);
}

for (i=0; i < a10.size(); i++) {
Real calculated = f2(static_cast<Real>(i));
if (std::fabs(a10[i] -  calculated) >= 1e-5) {
    BOOST_ERROR("Array transform test failed " << a10[i] << " "
                << calculated);
}
}

for (Size i=0; i < a.size(); ++i) {
a[i] = std::sin(Real(i))+1.1;
}

for (Size i=0; i < a.size(); ++i) {
if (std::fabs(p[i]-std::pow(a[i], exponential)) > tol) {
    BOOST_FAIL("Array function test Pow failed");
}
if (std::fabs(e[i]-std::exp(a[i])) > tol) {
    BOOST_FAIL("Array function test Exp failed");
}
if (std::fabs(l[i]-std::log(a[i])) > tol) {
    BOOST_FAIL("Array function test Log failed");
}
if (std::fabs(s[i]-std::sqrt(a[i])) > tol) {
    BOOST_FAIL("Array function test Sqrt failed");
}
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/jumpdiffusion.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i<LENGTH(values); i++) {

boost::shared_ptr<StrikedTypePayoff> payoff(new
    PlainVanillaPayoff(values[i].type, values[i].strike));

Date exDate = today + Integer(values[i].t*360+0.5);
boost::shared_ptr<Exercise> exercise(new EuropeanExercise(exDate));

spot ->setValue(values[i].s);
qRate->setValue(values[i].q);
rRate->setValue(values[i].r);


jumpIntensity->setValue(values[i].jumpIntensity);

// delta in Haug's notation
Real jVol = values[i].v *
    std::sqrt(values[i].gamma / values[i].jumpIntensity);
jumpVol->setValue(jVol);

// z in Haug's notation
Real diffusionVol = values[i].v * std::sqrt(1.0 - values[i].gamma);
vol  ->setValue(diffusionVol);

// Haug is assuming zero meanJump
Real meanJump = 0.0;
meanLogJump->setValue(std::log(1.0+meanJump)-0.5*jVol*jVol);

Volatility totalVol = std::sqrt(values[i].jumpIntensity*jVol*jVol +
                              diffusionVol*diffusionVol);
Volatility volError = std::fabs(totalVol-values[i].v);
QL_REQUIRE(volError<1e-13,
           volError << " mismatch");

EuropeanOption option(payoff, exercise);
option.setPricingEngine(engine);

Real calculated = option.NPV();
Real error = std::fabs(calculated-values[i].result);
if (error>values[i].tol) {
    REPORT_FAILURE_2("value", payoff, exercise,
                     values[i].s, values[i].q, values[i].r,
                     today, values[i].v, values[i].jumpIntensity,
                     values[i].gamma, values[i].result, calculated,
                     error, values[i].tol);
}
}

for (Size i=0; i<LENGTH(types); i++) {
for (Size j=0; j<LENGTH(strikes); j++) {
for (Size jj1=0; jj1<LENGTH(jInt); jj1++) {
jumpIntensity->setValue(jInt[jj1]);
for (Size jj2=0; jj2<LENGTH(mLJ); jj2++) {
meanLogJump->setValue(mLJ[jj2]);
for (Size jj3=0; jj3<LENGTH(jV); jj3++) {
jumpVol->setValue(jV[jj3]);
for (Size k=0; k<LENGTH(residualTimes); k++) {
  Date exDate = today + Integer(residualTimes[k]*360+0.5);
  boost::shared_ptr<Exercise> exercise(new EuropeanExercise(exDate));
  for (Size kk=0; kk<1; kk++) {
      // option to check
      if (kk==0) {
          payoff = boost::shared_ptr<StrikedTypePayoff>(new
            PlainVanillaPayoff(types[i], strikes[j]));
      } else if (kk==1) {
          payoff = boost::shared_ptr<StrikedTypePayoff>(new
            CashOrNothingPayoff(types[i], strikes[j],
            100.0));
      } else if (kk==2) {
          payoff = boost::shared_ptr<StrikedTypePayoff>(new
            AssetOrNothingPayoff(types[i], strikes[j]));
      } else if (kk==3) {
          payoff = boost::shared_ptr<StrikedTypePayoff>(new
            GapPayoff(types[i], strikes[j], 100.0));
      }
      EuropeanOption option(payoff, exercise);
      option.setPricingEngine(engine);

      for (Size l=0; l<LENGTH(underlyings); l++) {
        Real u = underlyings[l];
        for (Size m=0; m<LENGTH(qRates); m++) {
          Rate q = qRates[m];
          for (Size n=0; n<LENGTH(rRates); n++) {
            Rate r = rRates[n];
            for (Size p=0; p<LENGTH(vols); p++) {
              Volatility v = vols[p];
              spot->setValue(u);
              qRate->setValue(q);
              rRate->setValue(r);
              vol->setValue(v);

              Real value = option.NPV();
              calculated["delta"]  = option.delta();
              calculated["gamma"]  = option.gamma();
              calculated["theta"]  = option.theta();
              calculated["rho"]    = option.rho();
              calculated["divRho"] = option.dividendRho();
              calculated["vega"]   = option.vega();

              if (value > spot->value()*1.0e-5) {
                  // perturb spot and get delta and gamma
                  Real du = u*1.0e-5;
                  spot->setValue(u+du);
                  Real value_p = option.NPV(),
                       delta_p = option.delta();
                  spot->setValue(u-du);
                  Real value_m = option.NPV(),
                       delta_m = option.delta();
                  spot->setValue(u);
                  expected["delta"] = (value_p - value_m)/(2*du);
                  expected["gamma"] = (delta_p - delta_m)/(2*du);

                  // perturb rates and get rho and dividend rho
                  Spread dr = 1.0e-5;
                  rRate->setValue(r+dr);
                  value_p = option.NPV();
                  rRate->setValue(r-dr);
                  value_m = option.NPV();
                  rRate->setValue(r);
                  expected["rho"] = (value_p - value_m)/(2*dr);

                  Spread dq = 1.0e-5;
                  qRate->setValue(q+dq);
                  value_p = option.NPV();
                  qRate->setValue(q-dq);
                  value_m = option.NPV();
                  qRate->setValue(q);
                  expected["divRho"] = (value_p - value_m)/(2*dq);

                  // perturb volatility and get vega
                  Volatility dv = v*1.0e-4;
                  vol->setValue(v+dv);
                  value_p = option.NPV();
                  vol->setValue(v-dv);
                  value_m = option.NPV();
                  vol->setValue(v);
                  expected["vega"] = (value_p - value_m)/(2*dv);

                  // get theta from time-shifted options
                  Time dT = dc.yearFraction(today-1, today+1);
                  Settings::instance().evaluationDate() = today-1;
                  value_m = option.NPV();
                  Settings::instance().evaluationDate() = today+1;
                  value_p = option.NPV();
                  Settings::instance().evaluationDate() = today;
                  expected["theta"] = (value_p - value_m)/dT;
                  // compare
                  std::map<std::string,Real>::iterator it;
                  for (it = expected.begin();
                       it != expected.end(); ++it) {
                      std::string greek = it->first;
                      Real expct = expected  [greek],
                           calcl = calculated[greek],
                           tol   = tolerance [greek];
                      Real error = std::fabs(expct-calcl);
                      if (error>tol) {
                          REPORT_FAILURE_1(greek, payoff, exercise,
                                           u, q, r, today, v,
                                           jInt[jj1], mLJ[jj2],
                                           jV[jj3], expct, calcl,
                                           error, tol);
                      }
                  }
              }
            }
          }
        }
      }
    }
}
} // strike loop
}
}
}
} // type loop

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/swaptionvolatilitymatrix.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    for (Size i=0; i<atm.tenors.options.size(); ++i) {
        Date optionDate =
            vol->optionDateFromTenor(atm.tenors.options[i]);
        if (optionDate!=vol->optionDates()[i])
            BOOST_FAIL(
                 "optionDateFromTenor failure for " <<
                 description << ":"
                 "\n       option tenor: " << atm.tenors.options[i] <<
                 "\nactual option date : " << optionDate <<
                 "\n  exp. option date : " << vol->optionDates()[i]);
        Time optionTime = vol->timeFromReference(optionDate);
        if (!close(optionTime,vol->optionTimes()[i]))
            BOOST_FAIL(
                 "timeFromReference failure for " <<
                 description << ":"
                 "\n       option tenor: " << atm.tenors.options[i] <<
                 "\n       option date : " << optionDate <<
                 "\nactual option time : " << optionTime <<
                 "\n  exp. option time : " << vol->optionTimes()[i]);
    }

    for (Size j=0; j<atm.tenors.swaps.size(); j++) {
        Time swapLength = vol->swapLength(atm.tenors.swaps[j]);
        if (!close(swapLength,years(atm.tenors.swaps[j])))
            BOOST_FAIL("convertSwapTenor failure for " <<
                       description << ":"
                       "\n        swap tenor : " << atm.tenors.swaps[j] <<
                       "\n actual swap length: " << swapLength <<
                       "\n   exp. swap length: " << years(atm.tenors.swaps[j]));

        boost::shared_ptr<SwapIndex> swapIndex(new
            EuriborSwapIsdaFixA(atm.tenors.swaps[j], termStructure));

        for (Size i=0; i<atm.tenors.options.size(); ++i) {
            Real error, tolerance = 1.0e-16;
            Volatility actVol, expVol = atm.vols[i][j];

            actVol = vol->volatility(atm.tenors.options[i],
                                     atm.tenors.swaps[j], 0.05, true);
            error = std::abs(expVol-actVol);
            if (error>tolerance)
                BOOST_FAIL(
                      "recovery of atm vols failed for " <<
                      description << ":"
                      "\noption tenor = " << atm.tenors.options[i] <<
                      "\n swap length = " << atm.tenors.swaps[j] <<
                      "\nexpected vol = " << io::volatility(expVol) <<
                      "\n  actual vol = " << io::volatility(actVol) <<
                      "\n       error = " << io::volatility(error) <<
                      "\n   tolerance = " << tolerance);

            Date optionDate =
                vol->optionDateFromTenor(atm.tenors.options[i]);
            actVol = vol->volatility(optionDate,
                                     atm.tenors.swaps[j], 0.05, true);
            error = std::abs(expVol-actVol);
            if (error>tolerance)
                BOOST_FAIL(
                     "recovery of atm vols failed for " <<
                     description << ":"
                     "\noption tenor: " << atm.tenors.options[i] <<
                     "\noption date : " << optionDate <<
                     "\n  swap tenor: " << atm.tenors.swaps[j] <<
                     "\n   exp. vol: " << io::volatility(expVol) <<
                     "\n actual vol: " << io::volatility(actVol) <<
                     "\n      error: " << io::volatility(error) <<
                     "\n  tolerance: " << tolerance);

            Time optionTime = vol->timeFromReference(optionDate);
            actVol = vol->volatility(optionTime, swapLength,
                                     0.05, true);
            error = std::abs(expVol-actVol);
            if (error>tolerance)
                BOOST_FAIL(
                     "recovery of atm vols failed for " <<
                     description << ":"
                     "\noption tenor: " << atm.tenors.options[i] <<
                     "\noption time : " << optionTime <<
                     "\n  swap tenor: " << atm.tenors.swaps[j] <<
                     "\n swap length: " << swapLength <<
                     "\n    exp. vol: " << io::volatility(expVol) <<
                     "\n  actual vol: " << io::volatility(actVol) <<
                     "\n       error: " << io::volatility(error) <<
                     "\n   tolerance: " << tolerance);

            // ATM swaption
            Swaption swaption =
                MakeSwaption(swapIndex, atm.tenors.options[i])
                .withPricingEngine(engine);

            Date exerciseDate = swaption.exercise()->dates().front();
            if (exerciseDate!=vol->optionDates()[i])
                BOOST_FAIL(
                     "\noptionDateFromTenor mismatch for " <<
                     description << ":"
                     "\n      option tenor: " << atm.tenors.options[i] <<
                     "\nactual option date: " << exerciseDate <<
                     "\n  exp. option date: " << vol->optionDates()[i]);

            Date start = swaption.underlyingSwap()->startDate();
            Date end = swaption.underlyingSwap()->maturityDate();
            Time swapLength2 = vol->swapLength(start, end);
            if (!close(swapLength2,swapLength))
                BOOST_FAIL("\nswapLength failure for " <<
                           description << ":"
                           "\n   exp. swap length: " << swapLength <<
                           "\n actual swap length: " << swapLength2 <<
                           "\n        swap tenor : " << atm.tenors.swaps[j] <<
                           "\n  swap index tenor : " << swapIndex->tenor() <<
                           "\n        option date: " << exerciseDate <<
                           "\n         start date: " << start <<
                           "\n      maturity date: " << end
                           );

            Real npv = swaption.NPV();
            actVol = swaption.impliedVolatility(npv, termStructure,
                                                expVol*0.98, 1e-6,
                                                100, 10.0e-7, 4.0, 0.0);
            error = std::abs(expVol-actVol);
            Real tolerance2 = 0.000001;
            if (error>tolerance2)
                BOOST_FAIL(
                     "recovery of atm vols through BlackSwaptionEngine failed for " <<
                     description << ":"
                     "\noption tenor: " << atm.tenors.options[i] <<
                     "\noption time : " << optionTime <<
                     "\n  swap tenor: " << atm.tenors.swaps[j] <<
                     "\n swap length: " << swapLength <<
                     "\n   exp. vol: " << io::volatility(expVol) <<
                     "\n actual vol: " << io::volatility(actVol) <<
                     "\n      error: " << io::volatility(error) <<
                     "\n  tolerance: " << tolerance2);
        }
    }

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/garch.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (std::size_t i = 0; i < 50000; ++i, d += 1) {
v = garch.forecast(r, v);
r = rng.next().value * std::sqrt(v);
ts[d] = r;
}

for (std::size_t i = 0; i < 10; ++i, d += 1) {
ts[d] = r;
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/curvestates.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    for (Size i=1; i<dates.size(); ++i)
        rateTimes[i-1] = dayCounter.yearFraction(todaysDate, dates[i]);

    for (Size i=1; i<rateTimes.size(); ++i)
        accruals[i-1] = rateTimes[i] - rateTimes[i-1];

    for (Size i=0; i<todaysForwards.size(); ++i)
        todaysForwards[i] = 0.03 + 0.0010*i;

    for (Size i=1; i<rateTimes.size(); ++i)
        todaysDiscounts[i] = todaysDiscounts[i-1] /
            (1.0+todaysForwards[i-1]*accruals[i-1]);

    for (Size i=1; i<=N; ++i) {
        if (i==1) {
            coterminalAnnuity[N-1] = accruals[N-1]*todaysDiscounts[N];
        } else {
            coterminalAnnuity[N-i] = coterminalAnnuity[N-i+1] +
                accruals[N-i]*todaysDiscounts[N-i+1];
        }
        floatingLeg = todaysDiscounts[N-i]-todaysDiscounts[N];
        todaysCoterminalSwapRates[N-i] =
            floatingLeg/coterminalAnnuity[N-i];
    }

for (Size i = 0; i < forwards.size(); ++i)
forwards[i] = static_cast<Rate>(i)*.001+.04;

for (Size i = 0; i < rateTimes.size(); ++i)
rateTimes[i] = static_cast<Time>(i+1)*.5;

for (Size i = 0; i<nbRates; ++i){
 std::cout << lmmDrifts[i] << "\t\t"<< cmsDrifts[i] << std::endl;
}*/

/*for (Size i = 0; i <nbRates; ++i){
std::cout << lmmCs.discountRatio(i, nbRates) << "\t"<< cmsCs.discountRatio(i, nbRates) << std::endl;
}*/

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/integrals.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i < LENGTH(nr); ++i) {
const Size n = nr[i];
const Real calculatedCosine
    = FilonIntegral(FilonIntegral::Cosine, t, n)(cosineF(),0,2*M_PI);
const Real calculatedSine
    = FilonIntegral(FilonIntegral::Sine, t, n)
        (sineF(), o,2*M_PI + o);

if (std::fabs(calculatedCosine-expected[i]) > tol) {
    BOOST_FAIL(std::setprecision(10)
        << "Filon Cosine integration failed: "
        << "\n    calculated: " << calculatedCosine
        << "\n    expected:   " << expected[i]);
}
if (std::fabs(calculatedSine-expected[i]) > tol) {
    BOOST_FAIL(std::setprecision(10)
        << "Filon Sine integration failed: "
        << "\n    calculated: " << calculatedCosine
        << "\n    expected:   " << expected[i]);
}
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/shortratemodels.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i<LENGTH(data); i++) {
boost::shared_ptr<Quote> vol(new SimpleQuote(data[i].volatility));
boost::shared_ptr<CalibrationHelper> helper(
                     new SwaptionHelper(Period(data[i].start, Years),
                                        Period(data[i].length, Years),
                                        Handle<Quote>(vol),
                                        index,
                                        Period(1, Years), Thirty360(),
                                        Actual360(), termStructure));
helper->setPricingEngine(engine);
swaptions.push_back(helper);
}

for (Size i=0; i<LENGTH(data); i++) {
boost::shared_ptr<Quote> vol(new SimpleQuote(data[i].volatility));
boost::shared_ptr<CalibrationHelper> helper(
                     new SwaptionHelper(Period(data[i].start, Years),
                                        Period(data[i].length, Years),
                                        Handle<Quote>(vol),
                                        index,
                                        Period(1, Years), Thirty360(),
                                        Actual360(), termStructure));
helper->setPricingEngine(engine);
swaptions.push_back(helper);
}

for (Size i=0; i<LENGTH(data); i++) {
boost::shared_ptr<Quote> vol(new SimpleQuote(data[i].volatility));
boost::shared_ptr<CalibrationHelper> helper(
                     new SwaptionHelper(Period(data[i].start, Years),
                                        Period(data[i].length, Years),
                                        Handle<Quote>(vol),
                                        index0,
                                        Period(1, Years), Thirty360(),
                                        Actual360(), termStructure));
helper->setPricingEngine(engine);
swaptions.push_back(helper);
}

for (Size i=0; i<LENGTH(start); i++) {

Date startDate = calendar.advance(settlement,start[i],Months);
if (startDate < today) {
    Date fixingDate = calendar.advance(startDate,-2,Days);
    TimeSeries<Real> pastFixings;
    pastFixings[fixingDate] = 0.03;
    IndexManager::instance().setHistory(euribor->name(),
                                        pastFixings);
}

for (Size j=0; j<LENGTH(length); j++) {

    Date maturity = calendar.advance(startDate,length[i],Years);
    Schedule fixedSchedule(startDate, maturity, Period(Annual),
                           calendar, Unadjusted, Unadjusted,
                           DateGeneration::Forward, false);
    Schedule floatSchedule(startDate, maturity, Period(Semiannual),
                           calendar, Following, Following,
                           DateGeneration::Forward, false);
    for (Size k=0; k<LENGTH(rates); k++) {

        VanillaSwap swap(VanillaSwap::Payer, 1000000.0,
                         fixedSchedule, rates[k], Thirty360(),
                         floatSchedule, euribor, 0.0, Actual360());
        swap.setPricingEngine(boost::shared_ptr<PricingEngine>(
                           new DiscountingSwapEngine(termStructure)));
        Real expected = swap.NPV();
        swap.setPricingEngine(engine);
        Real calculated = swap.NPV();

        Real error = std::fabs((expected-calculated)/expected);
        if (error > tolerance) {
            BOOST_ERROR("Failed to reproduce swap NPV:"
                        << QL_FIXED << std::setprecision(9)
                        << "\n    calculated: " << calculated
                        << "\n    expected:   " << expected
                        << QL_SCIENTIFIC
                        << "\n    rel. error: " << error);
        }
    }
}
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/nthtodefault.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i = 0; i < lambda.size(); i++) {
Handle<Quote> h(boost::shared_ptr<Quote>(new SimpleQuote(lambda[i])));
boost::shared_ptr<DefaultProbabilityTermStructure> ptr (
                                 new FlatHazardRate(asofDate, h, dc));
probabilities.push_back(Handle<DefaultProbabilityTermStructure>(ptr));
}

for(Size i=0; i<names; i++)
namesIds.push_back(std::string("Name") + 
    boost::lexical_cast<std::string>(i));

for(Size i=0; i<names; i++) {
std::vector<QuantLib::Issuer::key_curve_pair> curves(1, 
    std::make_pair(NorthAmericaCorpDefaultKey(
        EURCurrency(), QuantLib::SeniorSec,
        Period(), 1. // amount threshold
        ), probabilities[i]));
issuers.push_back(Issuer(curves));
}

for(Size i=0; i<names; i++)
thePool->add(namesIds[i], issuers[i], NorthAmericaCorpDefaultKey(
        EURCurrency(), QuantLib::SeniorSec, Period(), 1.));

for (Size i = 1; i <= probabilities.size(); i++) {
ntd.push_back (NthToDefault (basket, i, Protection::Seller, 
    schedule, 0.0, 0.02, Actual360(), namesNotional*names, true));
ntd.back().setPricingEngine(engine);
}

for (Size j = 0; j < LENGTH(hwCorrelation); j++) {
simpleQuote->setValue (hwCorrelation[j]);
for (Size i = 0; i < ntd.size(); i++) {
    QL_REQUIRE (ntd[i].rank() == hwData[i].rank, "rank does not match");
    QL_REQUIRE (LENGTH(hwCorrelation) == LENGTH(hwData[i].spread),
                "vector length does not match");
    diff = 1e4 * ntd[i].fairPremium() - hwData[i].spread[j];
    maxDiff = max (maxDiff, fabs (diff));
    BOOST_CHECK_MESSAGE (fabs(diff/hwData[i].spread[j]) < relTolerance
                         || fabs(diff) < absTolerance,
                         "tolerance " << relTolerance << "|"
                         << absTolerance << " exceeded");
}
}

for (Size i = 0; i < lambda.size(); i++) {
Handle<Quote> h(boost::shared_ptr<Quote>(new SimpleQuote(lambda[i])));
boost::shared_ptr<DefaultProbabilityTermStructure> ptr (
                                 new FlatHazardRate(asofDate, h, dc));
probabilities.push_back(Handle<DefaultProbabilityTermStructure>(ptr));
}

for(Size i=0; i<names; i++)
namesIds.push_back(std::string("Name") + 
    boost::lexical_cast<std::string>(i));

for(Size i=0; i<names; i++) {
std::vector<QuantLib::Issuer::key_curve_pair> curves(1, 
    std::make_pair(NorthAmericaCorpDefaultKey(
        EURCurrency(), QuantLib::SeniorSec,
        Period(), 1. // amount threshold
        ), probabilities[i]));
issuers.push_back(Issuer(curves));
}

for(Size i=0; i<names; i++)
thePool->add(namesIds[i], issuers[i], NorthAmericaCorpDefaultKey(
        EURCurrency(), QuantLib::SeniorSec, Period(), 1.));

for (Size i = 1; i <= probabilities.size(); i++) {
ntd.push_back (NthToDefault (basket, i, Protection::Seller, 
    schedule, 0.0, 0.02, Actual360(), 100.*names, true));
ntd.back().setPricingEngine(engine);
}

for (Size i = 0; i < ntd.size(); i++) {
QL_REQUIRE (ntd[i].rank() == hwDataDist[i].rank, "rank does not match");

Real diff = 1e4 * ntd[i].fairPremium() - hwDataDist[i].spread[0];
maxDiff = max (maxDiff, fabs (diff));
BOOST_CHECK_MESSAGE (fabs(diff / hwDataDist[i].spread[0]) ||
                     fabs(diff) < absTolerance,
                     "tolerance " << relTolerance << "|"
                     << absTolerance << " exceeded");
}

for (Size i = 0; i < ntd.size(); i++) {
QL_REQUIRE (ntd[i].rank() == hwDataDist[i].rank, "rank does not match");

Real diff = 1e4 * ntd[i].fairPremium() - hwDataDist[i].spread[3];
maxDiff = max (maxDiff, fabs (diff));
BOOST_CHECK_MESSAGE (fabs(diff / hwDataDist[i].spread[3]) ||
                     fabs(diff) < absTolerance,
                     "tolerance " << relTolerance << "|"
                     << absTolerance << " exceeded");
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/dividendoption.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i<LENGTH(types); i++) {
for (Size j=0; j<LENGTH(strikes); j++) {
for (Size k=0; k<LENGTH(lengths); k++) {
  Date exDate = today + lengths[k]*Years;
  boost::shared_ptr<Exercise> exercise(new EuropeanExercise(exDate));

  std::vector<Date> dividendDates;
  std::vector<Real> dividends;
  for (Date d = today + 3*Months;
            d < exercise->lastDate();
            d += 6*Months) {
      dividendDates.push_back(d);
      dividends.push_back(0.0);
  }

  boost::shared_ptr<StrikedTypePayoff> payoff(
                        new PlainVanillaPayoff(types[i], strikes[j]));

  boost::shared_ptr<BlackScholesMertonProcess> stochProcess(
                    new BlackScholesMertonProcess(Handle<Quote>(spot),
                                                  qTS, rTS, volTS));

  boost::shared_ptr<PricingEngine> ref_engine(
                            new AnalyticEuropeanEngine(stochProcess));

  boost::shared_ptr<PricingEngine> engine(
                    new AnalyticDividendEuropeanEngine(stochProcess));

  DividendVanillaOption option(payoff, exercise,
                               dividendDates, dividends);
  option.setPricingEngine(engine);

  VanillaOption ref_option(payoff, exercise);
  ref_option.setPricingEngine(ref_engine);

  for (Size l=0; l<LENGTH(underlyings); l++) {
    for (Size m=0; m<LENGTH(qRates); m++) {
      for (Size n=0; n<LENGTH(rRates); n++) {
        for (Size p=0; p<LENGTH(vols); p++) {
            Real u = underlyings[l];
            Rate q = qRates[m],
                 r = rRates[n];
            Volatility v = vols[p];
            spot->setValue(u);
            qRate->setValue(q);
            rRate->setValue(r);
            vol->setValue(v);

            Real calculated = option.NPV();
            Real expected = ref_option.NPV();
            Real error = std::fabs(calculated-expected);
            if (error > tolerance) {
                REPORT_FAILURE("value start limit",
                               payoff, exercise,
                               u, q, r, today, v,
                               expected, calculated,
                               error, tolerance);
            }
        }
      }
    }
  }
}
}
}

for (Size i=0; i<LENGTH(types); i++) {
for (Size j=0; j<LENGTH(strikes); j++) {
for (Size k=0; k<LENGTH(lengths); k++) {
  Date exDate = today + lengths[k]*Years;
  boost::shared_ptr<Exercise> exercise(new EuropeanExercise(exDate));

  std::vector<Date> dividendDates;
  std::vector<Real> dividends;
  dividendDates.push_back(today);
  dividends.push_back(dividendValue);

  boost::shared_ptr<StrikedTypePayoff> payoff(
                        new PlainVanillaPayoff(types[i], strikes[j]));

  boost::shared_ptr<BlackScholesMertonProcess> stochProcess(
                    new BlackScholesMertonProcess(Handle<Quote>(spot),
                                                  qTS, rTS, volTS));

  boost::shared_ptr<PricingEngine> engine(
                    new AnalyticDividendEuropeanEngine(stochProcess));

  boost::shared_ptr<PricingEngine> ref_engine(
                            new AnalyticEuropeanEngine(stochProcess));

  DividendVanillaOption option(payoff, exercise,
                               dividendDates, dividends);
  option.setPricingEngine(engine);

  VanillaOption ref_option(payoff, exercise);
  ref_option.setPricingEngine(ref_engine);

  for (Size l=0; l<LENGTH(underlyings); l++) {
    for (Size m=0; m<LENGTH(qRates); m++) {
      for (Size n=0; n<LENGTH(rRates); n++) {
        for (Size p=0; p<LENGTH(vols); p++) {
            Real u = underlyings[l];
            Rate q = qRates[m],
                 r = rRates[n];
            Volatility v = vols[p];
            spot->setValue(u);
            qRate->setValue(q);
            rRate->setValue(r);
            vol->setValue(v);

            Real calculated = option.NPV();
            spot->setValue(u-dividendValue);
            Real expected = ref_option.NPV();
            Real error = std::fabs(calculated-expected);
            if (error > tolerance) {
                REPORT_FAILURE("value", payoff, exercise,
                               u, q, r, today, v,
                               expected, calculated,
                               error, tolerance);
            }
        }
      }
    }
  }
}
}
}

for (Size i=0; i<LENGTH(types); i++) {
for (Size j=0; j<LENGTH(strikes); j++) {
for (Size k=0; k<LENGTH(lengths); k++) {
  Date exDate = today + lengths[k]*Years;
  boost::shared_ptr<Exercise> exercise(new EuropeanExercise(exDate));

  std::vector<Date> dividendDates;
  std::vector<Real> dividends;
  dividendDates.push_back(exercise->lastDate());
  dividends.push_back(dividendValue);

  boost::shared_ptr<StrikedTypePayoff> payoff(
                        new PlainVanillaPayoff(types[i], strikes[j]));


  boost::shared_ptr<StrikedTypePayoff> refPayoff(
                        new PlainVanillaPayoff(types[i],
                                               strikes[j] +
                                               dividendValue));

  boost::shared_ptr<BlackScholesMertonProcess> stochProcess(
                    new BlackScholesMertonProcess(Handle<Quote>(spot),
                                                  qTS, rTS, volTS));

  boost::shared_ptr<PricingEngine> engine(
                    new AnalyticDividendEuropeanEngine(stochProcess));

  boost::shared_ptr<PricingEngine> ref_engine(
                            new AnalyticEuropeanEngine(stochProcess));

  DividendVanillaOption option(payoff, exercise,
                               dividendDates, dividends);
  option.setPricingEngine(engine);

  VanillaOption ref_option(refPayoff, exercise);
  ref_option.setPricingEngine(ref_engine);

  for (Size l=0; l<LENGTH(underlyings); l++) {
    for (Size m=0; m<LENGTH(qRates); m++) {
      for (Size n=0; n<LENGTH(rRates); n++) {
        for (Size p=0; p<LENGTH(vols); p++) {
            Real u = underlyings[l];
            Rate q = qRates[m],
                 r = rRates[n];
            Volatility v = vols[p];
            spot->setValue(u);
            qRate->setValue(q);
            rRate->setValue(r);
            vol->setValue(v);

            Real calculated = option.NPV();
            Real expected = ref_option.NPV();
            Real error = std::fabs(calculated-expected);
            if (error > tolerance) {
                REPORT_FAILURE("value", payoff, exercise,
                               u, q, r, today, v,
                               expected, calculated,
                               error, tolerance);
            }
        }
      }
    }
  }
}
}
}

for (Size i=0; i<LENGTH(types); i++) {
for (Size j=0; j<LENGTH(strikes); j++) {
for (Size k=0; k<LENGTH(lengths); k++) {
  Date exDate = today + lengths[k]*Years;
  boost::shared_ptr<Exercise> exercise(new EuropeanExercise(exDate));

  std::vector<Date> dividendDates;
  std::vector<Real> dividends;
  for (Date d = today + 3*Months;
            d < exercise->lastDate();
            d += 6*Months) {
      dividendDates.push_back(d);
      dividends.push_back(5.0);
  }

  boost::shared_ptr<StrikedTypePayoff> payoff(
                        new PlainVanillaPayoff(types[i], strikes[j]));

  boost::shared_ptr<BlackScholesMertonProcess> stochProcess(
                    new BlackScholesMertonProcess(Handle<Quote>(spot),
                                                  qTS, rTS, volTS));

  boost::shared_ptr<PricingEngine> engine(
                    new AnalyticDividendEuropeanEngine(stochProcess));

  DividendVanillaOption option(payoff, exercise,
                               dividendDates, dividends);
  option.setPricingEngine(engine);

  for (Size l=0; l<LENGTH(underlyings); l++) {
    for (Size m=0; m<LENGTH(qRates); m++) {
      for (Size n=0; n<LENGTH(rRates); n++) {
        for (Size p=0; p<LENGTH(vols); p++) {
            Real u = underlyings[l];
            Rate q = qRates[m],
                 r = rRates[n];
            Volatility v = vols[p];
            spot->setValue(u);
            qRate->setValue(q);
            rRate->setValue(r);
            vol->setValue(v);

            Real value = option.NPV();
            calculated["delta"]  = option.delta();
            calculated["gamma"]  = option.gamma();
            calculated["theta"]  = option.theta();
            calculated["rho"]    = option.rho();
            calculated["vega"]   = option.vega();

            if (value > spot->value()*1.0e-5) {
                // perturb spot and get delta and gamma
                Real du = u*1.0e-4;
                spot->setValue(u+du);
                Real value_p = option.NPV(),
                     delta_p = option.delta();
                spot->setValue(u-du);
                Real value_m = option.NPV(),
                     delta_m = option.delta();
                spot->setValue(u);
                expected["delta"] = (value_p - value_m)/(2*du);
                expected["gamma"] = (delta_p - delta_m)/(2*du);

                // perturb risk-free rate and get rho
                Spread dr = r*1.0e-4;
                rRate->setValue(r+dr);
                value_p = option.NPV();
                rRate->setValue(r-dr);
                value_m = option.NPV();
                rRate->setValue(r);
                expected["rho"] = (value_p - value_m)/(2*dr);

                // perturb volatility and get vega
                Spread dv = v*1.0e-4;
                vol->setValue(v+dv);
                value_p = option.NPV();
                vol->setValue(v-dv);
                value_m = option.NPV();
                vol->setValue(v);
                expected["vega"] = (value_p - value_m)/(2*dv);

                // perturb date and get theta
                Time dT = dc.yearFraction(today-1, today+1);
                Settings::instance().evaluationDate() = today-1;
                value_m = option.NPV();
                Settings::instance().evaluationDate() = today+1;
                value_p = option.NPV();
                Settings::instance().evaluationDate() = today;
                expected["theta"] = (value_p - value_m)/dT;

                // compare
                std::map<std::string,Real>::iterator it;
                for (it = calculated.begin();
                     it != calculated.end(); ++it) {
                    std::string greek = it->first;
                    Real expct = expected  [greek],
                         calcl = calculated[greek],
                         tol   = tolerance [greek];
                    Real error = relativeError(expct,calcl,u);
                    if (error>tol) {
                        REPORT_FAILURE(greek, payoff, exercise,
                                       u, q, r, today, v,
                                       expct, calcl, error, tol);
                    }
                }
            }
        }
      }
    }
  }
}
}
}

for (Size i=0; i<LENGTH(types); i++) {
for (Size j=0; j<LENGTH(strikes); j++) {
for (Size k=0; k<LENGTH(lengths); k++) {
  Date exDate = today + lengths[k]*Years;
  boost::shared_ptr<Exercise> exercise(new EuropeanExercise(exDate));

  std::vector<Date> dividendDates;
  std::vector<Real> dividends;
  for (Date d = today + 3*Months;
            d < exercise->lastDate();
            d += 6*Months) {
      dividendDates.push_back(d);
      dividends.push_back(5.0);
  }

  boost::shared_ptr<StrikedTypePayoff> payoff(
                        new PlainVanillaPayoff(types[i], strikes[j]));

  boost::shared_ptr<BlackScholesMertonProcess> stochProcess(
                    new BlackScholesMertonProcess(Handle<Quote>(spot),
                                                  qTS, rTS, volTS));

  boost::shared_ptr<PricingEngine> engine(
      new FDDividendEuropeanEngine<CrankNicolson>(stochProcess,
                                                  timeSteps,
                                                  gridPoints));

  boost::shared_ptr<PricingEngine> ref_engine(
                    new AnalyticDividendEuropeanEngine(stochProcess));

  DividendVanillaOption option(payoff, exercise,
                               dividendDates, dividends);
  option.setPricingEngine(engine);

  DividendVanillaOption ref_option(payoff, exercise,
                                   dividendDates, dividends);
  ref_option.setPricingEngine(ref_engine);

  for (Size l=0; l<LENGTH(underlyings); l++) {
    for (Size m=0; m<LENGTH(qRates); m++) {
      for (Size n=0; n<LENGTH(rRates); n++) {
        for (Size p=0; p<LENGTH(vols); p++) {
            Real u = underlyings[l];
            Rate q = qRates[m],
                 r = rRates[n];
            Volatility v = vols[p];
            spot->setValue(u);
            qRate->setValue(q);
            rRate->setValue(r);
            vol->setValue(v);
            // FLOATING_POINT_EXCEPTION
            Real calculated = option.NPV();
            if (calculated > spot->value()*1.0e-5) {
                Real expected = ref_option.NPV();
                Real error = std::fabs(calculated-expected);
                if (error > tolerance) {
                    REPORT_FAILURE("value", payoff, exercise,
                                   u, q, r, today, v,
                                   expected, calculated,
                                   error, tolerance);
                }
            }
        }
      }
    }
  }
}
}
}

for (Size i=0; i<LENGTH(types); i++) {
    for (Size j=0; j<LENGTH(strikes); j++) {

        std::vector<Date> dividendDates;
        std::vector<Real> dividends;
        for (Date d = today + 3*Months;
             d < exercise->lastDate();
             d += 6*Months) {
            dividendDates.push_back(d);
            dividends.push_back(5.0);
        }

        boost::shared_ptr<StrikedTypePayoff> payoff(
                        new PlainVanillaPayoff(types[i], strikes[j]));

        boost::shared_ptr<BlackScholesMertonProcess> stochProcess(
                    new BlackScholesMertonProcess(Handle<Quote>(spot),
                                                  qTS, rTS, volTS));

        boost::shared_ptr<PricingEngine> engine(
                                            new Engine(stochProcess));
        DividendVanillaOption option(payoff, exercise,
                                     dividendDates, dividends);
        option.setPricingEngine(engine);

        for (Size l=0; l<LENGTH(underlyings); l++) {
          for (Size m=0; m<LENGTH(qRates); m++) {
            for (Size n=0; n<LENGTH(rRates); n++) {
              for (Size p=0; p<LENGTH(vols); p++) {
                Real u = underlyings[l];
                Rate q = qRates[m],
                     r = rRates[n];
                Volatility v = vols[p];
                spot->setValue(u);
                qRate->setValue(q);
                rRate->setValue(r);
                vol->setValue(v);

                // FLOATING_POINT_EXCEPTION
                Real value = option.NPV();
                calculated["delta"]  = option.delta();
                calculated["gamma"]  = option.gamma();
                // calculated["theta"]  = option.theta();

                if (value > spot->value()*1.0e-5) {
                  // perturb spot and get delta and gamma
                  Real du = u*1.0e-4;
                  spot->setValue(u+du);
                  Real value_p = option.NPV(),
                       delta_p = option.delta();
                  spot->setValue(u-du);
                  Real value_m = option.NPV(),
                       delta_m = option.delta();
                  spot->setValue(u);
                  expected["delta"] = (value_p - value_m)/(2*du);
                  expected["gamma"] = (delta_p - delta_m)/(2*du);

                  // perturb date and get theta
                  /*
                    Time dT = dc.yearFraction(today-1, today+1);
                    Settings::instance().evaluationDate() = today-1;
                    value_m = option.NPV();
                    Settings::instance().evaluationDate() = today+1;
                    value_p = option.NPV();
                    Settings::instance().evaluationDate() = today;
                    expected["theta"] = (value_p - value_m)/dT;
                  */

                  // compare
                  std::map<std::string,Real>::iterator it;
                  for (it = calculated.begin();
                       it != calculated.end(); ++it) {
                    std::string greek = it->first;
                    Real expct = expected  [greek],
                         calcl = calculated[greek],
                         tol   = tolerance [greek];
                    Real error = relativeError(expct,calcl,u);
                    if (error>tol) {
                        REPORT_FAILURE(greek, payoff, exercise,
                                       u, q, r, today, v,
                                       expct, calcl, error, tol);
                    }
                  }
                }
              }
            }
          }
        }
    }
}

for (Size i=0; i<LENGTH(lengths); i++) {
Date exDate = today + lengths[i]*Years;
boost::shared_ptr<Exercise> exercise(new EuropeanExercise(exDate));
testFdGreeks<FDDividendEuropeanEngine<CrankNicolson> >(today,exercise);
}

for (Size i=0; i<LENGTH(lengths); i++) {
Date exDate = today + lengths[i]*Years;
boost::shared_ptr<Exercise> exercise(
                                  new AmericanExercise(today,exDate));
testFdGreeks<FDDividendAmericanEngine<CrankNicolson> >(today,exercise);
}

for (Size i=0; i<=6; i++) {

    dividends.push_back(0.0);
    dividendDates.push_back(today+i);

    DividendVanillaOption option(payoff, exercise,
                                 dividendDates, dividends);
    option.setPricingEngine(engine);
    Real value = option.NPV();

    if (std::fabs(refValue-value) > tolerance)
        BOOST_FAIL("NPV changed by null dividend :\n"
                   << "    previous value: " << value << "\n"
                   << "    current value:  " << refValue << "\n"
                   << "    change:         " << value-refValue);
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/swingoption.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size n=0; n < LENGTH(f); ++n) {
ExtendedOrnsteinUhlenbeckProcess refProcess(
    speed, vol, 0.0, f[n], 
    ExtendedOrnsteinUhlenbeckProcess::GaussLobatto, 1e-6);

for (Size i=0; i < LENGTH(discr)-1; ++i) {
    ExtendedOrnsteinUhlenbeckProcess eouProcess(
                              speed, vol, 0.0, f[n], discr[i]);

    const Time T = 10;
    const Size nTimeSteps = 10000;

    const Time dt = T/nTimeSteps;
    Time t  = 0.0;
    Real q = 0.0;
    Real p = 0.0;
    
    PseudoRandom::rng_type rng(PseudoRandom::urng_type(1234u));

    for (Size j=0; j < nTimeSteps; ++j) {
        const Real dw = rng.next().value;
        q=eouProcess.evolve(t,q,dt,dw);
        p=refProcess.evolve(t,p,dt,dw);

        if (std::fabs(q-p) > 1e-6) {
            BOOST_FAIL("invalid process evaluation " 
                        << n << " " << i << " " << j << " " << q-p);
        }
        t+=dt;
    }
}
}

for (Size i=0; i < n; ++i) {
dw[0] = mt.next().value;
dw[1] = mt.next().value;
dw[2] = mt.next().value;
path[i] = (x = jumpProcess->evolve(0.0, x, dt, dw))[1];
}

for (Real x=1e-12; x < 1.0; x*=10) {
const Real v = mesher.jumpSizeDistribution(x);

std::vector<Real>::iterator iter
    = std::lower_bound(path.begin(), path.end(), x);
const Real q = std::distance(path.begin(), iter)/Real(n);
QL_REQUIRE(std::fabs(q - v) < relTol1
           || ((v < threshold) && std::fabs(q-v) < relTol2),
            "can not reproduce jump distribution");
}

for (Size n=0; n < nrTrails; ++n) {
sample_type path = generator.next();

const Real x = path.value[0].back();
const Real y = path.value[1].back();

const Real cashflow = (*payoff)(std::exp(x+y));
npv.add(cashflow*rTS->discount(maturity));
}

for (Size i=0; i < exerciseDates.size(); ++i) {
const Size exerciseRights = i+1;

VanillaSwingOption swingOption(forward, swingExercise,
		                       0, exerciseRights);
swingOption.setPricingEngine(engine);
const Real swingOptionPrice = swingOption.NPV();

const Real upperBound = exerciseRights*bermudanOptionPrices;

if (swingOptionPrice - upperBound > 2e-2) {
    BOOST_ERROR("Failed to reproduce upper bounds"
                << "\n    upper Bound: " << upperBound
                << "\n    Price:       " << swingOptionPrice);
}

Real lowerBound = 0.0;
for (Size j=exerciseDates.size()-i-1; j < exerciseDates.size(); ++j) {
    VanillaOption europeanOption(payoff, boost::shared_ptr<Exercise>(
                             new EuropeanExercise(exerciseDates[j])));
    europeanOption.setPricingEngine(
        boost::shared_ptr<PricingEngine>(
                                  new AnalyticEuropeanEngine(process)));
    lowerBound += europeanOption.NPV();
}

if (lowerBound - swingOptionPrice > 2e-2) {
    BOOST_ERROR("Failed to reproduce lower bounds"
                << "\n    lower Bound: " << lowerBound
                << "\n    Price:       " << swingOptionPrice);
}
}

for (Size i=0; i < exerciseTimes.size(); ++i) {
exerciseTimes[i]
         = dayCounter.yearFraction(settlementDate, exerciseDates[i]);
}

for (Size i=0; i < exerciseIndex.size(); ++i) {
exerciseIndex[i] = grid.closestIndex(exerciseTimes[i]);
}

for (Size i=0; i < exerciseDates.size(); ++i) {
const Size exerciseRights = i+1;

VanillaSwingOption swingOption(forward, swingExercise,
                               0, exerciseRights);
swingOption.setPricingEngine(swingEngine);
const Real swingOptionPrice = swingOption.NPV();

const Real upperBound = exerciseRights*bermudanOptionPrices;

if (swingOptionPrice - upperBound > 2e-2) {
    BOOST_ERROR("Failed to reproduce upper bounds"
                << "\n    upper Bound: " << upperBound
                << "\n    Price:       " << swingOptionPrice);
}

Real lowerBound = 0.0;
for (Size j=exerciseDates.size()-i-1; j < exerciseDates.size(); ++j) {
    VanillaOption europeanOption(payoff, boost::shared_ptr<Exercise>(
                             new EuropeanExercise(exerciseDates[j])));
    europeanOption.setPricingEngine(
        boost::shared_ptr<PricingEngine>(vanillaEngine));
    lowerBound += europeanOption.NPV();
}

if (lowerBound - swingOptionPrice > 2e-2) {
    BOOST_ERROR("Failed to reproduce lower bounds"
               << "\n    lower Bound: " << lowerBound
               << "\n    Price:       " << swingOptionPrice);
}

// use MC plus perfect forecast to find an upper bound
GeneralStatistics npv;
for (Size n=0; n < nrTrails; ++n) {
    sample_type path = generator.next();

    std::vector<Real> exerciseValues(exerciseTimes.size());
    for (Size k=0; k < exerciseTimes.size(); ++k) {
        const Real x = path.value[0][exerciseIndex[k]];
        const Real y = path.value[1][exerciseIndex[k]];
        const Real s = std::exp(x+y);

        exerciseValues[k] =(*payoff)(s)*rTS->discount(exerciseDates[k]);
    }
    std::sort(exerciseValues.begin(), exerciseValues.end(),
              std::greater<Real>());

    Real npCashFlows
        = std::accumulate(exerciseValues.begin(),
                          exerciseValues.begin()+exerciseRights, Real(0.0));
    npv.add(npCashFlows);
}

const Real mcUpperBound = npv.mean();
const Real mcErrorUpperBound = npv.errorEstimate();
if (swingOptionPrice - mcUpperBound > 2.36*mcErrorUpperBound) {
    BOOST_ERROR("Failed to reproduce mc upper bounds"
               << "\n    mc upper Bound: " << mcUpperBound
               << "\n    Price:          " << swingOptionPrice);
}
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/quantooption.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i<LENGTH(values); i++) {

boost::shared_ptr<StrikedTypePayoff> payoff(
            new PlainVanillaPayoff(values[i].type, values[i].strike));
Date exDate = today + Integer(values[i].t*360+0.5);
boost::shared_ptr<Exercise> exercise(new EuropeanExercise(exDate));

spot ->setValue(values[i].s);
qRate->setValue(values[i].q);
rRate->setValue(values[i].r);
vol  ->setValue(values[i].v);

fxRate->setValue(values[i].fxr);
fxVol->setValue(values[i].fxv);
correlation->setValue(values[i].corr);

QuantoVanillaOption option(payoff, exercise);
option.setPricingEngine(engine);

Real calculated = option.NPV();
Real error = std::fabs(calculated-values[i].result);
Real tolerance = 1e-4;
if (error>tolerance) {
    QUANTO_REPORT_FAILURE("value", payoff, exercise, values[i].s,
                   values[i].q, values[i].r, today,
                   values[i].v, values[i].fxr, values[i].fxv,
                   values[i].corr, values[i].result, calculated,
                   error, tolerance);
}
}

for (Size i=0; i<LENGTH(types); i++) {
for (Size j=0; j<LENGTH(strikes); j++) {
for (Size k=0; k<LENGTH(lengths); k++) {

  Date exDate = today + lengths[k]*Years;
  boost::shared_ptr<Exercise> exercise(new EuropeanExercise(exDate));

  boost::shared_ptr<StrikedTypePayoff> payoff(
                        new PlainVanillaPayoff(types[i], strikes[j]));

  QuantoVanillaOption option(payoff, exercise);
  option.setPricingEngine(engine);

  for (Size l=0; l<LENGTH(underlyings); l++) {
    for (Size m=0; m<LENGTH(qRates); m++) {
      for (Size n=0; n<LENGTH(rRates); n++) {
        for (Size p=0; p<LENGTH(vols); p++) {
          for (Size a=0; a<LENGTH(rRates); a++) {
            for (Size b=0; b<LENGTH(vols); b++) {
              for (Size c=0; c<LENGTH(correlations); c++) {

                Real u = underlyings[l];
                Rate q = qRates[m],
                     r = rRates[n];
                Volatility v = vols[p];
                Rate fxr = rRates[a];
                Volatility fxv = vols[b];
                Rate corr = correlations[c];
                spot->setValue(u);
                qRate->setValue(q);
                rRate->setValue(r);
                vol->setValue(v);
                fxRate->setValue(fxr);
                fxVol->setValue(fxv);
                correlation->setValue(corr);

                Real value = option.NPV();
                calculated["delta"]   = option.delta();
                calculated["gamma"]   = option.gamma();
                calculated["theta"]   = option.theta();
                calculated["rho"]     = option.rho();
                calculated["divRho"]  = option.dividendRho();
                calculated["vega"]    = option.vega();
                calculated["qrho"]    = option.qrho();
                calculated["qvega"]   = option.qvega();
                calculated["qlambda"] = option.qlambda();

                if (value > spot->value()*1.0e-5) {
                  // perturb spot and get delta and gamma
                  Real du = u*1.0e-4;
                  spot->setValue(u+du);
                  Real value_p = option.NPV(),
                       delta_p = option.delta();
                  spot->setValue(u-du);
                  Real value_m = option.NPV(),
                       delta_m = option.delta();
                  spot->setValue(u);
                  expected["delta"] = (value_p - value_m)/(2*du);
                  expected["gamma"] = (delta_p - delta_m)/(2*du);

                  // perturb rates and get rho and dividend rho
                  Spread dr = r*1.0e-4;
                  rRate->setValue(r+dr);
                  value_p = option.NPV();
                  rRate->setValue(r-dr);
                  value_m = option.NPV();
                  rRate->setValue(r);
                  expected["rho"] = (value_p - value_m)/(2*dr);

                  Spread dq = q*1.0e-4;
                  qRate->setValue(q+dq);
                  value_p = option.NPV();
                  qRate->setValue(q-dq);
                  value_m = option.NPV();
                  qRate->setValue(q);
                  expected["divRho"] = (value_p - value_m)/(2*dq);

                  // perturb volatility and get vega
                  Volatility dv = v*1.0e-4;
                  vol->setValue(v+dv);
                  value_p = option.NPV();
                  vol->setValue(v-dv);
                  value_m = option.NPV();
                  vol->setValue(v);
                  expected["vega"] = (value_p - value_m)/(2*dv);

                  // perturb fx rate and get qrho
                  Spread dfxr = fxr*1.0e-4;
                  fxRate->setValue(fxr+dfxr);
                  value_p = option.NPV();
                  fxRate->setValue(fxr-dfxr);
                  value_m = option.NPV();
                  fxRate->setValue(fxr);
                  expected["qrho"] = (value_p - value_m)/(2*dfxr);

                  // perturb fx volatility and get qvega
                  Volatility dfxv = fxv*1.0e-4;
                  fxVol->setValue(fxv+dfxv);
                  value_p = option.NPV();
                  fxVol->setValue(fxv-dfxv);
                  value_m = option.NPV();
                  fxVol->setValue(fxv);
                  expected["qvega"] = (value_p - value_m)/(2*dfxv);

                  // perturb correlation and get qlambda
                  Real dcorr = corr*1.0e-4;
                  correlation->setValue(corr+dcorr);
                  value_p = option.NPV();
                  correlation->setValue(corr-dcorr);
                  value_m = option.NPV();
                  correlation->setValue(corr);
                  expected["qlambda"] = (value_p - value_m)/(2*dcorr);

                  // perturb date and get theta
                  Time dT = dc.yearFraction(today-1, today+1);
                  Settings::instance().evaluationDate() = today-1;
                  value_m = option.NPV();
                  Settings::instance().evaluationDate() = today+1;
                  value_p = option.NPV();
                  Settings::instance().evaluationDate() = today;
                  expected["theta"] = (value_p - value_m)/dT;

                  // compare
                  std::map<std::string,Real>::iterator it;
                  for (it = calculated.begin();
                       it != calculated.end(); ++it) {
                      std::string greek = it->first;
                      Real expct = expected  [greek],
                           calcl = calculated[greek],
                           tol   = tolerance [greek];
                      Real error = relativeError(expct,calcl,u);
                      if (error>tol) {
                          QUANTO_REPORT_FAILURE(greek, payoff, exercise,
                                         u, q, r, today, v,
                                         fxr, fxv, corr,
                                         expct, calcl, error, tol);
                      }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}
}
}

for (Size i=0; i<LENGTH(values); i++) {

boost::shared_ptr<StrikedTypePayoff> payoff(
                         new PlainVanillaPayoff(values[i].type, 0.0));
Date exDate = today + Integer(values[i].t*360+0.5);
boost::shared_ptr<Exercise> exercise(new EuropeanExercise(exDate));
Date reset = today + Integer(values[i].start*360+0.5);

spot ->setValue(values[i].s);
qRate->setValue(values[i].q);
rRate->setValue(values[i].r);
vol  ->setValue(values[i].v);

fxRate->setValue(values[i].fxr);
fxVol->setValue(values[i].fxv);
correlation->setValue(values[i].corr);

QuantoForwardVanillaOption option(values[i].moneyness, reset,
                                  payoff, exercise);
option.setPricingEngine(engine);

Real calculated = option.NPV();
Real error = std::fabs(calculated-values[i].result);
Real tolerance = 1e-4;
if (error>tolerance) {
    QUANTO_FORWARD_REPORT_FAILURE("value", payoff, values[i].moneyness,
                    exercise, values[i].s,
                    values[i].q, values[i].r, today, reset,
                    values[i].v, values[i].fxr, values[i].fxv,
                    values[i].corr, values[i].result, calculated,
                    error, tolerance);
}
}

for (Size i=0; i<LENGTH(types); i++) {
for (Size j=0; j<LENGTH(moneyness); j++) {
for (Size k=0; k<LENGTH(lengths); k++) {
  for (Size h=0; h<LENGTH(startMonths); h++) {

    Date exDate = today + lengths[k]*Years;
    boost::shared_ptr<Exercise> exercise(new EuropeanExercise(exDate));

    Date reset = today + startMonths[h]*Months;

    boost::shared_ptr<StrikedTypePayoff> payoff(
                               new PlainVanillaPayoff(types[i], 0.0));

    QuantoForwardVanillaOption option(moneyness[j], reset,
                                      payoff, exercise);
    option.setPricingEngine(engine);

    for (Size l=0; l<LENGTH(underlyings); l++) {
      for (Size m=0; m<LENGTH(qRates); m++) {
        for (Size n=0; n<LENGTH(rRates); n++) {
          for (Size p=0; p<LENGTH(vols); p++) {
            for (Size a=0; a<LENGTH(rRates); a++) {
              for (Size b=0; b<LENGTH(vols); b++) {
                for (Size c=0; c<LENGTH(correlations); c++) {

                  Real u = underlyings[l];
                  Rate q = qRates[m],
                       r = rRates[n];
                  Volatility v = vols[p];
                  Rate fxr = rRates[a];
                  Volatility fxv = vols[b];
                  Real corr = correlations[c];
                  spot->setValue(u);
                  qRate->setValue(q);
                  rRate->setValue(r);
                  vol->setValue(v);
                  fxRate->setValue(fxr);
                  fxVol->setValue(fxv);
                  correlation->setValue(corr);

                  Real value = option.NPV();
                  calculated["delta"]   = option.delta();
                  calculated["gamma"]   = option.gamma();
                  calculated["theta"]   = option.theta();
                  calculated["rho"]     = option.rho();
                  calculated["divRho"]  = option.dividendRho();
                  calculated["vega"]    = option.vega();
                  calculated["qrho"]    = option.qrho();
                  calculated["qvega"]   = option.qvega();
                  calculated["qlambda"] = option.qlambda();

                  if (value > spot->value()*1.0e-5) {
                    // perturb spot and get delta and gamma
                    Real du = u*1.0e-4;
                    spot->setValue(u+du);
                    Real value_p = option.NPV(),
                         delta_p = option.delta();
                    spot->setValue(u-du);
                    Real value_m = option.NPV(),
                         delta_m = option.delta();
                    spot->setValue(u);
                    expected["delta"] = (value_p - value_m)/(2*du);
                    expected["gamma"] = (delta_p - delta_m)/(2*du);

                    // perturb rates and get rho and dividend rho
                    Spread dr = r*1.0e-4;
                    rRate->setValue(r+dr);
                    value_p = option.NPV();
                    rRate->setValue(r-dr);
                    value_m = option.NPV();
                    rRate->setValue(r);
                    expected["rho"] = (value_p - value_m)/(2*dr);

                    Spread dq = q*1.0e-4;
                    qRate->setValue(q+dq);
                    value_p = option.NPV();
                    qRate->setValue(q-dq);
                    value_m = option.NPV();
                    qRate->setValue(q);
                    expected["divRho"] = (value_p - value_m)/(2*dq);

                    // perturb volatility and get vega
                    Volatility dv = v*1.0e-4;
                    vol->setValue(v+dv);
                    value_p = option.NPV();
                    vol->setValue(v-dv);
                    value_m = option.NPV();
                    vol->setValue(v);
                    expected["vega"] = (value_p - value_m)/(2*dv);

                    // perturb fx rate and get qrho
                    Spread dfxr = fxr*1.0e-4;
                    fxRate->setValue(fxr+dfxr);
                    value_p = option.NPV();
                    fxRate->setValue(fxr-dfxr);
                    value_m = option.NPV();
                    fxRate->setValue(fxr);
                    expected["qrho"] = (value_p - value_m)/(2*dfxr);

                    // perturb fx volatility and get qvega
                    Volatility dfxv = fxv*1.0e-4;
                    fxVol->setValue(fxv+dfxv);
                    value_p = option.NPV();
                    fxVol->setValue(fxv-dfxv);
                    value_m = option.NPV();
                    fxVol->setValue(fxv);
                    expected["qvega"] = (value_p - value_m)/(2*dfxv);

                    // perturb correlation and get qlambda
                    Real dcorr = corr*1.0e-4;
                    correlation->setValue(corr+dcorr);
                    value_p = option.NPV();
                    correlation->setValue(corr-dcorr);
                    value_m = option.NPV();
                    correlation->setValue(corr);
                    expected["qlambda"] =
                        (value_p - value_m)/(2*dcorr);

                    // perturb date and get theta
                    Time dT = dc.yearFraction(today-1, today+1);
                    Settings::instance().evaluationDate() = today-1;
                    value_m = option.NPV();
                    Settings::instance().evaluationDate() = today+1;
                    value_p = option.NPV();
                    Settings::instance().evaluationDate() = today;
                    expected["theta"] = (value_p - value_m)/dT;

                    // compare
                    std::map<std::string,Real>::iterator it;
                    for (it = calculated.begin();
                         it != calculated.end(); ++it) {
                      std::string greek = it->first;
                      Real expct = expected  [greek],
                           calcl = calculated[greek],
                           tol   = tolerance [greek];
                      Real error = relativeError(expct,calcl,u);
                      if (error>tol) {
                          QUANTO_FORWARD_REPORT_FAILURE(greek, payoff,
                              moneyness[j],
                              exercise, u, q, r, today, reset, v, fxr,
                              fxv, corr, expct, calcl, error, tol);
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}
}
}

for (Size i=0; i<LENGTH(values); i++) {

boost::shared_ptr<StrikedTypePayoff> payoff(
//                               new PercentageStrikePayoff(values[i].type, values[i].moneyness));
                         new PlainVanillaPayoff(values[i].type, 0.0));
Date exDate = today + Integer(values[i].t*360+0.5);
boost::shared_ptr<Exercise> exercise(new EuropeanExercise(exDate));
Date reset = today + Integer(values[i].start*360+0.5);

spot ->setValue(values[i].s);
qRate->setValue(values[i].q);
rRate->setValue(values[i].r);
vol  ->setValue(values[i].v);

fxRate->setValue(values[i].fxr);
fxVol->setValue(values[i].fxv);
correlation->setValue(values[i].corr);

QuantoForwardVanillaOption option(values[i].moneyness, reset,
                                  payoff, exercise);
option.setPricingEngine(engine);

Real calculated = option.NPV();
Real error = std::fabs(calculated-values[i].result);
Real tolerance = 1e-4;
if (error>tolerance) {
    QUANTO_FORWARD_REPORT_FAILURE("value", payoff, values[i].moneyness,
        exercise,
        values[i].s, values[i].q, values[i].r, today, reset,
        values[i].v, values[i].fxr, values[i].fxv, values[i].corr,
        values[i].result, calculated, error, tolerance);
}
}

for (Size i=0; i<LENGTH(values); i++) {

boost::shared_ptr<StrikedTypePayoff> payoff(
            new PlainVanillaPayoff(values[i].type, values[i].strike));

Date exDate = today + Integer(values[i].t*360+0.5);
boost::shared_ptr<Exercise> exercise(new EuropeanExercise(exDate));

spot ->setValue(values[i].s);
qRate->setValue(values[i].q);
rRate->setValue(values[i].r);
vol  ->setValue(values[i].v);

fxRate->setValue(values[i].fxr);
fxVol->setValue(values[i].fxv);
correlation->setValue(values[i].corr);

QuantoBarrierOption option(values[i].barrierType,
                           values[i].barrier,
                           values[i].rebate,
                           payoff,
                           exercise);

option.setPricingEngine(engine);

Real calculated = option.NPV();
Real error = std::fabs(calculated-values[i].result);
Real tolerance = values[i].tol;

if (error>tolerance) {
    QUANTO_BARRIER_REPORT_FAILURE("value", payoff,
        values[i].barrierType,
        values[i].barrier,
        values[i].rebate,
        exercise,
        values[i].s, values[i].q, values[i].r, today,
        values[i].v, values[i].fxr, values[i].fxv, values[i].corr,
        values[i].result, calculated, error, tolerance);
}
}

for (Size i=0; i<LENGTH(values); i++) {

boost::shared_ptr<StrikedTypePayoff> payoff(
            new PlainVanillaPayoff(values[i].type, values[i].strike));

Date exDate = today + Integer(values[i].t*360+0.5);
boost::shared_ptr<Exercise> exercise(new EuropeanExercise(exDate));

spot ->setValue(values[i].s);
qRate->setValue(values[i].q);
rRate->setValue(values[i].r);
vol  ->setValue(values[i].v);

fxRate->setValue(values[i].fxr);
fxVol->setValue(values[i].fxv);
correlation->setValue(values[i].corr);

QuantoDoubleBarrierOption option(values[i].barrierType,
                           values[i].barrier_lo,
                           values[i].barrier_hi,
                           values[i].rebate,
                           payoff,
                           exercise);

option.setPricingEngine(engine);

Real calculated = option.NPV();
Real error = std::fabs(calculated-values[i].result);
Real tolerance = values[i].tol;

if (error>tolerance) {
    QUANTO_DOUBLE_BARRIER_REPORT_FAILURE("value", payoff,
        values[i].barrierType,
        values[i].barrier_lo,
        values[i].barrier_hi,
        values[i].rebate,
        exercise,
        values[i].s, values[i].q, values[i].r, today,
        values[i].v, values[i].fxr, values[i].fxv, values[i].corr,
        values[i].result, calculated, error, tolerance);
}
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/swap.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i<LENGTH(lengths); i++) {
for (Size j=0; j<LENGTH(spreads); j++) {

    boost::shared_ptr<VanillaSwap> swap =
        vars.makeSwap(lengths[i],0.0,spreads[j]);
    swap = vars.makeSwap(lengths[i],swap->fairRate(),spreads[j]);
    if (std::fabs(swap->NPV()) > 1.0e-10) {
        BOOST_ERROR("recalculating with implied rate:\n"
                    << std::setprecision(2)
                    << "    length: " << lengths[i] << " years\n"
                    << "    floating spread: "
                    << io::rate(spreads[j]) << "\n"
                    << "    swap value: " << swap->NPV());
    }
}
}

for (Size i=0; i<LENGTH(lengths); i++) {
for (Size j=0; j<LENGTH(rates); j++) {

    boost::shared_ptr<VanillaSwap> swap =
        vars.makeSwap(lengths[i],rates[j],0.0);
    swap = vars.makeSwap(lengths[i],rates[j],swap->fairSpread());
    if (std::fabs(swap->NPV()) > 1.0e-10) {
        BOOST_ERROR("recalculating with implied spread:\n"
                    << std::setprecision(2)
                    << "    length: " << lengths[i] << " years\n"
                    << "    fixed rate: " << io::rate(rates[j]) << "\n"
                    << "    swap value: " << swap->NPV());
    }
}
}

for (Size i=0; i<LENGTH(lengths); i++) {
for (Size j=0; j<LENGTH(spreads); j++) {
    // store the results for different rates...
    std::vector<Real> swap_values;
    for (Size k=0; k<LENGTH(rates); k++) {
        boost::shared_ptr<VanillaSwap> swap =
            vars.makeSwap(lengths[i],rates[k],spreads[j]);
        swap_values.push_back(swap->NPV());
    }
    // and check that they go the right way
    std::vector<Real>::iterator it =
        std::adjacent_find(swap_values.begin(),swap_values.end(),
                           std::less<Real>());
    if (it != swap_values.end()) {
        Size n = it - swap_values.begin();
        BOOST_ERROR(
            "NPV is increasing with the fixed rate in a swap: \n"
            << "    length: " << lengths[i] << " years\n"
            << "    value:  " << swap_values[n]
            << " paying fixed rate: " << io::rate(rates[n]) << "\n"
            << "    value:  " << swap_values[n+1]
            << " paying fixed rate: " << io::rate(rates[n+1]));
    }
}
}

for (Size i=0; i<LENGTH(lengths); i++) {
for (Size j=0; j<LENGTH(rates); j++) {
    // store the results for different spreads...
    std::vector<Real> swap_values;
    for (Size k=0; k<LENGTH(spreads); k++) {
        boost::shared_ptr<VanillaSwap> swap =
            vars.makeSwap(lengths[i],rates[j],spreads[k]);
        swap_values.push_back(swap->NPV());
    }
    // and check that they go the right way
    std::vector<Real>::iterator it =
        std::adjacent_find(swap_values.begin(),swap_values.end(),
                           std::greater<Real>());
    if (it != swap_values.end()) {
        Size n = it - swap_values.begin();
        BOOST_ERROR(
            "NPV is decreasing with the floating spread in a swap: \n"
            << "    length: " << lengths[i] << " years\n"
            << "    value:  " << swap_values[n]
            << " receiving spread: " << io::rate(spreads[n]) << "\n"
            << "    value:  " << swap_values[n+1]
            << " receiving spread: " << io::rate(spreads[n+1]));
    }
}
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/batesmodel.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i = 0; i < options.size(); ++i) {
    const Real diff = options[i]->calibrationError()*100.0;
    sse += diff*diff;
}

for (Integer i=1; i<=5; i+=2) {
Date exerciseDate = settlementDate + i*Years;
boost::shared_ptr<Exercise> exercise(
    new EuropeanExercise(exerciseDate));

VanillaOption batesOption(payoff, exercise);

batesOption.setPricingEngine(batesEngine);
Real calculated = batesOption.NPV();

batesOption.setPricingEngine(mcBatesEngine);
Real mcCalculated = batesOption.NPV();

EuropeanOption mertonOption(payoff, exercise);
mertonOption.setPricingEngine(mertonEngine);
Real expected = mertonOption.NPV();

Real tolerance = 2e-8;
Real relError = std::fabs(calculated - expected)/expected;
if (relError > tolerance) {
    BOOST_FAIL("failed to reproduce Merton76 price with semi "
               "analytic BatesEngine"
               << QL_FIXED << std::setprecision(8)
               << "\n    calculated: " << calculated
               << "\n    expected:   " << expected
               << "\n    rel. error: " << relError
               << "\n    tolerance:  " << tolerance);
}

Real mcError = std::fabs(expected - mcCalculated);
if (mcError > 3*mcTol) {
    BOOST_FAIL("failed to reproduce Merton76 price with Monte-Carlo "
               "BatesEngine"
               << QL_FIXED << std::setprecision(8)
               << "\n    calculated: " << mcCalculated
               << "\n    expected:   " << expected
               << "\n    error: "      << mcError
               << "\n    tolerance:  " << mcTol);
}
}

for (Size i=0; i < LENGTH(hestonModels); ++i) { 
Handle<YieldTermStructure> riskFreeTS(flatRate(hestonModels[i].r, 
                                               dayCounter));
Handle<YieldTermStructure> dividendTS(flatRate(hestonModels[i].q, 
                                               dayCounter));
Handle<Quote> s0(boost::shared_ptr<Quote>(new SimpleQuote(100)));

boost::shared_ptr<BatesProcess> batesProcess(new BatesProcess(
               riskFreeTS, dividendTS, s0,
               hestonModels[i].v0, 
               hestonModels[i].kappa, 
               hestonModels[i].theta, 
               hestonModels[i].sigma, 
               hestonModels[i].rho, 2.0, -0.2, 0.1));

const Real mcTolerance = 0.5;
boost::shared_ptr<PricingEngine> mcEngine =
        MakeMCEuropeanHestonEngine<PseudoRandom>(batesProcess)
        .withStepsPerYear(20)
        .withAntitheticVariate()
        .withAbsoluteTolerance(mcTolerance)
        .withSeed(1234);

boost::shared_ptr<BatesModel> batesModel(new BatesModel(batesProcess));    

boost::shared_ptr<PricingEngine> fdEngine(
                    new FdBatesVanillaEngine(batesModel, 50, 100, 30));

boost::shared_ptr<PricingEngine> analyticEngine(
                                     new BatesEngine(batesModel, 160));

VanillaOption option(payoff, exercise);

option.setPricingEngine(mcEngine);
const Real calculated = option.NPV();

option.setPricingEngine(analyticEngine);
const Real expected = option.NPV();

option.setPricingEngine(fdEngine);
const Real fdCalculated = option.NPV();

const Real mcError = std::fabs(calculated - expected);
if (mcError > 3*mcTolerance) {
    BOOST_FAIL("failed to reproduce Monte-Carlo price for BatesEngine"
               << QL_FIXED << std::setprecision(8)
               << "\n    calculated: " << calculated
               << "\n    expected:   " << expected
               << "\n    error: "      << mcError
               << "\n    tolerance:  " << mcTolerance);
}
const Real fdTolerance = 0.2;
const Real fdError = std::fabs(fdCalculated - expected);
if (fdError > fdTolerance) {
    BOOST_FAIL("failed to reproduce PIDE price for BatesEngine"
               << QL_FIXED << std::setprecision(8)
               << "\n    calculated: " << fdCalculated
               << "\n    expected:   " << expected
               << "\n    error: "      << fdError
               << "\n    tolerance:  " << fdTolerance);
}
}

for (Size i = 0; i < 8; ++i) {
dates.push_back(settlementDate + t[i]);
rates.push_back(r[i]);
}

for (Size s = 0; s < 13; ++s) {
for (Size m = 0; m < 8; ++m) {
    Handle<Quote> vol(boost::shared_ptr<Quote>(
                                          new SimpleQuote(v[s*8+m])));

    Period maturity((int)((t[m]+3)/7.), Weeks); // round to weeks

    // this is the calibration helper for the bates models
    // FLOATING_POINT_EXCEPTION
    options.push_back(boost::shared_ptr<CalibrationHelper>(
            new HestonModelHelper(maturity, calendar,
                                  s0->value(), strike[s], vol,
                                  riskFreeTS, dividendTS, 
                                  CalibrationHelper::ImpliedVolError)));
    options.back()->setPricingEngine(batesEngine);
}
}

for (Size i = 0; i < pricingEngines.size(); ++i) {
for (Size j = 0; j < options.size(); ++j) {
    options[j]->setPricingEngine(pricingEngines[i]);
}

Real calculated = std::fabs(getCalibrationError(options));
if (std::fabs(calculated - expectedValues[i]) > tolerance)
    BOOST_ERROR("failed to calculated prices for derived Bates models"
                << "\n    calculated: " << calculated
                << "\n    expected:   " << expectedValues[i]);
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/solvers.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i<LENGTH(accuracy); i++) {
    Real root = solver.solve(f,accuracy[i],guess,0.1);
    if (std::fabs(root-expected) > accuracy[i]) {
        BOOST_FAIL(name << " solver (not bracketed):\n"
                   << "    expected:   " << expected << "\n"
                   << "    calculated: " << root << "\n"
                   << "    accuracy:   " << accuracy[i]);
    }
}

for (Size i=0; i<LENGTH(accuracy); i++) {
    // guess on the left side of the root, increasing function
    Real root = solver.solve(f,accuracy[i],guess,0.0,2.0);
    if (std::fabs(root-expected) > accuracy[i]) {
        BOOST_FAIL(name << " solver (bracketed):\n"
                   << "    expected:   " << expected << "\n"
                   << "    calculated: " << root << "\n"
                   << "    accuracy:   " << accuracy[i]);
    }
}

for (Size i=0; i<4; ++i) {
    if (bracketed) {
        result = solver.solve(Probe(argument, offsets[i]), accuracy,
                              guesses[i], mins[i], maxs[i]);
    } else {
        result = solver.solve(Probe(argument, offsets[i]), accuracy,
                              guesses[i], steps[i]);
    }

    Real error = std::fabs(result-argument);
    // no floating-point comparison: the solver should have
    // called the function with the very same value it's
    // returning
    if (result != argument) {
        BOOST_FAIL(name << " solver ("
                   << (bracketed ? "" : "not ")
                   << "bracketed):\n"
                   << "    index:   " << i << "\n"
                   << "    expected:   " << result << "\n"
                   << "    calculated: " << argument << "\n"
                   << "    error: " << error);
    }
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/libormarketmodelprocess.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i < len; ++i) {
    capletVols.push_back(vols[i]/100);
    dates.push_back(process->fixingDates()[i+1]);
}

for (Integer daysOffset=0; daysOffset < 1825 /* 5 year*/; daysOffset+=8) {
Date todaysDate = calendar.adjust(Date::todaysDate()+daysOffset);
Settings::instance().evaluationDate() = todaysDate;
Date settlementDate =
    calendar.advance(todaysDate, index->fixingDays(), Days);

termStructure.linkTo(flatRate(settlementDate, 0.04, dayCounter));

LiborForwardModelProcess process(60, index);

std::vector<Time> fixings = process.fixingTimes();
for (Size i=1; i < fixings.size()-1; ++i) {
    Size ileft  = process.nextIndexReset(fixings[i]-0.000001);
    Size iright = process.nextIndexReset(fixings[i]+0.000001);
    Size ii     = process.nextIndexReset(fixings[i]);

    if ((ileft != i) || (iright != i+1) || (ii != i+1)) {
        BOOST_ERROR("Failed to next index resets");
    }
}

}

for (Size i=0; i<9; ++i) {
const Real calculated = std::sqrt(covar[i+1][i+1]);
const Real expected   = lambdaExpected[i]/100;

if (std::fabs(calculated - expected) > tolerance)
    BOOST_ERROR("Failed to reproduce expected lambda values"
                << "\n    calculated: " << calculated
                << "\n    expected:   " << expected);
}

for (Size t=0; t<grid.size(); ++t) {
Matrix diff = (param->integratedCovariance(grid[t])
- param->LfmCovarianceParameterization::integratedCovariance(grid[t]));

for (Size i=0; i<diff.rows(); ++i) {
    for (Size j=0; j<diff.columns(); ++j) {
        if (std::fabs(diff[i][j]) > tolerance) {
             BOOST_FAIL("Failed to reproduce integrated covariance" <<
                "\n    i: " << i <<
                "\n    j: " << j <<
                "\nerror: " << diff[i][j]);
        }
    }
}
}

for (i=0; i < tmp.size(); ++i) {
location.push_back(
              std::find(grid.begin(),grid.end(),tmp[i])-grid.begin());
}

for (i=0; i<nrTrails; ++i) {
sample_type path1 = generator1.next();
sample_type path2 = generator2.next();

std::vector<Rate> rates1(len);
std::vector<Rate> rates2(len);
for (Size j=0; j<process1->size(); ++j) {
    rates1[j] = path1.value[j][location[j]];
    rates2[j] = path2.value[j][location[j]];
}

std::vector<DiscountFactor> dis1 = process1->discountBond(rates1);
std::vector<DiscountFactor> dis2 = process2->discountBond(rates2);

for (Size k=0; k<process1->size(); ++k) {
    Real accrualPeriod =  process1->accrualEndTimes()[k]
                        - process1->accrualStartTimes()[k];
    // caplet payoff function, cap rate at 4%
    Real payoff1 = std::max(rates1[k] - 0.04, 0.0) * accrualPeriod;

    Real payoff2 = std::max(rates2[k] - 0.04, 0.0) * accrualPeriod;
    stat1[k].add(dis1[k] * payoff1);
    stat2[k].add(dis2[k] * payoff2);

    if (k != 0) {
        // ratchet cap payoff function
        Real payoff3 =  std::max(rates2[k] - (rates2[k-1]+0.0025), 0.0)
                      * accrualPeriod;
        stat3[k-1].add(dis2[k] * payoff3);
    }
}

}

for (Size k=0; k < process1->size(); ++k) {

Real calculated1 = stat1[k].mean();
Real tolerance1  = stat1[k].errorEstimate();
Real expected    = capletNpv[k];

if (std::fabs(calculated1 - expected) > tolerance1) {
    BOOST_ERROR("Failed to reproduce expected caplet NPV"
                << "\n    calculated: " << calculated1
                << "\n    error int:  " << tolerance1
                << "\n    expected:   " << expected);
}

Real calculated2 = stat2[k].mean();
Real tolerance2  = stat2[k].errorEstimate();

if (std::fabs(calculated2 - expected) > tolerance2) {
    BOOST_ERROR("Failed to reproduce expected caplet NPV"
                << "\n    calculated: " << calculated2
                << "\n    error int:  " << tolerance2
                << "\n    expected:   " << expected);
}

if (k != 0) {
    Real calculated3 = stat3[k-1].mean();
    Real tolerance3  = stat3[k-1].errorEstimate();
    expected    = ratchetNpv[k-1];

    Real refError = 1e-5; // 1e-5. error bars of the reference values

    if (std::fabs(calculated3 - expected) > tolerance3 + refError) {
        BOOST_ERROR("Failed to reproduce expected caplet NPV"
                    << "\n    calculated: " << calculated3
                    << "\n    error int:  " << tolerance3 + refError
                    << "\n    expected:   " << expected);
    }
}
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/markovfunctional.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (int i = 0; i < 10 + 15 + 35; i++) {
    q6m.push_back(boost::shared_ptr<Quote>(new SimpleQuote(q6mh[i])));
}

for (int i = 0; i < 10; i++) {
    r6m.push_back(boost::shared_ptr<DepositRateHelper>(
        new DepositRateHelper(Handle<Quote>(q6m[i]), q6mh1[i],
                              i < 2 ? i : 2, TARGET(),
                              ModifiedFollowing, false, Actual360())));
}

for (int i = 0; i < 18; i++) {
    if (i + 1 != 6 && i + 1 != 12 && i + 1 != 18) {
#ifndef QL_NEGATIVE_RATES
        if (i + 10 != 16 && i + 10 != 17)
#endif
            r6m.push_back(boost::shared_ptr<FraRateHelper>(
                new FraRateHelper(Handle<Quote>(q6m[10 + i]), i + 1,
                                  i + 7, 2, TARGET(), ModifiedFollowing,
                                  false, Actual360())));
    }
}

for (int i = 0; i < 15 + 35; i++) {
    if (i + 7 == 12 || i + 7 == 18 || i + 7 >= 24) {
        r6m.push_back(boost::shared_ptr<SwapRateHelper>(
            new SwapRateHelper(Handle<Quote>(q6m[10 + i]), q6mh2[i],
                               TARGET(), Annual, ModifiedFollowing,
                               Actual360(), euribor6mEmpty)));
    }
}

for (Size i = 0; i < 20; i++)
    optionTenors.push_back(optTen[i]);

for (Size i = 0; i < 14; i++)
    swapTenors.push_back(swpTen[i]);

for (int i = 0; i < 20; i++) {
    std::vector<Handle<Quote> > qSwAtmTmp;
    for (int j = 0; j < 14; j++) {
        qSwAtmTmp.push_back(Handle<Quote>(boost::shared_ptr<Quote>(
            new SimpleQuote(qSwAtmh[i * 14 + j]))));
    }
    qSwAtm.push_back(qSwAtmTmp);
}

for (Size i = 0; i < 6; i++)
    optionTenorsSmile.push_back(optTenSm[i]);

for (Size i = 0; i < 5; i++)
    swapTenorsSmile.push_back(swpTenSm[i]);

for (Size i = 0; i < 9; i++)
    strikeSpreads.push_back(strksp[i]);

for (int i = 0; i < 30; i++) {
    std::vector<Handle<Quote> > qSwSmileTmp;
    for (int j = 0; j < 9; j++) {
        qSwSmileTmp.push_back(Handle<Quote>(boost::shared_ptr<Quote>(
            new SimpleQuote(qSwSmileh[i * 9 + j]))));
    }
    qSwSmile.push_back(qSwSmileTmp);
}

for (int i = 0; i < 30; i++) {
    std::vector<Handle<Quote> > parameterGuessTmp;
    for (int j = 0; j < 4; j++) {
        parameterGuessTmp.push_back(
            Handle<Quote>(boost::shared_ptr<Quote>(
                new SimpleQuote(qSwSmileh1[i * 4 + j]))));
    }
    parameterGuess.push_back(parameterGuessTmp);
}

for (Size i = 0; i < nOptTen; i++)
    optionTenors.push_back(optTen[i]);

for (Size i = 0; i < nStrikes; i++)
    strikes.push_back(strk[i]);

for (Size i = 0; i < nStrikes; i++) {
    for (Size j = 0; j < nOptTen; j++) {
        vols[j][i] = volsa[i][j];
    }
}

for (int i = 1; i <= 5; i++)
    res.push_back(TARGET().advance(referenceDate_, i * Years));

for (Size i = 0; i < prices.size(); i++) {
    result.push_back(blackFormulaImpliedStdDev(Option::Call, strikes[i],
                                               atm, prices[i], 1.0, 0.0,
                                               0.2, 1E-8, 1000));
}

for (Size i = 0; i < strikes.size(); i++) {
money.push_back(strikes[i] / atm);
calls0.push_back(blackFormula(Option::Call, strikes[i], atm,
                              0.50 * std::sqrt(t), 1.0, 0.0));
}

for (Size i = 1; i < strikes.size(); i++) {
Real pric0 = sec1->optionPrice(strikes[i]);
Real pric1 = ksec12->optionPrice(strikes[i]);
if (std::fabs(pric0 - pric1) > tol)
    BOOST_ERROR("smile12 is not reproduced on grid at strike "
                << strikes[i] << " input smile call price is " << pric0
                << " kahale smile call price is " << pric1);
}

for (Size i = 0; i < outputs1.expiries_.size(); i++) {
if (fabs(outputs1.marketZerorate_[i] - outputs1.modelZerorate_[i]) >
    tol0)
    BOOST_ERROR("Basket 1 / flat termstructures : Market zero rate ("
                << outputs1.marketZerorate_[i]
                << ") and model zero rate ("
                << outputs1.modelZerorate_[i] << ") do not agree.");
}

for (Size i = 0; i < outputs1.expiries_.size(); i++) {
for (Size j = 0; j < outputs1.smileStrikes_[i].size(); j++) {
    if (fabs(outputs1.marketCallPremium_[i][j] -
             outputs1.modelCallPremium_[i][j]) > tol1)
        BOOST_ERROR(
            "Basket 1 / flat termstructures : Market call premium ("
            << outputs1.marketCallPremium_[i][j]
            << ") does not match model premium ("
            << outputs1.modelCallPremium_[i][j] << ")");
    if (fabs(outputs1.marketPutPremium_[i][j] -
             outputs1.modelPutPremium_[i][j]) > tol1)
        BOOST_ERROR(
            "Basket 1 / flat termstructures : Market put premium ("
            << outputs1.marketPutPremium_[i][j]
            << ") does not match model premium ("
            << outputs1.modelPutPremium_[i][j] << ")");
}
}

for (Size i = 0; i < outputs2.expiries_.size(); i++) {
if (fabs(outputs2.marketZerorate_[i] - outputs2.modelZerorate_[i]) >
    tol0)
    BOOST_ERROR("Basket 2 / flat termstructures : Market zero rate ("
                << outputs2.marketZerorate_[i]
                << ") and model zero rate ("
                << outputs2.modelZerorate_[i] << ") do not agree.");
}

for (Size i = 0; i < outputs2.expiries_.size(); i++) {
for (Size j = 0; j < outputs2.smileStrikes_[i].size(); j++) {
    if (fabs(outputs2.marketCallPremium_[i][j] -
             outputs2.modelCallPremium_[i][j]) > tol1)
        BOOST_ERROR(
            "Basket 2 / flat termstructures : Market call premium ("
            << outputs2.marketCallPremium_[i][j]
            << ") does not match model premium ("
            << outputs2.modelCallPremium_[i][j] << ")");
    if (fabs(outputs2.marketPutPremium_[i][j] -
             outputs2.modelPutPremium_[i][j]) > tol1)
        BOOST_ERROR(
            "Basket 2/ flat termstructures : Market put premium ("
            << outputs2.marketPutPremium_[i][j]
            << ") does not match model premium ("
            << outputs2.modelPutPremium_[i][j] << ")");
}
}

for (Size i = 0; i < outputs3.expiries_.size(); i++) {
if (fabs(outputs3.marketZerorate_[i] - outputs3.modelZerorate_[i]) >
    tol0)
    BOOST_ERROR("Basket 1 / real termstructures: Market zero rate ("
                << outputs3.marketZerorate_[i]
                << ") and model zero rate ("
                << outputs3.modelZerorate_[i] << ") do not agree.");
}

for (Size i = 0; i < outputs3.expiries_.size(); i++) {
for (Size j = 0; j < outputs3.smileStrikes_[i].size(); j++) {
    if (fabs(outputs3.marketCallPremium_[i][j] -
             outputs3.modelCallPremium_[i][j]) > tol1)
        BOOST_ERROR(
            "Basket 1 / real termstructures: Market call premium ("
            << outputs3.marketCallPremium_[i][j]
            << ") does not match model premium ("
            << outputs3.modelCallPremium_[i][j] << ")");
    if (fabs(outputs3.marketPutPremium_[i][j] -
             outputs3.modelPutPremium_[i][j]) > tol1)
        BOOST_ERROR(
            "Basket 1 /  real termstructures: Market put premium ("
            << outputs3.marketPutPremium_[i][j]
            << ") does not match model premium ("
            << outputs3.modelPutPremium_[i][j] << ")");
}
}

for (Size i = 0; i < outputs4.expiries_.size(); i++) {
if (fabs(outputs4.marketZerorate_[i] - outputs4.modelZerorate_[i]) >
    tol0)
    BOOST_ERROR("Basket 2 / real termstructures : Market zero rate ("
                << outputs4.marketZerorate_[i]
                << ") and model zero rate ("
                << outputs4.modelZerorate_[i] << ") do not agree.");
}

for (Size i = 0; i < outputs4.expiries_.size(); i++) {
for (Size j = 0; j < outputs4.smileStrikes_[i].size(); j++) {
    if (fabs(outputs4.marketCallPremium_[i][j] -
             outputs4.modelCallPremium_[i][j]) > tol1)
        BOOST_ERROR(
            "Basket 2 / real termstructures : Market call premium ("
            << outputs4.marketCallPremium_[i][j]
            << ") does not match model premium ("
            << outputs4.modelCallPremium_[i][j] << ")");
    if (fabs(outputs4.marketPutPremium_[i][j] -
             outputs4.modelPutPremium_[i][j]) > tol1)
        BOOST_ERROR(
            "Basket 2/ real termstructures : Market put premium ("
            << outputs4.marketPutPremium_[i][j]
            << ") does not match model premium ("
            << outputs4.modelPutPremium_[i][j] << ")");
}
}

for (Size i = 0; i < outputs1.expiries_.size(); i++) {
for (Size j = 0; j < outputs1.smileStrikes_[0].size(); j++) {
    boost::shared_ptr<VanillaSwap> underlyingCall =
        MakeVanillaSwap(outputs1.tenors_[i], iborIndex1,
                        outputs1.smileStrikes_[i][j])
            .withEffectiveDate(
                 TARGET().advance(outputs1.expiries_[i], 2, Days))
            .receiveFixed(false);
    boost::shared_ptr<VanillaSwap> underlyingPut =
        MakeVanillaSwap(outputs1.tenors_[i], iborIndex1,
                        outputs1.smileStrikes_[i][j])
            .withEffectiveDate(
                 TARGET().advance(outputs1.expiries_[i], 2, Days))
            .receiveFixed(true);
    boost::shared_ptr<Exercise> exercise(
        new EuropeanExercise(outputs1.expiries_[i]));
    Swaption swaptionC(underlyingCall, exercise);
    Swaption swaptionP(underlyingPut, exercise);
    swaptionC.setPricingEngine(blackSwaptionEngine1);
    swaptionP.setPricingEngine(blackSwaptionEngine1);
    Real blackPriceCall = swaptionC.NPV();
    Real blackPricePut = swaptionP.NPV();
    swaptionC.setPricingEngine(mfSwaptionEngine1);
    swaptionP.setPricingEngine(mfSwaptionEngine1);
    Real mfPriceCall = swaptionC.NPV();
    Real mfPricePut = swaptionP.NPV();
    if (fabs(blackPriceCall - mfPriceCall) > tol1)
        BOOST_ERROR(
            "Basket 1 / flat termstructures: Call premium market ("
            << blackPriceCall << ") does not match model premium ("
            << mfPriceCall << ")");
    if (fabs(blackPricePut - mfPricePut) > tol1)
        BOOST_ERROR(
            "Basket 1 / flat termstructures: Put premium market ("
            << blackPricePut << ") does not match model premium ("
            << mfPricePut << ")");
}
}

for (Size i = 0; i < c2.size(); i++) {
c2[i].setPricingEngine(blackCapFloorEngine2);
Real blackPrice = c2[i].NPV();
c2[i].setPricingEngine(mfCapFloorEngine2);
Real mfPrice = c2[i].NPV();
if (fabs(blackPrice - mfPrice) > tol1)
    BOOST_ERROR(
        "Basket 2 / flat termstructures: Cap/Floor premium market ("
        << blackPrice << ") does not match model premium (" << mfPrice
        << ")");
}

for (Size i = 0; i < outputs3.expiries_.size(); i++) {
for (Size j = 0; j < outputs3.smileStrikes_[0].size(); j++) {
    boost::shared_ptr<VanillaSwap> underlyingCall =
        MakeVanillaSwap(outputs3.tenors_[i], iborIndex3,
                        outputs3.smileStrikes_[i][j])
            .withEffectiveDate(
                 TARGET().advance(outputs3.expiries_[i], 2, Days))
            .receiveFixed(false);
    boost::shared_ptr<VanillaSwap> underlyingPut =
        MakeVanillaSwap(outputs3.tenors_[i], iborIndex3,
                        outputs3.smileStrikes_[i][j])
            .withEffectiveDate(
                 TARGET().advance(outputs3.expiries_[i], 2, Days))
            .receiveFixed(true);
    boost::shared_ptr<Exercise> exercise(
        new EuropeanExercise(outputs3.expiries_[i]));
    Swaption swaptionC(underlyingCall, exercise);
    Swaption swaptionP(underlyingPut, exercise);
    swaptionC.setPricingEngine(blackSwaptionEngine3);
    swaptionP.setPricingEngine(blackSwaptionEngine3);
    Real blackPriceCall = swaptionC.NPV();
    Real blackPricePut = swaptionP.NPV();
    swaptionC.setPricingEngine(mfSwaptionEngine3);
    swaptionP.setPricingEngine(mfSwaptionEngine3);
    Real mfPriceCall = swaptionC.NPV();
    Real mfPricePut = swaptionP.NPV();
    Real smileCorrectionCall =
        (outputs3.marketCallPremium_[i][j] -
         outputs3.marketRawCallPremium_[i][j]); // we can not expect to
                                                // match the black
                                                // scholes price where
                                                // the smile is adjusted
    Real smileCorrectionPut = (outputs3.marketPutPremium_[i][j] -
                               outputs3.marketRawPutPremium_[i][j]);
    if (fabs(blackPriceCall - mfPriceCall + smileCorrectionCall) > tol1)
        BOOST_ERROR(
            "Basket 1 / real termstructures: Call premium market ("
            << blackPriceCall << ") does not match model premium ("
            << mfPriceCall << ")");
    if (fabs(blackPricePut - mfPricePut + smileCorrectionPut) > tol1)
        BOOST_ERROR(
            "Basket 1 / real termstructures: Put premium market ("
            << blackPricePut << ") does not match model premium ("
            << mfPricePut << ")");
}
}

for (Size i = 0; i < c4.size(); i++) {
c4[i].setPricingEngine(blackCapFloorEngine4);
Real blackPrice = c4[i].NPV();
std::vector<Real> blackOptionlets =
    c4[i].result<std::vector<Real> >("optionletsPrice");
c4[i].setPricingEngine(mfCapFloorEngine4);
std::vector<Real> mfOptionlets =
    c4[i].result<std::vector<Real> >("optionletsPrice");
Real mfPrice = c4[i].NPV();
if (fabs(blackPrice - mfPrice) > tol1)
    BOOST_ERROR(
        "Basket 2 / real termstructures: Cap/Floor premium market ("
        << blackPrice << ") does not match model premium (" << mfPrice
        << ")");
}

for (Size i = 0; i < ch1.size(); i++) {
boost::shared_ptr<BlackSwaptionEngine> blackEngine(
    new BlackSwaptionEngine(flatYts_, calibrationHelperVols1[i]));
ch1[i].setPricingEngine(blackEngine);
Real blackPrice = ch1[i].NPV();
Real blackVega = ch1[i].result<Real>("vega");
ch1[i].setPricingEngine(mfSwaptionEngine1);
Real mfPrice = ch1[i].NPV();
if (fabs(blackPrice - mfPrice) / blackVega > tol1)
    BOOST_TEST_MESSAGE("Basket 1 / flat yts, vts: Secondary instrument set "
                  "calibration failed for instrument #"
                  << i << " black premium is " << blackPrice
                  << " while model premium is " << mfPrice
                  << " (market vega is " << blackVega << ")");
}

for (Size i = 0; i < ch2.size(); i++) {
boost::shared_ptr<BlackSwaptionEngine> blackEngine(
    new BlackSwaptionEngine(md0Yts_, calibrationHelperVols2[i]));
ch2[i].setPricingEngine(blackEngine);
Real blackPrice = ch2[i].NPV();
Real blackVega = ch2[i].result<Real>("vega");
ch2[i].setPricingEngine(mfSwaptionEngine2);
Real mfPrice = ch2[i].NPV();
if (fabs(blackPrice - mfPrice) / blackVega > tol1)
    BOOST_TEST_MESSAGE("Basket 1 / real yts, vts: Secondary instrument set "
                  "calibration failed for instrument #"
                  << i << " black premium is " << blackPrice
                  << " while model premium is " << mfPrice
                  << " (market vega is " << blackVega << ")");
}

for (Size i = 0; i < expiries.size(); i++) {
europeanExercises.push_back(
    boost::shared_ptr<Exercise>(new EuropeanExercise(expiries[i])));
europeanSwaptions.push_back(
    Swaption(underlyingCall, europeanExercises[i]));
europeanSwaptions.back().setPricingEngine(mfSwaptionEngine1);
}

for (Size i = 0; i < expiries.size(); i++) {
Real npv = europeanSwaptions[i].NPV();
if (fabs(npv - cachedValues[i]) > tol0)
    BOOST_ERROR("European swaption value ("
                << npv << ") deviates from cached value ("
                << cachedValues[i] << ")");
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/fdmlinearop.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size k=0; k < dim[0]; ++k) {
for (Size l=0; l < dim[1]; ++l) {
    for (Size m=0; m < dim[2]; ++m) {
        std::vector<Size> tmp(3);
        tmp[0] = k; tmp[1] = l; tmp[2] = m;

        Size calculatedIndex = layout.index(tmp);
        Size expectedIndex = k + l*dim[0] + m*dim[0]*dim[1];

        if (expectedIndex != layout.index(tmp)) {
            BOOST_FAIL("index.size() should be " << expectedIndex
                        <<", but is " << calculatedIndex);
        }
    }
}
}

for (Size m=0; m < dim[2]; ++m) {
for (Size l=0; l < dim[1]; ++l) {
    for (Size k=0; k < dim[0]; ++k, ++iter) {
        for (Size n=1; n < 4; ++n) {
            Size nn = layout.neighbourhood(iter, 1, n);
            Size calculatedIndex = k + m*dim[0]*dim[1]
               + ((l < dim[1]-n)? l+n
                                : dim[1]-1-(l+n-(dim[1]-1)))*dim[0];

            if (nn != calculatedIndex) {
                BOOST_FAIL("next neighbourhood index is " << nn
                            << " but should be " << calculatedIndex);
            }
        }

        for (Size n=1; n < 7; ++n) {
            Size nn = layout.neighbourhood(iter, 2, -Integer(n));
            Size calculatedIndex = k + l*dim[0]
                    + ((m < n) ? n-m : m-n)*dim[0]*dim[1];
            if (nn != calculatedIndex) {
                BOOST_FAIL("next neighbourhood index is " << nn
                    << " but should be " << calculatedIndex);
            }
        }
    }
}
}

for (FdmLinearOpIterator iter = index->begin(); iter != endIter; ++iter) {
r[iter.index()] =  std::sin(mesher->location(iter, 0))
                 + std::cos(mesher->location(iter, 2));
}

for (FdmLinearOpIterator iter = index->begin(); iter != endIter; ++iter) {
const Size z = iter.coordinates()[2];

const Size z0 = (z > 0) ? z-1 : 1;
const Size z2 = (z < dims[2]-1) ? z+1 : dims[2]-2;
const Real lz0 = boundaries[2].first + z0*dz;
const Real lz2 = boundaries[2].first + z2*dz;

Real expected;
if (z == 0) {
    expected = (std::cos(boundaries[2].first+dz)
                - std::cos(boundaries[2].first))/dz;
}
else if (z == dim[2]-1) {
    expected = (std::cos(boundaries[2].second)
                - std::cos(boundaries[2].second-dz))/dz;
}
else {
    expected = (std::cos(lz2)-std::cos(lz0))/(2*dz);
}

const Real calculated = t[iter.index()];
if (std::fabs(calculated - expected) > 1e-10) {
    BOOST_FAIL("first derivative calculation failed."
                << "\n    calculated: " << calculated
                << "\n    expected:   " << expected);
}
}

for (FdmLinearOpIterator iter = index->begin(); iter != endIter; ++iter) {
const Real x = mesher->location(iter, 0);
const Real y = mesher->location(iter, 1);
const Real z = mesher->location(iter, 2);

r[iter.index()] = std::sin(x)*std::cos(y)*std::exp(z);
}

for (FdmLinearOpIterator iter = index->begin(); iter != endIter; ++iter) {
const Size i = iter.index();
const Real x = mesher->location(iter, 0);
const Real y = mesher->location(iter, 1);
const Real z = mesher->location(iter, 2);

Real d = -std::sin(x)*std::cos(y)*std::exp(z);
if (iter.coordinates()[0] == 0 || iter.coordinates()[0] == dims[0]-1) {
    d = 0;
}

if (std::fabs(d - t[i]) > tol) {
    BOOST_FAIL("numerical derivative in dx^2 deviation is too big"
        << "\n  found at " << x << " " << y << " " << z);
}
}

for (FdmLinearOpIterator iter = index->begin(); iter != endIter; ++iter) {
const Size i = iter.index();
const Real x = mesher->location(iter, 0);
const Real y = mesher->location(iter, 1);
const Real z = mesher->location(iter, 2);

Real d = -std::sin(x)*std::cos(y)*std::exp(z);
if (iter.coordinates()[1] == 0 || iter.coordinates()[1] == dims[1]-1) {
    d = 0;
}

if (std::fabs(d - t[i]) > tol) {
    BOOST_FAIL("numerical derivative in dy^2 deviation is too big"
        << "\n  found at " << x << " " << y << " " << z);
}
}

for (FdmLinearOpIterator iter = index->begin(); iter != endIter; ++iter) {
const Size i = iter.index();
const Real x = mesher->location(iter, 0);
const Real y = mesher->location(iter, 1);
const Real z = mesher->location(iter, 2);

Real d = std::sin(x)*std::cos(y)*std::exp(z);
if (iter.coordinates()[2] == 0 || iter.coordinates()[2] == dims[2]-1) {
    d = 0;
}

if (std::fabs(d - t[i]) > tol) {
    BOOST_FAIL("numerical derivative in dz^2 deviation is too big"
        << "\n  found at " << x << " " << y << " " << z);
}
}

for (Size direction=0; direction < 3; ++direction) {

const SparseMatrix dfdx
    = FirstDerivativeOp(direction, meshers).toMatrix();
const SparseMatrix d2fdx2
    = SecondDerivativeOp(direction, meshers).toMatrix();

const Array gridPoints = meshers->locations(direction);

for (FdmLinearOpIterator iter=layout->begin();
    iter != endIter; ++iter) {

    const Size c = iter.coordinates()[direction];
    const Size index   = iter.index();
    const Size indexM1 = layout->neighbourhood(iter,direction,-1);
    const Size indexP1 = layout->neighbourhood(iter,direction,+1);

    // test only if not on the boundary
    if (c == 0) {
        Array twoPoints(2);
        twoPoints[0] = 0.0;
        twoPoints[1] = gridPoints.at(indexP1)-gridPoints.at(index);

        const Array ndWeights1st = NumericalDifferentiation(
            boost::function<Real(Real)>(), 1 , twoPoints).weights();

        const Real beta1  = dfdx(index, index);
        const Real gamma1 = dfdx(index, indexP1);
        if (   std::fabs((beta1  - ndWeights1st.at(0))/beta1) > tol
            || std::fabs((gamma1 - ndWeights1st.at(1))/gamma1) > tol) {
            BOOST_FAIL("can not reproduce the weights of the "
                       "first order derivative operator "
                       "on the lower boundary"
                    << "\n expected beta:    " << ndWeights1st.at(0)
                    << "\n calculated beta:  " << beta1
                    << "\n difference beta:  "
                    << beta1 - ndWeights1st.at(0)
                    << "\n expected gamma:   " << ndWeights1st.at(1)
                    << "\n calculated gamma: " << gamma1
                    << "\n difference gamma: "
                    << gamma1 - ndWeights1st.at(1));
        }

        // free boundary condition by default
        const Real beta2  = d2fdx2(index, index);
        const Real gamma2 = d2fdx2(index, indexP1);

        if (   std::fabs(beta2)  > QL_EPSILON
            || std::fabs(gamma2) > QL_EPSILON) {
            BOOST_FAIL("can not reproduce the weights of the "
                       "second order derivative operator "
                       "on the lower boundary"
                    << "\n expected beta:    " << 0.0
                    << "\n calculated beta:  " << beta2
                    << "\n expected gamma:   " << 0.0
                    << "\n calculated gamma: " << gamma2);
        }
    }
    else if (c == layout->dim()[direction]-1) {
        Array twoPoints(2);
        twoPoints[0] = gridPoints.at(indexM1)-gridPoints.at(index);
        twoPoints[1] = 0.0;

        const Array ndWeights1st = NumericalDifferentiation(
            boost::function<Real(Real)>(), 1 , twoPoints).weights();

        const Real alpha1 = dfdx(index, indexM1);
        const Real beta1  = dfdx(index, index);
        if (   std::fabs((alpha1 - ndWeights1st.at(0))/alpha1) > tol
            || std::fabs((beta1  - ndWeights1st.at(1))/beta1) > tol) {
            BOOST_FAIL("can not reproduce the weights of the "
                       "first order derivative operator "
                       "on the upper boundary"
                    << "\n expected alpha:   " << ndWeights1st.at(0)
                    << "\n calculated alpha: " << alpha1
                    << "\n difference alpha: "
                    << alpha1 - ndWeights1st.at(0)
                    << "\n expected beta:    " << ndWeights1st.at(1)
                    << "\n calculated beta:  " << beta1
                    << "\n difference beta:  "
                    << beta1 - ndWeights1st.at(1));
        }

        // free boundary condition by default
        const Real alpha2 = d2fdx2(index, indexM1);
        const Real beta2  = d2fdx2(index, index);

        if (   std::fabs(alpha2)  > QL_EPSILON
            || std::fabs(beta2) > QL_EPSILON) {
            BOOST_FAIL("can not reproduce the weights of the "
                       "second order derivative operator "
                       "on the upper boundary"
                    << "\n expected alpha:   " << 0.0
                    << "\n calculated alpha: " << alpha2
                    << "\n expected beta:    " << 0.0
                    << "\n calculated beta:  " << beta2);
        }
    }
    else {
        Array threePoints(3);
        threePoints[0] = gridPoints.at(indexM1)-gridPoints.at(index);
        threePoints[1] = 0.0;
        threePoints[2] = gridPoints.at(indexP1)-gridPoints.at(index);

        const Array ndWeights1st = NumericalDifferentiation(
            boost::function<Real(Real)>(), 1 , threePoints).weights();

        const Real alpha1 = dfdx(index, indexM1);
        const Real beta1  = dfdx(index, index);
        const Real gamma1 = dfdx(index, indexP1);

        if (   std::fabs((alpha1 - ndWeights1st.at(0))/alpha1) > tol
            || std::fabs((beta1  - ndWeights1st.at(1))/beta1) > tol
            || std::fabs((gamma1 - ndWeights1st.at(2))/gamma1) > tol) {
            BOOST_FAIL("can not reproduce the weights of the "
                       "first order derivative operator"
                    << "\n expected alpha:   " << ndWeights1st.at(0)
                    << "\n calculated alpha: " << alpha1
                    << "\n difference alpha: "
                    << alpha1 - ndWeights1st.at(0)
                    << "\n expected beta:    " << ndWeights1st.at(1)
                    << "\n calculated beta:  " << beta1
                    << "\n difference beta:  "
                    << beta1 - ndWeights1st.at(1)
                    << "\n expected gamma:   " << ndWeights1st.at(2)
                    << "\n calculated gamma: " << gamma1
                    << "\n difference gamma: "
                    << gamma1 - ndWeights1st.at(2));
        }

        const Array ndWeights2nd = NumericalDifferentiation(
            boost::function<Real(Real)>(), 2 , threePoints).weights();

        const Real alpha2 = d2fdx2(index, indexM1);
        const Real beta2  = d2fdx2(index, index);
        const Real gamma2 = d2fdx2(index, indexP1);
        if (   std::fabs((alpha2 - ndWeights2nd.at(0))/alpha2) > tol
            || std::fabs((beta2  - ndWeights2nd.at(1))/beta2) > tol
            || std::fabs((gamma2 - ndWeights2nd.at(2))/gamma2) > tol) {
            BOOST_FAIL("can not reproduce the weights of the "
                       "second order derivative operator"
                    << "\n expected alpha:   " << ndWeights2nd.at(0)
                    << "\n calculated alpha: " << alpha2
                    << "\n difference alpha: "
                    << alpha2 - ndWeights2nd.at(0)
                    << "\n expected beta:    " << ndWeights2nd.at(1)
                    << "\n calculated beta:  " << beta2
                    << "\n difference beta:  "
                    << beta2 - ndWeights2nd.at(1)
                    << "\n expected gamma:   " << ndWeights2nd.at(2)
                    << "\n calculated gamma: " << gamma2
                    << "\n difference gamma: "
                    << gamma2 - ndWeights2nd.at(2));
        }
    }
}
}

for (FdmLinearOpIterator iter = index->begin(); iter != endIter; ++iter) {
const Real x = mesher->location(iter, 0);
const Real y = mesher->location(iter, 1);
const Real z = mesher->location(iter, 2);

r[iter.index()] = std::sin(x)*std::cos(y)*std::exp(z);
}

for (FdmLinearOpIterator iter = index->begin(); iter != endIter; ++iter) {
const Size i = iter.index();
const Real x = mesher->location(iter, 0);
const Real y = mesher->location(iter, 1);
const Real z = mesher->location(iter, 2);

const Real d = -std::cos(x)*std::sin(y)*std::exp(z);

if (std::fabs(d - t[i]) > tol) {
    BOOST_FAIL("numerical derivative in dxdy deviation is too big"
                << "\n  found at " << x << " " << y << " " << z);
}

if (std::fabs(t[i]-u[i]) > 1e5*QL_EPSILON) {
    BOOST_FAIL("numerical derivative in dxdy not equal to dydx"
            << "\n  found at " << x << " " << y << " " << z
            << "\n  value    " << std::fabs(t[i]-u[i]));
}
}

for (FdmLinearOpIterator iter = index->begin(); iter != endIter; ++iter) {
const Size i = iter.index();
const Real x = mesher->location(iter, 0);
const Real y = mesher->location(iter, 1);
const Real z = mesher->location(iter, 2);

const Real d = std::cos(x)*std::cos(y)*std::exp(z);

if (std::fabs(d - t[i]) > tol) {
    BOOST_FAIL("numerical derivative in dxdy deviation is too big"
        << "\n  found at " << x << " " << y << " " << z);
}

if (std::fabs(t[i]-u[i]) > 1e5*QL_EPSILON) {
    BOOST_FAIL("numerical derivative in dxdz not equal to dzdx"
        << "\n  found at " << x << " " << y << " " << z
        << "\n  value    " << std::fabs(t[i]-u[i]));
}
}

for (FdmLinearOpIterator iter = index->begin(); iter != endIter; ++iter) {
const Size i = iter.index();
const Real x = mesher->location(iter, 0);
const Real y = mesher->location(iter, 1);
const Real z = mesher->location(iter, 2);

const Real d = -std::sin(x)*std::sin(y)*std::exp(z);

if (std::fabs(d - t[i]) > tol) {
    BOOST_FAIL("numerical derivative in dydz deviation is too big"
        << "\n  found at " << x << " " << y << " " << z);
}

if (std::fabs(t[i]-u[i]) > 1e5*QL_EPSILON) {
    BOOST_FAIL("numerical derivative in dydz not equal to dzdy"
        << "\n  found at " << x << " " << y << " " << z
        << "\n  value    " << std::fabs(t[i]-u[i]));
}
}

for (Size i=0; i < layout->size(); ++i)
u[i] = std::sin(0.1*i)+std::cos(0.35*i);

for (Size i=0; i < u.size(); ++i) {
if (std::fabs(u[i] - t[i]) > 1e-6) {
    BOOST_FAIL("solve and apply are not consistent "
            << "\n expected      : " << u[i]
            << "\n calculated    : " << t[i]);
}
}

for (Size i=0; i < u.size(); ++i) {
if (std::fabs(u[i] - t[i]) > 1e-6) {
    BOOST_FAIL("solve and apply are not consistent "
        << "\n expected      : " << u[i]
        << "\n calculated    : " << t[i]);
}
}

for (Size i=0; i < u.size(); ++i) {
if (std::fabs(u[i] - t[i]) > 1e-6) {
    BOOST_FAIL("solve and apply are not consistent "
        << "\n expected      : " << u[i]
        << "\n calculated    : " << t[i]);
}
}

for (Size i=0; i < u.size(); ++i) {
if (std::fabs(u[i] - t[i]) > 1e-6) {
    BOOST_FAIL("solve and apply are not consistent "
        << "\n expected      : " << u[i]
        << "\n calculated    : " << t[i]);
}
}

for (Size i=0; i < dims[0]; ++i)
for (Size j=0; j < dims[1]; ++j)
    ret[i][j] = rhs[i+j*dims[0]];

for (Size i=0; i < dims[0]; ++i)
for (Size j=0; j < dims[1]; ++j)
    ret[i][j] = rhs[i+j*dims[0]];

for (Size i=0; i <= 25; ++i) {
    dates.push_back(today+Period(i, Years));
    rates.push_back(0.05);
    divRates.push_back(0.02);
}

for (Size k=0; k < dim[2]; ++k) {
Matrix ret(dim[0], dim[1]);
for (Size i=0; i < dim[0]; ++i)
    for (Size j=0; j < dim[1]; ++j)
        ret[i][j] = rhs[ i+j*dim[0]+k*dim[0]*dim[1] ];

y.push_back(BicubicSpline(ty.begin(), ty.end(),
                          tx.begin(), tx.end(), ret)(v0, std::log(x0)));
}

for (Size i=0; i < n; ++i) {
for (Size j=0; j < m; ++j) {
    const Size k = i*m+j;
    a(k,k)=1.0;

    if (i > 0 && j > 0 && i <n-1 && j < m-1) {
        const Size im1 = i-1;
        const Size ip1 = i+1;
        const Size jm1 = j-1;
        const Size jp1 = j+1;
        const Real delta = theta/((ip1-im1)*(jp1-jm1));

        a(k,im1*m+jm1) =  delta;
        a(k,im1*m+jp1) = -delta;
        a(k,ip1*m+jm1) = -delta;
        a(k,ip1*m+jp1) =  delta;
    }
}
}

for (Size i=0; i < b.size(); ++i) {
b[i] = rng.next().value;
}

for (Size i=0; i < v.size(); ++i) {
SparseMatrixReference m(v[i]);
for (Size j=0; j < nElements; ++j) {
    const Size row    = Size(rng.next().value*rows);
    const Size column = Size(rng.next().value*columns);

    const Real value = rng.next().value;
    m(row, column)        += value;
    expected(row, column) += value;
}

refs.push_back(m);
}

for (Size i=0; i < rows; ++i) {
for (Size j=0; j < columns; ++j) {
    if (std::fabs(calculated(i,j) - expected(i,j)) > 100*QL_EPSILON) {
        BOOST_FAIL("Error using sparse matrix references in " <<
                   "Element (" << i << ", " << j << ")" <<
                "\n expected  : " << expected(i, j) <<
                "\n calculated: " << calculated(i, j));
    }
}
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/sampledcurve.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i < curve.size(); i++) {
Real grid = curve.gridValue(i);
Real value = curve.value(i);
Real expected = f2(grid);
if (std::fabs(value - expected) > tolerance) {
    BOOST_ERROR("sample curve regriding failed" <<
                "\n    at " << io::ordinal(i+1) << " point " << "(x = " << grid << ")" <<
                "\n    grid value: " << value <<
                "\n    expected:   " << expected);
}
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/fastfouriertransform.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (size_t i = 0; i<8; i++) {
if ((std::fabs(b[i].real() - expected[i].real()) > 1.0e-2) ||
    (std::fabs(b[i].imag() - expected[i].imag()) > 1.0e-2))
    BOOST_ERROR("Convolution(" << i << ")\n"
                << std::setprecision(4) << QL_SCIENTIFIC
                << "    calculated: " << b[i] << "\n"
                << "    expected:   " << expected[i]);
}

for (Size i=0; i<nFrq; ++i) {
tmp[i] = std::norm<Real>(ft[i]);
ft[i] = z;
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/catbonds.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for(size_t i=0; i<PATHS; ++i)
{
BOOST_REQUIRE(simulation->nextPath(path));
Real processValue = 0.0;
for(size_t j=0; j<path.size(); ++j) processValue+=path[j].second;
sum+=processValue;
sumSquares+=processValue*processValue;
poissonSum+=path.size();
poissonSumSquares+=path.size()*path.size();
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/europeanoption.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i<LENGTH(values); i++) {

boost::shared_ptr<StrikedTypePayoff> payoff(new
    PlainVanillaPayoff(values[i].type, values[i].strike));
Date exDate = today + timeToDays(values[i].t);
boost::shared_ptr<Exercise> exercise(new EuropeanExercise(exDate));

spot ->setValue(values[i].s);
qRate->setValue(values[i].q);
rRate->setValue(values[i].r);
vol  ->setValue(values[i].v);

boost::shared_ptr<BlackScholesMertonProcess> stochProcess(new
    BlackScholesMertonProcess(Handle<Quote>(spot),
                              Handle<YieldTermStructure>(qTS),
                              Handle<YieldTermStructure>(rTS),
                              Handle<BlackVolTermStructure>(volTS)));
boost::shared_ptr<PricingEngine> engine(
                            new AnalyticEuropeanEngine(stochProcess));

EuropeanOption option(payoff, exercise);
option.setPricingEngine(engine);

Real calculated = option.NPV();
Real error = std::fabs(calculated-values[i].result);
Real tolerance = values[i].tol;
if (error>tolerance) {
    REPORT_FAILURE("value", payoff, exercise, values[i].s,
                   values[i].q, values[i].r, today,
                   values[i].v, values[i].result, calculated,
                   error, tolerance);
}

engine = boost::shared_ptr<PricingEngine>(
            new FdBlackScholesVanillaEngine(stochProcess,200,400));
option.setPricingEngine(engine);

calculated = option.NPV();
error = std::fabs(calculated-values[i].result);
tolerance = 1.0e-3;
if (error>tolerance) {
    REPORT_FAILURE("value", payoff, exercise, values[i].s,
                   values[i].q, values[i].r, today,
                   values[i].v, values[i].result, calculated,
                   error, tolerance);
}
}

for (Size i=0; i<LENGTH(types); i++) {
for (Size j=0; j<LENGTH(strikes); j++) {
for (Size k=0; k<LENGTH(residualTimes); k++) {
  Date exDate = today + timeToDays(residualTimes[k]);
  boost::shared_ptr<Exercise> exercise(new EuropeanExercise(exDate));
  for (Size kk=0; kk<4; kk++) {
      // option to check
      if (kk==0) {
          payoff = boost::shared_ptr<StrikedTypePayoff>(new
            PlainVanillaPayoff(types[i], strikes[j]));
      } else if (kk==1) {
          payoff = boost::shared_ptr<StrikedTypePayoff>(new
            CashOrNothingPayoff(types[i], strikes[j],
            100.0));
      } else if (kk==2) {
          payoff = boost::shared_ptr<StrikedTypePayoff>(new
            AssetOrNothingPayoff(types[i], strikes[j]));
      } else if (kk==3) {
          payoff = boost::shared_ptr<StrikedTypePayoff>(new
            GapPayoff(types[i], strikes[j], 100.0));
      }

      boost::shared_ptr<BlackScholesMertonProcess> stochProcess(
                    new BlackScholesMertonProcess(Handle<Quote>(spot),
                                                  qTS, rTS, volTS));
      boost::shared_ptr<PricingEngine> engine(
                            new AnalyticEuropeanEngine(stochProcess));
      EuropeanOption option(payoff, exercise);
      option.setPricingEngine(engine);

      for (Size l=0; l<LENGTH(underlyings); l++) {
        for (Size m=0; m<LENGTH(qRates); m++) {
          for (Size n=0; n<LENGTH(rRates); n++) {
            for (Size p=0; p<LENGTH(vols); p++) {
              Real u = underlyings[l];
              Rate q = qRates[m],
                   r = rRates[n];
              Volatility v = vols[p];
              spot->setValue(u);
              qRate->setValue(q);
              rRate->setValue(r);
              vol->setValue(v);

              Real value = option.NPV();
              calculated["delta"]  = option.delta();
              calculated["gamma"]  = option.gamma();
              calculated["theta"]  = option.theta();
              calculated["rho"]    = option.rho();
              calculated["divRho"] = option.dividendRho();
              calculated["vega"]   = option.vega();

              if (value > spot->value()*1.0e-5) {
                  // perturb spot and get delta and gamma
                  Real du = u*1.0e-4;
                  spot->setValue(u+du);
                  Real value_p = option.NPV(),
                       delta_p = option.delta();
                  spot->setValue(u-du);
                  Real value_m = option.NPV(),
                       delta_m = option.delta();
                  spot->setValue(u);
                  expected["delta"] = (value_p - value_m)/(2*du);
                  expected["gamma"] = (delta_p - delta_m)/(2*du);

                  // perturb rates and get rho and dividend rho
                  Spread dr = r*1.0e-4;
                  rRate->setValue(r+dr);
                  value_p = option.NPV();
                  rRate->setValue(r-dr);
                  value_m = option.NPV();
                  rRate->setValue(r);
                  expected["rho"] = (value_p - value_m)/(2*dr);

                  Spread dq = q*1.0e-4;
                  qRate->setValue(q+dq);
                  value_p = option.NPV();
                  qRate->setValue(q-dq);
                  value_m = option.NPV();
                  qRate->setValue(q);
                  expected["divRho"] = (value_p - value_m)/(2*dq);

                  // perturb volatility and get vega
                  Volatility dv = v*1.0e-4;
                  vol->setValue(v+dv);
                  value_p = option.NPV();
                  vol->setValue(v-dv);
                  value_m = option.NPV();
                  vol->setValue(v);
                  expected["vega"] = (value_p - value_m)/(2*dv);

                  // perturb date and get theta
                  Time dT = dc.yearFraction(today-1, today+1);
                  Settings::instance().evaluationDate() = today-1;
                  value_m = option.NPV();
                  Settings::instance().evaluationDate() = today+1;
                  value_p = option.NPV();
                  Settings::instance().evaluationDate() = today;
                  expected["theta"] = (value_p - value_m)/dT;

                  // compare
                  std::map<std::string,Real>::iterator it;
                  for (it = calculated.begin();
                       it != calculated.end(); ++it) {
                      std::string greek = it->first;
                      Real expct = expected  [greek],
                           calcl = calculated[greek],
                           tol   = tolerance [greek];
                      Real error = relativeError(expct,calcl,u);
                      if (error>tol) {
                          REPORT_FAILURE(greek, payoff, exercise,
                                         u, q, r, today, v,
                                         expct, calcl, error, tol);
                      }
                  }
              }
            }
          }
        }
      }
    }
}
}
}

for (Size i=0; i<LENGTH(types); i++) {
for (Size j=0; j<LENGTH(strikes); j++) {
for (Size k=0; k<LENGTH(lengths); k++) {
  // option to check
  Date exDate = today + lengths[k];
  boost::shared_ptr<Exercise> exercise(new EuropeanExercise(exDate));
  boost::shared_ptr<StrikedTypePayoff> payoff(
                        new PlainVanillaPayoff(types[i], strikes[j]));
  boost::shared_ptr<VanillaOption> option =
      makeOption(payoff, exercise, spot, qTS, rTS, volTS,
                 Analytic, Null<Size>(), Null<Size>());

  boost::shared_ptr<GeneralizedBlackScholesProcess> process =
      makeProcess(spot, qTS, rTS,volTS);

  for (Size l=0; l<LENGTH(underlyings); l++) {
    for (Size m=0; m<LENGTH(qRates); m++) {
      for (Size n=0; n<LENGTH(rRates); n++) {
        for (Size p=0; p<LENGTH(vols); p++) {
          Real u = underlyings[l];
          Rate q = qRates[m],
               r = rRates[n];
          Volatility v = vols[p];
          spot->setValue(u);
          qRate->setValue(q);
          rRate->setValue(r);
          vol->setValue(v);

          Real value = option->NPV();
          Volatility implVol = 0.0; // just to remove a warning...
          if (value != 0.0) {
              // shift guess somehow
              vol->setValue(v*0.5);
              if (std::fabs(value-option->NPV()) <= 1.0e-12) {
                  // flat price vs vol --- pointless (and
                  // numerically unstable) to solve
                  continue;
              }
              try {
                  implVol = option->impliedVolatility(value,
                                                      process,
                                                      tolerance,
                                                      maxEvaluations);
              } catch (std::exception& e) {
                  BOOST_ERROR(
                      "\nimplied vol calculation failed:" <<
                      "\n   option:         " << types[i] <<
                      "\n   strike:         " << strikes[j] <<
                      "\n   spot value:     " << u <<
                      "\n   dividend yield: " << io::rate(q) <<
                      "\n   risk-free rate: " << io::rate(r) <<
                      "\n   today:          " << today <<
                      "\n   maturity:       " << exDate <<
                      "\n   volatility:     " << io::volatility(v) <<
                      "\n   option value:   " << value <<
                      "\n" << e.what());
              }
              if (std::fabs(implVol-v) > tolerance) {
                  // the difference might not matter
                  vol->setValue(implVol);
                  Real value2 = option->NPV();
                  Real error = relativeError(value,value2,u);
                  if (error > tolerance) {
                      BOOST_ERROR(
                          types[i] << " option :\n"
                          << "    spot value:          " << u << "\n"
                          << "    strike:              "
                          << strikes[j] << "\n"
                          << "    dividend yield:      "
                          << io::rate(q) << "\n"
                          << "    risk-free rate:      "
                          << io::rate(r) << "\n"
                          << "    maturity:            "
                          << exDate << "\n\n"
                          << "    original volatility: "
                          << io::volatility(v) << "\n"
                          << "    price:               "
                          << value << "\n"
                          << "    implied volatility:  "
                          << io::volatility(implVol)
                          << "\n"
                          << "    corresponding price: "
                          << value2 << "\n"
                          << "    error:               " << error);
                  }
              }
          }
        }
      }
    }
  }
}
}
}

for (Size i=0; i<LENGTH(types); i++) {
  for (Size j=0; j<LENGTH(strikes); j++) {
    for (Size k=0; k<LENGTH(lengths); k++) {
      Date exDate = today + lengths[k]*360;
      boost::shared_ptr<Exercise> exercise(
                                        new EuropeanExercise(exDate));
      boost::shared_ptr<StrikedTypePayoff> payoff(new
                            PlainVanillaPayoff(types[i], strikes[j]));
      // reference option
      boost::shared_ptr<VanillaOption> refOption =
          makeOption(payoff, exercise, spot, qTS, rTS, volTS,
                     Analytic, Null<Size>(), Null<Size>());
      // option to check
      boost::shared_ptr<VanillaOption> option =
          makeOption(payoff, exercise, spot, qTS, rTS, volTS,
                     engine, binomialSteps, samples);

      for (Size l=0; l<LENGTH(underlyings); l++) {
        for (Size m=0; m<LENGTH(qRates); m++) {
          for (Size n=0; n<LENGTH(rRates); n++) {
            for (Size p=0; p<LENGTH(vols); p++) {
              Real u = underlyings[l];
              Rate q = qRates[m],
                   r = rRates[n];
              Volatility v = vols[p];
              spot->setValue(u);
              qRate->setValue(q);
              rRate->setValue(r);
              vol->setValue(v);

              expected.clear();
              calculated.clear();

              // FLOATING_POINT_EXCEPTION
              expected["value"] = refOption->NPV();
              calculated["value"] = option->NPV();

              if (testGreeks && option->NPV() > spot->value()*1.0e-5) {
                   expected["delta"] = refOption->delta();
                   expected["gamma"] = refOption->gamma();
                   expected["theta"] = refOption->theta();
                   calculated["delta"] = option->delta();
                   calculated["gamma"] = option->gamma();
                   calculated["theta"] = option->theta();
              }
              std::map<std::string,Real>::iterator it;
              for (it = calculated.begin();
                   it != calculated.end(); ++it) {
                  std::string greek = it->first;
                  Real expct = expected  [greek],
                       calcl = calculated[greek],
                       tol   = tolerance [greek];
                  Real error = relativeError(expct,calcl,u);
                  if (error > tol) {
                      REPORT_FAILURE(greek, payoff, exercise,
                                     u, q, r, today, v,
                                     expct, calcl, error, tol);
                  }
              }
            }
          }
        }
      }
    }
  }
}

for (Size i=0; i<LENGTH(values); i++) {

boost::shared_ptr<StrikedTypePayoff> payoff(new
    PlainVanillaPayoff(values[i].type, values[i].strike));
// FLOATING_POINT_EXCEPTION
Date exDate = today + timeToDays(values[i].t);
boost::shared_ptr<Exercise> exercise(new EuropeanExercise(exDate));

spot ->setValue(values[i].s);
qRate->setValue(values[i].q);
rRate->setValue(values[i].r);
vol  ->setValue(values[i].v);

EuropeanOption option(payoff, exercise);
option.setPricingEngine(engine);
SampledCurve price_curve = option.result<SampledCurve>("priceCurve");
if (price_curve.empty()) {
    REPORT_FAILURE("no price curve", payoff, exercise, values[i].s,
                   values[i].q, values[i].r, today,
                   values[i].v, values[i].result, 0.0,
                   0.0, 0.0);
    continue;
}

// Ignore the end points
Size start = price_curve.size() / 4;
Size end = price_curve.size() * 3 / 4;
for (Size i=start; i < end; i++) {
    spot->setValue(price_curve.gridValue(i));
    boost::shared_ptr<StochasticProcess> stochProcess1(
              new BlackScholesMertonProcess(
                               Handle<Quote>(spot),
                               Handle<YieldTermStructure>(qTS),
                               Handle<YieldTermStructure>(rTS),
                               Handle<BlackVolTermStructure>(volTS)));
    boost::shared_ptr<PricingEngine> engine1(
                     new FDEuropeanEngine<CrankNicolson>(stochProcess,
                                                         timeSteps,
                                                         gridPoints));

    option.setPricingEngine(engine1);
    Real calculated = option.NPV();
    Real error = std::fabs(calculated-price_curve.value(i));
    Real tolerance = 1e-3;
    if (error>tolerance) {
        REPORT_FAILURE("price curve error", payoff, exercise,
                       price_curve.gridValue(i),
                       values[i].q, values[i].r, today,
                       values[i].v,
                       price_curve.value(i), calculated,
                       error, tolerance);
        break;
    }
}
}

for (Size i = 0; i < 8; ++i) {
dates.push_back(settlementDate + t[i]);
rates.push_back(r[i]);
}

for (Size i=0; i < strikes.size(); ++i)
for (Size j=1; j < dates.size(); ++j) {
    blackVolMatrix[i][j-1] = v[i*(dates.size()-1)+j-1];
}

for (Size i=2; i < dates.size(); ++i) {
for (Size j=3; j < strikes.size()-5; j+=5) {
    const Date& exDate = dates[i];
    const boost::shared_ptr<StrikedTypePayoff> payoff(new
                         PlainVanillaPayoff(Option::Call, strikes[j]));

    const boost::shared_ptr<Exercise> exercise(
                                         new EuropeanExercise(exDate));

    EuropeanOption option(payoff, exercise);
    option.setPricingEngine(boost::shared_ptr<PricingEngine>(
                                 new AnalyticEuropeanEngine(process)));
     
    const Real tol = 0.001;
    const Real expectedNPV   = option.NPV();
    const Real expectedDelta = option.delta();
    const Real expectedGamma = option.gamma();
    
    option.setPricingEngine(boost::shared_ptr<PricingEngine>(
                 new FdBlackScholesVanillaEngine(process, 200, 400)));

    Real calculatedNPV = option.NPV();
    const Real calculatedDelta = option.delta();
    const Real calculatedGamma = option.gamma();
    
    // check implied pricing first
    if (std::fabs(expectedNPV - calculatedNPV) > tol*expectedNPV) {
        BOOST_FAIL("Failed to reproduce option price for "
                   << "\n    strike:     " << payoff->strike()
                   << "\n    maturity:   " << exDate
                   << "\n    calculated: " << calculatedNPV
                   << "\n    expected:   " << expectedNPV);
    }
    if (std::fabs(expectedDelta - calculatedDelta) >tol*expectedDelta) {
        BOOST_FAIL("Failed to reproduce option delta for "
                   << "\n    strike:     " << payoff->strike()
                   << "\n    maturity:   " << exDate
                   << "\n    calculated: " << calculatedDelta
                   << "\n    expected:   " << expectedDelta);
    }
    if (std::fabs(expectedGamma - calculatedGamma) >tol*expectedGamma) {
        BOOST_FAIL("Failed to reproduce option gamma for "
                   << "\n    strike:     " << payoff->strike()
                   << "\n    maturity:   " << exDate
                   << "\n    calculated: " << calculatedGamma
                   << "\n    expected:   " << expectedGamma);
    }
    
    // check local vol pricing
    // delta/gamma are not the same by definition (model implied greeks)
    option.setPricingEngine(boost::shared_ptr<PricingEngine>(
            new FdBlackScholesVanillaEngine(process, 25, 400, 0, 
                                            FdmSchemeDesc::Douglas(), 
                                            true, 0.35)));
    calculatedNPV = option.NPV();
    if (std::fabs(expectedNPV - calculatedNPV) > tol*expectedNPV) {
        BOOST_FAIL("Failed to reproduce local vol option price for "
                   << "\n    strike:     " << payoff->strike()
                   << "\n    maturity:   " << exDate
                   << "\n    calculated: " << calculatedNPV
                   << "\n    expected:   " << expectedNPV);
    }
}
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/brownianbridge.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i<samples; ++i) {
const std::vector<Real>& sample = generator.nextSequence().value;

bridge.transform(sample.begin(), sample.end(), temp.begin());
stats1.add(temp.begin(), temp.end());

temp[0] = temp[0]*std::sqrt(times[0]);
for (Size j=1; j<N; ++j)
    temp[j] = temp[j-1] + temp[j]*std::sqrt(times[j]-times[j-1]);
stats2.add(temp.begin(), temp.end());
}

for (Size i=0; i<N; i++)
expectedCovariance[i][i] = 1.0;

for (Size i=0; i<N; ++i)
for (Size j=i; j<N; ++j)
    expectedCovariance[i][j] = expectedCovariance[j][i] = times[i];

for (Size i=0; i<samples; ++i) {
const Path& path1 = generator1.next().value;
std::copy(path1.begin()+1, path1.end(), temp.begin());
stats1.add(temp.begin(), temp.end());

const Path& path2 = generator2.next().value;
std::copy(path2.begin()+1, path2.end(), temp.begin());
stats2.add(temp.begin(), temp.end());
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/lowdiscrepancysequences.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i < numberBatches; ++i)
{
    SequenceStatistics innerStats(maxDim);
    for (Size j=0; j < N; ++j)
    {
        innerStats.add(rldsg.nextSequence().value);
    }
    outerStats.add(innerStats.mean());
    rldsg.nextRandomizer();
}

for (Size i=0; i < maxDim; ++i)
    errorInSds[i] = (means[i]-0.5)/ sds[i];

for (Size i=0; i < maxDim; ++i)
    if (fabs(errorInSds[i] ) > tolerance)
        BOOST_ERROR("Lattice generator" << nameString <<" returns  a mean of " <<
        means[i] << " with error equal to  " << errorInSds[i]
    << " standard deviations in dimension " << i);

for (i=0; i<points; i++) {
point = rsg.nextSequence().value;
if (point.size()!=dimensionality) {
    BOOST_ERROR("Sobol sequence generator returns "
                " a sequence of wrong dimensionality: " << point.size()
                << " instead of  " << dimensionality);
}
}

for (Integer j=1; j<5; j++) { // five cycle
points = Size(std::pow(2.0, j))-1; // base 2
for (; k<points; k++) {
    point = rsg.nextSequence().value;
    stat.add(point);
}
mean = stat.mean();
for (i=0; i<dimensionality; i++) {
    Real error = std::fabs(mean[i]-0.5);
    if (error > tolerance) {
        BOOST_ERROR(io::ordinal(i+1) << " dimension: "
                    << QL_FIXED
                    << "mean (" << mean[i]
                    << ") at the end of the " << io::ordinal(j+1)
                    << " cycle in Sobol sequence is not " << 0.5
                    << QL_SCIENTIFIC
                    << " (error = " << error << ")");
    }
}
}

for (i=0; i<points; i++) {
point = rsg.nextSequence().value;
Real error = std::fabs(point[0]-vanderCorputSequenceModuloTwo[i]);
if (error > tolerance) {
    BOOST_ERROR(io::ordinal(i+1) << " draw ("
                << QL_FIXED << point[0]
                << ") in 1-D Sobol sequence is not in the "
                << "van der Corput sequence modulo two: "
                << "it should have been "
                << vanderCorputSequenceModuloTwo[i]
                << QL_SCIENTIFIC
                << " (error = " << error << ")");
}
}

for (i=0; i<points; i++) {
point = rsg.nextSequence().value;
if (point.size()!=dimensionality) {
    BOOST_ERROR("Faure sequence generator returns "
                " a sequence of wrong dimensionality: " << point.size()
                << " instead of  " << dimensionality);
}
}

for (i=0; i<points; i++) {
point = rsg.nextSequence().value;
Real error = std::fabs(point[0]-vanderCorputSequenceModuloTwo[i]);
if (error > tolerance) {
    BOOST_ERROR(io::ordinal(i+1) << " draw, dimension 1 ("
                << QL_FIXED << point[0]
                << ") in 3-D Faure sequence should have been "
                << vanderCorputSequenceModuloTwo[i]
                << QL_SCIENTIFIC
                << " (error = " << error << ")");
}
}

for (i=0; i<points; i++) {
point = rsg.nextSequence().value;
Real error = std::fabs(point[0]-vanderCorputSequenceModuloTwo[i]);
if (error > tolerance) {
    BOOST_ERROR(io::ordinal(i+1) << " draw, dimension 1 ("
                << QL_FIXED << point[0]
                << ") in 3-D Faure sequence should have been "
                << vanderCorputSequenceModuloTwo[i]
                << QL_SCIENTIFIC
                << " (error = " << error << ")");
}
error = std::fabs(point[1]-FaureDimensionTwoOfTwo[i]);
if (error > tolerance) {
    BOOST_ERROR(io::ordinal(i+1) << " draw, dimension 2 ("
                << QL_FIXED << point[1]
                << ") in 3-D Faure sequence should have been "
                << FaureDimensionTwoOfTwo[i]
                << QL_SCIENTIFIC
                << " (error = " << error << ")");
}
}

for (i=0; i<points; i++) {
point = rsg.nextSequence().value;
Real error = std::fabs(point[0]-FaureDimensionOneOfThree[i]);
if (error > tolerance) {
    BOOST_ERROR(io::ordinal(i+1) << " draw, dimension 1 ("
                << QL_FIXED << point[0]
                << ") in 3-D Faure sequence should have been "
                << FaureDimensionOneOfThree[i]
                << QL_SCIENTIFIC
                << " (error = " << error << ")");
}
error = std::fabs(point[1]-FaureDimensionTwoOfThree[i]);
if (error > tolerance) {
    BOOST_ERROR(io::ordinal(i+1) << " draw, dimension 2 ("
                << QL_FIXED << point[1]
                << ") in 3-D Faure sequence should have been "
                << FaureDimensionTwoOfThree[i]
                << QL_SCIENTIFIC
                << " (error = " << error << ")");
}
error = std::fabs(point[2]-FaureDimensionThreeOfThree[i]);
if (error > tolerance) {
    BOOST_ERROR(io::ordinal(i+1) << " draw, dimension 3 ("
                << QL_FIXED << point[2]
                << ") in 3-D Faure sequence should have been "
                << FaureDimensionThreeOfThree[i]
                << QL_SCIENTIFIC
                << " (error = " << error << ")");
}
}

for (i=0; i<points; i++) {
point = rsg.nextSequence().value;
if (point.size()!=dimensionality) {
    BOOST_ERROR("Halton sequence generator returns "
                " a sequence of wrong dimensionality: " << point.size()
                << " instead of  " << dimensionality);
}
}

for (i=0; i<points; i++) {
point = rsg.nextSequence().value;
Real error = std::fabs(point[0]-vanderCorputSequenceModuloTwo[i]);
if (error > tolerance) {
    BOOST_ERROR(io::ordinal(i+1) << " draw ("
                << QL_FIXED << point[0]
                << ") in 1-D Halton sequence is not in the "
                << "van der Corput sequence modulo two: "
                << "it should have been "
                << vanderCorputSequenceModuloTwo[i]
                << QL_SCIENTIFIC
                << " (error = " << error << ")");
}
}

for (i=0; i<points; i++) {
point = rsg.nextSequence().value;
Real error = std::fabs(point[0]-vanderCorputSequenceModuloTwo[i]);
if (error > tolerance) {
    BOOST_ERROR("First component of " << io::ordinal(i+1)
                << " draw (" << QL_FIXED << point[0]
                << ") in 2-D Halton sequence is not in the "
                << "van der Corput sequence modulo two: "
                << "it should have been "
                << vanderCorputSequenceModuloTwo[i]
                << QL_SCIENTIFIC
                << " (error = " << error << ")");
}
error = std::fabs(point[1]-vanderCorputSequenceModuloThree[i]);
if (error > tolerance) {
    BOOST_ERROR("Second component of " << io::ordinal(i+1)
                << " draw (" << QL_FIXED << point[1]
                << ") in 2-D Halton sequence is not in the "
                << "van der Corput sequence modulo three: "
                << "it should have been "
                << vanderCorputSequenceModuloThree[i]
                << QL_SCIENTIFIC
                << " (error = " << error << ")");
}
}

for (j=1; j<5; j++) { // five cycle
points = Size(std::pow(2.0, j))-1; // base 2
for (; k<points; k++) {
    point = rsg.nextSequence().value;
    stat.add(point);
}
mean = stat.mean();
Real error = std::fabs(mean[0] - 0.5);
if (error > tolerance) {
    BOOST_ERROR("First dimension mean (" << QL_FIXED << mean[0]
                << ") at the end of the " << io::ordinal(j+1)
                << " cycle in Halton sequence is not " << 0.5
                << QL_SCIENTIFIC
                << " (error = " << error << ")");
}
}

for (j=1; j<3; j++) { // three cycle
points = Size(std::pow(3.0, j))-1; // base 3
for (; k<points; k++) {
    point = rsg.nextSequence().value;
    stat.add(point);
}
mean = stat.mean();
Real error = std::fabs(mean[1] - 0.5);
if (error > tolerance) {
    BOOST_ERROR("Second dimension mean (" << QL_FIXED << mean[1]
                << ") at the end of the " << io::ordinal(j+1)
                << " cycle in Halton sequence is not " << 0.5
                << QL_SCIENTIFIC
                << " (error = " << error << ")");
}
}

for (Integer i = 0; i<8; i++) {
    #ifdef PRINT_ONLY
    outStream << std::endl;
    #endif

    dim = dimensionality[i];
    DiscrepancyStatistics stat(dim);

    typename T::generator_type rsg = generatorFactory.make(dim, seed);

    Size j, k=0, jMin=10;
    stat.reset();
    #ifdef PRINT_ONLY
    outStream << "const Real dim" << dim
              << arrayName << "[] = {" ;
    #endif
    for (j=jMin; j<jMin+sampleLoops; j++) {
        Size points = Size(std::pow(2.0, Integer(j)))-1;
        for (; k<points; k++) {
            point = rsg.nextSequence().value;
            stat.add(point);
        }

        discr = stat.discrepancy();

        #ifdef PRINT_ONLY
        if (j!=jMin)
            outStream << ", ";
        outStream << QL_FIXED << std::setprecision(2) << discr;
        #else
        if (std::fabs(discr-discrepancy[i][j-jMin])>tolerance*discr) {
            BOOST_ERROR(generatorFactory.name()
                        << "discrepancy dimension " << dimensionality[i]
                        << " at " << points << " samples is "
                        << discr << " instead of "
                        << discrepancy[i][j-jMin]);
        }
        #endif
    }
    #ifdef PRINT_ONLY
    outStream << "};" << std::endl;
    #endif
}

for (Size i=0; i<LENGTH(integers); i++) {
for (Size j=0; j<LENGTH(dimensionality); j++) {
for (Size k=0; k<LENGTH(skip); k++) {

    // extract n samples
    SobolRsg rsg1(dimensionality[j], seed, integers[i]);
    for (Size l=0; l<skip[k]; l++)
        rsg1.nextInt32Sequence();

    // skip n samples at once
    SobolRsg rsg2(dimensionality[j], seed, integers[i]);
    rsg2.skipTo(skip[k]);

    // compare next 100 samples
    for (Size m=0; m<100; m++) {
        std::vector<unsigned long> s1 = rsg1.nextInt32Sequence();
        std::vector<unsigned long> s2 = rsg2.nextInt32Sequence();
        for (Size n=0; n<s1.size(); n++) {
            if (s1[n] != s2[n]) {
                BOOST_ERROR("Mismatch after skipping:"
                            << "\n  size:     " << dimensionality[j]
                            << "\n  integers: " << integers[i]
                            << "\n  skipped:  " << skip[k]
                            << "\n  at index: " << n
                            << "\n  expected: " << s1[n]
                            << "\n  found:    " << s2[n]);
            }
        }
    }
}
}
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/lookbackoptions.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i<LENGTH(values); i++) {
Date exDate = today + Integer(values[i].t*360+0.5);
boost::shared_ptr<Exercise> exercise(new EuropeanExercise(exDate));

spot ->setValue(values[i].s);
qRate->setValue(values[i].q);
rRate->setValue(values[i].r);
vol  ->setValue(values[i].v);

boost::shared_ptr<FloatingTypePayoff> payoff(
                              new FloatingTypePayoff(values[i].type));

boost::shared_ptr<BlackScholesMertonProcess> stochProcess(
                    new BlackScholesMertonProcess(
                               Handle<Quote>(spot),
                               Handle<YieldTermStructure>(qTS),
                               Handle<YieldTermStructure>(rTS),
                               Handle<BlackVolTermStructure>(volTS)));

boost::shared_ptr<PricingEngine> engine(
          new AnalyticContinuousFloatingLookbackEngine(stochProcess));

ContinuousFloatingLookbackOption option(values[i].minmax,
                                        payoff,
                                        exercise);
option.setPricingEngine(engine);

Real calculated = option.NPV();
Real expected = values[i].result;
Real error = std::fabs(calculated-expected);
if (error>values[i].tol) {
    REPORT_FAILURE_FLOATING("value", values[i].minmax, payoff,
                            exercise, values[i].s, values[i].q,
                            values[i].r, today, values[i].v,
                            expected, calculated, error,
                            values[i].tol);
}
}

for (Size i=0; i<LENGTH(values); i++) {
Date exDate = today + Integer(values[i].t*360+0.5);
boost::shared_ptr<Exercise> exercise(new EuropeanExercise(exDate));

spot ->setValue(values[i].s);
qRate->setValue(values[i].q);
rRate->setValue(values[i].r);
vol  ->setValue(values[i].v);

boost::shared_ptr<StrikedTypePayoff> payoff(
             new PlainVanillaPayoff(values[i].type, values[i].strike));

boost::shared_ptr<BlackScholesMertonProcess> stochProcess(
                    new BlackScholesMertonProcess(
                               Handle<Quote>(spot),
                               Handle<YieldTermStructure>(qTS),
                               Handle<YieldTermStructure>(rTS),
                               Handle<BlackVolTermStructure>(volTS)));

boost::shared_ptr<PricingEngine> engine(
             new AnalyticContinuousFixedLookbackEngine(stochProcess));

ContinuousFixedLookbackOption option(values[i].minmax,
                                     payoff,
                                     exercise);
option.setPricingEngine(engine);

Real calculated = option.NPV();
Real expected = values[i].result;
Real error = std::fabs(calculated-expected);
if (error>values[i].tol) {
    REPORT_FAILURE_FIXED("value", values[i].minmax, payoff, exercise,
                         values[i].s, values[i].q, values[i].r, today,
                         values[i].v, expected, calculated, error,
                         values[i].tol);
}
}

for (Size i=0; i<LENGTH(values); i++) {
Date exDate = today + Integer(values[i].t*360+0.5);
boost::shared_ptr<Exercise> exercise(new EuropeanExercise(exDate));

spot ->setValue(values[i].s);
qRate->setValue(values[i].q);
rRate->setValue(values[i].r);
vol  ->setValue(values[i].v);

boost::shared_ptr<FloatingTypePayoff> payoff(
                              new FloatingTypePayoff(values[i].type));

boost::shared_ptr<BlackScholesMertonProcess> stochProcess(
                    new BlackScholesMertonProcess(
                               Handle<Quote>(spot),
                               Handle<YieldTermStructure>(qTS),
                               Handle<YieldTermStructure>(rTS),
                               Handle<BlackVolTermStructure>(volTS)));

boost::shared_ptr<PricingEngine> engine(
          new AnalyticContinuousPartialFloatingLookbackEngine(stochProcess));

Date lookbackEnd = today + Integer(values[i].t1*360+0.5);
ContinuousPartialFloatingLookbackOption option(values[i].minmax,
                                        values[i].l,
                                        lookbackEnd,
                                        payoff,
                                        exercise);
option.setPricingEngine(engine);

Real calculated = option.NPV();
Real expected = values[i].result;
Real error = std::fabs(calculated-expected);
if (error>values[i].tol) {
    REPORT_FAILURE_FLOATING("value", values[i].minmax, payoff,
                            exercise, values[i].s, values[i].q,
                            values[i].r, today, values[i].v,
                            expected, calculated, error,
                            values[i].tol);
}
}

for (Size i=0; i<LENGTH(values); i++) {
Date exDate = today + Integer(values[i].t*360+0.5);
boost::shared_ptr<Exercise> exercise(new EuropeanExercise(exDate));

spot ->setValue(values[i].s);
qRate->setValue(values[i].q);
rRate->setValue(values[i].r);
vol  ->setValue(values[i].v);

boost::shared_ptr<StrikedTypePayoff> payoff(
             new PlainVanillaPayoff(values[i].type, values[i].strike));

boost::shared_ptr<BlackScholesMertonProcess> stochProcess(
                    new BlackScholesMertonProcess(
                               Handle<Quote>(spot),
                               Handle<YieldTermStructure>(qTS),
                               Handle<YieldTermStructure>(rTS),
                               Handle<BlackVolTermStructure>(volTS)));

boost::shared_ptr<PricingEngine> engine(
             new AnalyticContinuousPartialFixedLookbackEngine(stochProcess));

Date lookbackStart = today + Integer(values[i].t1*360+0.5);
ContinuousPartialFixedLookbackOption option(lookbackStart,
                                     payoff,
                                     exercise);
option.setPricingEngine(engine);

Real calculated = option.NPV();
Real expected = values[i].result;
Real error = std::fabs(calculated-expected);
if (error>values[i].tol) {
    REPORT_FAILURE_FIXED("value", values[i].minmax, payoff, exercise,
                         values[i].s, values[i].q, values[i].r, today,
                         values[i].v, expected, calculated, error,
                         values[i].tol);
}
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/pathgenerator.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (i=0; i<100; i++)
    generator.next();

for (i=0; i<100; i++)
    generator.next();

for (j=0; j<assets; j++)
    calculated[j] = sample.value[j].back();

for (j=0; j<assets; j++) {
    error = std::fabs(calculated[j]-expected[j]);
    if (error > tolerance) {
        BOOST_ERROR("using " << tag << " process "
                    << "(" << io::ordinal(j+1) << " asset:)\n"
                    << std::setprecision(13)
                    << "    calculated: " << calculated[j] << "\n"
                    << "    expected:   " << expected[j] << "\n"
                    << "    error:      " << error << "\n"
                    << "    tolerance:  " << tolerance);
    }
}

for (j=0; j<assets; j++)
    calculated[j] = sample.value[j].back();

for (j=0; j<assets; j++) {
    error = std::fabs(calculated[j]-antithetic[j]);
    if (error > tolerance) {
        BOOST_ERROR("using " << tag << " process "
                    << "(" << io::ordinal(j+1) << " asset:)\n"
                    << "antithetic sample:\n"
                    << std::setprecision(13)
                    << "    calculated: " << calculated[j] << "\n"
                    << "    expected:   " << antithetic[j] << "\n"
                    << "    error:      " << error << "\n"
                    << "    tolerance:  " << tolerance);
    }
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/digitaloption.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i<LENGTH(values); i++) {

boost::shared_ptr<StrikedTypePayoff> payoff(new CashOrNothingPayoff(
    values[i].type, values[i].strike, 10.0));

Date exDate = today + Integer(values[i].t*360+0.5);
boost::shared_ptr<Exercise> exercise(new EuropeanExercise(exDate));

spot ->setValue(values[i].s);
qRate->setValue(values[i].q);
rRate->setValue(values[i].r);
vol  ->setValue(values[i].v);

boost::shared_ptr<BlackScholesMertonProcess> stochProcess(new
    BlackScholesMertonProcess(Handle<Quote>(spot),
                              Handle<YieldTermStructure>(qTS),
                              Handle<YieldTermStructure>(rTS),
                              Handle<BlackVolTermStructure>(volTS)));
boost::shared_ptr<PricingEngine> engine(
                            new AnalyticEuropeanEngine(stochProcess));

VanillaOption opt(payoff, exercise);
opt.setPricingEngine(engine);

Real calculated = opt.NPV();
Real error = std::fabs(calculated-values[i].result);
if (error > values[i].tol) {
    REPORT_FAILURE("value", payoff, exercise, values[i].s, values[i].q,
                   values[i].r, today, values[i].v, values[i].result,
                   calculated, error, values[i].tol, values[i].knockin);
}
}

for (Size i=0; i<LENGTH(values); i++) {

boost::shared_ptr<StrikedTypePayoff> payoff(new AssetOrNothingPayoff(
    values[i].type, values[i].strike));

Date exDate = today + Integer(values[i].t*360+0.5);
boost::shared_ptr<Exercise> exercise(new EuropeanExercise(exDate));

spot ->setValue(values[i].s);
qRate->setValue(values[i].q);
rRate->setValue(values[i].r);
vol  ->setValue(values[i].v);

boost::shared_ptr<BlackScholesMertonProcess> stochProcess(new
    BlackScholesMertonProcess(Handle<Quote>(spot),
                              Handle<YieldTermStructure>(qTS),
                              Handle<YieldTermStructure>(rTS),
                              Handle<BlackVolTermStructure>(volTS)));
boost::shared_ptr<PricingEngine> engine(
                            new AnalyticEuropeanEngine(stochProcess));

VanillaOption opt(payoff, exercise);
opt.setPricingEngine(engine);

Real calculated = opt.NPV();
Real error = std::fabs(calculated-values[i].result);
if (error > values[i].tol) {
    REPORT_FAILURE("value", payoff, exercise, values[i].s, values[i].q,
                   values[i].r, today, values[i].v, values[i].result,
                   calculated, error, values[i].tol, values[i].knockin);
}
}

for (Size i=0; i<LENGTH(values); i++) {

boost::shared_ptr<StrikedTypePayoff> payoff(new GapPayoff(
    values[i].type, values[i].strike, 57.00));

Date exDate = today + Integer(values[i].t*360+0.5);
boost::shared_ptr<Exercise> exercise(new EuropeanExercise(exDate));

spot ->setValue(values[i].s);
qRate->setValue(values[i].q);
rRate->setValue(values[i].r);
vol  ->setValue(values[i].v);

boost::shared_ptr<BlackScholesMertonProcess> stochProcess(new
    BlackScholesMertonProcess(Handle<Quote>(spot),
                              Handle<YieldTermStructure>(qTS),
                              Handle<YieldTermStructure>(rTS),
                              Handle<BlackVolTermStructure>(volTS)));
boost::shared_ptr<PricingEngine> engine(
                            new AnalyticEuropeanEngine(stochProcess));

VanillaOption opt(payoff, exercise);
opt.setPricingEngine(engine);

Real calculated = opt.NPV();
Real error = std::fabs(calculated-values[i].result);
if (error > values[i].tol) {
    REPORT_FAILURE("value", payoff, exercise, values[i].s, values[i].q,
                   values[i].r, today, values[i].v, values[i].result,
                   calculated, error, values[i].tol, values[i].knockin);
}
}

for (Size i=0; i<LENGTH(values); i++) {

boost::shared_ptr<StrikedTypePayoff> payoff(new CashOrNothingPayoff(
    values[i].type, values[i].strike, 15.00));

Date exDate = today + Integer(values[i].t*360+0.5);
boost::shared_ptr<Exercise> amExercise(new AmericanExercise(today,
                                                            exDate));

spot ->setValue(values[i].s);
qRate->setValue(values[i].q);
rRate->setValue(values[i].r);
vol  ->setValue(values[i].v);

boost::shared_ptr<BlackScholesMertonProcess> stochProcess(new
    BlackScholesMertonProcess(Handle<Quote>(spot),
                              Handle<YieldTermStructure>(qTS),
                              Handle<YieldTermStructure>(rTS),
                              Handle<BlackVolTermStructure>(volTS)));
boost::shared_ptr<PricingEngine> engine(
                     new AnalyticDigitalAmericanEngine(stochProcess));

VanillaOption opt(payoff, amExercise);
opt.setPricingEngine(engine);

Real calculated = opt.NPV();
Real error = std::fabs(calculated-values[i].result);
if (error > values[i].tol) {
    REPORT_FAILURE("value", payoff, amExercise, values[i].s,
                   values[i].q, values[i].r, today, values[i].v,
                   values[i].result, calculated, error, values[i].tol, values[i].knockin);
}
}

for (Size i=0; i<LENGTH(values); i++) {

boost::shared_ptr<StrikedTypePayoff> payoff(new AssetOrNothingPayoff(
    values[i].type, values[i].strike));

Date exDate = today + Integer(values[i].t*360+0.5);
boost::shared_ptr<Exercise> amExercise(new AmericanExercise(today,
                                                            exDate));

spot ->setValue(values[i].s);
qRate->setValue(values[i].q);
rRate->setValue(values[i].r);
vol  ->setValue(values[i].v);

boost::shared_ptr<BlackScholesMertonProcess> stochProcess(new
    BlackScholesMertonProcess(Handle<Quote>(spot),
                              Handle<YieldTermStructure>(qTS),
                              Handle<YieldTermStructure>(rTS),
                              Handle<BlackVolTermStructure>(volTS)));
boost::shared_ptr<PricingEngine> engine(
                     new AnalyticDigitalAmericanEngine(stochProcess));

VanillaOption opt(payoff, amExercise);
opt.setPricingEngine(engine);

Real calculated = opt.NPV();
Real error = std::fabs(calculated-values[i].result);
if (error > values[i].tol) {
    REPORT_FAILURE("value", payoff, amExercise, values[i].s,
                   values[i].q, values[i].r, today, values[i].v,
                   values[i].result, calculated, error, values[i].tol, values[i].knockin);
}
}

for (Size i=0; i<LENGTH(values); i++) {

boost::shared_ptr<StrikedTypePayoff> payoff(new CashOrNothingPayoff(
    values[i].type, values[i].strike, 15.0));

Date exDate = today + Integer(values[i].t*360+0.5);
boost::shared_ptr<Exercise> amExercise(new AmericanExercise(today,
                                                            exDate,
                                                            true));

spot ->setValue(values[i].s);
qRate->setValue(values[i].q);
rRate->setValue(values[i].r);
vol  ->setValue(values[i].v);

boost::shared_ptr<BlackScholesMertonProcess> stochProcess(new
    BlackScholesMertonProcess(Handle<Quote>(spot),
                              Handle<YieldTermStructure>(qTS),
                              Handle<YieldTermStructure>(rTS),
                              Handle<BlackVolTermStructure>(volTS)));
boost::shared_ptr<PricingEngine> engine;
if (values[i].knockin)
   engine.reset(new AnalyticDigitalAmericanEngine(stochProcess));
else
   engine.reset(new AnalyticDigitalAmericanKOEngine(stochProcess));

VanillaOption opt(payoff, amExercise);
opt.setPricingEngine(engine);

Real calculated = opt.NPV();
Real error = std::fabs(calculated-values[i].result);
if (error > values[i].tol) {
    REPORT_FAILURE("value", payoff, amExercise, values[i].s,
                   values[i].q, values[i].r, today, values[i].v,
                   values[i].result, calculated, error, values[i].tol, values[i].knockin);
}
}

for (Size i=0; i<LENGTH(values); i++) {

boost::shared_ptr<StrikedTypePayoff> payoff(new AssetOrNothingPayoff(
    values[i].type, values[i].strike));

Date exDate = today + Integer(values[i].t*360+0.5);
boost::shared_ptr<Exercise> amExercise(new AmericanExercise(today,
                                                            exDate,
                                                            true));

spot ->setValue(values[i].s);
qRate->setValue(values[i].q);
rRate->setValue(values[i].r);
vol  ->setValue(values[i].v);

boost::shared_ptr<BlackScholesMertonProcess> stochProcess(new
    BlackScholesMertonProcess(Handle<Quote>(spot),
                              Handle<YieldTermStructure>(qTS),
                              Handle<YieldTermStructure>(rTS),
                              Handle<BlackVolTermStructure>(volTS)));
boost::shared_ptr<PricingEngine> engine;
if (values[i].knockin)
   engine.reset(new AnalyticDigitalAmericanEngine(stochProcess));
else
   engine.reset(new AnalyticDigitalAmericanKOEngine(stochProcess));

VanillaOption opt(payoff, amExercise);
opt.setPricingEngine(engine);

Real calculated = opt.NPV();
Real error = std::fabs(calculated-values[i].result);
if (error > values[i].tol) {
    REPORT_FAILURE("value", payoff, amExercise, values[i].s,
                   values[i].q, values[i].r, today, values[i].v,
                   values[i].result, calculated, error, values[i].tol, values[i].knockin);
}
}

for (Size j=0; j<LENGTH(engines); j++) {
for (Size i1=0; i1<LENGTH(types); i1++) {
for (Size i6=0; i6<LENGTH(strikes); i6++) {
  boost::shared_ptr<StrikedTypePayoff> payoff(
                    new CashOrNothingPayoff(types[i1],
                                            strikes[i6], cashPayoff));

  VanillaOption opt(payoff, exercises[j]);
  opt.setPricingEngine(engines[j]);

  for (Size i2=0; i2<LENGTH(underlyings); i2++) {
    for (Size i4=0; i4<LENGTH(qRates); i4++) {
      for (Size i3=0; i3<LENGTH(rRates); i3++) {
        for (Size i7=0; i7<LENGTH(vols); i7++) {
          // test data
          Real u = underlyings[i2];
          Rate q = qRates[i4];
          Rate r = rRates[i3];
          Volatility v = vols[i7];
          spot->setValue(u);
          qRate->setValue(q);
          rRate->setValue(r);
          vol->setValue(v);

          // theta, dividend rho and vega are not available for
          // digital option with american exercise. Greeks of
          // digital options with european payoff are tested
          // in the europeanoption.cpp test
          Real value = opt.NPV();
          calculated["delta"]  = opt.delta();
          calculated["gamma"]  = opt.gamma();
          // calculated["theta"]  = opt.theta();
          calculated["rho"]    = opt.rho();
          // calculated["divRho"] = opt.dividendRho();
          // calculated["vega"]   = opt.vega();

          if (value > 1.0e-6) {
              // perturb spot and get delta and gamma
              Real du = u*1.0e-4;
              spot->setValue(u+du);
              Real value_p = opt.NPV(),
                   delta_p = opt.delta();
              spot->setValue(u-du);
              Real value_m = opt.NPV(),
                   delta_m = opt.delta();
              spot->setValue(u);
              expected["delta"] = (value_p - value_m)/(2*du);
              expected["gamma"] = (delta_p - delta_m)/(2*du);

              // perturb rates and get rho and dividend rho
              Spread dr = r*1.0e-4;
              rRate->setValue(r+dr);
              value_p = opt.NPV();
              rRate->setValue(r-dr);
              value_m = opt.NPV();
              rRate->setValue(r);
              expected["rho"] = (value_p - value_m)/(2*dr);

              /*
              Spread dq = q*1.0e-4;
              qRate->setValue(q+dq);
              value_p = opt.NPV();
              qRate->setValue(q-dq);
              value_m = opt.NPV();
              qRate->setValue(q);
              expected["divRho"] = (value_p - value_m)/(2*dq);

              // perturb volatility and get vega
              Volatility dv = v*1.0e-4;
              vol->setValue(v+dv);
              value_p = opt.NPV();
              vol->setValue(v-dv);
              value_m = opt.NPV();
              vol->setValue(v);
              expected["vega"] = (value_p - value_m)/(2*dv);

              // perturb date and get theta
              Time dT = dc.yearFraction(today-1, today+1);
              Settings::instance().setEvaluationDate(today-1);
              value_m = opt.NPV();
              Settings::instance().setEvaluationDate(today+1);
              value_p = opt.NPV();
              Settings::instance().setEvaluationDate(today);
              expected["theta"] = (value_p - value_m)/dT;
              */

              // check
              std::map<std::string,Real>::iterator it;
              for (it = calculated.begin();
                   it != calculated.end(); ++it) {
                  std::string greek = it->first;
                  Real expct = expected  [greek],
                       calcl = calculated[greek],
                       tol   = tolerance [greek];
                  Real error = relativeError(expct,calcl,value);
                  if (error > tol) {
                      REPORT_FAILURE(greek, payoff, exercise,
                                     u, q, r, today, v,
                                     expct, calcl, error, tol, knockin);
                  }
              }
          }
        }
      }
    }
  }
}
}
}

for (Size i=0; i<LENGTH(values); i++) {

boost::shared_ptr<StrikedTypePayoff> payoff(new CashOrNothingPayoff(
    values[i].type, values[i].strike, 15.0));
//FLOATING_POINT_EXCEPTION
Date exDate = today + Integer(values[i].t*360+0.5);
boost::shared_ptr<Exercise> amExercise(
                                 new AmericanExercise(today, exDate));

spot ->setValue(values[i].s);
qRate->setValue(values[i].q);
rRate->setValue(values[i].r);
vol  ->setValue(values[i].v);

boost::shared_ptr<BlackScholesMertonProcess> stochProcess(new
    BlackScholesMertonProcess(Handle<Quote>(spot),
                              Handle<YieldTermStructure>(qTS),
                              Handle<YieldTermStructure>(rTS),
                              Handle<BlackVolTermStructure>(volTS)));

Size requiredSamples = Size(std::pow(2.0, 14)-1);
boost::shared_ptr<PricingEngine> mcldEngine =
    MakeMCDigitalEngine<LowDiscrepancy>(stochProcess)
    .withStepsPerYear(timeStepsPerYear)
    .withBrownianBridge()
    .withSamples(requiredSamples)
    .withMaxSamples(maxSamples)
    .withSeed(seed);

VanillaOption opt(payoff, amExercise);
opt.setPricingEngine(mcldEngine);

Real calculated = opt.NPV();
Real error = std::fabs(calculated-values[i].result);
if (error > values[i].tol) {
    REPORT_FAILURE("value", payoff, amExercise, values[i].s,
                   values[i].q, values[i].r, today, values[i].v,
                   values[i].result, calculated, error, values[i].tol, values[i].knockin);
}
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/prices.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (i = d.begin(); i != d.end(); ++i) {
    retval[*i] = IntervalPrice(*openi, *closei, *highi, *lowi);
    ++openi; ++closei; ++highi; ++lowi;
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/discretizedasset.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    for (i=0; i<exerciseTimes_.size(); i++) {
        Time t = exerciseTimes_[i];
        if (t >= 0.0 && isOnTime(t))
            applyExerciseCondition();
    }

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/timegrid.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i<=steps; i++)
    times_.push_back(dt*i);

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/currencies/exchangeratemanager.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (i = data_.begin(); i != data_.end(); ++i) {
    // we look for exchange-rate data which involve our source
    // currency...
    if (hashes(i->first, source) && !(i->second.empty())) {
        // ...whose other currency is not forbidden...
        const Entry& e = i->second.front();
        const Currency& other =
            source == e.rate.source() ?
                e.rate.target() : e.rate.source();
        if (std::find(forbidden.begin(),forbidden.end(),
                      other.numericCode()) == forbidden.end()) {
            // ...and which carries information for the requested date.
            if (const ExchangeRate* head = fetch(source,other,date)) {
                // if we can get to the target from here...
                try {
                    ExchangeRate tail = smartLookup(other,target,date,
                                                    forbidden);
                    // ..we're done.
                    return ExchangeRate::chain(*head,tail);
                } catch (Error&) {
                    // otherwise, we just discard this rate.
                    ;
                }
            }
        }
    }
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/experimental/commodities/energyfuture.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (SecondaryCostAmounts::const_iterator i = secondaryCostAmounts_.begin(); i != secondaryCostAmounts_.end(); ++i) {
    Real amount = i->second.value();
    NPV_ -= amount;
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/experimental/commodities/commoditycurve.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i = 1; i < dates_.size(); i++) {
    QL_REQUIRE(dates_[i] > dates_[i-1],
               "invalid date (" << dates_[i] << ", vs "
               << dates_[i-1] << ")");
    times_[i] = dayCounter.yearFraction(dates_[0], dates_[i]);
}

for (std::map<Date, Real>::const_iterator i = prices.begin(); i != prices.end(); ++i) {
    dates_.push_back(i->first);
    data_.push_back(i->second);
}

for (Size i = 1; i < dates_.size(); i++)
    times_[i] = dayCounter().yearFraction(dates_[0], dates_[i]);

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/experimental/commodities/commoditypricinghelpers.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    for (Date periodStartDate=startDate; periodStartDate<endDate; ) {
        Date periodEndDate = (periodStartDate + (1 * Months)) - 1;
        Date paymentDate = paymentTerm.getPaymentDate(periodEndDate);
        pricingPeriods.push_back(boost::shared_ptr<PricingPeriod>(
                     new PricingPeriod(periodStartDate, periodEndDate,
                                       paymentDate, periodQuantity)));
        periodStartDate = periodEndDate + 1;
    }

    for (Date periodStartDate=startDate; periodStartDate<endDate; ) {
        Date periodEndDate = (periodStartDate + (1 * Months)) - 1;

        Quantity periodQuantity =
            quantity * (periodEndDate - periodStartDate);
        Date paymentDate = paymentTerm.getPaymentDate(periodEndDate);
        pricingPeriods.push_back(boost::shared_ptr<PricingPeriod>(
                     new PricingPeriod(periodStartDate, periodEndDate,
                                       paymentDate, periodQuantity)));
        periodStartDate = periodEndDate + 1;
    }

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/experimental/variancegamma/fftengine.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (PayoffMap::const_iterator payIt = payoffMap.begin(); payIt != payoffMap.end(); ++payIt)
{
    Date expiryDate = payIt->first;

    // Calculate n large enough for maximum strike, and round up to a power of 2
    Real maxStrike = 0.0;
    for (PayoffList::const_iterator it = payIt->second.begin();
        it != payIt->second.end(); ++it)
    {
        boost::shared_ptr<StrikedTypePayoff> payoff = *it;

        if (payoff->strike() > maxStrike)
            maxStrike = payoff->strike();
    }
    Real nR = 2.0 * (std::log(maxStrike) + lambda_) / lambda_;
Size log2_n = (static_cast<Size>((std::log(nR) / std::log(2.0))) + 1);
    Size n = 1 << log2_n;

    // Strike range (equation 19,20)
    Real b = n * lambda_ / 2.0;

    // Grid spacing (equation 23)
    Real eta = 2.0 * M_PI / (lambda_ * n);

    // Discount factor
    Real df = discountFactor(expiryDate);
    Real div = dividendYield(expiryDate);

    // Input to fourier transform
    std::vector<std::complex<Real> > fti;
    fti.resize(n);

    // Precalculate any discount factors etc.
    precalculateExpiry(expiryDate);

    for (Size i=0; i<n; i++)
    {
        Real v_j = eta * i;
        Real sw = eta * (3.0 + ((i % 2) == 0 ? -1.0 : 1.0) - ((i == 0) ? 1.0 : 0.0)) / 3.0; 

        std::complex<Real> psi = df * complexFourierTransform(v_j - (alpha + 1)* i1);
        psi = psi / (alpha*alpha + alpha - v_j*v_j + i1 * (2 * alpha + 1.0) * v_j);

        fti[i] = std::exp(i1 * b * v_j)  * sw * psi;
    }

    // Perform fft
    std::vector<std::complex<Real> > results(n);
    FastFourierTransform fft(log2_n);
    fft.transform(fti.begin(), fti.end(), results.begin());

    // Call prices
    std::vector<Real> prices, strikes;
    prices.resize(n);
    strikes.resize(n);
    for (Size i=0; i<n; i++)
    {
        Real k_u = -b + lambda_ * i;
        prices[i] = (std::exp(-alpha * k_u) / M_PI) * results[i].real();
        strikes[i] = std::exp(k_u);
    }

    for (PayoffList::const_iterator it = payIt->second.begin();
        it != payIt->second.end(); ++it)
    {
        boost::shared_ptr<StrikedTypePayoff> payoff = *it;

        Real callPrice = LinearInterpolation(strikes.begin(), strikes.end(), prices.begin())(payoff->strike());
        switch (payoff->optionType())
        {
        case Option::Call:
            resultMap_[expiryDate][payoff] = callPrice;
            break;
        case Option::Put:
            resultMap_[expiryDate][payoff] = callPrice - process_->x0() * div + payoff->strike() * df;
            break;
        default:
            QL_FAIL("Invalid option type");
        }
    }
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/experimental/swaptions/irregularswap.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Leg::const_iterator i = legs_[0].begin(); i < legs_[0].end(); ++i)
    registerWith(*i);

for (Leg::const_iterator i = legs_[1].begin(); i < legs_[1].end(); ++i)
    registerWith(*i);

for (Size i=0; i<fixedCoupons.size(); ++i) {
    boost::shared_ptr<FixedRateCoupon> coupon =
        boost::dynamic_pointer_cast<FixedRateCoupon>(fixedCoupons[i]);

    arguments->fixedPayDates[i]   = coupon->date();
    arguments->fixedResetDates[i] = coupon->accrualStartDate();
    arguments->fixedCoupons[i]    = coupon->amount();
    arguments->fixedNominals[i]   = coupon->nominal(); 
}

for (Size i=0; i<floatingCoupons.size(); ++i) {
    boost::shared_ptr<IborCoupon> coupon =
        boost::dynamic_pointer_cast<IborCoupon>(floatingCoupons[i]);

    arguments->floatingResetDates[i]   = coupon->accrualStartDate();
    arguments->floatingPayDates[i]     = coupon->date();

    arguments->floatingFixingDates[i]  = coupon->fixingDate();
    arguments->floatingAccrualTimes[i] = coupon->accrualPeriod();
    arguments->floatingSpreads[i]      = coupon->spread();
    arguments->floatingNominals[i]     = coupon->nominal();

    try {
        arguments->floatingCoupons[i] = coupon->amount();
    } catch (Error&) {
        arguments->floatingCoupons[i] = Null<Real>();
    }
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/experimental/swaptions/haganirregularswaptionengine.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    for(Size i = 0; i < fixedLeg.size(); ++i)  
    {
        //retrieve fixed rate coupon from fixed leg
        boost::shared_ptr<FixedRateCoupon> coupon = boost::dynamic_pointer_cast<FixedRateCoupon>(fixedLeg[i]);
        QL_REQUIRE(coupon,"dynamic cast of fixed leg coupon failed.");

        expiries_.push_back(coupon->date());

        boost::shared_ptr<FixedRateCoupon> newCpn = boost::shared_ptr<FixedRateCoupon> (
            new  FixedRateCoupon(coupon->date(),
            1.0,
            coupon->rate(),
            coupon->dayCounter(),
            coupon->accrualStartDate(),
            coupon->accrualEndDate(),
            coupon->referencePeriodStart(),
            coupon->referencePeriodEnd())); 

        fixedCFS.push_back(newCpn);

        annuities_.push_back(10000*CashFlows::bps(fixedCFS,**termStructure_,true));

        floatCFS.clear();

        for(Size j = 0; j < floatLeg.size(); ++j){
            //retrieve ibor coupon from floating leg
            boost::shared_ptr<IborCoupon> coupon = boost::dynamic_pointer_cast<IborCoupon>(floatLeg[j]);
            QL_REQUIRE(coupon,"dynamic cast of float leg coupon failed.");

            if( coupon->date() <= expiries_[i] ){
                boost::shared_ptr<IborCoupon> newCpn = boost::shared_ptr<IborCoupon> (
                    new  IborCoupon(coupon->date(),
                    1.0,
                    coupon->accrualStartDate(),
                    coupon->accrualEndDate(),
                    coupon->fixingDays(),
                    coupon->iborIndex(),
                    1.0,
                    coupon->spread(),
                    coupon->referencePeriodStart(),
                    coupon->referencePeriodEnd(),
                    coupon->dayCounter(),
                    coupon->isInArrears())); 


                if (!newCpn->isInArrears())
                    newCpn->setPricer(
                                 boost::shared_ptr<FloatingRateCouponPricer>(
                                          new BlackIborCouponPricer()));

                floatCFS.push_back(newCpn);
            }
        }

        Real floatLegNPV = CashFlows::npv(floatCFS,**termStructure_,true);

        fairRates_.push_back(floatLegNPV/annuities_[i]);

    }

for(Size r = 0; r < n; ++r)
{

    boost::shared_ptr<FixedRateCoupon> cpn_r = boost::dynamic_pointer_cast<FixedRateCoupon>(swap_->fixedLeg()[r]);
                QL_REQUIRE(cpn_r,"Cast to fixed rate coupon failed.");

    //looping over columns
    for(Size c = r; c < n; ++c){

        //set homogenous part of lse
        arr[r][c] = ( fairRates_[c] + lambda_ ) * cpn_r->accrualPeriod();   
    }

    // add nominal repayment for i-th swap
    arr[r][r] += 1;
}

for(Size r = 0; r < n; ++r)
{
    boost::shared_ptr<FixedRateCoupon> cpn_r = boost::dynamic_pointer_cast<FixedRateCoupon>(swap_->fixedLeg()[r]);

    // set inhomogenity of lse
    Real N_r = cpn_r->nominal();

    if(r < n - 1){

        boost::shared_ptr<FixedRateCoupon> cpn_rp1 = boost::dynamic_pointer_cast<FixedRateCoupon>(swap_->fixedLeg()[r+1]);

        Real N_rp1 = cpn_rp1->nominal();

        rhs[r] = N_r * (cpn_r->rate()) * cpn_r->accrualPeriod() + (N_r - N_rp1);

    } else {

        rhs[r] = N_r * (cpn_r->rate()) * cpn_r->accrualPeriod() + N_r;

    }       

}

for(Size i=0; i< weights.size();++i)   defect -= swap_->type()*lambda*weights[i]*annuities_[i];

for(Size j = 0; j < floatLeg.size(); ++j){
    //retrieve ibor coupon from floating leg
    boost::shared_ptr<IborCoupon> coupon = boost::dynamic_pointer_cast<IborCoupon>(floatLeg[j]);
    QL_REQUIRE(coupon,"dynamic cast of float leg coupon failed.");

    boost::shared_ptr<IborCoupon> newCpn = boost::shared_ptr<IborCoupon> (
        new  IborCoupon(coupon->date(),
        coupon->nominal(),
        coupon->accrualStartDate(),
        coupon->accrualEndDate(),
        coupon->fixingDays(),
        coupon->iborIndex(),
        coupon->gearing(),
        0.0,
        coupon->referencePeriodStart(),
        coupon->referencePeriodEnd(),
        coupon->dayCounter(),
        coupon->isInArrears())); 


    if (!newCpn->isInArrears())
        newCpn->setPricer(
                     boost::shared_ptr<FloatingRateCouponPricer>(
                              new BlackIborCouponPricer()));

    floatCFS.push_back(newCpn);
}

for(Size i = 0; i < fixedLeg.size(); ++i)  
{
    //retrieve fixed rate coupon from fixed leg
    boost::shared_ptr<FixedRateCoupon> coupon = boost::dynamic_pointer_cast<FixedRateCoupon>(fixedLeg[i]);
    QL_REQUIRE(coupon,"dynamic cast of fixed leg coupon failed.");

    boost::shared_ptr<FixedRateCoupon> newCpn = boost::shared_ptr<FixedRateCoupon> (
        new  FixedRateCoupon(coupon->date(),
        coupon->nominal(),
        coupon->rate()-cpn_adjustment,
        coupon->dayCounter(),
        coupon->accrualStartDate(),
        coupon->accrualEndDate(),
        coupon->referencePeriodStart(),
        coupon->referencePeriodEnd())); 

    fixedCFS.push_back(newCpn);
}

for(Size i=0; i<weights.size(); ++i)
{
    boost::shared_ptr<VanillaSwap> pvSwap_ = basket.component(i);
    Swaption swaption = Swaption(pvSwap_,exercise);
    swaption.setPricingEngine(blackSwaptionEngine);
    npv += weights[i]*swaption.NPV();
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/experimental/exoticoptions/continuousarithmeticasianvecerengine.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    for (Natural i= 0; i<= SVec.size()-1;i++) {
        SVec[i] = z_min_ + i * h;     // Value of Underlying on the grid
    }

    for (Natural i= 0; i<= SVec.size()-1;i++) {
        u_initial[i] = std::max<Real>(SVec[i] , 0.0); // Call Payoff
    }

    for (Natural i=0; i<=assetSteps_; i++) {
        u_surface[i] = u[i];
    }

    for (Natural j = 1; j<=timeSteps_;j++) {
        if (Theta != 1.0) { // Explicit Part
            for (Natural i = 1; i<= SVec.size()-2;i++) {
                vecerTerm = SVec[i] - std::exp(-q * (T-(j-1)*k))
                          * cont_strategy(T-(j-1)*k,T1,T2,q,r);
                gammaOp.setMidRow(i,
                    0.5 * sigma2 * vecerTerm * vecerTerm  * lowerD[i-1],
                    0.5 * sigma2 * vecerTerm * vecerTerm  * Dia[i],
                    0.5 * sigma2 *  vecerTerm * vecerTerm * upperD[i]);
            }
            explicit_part = gammaOp.identity(gammaOp.size()) +
                            (1 - Theta) * k * gammaOp;
            explicit_part.setFirstRow(1.0,0.0); // Apply before applying
            explicit_part.setLastRow(-1.0,1.0); // Neumann BC

            u = explicit_part.applyTo(u);

            // Apply after applying (Neumann BC)
            u[assetSteps_] = u[assetSteps_-1] + h;
            u[0] = 0;
        } // End Explicit Part

        if (Theta != 0.0) {  // Implicit Part
            for (Natural i = 1; i<= SVec.size()-2;i++) {
                vecerTerm = SVec[i] - std::exp(-q * (T-j*k)) *
                            cont_strategy(T-j*k,T1,T2,q,r);
                gammaOp.setMidRow(i,
                    0.5 * sigma2 * vecerTerm * vecerTerm * lowerD[i-1],
                    0.5 * sigma2 * vecerTerm * vecerTerm  * Dia[i],
                    0.5 * sigma2 * vecerTerm * vecerTerm * upperD[i]);
            }

            implicit_part = gammaOp.identity(gammaOp.size()) -
                            Theta * k * gammaOp;

            // Apply before solving
            implicit_part.setFirstRow(1.0,0.0);
            implicit_part.setLastRow(-1.0,1.0);
            rhs = u;
            rhs[0] = 0; // Lower BC
            rhs[assetSteps_] = h; // Upper BC (Neumann) Delta=1
            u = implicit_part.solveFor(rhs);
        } // End implicit Part

        // Save solution
        for (Natural i=0; i<=assetSteps_; i++) {
            u_surface[j*(assetSteps_+1) + i] = u[i];
        }
    } // End Time Loop

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/experimental/exoticoptions/mceverestengine.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size j=1; j<numAssets; ++j) {
    Rate yield = multiPath[j].back() / multiPath[j].front() - 1.0;
    minYield = std::min(minYield, yield);
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/experimental/exoticoptions/mcpagodaengine.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i = 1; i < numSteps; i++) {
    for (Size j = 0; j < numAssets; j++) {
        averagePerformance +=
            multiPath[j].front() *
            (multiPath[j][i]/multiPath[j][i-1] - 1.0);
    }
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/experimental/exoticoptions/mchimalayaengine.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i = 1; i < numNodes; i++) {
    Real bestPrice = 0.0;
    Real bestYield = QL_MIN_REAL;
    // dummy assignement to avoid compiler warning
    Size removeAsset = 0;
    for (Size j = 0; j < numAssets; j++) {
        if (remainingAssets[j]) {
            Real price = multiPath[j][i];
            Real yield = price/multiPath[j].front();
            if (yield >= bestYield) {
                bestPrice = price;
                removeAsset = j;
            }
        }
    }
    remainingAssets[removeAsset] = false;
    averagePrice += bestPrice;
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/experimental/callablebonds/callablebond.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    for (Size i=0; i<putCallSchedule_.size();++i) {
        finalOptionDate=std::max(finalOptionDate,
                                 putCallSchedule_[i]->date());
    }

for (Size i = 0; i<cashflows_.size(); ++i) {
    // the first coupon paying after d is the one we're after
    if (!cashflows_[i]->hasOccurred(settlement,IncludeToday)) {
        boost::shared_ptr<Coupon> coupon =
            boost::dynamic_pointer_cast<Coupon>(cashflows_[i]);
        if (coupon)
            // !!!
            return coupon->accruedAmount(settlement) /
                   notional(settlement) * 100.0;
        else
            return 0.0;
    }
}

for (Size i=0; i<cfs.size()-1; i++) {
    if (!cfs[i]->hasOccurred(settlement, false)) {
        arguments->couponDates.push_back(cfs[i]->date());
        arguments->couponAmounts.push_back(cfs[i]->amount());
    }
}

for (Size i=0; i<putCallSchedule_.size(); i++) {
    if (!putCallSchedule_[i]->hasOccurred(settlement, false)) {
        arguments->callabilityDates.push_back(
                                         putCallSchedule_[i]->date());
        arguments->callabilityPrices.push_back(
                               putCallSchedule_[i]->price().amount());

        if (putCallSchedule_[i]->price().type()==
            Callability::Price::Clean) {
            /* calling accrued() forces accrued interest to be zero
               if future option date is also coupon date, so that dirty
               price = clean price. Use here because callability is
               always applied before coupon in the tree engine.
            */
            arguments->callabilityPrices.back() +=
                this->accrued(putCallSchedule_[i]->date());
        }
    }
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/experimental/callablebonds/discretizedcallablefixedratebond.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i<couponTimes_.size(); ++i)
    couponTimes_[i] =
        dayCounter.yearFraction(referenceDate,
                                args.couponDates[i]);

for (Size i=0; i<callabilityTimes_.size(); ++i)
    callabilityTimes_[i] =
        dayCounter.yearFraction(referenceDate,
                                args.callabilityDates[i]);

for (Size i=0; i<callabilityTimes_.size(); i++) {
    Time exerciseTime = callabilityTimes_[i];
    for (Size j=0; j<couponTimes_.size(); j++) {
        if (withinNextWeek(exerciseTime, couponTimes_[j]))
            couponTimes_[j] = exerciseTime;
    }
}

for (i=0; i<couponTimes_.size(); i++) {
    t = couponTimes_[i];
    if (t >= 0.0) {
        times.push_back(t);
    }
}

for (i=0; i<callabilityTimes_.size(); i++) {
    t = callabilityTimes_[i];
    if (t >= 0.0) {
        times.push_back(t);
    }
}

for (Size i=0; i<callabilityTimes_.size(); i++) {
    Time t = callabilityTimes_[i];
    if (t >= 0.0 && isOnTime(t)) {
        applyCallability(i);
    }
}

for (Size i=0; i<couponTimes_.size(); i++) {
    Time t = couponTimes_[i];
    if (t >= 0.0 && isOnTime(t)) {
        addCoupon(i);
    }
}

    for (j=0; j<values_.size(); j++) {
        values_[j] =
            std::min(arguments_.callabilityPrices[i],
                     values_[j]);
    }

    for (j=0; j<values_.size(); j++) {
        values_[j] = std::max(values_[j],
                              arguments_.callabilityPrices[i]);
    }

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/experimental/callablebonds/blackcallablebondengine.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i = 0; i < cf.size() - 1; ++i) {
    if (!cf[i]->hasOccurred(settlement, false)) {
        if (cf[i]->hasOccurred(optionMaturity, false)) {
            income += cf[i]->amount() *
                      discountCurve_->discount(cf[i]->date());
        } else {
            break;
        }
    }
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/experimental/catbonds/riskynotional.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (; i<notionalRate_.size() && notionalRate_[i].first<=date; ++i)  //TODO do we take notional after reductions or before?
{}
return notionalRate_[i-1].second;
}

for(size_t i=0; i<events.size(); ++i) {
    if(events[i].second>=threshold_) {
        path.addReduction(paymentOffset_->paymentDate(events[i].first), Rate(0.0));
    }
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/experimental/catbonds/montecarlocatbondengine.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i<arguments_.cashflows.size(); ++i) {
    if (!arguments_.cashflows[i]->hasOccurred(settlementDate, 
                                includeSettlementDateFlows)) {
        Real amount = cashFlowRiskyValue(arguments_.cashflows[i], notionalPath);
        totalNPV += amount * discountCurve_->discount(arguments_.cashflows[i]->date());
    }
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/experimental/shortrate/generalizedhullwhite.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            for (Size i=0; i<size; i++) {
                if (t<times_[i])
                    return params[i];
            }

    for (Size j=0; j<size_; j++) {
        Real discount = std::exp(- fInverse_(theta+x)*dt_);
        value -= statePrices_[j]*discount;
        x += dx_;
    }

for (Size i=0;i<speedstructure.size()-1;i++)
    speedperiods_.push_back(dc.yearFraction(speedstructure[0],
                                            speedstructure[i+1]));

for (Size i=0;i<volstructure.size()-1;i++)
    volperiods_.push_back(dc.yearFraction(volstructure[0],
                                          volstructure[i+1]));

for (Size i=1; i< a_.size();i++){
    a_.setParam(i,0.01*i+0.07);
}

for (Size i=1; i< sigma_.size();i++){
    sigma_.setParam(i,0.01*i+0.01);
}

for (Size i=0;i<speedstructure.size();i++)
    speedperiods_.push_back(dc.yearFraction(ref,
                                            speedstructure[i]));

for (Size i=0;i<volstructure.size();i++)
    volperiods_.push_back(dc.yearFraction(ref,
                                          volstructure[i]));

for (Size i=0; i< sigma_.size();i++) {
    sigma_.setParam(i,vol[i]);
}

for (Size i=0; i< a_.size();i++) {
    a_.setParam(i,speed[i]);
}

for (Size i=0; i<(grid.size() - 1); i++) {
    Real discountBond = termStructure()->discount(grid[i+1]);
    Real xMin = trinomial->underlying(i, 0);
    Real dx = trinomial->dx(i);
    Helper finder(i, xMin, dx, discountBond, numericTree, fInverse_);
    Brent s1d;
    s1d.setMaxEvaluations(2000);
    value =s1d.solve(finder, 1e-8, value, vMin, vMax);
    impl->set(grid[i], value);
}

for (Size i=0;i<a_.size()-1;i++)
    speedvals.push_back(
    a_(
    (speedstructure_[i+1]- Settings::instance().evaluationDate() )/365.0
    - 0.001));

for (Size i=0;i<sigma_.size()-1;i++)
    volvals.push_back(
    sigma_(
    (speedstructure_[i+1]-Settings::instance().evaluationDate() )/365.0
    - 0.001));

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/experimental/coupons/subperiodcoupons.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i<observations_; ++i) {
    observationTimes_.push_back(
        dayCounter.yearFraction(referenceDate, observationDates_[i]));
}

for(Size i=0; i<observationDates.size(); i++) {
    Date fixingDate = calendar.advance(
                         observationDates[i],
                         -static_cast<Integer>(coupon_->fixingDays()),
                         Days);

    initialValues_[i] =
        index->fixing(fixingDate) + coupon_->rateSpread();

    Date fixingValueDate = index->valueDate(fixingDate);
    Date endValueDate = index->maturityDate(fixingValueDate);

    observationIndexStartDates_[i] = fixingValueDate;
    observationIndexEndDates_[i] = endValueDate;

    observationCvg_[i] =
        index->dayCounter().yearFraction(fixingValueDate, endValueDate);
}

for (Size i=0; i<nCount; i++) {
    dTotalPayment += initialValues_[i] * observationCvg_[i];
    dTotalCvg += observationCvg_[i];
}

for (Size i=0; i<nCount; i++) {
    dTotalPayment = initialValues_[i] * observationCvg_[i]*dNotional;
    dNotional += dTotalPayment;
    dTotalCvg += observationCvg_[i];
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/experimental/barrieroption/discretizeddoublebarrieroption.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i<stoppingTimes_.size(); ++i) {
    stoppingTimes_[i] =
        process.time(args.exercise->date(i));
    if (!grid.empty()) {
        // adjust to the given grid
        stoppingTimes_[i] = grid.closestTime(stoppingTimes_[i]);
    }
}

    for (Size i=0; i<stoppingTimes_.size(); i++) {
        if (isOnTime(stoppingTimes_[i])) {
            stoppingTime = true;
            break;
        }
    }

for (Size j=0; j<optvalues.size(); j++) {
    switch (arguments_.barrierType) {
      case DoubleBarrier::KnockIn:
          if (grid[j] <= arguments_.barrier_lo) {
             // knocked in dn
             if (stoppingTime) {
                 optvalues[j] = std::max(vanilla()[j],
                              (*arguments_.payoff)(grid[j]));
             }
             else
                 optvalues[j] = vanilla()[j]; 
          }
          else if (grid[j] >= arguments_.barrier_hi) {
             // knocked in up
             if (stoppingTime) {
                 optvalues[j] = std::max(vanilla()[j],
                              (*arguments_.payoff)(grid[j]));
             }
             else
                 optvalues[j] = vanilla()[j]; 
          }
          else if (endTime)
              optvalues[j] = arguments_.rebate;
          break;
      case DoubleBarrier::KnockOut:
          if (grid[j] <= arguments_.barrier_lo)
              optvalues[j] = arguments_.rebate; // knocked out lo
          else if (grid[j] >= arguments_.barrier_hi)
             optvalues[j] = arguments_.rebate; // knocked out hi
          else if (stoppingTime)
              optvalues[j] = std::max(optvalues[j],
                             (*arguments_.payoff)(grid[j]));
          break;
      case DoubleBarrier::KIKO:
          // low barrier is KI, high is KO
          if (grid[j] <= arguments_.barrier_lo) {
             // knocked in dn
             if (stoppingTime) {
                 optvalues[j] = std::max(vanilla()[j],
                              (*arguments_.payoff)(grid[j]));
             }
             else
                 optvalues[j] = vanilla()[j];
          }
          else if (grid[j] >= arguments_.barrier_hi)
             optvalues[j] = arguments_.rebate; // knocked out hi
          else if (endTime)
              optvalues[j] = arguments_.rebate;
          break;
      case DoubleBarrier::KOKI:
          // low barrier is KO, high is KI
          if (grid[j] <= arguments_.barrier_lo)
              optvalues[j] = arguments_.rebate; // knocked out lo
          else if (grid[j] >= arguments_.barrier_hi) {
             // knocked in up
             if (stoppingTime) {
                 optvalues[j] = std::max(vanilla()[j],
                              (*arguments_.payoff)(grid[j]));
             }
             else
                 optvalues[j] = vanilla()[j];
          }
          else if (endTime)
              optvalues[j] = arguments_.rebate;
          break;
      default:
          QL_FAIL("invalid barrier type");
    }
}

      for (Size j=0; j<optvalues.size()-1; ++j) {
          if (grid[j]<=barrier_lo && grid[j+1] > barrier_lo) {
             // grid[j+1] above barrier_lo, grid[j] under (in),
             // interpolate optvalues[j+1]
             Real ltob = (barrier_lo-grid[j]);
             Real htob = (grid[j+1]-barrier_lo);
             Real htol = (grid[j+1]-grid[j]);
             Real u1 = unenhanced_.values()[j+1];
             Real t1 = unenhanced_.vanilla()[j+1];
             optvalues[j+1] = std::max(0.0, (ltob*t1+htob*u1)/htol); // derman std
          }
          else if (grid[j] < barrier_hi && grid[j+1] >= barrier_hi) {
             // grid[j+1] above barrier_hi (in), grid[j] under, 
             // interpolate optvalues[j]
             Real ltob = (barrier_hi-grid[j]);
             Real htob = (grid[j+1]-barrier_hi);
             Real htol = (grid[j+1]-grid[j]);
             Real u = unenhanced_.values()[j];
             Real t = unenhanced_.vanilla()[j];
             optvalues[j] = std::max(0.0, (ltob*u+htob*t)/htol); // derman std
          }
      }

      for (Size j=0; j<optvalues.size()-1; ++j) {
          if (grid[j]<=barrier_lo && grid[j+1] > barrier_lo) {
             // grid[j+1] above barrier_lo, grid[j] under (out),
             // interpolate optvalues[j+1]
             Real a = (barrier_lo-grid[j])*rebate;
             Real b = (grid[j+1]-barrier_lo)*unenhanced_.values()[j+1];
             Real c = (grid[j+1]-grid[j]);
             optvalues[j+1] = std::max(0.0, (a+b)/c);
          }
          else if (grid[j] < barrier_hi && grid[j+1] >= barrier_hi) {
             // grid[j+1] above barrier_hi (out), grid[j] under, 
             // interpolate optvalues[j]
             Real a = (barrier_hi-grid[j])*unenhanced_.values()[j];
             Real b = (grid[j+1]-barrier_hi)*rebate;
             Real c = (grid[j+1]-grid[j]);
             optvalues[j] = std::max(0.0, (a+b)/c);
          }
      }

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/experimental/barrieroption/perturbativebarrieroptionengine.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for( i=1;i<=npoint;i++) {
    v1p=0.0;
    tmp=taumin+dt*double(2*i-1)*0.5;
    p=0.5*integs(tmp,taumax);
    /*
      !!
      !! Function E(p,tt,a,b,gm)
      !!
    */
    caux=v(p,tt,x,xstar,gm)+v(p,tt,x,-xstar,gm)-v(p,tt,-x,xstar,gm);
    ccaux=ccaux-v(p,tt,-x,-xstar,gm);
    auxnew=ccaux*(-kprice*exp(-xstar*0.5*(1.0-gm))+hbarr*exp(xstar*0.5*(1.0+gm)));
    v1p=v1p+auxnew;
    /*
      !!
      !! Function L(p,tt,a,b,c,gm)
      !!
    */
    b=gm-1.0;
    c=-xstar;
    ccaux=llold(p,tt,x,b,c,gm)-llold(p,tt,-x,b,c,gm);
    auxnew=kprice*(1.0-gm)*ccaux;
    v1p=v1p+auxnew;

    b=-(gm+1.0);
    c=xstar;
    ccaux=llold(p,tt,x,b,c,gm)-llold(p,tt,-x,b,c,gm);
    auxnew=-exp(gm*p)*hbarr*ccaux;
    v1p=v1p+auxnew;

    b=(gm+1.0);
    c=-xstar;
    ccaux=llold(p,tt,x,b,c,gm)-llold(p,tt,-x,b,c,gm);
    auxnew=exp(gm*p)*hbarr*gm*ccaux;
    v1p=v1p+auxnew;
    /*
      !!
      !! Function F(p,tt,a,b,c,gm)
      !!
    */
    b=gm-1.0;
    auxnew=-kprice*(1.0-gm)*(ff(p,tt,x,b,gm)-ff(p,tt,-x,b,gm));
    v1p=v1p+auxnew;

    b=gm+1.0;
    auxnew=-exp(gm*p)*gm*hbarr*(ff(p,tt,x,b,gm)-ff(p,tt,-x,b,gm));
    v1p=v1p+auxnew;

    v1=v1+(alpha(tmp)-gm*0.5*sigmaq(tmp))*v1p;
}

for(i=1;i<=npoint;i++) {
    v2p=0.0;
    tmp=taumin+dt*(double)(2*i-1)*0.5;
    p=0.5*integs(tmp,taumax);

    dtp=(taumax-tmp)/(double)(npoint2);

    for(j=1;j<=npoint2; j++) {
        tmp1=tmp+dtp*(double)(2*j-1)*0.50;
        s=0.50*integs(tmp1,taumax);

        caux=dll(s,p,tt,-x,-1.0+gm,-xstar,gm)-dll(s,p,tt,x,-1.0+gm,-xstar,gm);
        v2pp=caux*kprice*(1.0-gm);

        caux=dll(s,p,tt,-x,-1.0-gm,xstar,gm)-dll(s,p,tt,x,-1.0-gm,xstar,gm);
        v2pp=v2pp-exp(gm*s)*hbarr*caux;

        caux=dll(s,p,tt,-x,1.0+gm,-xstar,gm)-dll(s,p,tt,x,1.0+gm,-xstar,gm);
        v2pp=v2pp+exp(gm*s)*gm*hbarr*caux;

        caux=+dvv(s,p,tt,-x,xstar,gm)-dvv(s,p,tt,x,xstar,gm);
        caux=caux+(dvv(s,p,tt,-x,-xstar,gm)-dvv(s,p,tt,x,-xstar,gm));
        caux2=hbarr*exp(0.5*(1.0+gm)*xstar)-kprice*exp(-0.5*(1.0-gm)*xstar);
        v2pp=v2pp+caux2*caux;

        caux=dff(s,p,tt,-x,-1.0+gm,gm)-dff(s,p,tt,x,-1.0+gm,gm);
        v2pp=v2pp-(1.0-gm)*kprice*caux;

        caux=dff(s,p,tt,-x,1.0+gm,gm)-dff(s,p,tt,x,1.0+gm,gm);
        v2pp=v2pp-exp(gm*s)*gm*hbarr*caux;

        v2pp=v2pp*0.5*(1.0-gm);

        caux=-ddll(s,p,tt,-x,-1.0+gm,-xstar,gm)+ddll(s,p,tt,x,-1.0+gm,-xstar,gm);
        v2pp=v2pp+caux*kprice*(1.0-gm);

        caux=-ddll(s,p,tt,-x,-1.0-gm,xstar,gm)+ddll(s,p,tt,x,-1.0-gm,xstar,gm);
        v2pp=v2pp-exp(gm*s)*hbarr*caux;

        caux=-ddll(s,p,tt,-x,1.0+gm,-xstar,gm)+ddll(s,p,tt,x,1.0+gm,-xstar,gm);
        v2pp=v2pp+exp(gm*s)*gm*hbarr*caux;

        caux=-ddvv(s,p,tt,-x,xstar,gm)+ddvv(s,p,tt,x,xstar,gm);
        caux=caux+(-dvv(s,p,tt,-x,-xstar,gm)+dvv(s,p,tt,x,-xstar,gm));
        caux2=hbarr*exp(0.5*(1.0+gm)*xstar)-kprice*exp(-0.5*(1-gm)*xstar);

        v2pp=v2pp+caux2*caux;

        caux=-ddff(s,p,tt,-x,-1+gm,gm)+ddff(s,p,tt,x,-1+gm,gm);
        v2pp=v2pp-(1.0-gm)*kprice*caux;

        caux=-ddff(s,p,tt,-x,1.0+gm,gm)+ddff(s,p,tt,x,1.0+gm,gm);
        v2pp=v2pp-exp(gm*s)*gm*hbarr*caux;

        v2p=v2p+(alpha(tmp1)-gm*0.5*sigmaq(tmp1))*v2pp;
        v2pp=0.0;
    }

    v2=v2+v2p*(alpha(tmp)-gm*0.5*sigmaq(tmp))*dtp;
}

        for(I = 1; I<=IM; I++)
            {
                if( EI[I] > EI[IP]) IP = I;
                FIN = FIN + FI[I];
                ERR = ERR + EI[I]*EI[I];
            }

for (J = 1; J<= N; J++)
    {
        T = WID*XGK[J+1];
        FC = TVTMFN(CEN-T,H1, H2,  H3, R23, RUA, RUB, AR, RUC, NUC )+TVTMFN(CEN+T,H1, H2,  H3, R23, RUA, RUB, AR, RUC, NUC );
        RESK = RESK + WGK[J+1]*FC;
        if((J-2*int(J/2)) == 0 ) RESG = RESG + WG[1+J/2]*FC;
    }

        for( J = NU-2; J>= 2; J=J-2)
            {
                POLYN = 1.0 + ( J - 1.0 )*CSSTHE*POLYN/(double)J;
            }

                for( J = 1; J<= NU/2;J++)
                    {
                        BVT = BVT + GMPH*( 1 + KS*BTNCKH );
                        BVT = BVT + GMPK*( 1 + HS*BTNCHK );
                        BTNCKH = BTNCKH + BTPDKH;
                        BTPDKH = 2*J*BTPDKH*( 1 - XNKH )/( 2*J + 1 );
                        BTNCHK = BTNCHK + BTPDHK;
                        BTPDHK = 2*J*BTPDHK*( 1 - XNHK )/( 2*J + 1 );
                        GMPH = GMPH*( 2*J - 1 )/( 2*J*( 1 + DH*DH/NU ) );
                        GMPK = GMPK*( 2*J - 1 )/( 2*J*( 1 + DK*DK/NU ) );
                    }

                for( J = 1;J<= ( NU - 1 )/2; J++)
                    {
                        BVT = BVT + GMPH*( 1 + KS*BTNCKH );
                        BVT = BVT + GMPK*( 1 + HS*BTNCHK );
                        BTPDKH = ( 2*J - 1 )*BTPDKH*( 1 - XNKH )/( 2*J );
                        BTNCKH = BTNCKH + BTPDKH;
                        BTPDHK = ( 2*J - 1 )*BTPDHK*( 1 - XNHK )/( 2*J );
                        BTNCHK = BTNCHK + BTPDHK;
                        GMPH = 2*J*GMPH/( ( 2*J + 1 )*( 1 + DH*DH/NU ) );
                        GMPK = 2*J*GMPK/( ( 2*J + 1 )*( 1 + DK*DK/NU ) );
                    }

        for (I = 1;I<= LG; I++){
            for( IS = -1; IS<= 1; IS=IS+2){
                SN = sin( ASR*(  IS*XL[I][NG] + 1 )/2 );
                BVN = BVN + WL[I][NG]*exp( ( SN*HK-HS )/( 1.0-SN*SN ) );

            }
        }

            for (I = 1; I<= LG;I++){
                for( IS = -1; IS<=1; IS=IS+2){
                    XS =POW( ( AA*(  IS*XL[I][NG] + 1 ) ),2)  ;
                    RS = POW( (1 - XS),2 );
                    ASR = -( BS/XS + HK )/2;
                    if ( ASR > -100 ) {

                        BVN = BVN + AA*WL[I][NG]*exp( ASR )*(exp( -HK*( 1 - RS )/( 2*( 1 + RS ) ) )/RS- ( 1 + C*XS*( 1 + D*XS ) ) );


                    }
                }
            }

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/experimental/barrieroption/analyticdoublebarrierbinaryengine.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i = 1 ; i < maxIteration ; ++i)
{
   Real term1 = (lo_alpha-std::pow(-1.0, (int)i)*hi_alpha) /
                      (std::pow(alpha,2)+std::pow(i*PI/Z, 2));
   Real term2 = std::sin(i*PI/Z * std::log(spot/barrier_lo));
   Real term3 = std::exp(-0.5*(std::pow(i*PI/Z,2)-beta)*variance);
   term = factor * i * term1 * term2 * term3;
   tot += term;
}

for (Size i = 1 ; i < maxIteration ; ++i)
{
    Real factor = std::pow(i*PI/Z,2)-beta;
    Real term1 = (beta - std::pow(i*PI/Z,2) * std::exp(-0.5*factor*variance)) / factor;
    Real term2 = std::sin(i * PI/Z * log_S_L);
    term = (2.0/(i*PI)) * term1 * term2;
    tot += term;
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/experimental/barrieroption/analyticdoublebarrierengine.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (int n = -series_ ; n <= series_ ; ++n) {
  Real L2n = std::pow(barrierLo(), 2 * n);
  Real U2n = std::pow(barrierHi(), 2 * n);
  Real d1 = std::log( underlying()* U2n / (strike() * L2n) ) / stdDeviation() + bsigma;
  Real d2 = std::log( underlying()* U2n / (barrierHi() * L2n) ) / stdDeviation() + bsigma;
  Real d3 = std::log( std::pow(barrierLo(), 2 * n + 2) / (strike() * underlying() * U2n) ) / stdDeviation() + bsigma;
  Real d4 = std::log( std::pow(barrierLo(), 2 * n + 2) / (barrierHi() * underlying() * U2n) ) / stdDeviation() + bsigma;

  acc1 += std::pow( std::pow(barrierHi(), n) / std::pow(barrierLo(), n), mu1 ) * 
          (f_(d1) - f_(d2)) -
          std::pow( std::pow(barrierLo(), n+1) / (std::pow(barrierHi(), n) * underlying()), mu1 ) * 
          (f_(d3) - f_(d4));

  acc2 += std::pow( std::pow(barrierHi(), n) / std::pow(barrierLo(), n), mu1-2) * 
          (f_(d1 - stdDeviation()) - f_(d2 - stdDeviation())) -
          std::pow( std::pow(barrierLo(), n+1) / (std::pow(barrierHi(), n) * underlying()), mu1-2 ) * 
          (f_(d3-stdDeviation()) - f_(d4-stdDeviation()));
}

for (int n = -series_ ; n <= series_ ; ++n) {
  Real L2n = std::pow(barrierLo(), 2 * n);
  Real U2n = std::pow(barrierHi(), 2 * n);
  Real y1 = std::log( underlying()* U2n / (std::pow(barrierLo(), 2 * n + 1)) ) / stdDeviation() + bsigma;
  Real y2 = std::log( underlying()* U2n / (strike() * L2n) ) / stdDeviation() + bsigma;
  Real y3 = std::log( std::pow(barrierLo(), 2 * n + 2) / (barrierLo() * underlying() * U2n) ) / stdDeviation() + bsigma;
  Real y4 = std::log( std::pow(barrierLo(), 2 * n + 2) / (strike() * underlying() * U2n) ) / stdDeviation() + bsigma;

  acc1 += std::pow( std::pow(barrierHi(), n) / std::pow(barrierLo(), n), mu1-2) * 
          (f_(y1 - stdDeviation()) - f_(y2 - stdDeviation())) -
          std::pow( std::pow(barrierLo(), n+1) / (std::pow(barrierHi(), n) * underlying()), mu1-2 ) * 
          (f_(y3-stdDeviation()) - f_(y4-stdDeviation()));

  acc2 += std::pow( std::pow(barrierHi(), n) / std::pow(barrierLo(), n), mu1 ) * 
          (f_(y1) - f_(y2)) -
          std::pow( std::pow(barrierLo(), n+1) / (std::pow(barrierHi(), n) * underlying()), mu1 ) * 
          (f_(y3) - f_(y4));

}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/experimental/barrieroption/wulinyongdoublebarrierengine.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for(int n = -series_; n < series_; n++){
    Real d1 = D(S/H*std::pow(L/H, 2.0*n), vol*vol+mu, vol, T);
    Real d2 = d1 - vol*std::sqrt(T);
    Real g1 = D(H/S*std::pow(L/H, 2.0*n - 1.0), vol*vol+mu, vol, T);
    Real g2 = g1 - vol*std::sqrt(T);
    Real h1 = D(S/H*std::pow(L/H, 2.0*n - 1.0), vol*vol+mu, vol, T);
    Real h2 = h1 - vol*std::sqrt(T);
    Real k1 = D(L/S*std::pow(L/H, 2.0*n - 1.0), vol*vol+mu, vol, T);
    Real k2 = k1 - vol*std::sqrt(T);
    Real d1_down = D(S/K_down*std::pow(L/H, 2.0*n), vol*vol+mu, vol, T);
    Real d2_down = d1_down - vol*std::sqrt(T);
    Real d1_up = D(S/K_up*std::pow(L/H, 2.0*n), vol*vol+mu, vol, T);
    Real d2_up = d1_up - vol*std::sqrt(T);
    Real k1_down = D((H*H)/(K_down*S)*std::pow(L/H, 2.0*n), vol*vol+mu, vol, T);
    Real k2_down = k1_down - vol*std::sqrt(T);
    Real k1_up = D((H*H)/(K_up*S)*std::pow(L/H, 2.0*n), vol*vol+mu, vol, T);
    Real k2_up = k1_up - vol*std::sqrt(T);

    if( payoff->optionType() == Option::Call) {
        barrierOut += std::pow(L/H, 2.0 * n * mu/(vol*vol))*
                    (df*S*std::pow(L/H, 2.0*n)*(f_(d1_down)-f_(d1))
                    -dd*K*(f_(d2_down)-f_(d2))
                    -df*std::pow(L/H, 2.0*n)*H*H/S*std::pow(H/S, 2.0*mu/(vol*vol))*(f_(k1_down)-f_(k1))
                    +dd*K*std::pow(H/S,2.0*mu/(vol*vol))*(f_(k2_down)-f_(k2)));
    }
    else if(payoff->optionType() == Option::Put){
        barrierOut += std::pow(L/H, 2.0 * n * mu/(vol*vol))*
                    (dd*K*(f_(h2)-f_(d2_up))
                    -df*S*std::pow(L/H, 2.0*n)*(f_(h1)-f_(d1_up))
                    -dd*K*std::pow(H/S,2.0*mu/(vol*vol))*(f_(g2)-f_(k2_up))
                    +df*std::pow(L/H, 2.0*n)*H*H/S*std::pow(H/S, 2.0*mu/(vol*vol))*(f_(g1)-f_(k1_up)));
    }
    else {
        QL_FAIL("option type not recognized");
    }

    Real v1 = D(H/S*std::pow(H/L, 2.0*n), -mu, vol, T);
    Real v2 = D(H/S*std::pow(H/L, 2.0*n), mu, vol, T);
    Real v3 = D(S/L*std::pow(H/L, 2.0*n), -mu, vol, T);
    Real v4 = D(S/L*std::pow(H/L, 2.0*n), mu, vol, T);
    rebateIn +=  dd * R_H * sgn * (std::pow(L/H, 2.0*n*mu/(vol*vol)) * f_(sgn * v1) - std::pow(H/S, 2.0*mu/(vol*vol)) * f_(-sgn * v2))
               + dd * R_L * sgn * (std::pow(L/S, 2.0*mu/(vol*vol)) * f_(-sgn * v3) - std::pow(H/L, 2.0*n*mu/(vol*vol)) * f_(sgn * v4));
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/experimental/convertiblebonds/convertiblebond.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i<n; i++) {
    if (!callability_[i]->hasOccurred(settlement, false)) {
        moreArgs->callabilityTypes.push_back(callability_[i]->type());
        moreArgs->callabilityDates.push_back(callability_[i]->date());
        moreArgs->callabilityPrices.push_back(
                                    callability_[i]->price().amount());
        if (callability_[i]->price().type() ==
                                            Callability::Price::Clean)
            moreArgs->callabilityPrices.back() +=
                bond_->accruedAmount(callability_[i]->date());
        boost::shared_ptr<SoftCallability> softCall =
            boost::dynamic_pointer_cast<SoftCallability>(
                                                     callability_[i]);
        if (softCall)
            moreArgs->callabilityTriggers.push_back(
                                                 softCall->trigger());
        else
            moreArgs->callabilityTriggers.push_back(Null<Real>());
    }
}

for (Size i=0; i<cashflows.size()-1; i++) {
    if (!cashflows[i]->hasOccurred(settlement, false)) {
        moreArgs->couponDates.push_back(cashflows[i]->date());
        moreArgs->couponAmounts.push_back(cashflows[i]->amount());
    }
}

for (Size i=0; i<dividends_.size(); i++) {
    if (!dividends_[i]->hasOccurred(settlement, false)) {
        moreArgs->dividends.push_back(dividends_[i]);
        moreArgs->dividendDates.push_back(dividends_[i]->date());
    }
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/experimental/convertiblebonds/discretizedconvertible.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i<arguments_.dividends.size(); i++) {
    if (arguments_.dividends[i]->date() >= settlementDate) {
        dividendValues_[i] =
            arguments_.dividends[i]->amount() *
            process_->riskFreeRate()->discount(
                                     arguments_.dividends[i]->date());
    }
}

for (Size i=0; i<stoppingTimes_.size(); ++i)
    stoppingTimes_[i] =
        dayCounter.yearFraction(bondSettlement,
                                arguments_.exercise->date(i));

for (Size i=0; i<callabilityTimes_.size(); ++i)
    callabilityTimes_[i] =
        dayCounter.yearFraction(bondSettlement,
                                arguments_.callabilityDates[i]);

for (Size i=0; i<couponTimes_.size(); ++i)
    couponTimes_[i] =
        dayCounter.yearFraction(bondSettlement,
                                arguments_.couponDates[i]);

for (Size i=0; i<dividendTimes_.size(); ++i)
    dividendTimes_[i] =
        dayCounter.yearFraction(bondSettlement,
                                arguments_.dividendDates[i]);

    for (Size i=0; i<stoppingTimes_.size(); i++)
        stoppingTimes_[i] = grid.closestTime(stoppingTimes_[i]);

    for (Size i=0; i<couponTimes_.size(); i++)
        couponTimes_[i] = grid.closestTime(couponTimes_[i]);

    for (Size i=0; i<callabilityTimes_.size(); i++)
        callabilityTimes_[i] = grid.closestTime(callabilityTimes_[i]);

    for (Size i=0; i<dividendTimes_.size(); i++)
        dividendTimes_[i] = grid.closestTime(dividendTimes_[i]);

for (Size j=0; j<values_.size(); j++) {
   spreadAdjustedRate_[j] =
       conversionProbability_[j] * riskFreeRate +
       (1-conversionProbability_[j])*(riskFreeRate + creditSpread);
}

    for (Size i=0; i<stoppingTimes_.size(); ++i) {
        if (isOnTime(stoppingTimes_[i]))
            convertible = true;
    }

for (Size i=0; i<callabilityTimes_.size(); i++) {
    if (isOnTime(callabilityTimes_[i]))
        applyCallability(i,convertible);
}

for (Size i=0; i<couponTimes_.size(); i++) {
    if (isOnTime(couponTimes_[i]))
        addCoupon(i);
}

for (Size j=0; j<values_.size(); j++) {
    Real payoff = arguments_.conversionRatio*grid[j];
    if (values_[j] <= payoff) {
        values_[j] = payoff;
        conversionProbability_[j] = 1.0;
    }
}

        for (j=0; j<values_.size(); j++) {
            // the callability is conditioned by the trigger...
            if (grid[j] >= trigger) {
                // ...and might trigger conversion
                values_[j] =
                    std::min(std::max(
                                  arguments_.callabilityPrices[i],
                                  arguments_.conversionRatio*grid[j]),
                             values_[j]);
            }
        }

        for (j=0; j<values_.size(); j++) {
            // exercising the callability might trigger conversion
            values_[j] =
                std::min(std::max(arguments_.callabilityPrices[i],
                                  arguments_.conversionRatio*grid[j]),
                         values_[j]);
        }

        for (j=0; j<values_.size(); j++) {
            values_[j] = std::min(arguments_.callabilityPrices[i],
                                  values_[j]);
        }

    for (j=0; j<values_.size(); j++) {
        values_[j] = std::max(values_[j],
                              arguments_.callabilityPrices[i]);
    }

for (Size i=0; i<arguments_.dividends.size(); i++) {
    Time dividendTime = dividendTimes_[i];
    if (dividendTime >= t || close(dividendTime,t)) {
        const boost::shared_ptr<Dividend>& d = arguments_.dividends[i];
        DiscountFactor dividendDiscount =
            process_->riskFreeRate()->discount(dividendTime) /
            process_->riskFreeRate()->discount(t);
        for (Size j=0; j<grid.size(); j++)
            grid[j] += d->amount(grid[j])*dividendDiscount;
    }
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/experimental/amortizingbonds/amortizingfixedratebond.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        for(Integer i=lowRatio; i <= highRatio; ++i) {
            Period testPeriod = subPeriod * i;
            if(testPeriod == superPeriod) {
                numSubPeriods = i;
                return true;
            }
        }

    for(Size i = 0; i < (Size)nPeriods-1; ++i) {
        compoundedInterest *= (1.0 + coupon);
        Real currentNotional = 0.0;
        if(coupon < 1.0e-12) {
            currentNotional =
               initialNotional*(1.0 - (i+1.0)/nPeriods);
        }
        else {
            currentNotional =
               initialNotional*(compoundedInterest - (compoundedInterest-1.0)/(1.0 - 1.0/totalValue));
        }
        notionals[i+1] = currentNotional;
    }

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/experimental/varianceoption/integralhestonvarianceoptionengine.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (j=0;j<=mm-1;j++)
{
    xiv[j+1]=(double)(j-mm/2)*nris;
}

for (j=0;j<=mm-1;j++)
{
    xi=xiv[j+1];
    caux=chi*chi;
    caux1=2.0*eps*eps;
    caux1=caux1*xi;
    caux1=caux1*ui;
    caux2=caux1+caux;

    zita=0.5*std::sqrt(caux2);

    caux1=std::exp(-2.0*tau*zita);

    beta=0.5*chi+zita;
    beta=beta+caux1*(zita-0.5*chi);
    gamma=1.0-caux1;

    caux=-ss*tau;
    caux2=caux*(zita-0.5*chi);
    caux=ss*std::log(2.0*(zita/beta));
    caux3=-v0*ui*xi*(gamma/beta);
    caux=caux+caux3;
    caux=caux+caux2;

    ff[j+1]=std::exp(caux);
    if(std::sqrt(std::imag(xi)*std::imag(xi)+std::real(xi)*std::real(xi))>1.e-06)
    {
        contrib=-eprice/(ui*xi);
        caux=ui*xi;
        caux=caux*eprice;
        caux=std::exp(caux);
        caux=caux-1.0;
        caux2=ui*xi*ui*xi;
        contrib=contrib+caux/caux2;
    }
    else
    {
        contrib=eprice*eprice*0.5;
    }
    ff[j+1]=ff[j+1]*contrib;
}

for (j=0;j<=mm-1;j++)
{
    caux=std::pow(-1.0,j);
    caux2=-2.0*pi*(double)mm*(double)j*0.5/(double)mm;
    caux3=ui*caux2;
    csum=csum+ff[j+1]*caux*std::exp(caux3);
}

for (j=0;j<=mm-1;j++)
{
    xiv[j+1]=(double)(j-mm/2)*nris;
    ivet[j+1]=(double)(j-mm/2)*pi2/((double)mm*nris);
}

for (j=0;j<=mm-1;j++)
{
    xi=xiv[j+1];

    caux=chi*chi;
    caux1=2.0*eps*eps;
    caux1=caux1*xi;
    caux1=caux1*ui;
    caux2=caux1+caux;

    zita=0.5*std::sqrt(caux2);
    caux1=std::exp(-2.0*tau*zita);

    beta=0.5*chi+zita;
    beta=beta+caux1*(zita-0.5*chi);

    gamma=1.0-caux1;

    caux=-ss*tau;
    caux2=caux*(zita-0.5*chi);
    caux=ss*std::log(2.0*(zita/beta));
    caux3=-v0*ui*xi*(gamma/beta);
    caux=caux+caux3;
    caux=caux+caux2;
    ff[j+1]=std::exp(caux);
}

for (k=0;k<=mm-1;k++)
{
    ip=i0-ivet[k+1];
    payoffval=payoff(ip);

    dxi=2.0*pi*(double)k/(double)mm*ui;
    csum=0.0;
    for (j=0;j<=mm-1;j++)
    {
        z=-(double)j*dxi;
        caux=std::pow(-1.0,j);
        csum=csum+ff[j+1]*caux*std::exp(z);
    }
    csum=csum*std::pow(-1.0,k)*nris/pi2;

    sumr=sumr+payoffval*std::real(csum);
    //sumi=sumi+payoffval*std::imag(csum);
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/experimental/finitedifferences/dynprogvppintrinsicvalueengine.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size j=powerPrices_.size(); j > 0; --j) {
    stepCondition->applyTo(state, (Time) j-1);
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/experimental/finitedifferences/glued1dmesher.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i < locations_.size()-1; ++i) {
    dplus_[i] = dminus_[i+1] = locations_[i+1] - locations_[i];
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/experimental/finitedifferences/fdmvppstartlimitstepcondition.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i < nStates_; ++i) {
    const Size j = i % sss;

    if (j < tMinUp_-1) {
        retVal[i] = std::max(state[i+1], state[tMinUp_+i+1]);
    }
    else if (j == tMinUp_-1) {
        retVal[i] = std::max(state[i+tMinUp_+1],
                             std::max(state[i], state[i+tMinUp_]));
    }
    else if (j < 2*tMinUp_) {
        retVal[i] = retVal[i-tMinUp_];
    }
    else if (j <  2*tMinUp_+tMinDown_-1) {
        retVal[i] = state[i+1];
    }
    else if (nStarts_ == Null<Size>()) {
        retVal[i] = std::max(state[i],
            std::max(state.front(), state[tMinUp_]) - startUpCost);

    }
    else if (i >= sss) {
        retVal[i] = std::max(state[i],
            std::max(state[i+1-2*sss], state[i+1-2*sss+tMinUp_])
                    - startUpCost);
    }
    else {
        retVal[i] = state[i];
    }
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/experimental/finitedifferences/fdsimpleklugeextouvppengine.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i < results.size(); ++i) {

    x[3] = std::max(minExerciseValue + tol,
                    std::min(exerciseMesher->location(i),
                             maxExerciseValue - tol));
    results[i] = solver->valueAt(x);
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/experimental/finitedifferences/fdmextoujumpop.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    for (Size i=0; i < yInt.size(); ++i) {
        const Real weight = std::exp(-yInt[i])*weights[i];

        const Real ys = y + yInt[i]/eta;
        const Integer l = (ys > yLoc.back()) ? yLoc.size()-2
            : std::upper_bound(yLoc.begin(),
                               yLoc.end()-1, ys) - yLoc.begin()-1;

        const Real s = (ys-yLoc[l])/(yLoc[l+1]-yLoc[l]);
        integroPart_(diag, layout->neighbourhood(iter, 1, l-yIndex))
            += weight*lambda*(1-s);
        integroPart_(diag, layout->neighbourhood(iter, 1, l+1-yIndex))
            += weight*lambda*s;
    }

for (Size k=0; k < extraDims; ++k) {
    for (Size i=0; i < f[k].columns(); ++i) {
        interpl[k][i] = boost::shared_ptr<LinearInterpolation>(
            new LinearInterpolation(y[k].begin(), y[k].end(),
                                    f[k].column_begin(i)));
    }
}

for (FdmLinearOpIterator iter=layout->begin(); iter!=endIter; ++iter) {
    const Size i = iter.coordinates()[0];
    const Size j = iter.coordinates()[1];
    const Size k = iter.index() / (layout->dim()[0]*layout->dim()[1]);

    integral[iter.index()] = gaussLaguerreIntegration_(
                IntegroIntegrand(interpl[k][i], bcSet_, y[k][j], eta));
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/experimental/finitedifferences/fdmvppstepcondition.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i < nStates_; ++i) {
    const Size j = i % (2*tMinUp_ + tMinDown_);

    if (j < tMinUp_) {
        stateEvolveFcts_[i] = boost::function<Real (Real)>(
            boost::bind(&FdmVPPStepCondition::evolveAtPMin,this, _1));
    }
    else if (j < 2*tMinUp_){
        stateEvolveFcts_[i] = boost::function<Real (Real)>(
            boost::bind(&FdmVPPStepCondition::evolveAtPMax,this, _1));
    }
}

for (FdmLinearOpIterator iter=layout->begin();iter != endIter; ++iter) {
    a[iter.index()] += evolve(iter, t);
}

for (FdmLinearOpIterator iter=layout->begin();iter != endIter; ++iter) {
    if (!iter.coordinates()[stateDirection_]) {

        Array x(nStates);
        for (Size i=0; i < nStates; ++i) {
            x[i] = a[layout->neighbourhood(iter, stateDirection_, i)];
        }

        const Real gasPrice = gasPrice_->innerValue(iter, t);
        x = changeState(gasPrice, x, t);
        for (Size i=0; i < nStates; ++i) {
            a[layout->neighbourhood(iter, stateDirection_, i)] = x[i];
        }
    }
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/experimental/finitedifferences/fdsimpleextoustorageengine.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i<arguments_.exercise->dates().size(); ++i) {
    const Time t = rTS_->dayCounter()
                   .yearFraction(rTS_->referenceDate(),
                                 arguments_.exercise->dates()[i]);

    QL_REQUIRE(t >= 0, "exercise dates must not contain past date");
    exerciseTimes.push_back(t);
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/experimental/math/expm.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        for (Size i=0; i < result.size(); i++) {
            result[i] = std::inner_product(y.begin(), y.end(),
                                           m_.row_begin(i), 0.0);
        }

for (Size i=0; i < n; ++i) {
    std::vector<Real> x0(n, 0.0);
    x0[i] = 1.0;

    const std::vector<Real> r = rk(odeFct, x0, 0.0, t);
    std::copy(r.begin(), r.end(), result.column_begin(i));
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/experimental/math/tcopulapolicy.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for(Size iFactor=0; iFactor<vals.tOrders.size(); iFactor++) {
    // require no T is of order 2 (finite variance)
    QL_REQUIRE(vals.tOrders[iFactor] > 2, 
        "Non finite variance T in latent model.");

    distributions_.push_back(boost::math::students_t_distribution<>(
        vals.tOrders[iFactor]));
    // inverses T variaces used in normalization of the random factors
    // For low values of the T order this number is very close to zero 
    // and it enters the expresions dividing them, which introduces 
    // numerical errors.
    varianceFactors_.push_back(std::sqrt(
        (vals.tOrders[iFactor]-2.)/vals.tOrders[iFactor]));
}

for(Size iLVar=0; iLVar<factorWeights.size(); iLVar++) {
    // This ensures the latent model is 'canonical'
    QL_REQUIRE(vals.tOrders.size() == factorWeights[iLVar].size()+1, 
        // num factors plus one
        "Incompatible number of T functions and number of factors."); 

    Real factorsNorm = std::inner_product(factorWeights[iLVar].begin(), 
        factorWeights[iLVar].end(), factorWeights[iLVar].begin(), 0.);
    QL_REQUIRE(factorsNorm < 1., 
        "Non normal random factor combination.");
    Real idiosyncFctr = std::sqrt(1.-factorsNorm);

    // linear comb factors ajusted for the variance renormalization:
    std::vector<Real> normFactorWeights;
    for(Size iFactor=0; iFactor<factorWeights[iLVar].size(); iFactor++)
        normFactorWeights.push_back(factorWeights[iLVar][iFactor] * 
            varianceFactors_[iFactor]);
    // idiosincratic term, all Z factors are assumed identical.
    normFactorWeights.push_back(idiosyncFctr * varianceFactors_.back());
    latentVarsCumul_.push_back( 
        CumulativeBehrensFisher(vals.tOrders, normFactorWeights));
    latentVarsInverters_.push_back(
        InverseCumulativeBehrensFisher(vals.tOrders, 
            normFactorWeights));
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/experimental/math/convolvedstudentt.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for(Size i=0; i<degreesFreedom.size(); i++) {
    QL_REQUIRE(degreesFreedom[i]%2 != 0,
        "Even degree of freedom not allowed");
    QL_REQUIRE(degreesFreedom[i] >= 0,
        "Negative degree of freedom not allowed");
}

for(Size i=0; i<degreesFreedom_.size(); i++)
    polynCharFnc_.push_back(polynCharactT((degreesFreedom[i]-1)/2));

for(Size i=0; i<degreesFreedom_.size(); i++) {
    Real multiplier = 1.;
    for(Size k=1; k<polynCharFnc_[i].size(); k++) {
        multiplier *= std::abs(factors_[i]);
        polynCharFnc_[i][k] *= multiplier;
    }
}

for(Size i=0; i<polynCharFnc_.size(); i++)
    polyConvolved_ =
        convolveVectorPolynomials(polyConvolved_, polynCharFnc_[i]);

  for(Size i=0; i<degreesFreedom_.size(); i++)
      a_ += std::sqrt(static_cast<Real>(degreesFreedom_[i]))
        * std::abs(factors_[i]);

for(Size k=1; k<n; k++) {
    std::vector<Real> recursionFactor(1,0.); // 0 coef
    recursionFactor.push_back(0.); // 1 coef
    recursionFactor.push_back(nu/((2.*k+1.)*(2.*k-1.))); // 2 coef
    std::vector<Real> lowUp =
        convolveVectorPolynomials(recursionFactor, low);
    //add them up:
    for(Size i=0; i<high.size(); i++)
        lowUp[i] += high[i];
    low = high;
    high = lowUp;
}

for(Size polyOrdr=0; polyOrdr<resultB.size(); polyOrdr++) {
    for(Size i=std::max<Integer>(0, polyOrdr-longer.size()+1);
        i<=std::min(polyOrdr, shorter.size()-1); i++)
        resultB[polyOrdr] += shorter[i]*longer[polyOrdr-i];
}

for(Size exponent = 2; exponent <polyConvolved_.size(); exponent++) {
    integral -= polyConvolved_[exponent] *
        Factorial::get(exponent-1) * std::sin((exponent)*atan2xa)
            /std::pow(rootsqr, static_cast<Real>(exponent));
 }

for(Size exponent=1; exponent <polyConvolved_.size(); exponent++) {
    integral += polyConvolved_[exponent] *
        Factorial::get(exponent) * std::cos((exponent+1)*atan2xa)
            /std::pow(rootsqr, static_cast<Real>(exponent+1) );
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/experimental/math/numericaldifferentiation.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        for (Integer i=0; i < Integer(n); ++i)
            retVal[i] = (i-Integer(n)/2)*h;

        for (Size i=0; i < n; ++i)
            retVal[i]=-(i*h);

        for (Size i=0; i < n; ++i)
            retVal[i]=i*h;

    for (Size n=1; n < N; ++n) {
        Real c2 = 1.0;
        for (Size nu=0; nu < n; ++nu) {
            const Real c3 = x[n] - x[nu];
            c2*=c3;

            for (Size m=0; m <= std::min(n, M); ++m) {
                d[m][n][nu] = (x[n]*d[m][n-1][nu]
                     - ((m > 0)? m*d[m-1][n-1][nu] : 0.0))/c3;
            }
        }

        for (Size m=0; m <= M; ++m) {
            d[m][n][n] = c1/c2*( ((m > 0)? m*d[m-1][n-1][n-1] : 0.0) -
                x[n-1]*d[m][n-1][n-1] );
        }
        c1=c2;
    }

    for (Size i=0; i < N; ++i) {
        retVal[i] = d[M][N-1][i];
    }

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/experimental/math/zigguratrng.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (;;) {
    j = mt32_.nextInt32(); // generate 32 bits of randomness
    f = j & 1; // 1 bit to choose a tails
    j >>= 1;
    i = j & 0x7f; // 7 bits to choose a strip
    j >>= 7; // the last 24 bits for accepttion/rejection
    x = (c[f]*static_cast<long>(j))*w_[i]; // x is uniform
                                           // within the i-th strip
    if (j < k_[i]) // if true, accept x
        break;

    // handle rejections
    if (i!=0) { // upper strips
        if ((f_[i-1]-f_[i])*mt32_.nextReal() + f_[i] < std::exp(-0.5*x*x))
            break;
    } else { // base strip, sample from the tail
        x = c[f]*InverseCumulativeNormal::standard_value(
                                              p_*mt32_.nextReal()+q_);
        break;
    }
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/experimental/inflation/cpicapfloortermpricesurface.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for(Size j = 0; j <cfMaturities_.size(); j++) {
    QL_REQUIRE( cfMaturities[j] > Period(0,Days), "non-positive maturities");
    if(j>0) {
        QL_REQUIRE( cfMaturities[j] > cfMaturities[j-1],
                    "non-increasing maturities");
    }
    for(Size i = 0; i <fPrice_.rows(); i++) {
        QL_REQUIRE( fPrice_[i][j] > 0.0,
                    "non-positive floor price: " << fPrice_[i][j] );
        if(i>0) {
            QL_REQUIRE( fPrice_[i][j] >= fPrice_[i-1][j],
                        "non-increasing floor prices");
        }
    }
    for(Size i = 0; i <cPrice_.rows(); i++) {
        QL_REQUIRE( cPrice_[i][j] > 0.0,
                    "non-positive cap price: " << cPrice_[i][j] );
        if(i>0) {
            QL_REQUIRE( cPrice_[i][j] <= cPrice_[i-1][j],
                        "non-decreasing cap prices: " 
                       << cPrice_[i][j] << " then " << cPrice_[i-1][j]);
        }
    }
}

for(Size i = 0; i <fStrikes_.size(); i++)
    cfStrikes_.push_back( fStrikes[i] );

for(Size i = 0; i < cStrikes_.size(); i++) {
    Rate k = cStrikes[i];
    if (k > maxFstrike + eps) cfStrikes_.push_back(k);
}

for (Size i = 1; i < cfStrikes_.size(); i++)
    QL_REQUIRE( cfStrikes_[i] > cfStrikes_[i-1],
                "cfStrikes not increasing");

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/experimental/inflation/yoycapfloortermpricesurface.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for(Size j = 0; j <cfMaturities_.size(); j++) {
    QL_REQUIRE( cfMaturities[j] > Period(0,Days), "non-positive maturities");
    if(j>0) {
        QL_REQUIRE( cfMaturities[j] > cfMaturities[j-1],
                    "non-increasing maturities");
    }
    for(Size i = 0; i <fPrice_.rows(); i++) {
        QL_REQUIRE( fPrice_[i][j] > 0.0,
                    "non-positive floor price: " << fPrice_[i][j] );
        if(i>0) {
            QL_REQUIRE( fPrice_[i][j] >= fPrice_[i-1][j],
                        "non-increasing floor prices");
        }
    }
    for(Size i = 0; i <cPrice_.rows(); i++) {
        QL_REQUIRE( cPrice_[i][j] > 0.0,
                    "non-positive cap price: " << cPrice_[i][j] );
        if(i>0) {
            QL_REQUIRE( cPrice_[i][j] <= cPrice_[i-1][j],
                        "non-decreasing cap prices");
        }
    }
}

for(Size i = 0; i <fStrikes_.size(); i++)
    cfStrikes_.push_back( fStrikes[i] );

for(Size i = 0; i < cStrikes_.size(); i++) {
    Rate k = cStrikes[i];
    if (k > maxFstrike + eps) cfStrikes_.push_back(k);
}

for (Size i = 1; i < cfStrikes_.size(); i++)
    QL_REQUIRE( cfStrikes_[i] > cfStrikes_[i-1],
                "cfStrikes not increasing");

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/experimental/mcbasket/mcpathbasketengine.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i = 0; i < numberOfTimes; ++i) {
    const Size pos = timePositions_[i];
    for (Size j = 0; j < numberOfAssets; ++j)
        path[j][i] = multiPath[j][pos];
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/experimental/mcbasket/longstaffschwartzmultipathpricer.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i = 0; i < numberOfTimes; ++i) {
    const Size pos = timePositions_[i];
    for (Size j = 0; j < numberOfAssets; ++j)
        path[j][i] = multiPath[j][pos];
}

for (Integer i = len - 2; i >= 0; --i) {
    price *= dF_[i + 1] / dF_[i];

    const Real exercise = path.exercises[i];

    /*
      coeff_[i].size()
      - 0 => never exercise
      - v_.size() => use estimated continuation value 
        (if > lowerBounds_[i])
      - v_.size() + 1 => always exercise

      In any case if states is empty, no exercise is allowed.
     */
    const Array & states = path.states[i];
    const bool canExercise = !states.empty();

    if (canExercise) {
        if (coeff_[i].size() == v_.size() + 1) {   
            // special value always exercise
            price = exercise;
        }
        else {
            if (!coeff_[i].empty() && exercise > lowerBounds_[i]) {
                
                Real continuationValue = 0.0;
                for (Size l = 0; l < v_.size(); ++l) {
                    continuationValue += coeff_[i][l] * v_[l](states);
                }
                
                if (continuationValue < exercise) {
                    price = exercise;
                }
            }
        }
    }
    const Real payoff = path.payments[i];
    price += payoff;
}

for (Size j = 0; j < n; ++j) {
    const Real payoff = paths_[j].payments[len - 1];
    const Real exercise = paths_[j].exercises[len - 1];
    const Array & states = paths_[j].states[len - 1];
    const bool canExercise = !states.empty();

    // at the end the continuation value is 0.0
    if (canExercise && exercise > 0.0)
        prices[j] += exercise;
    prices[j] += payoff;
}

for (Integer i = len - 2; i >= 0; --i) {
    std::vector<Real>  y;
    std::vector<Array> x;

    // prices are discounted up to time i
    const Real discountRatio = dF_[i + 1] / dF_[i];
    prices *= discountRatio;
    lowerBounds_[i + 1] *= discountRatio;

    //roll back step
    for (Size j = 0; j < n; ++j) {
        exercise[j] = paths_[j].exercises[i];

        // If states is empty, no exercise in this path
        // and the path will not partecipate to the Lesat Square regression

        const Array & states = paths_[j].states[i];
        QL_REQUIRE(states.empty() || states.size() == basisDimension, 
                   "Invalid size of basis system");

        // only paths that could potentially create exercise opportunities
        // partecipate to the regression

        // if exercise is lower than minimum continuation value, no point in considering it
        if (!states.empty() && exercise[j] > lowerBounds_[i + 1]) {
            x.push_back(states);
            y.push_back(prices[j]);
        }
    }

    if (v_.size() <=  x.size()) {
        coeff_[i] = GeneralLinearLeastSquares(x, y, v_).coefficients();
    }
    else {
    // if number of itm paths is smaller then the number of
    // calibration functions -> never exercise
        QL_TRACE("Not enough itm paths: default decision is NEVER");
        coeff_[i] = Array(0);
    }

    /* attempt to avoid static arbitrage given by always or never exercising.

       always is absolute: regardless of the lowerBoundContinuationValue_ (this could be changed)
       but it still honours "canExercise"
     */
    Real sumOptimized = 0.0;
    Real sumNoExercise = 0.0;
    Real sumAlwaysExercise = 0.0; // always, if allowed

    for (Size j = 0, k = 0; j < n; ++j) {
        sumNoExercise += prices[j];
        lsExercise[j] = false;

        const bool canExercise = !paths_[j].states[i].empty();
        if (canExercise) {
            sumAlwaysExercise += exercise[j];
            if (!coeff_[i].empty() && exercise[j] > lowerBounds_[i + 1]) {
                Real continuationValue = 0.0;
                for (Size l = 0; l < v_.size(); ++l) {
                    continuationValue += coeff_[i][l] * v_[l](x[k]);
                }
                
                if (continuationValue < exercise[j]) {
                    lsExercise[j] = true;
                }
                ++k;
            }
        }
        else {
            sumAlwaysExercise += prices[j];
        }

        sumOptimized += lsExercise[j] ? exercise[j] : prices[j];
    }

    sumOptimized /= n;
    sumNoExercise /= n;
    sumAlwaysExercise /= n;

    QL_TRACE(   "Time index: " << i 
             << ", LowerBound: " << lowerBounds_[i + 1] 
             << ", Optimum: " << sumOptimized 
             << ", Continuation: " << sumNoExercise 
             << ", Termination: " << sumAlwaysExercise);

    if (  sumOptimized >= sumNoExercise 
        && sumOptimized >= sumAlwaysExercise) {
        
        QL_TRACE("Accepted LS decision");
        for (Size j = 0; j < n; ++j) {
            // lsExercise already contains "canExercise"
            prices[j] = lsExercise[j] ? exercise[j] : prices[j];
        }
    }
    else if (sumAlwaysExercise > sumNoExercise) {
        QL_TRACE("Overridden bad LS decision: ALWAYS");
        for (Size j = 0; j < n; ++j) {
            const bool canExercise = !paths_[j].states[i].empty();
            prices[j] = canExercise ? exercise[j] : prices[j];
        }
        // special value to indicate always exercise
        coeff_[i] = Array(v_.size() + 1); 
    }
    else {
        QL_TRACE("Overridden bad LS decision: NEVER");
        // prices already contain the continuation value
        // special value to indicate never exercise
        coeff_[i] = Array(0); 
    }

    // then we add in any case the payment at time t
    // which is made even if cancellation happens at t
    for (Size j = 0; j < n; ++j) {
        const Real payoff = paths_[j].payments[i];
        prices[j] += payoff;
    }

    lowerBounds_[i] = *std::min_element(prices.begin(), prices.end());
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/experimental/credit/randomdefaultmodel.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size j = 0; j < pool_->size(); j++) {
    const string name = pool_->names()[j];
    const Handle<DefaultProbabilityTermStructure>&
        dts = pool_->get(name).defaultProbability(defaultKeys_[j]);

    Real y = a * values[0] + sqrt(1-a*a) * values[j+1];
    Real p = CumulativeNormalDistribution()(y);

    if (dts->defaultProbability(tmax) < p)
        pool_->setTime(name, tmax+1);
    else
        pool_->setTime(name, Brent().solve(Root(dts,p),accuracy_,0,1));
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/experimental/credit/integralntdengine.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i = 0; i < arguments_.premiumLeg.size(); i++) {
    boost::shared_ptr<FixedRateCoupon> coupon =
        boost::dynamic_pointer_cast<FixedRateCoupon>(
            arguments_.premiumLeg[i]);
    Date d = arguments_.premiumLeg[i]->date();
    if (d > discountCurve_->referenceDate()) {
        /*
        std::vector<Probability> probsTriggering =
            arguments_.basket->probsBeingNthEvent(arguments_.ntdOrder, 
                d);
        Probability defaultProb = 
            std::accumulate(probsTriggering.begin(), 
            probsTriggering.end(), Real(0.));
        // OVERKILL???? 1-probAtleastNevents is enough

*/
        // prob of contract not having been triggered by date of payment
        Probability probNonTriggered = 
            1. - arguments_.basket->probAtLeastNEvents(
                arguments_.ntdOrder, d);

        results_.premiumValue += arguments_.premiumLeg[i]->amount()
            * discountCurve_->discount(d)
            * probNonTriggered;
         ////   * (1.0 - defaultProb);

        if (coupon->accrualStartDate() >= 
            discountCurve_->referenceDate())
            d = coupon->accrualStartDate();
        else
            d = discountCurve_->referenceDate();

        // do steps of specified size
        d0 = d;
        Period stepSize = integrationStepSize_;
/*
        probsTriggering =
            arguments_.basket->probsBeingNthEvent(arguments_.ntdOrder, 
            ///////REDUNDANT?
                d0);
        Probability defProb0 = std::accumulate(probsTriggering.begin(), 
        ///OVERKILL????
            probsTriggering.end(), Real(0.));
*/
        Probability defProb0 = arguments_.basket->probAtLeastNEvents(
                arguments_.ntdOrder, d0);
        std::vector<Probability> probsTriggering, probsTriggering1;
        do {
            DiscountFactor disc = discountCurve_->discount(d);

            Probability defProb1;
            if(basketIsHomogeneous) {//take test out of the while loop
                defProb1 = arguments_.basket->probAtLeastNEvents(
                    arguments_.ntdOrder, d);
                claimValue -= (defProb1-defProb0)
                    * arguments_.basket->claim()->amount(d, 
                        arguments_.notional, 
                        arguments_.basket->recoveryRate(d, 0))
                    * disc;

            }else{
                probsTriggering1 =
                    arguments_.basket->probsBeingNthEvent(
                        arguments_.ntdOrder, d);
                defProb1 = std::accumulate(probsTriggering1.begin(), 
                    probsTriggering1.end(), Real(0.));
                /*Recoveries might differ along names, depending on 
                which name is triggering the contract the loss will be 
                different  
                There is an issue here; MC engines can still be used 
                since the prob of triggering the contract can be 
                extracted from the simulation from the 
                probsBeingNthEvent statistic. Yet, when the RR is 
                stochastic the realized value of the RR is the expected 
                one subject/conditional to the contract being triggered;
                not simply the expected value. For this reason the MC 
                can not be used through the statistic but has to consume
                the simulations directly.
                */
                for(Size iName=0; 
                    iName<arguments_.basket->remainingSize(); 
                    iName++) 
                {
                    claimValue -= (probsTriggering1[iName]-
                        probsTriggering[iName])
                        * arguments_.basket->claim()->amount(d, 
                            arguments_.notional,// [iName]! 
                            arguments_.basket->recoveryRate(d, iName))
                        * disc;
                }
                probsTriggering = probsTriggering1;
            }

            Probability dcfdd = defProb1 - defProb0;
            defProb0 = defProb1;

            if (arguments_.settlePremiumAccrual)
                accrualValue += coupon->accruedAmount(d)*disc*dcfdd;

            d0 = d;
            d = d0 + stepSize;
            // reduce step size ?
            if (stepSize != 1*Days && d > coupon->accrualEndDate()) {
                stepSize = 1*Days;
                d = d0 + stepSize;
            }
        }
        while (d <= coupon->accrualEndDate());
    }
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/experimental/credit/syntheticcdo.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i = 0; i < basket->names().size(); i++) {
    /* This turns out to be a problem: depends on today but I am not 
    modifying the registrations, if we go back in time in the 
    calculations this would left me unregistered to some. Not impossible
    to de-register and register when updating but i am dropping it.

    if(!basket->pool()->get(basket->names()[i]).
        defaultedBetween(schedule.dates()[0], today,
                             basket->pool()->defaultKeys()[i]))
    */
    // registers with the associated curve (issuer and event type)
    // \todo make it possible to access them by name instead of index
    registerWith(basket->pool()->get(basket->names()[i]).
        defaultProbability(basket->pool()->defaultKeys()[i]));
    /* \todo Issuers should be observables/obsrvr and they would in turn
    regiter with the DTS; only we might get updates from curves we do
    not use.
    */
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/experimental/credit/onefactorcopula.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i = 0; i < p.size(); i++)
    p[i] = conditionalProbability (prob[i], m);

for (Size i = 0; i < y_.size(); i++) {
    if (y_[i] > y)
        return (   (y_[i] - y)   * cumulativeY_[i-1]
                   + (y - y_[i-1]) * cumulativeY_[i]   )
            / (y_[i] - y_[i-1]);
}

for (Size i = 0; i < cumulativeY_.size(); i++) {
    if (cumulativeY_[i] > x)
        return (   (cumulativeY_[i] - x)   * y_[i-1]
                   + (x - cumulativeY_[i-1]) * y_[i]   )
            / (cumulativeY_[i] - cumulativeY_[i-1]);
}

for (Size i = 0; i < steps(); i++) {
    norm += densitydm (i);
    mean += m(i) * densitydm (i);
    var += pow (m(i), 2) * densitydm (i);
}

for (Size i = 1; i < zSteps; i++) {
    Real z1 = zMin + (zMax - zMin) / zSteps * (i - 1);
    Real z2 = zMin + (zMax - zMin) / zSteps * i;
    Real z  = (z1 + z2) / 2;
    Real densitydz = cumulativeZ (z2) - cumulativeZ (z1);
    norm += densitydz;
    mean += z * densitydz;
    var += pow (z, 2) * densitydz;
}

for (Size i = 1; i < ySteps; i++) {
    Real y1 = yMin + (yMax - yMin) / ySteps * (i - 1);
    Real y2 = yMin + (yMax - yMin) / ySteps * i;
    Real y  = (y1 + y2) / 2;
    Real densitydy = cumulativeY (y2) - cumulativeY (y1);
    norm += densitydy;
    mean += y * densitydy;
    var += y * y * densitydy;
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/experimental/credit/defaultevent.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for(Size i=0; i<contractKey.size(); i++) {
    if(this->matchesEventType(contractKey.eventTypes()[i])) return true;
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/experimental/credit/onefactorgaussiancopula.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    for (Real m = minimum; m < maximum; m += delta)
        for (Real z = minimum; z < (y - std::sqrt(c) * m) / std::sqrt (1. - c);

    for (Real z = minimum; z < maximum; z += delta)
        for (Real m = minimum; m < (y - std::sqrt(1.0 - c) * z) / std::sqrt(c);

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/experimental/credit/riskyassetswap.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i = 1; i < floatSchedule_.size(); i++) {
    Time dcf = floatDayCounter_.yearFraction (floatSchedule_[i-1],
                                              floatSchedule_[i]);
    annuity += dcf * yieldTS_->discount (floatSchedule_[i]);
}

for (Size i = 1; i < floatSchedule_.size(); i++) {
    Time dcf = fixedDayCounter_.yearFraction (floatSchedule_[i-1],
                                              floatSchedule_[i]);
    annuity += dcf * yieldTS_->discount (floatSchedule_[i]);
}

for (Size i = 1; i < fixedSchedule_.size(); i++) {
    TimeUnit stepSize = Days;
    Date d;
    if (fixedSchedule_[i-1] >= defaultTS_->referenceDate())
        d = fixedSchedule_[i-1];
    else
        d = defaultTS_->referenceDate();
    Date d0 = d;
    do {
        Real disc = yieldTS_->discount (d);
        Real dd   = defaultTS_->defaultDensity (d, true);
        Real dcf  = defaultTS_->dayCounter().yearFraction (d0, d);

        recoveryValue  += disc * dd * dcf;

        d0 = d;

        d = NullCalendar().advance (d0, 1, stepSize, Unadjusted);
    }
    while (d < fixedSchedule_[i]);
}

for (Size i = 1; i < fixedSchedule_.size(); i++) {
    Time dcf = fixedDayCounter_.yearFraction (fixedSchedule_[i-1],
                                              fixedSchedule_[i]);
    value += dcf * yieldTS_->discount (fixedSchedule_[i])
        * defaultTS_->survivalProbability (fixedSchedule_[i], true);
}

for (Size i = 1; i < fixedSchedule_.size(); i++) {
    Time dcf = fixedDayCounter_.yearFraction (fixedSchedule_[i-1],
                                              fixedSchedule_[i]);
    value += dcf * yieldTS_->discount (fixedSchedule_[i])
        * defaultTS_->defaultProbability (fixedSchedule_[i], true);
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/experimental/credit/basket.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i = 0; i < notionals_.size(); i++) {
    basketNotional_ += notionals_[i];
    attachmentAmount_ += notionals_[i] * attachmentRatio_;
    detachmentAmount_ += notionals_[i] * detachmentRatio_;
}

for (Size j = 0; j < size(); j++)
    prob[j] = pool_->get(pool_->names()[j]).defaultProbability(
        defKeys[j])->defaultProbability(d);

for (Size i = 0; i < size(); i++) {
    boost::shared_ptr<DefaultEvent> credEvent =
        pool_->get(pool_->names()[i]).defaultedBetween(refDate_,
            endDate, pool_->defaultKeys()[i]);
    if (credEvent) {
        /* \todo If the event has not settled one would need to 
        introduce some model recovery rate (independently of a loss 
        model) This remains to be done.
        */  
        if(credEvent->hasSettled())
            loss += claim_->amount(credEvent->date(),
                    // notionals_[i],
                    exposure(pool_->names()[i], credEvent->date()),
                    credEvent->settlement().recoveryRate(
                        pool_->defaultKeys()[i].seniority()));
    }
}

for (Size i = 0; i < size(); i++) {
    boost::shared_ptr<DefaultEvent> credEvent =
        pool_->get(pool_->names()[i]).defaultedBetween(refDate_,
            endDate, pool_->defaultKeys()[i]);
    if (credEvent) {
        if(credEvent->hasSettled()) {
            loss += claim_->amount(credEvent->date(),
                    //notionals_[i],
                    exposure(pool_->names()[i], credEvent->date()),
                    //NOtice I am requesting an exposure in the past...
                    /* also the seniority does not belong to the 
                    counterparty anymore but to the position.....*/
                    credEvent->settlement().recoveryRate(
                        pool_->defaultKeys()[i].seniority()));
        }
    }
}

for (Size i = 0; i < size(); i++)
    if (!pool_->get(pool_->names()[i]).defaultedBetween(
            refDate_,
            endDate,
            pool_->defaultKeys()[i]))
        calcBufferLiveList.push_back(i);

for (Size i = 0; i < size(); i++) {
    if (!pool_->get(pool_->names()[i]).defaultedBetween(refDate_,
                                                endDate,
                                                defKeys[i]))
        notional += notionals_[i];
}

for(Size i=0; i<alive.size(); i++)
    calcBufferNotionals.push_back(
        exposure(pool_->names()[i], endDate)
        );// some better way to trim it? 
return calcBufferNotionals;

for(Size i=0; i<alive.size(); i++)
    prob.push_back(pool_->get(pool_->names()[i]).defaultProbability(
        pool_->defaultKeys()[i])->defaultProbability(d, true));

for(Size i=0; i<alive.size(); i++)
    calcBufferNames.push_back(pool_->names()[alive[i]]);

for(Size i=0; i<alive.size(); i++)
    defKeys.push_back(pool_->defaultKeys()[alive[i]]);

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/experimental/credit/lossdistribution.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i = n; i <= p.size(); i++)
    defp += binomialProbabilityOfNEvents (i, p);

for (Size j = 0; j < n; j++) {
    prev = probability;
    probability[0] = prev[0] * (1.0 - p[j]);
    for (Size i = 1; i <= j; i++)
        probability[i] = prev[i-1] * p[j] + prev[i] * (1.0 - p[j]);
    probability[j+1] = prev[j] * p[j];
}

for (int j = 0; j < k; j++)
    sum -= probability[j];

for (Size i = k; i <= p.size(); i++)
    sum += probabilityOfNEvents (i, p);

for (Size i = 0; i <= n; i++) {
    if (volume_ * i <= maximum_) {
        probability_[i] = binomial(i);
        Size bucket = dist.locate(volume * i);
        dist.addDensity (bucket, probability_[i] / dist.dx(bucket));
        dist.addAverage (bucket, volume * i);
    }
}

for (int k = n_-1; k >= 0; k--)
    excessProbability_[k] = excessProbability_[k+1] + probability_[k];

for (Size k = 0; k < n_; k++) {
    prev = probability_;
    probability_[0] = prev[0] * (1.0 - p[k]);
    for (Size i = 1; i <= k; i++)
        probability_[i] = prev[i-1] * p[k] + prev[i] * (1.0 - p[k]);
    probability_[k+1] = prev[k] * p[k];
}

for (int k = n_ - 1; k >= 0; k--)
    excessProbability_[k] = excessProbability_[k+1] + probability_[k];

for (Size i = 0; i <= n_; i++) {
    if (volume * i <= maximum_) {
        Size bucket = dist.locate(volume * i);
        dist.addDensity (bucket, probability_[i] / dist.dx(bucket));
        dist.addAverage (bucket, volume*i);
    }
}

for (Size k = 1; k < nBuckets_; k++)
    a[k] = dx * k + dx/2;

for (Size i = 0; i < nominals.size(); i++) {
    Real L = nominals[i];
    Real P = probabilities[i];
    for (int k = a.size()-1; k >= 0; k--) {
        if (p[k] > 0) {
            int u = locateTargetBucket (a[k] + L, k);
            QL_REQUIRE (u >= 0, "u=" << u << " at i=" << i << " k=" << k);
            QL_REQUIRE (u >= k, "u=" << u << "<k=" << k << " at i=" << i);

            Real dp = p[k] * P;
            if (u == k)
                a[k] += P * L;
            else {
                // no update of a[u] and p[u] if u is beyond grid end
                if (u < int(nBuckets_)) {
                    // a[u] remains unchanged, if dp = 0
                    if (dp > 0.0) {
                        // on Windows, p[u]/dp could cause a NaN for
                        // some very small values of p[k].
                        // Writing the above as (p[u]/p[k])/P prevents
                        // the NaN. What can I say?
                        Real f = 1.0 / (1.0 + (p[u]/p[k]) / P);
                        a[u] = (1.0 - f) * a[u] + f * (a[k] + L);
                    }
                    /* formulation of Hull-White:
                       if (p[u] + dp > 0)
                          a[u] = (p[u] * a[u] + dp * (a[k] + L))
                                 / (p[u] + dp);
                    */
                    p[u] += dp;
                }
                p[k] -= dp;
            }
        }
        QL_REQUIRE(a[k] + epsilon_ >= dx * k && a[k] < dx * (k+1),
                   "a out of range at k=" << k << ", contract " << i);
    }
}

for (Size i = 0; i < nBuckets_; i++) {
    dist.addDensity (i, p[i] / dx);
    dist.addAverage (i, a[i]);
}

for (Size i = i0; i < nBuckets_; i++)
    if (dx * i > loss + epsilon_) return i - 1;

for (Size i = 0; i < simulations_; i++) {
    Real e = 0;
    for (Size j = 0; j < nominals.size(); j++) {
        Real r = rng.next().value;
        if (r <= probabilities[j])
            e += nominals[j];
    }
    dist.add (e + epsilon_);
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/experimental/credit/cdo.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i = 0; i < basket_.size(); i++)
    registerWith (basket_[i]);

    for (Size i = 0; i < n; i++)
        nominals_.push_back(back);

for (Size i = 0; i < nominals_.size(); i++) {
    lgds_.push_back (nominals_[i] * (1.0 - recoveryRate_));
    nominal_ += nominals_[i];
    lgd_ += lgds_[i];
}

for (Size j = 0; j < basket_.size(); j++)
    defProb[j] = basket_[j]->defaultProbability (d);

for (Size i = 1; i < premiumSchedule_.size(); i++) {
    Date d2 = premiumSchedule_[i];
    if (d2 < today)
        continue;

    Date d1 = premiumSchedule_[i-1];

    Date d, d0 = d1;
    do {
        d = NullCalendar().advance (d0 > today ? d0 : today,
                                    integrationStep_);
        if (d > d2)
            d = d2;

        Real e2 = expectedTrancheLoss (d);

        premiumValue_ += (xMax_ - xMin_ - e2)
            * premiumRate_ * dayCounter_.yearFraction (d0, d)
            * yieldTS_->discount (d);

        if (e2 < e1) {
            error_ ++;
        }

        protectionValue_ -= (e2 - e1) * yieldTS_->discount (d);

        d0 = d;
        e1 = e2;
    }
    while (d < d2);
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/experimental/credit/riskybond.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i = 0; i < cf.size(); i++) {
    Date d2 = cf[i]->date();
    if (d2 > today) {
        d1 = max(today , d1);
        Date defaultDate = d1 + (d2-d1)/2;

        Real coupon = cf[i]->amount()
            * defaultTS_->survivalProbability(d2);
        Real recovery = notional(defaultDate) * recoveryRate_
            * (defaultTS_->survivalProbability(d1)
               -defaultTS_->survivalProbability(d2));
        NPV_ += coupon * yieldTS()->discount(d2);
        NPV_ += recovery * yieldTS()->discount(defaultDate);
    }
    d1 = d2;
}

for (Size i = 0; i < cf.size(); i++) {
    Date d2 = cf[i]->date();
    if (d2 > today)
        npv += cf[i]->amount() * yieldTS()->discount(d2);
}

for (Size i = 0; i < cf.size(); i++) {
    if (cf[i]->date() > today)
        flow += cf[i]->amount();
}

for (Size i = 0; i < cf.size(); i++) {
    Date d2 = cf[i]->date();
    if (d2 > today) {
        d1 = max(today , d1);
        Date defaultDate = d1 + (d2-d1)/2;

        Real coupon = cf[i]->amount()
            * defaultTS_->survivalProbability(d2);
        Real recovery = notional(defaultDate) * recoveryRate_
            * (defaultTS_->survivalProbability(d1)
               -defaultTS_->survivalProbability(d2));
        boost::shared_ptr<CashFlow>
            flow1(new SimpleCashFlow(coupon, d2));
        expected.push_back(flow1);

        boost::shared_ptr<CashFlow>
            flow2(new SimpleCashFlow(recovery, defaultDate));
        expected.push_back(flow2);
    }
    d1 = d2;
}

for (Size i = 1; i < dates.size(); i++) {
    Real currentNotional = (i < notionals_.size() ?
                     notionals_[i] :
                     notionals_.back());
    boost::shared_ptr<CashFlow> interest (new
           FixedRateCoupon(dates[i], previousNotional,
                           rate_, dayCounter_, dates[i-1], dates[i]));
    boost::shared_ptr<CashFlow> amortization(new
         AmortizingPayment(previousNotional - currentNotional, dates[i]));
    previousNotional = currentNotional;

    leg_.push_back(interest);
    interestLeg_.push_back(interest);
    if (amortization->amount() != 0){
        leg_.push_back(amortization);
        redemptionLeg_.push_back(amortization);
    }
}

for (Size i = 0; i < schedule_.size(); i++) {
    if (i < notionals_.size() && schedule_[i] <= date)
        ntl = notionals_[i];
    else
        break;
}

for (Size i = 1; i < dates.size(); i++) {
    Real currentNotional = (i < notionals_.size() ?
                     notionals_[i] :
                     notionals_.back());
    boost::shared_ptr<CashFlow> interest (new
           IborCoupon(dates[i], previousNotional, dates[i-1], dates[i],
                      fixingDays_, index_, 1.0, spread_));
    boost::shared_ptr<CashFlow> amortization(new
         AmortizingPayment(previousNotional - currentNotional, dates[i]));
    previousNotional = currentNotional;

    leg_.push_back(interest);
    interestLeg_.push_back(interest);
    if (amortization->amount() != 0){
        leg_.push_back(amortization);
        redemptionLeg_.push_back(amortization);
    }
}

for (Size i = 0; i < schedule_.size(); i++) {
    if (i < notionals_.size() && schedule_[i] <= date)
        ntl = notionals_[i];
    else
        break;
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/experimental/credit/gaussianlhplossmodel.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    for(Size i=0; i<quotes.size(); i++)
        registerWith(quotes[i]);

    for(Size i=0; i<recoveries.size(); i++)
        rrQuotes_.push_back(Handle<RecoveryRateQuote>(
        boost::make_shared<RecoveryRateQuote>(recoveries[i])));

    for(Size i=0; i<recoveries.size(); i++)
        rrQuotes_.push_back(Handle<RecoveryRateQuote>(
        boost::make_shared<RecoveryRateQuote>(recoveries[i])));

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/experimental/credit/defaultprobabilitykey.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for(Size i=0; i<mySize; i++) {
    if(std::find_if(lhs.eventTypes().begin(), lhs.eventTypes().end(),
        *_1 == *rhs.eventTypes()[i]) == lhs.eventTypes().end())
        return false;
}// naah, I bet this can be done with a double lambda

for(Size i=0; i< numEvents; i++)
    buffer.insert(eventTypes_[i]->defaultType());

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/experimental/credit/issuer.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for(Size i=0; i <eventTypes.size(); i++) {
    DefaultProbKey keytmp(eventTypes[i], currencies[i],
        seniorities[i]);
    probabilities_.push_back(std::make_pair(keytmp, curves[i]));
}

for(Size i=0; i<probabilities_.size(); i++)
    if(key == probabilities_[i].first)
        return probabilities_[i].second;

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/experimental/credit/distribution.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (int i = 0; i < nBuckets; i++) {
    dx_[i] = (xmax - xmin) / nBuckets;
    x_[i] = (i == 0 ? xmin : x_[i-1] + dx_[i-1]);
}

for (Size i = 0; i < x_.size(); i++) {
    if (x_[i] > x)
        return i - 1;
}

    for (Size i = 0; i < count_.size(); i++) {
        if (x_[i] + dx_[i] > value) {
            count_[i]++;
            average_[i] += value;
            return;
        }
    }

for (int i = 0; i < size_; i++)
    count += count_[i];

for (int i = 0; i < size_; i++) {
    if (count > 0) {
        density_[i] = 1.0 / dx_[i] * count_[i] / count;
        if (count_[i] > 0)
            average_[i] /= count_[i];
    }
    if (density_[i] == 0.0)
        average_[i] = x_[i] + dx_[i]/2;

    cumulativeDensity_[i] = density_[i] * dx_[i];
    if (i > 0) {
        cumulativeDensity_[i] += cumulativeDensity_[i-1];
        excessProbability_[i] = 1.0 - cumulativeDensity_[i-1];
//                     excessProbability_[i] = excessProbability_[i-1]
//                         - density_[i-1] * dx_[i-1];
//                     cumulativeExcessProbability_[i]
//                         = (excessProbability_[i-1] +
//                            excessProbability_[i]) / 2 * dx_[i-1]
//                         + cumulativeExcessProbability_[i-1];
        cumulativeExcessProbability_[i]
            = excessProbability_[i-1] * dx_[i-1]
            + cumulativeExcessProbability_[i-1];
    }
}

for (int i = 0; i < size_; i++) {
    if (cumulativeDensity_[i] > quantil)
        return x_[i] + dx_[i];
}

for (int i = 0; i < size_; i++) {
    Real x = x_[i] + dx_[i]/2;
    expected += x * dx_[i] * density_[i];
}

for (int i = 0; i < size_; i++) {
    Real x = x_[i] + dx_[i]/2;
    if (x < a)
        continue;
    if (x > d)
        break;
    expected += (x - a) * dx_[i] * density_[i];
}

for (int i = 0; i < size_; i++) {
    if (x_[i] >= b) break;
    if (x_[i] >= a)
        integral += dx_[i] * excessProbability_[i];
}

for (int i = 0; i < size_; i++) {
    if (x_[i] + dx_[i] + tiny >= x)
        return ((x - x_[i]) * cumulativeDensity_[i]
             + (x_[i] + dx_[i] - x) * cumulativeDensity_[i-1]) / dx_[i];
}

for (Size i = 0; i < x_.size(); i++) {
    x_[i] = std::min(std::max(x_[i] - attachmentPoint, 0.), 
        detachmentPoint - attachmentPoint);
}

for(Integer i=1; i<size_-1; i++) {
    excessProbability_.push_back(1.-cumulativeDensity_[i-1]);
    density_.push_back((cumulativeDensity_[i]-
        cumulativeDensity_[i-1])/dx_[i]);
}

for (Size i = 1; i < d1.size(); i++)
    QL_REQUIRE (d1.dx_[i] == d1.dx_[i-1], "bucket size varies in d1");

for (Size i = 1; i < d2.size(); i++)
    QL_REQUIRE (d2.dx_[i] == d2.dx_[i-1], "bucket size varies in d2");

for (Size i1 = 0; i1 < d1.size(); i1++) {
    Real dx = d1.dx_[i1];
    for (Size i2 = 0; i2 < d2.size(); i2++)
        dist.density_[i1+i2] = d1.density_[i1] * d2.density_[i2] * dx;
}

for (Size i = 0; i < dist.size(); i++) {
    dist.cumulativeDensity_[i] = dist.density_[i] * dist.dx_[i];
    if (i > 0) {
        dist.cumulativeDensity_[i] += dist.cumulativeDensity_[i-1];
        dist.excessProbability_[i] = dist.excessProbability_[i-1]
            - dist.density_[i-1] * dist.dx_[i-1];
    }
}

for (int i = iVal; i < size_; i++)
    expected += x_[i] * 
        (cumulativeDensity_[i] - cumulativeDensity_[i-1]);

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/experimental/credit/midpointcdoengine.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i = 0; i < arguments_.normalizedLeg.size(); i++) {
    if(arguments_.normalizedLeg[i]->hasOccurred(today)) {
        results_.expectedTrancheLoss.push_back(0.);
        continue;
    }
    boost::shared_ptr<Coupon> coupon =
      boost::dynamic_pointer_cast<Coupon>(arguments_.normalizedLeg[i]);
    Date paymentDate = coupon->date();
    Date startDate = std::max(coupon->accrualStartDate(),
                              discountCurve_->referenceDate());
    Date endDate = coupon->accrualEndDate();
    // we assume the loss within the period took place on this date:
    Date defaultDate = startDate + (endDate-startDate)/2;

    Real e2 = arguments_.basket->expectedTrancheLoss(endDate);
    results_.expectedTrancheLoss.push_back(e2);
    results_.premiumValue += 
        ((inceptionTrancheNotional - e2) / inceptionTrancheNotional)
        * coupon->amount()
        * discountCurve_->discount(paymentDate);
    // default flows:
    const Real discount = discountCurve_->discount(defaultDate);

    /* Accrual removed till the argument flag is implemented
    // pays accrued on defaults' date
    results_.premiumValue += coupon->accruedAmount(defaultDate)
        * discount * (e2 - e1) / inceptionTrancheNotional;
    */
    results_.protectionValue += discount * (e2 - e1);
    /* use it in a future version for coherence with the integral engine
    * arguments_.leverageFactor;
    */
    e1 = e2;
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/experimental/credit/integralcdoengine.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i = 0; i < arguments_.normalizedLeg.size(); i++) {
    if(arguments_.normalizedLeg[i]->hasOccurred(today)) {
        // add includeSettlement date flows variable to engine.
        results_.expectedTrancheLoss.push_back(0.);
        continue;
    }

    const boost::shared_ptr<Coupon> coupon =
        boost::dynamic_pointer_cast<Coupon>(
            arguments_.normalizedLeg[i]);

    Date d1 = coupon->accrualStartDate();
    Date d2 = coupon->date();

    Date d, d0 = d1;
    Real e2;
    do {
        d = NullCalendar().advance(d0 > today ? d0 : today,
                                   stepSize_);
        if (d > d2) d = d2;

        e2 = arguments_.basket->expectedTrancheLoss(d);

        results_.premiumValue
            // ..check for e2 including past/realized losses
            += (inceptionTrancheNotional - e2)
            * arguments_.runningRate
            * arguments_.dayCounter.yearFraction(d0, d)
            * discountCurve_->discount(d);

        // TO DO: Addd default coupon accrual value here-----

        if (e2 < e1) results_.error ++;

        results_.protectionValue
            += (e2 - e1) * discountCurve_->discount(d);

        d0 = d;
        e1 = e2;
    }
    while (d < d2);
    results_.expectedTrancheLoss.push_back(e2);
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/experimental/credit/onefactorstudentcopula.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i = 0; i <= steps; i++) {
    Real y = ymin + (ymax - ymin) * i / steps;
    Real c = cumulativeYintegral (y);
    y_.push_back (y);
    cumulativeY_.push_back (c);
}

    for (Real m = minimum + delta/2; m < maximum; m += delta)
        for (Real z = minimum + delta/2;

    for (Real z = minimum + delta/2; z < maximum; z += delta)
        for (Real m = minimum + delta/2;

for (Size i = 0; i <= steps; i++) {
    Real y = ymin + (ymax - ymin) * i / steps;
    Real c = cumulativeYintegral (y);
    y_.push_back (y);
    cumulativeY_.push_back (c);
}

    for (Real m = minimum + delta/2; m < maximum; m += delta)
        for (Real z = minimum + delta/2;

    for (Real z = minimum + delta/2; z < maximum; z += delta)
        for (Real m = minimum + delta/2;

for (Size i = 0; i <= steps; i++) {
    Real y = ymin + (ymax - ymin) * i / steps;
    Real c = cumulativeYintegral (y);
    y_.push_back (y);
    cumulativeY_.push_back (c);
}

    for (Real m = minimum + delta/2; m < maximum; m += delta)
        for (Real z = minimum + delta/2;

    for (Real z = minimum + delta/2; z < maximum; z += delta)
        for (Real m = minimum + delta/2;

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/experimental/risk/sensitivityanalysis.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    for (Size k=0; k<n; ++k)
        npv += instruments[k]->NPV();

    for (Size k=0; k<n; ++k)
        npv += quant[k] * instruments[k]->NPV();

for (Size i=0; i<n; ++i)
    if (quotes[i]->isValid())
        quoteValues[i] = quotes[i]->value();

    for (Size i=0; i<n; ++i)
        if (quotes[i]->isValid())
            quotes[i]->setValue(quoteValues[i]+shift);

        for (Size i=0; i<n; ++i)
            if (quotes[i]->isValid())
                quotes[i]->setValue(quoteValues[i]-shift);

    for (Size i=0; i<n; ++i)
        if (quotes[i]->isValid())
            quotes[i]->setValue(quoteValues[i]);

    for (Size i=0; i<n; ++i)
        if (quoteValues[i]!=Null<Real>())
            quotes[i]->setValue(quoteValues[i]);

    for (Size j=0; j<m; ++j) {
        deltaVector[j]=Null<Real>();
        gammaVector[j]=Null<Real>();
    }

    for (Size j=0; j<m; ++j) {
        if (params[j]->isValid()) // fault tolerant
            refVals[j] = params[j]->value();
    }

            for (Size j=0; j<m; ++j) {
                gammaVector[j] = Null<Real>();
                if (refVals[j] != Null<Real>())
                    deltaVector[j] = (params[j]->value()-refVals[j])/shift;
                else
                    deltaVector[j] = Null<Real>();
            }

            for (Size j=0; j<m; ++j) {
                if (refVals[j] != Null<Real>())
                    plus[j] = params[j]->value();
            }

            for (Size j=0; j<m; ++j) {
                if (refVals[j] != Null<Real>()) {
                    Real minus = params[j]->value();
                    deltaVector[j] = (plus[j]-minus)/(2.0*shift);
                    gammaVector[j] = (plus[j]-2.0*refVals[j]+minus)/(shift*shift);
                } else {
                    deltaVector[j] = Null<Real>();
                    gammaVector[j] = Null<Real>();
                }
            }

for (Size i=0; i<n; ++i) {
    tmp = bucketAnalysis(quotes[i], instr, quant, shift, type, npv);
    result.first[i] = tmp.first;
    result.second[i] = tmp.second;
}

for (Size i=0; i<m; ++i) {
    if (parameters[i]->isValid())
        referenceValues[i] = parameters[i]->value();
}

for (Size i=0; i<n; ++i) {
    bucketAnalysis(deltaMatrix[i], gammaMatrix[i], referenceValues,
                   quotes[i], parameters, shift, type);
}

for (Size i=0; i<n; ++i) {
    Size tmp = quotes[i].size();
    first[i] = vector<Real>(tmp, 0.0);
    second[i] = vector<Real>(tmp, 0.0);
}

for (Size i=0; i<n; ++i) {
  for (Size j=0; j<quotes[i].size(); ++j) {
    tmp = bucketAnalysis(quotes[i][j], instr, quant, shift, type, npv);
    result.first[i][j] = tmp.first;
    result.second[i][j] = tmp.second;
  }
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/experimental/risk/creditriskplus.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i = 0; i < m_; ++i) {
    QL_REQUIRE(exposure_[i] >= 0.0, "exposure #"
                                        << i << " is negative ("
                                        << exposure_[i] << ")");
    QL_REQUIRE(pd_[i] > 0.0, "pd #" << i << " is negative (" << pd_[i]
                                    << ")");
    QL_REQUIRE(sector_[i] < n_, "sector #" << i << " (" << sector_[i]
                                           << ") is out of range 0..."
                                           << (n_ - 1));
    exposureSum_ += exposure_[i];
    el_ += pd_[i] * exposure_[i];
    el2_ += pd_[i] * exposure_[i]*exposure_[i];
}

for (Size k = 0; k < m_; ++k) {
    unsigned long exUnit = (unsigned long)(std::floor(0.5 + exposure_[k] / unit_)); // round
    if (exposure_[k] > 0 && exUnit == 0)
        exUnit = 1; // but avoid zero exposure
    if (exUnit > maxNu_)
        maxNu_ = exUnit;
    pdAdj[k] = exposure_[k] > 0.0
                   ? exposure_[k] * pd_[k] / (exUnit * unit_)
                   : 0.0; // adjusted pd
    Real el = exUnit * pdAdj[k];
    if (exUnit > 0) {
        iter = epsNuC_.find(exUnit);
        if (iter == epsNuC_.end()) {
            epsNuC_.insert(std::pair<unsigned long, Real>(exUnit, el));
        } else {
            (*iter).second += el;
        }
        upperIndex_ += exUnit;
    }
}

for (Size k = 0; k < m_; ++k) {
    pdSum_ += pdAdj[k];
    sectorPdSum_[sector_[k]] += pd_[k];
    sectorExposure_[sector_[k]] += exposure_[k];
    sectorEl_[sector_[k]] += exposure_[k] * pd_[k];
}

for (Size i = 0; i < n_; ++i) {

    // precompute sector specific terms (formula 15 in [1])

    sectorSpecTerms_[i] += relativeDefaultVariance_[i] * sectorEl_[i];
    for (Size j = 0; j < n_; ++j) {
        if (j != i) {
            sectorSpecTerms_[i] +=
                correlation_[i][j] *
                std::sqrt(relativeDefaultVariance_[i] *
                          relativeDefaultVariance_[j]) *
                sectorEl_[j];
        }
    }
}

for (Size i = 0; i < n_; ++i) {
    sectorUl_[i] =
        relativeDefaultVariance_[i] * sectorEl_[i] * sectorEl_[i];
    ul_ += sectorUl_[i];
    for (Size j = 0; j < n_; ++j) {
        if (j != i) {
            ul_ += correlation_[i][j] *
                   std::sqrt(relativeDefaultVariance_[i] *
                             relativeDefaultVariance_[j]) *
                   sectorEl_[i] * sectorEl_[j];
        }
    }
}

for (Size k = 0; k < m_; ++k) {
    Real tmp = pd_[k] * exposure_[k] * exposure_[k];
    sectorUl_[sector_[k]] += tmp;
    ul_ += tmp;
}

for (Size i = 0; i < n_; ++i)
    sectorUl_[i] = std::sqrt(sectorUl_[i]);

for (Size k = 0; k < m_; ++k) {
    marginalLoss_[k] = pd_[k] * exposure_[k] / ul_ *
                       (sectorSpecTerms_[sector_[k]] + exposure_[k]);
}

for (unsigned long n = 0; n < upperIndex_ - 1; ++n) { // compute A(n+1)
                                                      // recursively
    res = 0.0;
    for (unsigned long j = 0;
         j <= std::min<unsigned long>(maxNu_ - 1, n); ++j) {
        iter = epsNuC_.find(j + 1);
        if (iter != epsNuC_.end()) {
            res += (*iter).second * loss_[n - j] * alphaC_;
            if (j <= n - 1)
                res += (*iter).second / ((Real)(j + 1)) *
                       ((Real)(n - j)) * loss_[n - j];
        }
    }
    loss_.push_back(res * pC_ / (pdSum_ * ((Real)(n + 1))));
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/experimental/volatility/extendedblackvariancesurface.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size j=1; j<=dates.size(); j++) {
    times_[j] = timeFromReference(dates[j-1]);
    QL_REQUIRE(times_[j]>times_[j-1],
               "dates must be sorted unique");
}

for (Size j = 0; j < volatilities_.size(); j++)
    registerWith(volatilities_[j]);

for (Size i=0; i<times_.size()+1; i++) {
    variances_[0][i] = 0.0;
}

for (Size j=1; j<=times_.size(); j++) {
    for (Size i=0; i<strikes_.size(); i++) {
        Volatility sigma = volatilities_[i*times_.size()+j-1]->value();
        variances_[i][j] = times_[j] * sigma * sigma;
        QL_REQUIRE(variances_[i][j]>=variances_[i][j-1],
                   "variance must be non-decreasing");
    }
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/experimental/volatility/sviinterpolatedsmilesection.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i = 0; i < volHandles_.size(); ++i)
LazyObject::registerWith(volHandles_[i]);

for (Size i = 0; i < volHandles_.size(); ++i)
volHandles_[i] = Handle<Quote>(
    boost::shared_ptr<Quote>(new SimpleQuote(volHandles[i])));

for (Size i = 0; i < volHandles_.size(); ++i) {
if (volHandles_[i]->isValid()) {
    if (hasFloatingStrikes_) {
        actualStrikes_.push_back(forwardValue_ + strikes_[i]);
        vols_.push_back(atmVolatility_->value() +
                        volHandles_[i]->value());
    } else {
        actualStrikes_.push_back(strikes_[i]);
        vols_.push_back(volHandles_[i]->value());
    }
}
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/experimental/volatility/noarbsabr.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (int iTau = -1; iTau <= 0; ++iTau) {
for (int iSigma = -1; iSigma <= 0; ++iSigma) {
    for (int iRho = -1; iRho <= 0; ++iRho) {
        for (int iNu = -1; iNu <= 0; ++iNu) {
            for (int iBeta = -1; iBeta <= 0; ++iBeta) {
                Real phiTmp;
                if (iNu == -1 && nuInd == 0) {
                    phiTmp =
                        0.5 /
                        (sigmaI_ * sigmaI_ * (1.0 - beta_) *
                         (1.0 - beta_)); // this is 0.5*z_F^2, see above
                } else {
                    if (iBeta == 0 && betaInd == betaG_.size()) {
                        phiTmp =
                            phi(detail::NoArbSabrModel::tiny_prob);
                    } else {
                        int ind = (tauInd + iTau +
                                   (sigmaIInd + iSigma +
                                    (rhoInd + iRho +
                                     (nuInd + iNu + ((betaInd + iBeta) *
                                                     nuG_.size())) *
                                         rhoG_.size()) *
                                        sigmaIG_.size()) *
                                       tauG_.size());
                        QL_REQUIRE(ind >= 0 && ind < 1209600,
                                   "absorption matrix index ("
                                       << ind << ") invalid");
                        phiTmp = phi((Real)sabrabsprob[ind] /
                                     detail::NoArbSabrModel::nsim);
                    }
                }
                phiRes += phiTmp * (iTau == -1 ? (1.0 - tauL) : tauL) *
                          (iSigma == -1 ? (1.0 - sigmaIL) : sigmaIL) *
                          (iRho == -1 ? (1.0 - rhoL) : rhoL) *
                          (iNu == -1 ? (1.0 - nuL) : nuL) *
                          (iBeta == -1 ? (1.0 - betaL) : betaL);
            }
        }
    }
}
}

for (Size i = 0; i < 1209600; ++i)
boost::hash_combine(seed, detail::sabrabsprob[i]);

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/experimental/volatility/abcdatmvolcurve.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i<vols_.size(); ++i)
    vols_[i] = volHandles_[i]->value();

for (Size i=1; i<nOptionTenors_; ++i)
    QL_REQUIRE(optionTenors_[i]>optionTenors_[i-1],
               "non increasing option tenor: " << io::ordinal(i) <<
               " is " << optionTenors_[i-1] << ", " <<
               io::ordinal(i+1) << " is " << optionTenors_[i]);

    for(Size j=1; j<nOptionTenors_;++j)
        inclusionInInterpolation_[j] = inclusionInInterpolation_[0];

for (Size i=0; i<volHandles_.size(); ++i)
    registerWith(volHandles_[i]);

for (Size i=0; i<nOptionTenors_; ++i) {
    optionDates_[i] = optionDateFromTenor(optionTenors_[i]);
    optionTimes_[i] = timeFromReference(optionDates_[i]);
}

for (Size i=0; i<nOptionTenors_; ++i) {
    if(inclusionInInterpolation_[i]==true) {
       actualOptionTimes_.push_back(optionTimes_[i]);
       actualOptionTenors_.push_back(optionTenors_[i]);
    }
}

for (Size i=0; i<nOptionTenors_; ++i) {
    vols_[i] = volHandles_[i]->value();
    if(inclusionInInterpolation_[i]==true)
       actualVols_.push_back(vols_[i]);
}

for (Size i=0; i<vols_.size(); ++i) {
    vols_[i] = volHandles_[i]->value();
    if(inclusionInInterpolation_[i]==true)
       actualVols_.push_back(vols_[i]);
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/experimental/volatility/zabr.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size j = 0; j < v_.size(); ++j)
std::copy(rhs.begin() + j * f_.size(),
          rhs.begin() + (j + 1) * f_.size(), result.row_begin(j));

for (Size m = 0; m < y.size(); m++) {
    Real J = std::sqrt(1.0 + nu_ * nu_ * y[m] * y[m] -
                       2.0 * rho_ * nu_ * y[m]);
    result[y.size() - 1 - m] =
        std::log((J + nu_ * y[m] - rho_) / (1.0 - rho_)) / nu_;
}

for (int dir = 1; dir >= -1; dir -= 2) {
    Real y0 = 0.0, u0 = 0.0;
    for (int m = ynz + (dir == -1 ? -1 : 0);
         dir == -1 ? m >= 0 : m < (int)y.size(); m += dir) {
        Real u = rk(boost::bind(&ZabrModel::F, this, _1, _2),
                    u0, y0, y[m]);
        result[y.size() - 1 - m] = u * pow(alpha_, 1.0 - gamma_);
        u0 = u;
        y0 = y[m];
    }
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/experimental/volatility/noarbsabrinterpolatedsmilesection.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    for (Size i=0; i<volHandles_.size(); ++i)
        LazyObject::registerWith(volHandles_[i]);

    for (Size i=0; i<volHandles_.size(); ++i)
        volHandles_[i] = Handle<Quote>(boost::shared_ptr<Quote>(new
                                SimpleQuote(volHandles[i])));

for (Size i=0; i<volHandles_.size(); ++i) {
    if (volHandles_[i]->isValid()) {
        if (hasFloatingStrikes_) {
            actualStrikes_.push_back(forwardValue_ + strikes_[i]);
            vols_.push_back(atmVolatility_->value() + volHandles_[i]->value());
        } else {
            actualStrikes_.push_back(strikes_[i]);
            vols_.push_back(volHandles_[i]->value());
        }
    }
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/experimental/volatility/volcube.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i<surfaces_.size(); ++i) {
    QL_REQUIRE(surfaces_[i]->referenceDate() == refDate,
               "different reference dates");
    //curves_.push_back(surfaces_[i]);
}

for (Size i=0; i<curves_.size(); ++i) {
    QL_REQUIRE(curves_[i]->referenceDate() == refDate,
               "different reference dates");
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/experimental/volatility/extendedblackvariancecurve.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size j=1; j<=dates.size(); ++j) {
    times_[j] = timeFromReference(dates[j-1]);
    QL_REQUIRE(times_[j]>times_[j-1],
               "dates must be sorted unique!");
}

for (Size j=0; j<volatilities_.size(); ++j)
    registerWith(volatilities_[j]);

for (Size j=1; j<=volatilities_.size(); j++) {
    Volatility sigma = volatilities_[j-1]->value();
    variances_[j] = times_[j] * sigma * sigma;
    QL_REQUIRE(variances_[j]>=variances_[j-1]
               || !forceMonotoneVariance_,
               "variance must be non-decreasing");
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/experimental/volatility/sabrvolsurface.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i<optionTenors_.size(); ++i) {

    optionDates_[i] = optionDateFromTenor(optionTenors_[i]);
    optionTimes_[i] = timeFromReference(optionDates_[i]);

    // Hard coded
    sabrGuesses_[i][0] = 0.025; // alpha
    sabrGuesses_[i][1] = 0.5;   // beta
    sabrGuesses_[i][2] = 0.3;   // rho
    sabrGuesses_[i][3] = 0.0;   // nu
}

for (Size i=0; i<nAtmRateSpreads; ++i) {
    for (Size j=0; j<nOptionsTimes; ++j) {
        vols[j] = (**volSpreads_[j][i]).value();
    }
    LinearInterpolation interpolator(optionTimes_.begin(), optionTimes_.end(),
                                     vols.begin());
    interpolatedVols[i] = interpolator(timeFromReference(d),true);
}

for (Size i=0; i<optionTenors_.size(); ++i) {
    optionDates_[i] = optionDateFromTenor(optionTenors_[i]);
    optionTimes_[i] = timeFromReference(optionDates_[i]);
}

for (Size i=0; i<optionTenors_.size(); ++i) {
    for (Size j=0; j<atmRateSpreads_.size(); ++j) {
        registerWith(volSpreads_[i][j]);
    }
}

for (Size i=1; i<nStrikes; ++i)
    QL_REQUIRE(atmRateSpreads_[i-1]<atmRateSpreads_[i],
               "non increasing strike spreads: " <<
               io::ordinal(i) << " is " << atmRateSpreads_[i-1] << ", " <<
               io::ordinal(i+1) << " is " << atmRateSpreads_[i]);

for (Size i=0; i<volSpreads_.size(); i++)
    QL_REQUIRE(atmRateSpreads_.size()==volSpreads_[i].size(),
               "mismatch between number of strikes (" << atmRateSpreads_.size() <<
               ") and number of columns (" << volSpreads_[i].size() <<
               ") in the " << io::ordinal(i+1) << " row");

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/model.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    for (Size i=0; i<instruments_.size(); i++) {
        Real diff = instruments_[i]->calibrationError();
        value += diff*diff*weights_[i];
    }

    for (Size i=0; i<instruments_.size(); i++) {
        values[i] = instruments_[i]->calibrationError()
                   *std::sqrt(weights_[i]);
    }

for (i=0; i<arguments_.size(); i++)
    size += arguments_[i].size();

for (i=0; i<arguments_.size(); i++) {
    for (Size j=0; j<arguments_[i].size(); j++, k++) {
        params[k] = arguments_[i].params()[j];
    }
}

for (Size i=0; i<arguments_.size(); ++i) {
    for (Size j=0; j<arguments_[i].size(); ++j, ++p) {
        QL_REQUIRE(p!=params.end(),"parameter array too small");
        arguments_[i].setParam(j, *p);
    }
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/shortrate/onefactormodel.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    for (Size j=0; j<size_; j++)
        value -= statePrices_[j]*tree_.discount(i_,j);

for (Size i=0; i<(timeGrid.size() - 1); i++) {
    Real discountBond = theta->termStructure()->discount(t_[i+1]);
    Helper finder(i, discountBond, theta, *this);
    Brent s1d;
    s1d.setMaxEvaluations(1000);
    value = s1d.solve(finder, 1e-7, value, vMin, vMax);
    // vMin = value - 1.0;
    // vMax = value + 1.0;
    theta->change(value);
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/shortrate/twofactormodels/g2.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    for (Size i=0; i<size_; i++) {
        A_[i] = model.A(T_, t_[i]);
        Ba_[i] = model.B(a_, t_[i]-T_);
        Bb_[i] = model.B(b_, t_[i]-T_);
    }

    for (i=0; i<size_; i++) {
        Real tau = (i==0 ? t_[0] - T_ : t_[i] - t_[i-1]);
        Real c = (i==size_-1 ? (1.0+rate_*tau) : rate_*tau);
        lambda[i] = c*A_[i]*std::exp(-Ba_[i]*x);
    }

    for (i=0; i<size_; i++) {
        Real h2 = h1 +
            Bb_[i]*sigmay_*std::sqrt(1.0-rhoxy_*rhoxy_);
        Real kappa = - Bb_[i] *
            (muy_ - 0.5*txy*txy*sigmay_*sigmay_*Bb_[i] +
             rhoxy_*sigmay_*(x-mux_)/sigmax_);
        value -= lambda[i] *std::exp(kappa)*phi(-w_*h2);
    }

        for (Size i=0; i<lambda_.size(); i++) {
            value -= lambda_[i]*std::exp(-Bb_[i]*y);
        }

for (Size i=0; i<fixedPayTimes.size(); ++i)
    fixedPayTimes[i] =
        dayCounter.yearFraction(settlement,
                                arguments.fixedPayDates[i]);

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/shortrate/onefactormodels/hullwhite.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i<(grid.size() - 1); i++) {
    Real discountBond = termStructure()->discount(grid[i+1]);
    const Array& statePrices = numericTree->statePrices(i);
    Size size = numericTree->size(i);
    Time dt = numericTree->timeGrid().dt(i);
    Real dx = trinomial->dx(i);
    Real x = trinomial->underlying(i,0);
    Real value = 0.0;
    for (Size j=0; j<size; j++) {
        value += statePrices[j]*std::exp(-x*dt);
        x += dx;
    }
    value = std::log(value/discountBond)/dt;
    impl->set(grid[i], value);
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/shortrate/onefactormodels/gsr.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i = 0; i < volatilities.size(); ++i)
volatilities_[i] =
    Handle<Quote>(boost::make_shared<SimpleQuote>(volatilities[i]));

for (Size i = 0; i < volatilities.size(); ++i)
volatilities_[i] =
    Handle<Quote>(boost::make_shared<SimpleQuote>(volatilities[i]));

for (Size i = 0; i < reversions.size(); ++i)
reversions_[i] =
    Handle<Quote>(boost::make_shared<SimpleQuote>(reversions[i]));

for (Size i = 0; i < sigma_.size(); i++) {
sigma_.setParam(i, volatilities_[i]->value());
}

for (Size i = 0; i < reversion_.size(); i++) {
reversion_.setParam(i, reversions_[i]->value());
}

for (Size i = 0; i < sigma_.size(); i++) {
sigma_.setParam(i, volatilities_[i]->value());
}

for (Size i = 0; i < reversion_.size(); i++) {
reversion_.setParam(i, reversions_[i]->value());
}

for (Size i = 0; i < reversions_.size(); ++i)
reversionObserver_->registerWith(reversions_[i]);

for (Size i = 0; i < volatilities_.size(); ++i)
volatilityObserver_->registerWith(volatilities_[i]);

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/shortrate/onefactormodels/blackkarasinski.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    for (Size j=0; j<size_; j++) {
        Real discount = std::exp(-std::exp(theta+x)*dt_);
        value -= statePrices_[j]*discount;
        x += dx_;
    }

for (Size i=0; i<(grid.size() - 1); i++) {
    Real discountBond = termStructure()->discount(grid[i+1]);
    Real xMin = trinomial->underlying(i, 0);
    Real dx = trinomial->dx(i);
    Helper finder(i, xMin, dx, discountBond, numericTree);
    Brent s1d;
    s1d.setMaxEvaluations(1000);
    value = s1d.solve(finder, 1e-7, value, vMin, vMax);
    impl->set(grid[i], value);
    // vMin = value - 10.0;
    // vMax = value + 10.0;
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/shortrate/onefactormodels/gaussian1dmodel.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i = 1; i < floatSched.size(); i++) {
    floatleg +=
        (zerobond(floatSched[i - 1], referenceDate, y, ytsf) /
             zerobond(floatSched[i], referenceDate, y, ytsf) -
         1.0) *
        zerobond(floatSched.calendar().adjust(
                     floatSched[i], underlying->paymentConvention()),
                 referenceDate, y, ytsd);
}

for (unsigned int j = 1; j < sched.size(); j++) {
annuity += zerobond(sched.calendar().adjust(
                        sched.date(j), underlying->paymentConvention()),
                    referenceDate, y, ytsd) *
           swapIdx->dayCounter().yearFraction(sched.date(j - 1),
                                              sched.date(j));
}

for (Size i = 0; i < yg.size(); i++) {
Real expValDsc = zerobond(valueDate, expiry, yg[i], yts);
Real discount =
    zerobond(maturity, expiry, yg[i], yts) / expValDsc;
p[i] =
    std::max((type == Option::Call ? 1.0 : -1.0) * (discount - strike),
             0.0) /
    numeraire(fixingTime, yg[i], yts) * expValDsc;
}

for (Size i = 0; i < z.size() - 1; i++) {
price += gaussianShiftedPolynomialIntegral(
    0.0, payoff.cCoefficients()[i], payoff.bCoefficients()[i],
    payoff.aCoefficients()[i], p[i], z[i], z[i], z[i + 1]);
}

for (int j = -gridPoints; j <= gridPoints; j++) {
result[j + gridPoints] =
    (e_t_T + stdDev_t_T * ((Real)j) * h - e_0_T) / stdDev_0_T;
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/shortrate/onefactormodels/markovfunctional.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i = 0; i < normalIntegralX_.size(); i++) {
    normalIntegralW_[i] *=
        std::exp(-normalIntegralX_[i] * normalIntegralX_[i]) * M_1_SQRTPI;
    normalIntegralX_[i] *= M_SQRT2;
}

    for (std::vector<Date>::const_iterator i = capletExpiries_.begin(); i != capletExpiries_.end(); ++i) {
        makeCapletCalibrationPoint(*i);
    }

for (Size i = 0; i < sigma_.size(); i++) {
    sigma_.setParam(i, volatilities_[i]);
}

for (Size i = 0; i < times_.size(); i++) {
    boost::shared_ptr<Interpolation> numInt(new CubicInterpolation(
        y_.begin(), y_.end(), discreteNumeraire_->row_begin(i),
        CubicInterpolation::Spline, true, CubicInterpolation::Lagrange,
        0.0, CubicInterpolation::Lagrange, 0.0));
    numInt->enableExtrapolation();
    numeraire_.push_back(numInt);
}

for (unsigned int k = 1; k < sched.size(); k++) {
    p.yearFractions_.push_back(
        swapIndexBase_->dayCounter().yearFraction(
            k == 1 ? expiry : sched.date(k - 1), sched.date(k)));
    p.paymentDates_.push_back(cal.adjust(sched.date(k), bdc));
}

            for (Size j = 0; j < k.size(); j++) {
                v.push_back(
                    i->second.rawSmileSection_->volatility(k[j]));
            }

    for (unsigned int k = 0; k < i->second.paymentDates_.size(); k++) {
        deflatedFinalPayments =
            deflatedZerobondArray(termStructure()->timeFromReference(
                                      i->second.paymentDates_[k]),
                                  times_[idx], y_);
        discreteDeflatedAnnuities +=
            deflatedFinalPayments * i->second.yearFractions_[k];
    }

        for (int j = y_.size() - 1; j >= 0; j--) {

            Real integral = 0.0;

            if (j == (int)(y_.size() - 1)) {
                if ((modelSettings_.adjustments_ &
                     ModelSettings::NoPayoffExtrapolation) == 0) {
                    if ((modelSettings_.adjustments_ &
                         ModelSettings::ExtrapolatePayoffFlat) != 0) {
                        integral = gaussianShiftedPolynomialIntegral(
                            0.0, 0.0, 0.0, 0.0,
                            discreteDeflatedAnnuities[j - 1], y_[j - 1],
                            y_[j], 100.0);
                    } else {
                        Real ca =
                            deflatedAnnuities.aCoefficients()[j - 1];
                        Real cb =
                            deflatedAnnuities.bCoefficients()[j - 1];
                        Real cc =
                            deflatedAnnuities.cCoefficients()[j - 1];
                        integral = gaussianShiftedPolynomialIntegral(
                            0.0, cc, cb, ca,
                            discreteDeflatedAnnuities[j - 1], y_[j - 1],
                            y_[j], 100.0);
                    }
                }
            } else {
                Real ca = deflatedAnnuities.aCoefficients()[j];
                Real cb = deflatedAnnuities.bCoefficients()[j];
                Real cc = deflatedAnnuities.cCoefficients()[j];
                integral = gaussianShiftedPolynomialIntegral(
                    0.0, cc, cb, ca, discreteDeflatedAnnuities[j],
                    y_[j], y_[j], y_[j + 1]);
            }

            if (integral < 0) {
                QL_MFMESSAGE(modelOutputs_,
                             "WARNING: integral for digitalPrice is "
                             "negative for j="
                                 << j << " (" << integral
                                 << ") --- reset it to zero.");
                integral = 0.0;
            }

            digital += integral * numeraire0 * digitalsCorrectionFactor;

            if (digital >= i->second.minRateDigital_)
                swapRate = modelSettings_.lowerRateBound_ -
                           i->second.rawSmileSection_->shift();
            else {
                if (digital <= i->second.maxRateDigital_)
                    swapRate = modelSettings_.upperRateBound_;
                else {
                    swapRate = marketSwapRate(
                        i->first, i->second, digital, swapRate0,
                        i->second.rawSmileSection_->shift());
                    if (j < (int)y_.size() - 1 &&
                        swapRate > swapRate0) {
                        QL_MFMESSAGE(
                            modelOutputs_,
                            "WARNING: swap rate is decreasing in y for "
                            "t="
                                << times_[idx] << ", j=" << j
                                << " (y, swap rate) is (" << y_[j]
                                << "," << swapRate
                                << ") but for j=" << j + 1 << " it is ("
                                << y_[j + 1] << "," << swapRate0
                                << ") --- reset rate to " << swapRate0
                                << " in node j=" << j);
                        swapRate = swapRate0;
                    }
                }
            }
            swapRate0 = swapRate;
            Real numeraire =
                1.0 / (swapRate * discreteDeflatedAnnuities[j] +
                       deflatedFinalPayments[j]);
            (*discreteNumeraire_)[idx][j] = numeraire * normalization;
        }

        for (int j = y_.size() - 1; j >= 0; j--) {
            (*discreteNumeraire_)[idx][j] *=
                modelDeflatedZerobond / marketDeflatedZerobond;
        }

    for (Size i = 1; i < times_.size() - 1; i++) {
        modelOutputs_.marketZerorate_.push_back(
            termStructure()->zeroRate(times_[i], QuantLib::Continuous,
                                      QuantLib::Annual));
        // we need to put a small positive time here since the zerobond
        // implementation optimizes the case t=0.0 then using the
        // initial yts
        modelOutputs_.modelZerorate_.push_back(
            -std::log(zerobond(times_[i], 1.0E-10)) / times_[i]);
    }

        for (Size j = 0; j < money.size(); j++) {
            strikes.push_back(money[j] * (i->second.atm_ + shift) -
                              shift);
            try {
                marketRawCall.push_back(rawSec->optionPrice(
                    strikes[j], Option::Call, i->second.annuity_));
                marketRawPut.push_back(rawSec->optionPrice(
                    strikes[j], Option::Put, i->second.annuity_));
            }
            catch (QuantLib::Error) {
                // the smile section might not be able to output an
                // option price because it has no atm level
                marketRawCall.push_back(0.0);
                marketRawPut.push_back(0.0);
            }
            marketCall.push_back(sec->optionPrice(
                strikes[j], Option::Call, i->second.annuity_));
            marketPut.push_back(sec->optionPrice(
                strikes[j], Option::Put, i->second.annuity_));
            modelCall.push_back(
                i->second.isCaplet_
                    ? capletPriceInternal(Option::Call, i->first, strikes[j],
                                     Null<Date>(), 0.0, true)
                    : swaptionPriceInternal(Option::Call, i->first,
                                       i->second.tenor_, strikes[j],
                                       Null<Date>(), 0.0, true));
            modelPut.push_back(
                i->second.isCaplet_
                    ? capletPriceInternal(Option::Put, i->first, strikes[j],
                                     Null<Date>(), 0.0, true)
                    : swaptionPriceInternal(Option::Put, i->first,
                                       i->second.tenor_, strikes[j],
                                       Null<Date>(), 0.0, true));
            marketVega.push_back(
                sec->vega(strikes[j], i->second.annuity_));
        }

for (Size j = 0; j < y.size(); j++) {
    Real yv = y[j];
    if (yv < y_.front())
        yv = y_.front();
    // FIXME flat extrapolation should be incoperated into interpolation
    // object, see above
    if (yv > y_.back())
        yv = y_.back();
    Real na = (*numeraire_[i - 1])(yv);
    Real nb = (*numeraire_[i])(yv);
    res[j] =
        inverseNormalization / ((tz - ta) / nb + (tb - tz) / na) * dt;
    // linear in reciprocal of normalized numeraire
}

for (Size j = 0; j < y.size(); j++) {
    Array ya(modelSettings_.gaussHermitePoints_);
    for (Size i = 0; i < modelSettings_.gaussHermitePoints_; i++) {
        ya[i] = (y[j] * stdDev_0_t + stdDev_t_T * normalIntegralX_[i]) /
                stdDev_0_T;
    }
    Array res = numeraireArray(T, ya);
    for (Size i = 0; i < modelSettings_.gaussHermitePoints_; i++) {
        result[j] += normalIntegralW_[i] / res[i];
    }
}

for (Size i = 0; i < m.settings_.smileMoneynessCheckpoints_.size(); i++)
    out << m.settings_.smileMoneynessCheckpoints_[i]
        << (i < m.settings_.smileMoneynessCheckpoints_.size() - 1 ? ";"
                                                                  : "");

for (Size i = 0; i < m.expiries_.size(); i++) {
    out << m.expiries_[i] << ";" << m.tenors_[i] << ";" << m.atm_[i]
        << ";" << m.annuity_[i] << ";"
        << m.digitalsAdjustmentFactors_[i] << ";"
        << m.adjustmentFactors_[i] << ";" << m.marketZerorate_[i] << ";"
        << m.modelZerorate_[i] << ";"
        << (m.marketZerorate_[i] - m.modelZerorate_[i]) * 10000.0
        << std::endl;
}

for (Size i = 0; i < m.expiries_.size(); i++) {
    std::ostringstream os;
    os << m.expiries_[i] << "/" << m.tenors_[i];
    std::string p = os.str();
    out << "strike(" << p << ");marketCallRaw(" << p << ";marketCall("
        << p << ");modelCall(" << p << ");marketPutRaw(" << p
        << ");marketPut(" << p << ");modelPut(" << p << ");marketVega("
        << p << ")" << (i < m.expiries_.size() - 1 ? ";" : "");
}

for (Size j = 0; j < m.smileStrikes_[0].size(); j++) {
    for (Size i = 0; i < m.expiries_.size(); i++) {
        out << m.smileStrikes_[i][j] << ";"
            << m.marketRawCallPremium_[i][j] << ";"
            << m.marketCallPremium_[i][j] << ";"
            << m.modelCallPremium_[i][j] << ";"
            << m.marketRawPutPremium_[i][j] << ";"
            << m.marketPutPremium_[i][j] << ";"
            << m.modelPutPremium_[i][j] << ";" << m.marketVega_[i][j]
            << (i < m.expiries_.size() - 1 ? ";" : "");
    }
    out << std::endl;
}

for (unsigned int j = 1; j < sched.size(); j++) {
    annuity +=
        zerobond(sched.calendar().adjust(
                     sched.date(j), underlying->paymentConvention()),
                 referenceDate, y) *
        swapIdx->dayCounter().yearFraction(
            j == 1 && zeroFixingDays ? fixing : sched.date(j - 1),
            sched.date(j));
}

for (Size i = 0; i < yg.size(); i++) {
    Real annuity = swapAnnuityInternal(expiry, tenor, expiry, yg[i],
                                  zeroFixingDays, swapIdx);
    Rate atm = swapRateInternal(expiry, tenor, expiry, yg[i], zeroFixingDays,
                           swapIdx);
    p[i] = annuity * std::max((type == Option::Call ? 1.0 : -1.0) *
                                  (atm - strike),
                              0.0) /
           numeraire(fixingTime, yg[i]);
}

for (Size i = 0; i < z.size() - 1; i++) {
    price += gaussianShiftedPolynomialIntegral(
        0.0, payoff.cCoefficients()[i], payoff.bCoefficients()[i],
        payoff.aCoefficients()[i], p[i], z[i], z[i], z[i + 1]);
}

for (Size i = 0; i < yg.size(); i++) {
    Real annuity = zerobond(endDate, expiry, yg[i]) * dcf;
    Rate atm =
        forwardRateInternal(expiry, expiry, yg[i], zeroFixingDays, iborIdx);
    p[i] = annuity * std::max((type == Option::Call ? 1.0 : -1.0) *
                                  (atm - strike),
                              0.0) /
           numeraire(fixingTime, yg[i]);
}

for (Size i = 0; i < z.size() - 1; i++) {
    price += gaussianShiftedPolynomialIntegral(
        0.0, payoff.cCoefficients()[i], payoff.bCoefficients()[i],
        payoff.aCoefficients()[i], p[i], z[i], z[i], z[i + 1]);
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/volatility/garch.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    for (std::size_t i = 2; i < idx_.size(); ++i) {
        target[i] = acf_[idx_[i]] / A4;
        fct2fit[i] = std::pow(gamma, (int)idx_[i]-1)* fct2fit[1];
    }

    for (std::size_t i = 2; i < idx_.size(); ++i) {
        target[i] = acf_[idx_[i]] / A4;
        w1 = std::pow(gamma, (int)idx_[i]-1);
        fct2fit[i] = w1 * fct2fit[1];
        grad_fct2fit[i][0] = (idx_[i]-1) * (w1/gamma)*fct2fit[1] + w1*grad_fct2fit[1][0];
        grad_fct2fit[i][1] = w1 * grad_fct2fit[1][1];
    }

    for (std::size_t i = 0; i <= nCov; ++i) {
        if (i < 2 || (i > 1 && acf[i] > 0 && acf[i-1] > 0 && acf[i-1] > acf[i])) {
            idx.push_back(i);
        }
    }

    for (std::size_t i = 0; i <= nCov; ++i) {
        if (i < 2) idx.push_back(i);
        if (i > 1 && acf[i] > 0 && acf[i-1] > 0 && acf[i-1] > acf[i]) {
            gamma += acf[i]/acf[i-1];
            nn++;
            idx.push_back(i);
        }
    }

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/volatility/constantestimator.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=size_; i < volatilitySeries.size(); i++) {
    Size j;
    Real sumu2=0.0, sumu=0.0;
    for (j=i-size_; j <i; j++) {
        sumu += u[j];
        sumu2 += u[j]*u[j];
    }
    Real s = std::sqrt(sumu2/(Real)size_ - sumu*sumu / (Real) size_ /
                       (Real) (size_+1));
    retval[cur->first] = s;
    ++cur;
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/marketmodeldifferences.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i<totalCovariance1.columns(); ++i) {
    Real diff = totalCovariance1[i][i]-totalCovariance2[i][i];
    result[i] = std::sqrt(diff/maturities[i]);
}

for (Size i=0; i<evolutionTimes.size(); ++i) {
    Time currentEvolutionTime = evolutionTimes[i];
    Time dt = currentEvolutionTime - previousEvolutionTime;
    const Matrix& covariance1 = marketModel1.covariance(i);
    const Matrix& covariance2 = marketModel2.covariance(i);
    Real diff = covariance1[index][index] - covariance2[index][index];
    result[i] = std::sqrt(diff/dt);
    previousEvolutionTime = currentEvolutionTime;
}

    for (Size i=1; i<rateTimes.size(); ++i) {
        Time sqrtTau = std::sqrt(rateTimes[i]-rateTimes[i-1]);
        const Matrix& correlations
            = piecewiseConstantCorrelation.correlation(i);
        Matrix pseudoRoot(correlations.rows(), correlations.rows());
        for (Size j=0; j<correlations.rows(); ++j) {
            Real volatility
              = piecewiseConstantVariances[j]->volatility(i)*sqrtTau;
            std::transform(correlations.row_begin(j),
                           correlations.row_end(j),
                           pseudoRoot.row_begin(j),
                           std::bind2nd(std::multiplies<Real>(),
                                                    volatility));
        }
        peudoRoots.push_back(pseudoRoot);
    }

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/utilities.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i<times.size(); i++) {
    allTimes.insert(allTimes.end(),
                    times[i].begin(),
                    times[i].end());
}

for (Size i=0; i<times.size(); i++) {
    isPresent[i].resize(allTimes.size());
    for (Size j=0; j<allTimes.size(); j++) {
        isPresent[i][j] = std::binary_search(times[i].begin(),
                                             times[i].end(),
                                             allTimes[j]);
    }
}

for (Size i=0; i<dimSet; ++i) {  // loop in set
    Size j=0;
    setElement = set[i];
    for (;;) {              // loop in subset
        subsetElement = subset[j];
        result[i] = false;
        // if smaller no hope, leave false and go to next i
        if (setElement < subsetElement)
            break;
        // if match, set result[i] to true and go to next i
        if (setElement == subsetElement) {
            result[i] = true;
            break;
        }
        // if larger, leave false if at the end or go to next j
        if (j == dimsubSet-1)
            break;
        ++j;
    }
}

for (Size i=0; i<nTimes-1; ++i)
    QL_REQUIRE(times[i+1]-times[i]>0,
               "non increasing rate times: "
               "times[" << i   << "]=" << times[i] << ", "
               "times[" << i+1 << "]=" << times[i+1]);

for (Size i=0; i<nTimes-1; ++i) {
    taus[i]=times[i+1]-times[i];
    QL_REQUIRE(taus[i]>0,
               "non increasing rate times: "
               "times[" << i   << "]=" << times[i] << ", "
               "times[" << i+1 << "]=" << times[i+1]);
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/marketmodel.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    for (Size j=0; j<numberOfSteps(); ++j)
        covariance_[j] = pseudoRoot(j) * transpose(pseudoRoot(j));

    for (Size j=1; j<numberOfSteps(); ++j)
        totalCovariance_[j] = totalCovariance_[j-1] + covariance_[j];

for (Size j=0; j<numberOfSteps(); ++j) {
    Time tau = evolutionTime[j]-lastTime;
    Real thisVariance = covariance(j)[i][i];
    Real thisVol = std::sqrt(thisVariance/tau);
    result[j] = thisVol;
    lastTime =  evolutionTime[j];
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/forwardforwardmappings.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size l=0; l < k; ++l)
    {
    Real df = cs.discountRatio(m,m+multiplier);
    Real bigTau = cs.rateTimes()[m+multiplier]
    -  cs.rateTimes()[m];

    for (Size r=0; r < multiplier; ++r, ++m)
        {
        Real value = df * tau[m]*cs.discountRatio(m+1,m)-1;
        value /= bigTau;
        jacobian[l][m]=-value;

        }
    }

for (Size i=0; i < k ; ++i)
    {
    Real tau = cs.rateTimes()[(i+1)*multiplier+offset]
    -  cs.rateTimes()[i*multiplier+offset];

    Real longForward = (cs.discountRatio((i+1)*multiplier+offset,i*multiplier+offset)-1.0)
        /tau;
    Real longForwardDisplaced = longForward+ longDisplacements[i];
    for (Size j=0; j < n; ++j)
        {
        Real shortForward = cs.forwardRate(j);
        Real shortForwardDisplaced = shortForward+shortDisplacements[j];
        jacobian[i][j] *= shortForwardDisplaced/longForwardDisplaced;
        }

    }

   for (Size i=0; i < k+1; ++i)
   {
       times[i] = cs.rateTimes()[i*multiplier+offset];
       discRatios[i] = cs.discountRatio(i*multiplier+offset,0);
   }

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/pathwiseaccountingengine.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i <= numberSteps_; ++i)
    Discounts_[i][0] = 1.0;

for (Size i=0; i<numberProducts_; ++i)
{
    cashFlowsGenerated_[i].resize(
        product_->maxNumberOfCashFlowsPerProductPerStep());

    for (Size j=0; j < cashFlowsGenerated_[i].size(); ++j)
        cashFlowsGenerated_[i][j].amount.resize(numberRates_+1);

    numberCashFlowsThisIndex_[i].resize(product_->possibleCashFlowTimes().size());

    V_.push_back(VModel);


    totalCashFlowsThisIndex_.push_back(modelCashFlowIndex);
}

for (Size j=0; j<cashFlowTimes.size(); ++j)
    discounters_.push_back(MarketModelPathwiseDiscounter(cashFlowTimes[j],
    rateTimes));

for (Size i=0; i < numberCashFlowTimes_; ++i)
{
    std::vector<Time>::const_iterator it = std::upper_bound( evolutionTimes.begin(), evolutionTimes.end(), cashFlowTimes[i]);
    if (it != evolutionTimes.begin())
        --it;
    Size index = it - evolutionTimes.begin();
    cashFlowIndicesThisStep_[index].push_back(i);
}

for (Size i=0; i < numberProducts_; ++i)
{
    numerairesHeld_[i]=0.0;

    for (Size j=0; j < numberCashFlowTimes_; ++j)
    {
        numberCashFlowsThisIndex_[i][j] =0;

        for (Size k=0; k <= numberRates_; ++k)
            totalCashFlowsThisIndex_[i][j][k] =0.0;
    }

    for (Size l=0;  l< numberRates_; ++l)
        for (Size m=0; m <= numberSteps_; ++m)
            V_[i][m][l] =0.0;

}

    for (unsigned long i=0; i < numberRates_; ++i)
    {
        Real x=  evolver_->currentState().discountRatio(i+1,i);
        StepsDiscountsSquared_[storeStep][i] = x*x;

        LIBORRatios_[storeStep][i] = currentForwards_[i]/lastForwards_[i];
        LIBORRates_[storeStep][i] = currentForwards_[i];
        Discounts_[storeStep][i+1] = evolver_->currentState().discountRatio(i+1,0);
    }

    for (Size i=0; i<numberProducts_; ++i)
    {
        // ...and each cash flow...
        for (Size j=0; j<numberCashFlowsThisStep_[i]; ++j)
        {
            Size k = cashFlowsGenerated_[i][j].timeIndex;
            ++numberCashFlowsThisIndex_[i][ k];

            for (Size l=0; l <= numberRates_; ++l)
                totalCashFlowsThisIndex_[i][k][l] += cashFlowsGenerated_[i][j].amount[l]*weight;

        }
    }

for (Integer currentStep =  numberSteps_-1; currentStep >=0 ; --currentStep) // must be a signed type as we go negative
{
    Integer stepToUse = std::min<Integer>(currentStep, finalStepDone)+1;

    for (Size k=0; k < cashFlowIndicesThisStep_[currentStep].size(); ++k)
    {
        Size cashFlowIndex =cashFlowIndicesThisStep_[currentStep][k];

        // first check to see if anything actually happened before spending time on computing stuff
        bool noFlows = true;
        for (Size l=0; l < numberProducts_ && noFlows; ++l)
            noFlows = noFlows && (numberCashFlowsThisIndex_[l][cashFlowIndex] ==0);

        flowsFound = flowsFound || !noFlows;

        if (!noFlows)
        {
            if (doDeflation_)
                discounters_[cashFlowIndex].getFactors(LIBORRates_, Discounts_,stepToUse, deflatorAndDerivatives_); // get amount to discount cash flow by and amount to multiply its derivatives by

            for (Size j=0; j < numberProducts_; ++j)
            {
                if (numberCashFlowsThisIndex_[j][cashFlowIndex] > 0)
                {
                    Real deflatedCashFlow = totalCashFlowsThisIndex_[j][cashFlowIndex][0];
                    if (doDeflation_)
                        deflatedCashFlow *= deflatorAndDerivatives_[0];
                    //cashFlowsGenerated_[j][cashFlowIndex].amount[0]*deflatorAndDerivatives_[0];
                    numerairesHeld_[j] += deflatedCashFlow;

                    for (Size i=1; i <= numberRates_; ++i)
                    {
                        Real thisDerivative =  totalCashFlowsThisIndex_[j][cashFlowIndex][i];
                        if (doDeflation_)
                        {
                            thisDerivative *= deflatorAndDerivatives_[0];
                            thisDerivative +=  totalCashFlowsThisIndex_[j][cashFlowIndex][0]*deflatorAndDerivatives_[i];
                        }

                        V_[j][stepToUse][i-1] += thisDerivative; // zeroth row of V is t =0 not t_0
                    }
                }
            }
        }
    }

    // need to do backwards updating
    if (flowsFound)
    {
        Integer nextStepToUse  = std::min<Integer>(currentStep-1, finalStepDone);
        Integer nextStepIndex = nextStepToUse+1;
        if (nextStepIndex != stepToUse) // then we need to update V
        {

            const Matrix& thisPseudoRoot_= pseudoRootStructure_->pseudoRoot(currentStep);

            for (Size i=0; i < numberProducts_; ++i)
            {
                // compute partials
                for (Size f=0; f < factors; ++f)
                {
                    Real libor = LIBORRates_[stepToUse][numberRates_-1];
                    Real V = V_[i][stepToUse][numberRates_-1];
                    Real pseudo = thisPseudoRoot_[numberRates_-1][f];
                    Real thisPartialTerm = libor*V*pseudo;
                    partials_[f][numberRates_-1] = thisPartialTerm;

                    for (Integer r = numberRates_-2; r >=0 ; --r)
                    {
                        Real thisPartialTermr = LIBORRates_[stepToUse][r]*V_[i][stepToUse][r]*thisPseudoRoot_[r][f];

                        partials_[f][r] = partials_[f][r+1] + thisPartialTermr;

                    }
                }
                for (Size j=0; j < numberRates_; ++j)
                {
                    Real nextV = V_[i][stepToUse][j] * LIBORRatios_[stepToUse][j];
                    V_[i][nextStepIndex][j] = nextV;

                    Real summandTerm = 0.0;
                    for (Size f=0; f < factors; ++f)
                        summandTerm += thisPseudoRoot_[j][f]*partials_[f][j];

                    summandTerm *= taus[j]*StepsDiscountsSquared_[stepToUse][j];

                    V_[i][nextStepIndex][j] += summandTerm;

                }
            }

        }
    }




}

for (Size i=0; i < numberProducts_; ++i)
{
    values[i] = numerairesHeld_[i]*initialNumeraireValue_;
    for (Size j=0; j < numberRates_; ++j)
        values[(i+1)*numberProducts_+j] = V_[i][0][j]*initialNumeraireValue_;
}

for (Size i=0; i<numberOfPaths; ++i)
{
    Real weight = singlePathValues(values);
    stats.add(values,weight);
}

for (Size i =0; i < numberSteps_; ++i)
{
    Size thisSize = vegaBumps[i].size();
    QL_REQUIRE(thisSize == numberBumps_,"We must have precisely the same number of bumps for each step.");
    jacobianComputers_.push_back(RatePseudoRootJacobian(pseudoRootStructure_->pseudoRoot(i),evolution.firstAliveRate()[i],
                        numeraires_[i],
                        evolution.rateTaus(),
                        vegaBumps[i], pseudoRootStructure_->displacements()));

    jacobiansThisPaths_.push_back(Matrix(numberBumps_,pseudoRootStructure_->numberOfRates()));

}

for (Size i=0; i <= numberSteps_; ++i)
    Discounts_[i][0] = 1.0;

for (Size i=0; i<numberProducts_; ++i)
{
    cashFlowsGenerated_[i].resize(
        product_->maxNumberOfCashFlowsPerProductPerStep());

    for (Size j=0; j < cashFlowsGenerated_[i].size(); ++j)
        cashFlowsGenerated_[i][j].amount.resize(numberRates_+1);

    numberCashFlowsThisIndex_[i].resize(product_->possibleCashFlowTimes().size());

    V_.push_back(VModel);


    totalCashFlowsThisIndex_.push_back(modelCashFlowIndex);
}

for (Size j=0; j<cashFlowTimes.size(); ++j)
    discounters_.push_back(MarketModelPathwiseDiscounter(cashFlowTimes[j],
    rateTimes));

for (Size i=0; i < numberCashFlowTimes_; ++i)
{
    std::vector<Time>::const_iterator it = std::upper_bound( evolutionTimes.begin(), evolutionTimes.end(), cashFlowTimes[i]);
    if (it != evolutionTimes.begin())
        --it;
    Size index = it - evolutionTimes.begin();
    cashFlowIndicesThisStep_[index].push_back(i);
}

for (Size i=0; i < numberProducts_; ++i)
{
    numerairesHeld_[i]=0.0;

    for (Size j=0; j < numberCashFlowTimes_; ++j)
    {
        numberCashFlowsThisIndex_[i][j] =0;

        for (Size k=0; k <= numberRates_; ++k)
            totalCashFlowsThisIndex_[i][j][k] =0.0;
    }

    for (Size l=0;  l< numberRates_; ++l)
        for (Size m=0; m <= numberSteps_; ++m)
            V_[i][m][l] =0.0;

    for (Size p=0; p < numberBumps_; ++p)
        vegasThisPath_[i][p] =0.0;

}

    for (unsigned long i=0; i < numberRates_; ++i)
    {
        Real x=  evolver_->currentState().discountRatio(i+1,i);
        stepsDiscounts_[i+1] = x;
        StepsDiscountsSquared_[storeStep][i] = x*x;

        LIBORRatios_[storeStep][i] = currentForwards_[i]/lastForwards_[i];
        LIBORRates_[storeStep][i] = currentForwards_[i];
        Discounts_[storeStep][i+1] = evolver_->currentState().discountRatio(i+1,0);
    }

    for (Size i=0; i<numberProducts_; ++i)
    {
        // ...and each cash flow...
        for (Size j=0; j<numberCashFlowsThisStep_[i]; ++j)
        {
            Size k = cashFlowsGenerated_[i][j].timeIndex;
            ++numberCashFlowsThisIndex_[i][ k];

            for (Size l=0; l <= numberRates_; ++l)
                totalCashFlowsThisIndex_[i][k][l] += cashFlowsGenerated_[i][j].amount[l]*weight;

        }
    }

for (Integer currentStep =  numberSteps_-1; currentStep >=0 ; --currentStep) // must be a signed type as we go negative
{
    Integer stepToUse = std::min<Integer>(currentStep, finalStepDone)+1;

    for (Size k=0; k < cashFlowIndicesThisStep_[currentStep].size(); ++k)
    {
        Size cashFlowIndex =cashFlowIndicesThisStep_[currentStep][k];

        // first check to see if anything actually happened before spending time on computing stuff
        bool noFlows = true;
        for (Size l=0; l < numberProducts_ && noFlows; ++l)
            noFlows = noFlows && (numberCashFlowsThisIndex_[l][cashFlowIndex] ==0);

        flowsFound = flowsFound || !noFlows;

        if (!noFlows)
        {
            if (doDeflation_)
                discounters_[cashFlowIndex].getFactors(LIBORRates_, Discounts_,stepToUse, deflatorAndDerivatives_); // get amount to discount cash flow by and amount to multiply its derivatives by

            for (Size j=0; j < numberProducts_; ++j)
            {
                if (numberCashFlowsThisIndex_[j][cashFlowIndex] > 0)
                {
                    Real deflatedCashFlow = totalCashFlowsThisIndex_[j][cashFlowIndex][0];
                    if (doDeflation_)
                        deflatedCashFlow *= deflatorAndDerivatives_[0];
                    //cashFlowsGenerated_[j][cashFlowIndex].amount[0]*deflatorAndDerivatives_[0];
                    numerairesHeld_[j] += deflatedCashFlow;

                    for (Size i=1; i <= numberRates_; ++i)
                    {
                        Real thisDerivative =  totalCashFlowsThisIndex_[j][cashFlowIndex][i];
                        if (doDeflation_)
                        {
                            thisDerivative *= deflatorAndDerivatives_[0];
                            thisDerivative +=  totalCashFlowsThisIndex_[j][cashFlowIndex][0]*deflatorAndDerivatives_[i];
                            fullDerivatives_[i-1] = thisDerivative;
                        }
                        else
                            fullDerivatives_[i-1] = thisDerivative;

                        V_[j][stepToUse][i-1] += thisDerivative; // zeroth row of V is t =0 not t_0
                    }

                    // ok we've got the derivatives and stored them, now add them to vegas
                    // this corresponds to the \frac{\partial F_n}[\partial theta} term
                    // we add the indirect terms later

                    for (Size k=0; k < numberBumps_; ++k)
                        for (Size i=0; i < numberRates_; ++i)
                        {
                            vegasThisPath_[j][k] +=  fullDerivatives_[i]*jacobiansThisPaths_[stepToUse-1][k][i];
                        }


                } // end of (numberCashFlowsThisIndex_[j][cashFlowIndex] > 0)
            } // end of (Size j=0; j < numberProducts_; ++j)
        } // end of  if (!noFlows)
    }

            for (Size i=0; i < numberProducts_; ++i)
            {
                // compute partials
                for (Size f=0; f < factors; ++f)
                {
                    Real libor = LIBORRates_[stepToUse][numberRates_-1];
                    Real V = V_[i][stepToUse][numberRates_-1];
                    Real pseudo = thisPseudoRoot_[numberRates_-1][f];
                    Real thisPartialTerm = libor*V*pseudo;
                    partials_[f][numberRates_-1] = thisPartialTerm;

                    for (Integer r = numberRates_-2; r >=0 ; --r)
                    {
                        Real thisPartialTermr = LIBORRates_[stepToUse][r]*V_[i][stepToUse][r]*thisPseudoRoot_[r][f];

                        partials_[f][r] = partials_[f][r+1] + thisPartialTermr;

                    }
                } // end of (Size f=0; f < factors; ++f)

                for (Size j=0; j < numberRates_; ++j)
                {
                    Real nextV = V_[i][stepToUse][j] * LIBORRatios_[stepToUse][j];
                    V_[i][nextStepIndex][j] = nextV;

                    Real summandTerm = 0.0;
                    for (Size f=0; f < factors; ++f)
                        summandTerm += thisPseudoRoot_[j][f]*partials_[f][j];

                    summandTerm *= taus[j]*StepsDiscountsSquared_[stepToUse][j];

                    V_[i][nextStepIndex][j] += summandTerm;

                } //end of  for (Size j=0; j < numberRates_; ++j)

            // we've done the Vs now the vegas

                if (nextStepIndex >0)

                    for (Size l=0; l < numberBumps_; ++l)
                        for (Size j=0; j < numberRates_; ++j)
                            vegasThisPath_[i][l] +=  V_[i][nextStepIndex][j] * jacobiansThisPaths_[nextStepIndex-1][l][j];


            } // end of (Size i=0; i < numberProducts_; ++i)

} // end of  for (Integer currentStep =  numberSteps_-1; currentStep >=0 ; --currentStep)

// write answer into values

Size entriesPerProduct = 1+numberRates_+numberBumps_;

for (Size i=0; i < numberProducts_; ++i)
{
    values[i*entriesPerProduct] = numerairesHeld_[i]*initialNumeraireValue_;
    for (Size j=0; j < numberRates_; ++j)
        values[i*entriesPerProduct+1+j] = V_[i][0][j]*initialNumeraireValue_;
    for (Size k=0; k < numberBumps_; ++k)
        values[i*entriesPerProduct + numberRates_ +k +1 ] = vegasThisPath_[i][k]*initialNumeraireValue_;
}

for (Size i=0; i<numberOfPaths; ++i)
{
    /* Real weight = */ singlePathValues(values);
    // stats.add(values,weight);
    for (Size j=0; j < values.size(); ++j)
    {
        sums[j] += values[j];
        sumsqs[j] += values[j]*values[j];

    }
}

for (Size j=0; j < values.size(); ++j)
    {
        means[j] = sums[j]/numberOfPaths;
        Real meanSq = sumsqs[j]/numberOfPaths;
        Real variance = meanSq - means[j]*means[j];
        errors[j] = std::sqrt(variance/numberOfPaths);

    }

for (Size i =0; i < numberRates_; ++i)
      jacobiansThisPathsModel.push_back(Matrix(numberRates_,factors_));

for (Size i =0; i < numberSteps_; ++i)
{
      jacobianComputers_.push_back(RatePseudoRootJacobianAllElements(pseudoRootStructure_->pseudoRoot(i),evolution.firstAliveRate()[i],
                        numeraires_[i],
                        evolution.rateTaus(),
                        pseudoRootStructure_->displacements()));

      // vector of vector of matrices to store jacobians of rates with respect to pseudo-root elements
    jacobiansThisPaths_.push_back(jacobiansThisPathsModel);
}

for (Size i=0; i <= numberSteps_; ++i)
    Discounts_[i][0] = 1.0;

for (Size i=0; i<numberProducts_; ++i)
{
    cashFlowsGenerated_[i].resize(
        product_->maxNumberOfCashFlowsPerProductPerStep());

    for (Size j=0; j < cashFlowsGenerated_[i].size(); ++j)
        cashFlowsGenerated_[i][j].amount.resize(numberRates_+1);

    numberCashFlowsThisIndex_[i].resize(product_->possibleCashFlowTimes().size());

    V_.push_back(VModel);


    totalCashFlowsThisIndex_.push_back(modelCashFlowIndex);
}

for (Size j=0; j<cashFlowTimes.size(); ++j)
    discounters_.push_back(MarketModelPathwiseDiscounter(cashFlowTimes[j],
    rateTimes));

for (Size i=0; i < numberCashFlowTimes_; ++i)
{
    std::vector<Time>::const_iterator it = std::upper_bound( evolutionTimes.begin(), evolutionTimes.end(), cashFlowTimes[i]);
    if (it != evolutionTimes.begin())
        --it;
    Size index = it - evolutionTimes.begin();
    cashFlowIndicesThisStep_[index].push_back(i);
}

    for (Size i=0; i < numberProducts_; ++i)
    {  
        elementary_vegas_ThisPath_[i].resize(numberSteps_);
        for (Size j=0; j < numberSteps_; ++j)
        {
           
                elementary_vegas_ThisPath_[i][j]= modelVegaMatrix;
        }
    }

for (Size i=0; i < numberProducts_; ++i)
{
    numerairesHeld_[i]=0.0;

    for (Size j=0; j < numberCashFlowTimes_; ++j)
    {
        numberCashFlowsThisIndex_[i][j] =0;

        for (Size k=0; k <= numberRates_; ++k)
            totalCashFlowsThisIndex_[i][j][k] =0.0;
    }

    for (Size l=0;  l< numberRates_; ++l)
        for (Size m=0; m <= numberSteps_; ++m)
            V_[i][m][l] =0.0;

}

    for (unsigned long i=0; i < numberRates_; ++i)
    {
        Real x=  evolver_->currentState().discountRatio(i+1,i);
        stepsDiscounts_[i+1] = x;
        StepsDiscountsSquared_[storeStep][i] = x*x;

        LIBORRatios_[storeStep][i] = currentForwards_[i]/lastForwards_[i];
        LIBORRates_[storeStep][i] = currentForwards_[i];
        Discounts_[storeStep][i+1] = evolver_->currentState().discountRatio(i+1,0);
    }

    for (Size i=0; i<numberProducts_; ++i)
    {
        // ...and each cash flow...
        for (Size j=0; j<numberCashFlowsThisStep_[i]; ++j)
        {
            Size k = cashFlowsGenerated_[i][j].timeIndex;
            ++numberCashFlowsThisIndex_[i][ k];

            for (Size l=0; l <= numberRates_; ++l)
                totalCashFlowsThisIndex_[i][k][l] += cashFlowsGenerated_[i][j].amount[l]*weight;

        }
    }

for (Integer currentStep =  numberSteps_-1; currentStep >=0 ; --currentStep) // must be a signed type as we go negative
{
    Integer stepToUse = std::min<Integer>(currentStep, finalStepDone)+1;

    for (Size k=0; k < cashFlowIndicesThisStep_[currentStep].size(); ++k)
    {
        Size cashFlowIndex =cashFlowIndicesThisStep_[currentStep][k];

        // first check to see if anything actually happened before spending time on computing stuff
        bool noFlows = true;
        for (Size l=0; l < numberProducts_ && noFlows; ++l)
            noFlows = noFlows && (numberCashFlowsThisIndex_[l][cashFlowIndex] ==0);

        flowsFound = flowsFound || !noFlows;

        if (!noFlows)
        {
            if (doDeflation_)
                discounters_[cashFlowIndex].getFactors(LIBORRates_, Discounts_,stepToUse, deflatorAndDerivatives_); // get amount to discount cash flow by and amount to multiply its derivatives by

            for (Size j=0; j < numberProducts_; ++j)
            {
                if (numberCashFlowsThisIndex_[j][cashFlowIndex] > 0)
                {
                    Real deflatedCashFlow = totalCashFlowsThisIndex_[j][cashFlowIndex][0];
                    if (doDeflation_)
                        deflatedCashFlow *= deflatorAndDerivatives_[0];
                    //cashFlowsGenerated_[j][cashFlowIndex].amount[0]*deflatorAndDerivatives_[0];
                    numerairesHeld_[j] += deflatedCashFlow;

                    for (Size i=1; i <= numberRates_; ++i)
                    {
                        Real thisDerivative =  totalCashFlowsThisIndex_[j][cashFlowIndex][i];
                        if (doDeflation_)
                        {
                            thisDerivative *= deflatorAndDerivatives_[0];
                            thisDerivative +=  totalCashFlowsThisIndex_[j][cashFlowIndex][0]*deflatorAndDerivatives_[i];
                            fullDerivatives_[i-1] = thisDerivative;
                        }
                        else
                            fullDerivatives_[i-1] = thisDerivative;

                        V_[j][stepToUse][i-1] += thisDerivative; // zeroth row of V is t =0 not t_0
                    } // end of  for (Size i=1; i <= numberRates_; ++i)
                } // end of (numberCashFlowsThisIndex_[j][cashFlowIndex] > 0)
            } // end of (Size j=0; j < numberProducts_; ++j)
        } // end of  if (!noFlows)
    }

    // need to do backwards updating
    if (flowsFound)
    {
        Integer nextStepToUse  = std::min<Integer>(currentStep-1, finalStepDone);
        Integer nextStepIndex = nextStepToUse+1;
        if (nextStepIndex != stepToUse) // then we need to update V
        {

            const Matrix& thisPseudoRoot_= pseudoRootStructure_->pseudoRoot(currentStep);

            for (Size i=0; i < numberProducts_; ++i)
            {
                // compute partials
                for (Size f=0; f < factors; ++f)
                {
                    Real libor = LIBORRates_[stepToUse][numberRates_-1];
                    Real V = V_[i][stepToUse][numberRates_-1];
                    Real pseudo = thisPseudoRoot_[numberRates_-1][f];
                    Real thisPartialTerm = libor*V*pseudo;
                    partials_[f][numberRates_-1] = thisPartialTerm;

                    for (Integer r = numberRates_-2; r >=0 ; --r)
                    {
                        Real thisPartialTermr = LIBORRates_[stepToUse][r]*V_[i][stepToUse][r]*thisPseudoRoot_[r][f];

                        partials_[f][r] = partials_[f][r+1] + thisPartialTermr;

                    }
                } // end of (Size f=0; f < factors; ++f)

                for (Size j=0; j < numberRates_; ++j)
                {
                    Real nextV = V_[i][stepToUse][j] * LIBORRatios_[stepToUse][j];
                    V_[i][nextStepIndex][j] = nextV;

                    Real summandTerm = 0.0;
                    for (Size f=0; f < factors; ++f)
                        summandTerm += thisPseudoRoot_[j][f]*partials_[f][j];

                    summandTerm *= taus[j]*StepsDiscountsSquared_[stepToUse][j];

                    V_[i][nextStepIndex][j] += summandTerm;

                } //end of  for (Size j=0; j < numberRates_; ++j)

            } // end of (Size i=0; i < numberProducts_; ++i)

        } //  end of   if (nextStepIndex != stepToUse)

    } // end of  if (flowsFound)

} // end of  for (Integer currentStep =  numberSteps_-1; currentStep >=0 ; --currentStep)

for (Size i=0; i < numberProducts_; ++i)
{
        for (Size j=0; j < numberSteps_; ++j)
        {
            Size nextIndex = j+1;

            // we know V, we need to pair against the senstivity of the rate to the elementary vega
            // note the simplification here arising from the fact that the elementary vega affects the evolution on precisely one step

            for (Size k=0; k < numberRates_; ++k)
                for (Size f=0; f < factors_; ++f)
                {
                        Real sensitivity =0.0;

                        for (Size r=0; r < numberRates_; ++r)
                        {
                                sensitivity += V_[i][nextIndex][r]*jacobiansThisPaths_[j][r][k][f];

                          }
/*
                          if (j ==distinguishedStep_ && k ==distinguishedRate_ &&f== distinguishedFactor_)
                              std::cout << sensitivity << "," <<  jacobiansThisPaths_[j][j][k][f] << "," << gaussians_[j][f] << "," << V_[i][nextIndex][j] << "," << LIBORRates_[nextIndex][j] << "\n";
*/                


                        elementary_vegas_ThisPath_[i][j][k][f] = sensitivity;
                }
        }
}

for (Size i=0; i < numberProducts_; ++i)
{
    values[i*entriesPerProduct] = numerairesHeld_[i]*initialNumeraireValue_;
    for (Size j=0; j < numberRates_; ++j)
        values[i*entriesPerProduct+1+j] = V_[i][0][j]*initialNumeraireValue_;

    for (Size k=0; k < numberSteps_; ++k)
        for (Size l=0; l < numberRates_; ++l)
            for (Size m=0; m < factors_; ++m)
                values[i*entriesPerProduct + numberRates_ +1 + m+ l*factors_ + k*numberRates_*factors_] = elementary_vegas_ThisPath_[i][k][l][m]*initialNumeraireValue_;

}

for (Size i=0; i<numberOfPaths; ++i)
{
  singlePathValues(values);
  
  for (Size j=0; j < values.size(); ++j)
    {
        sums[j] += values[j];
        sumsqs[j] += values[j]*values[j];

    }
}

for (Size j=0; j < values.size(); ++j)
    {
        means[j] = sums[j]/numberOfPaths;
        Real meanSq = sumsqs[j]/numberOfPaths;
        Real variance = meanSq - means[j]*means[j];
        errors[j] = std::sqrt(variance/numberOfPaths);

    }

    for (Size p=0; p < numberProducts_; ++p)
    {
        for (Size i=0; i < 1 + numberRates_; ++i)
        {
              means[i+p*outDataPerProduct] = allMeans[i+p*inDataPerProduct];
              errors[i+p*outDataPerProduct] = allErrors[i+p*inDataPerProduct];
        }

       for (Size bump=0; bump<numberBumps_; ++bump)
        {
            Real thisVega=0.0;


            for (Size t=0; t < numberSteps_; ++t)
                for (Size r=0; r < numberRates_; ++r)
                    for (Size f=0; f < factors_; ++f)
                        thisVega+= vegaBumps_[t][bump][r][f]*allMeans[p*inDataPerProduct+1+numberRates_+t*numberRates_*factors_+r*factors_+f];


            means[p*outDataPerProduct+1+numberRates_+bump] = thisVega;
       }
            
    }

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/proxygreekengine.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i<numberProducts_; ++i)
    cashFlowsGenerated_[i].resize(
               product_->maxNumberOfCashFlowsPerProductPerStep());

for (Size j=0; j<n; ++j)
    discounters_.push_back(MarketModelDiscounter(cashFlowTimes[j],
                                                 rateTimes));

for (Size i=0; i<constrainedEvolvers_.size(); ++i) {
    for (Size j=0; j<constrainedEvolvers_[i].size(); ++j) {
        constrainedEvolvers_[i][j]->setThisConstraint(
                                    constraints_, constraintsActive_);
        singleEvolverValues(*(constrainedEvolvers_[i][j]),
                            modifiedValues[i][j]);
    }
}

for (Size i=0; i<modifiedValues.size(); ++i) {
    modifiedValues[i].resize(constrainedEvolvers_[i].size());
    for (Size j=0; j<modifiedValues[i].size(); ++j)
        modifiedValues[i][j].resize(N);
}

for (Size i=0; i<numberOfPaths; ++i) {
    singlePathValues(values, modifiedValues);
    stats.add(values);

    for (Size j=0; j<diffWeights_.size(); ++j) {
        for (Size k=0; k<diffWeights_[j].size(); ++k) {
            const std::vector<Real>& weights = diffWeights_[j][k];
            for (Size l=0; l<N; ++l) {
                results[l] = weights[0]*values[l];
                for (Size n=1; n<weights.size(); ++n)
                    results[l] += weights[n]*modifiedValues[j][n-1][l];
            }
            modifiedStats[j][k].add(results);
        }
    }
}

    for (Size i=0; i<numberProducts_; ++i) {
        // ...and each cash flow...
        const std::vector<MarketModelMultiProduct::CashFlow>& cashflows =
            cashFlowsGenerated_[i];
        for (Size j=0; j<numberCashFlowsThisStep_[i]; ++j) {
            // ...convert the cash flow to numeraires.
            // This is done by calculating the number of
            // numeraire bonds corresponding to such cash flow...
            const MarketModelDiscounter& discounter =
                discounters_[cashflows[j].timeIndex];

            Real bonds = cashflows[j].amount *
                discounter.numeraireBonds(evolver.currentState(),
                                          numeraire);

            // ...and adding the newly bought bonds to the number
            // of numeraires held.
            numerairesHeld_[i] +=
                weight*bonds/principalInNumerairePortfolio;
        }
    }

for (Size i=0; i<numerairesHeld_.size(); ++i)
    values[i] = numerairesHeld_[i] * initialNumeraireValue_;

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/swapforwardmappings.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=startIndex; i<endIndex; ++i)
    annuity += cs.rateTaus()[i]*cs.discountRatio(i+1, numeraireIndex);

for (Size k=0; k<n; ++k)
    a[k] = cs.discountRatio(k,n)-1.0;

for (Size i=0; i<n; ++i) {     // i = swap rate index
    for (Size j=i; j<n; ++j) { // j = forward rate index
        Real bi = cs.coterminalSwapAnnuity(n,i);
        Real bj = cs.coterminalSwapAnnuity(n,j);
        jacobian[i][j] =
            //   p[j+1]*tau[j]/b[i] +
            tau[j]/cs.coterminalSwapAnnuity(j+1,i) +
            // tau[j]/(1.0+f[j]*tau[j]) *
            tau[j]/(1.0+f[j]*tau[j]) *
            //    (-a[j]*b[i]+a[i]*b[j])/(b[i]*b[i]);
            (-a[j]*bi+a[i]*bj)/(bi*bi);

    }
}

    for (Size i=0; i<n; ++i)
        for (Size j=i; j<n; ++j)
            zMatrix[i][j] *= (f[j]+displacement)/(sr[i]+displacement);

for (Size i=0; i<n; ++i)      // i = swap rate index
    for (Size j=0; j<n; ++j)  // j = forward rate index
        jacobian[i][j] =swapDerivative(cs, 0, i+1, j);

for (Size i=0; i<n; ++i)      // i = swap rate index
    for (Size j=0; j<n; ++j)  // j = forward rate index
        jacobian[i][j] =swapDerivative(cs, i, std::min(n,i+spanningForwards), j);

for (Size i=0; i<n; ++i)
    sr[i] = cs.cmSwapRate(0,i+1);

for (Size i=0; i<n; ++i)
    for (Size j=i; j<n; ++j)
        zMatrix[i][j] *= (f[j]+displacement)/(sr[i]+displacement);

for (Size i=0; i<n; ++i)
    sr[i] = cs.cmSwapRate(i,spanningForwards);

for (Size i=0; i<n; ++i)
    for (Size j=i; j<n; ++j)
        zMatrix[i][j] *= (f[j]+displacement)/(sr[i]+displacement);

      for (Size f=0; f < factors; ++f)
      {
          Real sum=0.0;

          for (Size j=startIndex; j < endIndex;++j)
          {
              sum += cmsZed[startIndex][j]*thisPseudo[j][f];

          }
          thisVariance += sum*sum;

      }

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/historicalratesanalysis.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        for (Size i=0; i<nRates; ++i) {
            Rate fixing = indexes[i]->fixing(currentDate, false);
            sample[i] = fixing;
        }

        for (Size i=0; i<nRates; ++i)
            sampleDiff[i] = sample[i]/prevSample[i] -1.0;

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/accountingengine.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i<numberProducts_; ++i)
    cashFlowsGenerated_[i].resize(
               product_->maxNumberOfCashFlowsPerProductPerStep());

for (Size j=0; j<cashFlowTimes.size(); ++j)
    discounters_.push_back(MarketModelDiscounter(cashFlowTimes[j],
                                                 rateTimes));

    for (Size i=0; i<numberProducts_; ++i) {
        // ...and each cash flow...
        const std::vector<MarketModelMultiProduct::CashFlow>& cashflows =
            cashFlowsGenerated_[i];
        for (Size j=0; j<numberCashFlowsThisStep_[i]; ++j) {
            // ...convert the cash flow to numeraires.
            // This is done by calculating the number of
            // numeraire bonds corresponding to such cash flow...
            const MarketModelDiscounter& discounter =
                discounters_[cashflows[j].timeIndex];

            Real bonds = cashflows[j].amount *
                discounter.numeraireBonds(evolver_->currentState(),
                                          numeraire);

            // ...and adding the newly bought bonds to the number
            // of numeraires held.
            numerairesHeld_[i] += bonds/principalInNumerairePortfolio;
        }
    }

for (Size i=0; i<numerairesHeld_.size(); ++i)
    values[i] = numerairesHeld_[i] * initialNumeraireValue_;

for (Size i=0; i<numberOfPaths; ++i) {
    Real weight = singlePathValues(values);
    stats.add(values,weight);
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/evolutiondescription.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size j=0; j<numberOfSteps; ++j) {
    while (rateTimes_[firstAliveRate] <= currentEvolutionTime)
        ++firstAliveRate;
    firstAliveRate_[j] = firstAliveRate;
    currentEvolutionTime = evolutionTimes_[j];
}

for (Size i=0; i<n-1; i++)
    QL_REQUIRE(rateTimes[numeraires[i]] >= evolutionTimes[i],
               io::ordinal(i+1) << " step, evolution time " <<
               evolutionTimes[i] << ": the numeraire (" << numeraires[i] <<
               "), corresponding to rate time " <<
               rateTimes[numeraires[i]] << ", is expired");

for (Size i=0, j=0; i<evolutionTimes.size(); ++i) {
    while (rateTimes[j] < evolutionTimes[i])
        j++;
    res = (numeraires[i] == std::min(j+offset, maxNumeraire)) && res;
}

for (Size i=0, j=0; i<n; ++i) {
    while (rateTimes[j] < evolutionTimes[i])
        j++;
    numeraires[i] = std::min(j+offset, maxNumeraire);
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/curvestate.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=begin; i<end; ++i)
    sum += rateTaus_[i]*discountRatio(i+1, numberOfRates_);

for (Size i=firstValidIndex; i<fwds.size(); ++i)
    fwds[i] = (ds[i]-ds[i+1])/(ds[i+1]*taus[i]);

for (Size i=nCotSwapRates-1; i>firstValidIndex; --i) {
    cotSwapAnnuities[i-1] = cotSwapAnnuities[i] + taus[i-1] * discountFactors[i];
    cotSwapRates[i-1] = 
        (discountFactors[i-1]-discountFactors[nCotSwapRates])
        /cotSwapAnnuities[i-1];
}

for (Size i=firstValidIndex; i<lastIndex; ++i) {
    constMatSwapAnnuities[firstValidIndex]+= taus[i] * ds[i+1];
}

for (Size i=firstValidIndex+1; i<nConstMatSwapRates; ++i) {
    Size lastIndex = std::min(i+spanningForwards,nConstMatSwapRates);
    constMatSwapAnnuities[i] = constMatSwapAnnuities[i-1]
                               - taus[i-1] * ds[i];
    if (lastIndex!=oldLastIndex)
       constMatSwapAnnuities[i] += taus[lastIndex-1] * ds[lastIndex];
    constMatSwapRates[i] = (ds[i]-ds[lastIndex])
        /constMatSwapAnnuities[i];
    oldLastIndex = lastIndex;
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/pathwisediscounter.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i < numberRates_; ++i)
    taus_[i] = rateTimes[i+1] - rateTimes[i];

for (Size i=before_+1; i<numberRates_; ++i)
factors[i+1] =0.0;

for (Size i=0; i<before_; ++i)
    factors[i+1] = -preDF*taus_[i]*Discounts[currentStep][i+1]/Discounts[currentStep][i];

for (Size i=0; i<=before_; ++i)
factors[i+1] = -df*taus_[i]*Discounts[currentStep][i+1]/Discounts[currentStep][i];

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/browniangenerators/sobolbrowniangenerator.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    for (Size i=0; i<factors; ++i)
        for (Size j=0; j<steps; ++j)
            M[i][j] = counter++;

    for (Size j=0; j<steps; ++j)
        for (Size i=0; i<factors; ++i)
            M[i][j] = counter++;

for (Size i=0; i<factors_; ++i) {
    bridge_.transform(boost::make_permutation_iterator(
                                          sample.value.begin(),
                                          orderedIndices_[i].begin()),
                      boost::make_permutation_iterator(
                                          sample.value.begin(),
                                          orderedIndices_[i].end()),
                      bridgedVariates_[i].begin());
}

for (Size j=0; j < nPaths; ++j) {
    std::vector<Real> sample(steps_*factors_);
    for (Size k=0; k < dim; ++k) {
        sample[k] = variates[k][j];
    }
    for (Size i=0; i<factors_; ++i) {
        bridge_.transform(boost::make_permutation_iterator(
                                          sample.begin(),
                                          orderedIndices_[i].begin()),
                  boost::make_permutation_iterator(
                                          sample.begin(),
                                          orderedIndices_[i].end()),
                  retVal[i].begin()+j*steps_);
    }
}

for (Size i=0; i<factors_; ++i)
    output[i] = bridgedVariates_[i][lastStep_];

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/driftcomputation/lmmdriftcalculator.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i<taus.size(); ++i)
    oneOverTaus_[i] = 1.0/taus[i];

for (Size i=alive_; i<numberOfRates_; ++i) {
    downs_[i] = std::min(i+1, numeraire_);
    ups_[i]   = std::max(i+1, numeraire_);
}

for(i=alive_; i<numberOfRates_; ++i)
    tmp_[i] = (forwards[i]+displacements_[i]) /
              (oneOverTaus_[i]+forwards[i]);

for (i=alive_; i<numberOfRates_; ++i) {
    drifts[i] = std::inner_product(tmp_.begin()+downs_[i],
                                   tmp_.begin()+ups_[i],
                                   C_.row_begin(i)+downs_[i], 0.0);
    if (numeraire_>i+1)
        drifts[i] = -drifts[i];
}

for (Size i=alive_; i<numberOfRates_; ++i)
    tmp_[i] = (forwards[i]+displacements_[i]) /
        (oneOverTaus_[i]+forwards[i]);

for (Size r=0; r<numberOfFactors_; ++r)
    e_[r][std::max(0,static_cast<Integer>(numeraire_)-1)] = 0.0;

    for (Size r=0; r<numberOfFactors_; ++r) {
        e_[r][i] = e_[r][i+1] + tmp_[i+1] * pseudo_[i+1][r];
        drifts[i] -= e_[r][i]*pseudo_[i][r];
    }

for (Size i=numeraire_; i<numberOfRates_; ++i) {
    drifts[i] = 0.0;
    for (Size r=0; r<numberOfFactors_; ++r) {
        if (i==0)
            e_[r][i] = tmp_[i] * pseudo_[i][r];
        else
            e_[r][i] = e_[r][i-1] + tmp_[i] * pseudo_[i][r];
        drifts[i] += e_[r][i]*pseudo_[i][r];
    }
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/driftcomputation/lmmnormaldriftcalculator.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i<taus.size(); ++i)
    oneOverTaus_[i] = 1.0/taus[i];

for (Size i=alive_; i<numberOfRates_; ++i) {
    downs_[i] = std::min(i+1, numeraire_);
    ups_[i]   = std::max(i+1, numeraire_);
}

for(i=alive_; i<numberOfRates_; ++i)
    tmp_[i] = 1.0/(oneOverTaus_[i]+forwards[i]);

for (i=alive_; i<numberOfRates_; ++i) {
    drifts[i] = std::inner_product(tmp_.begin()+downs_[i],
                                   tmp_.begin()+ups_[i],
                                   C_.row_begin(i)+downs_[i], 0.0);
    if (numeraire_>i+1)
        drifts[i] = -drifts[i];
}

for (Size i=alive_; i<numberOfRates_; ++i)
    tmp_[i] = 1.0/(oneOverTaus_[i]+forwards[i]);

for (Size r=0; r<numberOfFactors_; ++r)
    e_[r][std::max(0,static_cast<Integer>(numeraire_)-1)] = 0.0;

    for (Size r=0; r<numberOfFactors_; ++r) {
        e_[r][i] = e_[r][i+1] + tmp_[i+1] * pseudo_[i+1][r];
        drifts[i] -= e_[r][i]*pseudo_[i][r];
    }

for (Size i=numeraire_; i<numberOfRates_; ++i) {
    drifts[i] = 0.0;
    for (Size r=0; r<numberOfFactors_; ++r) {
        if (i==0)
            e_[r][i] = tmp_[i] * pseudo_[i][r];
        else
            e_[r][i] = e_[r][i-1] + tmp_[i] * pseudo_[i][r];
        drifts[i] += e_[r][i]*pseudo_[i][r];
    }
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/driftcomputation/smmdriftcalculator.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i<taus.size(); ++i)
    oneOverTaus_[i] = 1.0/taus[i];

for (Size k=0; k<numberOfFactors_; ++k) {
        // taken care in the constructor
        // wkpj1_[k][numberOfRates_-1]= 0.0;
        // wkaj_[k][numberOfRates_-1] = 0.0;
    for (Integer j=numberOfRates_-2; j>=static_cast<Integer>(alive_)-1; --j) {
         // < W(k) | P(j+1)/P(n) > =
         // = SR(j+1) a(j+1,k) A(j+1) / P(n) + SR(j+1) < W(k) | A(j+1)/P(n) >
        Real annuity = cs.coterminalSwapAnnuity(numberOfRates_,j+1);
        wkpj_[k][j+1]= SR[j+1] *
                    ( pseudo_[j+1][k] * annuity +  wkaj_[k][j+1] )+
                    pseudo_[j+1][k]*displacements_[j+1]* annuity;

        if (j >=static_cast<Integer>(alive_))
            wkaj_[k][j] = wkpj_[k][j+1]*taus[j ]+wkaj_[k][j+1];
    }
  }

for (Size k=0; k<numberOfFactors_; ++k) {
    // compute < Wk, PN/pn>
    for (Size j=alive_; j<numberOfRates_; ++j)
    {
        wkajshifted_[k][j] = -wkaj_[k][j]/cs.coterminalSwapAnnuity(numberOfRates_,j)
                            + wkpj_[k][numeraire_]
                                        *numeraireRatio;
    }
}

for (Size j=alive_; j<numberOfRates_; ++j) {
    drifts[j] = 0.0;
    for (Size k=0; k<numberOfFactors_; ++k) {
        drifts[j] += wkajshifted_[k][j]*pseudo_[j][k];
    }
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/driftcomputation/cmsmmdriftcalculator.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i<taus.size(); ++i)
    oneOverTaus_[i] = 1.0/taus[i];

for (Size i=alive_; i<numberOfRates_; ++i) {
    downs_[i] = std::min(i+1, numeraire_);
    ups_[i]   = std::max(i+1, numeraire_);
}

for (Size k=0; k<PjPnWk_.rows(); ++k) {
    PjPnWk_[k][numberOfRates_]=0.0;
    wkaj_[k][numberOfRates_-1]=0.0;

    for (Integer j=static_cast<Integer>(numberOfRates_)-2;
         j>=static_cast<Integer>(alive_)-1; --j)
    {
        Real sr = cs.cmSwapRate(j+1,spanningFwds_);
        Integer endIndex =
            std::min<Integer>(j + static_cast<Integer>(spanningFwds_) + 1,
                     static_cast<Integer>(numberOfRates_));
        Real first = sr * wkaj_[k][j+1];
        Real second = cs.cmSwapAnnuity(numberOfRates_,j+1,spanningFwds_)
        * (sr+displacements_[j+1])
        *pseudo_[j+1][k];
        Real third = PjPnWk_[k][endIndex];
        PjPnWk_[k][j+1] = first
        + second
        + third;

        if (j>=static_cast<Integer>(alive_))
        {
            wkaj_[k][j] = wkaj_[k][j+1] + PjPnWk_[k][j+1]*taus[j];

            if (j+spanningFwds_+1 <= numberOfRates_)
                wkaj_[k][j] -= PjPnWk_[k][endIndex]*taus[endIndex-1];
        }

    }
}

for (Size j=alive_; j<numberOfRates_; ++j)
    for (Size k=0; k<numberOfFactors_; ++k)
        wkajN_[k][j] =  wkaj_[k][j]*PnOverPN
            -PjPnWk_[k][numeraire_]*PnOverPN*cs.cmSwapAnnuity(numeraire_,j,spanningFwds_);

for (Size j=alive_; j<numberOfRates_; ++j)
{
    drifts[j]=0.0;
    for (Size k=0; k<numberOfFactors_; ++k)
    {
        drifts[j] += pseudo_[j][k]*wkajN_[k][j];
    }
    drifts[j] /= -cs.cmSwapAnnuity(numeraire_,j,spanningFwds_);
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/curvestates/cmswapcurvestate.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=numberOfRates_-1; i>first_; --i)
{
    // formula 6.1 Joshi Liesch
    Integer endIndex = std::min(i + spanningFwds_,numberOfRates_);
    Integer annuityEndIndex = std::min(i + spanningFwds_-1,numberOfRates_);

    discRatios_[i] = discRatios_[endIndex] +
    cmSwapRates_[i]*cmSwapAnnuities_[i];
    cmSwapAnnuities_[i-1]= cmSwapAnnuities_[i]
    +discRatios_[i] * rateTaus_[i-1];

    if (annuityEndIndex < oldAnnuityEndIndex)
      cmSwapAnnuities_[i-1]-=discRatios_[oldAnnuityEndIndex] * rateTaus_[oldAnnuityEndIndex-1 ];

    oldAnnuityEndIndex = annuityEndIndex;
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/curvestates/lmmcurvestate.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=first_; i<numberOfRates_; ++i)
    discRatios_[i+1]=discRatios_[i]/(1.0+forwardRates_[i]*rateTaus_[i]);

for (Size i=first_; i<numberOfRates_; ++i)
    forwardRates_[i] = (discRatios_[i]/discRatios_[i+1]-1.0) /
                                                        rateTaus_[i];

for (int j= static_cast<int>(firstCotAnnuityComped_)-1; j >=static_cast<int>(i); --j)
    cotAnnuities_[j] = cotAnnuities_[j+1]+rateTaus_[j]*discRatios_[j+1];

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/curvestates/coterminalswapcurvestate.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=numberOfRates_-1; i>first_; --i) {
    discRatios_[i] = 1.0 + cotSwapRates_[i] * cotAnnuities_[i];
    cotAnnuities_[i-1] = cotAnnuities_[i] + rateTaus_[i-1] * discRatios_[i];
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/models/alphafinder.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Integer i=0; i < stepindex_+1; ++i) {
    Real vol1 = ratetwohomogeneousvols_[i]*(*parametricform_)(i);
    cov += vol1*rateonevols_[i]*correlations_[i];
}

for (Integer i=0; i < stepindex_+1; ++i) {
    Real vol = ratetwohomogeneousvols_[i]*(*parametricform_)(i);
    var+= vol*vol;
}

for (Size i=0; i<=static_cast<Size>(stepindex_)+1; ++i) {
Real val =  putativevols_[i]-ratetwohomogeneousvols_[i];
result +=val*val;
}

    for (Integer i =0; i < stepindex+1; ++i) {
        ratetwovols[i] = ratetwohomogeneousvols[i] *
                                    (*parametricform_)(i) * a;
        varSoFar += ratetwovols[i]* ratetwovols[i];
    }

for (Size i=0; i <=static_cast<Size>(stepindex)+1; ++i)
    totalVar_+=ratetwohomogeneousvols[i]*ratetwohomogeneousvols[i];

for (Integer i=0; i < stepindex+1; ++i)
        constantPart_+=rateonevols[i]*rateonevols[i];

for (Size i=0; i <=static_cast<Size>(stepindex)+1; ++i)
    totalVar_+=ratetwohomogeneousvols[i]*ratetwohomogeneousvols[i];

for (Integer i=0; i < stepindex+1; ++i)
    constantPart_+=rateonevols[i]*rateonevols[i];

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/models/fwdperiodadapter.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    for (Size k=0; k < numberOfRates_; ++k)
    {
        for (Size l=0; l < period; ++l, ++m)
            sum+= largeDisplacements_[m];

        displacements_.push_back(sum/period);
    }

for (Size i =0; i < oldEvolutionTimes.size() && oldEvolutionTimes[i]<= finalReset; ++i)
    newEvolutionTimes.push_back(oldEvolutionTimes[i]);

for (Size i=0; i < rateTimes.size()-1; ++i)
    QL_REQUIRE(setTimes.find(rateTimes[i]) != setTimes.end(),
                "every new rate time except last must be an evolution time in fwdperiod adapter");

for (Size k = 0; k<numberOfSteps_; ++k) {
    pseudoRoots_[k]=YMatrix*largeModel->pseudoRoot(k);
    for (Size i=0; i<alive[k]; ++i)
        std::fill(pseudoRoots_[k].row_begin(i),
                  pseudoRoots_[k].row_end(i),
                  0.0);
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/models/flatvol.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size k=0, kk=0; k<numberOfSteps_; ++k) {
    // one covariance per evolution step
    std::fill(covariance.begin(), covariance.end(), 0.0);

    // there might be more than one correlation matrix
    // in a single evolution step
    for (; corrTimes[kk]<evolTimes[k]; ++kk) {
        Time effStartTime = effStopTime;
        effStopTime = corrTimes[kk];
        const Matrix& corrMatrix = corr->correlation(kk);
        for (Size i=0; i<numberOfRates_; ++i) {
            for (Size j=i; j<numberOfRates_; ++j) {
                Real cov = flatVolCovariance(effStartTime, effStopTime,
                                             rateTimes[i], rateTimes[j],
                                             vols[i], vols[j]);
                covariance[i][j] += cov * corrMatrix[i][j];
             }
        }
    }
    // last part in the evolution step
    Time effStartTime = effStopTime;
    effStopTime = evolTimes[k];
    const Matrix& corrMatrix = corr->correlation(kk);
    for (Size i=0; i<numberOfRates_; ++i) {
        for (Size j=i; j<numberOfRates_; ++j) {
            Real cov = flatVolCovariance(effStartTime, effStopTime,
                                         rateTimes[i], rateTimes[j],
                                         vols[i], vols[j]);
            covariance[i][j] += cov * corrMatrix[i][j];
         }
    }
    // no more use for the kk-th correlation matrix
    while (kk<corrTimes.size() && corrTimes[kk]<=evolTimes[k])
        ++kk;

    // make it symmetric
    for (Size i=0; i<numberOfRates_; ++i) {
        for (Size j=i+1; j<numberOfRates_; ++j) {
             covariance[j][i] = covariance[i][j];
         }
    }

    pseudoRoots_[k] = rankReducedSqrt(covariance,
                                      numberOfFactors, 1.0,
                                      SalvagingAlgorithm::None);

    QL_ENSURE(pseudoRoots_[k].rows()==numberOfRates_,
              "step " << k
              << " flat vol wrong number of rows: "
              << pseudoRoots_[k].rows()
              << " instead of " << numberOfRates_);
    QL_ENSURE(pseudoRoots_[k].columns()==numberOfFactors,
              "step " << k
              << " flat vol wrong number of columns: "
              << pseudoRoots_[k].columns()
              << " instead of " << numberOfFactors_);
}

for (Size i=0; i<numberOfRates; ++i)
    initialRates[i] = yieldCurve_->forwardRate(rateTimes[i],
                                               rateTimes[i+1],
                                               Simple);

for (Size i=0; i<numberOfRates; ++i) {
    Volatility vol = // to be changes
        volatility_(rateTimes[i]);
    displacedVolatilities[i] =
        initialRates[i]*vol/(initialRates[i]+displacement_);
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/models/piecewiseconstantabcdvariance.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i<=resetIndex; ++i) {
    Time startTime = (i==0 ? 0.0 : rateTimes_[i-1]);
    variances_[i] = abcd.variance(startTime,
        rateTimes_[i],
        rateTimes_[resetIndex]);
    Time totTime = rateTimes_[i]-startTime;
    volatilities_[i] = std::sqrt(variances_[i]/totTime);
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/models/capletcoterminalmaxhomogeneity.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        for (; i<capletNumber+1; ++i) {
            previousSwapVariance += previousRateSolution[i] *
                previousRateSolution[i];
            thisSwapVariance += homogeneousSolution[i] *
                homogeneousSolution[i];
        }

    for (Size i=0; i<capletNumber+1; ++i) {
        b[i] = 2*w0*w1*correlations[i]*previousRateSolution[i]/theta;
        cylinderCentre[i] = -0.5*b[i];
        targetArray[i] = homogeneousSolution[i];
        targetArrayRestricted[i] = targetArray[i];
        bsq+=b[i]*b[i];
    }

    for (Size i=0; i<capletNumber+1; ++i) {
        Array ei(capletNumber+1,0.0);
        ei[i]=1.0;
        basis.addVector(ei);
    }

    for (Size k=0; k<capletNumber+1; ++k)
        for (Size l=0; l<capletNumber+1; ++l)
            orthTransformation[k][l]=orthTransformationRestricted[k][l];

        for (; i < arraySolution.size(); ++i)
            solution[i]=arraySolution[i];

        for (; i < solution.size(); ++i)
            solution[i]=0.0;

    for (Size i=0; i<corrPseudo.size(); ++i)
        corrPseudo[i] = rankReducedSqrt(corr.correlation(i),
        numberOfFactors, 1.0,
        SalvagingAlgorithm::None);

    for (Size i=0; i<numberOfRates-1; ++i) 
    {
        // final weight dont do anything when i < 2 
        Real thisFinalWeight = i  > 1 ? (i-1)/2.0 : 1.0;
        // we will calibrate caplet on forward rate i,
        // we will do this by modifying the vol of swap rate i+1
        const std::vector<Real>& var =
            displacedSwapVariances[i+1]->variances();

        for (Size j =0; j < i+2; ++j)
            secondRateVols[j] = std::sqrt(var[j]);

        for (Size k=0; k < i+1; k++) {
            Real correlation=0.0;
            for (Size l=0; l < numberOfFactors; ++l) {
                Real term1 = corrPseudo[k][i][l];
                Real term2 = corrPseudo[k][i+1][l];
                correlation += term1*term2;
            }
            correlations[k] = correlation;
        }

        Real w0 = invertedZedMatrix[i][i];
        Real w1 = invertedZedMatrix[i][i+1];
        // w0 adjustment
        for (Size k = i+2; k <invertedZedMatrix.columns(); ++k)
            w0+= invertedZedMatrix[i][k];

        Real targetCapletVariance= capletVols[i]*capletVols[i]*rateTimes[i];

        Real thisCapletError;
        Real thisSwaptionError;

        bool success = singleRateClosestPointFinder(
            i, secondRateVols, firstRateVols, targetCapletVariance, correlations,
            w0, w1, caplet0Swaption1Priority,maxIterations, tolerance,
            theseNewVols, thisFinalWeight ,thisSwaptionError, thisCapletError);

        totalSwaptionError+= thisSwaptionError*thisSwaptionError;

        if (!success)
            ++failures;

        for (Size j=0; j < i+2; ++j)
            deformationSize += (theseNewVols[i]-secondRateVols[i])*(theseNewVols[i]-secondRateVols[i]);

        newVols.push_back(theseNewVols);
        firstRateVols = theseNewVols;
    }

    for (Size k=0; k<numberOfSteps; ++k) {
        swapCovariancePseudoRoots[k] = corrPseudo[k];
        for (Size j=0; j<numberOfRates; ++j) {
            Real coeff =newVols[j][k];
            for (Size i=0; i<numberOfFactors; ++i)
                swapCovariancePseudoRoots[k][j][i]*=coeff;
        }
        QL_ENSURE(swapCovariancePseudoRoots[k].rows()==numberOfRates,
            "step " << k << " abcd vol wrong number of rows: " <<
            swapCovariancePseudoRoots[k].rows() <<
            " instead of " << numberOfRates);
        QL_ENSURE(swapCovariancePseudoRoots[k].columns()==numberOfFactors,
            "step " << k << " abcd vol wrong number of columns: " <<
            swapCovariancePseudoRoots[k].columns() <<
            " instead of " << numberOfFactors);
    }

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/models/volatilityinterpolationspecifierabcd.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i < noBigRates_; ++i)
    for (Size j=0; j < originalVariances[i].rateTimes().size(); ++j)
        QL_REQUIRE( originalVariances[i].rateTimes()[j] == timesForSmallRates[offset+j*period],"rate times in variances passed in don't match small times in VolatilityInterpolationSpecifierabcd");

for (Size i=0; i < noBigRates_; ++i)
    originalVariances_[i] = boost::shared_ptr<PiecewiseConstantVariance>(new PiecewiseConstantAbcdVariance(originalVariances[i]));

for (Size i=0; i < noBigRates_; ++i)
{
    Real a,b,c,d;
    originalABCDVariances_[i].getABCD(a,b,c,d);
    a*=scalingFactors_[i];
    b*=scalingFactors_[i];
    // c is not scaled
    d*=scalingFactors_[i];

    originalABCDVariancesScaled_[i] = PiecewiseConstantAbcdVariance(a,b,c,d, i, originalABCDVariances_[i].rateTimes());

}

    for (Size i=0; i < offset_; ++i)
        interpolatedVariances_[i] = boost::shared_ptr<PiecewiseConstantVariance>(
        new PiecewiseConstantAbcdVariance(a,b,c,d,i,timesForSmallRates_));

for (Size j=0; j < noBigRates_-1; ++j)
{
    Real a,b,c,d;
    Real a0,b0,c0,d0;
    Real a1,b1,c1,d1;
    originalABCDVariancesScaled_[j].getABCD(a0,b0,c0,d0);
    originalABCDVariancesScaled_[j+1].getABCD(a1,b1,c1,d1);
    a= 0.5*(a0+a1);
    b= 0.5*(b0+b1);
    c= 0.5*(c0+c1);
    d= 0.5*(d0+d1);

    for (Size i=0; i < period_; ++i)
        interpolatedVariances_[i+j*period_+offset_] =  boost::shared_ptr<PiecewiseConstantVariance>(
        new PiecewiseConstantAbcdVariance(a,b,c,d,i+j*period_,timesForSmallRates_));

}

    for (Size i=offset_+(noBigRates_-1)*period_; i < noSmallRates_; ++i)
        interpolatedVariances_[i] = boost::shared_ptr<PiecewiseConstantVariance>(
                                                                 new PiecewiseConstantAbcdVariance(a,b,c,d,i,timesForSmallRates_));

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/models/capletcoterminalswaptioncalibration.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i<corrPseudo.size(); ++i)
    corrPseudo[i] = rankReducedSqrt(corr.correlation(i),
                                    numberOfFactors, 1.0,
                                    SalvagingAlgorithm::None);

for (Size i=0; i<numberOfSteps; ++i) {
    Real s = (i==0 ? 0.0 : evolutionTimes[i-1]);
    for (Size j=i; j<numberOfRates; ++j) {
        const std::vector<Real>& var = displacedSwapVariances[j]->variances();
        originalVariances[j]+=var[i];
        swapTimeInhomogeneousVariances[i][j] = var[i]/
            ((1.0+alpha[j]*s)*(1.0+alpha[j]*s));
        modifiedVariances[j]+=swapTimeInhomogeneousVariances[i][j];
    }
}

for (Size i=0; i<numberOfSteps; ++i)
    for (Size j=i; j<numberOfRates; ++j)
        swapTimeInhomogeneousVariances[i][j] *= originalVariances[j]/
                                                modifiedVariances[j];

for (Size i=0; i<numberOfSteps; ++i) {
    CovarianceSwapPseudos[i] =  corrPseudo[i];
    for (Size j=0; j<numberOfRates; ++j)
        for (Size k=0; k < CovarianceSwapPseudos[i].columns();  ++k)
            CovarianceSwapPseudos[i][j][k] *=
                    std::sqrt(swapTimeInhomogeneousVariances[i][j]);

    CovarianceSwapMarginalCovs[i] = CovarianceSwapPseudos[i] *
                            transpose(CovarianceSwapPseudos[i]);

    CovarianceSwapCovs[i] = CovarianceSwapMarginalCovs[i];
    if (i>0)
        CovarianceSwapCovs[i]+= CovarianceSwapCovs[i-1];
}

for (Size i=0; i<numberOfRates; ++i) {
    for (Size jj=0; jj<=i; ++jj)
        totVariance[i] += displacedSwapVariances[i]->variances()[jj];
    Integer j;
    for (j=0; j<=static_cast<Integer>(i)-1; ++j)
        almostTotVariance[i] += swapTimeInhomogeneousVariances[j][i];
    for (j=0; j<=static_cast<Integer>(i)-2; ++j) {
        const Matrix& thisPseudo = corrPseudo[j];
        Real correlation = 0.0;
        for (Size k=0; k<numberOfFactors; ++k)
            correlation += thisPseudo[i-1][k]*thisPseudo[i][k];
        almostTotCovariance[i] += correlation *
            std::sqrt(swapTimeInhomogeneousVariances[j][i] *
            swapTimeInhomogeneousVariances[j][i-1]);
    }
    if (i>0) {
        const Matrix& thisPseudo = corrPseudo[j];
        Real correlation = 0.0;
        for (Size k=0; k<numberOfFactors; ++k)
            correlation += thisPseudo[i-1][k]*thisPseudo[i][k];
        leftCovariance[i] = correlation *
            std::sqrt(swapTimeInhomogeneousVariances[j][i] *
            swapTimeInhomogeneousVariances[j][i-1]);
    }
}

for (Size i=1; i<numberOfSteps; ++i) {
    Integer j=0;
    // up date variances to take account of last a and b computed
    for (; j <= static_cast<Integer>(i)-2; j++)
        swapTimeInhomogeneousVariances[j][i-1]*= a[i-1]*a[i-1];
    swapTimeInhomogeneousVariances[j][i-1]*= b[i-1]*b[i-1];

    Real w0 = invertedZedMatrix[i-1][i-1];
    Real w1 = -invertedZedMatrix[i-1][i];
    Real v1t1 = capletVols[i-1]*capletVols[i-1]*rateTimes[i-1];

    // now compute contribution from lower right corner
    Real extraConstantPart =0.0;
    // part of caplet approximation formula coming from later rates
    for (Size k = i+1; k < numberOfSteps; ++k)
        for (Size l = i+1; l < numberOfSteps; ++l)
            extraConstantPart+=invertedZedMatrix[i-1][k] *
                                 CovarianceSwapCovs[i-1][k][l] *
                                 invertedZedMatrix[i-1][l];

    // now compute contribution from top row excluding first two columns and its transpose
    // we divide into two parts as one part is multiplied by a[i-1] and the other by b[i-1]
    // a lot could be precomputed when we need to optimize
    for (Size k = i+1; k < numberOfSteps; ++k)
    {
        if (i > 1)
        {
            extraConstantPart+=invertedZedMatrix[i-1][i-1] *
                CovarianceSwapCovs[i-2][i-1][k] *
                invertedZedMatrix[i-1][k]*a[i-1];

            extraConstantPart+=invertedZedMatrix[i-1][k] *
                CovarianceSwapCovs[i-2][k][i-1] *
                invertedZedMatrix[i-1][i-1]*a[i-1];
        }

        extraConstantPart+=invertedZedMatrix[i-1][i-1] *
            CovarianceSwapMarginalCovs[i-1][i-1][k] *
            invertedZedMatrix[i-1][k]*b[i-1];

        extraConstantPart+=invertedZedMatrix[i-1][k] *
            CovarianceSwapCovs[i-1][k][i-1] *
            invertedZedMatrix[i-1][i-1]*b[i-1];

    }

    // we also get an extra linear part, this corresponds to row i, and columns j>i+1, and transpose
    Real extraLinearPart=0.0;
    for (Size k = i+1; k < numberOfSteps; ++k)
    {
            extraLinearPart+=invertedZedMatrix[i-1][k] *
                CovarianceSwapCovs[i-1][k][i] *
                invertedZedMatrix[i-1][i];

            extraLinearPart+=invertedZedMatrix[i-1][i] *
                CovarianceSwapCovs[i-1][i][k] *
                invertedZedMatrix[i-1][k];
    }



    Real constantPart = w0*w0*totVariance[i-1] +
                                            extraConstantPart*extraMultiplier-v1t1;
    Real linearPart = -2*w0*w1*(a[i-1]*almostTotCovariance[i] +
                                        b[i-1]*leftCovariance[i]) +extraLinearPart*extraMultiplier ;
    Real quadraticPart = w1*w1*almostTotVariance[i];
    Real disc = linearPart*linearPart-4.0*constantPart*quadraticPart;

    Real root, minimum = -linearPart/(2.0*quadraticPart);
    bool rightUsed = false;
    if (disc <0.0) {
        ++failures;
        // pick up the minimum vol for the caplet
        root = minimum;
    } else if (lowestRoot) {
        root = (-linearPart-std::sqrt(disc))/(2.0*quadraticPart);
    } else {
        if (minimum>1.0)
            root = (-linearPart-std::sqrt(disc))/(2.0*quadraticPart);
        else {
            rightUsed = true;
            root = (-linearPart+std::sqrt(disc))/(2.0*quadraticPart);
        }
    }

    Real varianceFound = root*root*almostTotVariance[i];
    Real varianceToFind = totVariance[i]-varianceFound;
    Real mult = varianceToFind/swapTimeInhomogeneousVariances[i][i];
    if (mult<=0.0 && rightUsed) {
        root = (-linearPart-std::sqrt(disc))/(2.0*quadraticPart);
        varianceFound = root*root*almostTotVariance[i];
        varianceToFind = totVariance[i]-varianceFound;
        mult = varianceToFind/swapTimeInhomogeneousVariances[i][i];
    }

    if (mult<0.0) // no solution...
    {
       ++failures;
       a[i]=root;
       b[i]=0.0;
    }
    else
    {
        a[i]=root;
        b[i]=std::sqrt(mult);
    }

    QL_ENSURE(root>=0.0,
              "negative root -- it should have not happened");

}

    for (; j <= static_cast<Integer>(i)-2; j++)
        swapTimeInhomogeneousVariances[j][i-1]*= a[i-1]*a[i-1];

for (Size k=0; k<numberOfSteps; ++k) {
    swapCovariancePseudoRoots[k] = corrPseudo[k];
    for (Size j=0; j<numberOfRates; ++j) {
        Real coeff = std::sqrt(swapTimeInhomogeneousVariances[k][j]);
         for (Size i=0; i<numberOfFactors; ++i)
            swapCovariancePseudoRoots[k][j][i]*=coeff;
    }
    QL_ENSURE(swapCovariancePseudoRoots[k].rows()==numberOfRates,
              "step " << k
              << " abcd vol wrong number of rows: "
              << swapCovariancePseudoRoots[k].rows()
              << " instead of " << numberOfRates);
    QL_ENSURE(swapCovariancePseudoRoots[k].columns()==numberOfFactors,
              "step " << k
              << " abcd vol wrong number of columns: "
              << swapCovariancePseudoRoots[k].columns()
              << " instead of " << numberOfFactors);
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/models/cotswaptofwdadapter.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i = 1; i<displacements.size(); ++i) {
    QL_REQUIRE(displacements[i]==displacements[0],
               io::ordinal(i+1) << " displacement (" <<
               displacements[i] << ") not equal to the previous ones"
               " (" << displacements[0] << ")");
}

for (Size k = 0; k<numberOfSteps_; ++k) {
    pseudoRoots_[k]=invertedZedMatrix*coterminalModel_->pseudoRoot(k);
    for (Size i=0; i<alive[k]; ++i)
        std::fill(pseudoRoots_[k].row_begin(i),
                  pseudoRoots_[k].row_end(i),
                  0.0);
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/models/fwdtocotswapadapter.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i = 1; i<displacements.size(); ++i) {
    QL_REQUIRE(displacements[i]==displacements[0],
               io::ordinal(i+1) << " displacement (" <<
               displacements[i] << ") not equal to the previous ones"
               " (" << displacements[0] << ")");
}

for (Size k = 0; k<numberOfSteps_; ++k) {
    pseudoRoots_[k]=zedMatrix*fwdModel_->pseudoRoot(k);
    for (Size i=0; i<alive[k]; ++i)
        std::fill(pseudoRoots_[k].row_begin(i),
                  pseudoRoots_[k].row_end(i),
                  0.0);
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/models/ctsmmcapletcalibration.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i<numberOfRates_; ++i)
    mktSwaptionVols_[i]=displacedSwapVariances_[i]->totalVolatility(i);

    for (Size i=0; i<numberOfRates_; ++i) {
        mdlSwaptionVols_[i] = std::sqrt(swaptionTotCovariance[i][i]/rateTimes[i]);
        Real swaptionError = std::fabs(mktSwaptionVols_[i]-mdlSwaptionVols_[i]);
        swaptionRmsError_ += swaptionError*swaptionError;
        swaptionMaxError_ = std::max(swaptionMaxError_, swaptionError);

        mdlCapletVols_[i] = std::sqrt(capletTotCovariance[i][i]/rateTimes[i]);
        Real capletError = std::fabs(mktCapletVols_[i]-mdlCapletVols_[i]);
        capletRmsError_ += capletError*capletError;
        capletMaxError_ = std::max(capletMaxError_, capletError);

        if (i < numberOfRates_-1)
            usedCapletVols_[i] *= mktCapletVols_[i]/mdlCapletVols_[i];
    }

 for (Size i=0; i<numberOfRates_; ++i)
     timeDependentCalibratedSwaptionVols_.push_back(
        ctsmm->timeDependentVolatility(i));

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/models/abcdvol.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size k=0, kk=0; k<numberOfSteps_; ++k) {
    // one covariance per evolution step
    std::fill(covariance.begin(), covariance.end(), 0.0);

    // there might be more than one correlation matrix
    // in a single evolution step,
    for (; corrTimes[kk]<evolTimes[k]; ++kk) {
        Time effStartTime = effStopTime;
        effStopTime = corrTimes[kk];
        const Matrix& corrMatrix = corr->correlation(kk);
        for (Size i=0; i<numberOfRates_; ++i) {
            for (Size j=i; j<numberOfRates_; ++j) {
                Real cov = ks[i]*ks[j]* abcd.covariance(effStartTime,
                                                        effStopTime,
                                                        rateTimes[i],
                                                        rateTimes[j]);
                covariance[i][j] += cov * corrMatrix[i][j];
            }
        }
    }
    // last part in the evolution step
    Time effStartTime = effStopTime;
    effStopTime = evolTimes[k];
    const Matrix& corrMatrix = corr->correlation(kk);
    for (Size i=0; i<numberOfRates_; ++i) {
        for (Size j=i; j<numberOfRates_; ++j) {
            Real cov = ks[i]*ks[j]* abcd.covariance(effStartTime,
                                                    effStopTime,
                                                    rateTimes[i],
                                                    rateTimes[j]);
            covariance[i][j] += cov * corrMatrix[i][j];
        }
    }
    // no more use for the kk-th correlation matrix
    while (kk<corrTimes.size() && corrTimes[kk]<=evolTimes[k])
        ++kk;

    // make it symmetric
    for (Size i=0; i<numberOfRates_; ++i) {
        for (Size j=i+1; j<numberOfRates_; ++j) {
             covariance[j][i] = covariance[i][j];
         }
    }

    pseudoRoots_[k] = rankReducedSqrt(covariance,
                                      numberOfFactors, 1.0,
                                      SalvagingAlgorithm::None);

    QL_ENSURE(pseudoRoots_[k].rows()==numberOfRates_,
              "step " << k
              << " abcd vol wrong number of rows: "
              << pseudoRoots_[k].rows()
              << " instead of " << numberOfRates_);
    QL_ENSURE(pseudoRoots_[k].columns()==numberOfFactors,
              "step " << k
              << " abcd vol wrong number of columns: "
              << pseudoRoots_[k].columns()
              << " instead of " << numberOfFactors);
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/models/capletcoterminalperiodic.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i < numberBigRates; ++i)
    scalingFactors[i] =1.0;

for (Size i=0; i < numberBigRates; ++i) {
    marketSwaptionVols[i] =
        displacedSwapVariances.originalVariances()[i]->totalVolatility(i);
}

    for (Size i=0; i < numberBigRates; ++i)
    {
        modelSwaptionVols[i] = std::sqrt(swaptionTotCovariance[i][i]/periodsmm->evolution().rateTimes()[i]);
        Real scale = marketSwaptionVols[i]/modelSwaptionVols[i];
        scalingFactors[i] *= scale; // since applied to vol

        totalSwaptionError +=  (marketSwaptionVols[i]-modelSwaptionVols[i])* (marketSwaptionVols[i]-modelSwaptionVols[i]);

    }

    for (Size i=0; i < numberBigRates; ++i)
        modelSwaptionVolsMatrix[iterationsDone][i] = modelSwaptionVols[i];

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/models/pseudorootfacade.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size k=0; k<numberOfSteps_; ++k) {
    QL_REQUIRE(covariancePseudoRoots_[k].rows()==numberOfRates_,
               "step " << k
               << ": pseudoRoot has wrong number of rows: "
               << covariancePseudoRoots_[k].rows()
               << " instead of " << numberOfRates_);
    // not really mandatory
    QL_REQUIRE(covariancePseudoRoots_[k].columns()==numberOfFactors_,
               "step " << k
               << ": pseudoRoot has wrong number of columns: "
               << covariancePseudoRoots_[k].columns()
               << " instead of " << numberOfFactors_);
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/models/capletcoterminalalphacalibration.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i<corrPseudo.size(); ++i)
    corrPseudo[i] = rankReducedSqrt(corr.correlation(i),
                                    numberOfFactors, 1.0,
                                    SalvagingAlgorithm::None);

for (Size i=0; i<numberOfRates-1; ++i) {
    // we will calibrate caplet on forward rate i,
    // we will do this by modifying the vol of swap rate i+1
    const std::vector<Real>& var =
                            displacedSwapVariances[i+1]->variances();
    for (Size j =0; j < i+2; ++j)
        secondRateVols[j] = std::sqrt(var[j]);

    for (Size k=0; k < i+1; k++) {
        Real correlation=0.0;
        for (Size l=0; l < numberOfFactors; ++l) {
            Real term1 = corrPseudo[k][i][l];
            Real term2 = corrPseudo[k][i+1][l];
            correlation += term1*term2;
        }
        correlations[k] = correlation;
    }

    Real w0 = invertedZedMatrix[i][i];
    Real w1 = invertedZedMatrix[i][i+1];
    // w0 adjustment
    for (Size k = i+2; k <invertedZedMatrix.columns(); ++k)
        w0+= invertedZedMatrix[i][k];

    Real targetVariance= capletVols[i]*capletVols[i]*rateTimes[i];

    bool success;
    if (maximizeHomogeneity)
        success = solver.solveWithMaxHomogeneity(
                                            alphaInitial[i+1] ,
                                            i,
                                            firstRateVols,
                                            secondRateVols,
                                            correlations,
                                            w0,
                                            w1,
                                            targetVariance,
                                            tolerance,
                                            alphaMax[i+1],
                                            alphaMin[i+1],
                                            maxIterations,
                                            alpha[i+1],
                                            a[i+1],
                                            b[i+1],
                                            theseNewVols);
    else
        success = solver.solve(alphaInitial[i+1] ,
                               i,
                               firstRateVols,
                               secondRateVols,
                               correlations,
                               w0,
                               w1,
                               targetVariance,
                               tolerance,
                               alphaMax[i+1],
                               alphaMin[i+1],
                               maxIterations,
                               alpha[i+1],
                               a[i+1],
                               b[i+1],
                               theseNewVols);

    if (!success) {
        //++failures;
        QL_FAIL("alpha form failure");
    }

    newVols.push_back(theseNewVols);
    firstRateVols = theseNewVols;
}

for (Size k=0; k<numberOfSteps; ++k) {
    swapCovariancePseudoRoots[k] = corrPseudo[k];
    for (Size j=0; j<numberOfRates; ++j) {
        Real coeff =newVols[j][k];
        for (Size i=0; i<numberOfFactors; ++i)
            swapCovariancePseudoRoots[k][j][i]*=coeff;
    }
    QL_ENSURE(swapCovariancePseudoRoots[k].rows()==numberOfRates,
        "step " << k
        << " abcd vol wrong number of rows: "
        << swapCovariancePseudoRoots[k].rows()
        << " instead of " << numberOfRates);
    QL_ENSURE(swapCovariancePseudoRoots[k].columns()==numberOfFactors,
        "step " << k
        << " abcd vol wrong number of columns: "
        << swapCovariancePseudoRoots[k].columns()
        << " instead of " << numberOfFactors);
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/evolvers/lognormalfwdrateeuler.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size j=0; j<steps; ++j) {
    const Matrix& A = marketModel_->pseudoRoot(j);
    calculators_.push_back(LMMDriftCalculator(A,
                                           displacements_,
                                           marketModel->evolution().rateTaus(),
                                           numeraires[j],
                                           alive_[j]));
    std::vector<Real> fixed(numberOfRates_);
    for (Size k=0; k<numberOfRates_; ++k) {
        Real variance =
            std::inner_product(A.row_begin(k), A.row_end(k),
                               A.row_begin(k), 0.0);
        fixed[k] = -0.5*variance;
    }
    fixedDrifts_.push_back(fixed);
}

for (Size i=0; i<numberOfRates_; ++i)
    initialLogForwards_[i] = std::log(forwards[i] +
                                      displacements_[i]);

for (Size i=alive; i<numberOfRates_; i++) {
    logForwards_[i] += drifts1_[i] + fixedDrift[i];
    logForwards_[i] +=
        std::inner_product(A.row_begin(i), A.row_end(i),
                           brownians_.begin(), 0.0);
    forwards_[i] = std::exp(logForwards_[i]) - displacements_[i];
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/evolvers/lognormalfwdrateipc.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size j=0; j<steps; ++j) {
    const Matrix& A = marketModel->pseudoRoot(j);
    calculators_.push_back(LMMDriftCalculator(A,
                                           displacements_,
                                           marketModel->evolution().rateTaus(),
                                           numeraires[j],
                                           alive_[j]));
    const Matrix& C = marketModel->covariance(j);
    std::vector<Real> fixed(numberOfRates_);
    for (Size k=0; k<numberOfRates_; ++k) {
        Real variance = C[k][k];
        fixed[k] = -0.5*variance;
    }
    fixedDrifts_.push_back(fixed);
}

for (Size i=0; i<numberOfRates_; ++i)
    initialLogForwards_[i] = std::log(forwards[i] +
                                      displacements_[i]);

for (Integer i=numberOfRates_-1; i>=alive; --i) {
    drifts2 = 0.0;
    for (Size j=i+1; j<numberOfRates_; ++j) {
        drifts2 -= g_[j]*C[i][j];
    }
    logForwards_[i] += 0.5*(drifts1_[i]+drifts2) + fixedDrift[i];
    logForwards_[i] +=
        std::inner_product(A.row_begin(i), A.row_end(i),
                           brownians_.begin(), 0.0);
    forwards_[i] = std::exp(logForwards_[i]) - displacements_[i];
    g_[i] = rateTaus_[i]*(forwards_[i]+displacements_[i])/
        (1.0+rateTaus_[i]*forwards_[i]);
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/evolvers/lognormalfwdrateeulerconstrained.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size j=0; j<steps; ++j) {
    const Matrix& A = marketModel_->pseudoRoot(j);
    calculators_.push_back(LMMDriftCalculator(A,
        displacements_,
        marketModel->evolution().rateTaus(),
        numeraires[j],
        alive_[j]));
    std::vector<Real> fixed(numberOfRates_);
    std::vector<Real> variances(numberOfRates_);
    for (Size k=0; k<numberOfRates_; ++k) {
        Real variance =
            std::inner_product(A.row_begin(k), A.row_end(k),
            A.row_begin(k), 0.0);
        variances[k] = variance;
        fixed[k] = -0.5*variance;
    }
    variances_.push_back(variances);
    fixedDrifts_.push_back(fixed);
}

for (Size i=0; i<numberOfRates_; ++i)
    initialLogForwards_[i] = std::log(forwards[i] +
                                      displacements_[i]);

for (Size i=0; i < startIndexOfSwapRate_.size(); ++i) {
    QL_REQUIRE(startIndexOfSwapRate_[i]+1 == endIndexOfSwapRate_[i],
        "constrained euler currently only implemented for forward rates");

    const Matrix& A = marketModel_->pseudoRoot(currentStep_);

    for (Size j=0; j < numberOfRates_; ++j) {
        Real cov=0.0;
        for (Size k=0; k < numberOfFactors_; ++k)
            cov += A[startIndexOfSwapRate_[i]][k]*A[j][k];
        covariances[j] = cov;

    }
    covariances_.push_back(covariances);
}

for (unsigned long i=0; i < rateConstraints_.size(); i++)
    rateConstraints_[i] = std::log(rateConstraints_[i]+displacements_[i]);

for (Size i=alive; i<numberOfRates_; i++) {
    logForwards_[i] += drifts1_[i] + fixedDrift[i];
    logForwards_[i] +=
        std::inner_product(A.row_begin(i), A.row_end(i),
        brownians_.begin(), 0.0);
}

    for (Size i=alive; i<numberOfRates_; i++) {
        // we only need a small part of cov matrix
        logForwards_[i] += multiplier*covariances_[currentStep_][i];
    }

    for (Size k=0; k < numberOfFactors_; k++) {
        Real shift = multiplier * A[index][k];
        Real originalDensity = phi.derivative(brownians_[k]+shift);
        // the density of the draw after changes in original measure
        Real newDensity = phi.derivative(brownians_[k]);
        // the density of the draw after changes in new measure, shifts cancel
        weightsEffect*= originalDensity/newDensity;
    }

for (Size i=alive; i<numberOfRates_; i++)
    forwards_[i] = std::exp(logForwards_[i]) - displacements_[i];

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/evolvers/lognormalcmswapratepc.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size j=0; j<steps; ++j) {
    const Matrix& A = marketModel_->pseudoRoot(j);
    calculators_.push_back(CMSMMDriftCalculator(A,
                                                displacements_,
                                                marketModel->evolution().rateTaus(),
                                                numeraires[j],
                                                alive_[j],
                                                spanningForwards));
    std::vector<Real> fixed(numberOfRates_);
    for (Size k=0; k<numberOfRates_; ++k) {
        Real variance =
            std::inner_product(A.row_begin(k), A.row_end(k),
                               A.row_begin(k), 0.0);
        fixed[k] = -0.5*variance;
    }
    fixedDrifts_.push_back(fixed);
}

for (Size i=0; i<numberOfRates_; ++i)
    initialLogSwapRates_[i] = std::log(swapRates[i] +
                                       displacements_[i]);

for (i=alive; i<numberOfRates_; ++i) {
    logSwapRates_[i] += drifts1_[i] + fixedDrift[i];
    logSwapRates_[i] +=
        std::inner_product(A.row_begin(i), A.row_end(i),
                           brownians_.begin(), 0.0);
    swapRates_[i] = std::exp(logSwapRates_[i]) - displacements_[i];
}

for (i=alive; i<numberOfRates_; ++i) {
    logSwapRates_[i] += (drifts2_[i]-drifts1_[i])/2.0;
    swapRates_[i] = std::exp(logSwapRates_[i]) - displacements_[i];
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/evolvers/lognormalfwdrateiballand.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size j=0; j<steps; ++j) {
    const Matrix& A = marketModel->pseudoRoot(j);
    calculators_.push_back(LMMDriftCalculator(A,
                                           displacements_,
                                           marketModel->evolution().rateTaus(),
                                           numeraires[j],
                                           alive_[j]));
    const Matrix& C = marketModel->covariance(j);
    std::vector<Real> fixed(numberOfRates_);
    for (Size k=0; k<numberOfRates_; ++k) {
        Real variance = C[k][k];
        fixed[k] = -0.5*variance;
    }
    fixedDrifts_.push_back(fixed);
}

for (Size i=0; i<numberOfRates_; ++i)
    initialLogForwards_[i] = std::log(forwards[i] +
                                      displacements_[i]);

for ( i = numberOfRates_-2; i >= alive ; --i )
{
    drifts2 = 0.0;
    for ( Size j = i+1; j < numberOfRates_ ; ++j )
        drifts2 -= g_[j]*C[i][j];
    logForwards_[i] += drifts2 + fixedDrift[i];
    logForwards_[i] += std::inner_product( A.row_begin(i), A.row_end(i),
                                           brownians_.begin(), 0.0);
    forwards_[i] = std::exp(logForwards_[i]) - displacements_[i];

    blFwd = std::sqrt( marketModel_->initialRates()[i]*forwards_[i] );
    g_[i] = rateTaus_[i]*( blFwd+displacements_[i] )/
            ( 1.0+rateTaus_[i]*blFwd );
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/evolvers/lognormalfwdratepc.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size j=0; j<steps; ++j) {
    const Matrix& A = marketModel_->pseudoRoot(j);
    calculators_.push_back(
        LMMDriftCalculator(A,
                           displacements_,
                           marketModel->evolution().rateTaus(),
                           numeraires[j],
                           alive_[j]));
    std::vector<Real> fixed(numberOfRates_);
    for (Size k=0; k<numberOfRates_; ++k) {
        Real variance =
            std::inner_product(A.row_begin(k), A.row_end(k),
                               A.row_begin(k), 0.0);
        fixed[k] = -0.5*variance;
    }
    fixedDrifts_.push_back(fixed);
}

for (Size i=0; i<numberOfRates_; ++i)
     initialLogForwards_[i] = std::log(forwards[i] +
                                       displacements_[i]);

for (i=alive; i<numberOfRates_; ++i) {
    logForwards_[i] += drifts1_[i] + fixedDrift[i];
    logForwards_[i] +=
        std::inner_product(A.row_begin(i), A.row_end(i),
                           brownians_.begin(), 0.0);
    forwards_[i] = std::exp(logForwards_[i]) - displacements_[i];
}

for (i=alive; i<numberOfRates_; ++i) {
    logForwards_[i] += (drifts2_[i]-drifts1_[i])/2.0;
    forwards_[i] = std::exp(logForwards_[i]) - displacements_[i];
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/evolvers/lognormalcotswapratepc.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size j=0; j<steps; ++j) {
    const Matrix& A = marketModel_->pseudoRoot(j);
    calculators_.push_back(SMMDriftCalculator(A,
                                              displacements_,
                                              marketModel->evolution().rateTaus(),
                                              numeraires[j],
                                              alive_[j]));
    std::vector<Real> fixed(numberOfRates_);
    for (Size k=0; k<numberOfRates_; ++k) {
        Real variance =
            std::inner_product(A.row_begin(k), A.row_end(k),
                               A.row_begin(k), 0.0);
        fixed[k] = -0.5*variance;
    }
    fixedDrifts_.push_back(fixed);
}

for (Size i=0; i<numberOfRates_; ++i)
    initialLogSwapRates_[i] = std::log(swapRates[i] +
                                       displacements_[i]);

for (i=alive; i<numberOfRates_; ++i) {
    logSwapRates_[i] += drifts1_[i] + fixedDrift[i];
    logSwapRates_[i] +=
        std::inner_product(A.row_begin(i), A.row_end(i),
                           brownians_.begin(), 0.0);
    swapRates_[i] = std::exp(logSwapRates_[i]) - displacements_[i];
}

for (i=alive; i<numberOfRates_; ++i) {
    logSwapRates_[i] += (drifts2_[i]-drifts1_[i])/2.0;
    swapRates_[i] = std::exp(logSwapRates_[i]) - displacements_[i];
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/evolvers/normalfwdratepc.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size j=0; j<steps; ++j) {
    const Matrix& A = marketModel_->pseudoRoot(j);
    calculators_.push_back(
        LMMNormalDriftCalculator(A,
                                 marketModel->evolution().rateTaus(),
                                 numeraires[j],
                                 alive_[j]));
    /*
    for (Size k=0; k<numberOfRates_; ++k) {
        Real variance =
            std::inner_product(A.row_begin(k), A.row_end(k),
                               A.row_begin(k), 0.0);
    }
    */
}

for (Size i=0; i<numberOfRates_; ++i)
calculators_[initialStep_].compute(forwards, initialDrifts_);

for (i=alive; i<numberOfRates_; ++i) {
    forwards_[i] += drifts1_[i] ;
    forwards_[i] +=
        std::inner_product(A.row_begin(i), A.row_end(i),
                           brownians_.begin(), 0.0);
}

for (i=alive; i<numberOfRates_; ++i) {
    forwards_[i] += (drifts2_[i]-drifts1_[i])/2.0;
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/evolvers/lognormalfwdrateballand.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size j=0; j<steps; ++j) {
    const Matrix& A = marketModel->pseudoRoot(j);
    calculators_.push_back(LMMDriftCalculator(A,
                                           displacements_,
                                           marketModel->evolution().rateTaus(),
                                           numeraires[j],
                                           alive_[j]));
    const Matrix& C = marketModel->covariance(j);
    std::vector<Real> fixed(numberOfRates_);
    for (Size k=0; k<numberOfRates_; ++k) {
        Real variance = C[k][k];
        fixed[k] = -0.5*variance;
    }
    fixedDrifts_.push_back(fixed);
}

for (Size i=0; i<numberOfRates_; ++i)
    initialLogForwards_[i] = std::log(forwards[i] +
                                      displacements_[i]);

for ( i = alive; i < numberOfRates_ ; ++i )
{
    logForwards_[i] += drifts1_[i] + fixedDrift[i];
    logForwards_[i] += std::inner_product(A.row_begin(i), A.row_end(i),
                                          brownians_.begin(), 0.0);
    forwards_[i] = std::exp(logForwards_[i]) - displacements_[i];
}

for ( i = alive; i < numberOfRates_ ; ++i )
{
    forwards_[i] = std::sqrt( forwards_[i]*(marketModel_->initialRates()[i]) );
}

for ( i = alive; i < numberOfRates_ ; ++i )
{
    logForwards_[i] += drifts2_[i] - drifts1_[i];
    forwards_[i] = std::exp(logForwards_[i]) - displacements_[i];
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/evolvers/svddfwdratepc.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size j=0; j<steps; ++j) 
{
    const Matrix& A = marketModel_->pseudoRoot(j);
    calculators_.push_back(
        LMMDriftCalculator(A,
                           displacements_,
                           marketModel->evolution().rateTaus(),
                           numeraires[j],
                           alive_[j]));
    std::vector<Real> fixed(numberOfRates_);
    for (Size k=0; k<numberOfRates_; ++k) 
    {
        Real variance =
            std::inner_product(A.row_begin(k), A.row_end(k),
                               A.row_begin(k), 0.0);
        fixed[k] = -0.5*variance;
    }
    fixedDrifts_.push_back(fixed);
}

for (Size i=0; i < volFactorsPerStep_; ++i)
    isVolVariate_[firstVolatilityFactor_+i*volIncrement] = true;

for (Size i=0; i<numberOfRates_; ++i)
     initialLogForwards_[i] = std::log(forwards[i] +
                                       displacements_[i]);

for (Size i=0, j=0, k=0; i < allBrownians_.size(); ++i)
    if ( isVolVariate_[i])
    {
        volBrownians_[j] = allBrownians_[i];
        ++j;
    }

for (Size i=alive; i<numberOfRates_; ++i) {
    logForwards_[i] += varianceMultiplier*(drifts1_[i] + fixedDrift[i]);
    logForwards_[i] += sdMultiplier*
        std::inner_product(A.row_begin(i), A.row_end(i),
                           brownians_.begin(), 0.0);
    forwards_[i] = std::exp(logForwards_[i]) - displacements_[i];
}

for (Size i=alive; i<numberOfRates_; ++i) {
    logForwards_[i] += varianceMultiplier*(drifts2_[i]-drifts1_[i])/2.0;
    forwards_[i] = std::exp(logForwards_[i]) - displacements_[i];
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/evolvers/volprocesses/squarerootandersen.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (; j < numberSubSteps_; ++j)
    dt_[j] = evolutionTimes[0]/numberSubSteps_;

for (Size i=1; i < evolutionTimes.size(); ++i)
{
    Real dt = (evolutionTimes[i] - evolutionTimes[i-1])/numberSubSteps_;

    Real ekdt = std::exp(-k_*dt);
    QL_REQUIRE(dt >0.0, "Steps must be of positive size.");

    for (Size k=0; k < numberSubSteps_; ++k)
    {
        dt_[j] = dt;
        eMinuskDt_[j] = ekdt;

        ++j;
    }
}

for (Size j=0; j < numberSubSteps_; ++j)
{
    DoOneSubStep(v_, variates[j], subStep_);
    ++subStep_;
    vPath_[subStep_] = v_;
}

for (Size k=0; k < numberSubSteps_; ++k)
    stepVariance += w1_*vPath_[k+lastStepStart]+w2_*vPath_[k+lastStepStart+1];

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/correlations/cotswapfromfwdcorrelation.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size k = 0; k<fwdCorrMatrices.size(); ++k) {
    swapCorrMatrices_[k] = CovarianceDecomposition(
        zed * fwdCorrMatrices[k] * zedT).correlationMatrix();
    // zero expired rates' correlation coefficients
    const std::vector<Time>& rateTimes = curveState.rateTimes();
    const std::vector<Time>& corrTimes = fwdCorr_->times();
    for (Size i=0; i<numberOfRates_; ++i)
        for (Size j=0; j<=i; ++j)
            if (corrTimes[k]>rateTimes[j])
                swapCorrMatrices_[k][i][j] =
                    swapCorrMatrices_[k][j][i] = 0.0;
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/correlations/expcorrelations.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i<nbRows; ++i) {
    // correlation is defined only between
    // (alive) stochastic rates...
    if (time<=rateTimes[i]) {
        correlations[i][i] = 1.0;
        for (Size j=0; j<i; ++j) {
            if (time<=rateTimes[j]) {
                correlations[i][j] = correlations[j][i] =
                    longTermCorr + (1.0-longTermCorr) *
                    std::exp(-beta*std::fabs(
                        std::pow(rateTimes[i]-time, gamma) -
                        std::pow(rateTimes[j]-time, gamma)
                        )
                    );
            }
        }
    }
}

    for (Size k=1; k<times_.size(); ++k) {
        time = (times_[k]+times_[k-1])/2.0;
        correlations_[k] = exponentialCorrelations(
            rateTimes_, longTermCorr_, beta_, gamma_, time);
    }

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/correlations/timehomogeneousforwardcorrelation.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size k=0; k<correlations.size(); ++k) {
    // proper diagonal values
    for (Size i=k; i<numberOfRates; ++i)
        correlations[k][i][i] = 1.0;
    // copy only time homogeneous values
    for (Size i=k; i<numberOfRates; ++i) {
        for (Size j=k; j<i; ++j) {
            correlations[k][i][j] = correlations[k][j][i] =
                fwdCorrelation[i-k][j-k];
        }
    }
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/callability/parametricexerciseadapter.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i<evolutionTimes.size(); ++i) {
    if (isExerciseTime_[i])
        exerciseTimes_.push_back(evolutionTimes[i]);
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/callability/lsstrategy.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (i=0; i<relevantTimes_.size(); ++i) {
    exerciseIndex_[i] = exercises;
    if (isRebateTime_[i]) {
        isExerciseTime_[i] = v[idx++];
        if (isExerciseTime_[i]) {
            exerciseTimes_.push_back(relevantTimes_[i]);
            ++exercises;
        }
    }
}

for (i=0; i<rebateTimes.size(); ++i)
    rebateDiscounters_.push_back(
                 MarketModelDiscounter(rebateTimes[i], rateTimes));

for (i=0; i<controlTimes.size(); ++i)
    controlDiscounters_.push_back(
                 MarketModelDiscounter(controlTimes[i], rateTimes));

for (i=0; i<basisValues_.size(); ++i)
    basisValues_[i].resize(basisSizes[i]);

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/callability/swapratetrigger.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i<exerciseTimes.size(); ++i) {
    while (j < rateTimes.size() && rateTimes[j] < exerciseTimes[i])
        ++j;
    rateIndex_[i] = j;
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/callability/triggeredswapexercise.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i<exerciseTimes.size(); ++i) {
    while (j < rateTimes.size() && rateTimes[j] < exerciseTimes[i])
        ++j;
    rateIndex_[i] = j;
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/callability/collectnodedata.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (i=0; i<n; ++i)
    productDiscounters.push_back(
                             MarketModelDiscounter(cashFlowTimes[i],
                                                   rateTimes));

for (i=0; i<n; ++i)
    rebateDiscounters.push_back(
                             MarketModelDiscounter(rebateTimes[i],
                                                   rateTimes));

for (i=0; i<n; ++i)
    controlDiscounters.push_back(
                             MarketModelDiscounter(controlTimes[i],
                                                   rateTimes));

for (i=0; i<evolutionTimes.size(); ++i) {
    if (isRebateTime[i]) {
        if(v[idx++]) {
            isExerciseTime[i] = true;
            exercises++;
        }
    }
}

for (i=0; i<collectedData.size(); ++i)
    collectedData[i].resize(numberOfPaths);

for (i=0; i<numberOfPaths; ++i) {
    evolver.startNewPath();
    product.reset();
    rebate.reset();
    control.reset();
    dataProvider.reset();
    Real principalInNumerairePortfolio = 1.0;

    bool done = false;
    Size nextExercise = 0;
    collectedData[0][i].cumulatedCashFlows = 0.0;
    do {
        Size currentStep = evolver.currentStep();
        evolver.advanceStep();
        const CurveState& currentState = evolver.currentState();
        Size numeraire = numeraires[currentStep];

        if (isRebateTime[currentStep])
            rebate.nextStep(currentState);
        if (isControlTime[currentStep])
            control.nextStep(currentState);
        if (isBasisTime[currentStep])
            dataProvider.nextStep(currentState);

        if (isExerciseTime[currentStep]) {
            NodeData& data = collectedData[nextExercise+1][i];

            CashFlow exerciseValue = rebate.value(currentState);
            data.exerciseValue =
                exerciseValue.amount *
                rebateDiscounters[exerciseValue.timeIndex]
                   .numeraireBonds(currentState, numeraire) /
                principalInNumerairePortfolio;

            dataProvider.values(currentState,
                                data.values);

            CashFlow controlValue = control.value(currentState);
            data.controlValue =
                controlValue.amount *
                controlDiscounters[controlValue.timeIndex]
                   .numeraireBonds(currentState, numeraire) /
                principalInNumerairePortfolio;

            data.cumulatedCashFlows = 0.0;

            data.isValid = true;

            ++nextExercise;
        }

        if (isProductTime[currentStep]) {
            done = product.nextTimeStep(currentState,
                                        numberCashFlowsThisStep,
                                        cashFlowsGenerated);

            for (Size j=0; j<numberCashFlowsThisStep[0]; ++j) {
                const CashFlow& cf = cashFlowsGenerated[0][j];
                collectedData[nextExercise][i].cumulatedCashFlows +=
                    cf.amount *
                    productDiscounters[cf.timeIndex]
                        .numeraireBonds(currentState, numeraire) /
                    principalInNumerairePortfolio;
            }
        }

        if (!done) {
            Size nextNumeraire = numeraires[currentStep+1];
            principalInNumerairePortfolio *=
                currentState.discountRatio(numeraire,
                                           nextNumeraire);
        }
    }
    while (!done);

    // fill the remaining (un)collected data with nulls
    for (Size j = nextExercise; j < exercises; ++j) {
        NodeData& data = collectedData[j+1][i];
        data.exerciseValue = data.controlValue = 0.0;
        data.cumulatedCashFlows = 0.0;
        data.isValid = false;
    }
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/callability/nothingexercisevalue.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for(Size i=0;i<isExerciseTime_.size();i++)
    if(isExerciseTime_[i])
        ++numberOfExercises_;

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/callability/swapbasissystem.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i<exerciseTimes.size(); ++i) {
    while (j < rateTimes.size() && rateTimes[j] < exerciseTimes[i])
        ++j;
    rateIndex_[i] = j;
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/callability/swapforwardbasissystem.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i<exerciseTimes.size(); ++i) 
{
    while (j < rateTimes.size() && rateTimes[j] < exerciseTimes[i])
        ++j;
    rateIndex_[i] = j;
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/callability/upperboundengine.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        for (Size i=0; i<N; ++i)
            cashFlowsGenerated_[i].resize(
                    product.maxNumberOfCashFlowsPerProductPerStep());

        for (Size i=0; i<lastSavedStep_; ++i)
            CallSpecifiedMultiProduct::nextTimeStep(
                                             *savedStates_[i],
                                             numberCashFlowsThisStep_,
                                             cashFlowsGenerated_);

for (Size i=0; i<numberOfProducts_; ++i)
    cashFlowsGenerated_[i].resize(
                  composite_.maxNumberOfCashFlowsPerProductPerStep());

for (Size j=0; j<n; ++j)
    discounters_.push_back(MarketModelDiscounter(cashFlowTimes[j],
                                                 rateTimes));

for (Size i=0; i<outerPaths; ++i) {
    std::pair<Real,Real> result = singlePathValue(innerPaths);
    stats.add(result.first, result.second);
}

for (Size k=0; k<numberOfSteps_; ++k) {
    weight *= evolver_->advanceStep();

    composite_.nextTimeStep(evolver_->currentState(),
                            numberCashFlowsThisStep_,
                            cashFlowsGenerated_);

    // First, we accumulate cash flows from both the
    // underlying...
    Real underlyingCashFlows =
        collectCashFlows(k,
                         principalInNumerairePortfolio,
                         underlyingOffset_,
                         underlyingOffset_+underlyingSize_);

    // ...and the hedge
    Real hedgeCashFlows =
        collectCashFlows(k,
                         principalInNumerairePortfolio,
                         hedgeOffset_,
                         hedgeOffset_+hedgeSize_);

    // we do the same for the rebates. Warning: this relies on
    // the fact that on each exercise date an ExerciseAdapter
    // generates a cash-flow equal to the exercise value
    Real rebateCashFlow =
        collectCashFlows(k,
                         principalInNumerairePortfolio,
                         rebateOffset_,
                         rebateOffset_+rebateSize_);

    Real hedgeRebateCashFlow =
        collectCashFlows(k,
                         principalInNumerairePortfolio,
                          hedgeRebateOffset_,
                         hedgeRebateOffset_+hedgeRebateSize_);


    numerairesHeld += underlyingCashFlows - hedgeCashFlows;

    // Second, we do the upper-bound thing
    if (isExerciseTime_[k]) {

        Real unexercisedHedgeValue = 0.0;

        if (k != numberOfSteps_-1) {

            // Here, we setup the relevant inner evolver and
            // the decorated callable hedge such that their
            // reset() method brings them to the current point
            // rather than the beginning of the path.

            boost::shared_ptr<MarketModelEvolver> currentEvolver =
                innerEvolvers_[exercise++];
            currentEvolver->setInitialState(evolver_->currentState());

            callable.stopRecording();
            callable.enableCallability();
            callable.save();

            // This allows us to write:
            AccountingEngine engine(currentEvolver, callable,
                                    1.0); // this causes the result
                                          // to be in numeraire units
            SequenceStatisticsInc innerStats(callable.numberOfProducts());
            engine.multiplePathValues(innerStats, innerPaths);

            const std::vector<Real>& values = innerStats.mean();
            unexercisedHedgeValue =
                std::accumulate(values.begin(), values.end(), Real(0.0))
                / principalInNumerairePortfolio;

            callable.disableCallability();
            callable.startRecording();

        }

        // Now, we can calculate the total value of our hedged
        // portfolio...
        Real portfolioValue = numerairesHeld;
        if (strategy.exercise(evolver_->currentState())) {
            // get the rebates...
            portfolioValue +=
                rebateCashFlow - hedgeRebateCashFlow;
            // ...and reinvest to rehedge
            numerairesHeld +=
                unexercisedHedgeValue - hedgeRebateCashFlow;
        } else {
            portfolioValue +=
                rebateCashFlow - unexercisedHedgeValue;
        }

        // ...and use it to update the maximum value
        maximumValue = std::max(maximumValue, portfolioValue);
    }


    // Lastly, we do the homework for next step (if any)
    if (k<numberOfSteps_-1) {

        // The numeraire might change between steps. This implies
        // that we might have to convert the numeraire bonds for
        // this step into a corresponding amount of numeraire
        // bonds for the next step. This can be done by changing
        // the principal of the numeraire and updating the number
        // of bonds in the numeraire portfolio accordingly.

        Size numeraire = evolver_->numeraires()[k];
        Size nextNumeraire = evolver_->numeraires()[k+1];

        principalInNumerairePortfolio *=
            evolver_->currentState().discountRatio(numeraire,
                                                   nextNumeraire);
    }

}

for (Size i=beginProduct; i<endProduct; ++i) {
    // ...and for each cash flow...
    const std::vector<MarketModelMultiProduct::CashFlow>& cashflows =
        cashFlowsGenerated_[i];
    for (Size j=0; j<numberCashFlowsThisStep_[i]; ++j) {
        // ...convert the cash flow to numeraires.  This is
        // done by calculating the number of numeraire bonds
        // corresponding to such cash flow...
        const MarketModelDiscounter& discounter =
            discounters_[cashflows[j].timeIndex];
        // ...and adding the newly bought bonds to the total
        numeraireUnits += cashflows[j].amount *
            discounter.numeraireBonds(evolver_->currentState(),
                                      numeraire);
    }
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/products/multiproductmultistep.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i<n; ++i) {
    evolutionTimes[i] = rateTimes_[i];
    relevanceRates[i] = std::make_pair(i, i+1);
}

for (Size i=0; i<n; ++i)
    numeraires[i]=i+1;

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/products/multiproductcomposite.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (const_iterator i=components_.begin(); i!=components_.end(); ++i)
    result += i->product->numberOfProducts();

for (const_iterator i=components_.begin(); i!=components_.end(); ++i)
    result = std::max(result,
    i->product
    ->maxNumberOfCashFlowsPerProductPerStep());

for (iterator i=components_.begin(); i!=components_.end(); ++i, ++n) {
    if (isInSubset_[n][currentIndex_] && !i->done) {
        // ...make it evolve...
        bool thisDone = i->product->nextTimeStep(currentState,
                                                 i->numberOfCashflows,
                                                 i->cashflows);
        // ...and copy the results. Time indices need to be remapped
        // so that they point into all cash-flow times. Amounts need
        // to be adjusted by the corresponding multiplier.
        for (Size j=0; j<i->product->numberOfProducts(); ++j) {
            numberCashFlowsThisStep[j+offset] =
                i->numberOfCashflows[j];
            for (Size k=0; k<i->numberOfCashflows[j]; ++k) {
                CashFlow& from = i->cashflows[j][k];
                CashFlow& to = cashFlowsGenerated[j+offset][k];
                to.timeIndex = i->timeIndices[from.timeIndex];
                to.amount = from.amount * i->multiplier;
            }
        }
        // finally, set done to false if this product isn't done
        done = done && thisDone;
    }
    else
        for (Size j=0; j<i->product->numberOfProducts(); ++j)
            numberCashFlowsThisStep[j+offset] =0;

    // the offset is updated whether or not the product was evolved
    offset += i->product->numberOfProducts();
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/products/singleproductcomposite.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (const_iterator i=components_.begin(); i!=components_.end(); ++i)
    result += i->product->maxNumberOfCashFlowsPerProductPerStep();

for (iterator i=components_.begin(); i!=components_.end(); ++i, ++n) {
    if (isInSubset_[n][currentIndex_] && !i->done) {
        // ...make it evolve...
        bool thisDone = i->product->nextTimeStep(currentState,
                                                 i->numberOfCashflows,
                                                 i->cashflows);
        // ...and copy the results. Time indices need to be remapped
        // so that they point into all cash-flow times. Amounts need
        // to be adjusted by the corresponding multiplier.
        for (Size j=0; j<i->product->numberOfProducts(); ++j) {
            Size offset = totalCashflows;
            totalCashflows += i->numberOfCashflows[j];
            for (Size k=0; k<i->numberOfCashflows[j]; ++k) {
                CashFlow& from = i->cashflows[j][k];
                CashFlow& to = cashFlowsGenerated[0][k+offset];
                to.timeIndex = i->timeIndices[from.timeIndex];
                to.amount = from.amount * i->multiplier;
            }
            numberCashFlowsThisStep[0] = totalCashflows;
        }
        // finally, set done to false if this product isn't done
        done = done && thisDone;
    }
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/products/compositeproduct.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (iterator i=components_.begin(); i!=components_.end(); ++i) {
    i->product->reset();
    i->done = false;
}

for (i=components_.begin(); i!=components_.end(); ++i) {
    EvolutionDescription d = i->product->evolution();
    // ...collect all possible cash-flow times...
    const std::vector<Time>& cashflowTimes =
        i->product->possibleCashFlowTimes();
    allCashflowTimes.insert(allCashflowTimes.end(),
                            cashflowTimes.begin(),
                            cashflowTimes.end());
    // ...allocate working vectors...
    i->numberOfCashflows =
        std::vector<Size>(i->product->numberOfProducts());
    i->cashflows =
        std::vector<std::vector<CashFlow> >(
             i->product->numberOfProducts(),
             std::vector<CashFlow>(i->product
                          ->maxNumberOfCashFlowsPerProductPerStep()));
}

for (i=components_.begin(); i!=components_.end(); ++i) {
    const std::vector<Time>& productTimes =
        i->product->possibleCashFlowTimes();
    i->timeIndices = std::vector<Size>(productTimes.size());
    for (Size j=0; j<productTimes.size(); ++j) {
        i->timeIndices[j] =
            std::find(cashflowTimes_.begin(), cashflowTimes_.end(),
                      productTimes[j]) - cashflowTimes_.begin();
    }
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/products/multistep/callspecifiedmultiproduct.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        for (Size i=0; i<numberCashFlowsThisStep.size(); ++i)
            for (Size j=0; j<numberCashFlowsThisStep[i]; ++j)
                cashFlowsGenerated[i][j].timeIndex += rebateOffset_;

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/products/multistep/multisteptarn.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i < paymentTimesFloating_.size(); ++i)
    allPaymentTimes_.push_back(paymentTimes[i]);

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/products/multistep/multistepcoinitialswaps.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=currentIndex_;i<lastIndex_;i++) {
    genCashFlows[i][0].timeIndex = currentIndex_;
    genCashFlows[i][0].amount =
        -fixedRate_*fixedAccruals_[currentIndex_];

    genCashFlows[i][1].timeIndex = currentIndex_;
    genCashFlows[i][1].amount =
        liborRate*floatingAccruals_[currentIndex_];

    numberCashFlowsThisStep[i] = 2;
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/products/multistep/multisteppathwisewrapper.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i < cashFlowsGenerated_.size(); ++i)
    for (Size j=0; j < cashFlowsGenerated_[i].size(); ++j)
            cashFlowsGenerated_[i][j].amount.resize(1+innerProduct.evolution().numberOfRates());

    for (Size i=0; i < numberOfProducts_; ++i)
        for (Size j=0; j< numberCashFlowsThisStep[i]; ++j)
        {
            cashFlowsGenerated[i][j].timeIndex =cashFlowsGenerated_[i][j].timeIndex;
            cashFlowsGenerated[i][j].amount =cashFlowsGenerated_[i][j].amount[0];
        }

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/products/multistep/cashrebate.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i<numberOfProducts_; ++i) 
{
    numberCashFlowsThisStep[i] = 1;
    genCashFlows[i][0].timeIndex = currentIndex_;
    genCashFlows[i][0].amount = amounts_[i][currentIndex_];
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/products/multistep/multistepperiodcapletswaptions.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i < swaptionPaymentTimes_.size(); ++i)
    paymentTimes_.push_back(swaptionPaymentTimes_[i]);

for (Size i=0; i < numberCashFlowsThisStep.size(); ++i)
numberCashFlowsThisStep[i]=0UL;

for (unsigned long i=0; i < numberPeriods; ++i)
{
    Time tau = rateTimes_[currentIndex_+(i+1)*period_]- rateTimes_[currentIndex_+i*period_];
    B+= tau*currentState.discountRatio(currentIndex_+(i+1)*period_,currentIndex_);
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/products/multistep/multistepcoterminalswaps.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for(Size i=0;i<=currentIndex_;i++){
    genCashFlows[i][0].timeIndex = currentIndex_;
    genCashFlows[i][0].amount =
        -fixedRate_*fixedAccruals_[currentIndex_];

    genCashFlows[i][1].timeIndex = currentIndex_;
    genCashFlows[i][1].amount =
        liborRate*floatingAccruals_[currentIndex_];

    numberCashFlowsThisStep[i] = 2;
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/products/pathwise/pathwiseproductswaption.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    for (Size i=1; i <= numberRates_; ++i)
        cashFlowsGenerated[currentIndex_][0].amount[i] =0;

    for (Size k=currentIndex_; k < numberRates_; ++k)
    {
      cashFlowsGenerated[currentIndex_][0].amount[k+1]  = (rateTimes_[k+1]-rateTimes_[k])*currentState.discountRatio(k+1,currentIndex_); 

      Real multiplier = - (rateTimes_[k+1]-rateTimes_[k])*currentState.discountRatio(k+1,k);

      for (Size l=k; l < numberRates_; ++l)
         cashFlowsGenerated[currentIndex_][0].amount[k+1]  +=(currentState.forwardRate(l)-strikes_[currentIndex_])*(rateTimes_[l+1]-rateTimes_[l])
                                                            * multiplier*currentState.discountRatio(l+1,currentIndex_);
    }

    for (Size i=0; i < numberRates_; ++i)
        numeraires[i] = i;

    for (Size i=1; i <= numberRates_; ++i)
        cashFlowsGenerated[currentIndex_][0].amount[i] =0;

    for (Size k=currentIndex_; k < numberRates_; ++k)
    {
        forwards_ = currentState.forwardRates();
        forwards_[k] += bumpSize_;
        up_.setOnForwardRates(forwards_);

        forwards_[k] -= bumpSize_;
        forwards_[k] -= bumpSize_;
        down_.setOnForwardRates(forwards_);

        Real upSR = up_.coterminalSwapRate(currentIndex_);
        Real upAnnuity = up_.coterminalSwapAnnuity(currentIndex_,currentIndex_);
        Real upValue = (upSR -  strikes_[currentIndex_])*  upAnnuity;

        Real downSR = down_.coterminalSwapRate(currentIndex_);
        Real downAnnuity = down_.coterminalSwapAnnuity(currentIndex_,currentIndex_);
        Real downValue = (downSR -  strikes_[currentIndex_])*  downAnnuity;

        Real deriv = (upValue - downValue)/(2.0*bumpSize_);

        cashFlowsGenerated[currentIndex_][0].amount[k+1]  = deriv; 
    
    }

    for (Size i=0; i < numberRates_; ++i)
        numeraires[i] = i;

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/products/pathwise/pathwiseproductcaplet.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    for (Size i=1; i <= numberRates_; ++i)
        cashFlowsGenerated[currentIndex_][0].amount[i] =0;

for (Size i=0; i < numberRates_; ++i)
    numeraires[i] = i+1;

    for (Size i=1; i <= numberRates_; ++i)
        cashFlowsGenerated[currentIndex_][0].amount[i] =0;

    for (Size i=0; i <= currentIndex_; ++i)
    {
        Real stepDF = currentState.discountRatio(i+1,i);
        cashFlowsGenerated[currentIndex_][0].amount[i+1] -=   accruals_[i]*stepDF
            *cashFlowsGenerated[currentIndex_][0].amount[0];
    }

for (Size i=0; i < numberRates_; ++i)
    numeraires[i] = i;

for (Size j=0; j < startsAndEnds_.size(); ++j)
{
    QL_REQUIRE(startsAndEnds_[j].first < startsAndEnds_[j].second,"a cap must start before it ends: " << j << startsAndEnds_[j].first << startsAndEnds_[j].second );
    QL_REQUIRE(startsAndEnds_[j].second <= accruals.size() ,"a cap must end when the underlying caplets: " << j << startsAndEnds_[j].first << startsAndEnds_[j].second );
   
}

for (Size i=0; i <  innerCashFlowsGenerated_.size(); ++i)
{
    innerCashFlowsGenerated_[i].resize(underlyingCaplets_.maxNumberOfCashFlowsPerProductPerStep());
    for (Size j=0; j < underlyingCaplets_.maxNumberOfCashFlowsPerProductPerStep(); ++j)
        innerCashFlowsGenerated_[i][j].amount.resize(accruals.size()+1);


}

for (Size k=0; k < startsAndEnds_.size(); ++k)
    numberCashFlowsThisStep[k]=0;

for (Size j=0; j < numberRates_; ++j)
{
    if (innerCashFlowSizes_[j]>0)
    {
        for (Size k=0; k < startsAndEnds_.size(); ++k)
        {
            if (startsAndEnds_[k].first <= j && j < startsAndEnds_[k].second)
            {
                for (Size l=0; l < innerCashFlowSizes_[j]; ++l)
                    cashFlowsGenerated[k][numberCashFlowsThisStep[k]++] = innerCashFlowsGenerated_[j][l];
            }
        }
    }
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/products/pathwise/pathwiseproductcashrebate.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i<numberOfProducts_; ++i) 
{
    numberCashFlowsThisStep[i] = 1;
    cashFlowsGenerated[i][0].timeIndex = currentIndex_;
    cashFlowsGenerated[i][0].amount[0] = amounts_[i][currentIndex_];

    for (Size k=1; k <= evolution_.numberOfRates(); ++k)
         cashFlowsGenerated[i][0].amount[k] = 0.0;

}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/products/pathwise/pathwiseproductinversefloater.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=1; i <= lastIndex_; ++i)
    cashFlowsGenerated[0][0].amount[i] =0;

for (Size i=0; i < lastIndex_; ++i)
    numeraires[i] = i;

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/products/pathwise/pathwiseproductcallspecified.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            for (Size i=0; i<numberCashFlowsThisStep.size(); ++i)
                for (Size j=0; j<numberCashFlowsThisStep[i]; ++j)
                    cashFlowsGenerated[i][j].timeIndex += rebateOffset_;

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/products/pathwise/pathwiseproductswap.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=1; i <= numberRates_; ++i)
        cashFlowsGenerated[0][0].amount[i] =0;

    for (Size i=0; i < numberRates_; ++i)
        numeraires[i] = i;

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/products/onestep/onestepcoterminalswaps.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size indexOfTime=0;indexOfTime<lastIndex_;indexOfTime++) {
    Rate liborRate = currentState.forwardRate(indexOfTime);

    for (Size i=0;i<=indexOfTime;i++) {
        genCashFlows[i][(indexOfTime-i)*2].timeIndex = indexOfTime;
        genCashFlows[i][(indexOfTime-i)*2].amount =
            -fixedRate_*fixedAccruals_[indexOfTime];

        genCashFlows[i][(indexOfTime-i)*2+1].timeIndex = indexOfTime;
        genCashFlows[i][(indexOfTime-i)*2+1].amount =
            liborRate*floatingAccruals_[indexOfTime];

        numberCashFlowsThisStep[i] += 2;
    }
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/products/onestep/onestepoptionlets.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i<payoffs_.size(); ++i) {
    Rate liborRate = currentState.forwardRate(i);
    Real payoff = (*payoffs_[i])(liborRate);
    if (payoff>0.0) {
        numberCashFlowsThisStep[i] = 1;
        genCashFlows[i][0].timeIndex = i;
        genCashFlows[i][0].amount = payoff*accruals_[i];
    }
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/products/onestep/onestepforwards.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i<strikes_.size(); ++i) {
    Rate liborRate = currentState.forwardRate(i);
    genCashFlows[i][0].timeIndex = i;
    genCashFlows[i][0].amount =
        (liborRate-strikes_[i])*accruals_[i];
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/products/onestep/onestepcoinitialswaps.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size indexOfTime=0;indexOfTime<lastIndex_;indexOfTime++) {
    Rate liborRate = currentState.forwardRate(indexOfTime);
    for (Size i=indexOfTime;i<lastIndex_;i++) {
        genCashFlows[i][(indexOfTime)*2].timeIndex = indexOfTime;
        genCashFlows[i][(indexOfTime)*2].amount =
            -fixedRate_*fixedAccruals_[indexOfTime];

        genCashFlows[i][(indexOfTime)*2+1].timeIndex = indexOfTime;
        genCashFlows[i][(indexOfTime)*2+1].amount =
            liborRate*floatingAccruals_[indexOfTime];

        numberCashFlowsThisStep[i] += 2;
    }
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/pathwisegreeks/vegabumpcluster.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size s=0; s < steps; ++s)
    for (Size r=volStructure->evolution().firstAliveRate()[s]; r < rates; ++r)
    {
        if (factorwiseBumping)
        {
            for (Size f=0; f < factors; ++f)
            {
                VegaBumpCluster thisCluster(f,f+1,r,r+1,s,s+1);
                allBumps_.push_back(thisCluster);

            }
        }
        else
        {
             VegaBumpCluster thisCluster(0,factors,r,r+1,s,s+1);
             allBumps_.push_back(thisCluster);

        }
    }

for (Size j=0; j < allBumps_.size(); ++j)
    QL_REQUIRE(allBumps_[j].isCompatible(associatedVolStructure_),"incompatible bumps passed to VegaBumpCollection");

for (Size i=0; i < associatedVolStructure_->numberOfRates(); ++i)
    modelTwo.push_back(model);

for (Size j=0; j < associatedVolStructure_->numberOfSteps(); ++j)
    v.push_back(modelTwo);

for (Size k=0; k < allBumps_.size(); ++k)
{
    for (Size f=allBumps_[k].factorBegin(); f <  allBumps_[k].factorEnd(); ++f)
        for (Size r=allBumps_[k].rateBegin(); r <  allBumps_[k].rateEnd(); ++r)
            for (Size s= allBumps_[k].stepBegin(); s <  allBumps_[k].stepEnd(); ++s)
                v[s][r][f] = true;

}

for (Size s =0; s < associatedVolStructure_->numberOfSteps(); ++s)
    for (Size f=0; f < associatedVolStructure_->numberOfFactors(); ++f)
        for (Size r=associatedVolStructure_->evolution().firstAliveRate()[s]; r <  associatedVolStructure_->numberOfRates(); ++r)
            if (!v[s][r][f])
                ++numberFailures;

for (Size i=0; i < associatedVolStructure_->numberOfRates(); ++i)
    modelTwo.push_back(model);

for (Size j=0; j < associatedVolStructure_->numberOfSteps(); ++j)
    v.push_back(modelTwo);

for (Size k=0; k < allBumps_.size(); ++k)
{
    for (Size f=allBumps_[k].factorBegin(); f <  allBumps_[k].factorEnd(); ++f)
        for (Size r=allBumps_[k].rateBegin(); r <  allBumps_[k].rateEnd(); ++r)
            for (Size s= allBumps_[k].stepBegin(); s <  allBumps_[k].stepEnd(); ++s)
            {
                if (v[s][r][f])
                    ++numberFailures;
                v[s][r][f] = true;
            }

}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/pathwisegreeks/bumpinstrumentjacobian.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    for (Size k=0;  k < bumps_.numberBumps(); ++k)
    {
        Real v =0.0;

        for (Size i= bumps_.allBumps()[k].stepBegin(); i < bumps_.allBumps()[k].stepEnd(); ++i)
        {
            const Matrix& fullDerivative = thisPseudo.volatilityDerivative(i);
            for (Size f= bumps_.allBumps()[k].factorBegin(); f < bumps_.allBumps()[k].factorEnd(); ++f)
                for (Size r= bumps_.allBumps()[k].rateBegin(); r < bumps_.allBumps()[k].rateEnd(); ++r)
                    v += fullDerivative[r][f];
        }

        derivatives_[j][k] =v;
        sizesq+= v*v;
    }

    for (Size k=0;  k < bumps_.numberBumps(); ++k)
    {
        Real v =0.0;

        for (Size i= bumps_.allBumps()[k].stepBegin(); i < bumps_.allBumps()[k].stepEnd(); ++i)
        {
            const Matrix& fullDerivative = thisPseudo.volatilityDerivative(i);
            for (Size f= bumps_.allBumps()[k].factorBegin(); f < bumps_.allBumps()[k].factorEnd(); ++f)
                for (Size r= bumps_.allBumps()[k].rateBegin(); r < bumps_.allBumps()[k].rateEnd(); ++r)
                    v += fullDerivative[r][f];
        }

        sizesq += v*v;

        derivatives_[initj][k] =v;
    }

for (Size k=0; k < bumps_.numberBumps(); ++k)
{
    bumpMatrix_[initj][k] = onePercentBumps_[initj][k] = 0.01 * derivatives_[initj][k]/sizesq;

}

     for (Size i=0; i <swaptions_.size()+caps_.size(); ++i)
        derivativesVolatility(i);

for (Size i=0; i < theBumps.size(); ++i)
    theBumps[i].resize(numberRestrictedBumps);

for (Size i=0;  i< numberSteps; ++i)
    for (Size j=0; j < numberRestrictedBumps; ++j)
        theBumps[i][j] = modelMatrix;

for (Size instrument=0; instrument < projector.validVectors().size(); ++instrument)
{
    if (projector.validVectors()[instrument])
    {
        for (Size cluster =0; cluster< bumpClusters.size(); ++cluster)
        {
            Real magnitude = projector.GetVector(instrument)[cluster];

            for (Size step = bumpClusters[cluster].stepBegin(); step <  bumpClusters[cluster].stepEnd(); ++step)
                for (Size rate = bumpClusters[cluster].rateBegin(); rate < bumpClusters[cluster].rateEnd(); ++rate)
                    for (Size factor = bumpClusters[cluster].factorBegin(); factor <  bumpClusters[cluster].factorEnd(); ++factor)
                        theBumps[step][bumpIndex][rate][factor] = magnitude;
        }

        ++bumpIndex;


    }

}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/pathwisegreeks/ratepseudorootjacobian.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i < pseudoBumps.size(); ++i)
{
    QL_REQUIRE(pseudoBumps[i].rows()==numberRates,
        "pseudoBumps[i].rows()<> taus.size() with i =" << i);

    QL_REQUIRE(pseudoBumps[i].columns()==factors_,
        "pseudoBumps[i].columns()<> factors with i = " << i);


    Matrix pseudo(pseudoRoot_);
    pseudo += pseudoBumps[i];
    pseudoBumped_.push_back(pseudo);
    driftsComputers_.push_back(LMMDriftCalculator(pseudo,
        displacements,
        taus,
        numeraire,
        aliveIndex));
}

for (Size i =0; i < numberBumps_; ++i)
{
    const Matrix& pseudo = pseudoBumped_[i];
    driftsComputers_[i].compute(oldRates,
        drifts_);

    for (Size j =0; j < aliveIndex_; ++j)
        B[i][j]=0.0;

    for (Size j=aliveIndex_; j < numberRates; ++j)
    {
        bumpedRates_[j] = std::log(oldRates[j]+displacements_[j]);

        for (Size k=0; k < factors_; ++k)
            bumpedRates_[j] += -0.5*pseudo[j][k]*pseudo[j][k];

        bumpedRates_[j] +=drifts_[j];

        for (Size k=0; k < factors_; ++k)
            bumpedRates_[j] += pseudo[j][k]*gaussians[k];

        bumpedRates_[j] = std::exp(bumpedRates_[j]);
        bumpedRates_[j] -= displacements_[j];
        Real tmp = bumpedRates_[j] - newRates[j];

        B[i][j] =  tmp;
    }
}

for (Size i=0; i < pseudoBumps.size(); ++i)
{
    QL_REQUIRE(pseudoBumps[i].rows()==numberRates,
        "pseudoBumps[i].rows()<> taus.size() with i =" << i);

    QL_REQUIRE(pseudoBumps[i].columns()==factors_,
        "pseudoBumps[i].columns()<> factors with i = " << i);




}

for (Size i=0; i < numberRates; ++i)
{
    allDerivatives_.push_back(Matrix(numberRates,factors_));
}

for (Size j=aliveIndex_; j < numberRates; ++j)
    ratios_[j] = (oldRates[j] + displacements_[j])*discountRatios[j+1];

for (Size f=0; f < factors_; ++f)
{
    e_[aliveIndex_][f] = 0;

    for (Size j= aliveIndex_+1; j < numberRates; ++j)
        e_[j][f] = e_[j-1][f] + ratios_[j-1]*pseudoRoot_[j-1][f];
}

for (Size f=0; f < factors_; ++f)
    for (Size j=aliveIndex_; j < numberRates; ++j)
    {
        for (Size k= aliveIndex_; k < j ; ++k)
            allDerivatives_[j][k][f] = newRates[j]*ratios_[k]*taus_[k]*pseudoRoot_[j][f];

        // GG don't seem to have the 2, this term is miniscule in any case
        Real tmp = //2*
            2*ratios_[j]*taus_[j]*pseudoRoot_[j][f];
        tmp -=  pseudoRoot_[j][f];
        tmp += e_[j][f]*taus_[j];
        tmp += gaussians[f];
        tmp *= (newRates[j]+displacements_[j]);


        allDerivatives_[j][j][f] =tmp;

        for (Size k= j+1; k < numberRates ; ++k)
            allDerivatives_[j][k][f]=0.0;


    }

    for (Size i =0; i < numberBumps_; ++i)
    {
        Size j=0;

        for (; j < aliveIndex_; ++j)
        {
            B[i][j]=0.0;
        }
        for (; j < numberRates; ++j)
        {
            Real sum =0.0;

            for (Size k=aliveIndex_; k < numberRates; ++k)
                for (Size f=0; f < factors_; ++f)
                    sum += pseudoBumps_[i][k][f]*allDerivatives_[j][k][f];
            B[i][j] =sum;

        }

    }

   for (Size j=0; j < B.size(); ++j)
              QL_REQUIRE(B[j].columns() == factors_ && B[j].rows() == numberRates , "we need B[j].rows() which is " << B[j].rows() << " to equal numberRates which is "  << numberRates << 
              " and B[j].columns() which is " << B[j].columns() << " to be equal to factors which is " << factors_);

for (Size j=aliveIndex_; j < numberRates; ++j)
    ratios_[j] = (oldRates[j] + displacements_[j])*discountRatios[j+1];

for (Size f=0; f < factors_; ++f)
{
    e_[aliveIndex_][f] = 0;

    for (Size j= aliveIndex_+1; j < numberRates; ++j)
        e_[j][f] = e_[j-1][f] + ratios_[j-1]*pseudoRoot_[j-1][f];
}

for (Size j=0; j < aliveIndex_; ++j)
    for (Size k=0; k < numberRates; ++k)
        for (Size f=0; f < factors_; ++f)
              B[j][k][f] =0.0;

for (Size f=0; f < factors_; ++f)
    for (Size j=aliveIndex_; j < numberRates; ++j)
    {
        for (Size k= aliveIndex_; k < j ; ++k)
            B[j][k][f] = newRates[j]*ratios_[k]*taus_[k]*pseudoRoot_[j][f];

        Real tmp = 2*ratios_[j]*taus_[j]*pseudoRoot_[j][f];
        tmp -=  pseudoRoot_[j][f];
        tmp += e_[j][f]*taus_[j];
        tmp += gaussians[f];
        tmp *= (newRates[j]+displacements_[j]);


        B[j][j][f] =tmp;

        for (Size k= 0; k < aliveIndex_ ; ++k)
            B[j][k][f]=0.0;

        for (Size k= j+1; k < numberRates ; ++k)
            B[j][k][f]=0.0;


    }

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/pathwisegreeks/swaptionpseudojacobian.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    for (Size j=startIndex; j < endIndex; ++j)
        for (Size k=startIndex; k < endIndex; ++k)
            for (Size f=0; f < factors; ++f)
                thisVariance_+= zed[0][j-startIndex]*thisPseudo[j][f]*thisPseudo[k][f]*zed[0][k-startIndex];

    for (Size rate=startIndex; rate<endIndex; ++rate)
    {
        Size zIndex = rate -startIndex;
        for (Size f =0; f < factors; ++f)
        {
            Real sum=0.0;
            for (Size rate2 = startIndex; rate2<endIndex; ++rate2)
            {
                Size zIndex2 = rate2-startIndex;
                sum += zed[0][zIndex2] * thisPseudo[rate2][f];
            }
            sum *= 2.0*zed[0][zIndex];

            thisDerivative[rate][f] =sum;

        }
    }

    for ( Size rate=startIndex; rate<endIndex; ++rate)
        for (Size f =0; f < factors; ++f)
            thisDerivative[rate][f] *= scale;

for (; index < inputModel->evolution().numberOfSteps(); ++index)
{
    varianceDerivatives_.push_back(nullDerivative);
    volatilityDerivatives_.push_back(nullDerivative);

}

    for (Size i=0; i < annuities_.size(); ++i)
    {
        price += blackFormula(Option::Call,strike_,
            currentRates_[i],
            volatility*std::sqrt(expiries_[i]),
            annuities_[i]);


    }

    for (Size i=0; i < annuities_.size(); ++i)
    {
 

        vega+= blackFormulaVolDerivative(strike_,currentRates_[i],
                                         
                                         volatility*std::sqrt(expiries_[i]),
                                         expiries_[i],
                                         annuities_[i],
                                         0.0);
    }

for (Size j = startIndex; j < endIndex; ++j)
{
    Size capletIndex = j - startIndex;
    Time resetTime = inputModel->evolution().rateTimes()[j];
    expiries[capletIndex] =  resetTime;

    Real sd = std::sqrt(totalCovariance[j][j]);
    displacedImpliedVols[capletIndex] = std::sqrt(totalCovariance[j][j]/resetTime);

    Real forward = inputModel->initialRates()[j];
    initialRates[capletIndex] = forward;

    Real annuity = curve.discountRatio(j+1,0)* inputModel->evolution().rateTaus()[j]*firstDF_;
    annuities[capletIndex] = annuity;

    Real displacement =  inputModel->displacements()[j];

    guess+=  displacedImpliedVols[capletIndex]*(forward+displacement)/forward;
    minVol =std::min(minVol, displacedImpliedVols[capletIndex]);
    maxVol =std::max(maxVol, displacedImpliedVols[capletIndex]*(forward+displacement)/forward);


    Real capletPrice = blackFormula(Option::Call,
        strike,
        forward,
        sd,
        annuity,
        displacement
        );

    capletPrices[capletIndex] = capletPrice;

    capPrice += capletPrice;

}

for (Size step =0; step < inputModel->evolution().numberOfSteps(); ++step)
{
    Matrix thisDerivative(numberRates,factors,0.0);

    for (Size rate =std::max(inputModel->evolution().firstAliveRate()[step],startIndex); 
        rate < endIndex; ++rate)
    {
        for (Size f=0; f < factors; ++f)
        {
            Real expiry = inputModel->evolution().rateTimes()[rate];
            Real volDerivative = inputModel->pseudoRoot(step)[rate][f]
            /(displacedImpliedVols[rate-startIndex]*expiry);
            Real capletVega = blackFormulaVolDerivative(strike,inputModel->initialRates()[rate],
                displacedImpliedVols[rate-startIndex]*std::sqrt(expiry),
                expiry,
                annuities[rate-startIndex],
                inputModel->displacements()[rate]);

            // note that the cap derivative  is equal to one of the caplet ones so we lose a loop
            thisDerivative[rate][f] = volDerivative*capletVega;
        }
    }

    priceDerivatives_.push_back(thisDerivative);

}

for (Size step =0; step < inputModel->evolution().numberOfSteps(); ++step)
{
    Matrix thisDerivative(numberRates,factors,0.0);

    for (Size rate =std::max(inputModel->evolution().firstAliveRate()[step],startIndex); 
        rate < endIndex; ++rate)
    {
        for (Size f=0; f < factors; ++f)
        {
           
            thisDerivative[rate][f] = priceDerivatives_[step][rate][f]/vega_;
        }
    }

    volatilityDerivatives_.push_back(thisDerivative);

}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/indexes/bmaindex.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Date d = previousWednesday(date); d<date; ++d) {
    if (cal.isBusinessDay(d))
        return false;
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/indexes/inflationindex.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i<n; ++i) {
    dates[i] = lim.first + i;
    rates[i] = fixing;
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/pricingengines/basket/mcamericanbasketengine.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i<assetNumber_; ++i) {
    tmp[i] = path[i][t]*scalingValue_;
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/pricingengines/basket/mceuropeanbasketengine.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (j = 0; j < numAssets; j++)
    finalPrice[j] = multiPath[j].back();

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/pricingengines/asian/fdblackscholesasianengine.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i<arguments_.fixingDates.size(); ++i) {
    Time t = process_->time(arguments_.fixingDates[i]);
    QL_REQUIRE(t >= 0, "Fixing dates must not contain past date");
    averageTimes.push_back(t);
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/pricingengines/asian/analytic_discr_geom_av_strike.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i<arguments_.fixingDates.size(); i++) {
    if (arguments_.fixingDates[i]>=arguments_.fixingDates[0]) {
        Time t = voldc.yearFraction(arguments_.fixingDates[0],
            arguments_.fixingDates[i]);
        fixingTimes.push_back(t);
    }
}

for (Size i=pastFixings+1; i<numberOfFixings; i++)
    temp += fixingTimes[i-pastFixings-1]*(N-i);

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/pricingengines/asian/mc_discr_geom_av_price.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=1; i<n+1; i++) {
    Real price = path[i];
    if (product < maxValue/price) {
        product *= price;
    } else {
        averagePrice *= std::pow(product, 1.0/fixings);
        product = price;
    }
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/pricingengines/asian/analytic_discr_geom_av_price.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (i=0; i<arguments_.fixingDates.size(); i++) {
    if (arguments_.fixingDates[i]>=referenceDate) {
        Time t = voldc.yearFraction(referenceDate,
            arguments_.fixingDates[i]);
        fixingTimes.push_back(t);
    }
}

for (i=pastFixings+1; i<numberOfFixings; i++)
    temp += fixingTimes[i-pastFixings-1]*(N-i);

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/pricingengines/cliquet/mcperformanceengine.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i = 2 ; i < n; i++) {
    sum += discounts_[i-1] * payoff(path[i]/path[i-1]);
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/pricingengines/cliquet/analyticcliquetengine.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i = 1; i < resetDates.size(); i++) {

    Real weight =
        process_->dividendYield()->discount(resetDates[i-1]);
    DiscountFactor discount =
        process_->riskFreeRate()->discount(resetDates[i]) /
        process_->riskFreeRate()->discount(resetDates[i-1]);
    DiscountFactor qDiscount =
        process_->dividendYield()->discount(resetDates[i]) /
        process_->dividendYield()->discount(resetDates[i-1]);
    Real forward = underlying*qDiscount/discount;
    Real variance =
        process_->blackVolatility()->blackForwardVariance(
                                resetDates[i-1],resetDates[i],strike);

    BlackCalculator black(payoff, forward, std::sqrt(variance), discount);

    DayCounter rfdc  = process_->riskFreeRate()->dayCounter();
    DayCounter divdc = process_->dividendYield()->dayCounter();
    DayCounter voldc = process_->blackVolatility()->dayCounter();

    results_.value += weight * black.value();
    results_.delta += weight * (black.delta(underlying) +
                                moneyness->strike() * discount *
                                black.beta());
    results_.gamma += 0.0;
    results_.theta += process_->dividendYield()->forwardRate(
        resetDates[i-1], resetDates[i], rfdc, Continuous, NoFrequency) *
        weight * black.value();

    Time dt = rfdc.yearFraction(resetDates[i-1],resetDates[i]);
    results_.rho += weight * black.rho(dt);

    Time t = divdc.yearFraction(
                            process_->dividendYield()->referenceDate(),
                            resetDates[i-1]);
    dt = divdc.yearFraction(resetDates[i-1],resetDates[i]);
    results_.dividendRho += weight * (black.dividendRho(dt) -
                                      t * black.value());

    dt = voldc.yearFraction(resetDates[i-1], resetDates[i]);
    results_.vega += weight * black.vega(dt);
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/pricingengines/cliquet/analyticperformanceengine.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i = 1; i < resetDates.size(); i++) {

    DiscountFactor discount =
        process_->riskFreeRate()->discount(resetDates[i-1]);
    DiscountFactor rDiscount =
        process_->riskFreeRate()->discount(resetDates[i]) /
        process_->riskFreeRate()->discount(resetDates[i-1]);
    DiscountFactor qDiscount =
        process_->dividendYield()->discount(resetDates[i]) /
        process_->dividendYield()->discount(resetDates[i-1]);
    Real forward = (1.0/moneyness->strike())*qDiscount/rDiscount;
    Real variance =
        process_->blackVolatility()->blackForwardVariance(
                                resetDates[i-1],resetDates[i],
                                underlying * moneyness->strike());

    BlackCalculator black(payoff, forward, std::sqrt(variance), rDiscount);

    DayCounter rfdc  = process_->riskFreeRate()->dayCounter();
    DayCounter divdc = process_->dividendYield()->dayCounter();
    DayCounter voldc = process_->blackVolatility()->dayCounter();

    results_.value += discount * moneyness->strike() * black.value();
    results_.delta += 0.0;
    results_.gamma += 0.0;
    results_.theta += process_->riskFreeRate()->forwardRate(
        resetDates[i-1], resetDates[i], rfdc, Continuous, NoFrequency) *
        discount * moneyness->strike() * black.value();

    Time dt = rfdc.yearFraction(resetDates[i-1],resetDates[i]);
    Time t = rfdc.yearFraction(
                          process_->riskFreeRate()->referenceDate(),
                          resetDates[i-1]);
    results_.rho += discount * moneyness->strike() *
        (black.rho(dt) - t * black.value());

    dt = divdc.yearFraction(resetDates[i-1],resetDates[i]);
    results_.dividendRho += discount * moneyness->strike() *
        black.dividendRho(dt);

    dt = voldc.yearFraction(resetDates[i-1], resetDates[i]);
    results_.vega += discount * moneyness->strike() * black.vega(dt);
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/pricingengines/vanilla/mcdigitalengine.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    for (i=0; i<n-1; i++) {
        x = std::log(path[i+1]/path[i]);
        // terminal or initial vol?
        vol = diffProcess_->diffusion(timeGrid[i+1],
                                      std::exp(log_asset_price));
        // vol = diffProcess_->diffusion(timeGrid[i+2],
        //                               std::exp(log_asset_price+x));
        dt = timeGrid.dt(i);
        y = log_asset_price +
            0.5*(x + std::sqrt(x*x-2*vol*vol*dt*std::log((1-u[i]))));
        // cross the strike
        if (y >= log_strike) {
            if (exercise_->payoffAtExpiry()) {
                return payoff_->cashPayoff() *
                    discountTS_->discount(path.timeGrid().back());
            } else {
                // the discount should be calculated at the exercise
                // time between path.timeGrid()[i+1] and
                // path.timeGrid()[i+2]
                return payoff_->cashPayoff() *
                    discountTS_->discount(path.timeGrid()[i+1]);
            }
        }
        log_asset_price += x;
    }

    for (i=0; i<n-1; i++) {
        x = std::log(path[i+1]/path[i]);
        // terminal or initial vol?
        // initial (timeGrid[i+1]) for the time being
        vol = diffProcess_->diffusion(timeGrid[i+1],
                                      std::exp(log_asset_price));
        // vol = diffProcess_->diffusion(timeGrid[i+2],
        //                               std::exp(log_asset_price+x));
        dt = timeGrid.dt(i);
        y = log_asset_price +
            0.5*(x - std::sqrt(x*x - 2*vol*vol*dt*std::log(u[i])));
        if (y <= log_strike) {
            if (exercise_->payoffAtExpiry()) {
                return payoff_->cashPayoff() *
                    discountTS_->discount(path.timeGrid().back());
            } else {
                // the discount should be calculated at the exercise
                // time between path.timeGrid()[i+1] and
                // path.timeGrid()[i+2]
                return payoff_->cashPayoff() *
                    discountTS_->discount(path.timeGrid()[i+1]);
            }
        }
        log_asset_price += x;
    }

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/pricingengines/vanilla/discretizedvanillaoption.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i<stoppingTimes_.size(); ++i) {
    stoppingTimes_[i] =
        process.time(args.exercise->date(i));
    if (!grid.empty()) {
        // adjust to the given grid
        stoppingTimes_[i] = grid.closestTime(stoppingTimes_[i]);
    }
}

    for (Size i=0; i<stoppingTimes_.size(); i++) {
        if (isOnTime(stoppingTimes_[i]))
            applySpecificCondition();
    }

for (Size j=0; j<values_.size(); j++) {
    values_[j] = std::max(values_[j],
                          (*arguments_.payoff)(grid[j]));
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/pricingengines/vanilla/fdsimplebsswingengine.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i<arguments_.exercise->dates().size(); ++i) {
    Time t = process_->time(arguments_.exercise->dates()[i]);
    QL_REQUIRE(t >= 0, "exercise dates must not contain past date");
    exerciseTimes.push_back(t);
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/pricingengines/vanilla/analyticgjrgarchengine.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    for (i=1; i < T; ++i) {
        m1ai[i] = m1ai[i-1]*m1;
        m2ai[i] = m2ai[i-1]*m2;
        m3ai[i] = m3ai[i-1]*m3;
    }

    for (i = 0; i < T; ++i) {
        Real m1i = m1ai[i];
        Real m2i = m2ai[i];
        Real m3i = m3ai[i];

        Real m1im2i = m1i-m2i, m1im3i = m1i-m3i, m2im3i = m2i-m3i;
        Real Eh = b0*(1-m1i)/(1-m1) + m1i*h1; // ko
        Real Eh2 = b0*b0*((1+m1)*(1-m2i)/(1-m2)
                          - 2*m1*m1im2i/(m1-m2))/(1-m1)
            + 2*b0*m1*m1im2i*h1/(m1-m2)
            + m2i*h1*h1; // ko
        Real Eh3 = pow<3>(b0)*(
            (1-m3i)/(1-m3)
            + 3*m2*((1-m3i)/(1-m3)-m2im3i/(m2-m3))/(1-m2) 
            + 3*m1*((1-m3i)/(1-m3)-m1im3i/(m1-m3))/(1-m1) 
            + 6*m1*m2*(
                       ((1-m3i)/(1-m3)-m2im3i/(m2-m3))/(1-m2)
                       + (m2im3i/(m2-m3)-m1im3i/(m1-m3))/(m1-m2)
                       )/(1-m1))
            + 3*b0*b0*m1*h1*(m1im3i/(m1-m3)
                        +2*m2*(m1im3i/(m1-m3)-m2im3i/(m2-m3))/(m1-m2))
            + 3*b0*m2*h1*h1*m2im3i/(m2-m3) 
            + m3i*h1*h1*h1; // ko
        Real Eh3_2 = .375*std::pow(Eh,-0.5)*Eh2+.625*std::pow(Eh,1.5);
        Real Eh5_2 = 1.875*std::pow(Eh,0.5)*Eh2-.875*std::pow(Eh,2.5);
        sEh += Eh;
        sEh2 += Eh2;
        sEh3 += Eh3;
        for (j = 0; j < T-i-1; ++j) {
            Real Ehh = b0*Eh*(1-m1ai[j+1])/(1-m1)+ Eh2*m1ai[j+1]; // ko
            Real Ehh2 = b0*b0*Eh*((1+m1)*(1-m2ai[j+1])/(1-m2) 
                          - 2*m1*(m1ai[j+1]
                                  -m2ai[j+1])/(m1-m2))/(1-m1)
                + 2*b0*m1*Eh2*(m1ai[j+1]-m2ai[j+1])/(m1-m2)
                + m2ai[j+1]*Eh3; // ko
            Real Eh2h = b0*Eh2*(1-m1ai[j+1])/(1-m1) 
                + m1ai[j+1]*Eh3; // ok
            Real Eh1_2eh = v1*m1ai[j]*Eh3_2; // ko
            Real Eh1_2eh2 = 2*b0*v1*(m1ai[j+1]
                                     -m2ai[j+1])*Eh3_2/(m1-m2) 
                + v2*m2ai[j]*Eh5_2; // ko
            Real Ehij = b0*(1-m1ai[i+j+1])/(1-m1) 
                + m1ai[i+j+1]*h1; // ko
            Real Ehh3_2 = 0.375*Ehh2/std::sqrt(Ehij) 
                + 0.75*std::sqrt(Ehij)*Ehh 
                - 0.125*std::pow(Ehij,1.5)*Eh; // ko
            Real Eh3_2eh = v1*m1ai[j]*Eh5_2; // ko
            Real Eh3_2e3h = x1*m1ai[j]*Eh5_2; // ok
            Real Eh1_2eh3_2 = 0.375*Eh1_2eh2/std::sqrt(Ehij) 
                + 0.75*std::sqrt(Ehij)*Eh1_2eh; // ko
            sEhh += Ehh;
            sEh1_2eh += Eh1_2eh;
            sEhh2 += Ehh2; 
            sEh2h += Eh2h;
            sEh1_2eh2 += Eh1_2eh2;
            sEh3_2eh += Eh3_2eh;
            sEhe2h += b0*Eh*(1-m1ai[j+1])/(1-m1) 
                + z1*m1ai[j]*Eh2; // ko
            sEh3_2e3h += Eh3_2e3h; // ok
            for (k = 0; k < T-i-j-2; ++k) {
                Real Ehhh = b0*Ehh*(1-m1ai[k+1])/(1-m1) 
                    + m1ai[k+1]*Ehh2; //ko
                Real Eh1_2ehh = b0*Eh1_2eh*(1-m1ai[k+1])/(1-m1) 
                    + m1ai[k+1]*Eh1_2eh2; // ko
                sEhhh += Ehhh;
                sEh1_2ehh += Eh1_2ehh;
                sEhh1_2eh += v1*m1ai[k]*Ehh3_2; // ko
                sEh1_2eh1_2eh += v1*m1ai[k]*Eh1_2eh3_2; // ko
            }
        }
    }

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/pricingengines/vanilla/mchestonhullwhiteengine.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size j=0; j < states.size(); ++j) {
    states[j] = path[j][path.pathSize()-1];
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/pricingengines/vanilla/fdhestonhullwhitevanillaengine.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i < cachedArgs2results_.size(); ++i) {
    if (   cachedArgs2results_[i].first.exercise->type()
                == arguments_.exercise->type()
        && cachedArgs2results_[i].first.exercise->dates()
                == arguments_.exercise->dates()) {
        boost::shared_ptr<PlainVanillaPayoff> p1 =
            boost::dynamic_pointer_cast<PlainVanillaPayoff>(
                                                    arguments_.payoff);
        boost::shared_ptr<PlainVanillaPayoff> p2 =
            boost::dynamic_pointer_cast<PlainVanillaPayoff>(
                                  cachedArgs2results_[i].first.payoff);

        if (p1 && p1->strike()     == p2->strike()
               && p1->optionType() == p2->optionType()) {
            QL_REQUIRE(arguments_.cashFlow.empty(),
                       "multiple strikes engine does "
                       "not work with discrete dividends");
            results_ = cachedArgs2results_[i].second;
            return;
        }
    }
}

for (Size i=0; i < strikes_.size(); ++i) {
    cachedArgs2results_[i].first.exercise = arguments_.exercise;
    cachedArgs2results_[i].first.payoff = 
        boost::shared_ptr<PlainVanillaPayoff>(
            new PlainVanillaPayoff(payoff->optionType(), strikes_[i]));
    const Real d = payoff->strike()/strikes_[i];
    
    DividendVanillaOption::results& 
                        results = cachedArgs2results_[i].second;
    results.value = solver->valueAt(spot*d, v0, 0)/d;
    results.delta = solver->deltaAt(spot*d, v0, 0, spot*d*0.01);
    results.gamma = solver->gammaAt(spot*d, v0, 0, spot*d*0.01)*d;
    results.theta = solver->thetaAt(spot*d, v0, 0)/d;
}

    for (Size i=0; i < strikes_.size(); ++i) {
        VanillaOption controlVariateOption(
            boost::shared_ptr<StrikedTypePayoff>(
                new PlainVanillaPayoff(payoff->optionType(), 
                                       strikes_[i])), exercise);
        controlVariateOption.setPricingEngine(analyticEngine);
        analyticNPV = controlVariateOption.NPV();
        
        controlVariateOption.setPricingEngine(fdEngine);
        fdNPV = controlVariateOption.NPV();
        cachedArgs2results_[i].second.value += analyticNPV - fdNPV;
    }

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/pricingengines/vanilla/fdhestonvanillaengine.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i < cachedArgs2results_.size(); ++i) {
    if (   cachedArgs2results_[i].first.exercise->type()
                == arguments_.exercise->type()
        && cachedArgs2results_[i].first.exercise->dates()
                == arguments_.exercise->dates()) {
        boost::shared_ptr<PlainVanillaPayoff> p1 =
            boost::dynamic_pointer_cast<PlainVanillaPayoff>(
                                                    arguments_.payoff);
        boost::shared_ptr<PlainVanillaPayoff> p2 =
            boost::dynamic_pointer_cast<PlainVanillaPayoff>(
                                  cachedArgs2results_[i].first.payoff);

        if (p1 && p1->strike()     == p2->strike()
               && p1->optionType() == p2->optionType()) {
            QL_REQUIRE(arguments_.cashFlow.empty(),
                       "multiple strikes engine does "
                       "not work with discrete dividends");
            results_ = cachedArgs2results_[i].second;
            return;
        }
    }
}

for (Size i=0; i < strikes_.size(); ++i) {
    cachedArgs2results_[i].first.exercise = arguments_.exercise;
    cachedArgs2results_[i].first.payoff = 
        boost::shared_ptr<PlainVanillaPayoff>(
            new PlainVanillaPayoff(payoff->optionType(), strikes_[i]));
    const Real d = payoff->strike()/strikes_[i];
    
    DividendVanillaOption::results& 
                        results = cachedArgs2results_[i].second;
    results.value = solver->valueAt(spot*d, v0)/d;
    results.delta = solver->deltaAt(spot*d, v0);
    results.gamma = solver->gammaAt(spot*d, v0)*d;
    results.theta = solver->thetaAt(spot*d, v0)/d;                
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/pricingengines/vanilla/analyticdividendeuropeanengine.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (i=0; i<arguments_.cashFlow.size(); i++)
    if (arguments_.cashFlow[i]->date() >= settlementDate)
        riskless += arguments_.cashFlow[i]->amount() *
            process_->riskFreeRate()->discount(
                                      arguments_.cashFlow[i]->date());

for (i = 0; i < arguments_.cashFlow.size(); i++) {
    Date d = arguments_.cashFlow[i]->date();
    if (d >= settlementDate) {
        delta_theta -= arguments_.cashFlow[i]->amount() *
          process_->riskFreeRate()->zeroRate(d,rfdc,Continuous,Annual)*
          process_->riskFreeRate()->discount(d);
        Time t = process_->time(d);
        delta_rho += arguments_.cashFlow[i]->amount() * t *
                     process_->riskFreeRate()->discount(t);
    }
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/pricingengines/vanilla/analyticptdhestonengine.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i <timeGrid_.size()-1; ++i) {
    const Time begin = std::min(term_, timeGrid_[i]);
    const Time end   = std::min(term_, timeGrid_[i+1]);
    r_[i] = model->riskFreeRate()
            ->forwardRate(begin, end, Continuous, NoFrequency).rate();
    q_[i] = model->dividendYield()
            ->forwardRate(begin, end, Continuous, NoFrequency).rate();
}            

for (Size i=timeGrid_.size()-1; i > 0; --i) {
    const Time begin = timeGrid_[i-1];
    if (begin < term_) {
        const Time end = std::min(term_, timeGrid_[i]);
        const Time tau = end-begin;
        const Time t   = 0.5*(end+begin);
        
        const Real rho = model_->rho(t);
        const Real sigma = model_->sigma(t);
        const Real kappa = model_->kappa(t);
        const Real theta = model_->theta(t);
        
        const Real sigma2 = sigma*sigma;
        const Real t0 = kappa - ((j_== 1)? rho*sigma : 0);
        const Real rpsig = rho*sigma*phi;

        const std::complex<Real> t1 = t0+std::complex<Real>(0, -rpsig);
        const std::complex<Real> d  = std::sqrt(t1*t1 - sigma2*phi
                         *std::complex<Real>(-phi, (j_== 1)? 1 : -1));
        const std::complex<Real> g = (t1-d)/(t1+d);
        const std::complex<Real> gt 
                               = (t1-d - D*sigma2)/(t1+d - D*sigma2);
        
        D = (t1+d)/sigma2*(g-gt*std::exp(-d*tau))
            /(1.0-gt*std::exp(-d*tau));
        
        const std::complex<Real> lng 
            = std::log((1.0 - gt*std::exp(-d*tau))/(1.0 - gt));
        
        C =(kappa*theta)/sigma2*((t1-d)*tau-2.0*lng)
            + std::complex<Real>(0.0, phi*(r_[i-1]-q_[i-1])*tau) + C;
    }
}

for (Size i=1; i <= n; ++i) {
    const Time t = 0.5*(timeGrid[i-1] + timeGrid[i]);
    kappaAvg += model_->kappa(t);
    thetaAvg += model_->theta(t);
    sigmaAvg += model_->sigma(t);
    rhoAvg   += model_->rho(t);
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/pricingengines/barrier/mcbarrierengine.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    for (i = 0; i < n-1; i++) {
        new_asset_price = path[i+1];
        // terminal or initial vol?
        vol = diffProcess_->diffusion(timeGrid[i],asset_price);
        dt = timeGrid.dt(i);

        x = std::log(new_asset_price / asset_price);
        y = 0.5*(x - std::sqrt (x*x - 2*vol*vol*dt*std::log(u[i])));
        y = asset_price * std::exp(y);
        if (y <= barrier_) {
            isOptionActive = true;
            if (knockNode == null)
                knockNode = i+1;
        }
        asset_price = new_asset_price;
    }

    for (i = 0; i < n-1; i++) {
        new_asset_price = path[i+1];
        // terminal or initial vol?
        vol = diffProcess_->diffusion(timeGrid[i],asset_price);
        dt = timeGrid.dt(i);

        x = std::log(new_asset_price / asset_price);
        y = 0.5*(x + std::sqrt(x*x - 2*vol*vol*dt*std::log((1-u[i]))));
        y = asset_price * std::exp(y);
        if (y >= barrier_) {
            isOptionActive = true;
            if (knockNode == null)
                knockNode = i+1;
        }
        asset_price = new_asset_price;
    }

    for (i = 0; i < n-1; i++) {
        new_asset_price = path[i+1];
        // terminal or initial vol?
        vol = diffProcess_->diffusion(timeGrid[i],asset_price);
        dt = timeGrid.dt(i);

        x = std::log(new_asset_price / asset_price);
        y = 0.5*(x - std::sqrt(x*x - 2*vol*vol*dt*std::log(u[i])));
        y = asset_price * std::exp(y);
        if (y <= barrier_) {
            isOptionActive = false;
            if (knockNode == null)
                knockNode = i+1;
        }
        asset_price = new_asset_price;
    }

    for (i = 0; i < n-1; i++) {
        new_asset_price = path[i+1];
        // terminal or initial vol?
        vol = diffProcess_->diffusion(timeGrid[i],asset_price);
        dt = timeGrid.dt(i);

        x = std::log(new_asset_price / asset_price);
        y = 0.5*(x + std::sqrt(x*x - 2*vol*vol*dt*std::log((1-u[i]))));
        y = asset_price * std::exp(y);
        if (y >= barrier_) {
            isOptionActive = false;
            if (knockNode == null)
                knockNode = i+1;
        }
        asset_price = new_asset_price;
    }

    for (i = 1; i < n; i++) {
        asset_price = path[i];
        if (asset_price <= barrier_) {
            isOptionActive = true;
            if (knockNode == null)
                knockNode = i;
        }
    }

    for (i = 1; i < n; i++) {
        asset_price = path[i];
        if (asset_price >= barrier_) {
            isOptionActive = true;
            if (knockNode == null)
                knockNode = i;
        }
    }

    for (i = 1; i < n; i++) {
        asset_price = path[i];
        if (asset_price <= barrier_) {
            isOptionActive = false;
            if (knockNode == null)
                knockNode = i;
        }
    }

    for (i = 1; i < n; i++) {
        asset_price = path[i];
        if (asset_price >= barrier_) {
            isOptionActive = false;
            if (knockNode == null)
                knockNode = i;
        }
    }

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/pricingengines/barrier/discretizedbarrieroption.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i<stoppingTimes_.size(); ++i) {
    stoppingTimes_[i] =
        process.time(args.exercise->date(i));
    if (!grid.empty()) {
        // adjust to the given grid
        stoppingTimes_[i] = grid.closestTime(stoppingTimes_[i]);
    }
}

    for (Size i=0; i<stoppingTimes_.size(); i++) {
        if (isOnTime(stoppingTimes_[i])) {
            stoppingTime = true;
            break;
        }
    }

for (Size j=0; j<optvalues.size(); j++) {
    switch (arguments_.barrierType) {
      case Barrier::DownIn:
          if (grid[j] <= arguments_.barrier) {
             // knocked in
             if (stoppingTime) {
                optvalues[j] = std::max(vanilla_.values()[j],
                              (*arguments_.payoff)(grid[j]));
             }
             else
                 optvalues[j] = vanilla_.values()[j]; 
          }
          else if (endTime)
              optvalues[j] = arguments_.rebate;
          break;
      case Barrier::DownOut:
          if (grid[j] <= arguments_.barrier)
              optvalues[j] = arguments_.rebate; // knocked out
          else if (stoppingTime) {
              optvalues[j] = std::max(optvalues[j],
                             (*arguments_.payoff)(grid[j]));
          }
          break;
      case Barrier::UpIn:
          if (grid[j] >= arguments_.barrier) {
             // knocked in
             if (stoppingTime) {
                 optvalues[j] = std::max(vanilla_.values()[j],
                              (*arguments_.payoff)(grid[j]));
             }
             else
                 optvalues[j] = vanilla_.values()[j]; 
          }
          else if (endTime)
              optvalues[j] = arguments_.rebate;
          break;
      case Barrier::UpOut:
          if (grid[j] >= arguments_.barrier)
             optvalues[j] = arguments_.rebate; // knocked out
          else if (stoppingTime)
              optvalues[j] = std::max(optvalues[j],
                             (*arguments_.payoff)(grid[j]));
          break;
      default:
          QL_FAIL("invalid barrier type");
    }
}

      for (Size j=0; j<optvalues.size()-1; ++j) {
          if (grid[j]<=barrier && grid[j+1] > barrier) {
              // grid[j+1] above barrier, grid[j] under (in),
              // interpolate optvalues[j+1]
              Real ltob = (barrier-grid[j]);
              Real htob = (grid[j+1]-barrier);
              Real htol = (grid[j+1]-grid[j]);
              Real u1 = unenhanced_.values()[j+1];
              Real t1 = unenhanced_.vanilla()[j+1];
              optvalues[j+1] = std::max(0.0, (ltob*t1+htob*u1)/htol);
          }
      }

      for (Size j=0; j<optvalues.size()-1; ++j) {
          if (grid[j]<=barrier && grid[j+1] > barrier) {
              // grid[j+1] above barrier, grid[j] under (out),
              // interpolate optvalues[j+1]
              Real a = (barrier-grid[j])*rebate;
              Real b = (grid[j+1]-barrier)*unenhanced_.values()[j+1];
              Real c = (grid[j+1]-grid[j]);
              optvalues[j+1] = std::max(0.0, (a+b)/c);
          }
      }

      for (Size j=0; j<optvalues.size()-1; ++j) {
          if (grid[j] < barrier && grid[j+1] >= barrier) {
              // grid[j+1] above barrier (in), grid[j] under, 
              // interpolate optvalues[j]
              Real ltob = (barrier-grid[j]);
              Real htob = (grid[j+1]-barrier);
              Real htol = (grid[j+1]-grid[j]);
              Real u = unenhanced_.values()[j];
              Real t = unenhanced_.vanilla()[j];
              optvalues[j] = std::max(0.0, (ltob*u+htob*t)/htol); // derman std
          }
       }

      for (Size j=0; j<optvalues.size()-1; ++j) {
          if (grid[j] < barrier && grid[j+1] >= barrier) {
              // grid[j+1] above barrier (out), grid[j] under, 
              // interpolate optvalues[j]
              Real a = (barrier-grid[j])*unenhanced_.values()[j];
              Real b = (grid[j+1]-barrier)*rebate;
              Real c = (grid[j+1]-grid[j]);
              optvalues[j] = std::max(0.0, (a+b)/c);
          }
      }

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/pricingengines/capfloor/blackcapfloorengine.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i<optionlets; ++i) {
    Date paymentDate = arguments_.endDates[i];
    // handling of settlementDate, npvDate and includeSettlementFlows
    // should be implemented.
    // For the time being just discard expired caplets
    if (paymentDate > settlement) {
        DiscountFactor d = arguments_.nominals[i] *
                           arguments_.gearings[i] *
                           discountCurve_->discount(paymentDate) *
                           arguments_.accrualTimes[i];

        Rate forward = arguments_.forwards[i];

        Date fixingDate = arguments_.fixingDates[i];
        Time sqrtTime = 0.0;
        if (fixingDate > today)
            sqrtTime = std::sqrt(vol_->timeFromReference(fixingDate));

        if (type == CapFloor::Cap || type == CapFloor::Collar) {
            Rate strike = arguments_.capRates[i];
            if (sqrtTime>0.0) {
                stdDevs[i] = std::sqrt(vol_->blackVariance(fixingDate,
                                                           strike));
                vegas[i] = blackFormulaStdDevDerivative(strike,
                    forward, stdDevs[i], d, displacement_) * sqrtTime;
            }
            // include caplets with past fixing date
            values[i] = blackFormula(Option::Call,
                strike, forward, stdDevs[i], d, displacement_);
        }
        if (type == CapFloor::Floor || type == CapFloor::Collar) {
            Rate strike = arguments_.floorRates[i];
            Real floorletVega = 0.0;
            if (sqrtTime>0.0) {
                stdDevs[i] = std::sqrt(vol_->blackVariance(fixingDate,
                                                           strike));
                floorletVega = blackFormulaStdDevDerivative(strike,
                    forward, stdDevs[i], d, displacement_) * sqrtTime;
            }
            Real floorlet = blackFormula(Option::Put,
                strike, forward, stdDevs[i], d, displacement_);
            if (type == CapFloor::Floor) {
                values[i] = floorlet;
                vegas[i] = floorletVega;
            } else {
                // a collar is long a cap and short a floor
                values[i] -= floorlet;
                vegas[i] -= floorletVega;
            }
        }
        value += values[i];
        vega += vegas[i];
    }
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/pricingengines/capfloor/analyticcapfloorengine.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i<nPeriods; i++) {

    Time fixingTime =
        dayCounter.yearFraction(referenceDate,
                                arguments_.fixingDates[i]);
    Time paymentTime =
        dayCounter.yearFraction(referenceDate,
                                arguments_.endDates[i]);

    bool not_expired =
        includeRefDatePayments ? paymentTime >= 0.0 : paymentTime > 0.0;

    if (not_expired) {
        Time tenor = arguments_.accrualTimes[i];
        Rate fixing = arguments_.forwards[i];
        if (fixingTime <= 0.0) {
            if (type == CapFloor::Cap || type == CapFloor::Collar) {
                DiscountFactor discount = model_->discount(paymentTime);
                Rate strike = arguments_.capRates[i];
                value += discount * arguments_.nominals[i] * tenor
                       * arguments_.gearings[i]
                       * std::max(0.0, fixing - strike);
            }
            if (type == CapFloor::Floor || type == CapFloor::Collar) {
                DiscountFactor discount = model_->discount(paymentTime);
                Rate strike = arguments_.floorRates[i];
                Real mult = (type == CapFloor::Floor) ? 1.0 : -1.0;
                value += discount * arguments_.nominals[i] * tenor
                       * mult * arguments_.gearings[i]
                       * std::max(0.0, strike - fixing);
            }
        } else {
            Time maturity =
                dayCounter.yearFraction(referenceDate,
                                        arguments_.startDates[i]);
            if (type == CapFloor::Cap || type == CapFloor::Collar) {
                Real temp = 1.0+arguments_.capRates[i]*tenor;
                value += arguments_.nominals[i] *
                    arguments_.gearings[i] * temp *
                    model_->discountBondOption(Option::Put, 1.0/temp,
                                               maturity, paymentTime);
            }
            if (type == CapFloor::Floor || type == CapFloor::Collar) {
                Real temp = 1.0+arguments_.floorRates[i]*tenor;
                Real mult = (type == CapFloor::Floor) ? 1.0 : -1.0;
                value += arguments_.nominals[i] *
                    arguments_.gearings[i] * temp * mult *
                    model_->discountBondOption(Option::Call, 1.0/temp,
                                               maturity, paymentTime);
            }
        }
    }
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/pricingengines/capfloor/bacheliercapfloorengine.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i<optionlets; ++i) {
    Date paymentDate = arguments_.endDates[i];
    // handling of settlementDate, npvDate and includeSettlementFlows
    // should be implemented.
    // For the time being just discard expired caplets
    if (paymentDate > settlement) {
        DiscountFactor d = arguments_.nominals[i] *
                           arguments_.gearings[i] *
                           discountCurve_->discount(paymentDate) *
                           arguments_.accrualTimes[i];

        Rate forward = arguments_.forwards[i];

        Date fixingDate = arguments_.fixingDates[i];
        Time sqrtTime = 0.0;
        if (fixingDate > today)
            sqrtTime = std::sqrt(vol_->timeFromReference(fixingDate));

        if (type == CapFloor::Cap || type == CapFloor::Collar) {
            Rate strike = arguments_.capRates[i];
            if (sqrtTime>0.0) {
                stdDevs[i] = std::sqrt(vol_->blackVariance(fixingDate,
                                                           strike));
                vegas[i] = bachelierBlackFormulaStdDevDerivative(strike,
                    forward, stdDevs[i], d) * sqrtTime;
            }
            // include caplets with past fixing date
            values[i] = bachelierBlackFormula(Option::Call,
                strike, forward, stdDevs[i], d);
        }
        if (type == CapFloor::Floor || type == CapFloor::Collar) {
            Rate strike = arguments_.floorRates[i];
            Real floorletVega = 0.0;
            if (sqrtTime>0.0) {
                stdDevs[i] = std::sqrt(vol_->blackVariance(fixingDate,
                                                           strike));
                floorletVega = bachelierBlackFormulaStdDevDerivative(strike,
                    forward, stdDevs[i], d) * sqrtTime;
            }
            Real floorlet = bachelierBlackFormula(Option::Put,
                strike, forward, stdDevs[i], d);
            if (type == CapFloor::Floor) {
                values[i] = floorlet;
                vegas[i] = floorletVega;
            } else {
                // a collar is long a cap and short a floor
                values[i] -= floorlet;
                vegas[i] -= floorletVega;
            }
        }
        value += values[i];
        vega += vegas[i];
    }
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/pricingengines/capfloor/discretizedcapfloor.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i<startTimes_.size(); ++i)
    startTimes_[i] = dayCounter.yearFraction(referenceDate,
                                             args.startDates[i]);

for (Size i=0; i<endTimes_.size(); ++i)
    endTimes_[i] = dayCounter.yearFraction(referenceDate,
                                           args.endDates[i]);

for (Size i=0; i<startTimes_.size(); i++) {
    if (isOnTime(startTimes_[i])) {
        Time end = endTimes_[i];
        Time tenor = arguments_.accrualTimes[i];
        DiscretizedDiscountBond bond;
        bond.initialize(method(), end);
        bond.rollback(time_);

        CapFloor::Type type = arguments_.type;
        Real gearing = arguments_.gearings[i];
        Real nominal = arguments_.nominals[i];

        if ( (type == CapFloor::Cap) ||
             (type == CapFloor::Collar)) {
            Real accrual = 1.0 + arguments_.capRates[i]*tenor;
            Real strike = 1.0/accrual;
            for (Size j=0; j<values_.size(); j++)
                values_[j] += nominal*accrual*gearing*
                    std::max<Real>(strike - bond.values()[j], 0.0);
        }

        if ( (type == CapFloor::Floor) ||
             (type == CapFloor::Collar)) {
            Real accrual = 1.0 + arguments_.floorRates[i]*tenor;
            Real strike = 1.0/accrual;
            Real mult = (type == CapFloor::Floor)?1.0:-1.0;
            for (Size j=0; j<values_.size(); j++)
                values_[j] += nominal*accrual*mult*gearing*
                    std::max<Real>(bond.values()[j] - strike, 0.0);
        }
    }
}

for (Size i=0; i<endTimes_.size(); i++) {
    if (isOnTime(endTimes_[i])) {
        if (startTimes_[i] < 0.0) {
            Real nominal = arguments_.nominals[i];
            Time accrual = arguments_.accrualTimes[i];
            Rate fixing = arguments_.forwards[i];
            Real gearing = arguments_.gearings[i];
            CapFloor::Type type = arguments_.type;

            if (type == CapFloor::Cap || type == CapFloor::Collar) {
                Rate cap = arguments_.capRates[i];
                Rate capletRate = std::max(fixing-cap, 0.0);
                values_ += capletRate*accrual*nominal*gearing;
            }

            if (type == CapFloor::Floor || type == CapFloor::Collar) {
                Rate floor = arguments_.floorRates[i];
                Rate floorletRate = std::max(floor-fixing, 0.0);
                if (type == CapFloor::Floor)
                    values_ += floorletRate*accrual*nominal*gearing;
                else
                    values_ -= floorletRate*accrual*nominal*gearing;
            }
        }
    }
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/pricingengines/capfloor/mchullwhiteengine.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    for (Size i=0; i<startTimes_.size(); ++i)
        startTimes_[i] = dayCounter.yearFraction(referenceDate,
                                                 args.startDates[i]);

    for (Size i=0; i<endTimes_.size(); ++i)
        endTimes_[i] = dayCounter.yearFraction(referenceDate,
                                               args.endDates[i]);

    for (Size i=0; i<fixingTimes_.size(); ++i)
        fixingTimes_[i] = dayCounter.yearFraction(referenceDate,
                                                  args.fixingDates[i]);

    for (Size i = 0; i<fixingTimes_.size(); i++) {
        Time tau = args_.accrualTimes[i];
        Time start = startTimes_[i],
             end = endTimes_[i],
             fixing = fixingTimes_[i];
        if (end <= 0.0) {
            // the fixing is in the past...
            pastFixings++;
            // ...and the caplet is expired; nothing more to do.
        } else {
            Rate ri_1, ri_2, currentLibor;
            if (fixing <= 0.0) {
                // current caplet. The fixing is in the past...
                pastFixings++;
                // ...so it is determined.
                currentLibor = args_.forwards[i];
                // However, the short rate at caplet expiry is not.
                ri_2 = path[i-pastFixings+2];
            } else {
                // future caplet. Everything is to be forecast.
                // The number of past fixings is used as an offset
                // to index into the path.
                ri_1 = path[i-pastFixings+1];
                ri_2 = path[i-pastFixings+2];

                DiscountFactor d1 =
                    model_->discountBond(fixing, start, ri_1);
                DiscountFactor d2 =
                    model_->discountBond(fixing, end, ri_1);
                currentLibor = (d1/d2-1)/tau;
            }

            Real accrualFactor =
                1.0/model_->discountBond(end, Tb, ri_2);

            Rate strike = isCap?
                args_.capRates[i] :
                args_.floorRates[i];
            Real payoff = isCap?
                std::max(currentLibor - strike, 0.0) :
            std::max(strike - currentLibor, 0.0);

            npv += payoff * tau * args_.gearings[i] *
                   args_.nominals[i] * accrualFactor;
        }
    }

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/pricingengines/capfloor/gaussian1dcapfloorengine.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i = 0; i < arguments_.spreads.size(); i++)
    QL_REQUIRE(arguments_.spreads[i] == 0.0,
               "Non zero spreads (" << arguments_.spreads[i]
                                    << ") are not allowed.");

for (Size i = 0; i < optionlets; ++i) {

    Date valueDate = arguments_.startDates[i];
    Date paymentDate = arguments_.endDates[i];
    boost::shared_ptr<IborIndex> iborIndex =
        boost::dynamic_pointer_cast<IborIndex>(arguments_.indexes[i]);
    // if we do not find an ibor index with associated forwarding curve
    // we fall back on the model curve

    if (paymentDate > settlement) {

        Real f = arguments_.nominals[i] * arguments_.gearings[i];
        Date fixingDate = arguments_.fixingDates[i];
        Time fixingTime =
            model_->termStructure()->timeFromReference(fixingDate);

        Real strike;

        if (type == CapFloor::Cap || type == CapFloor::Collar) {
            strike = arguments_.capRates[i];
            if (fixingDate <= settlement) {
                values[i] =
                    std::max(arguments_.forwards[i] - strike, 0.0) * f *
                    arguments_.accrualTimes[i];
            } else {

                // todo add openmp support later on (as in gaussian1dswaptionengine)

                for (Size j = 0; j < z.size(); j++) {
                    Real floatingLegNpv;
                    if (iborIndex != NULL)
                        floatingLegNpv =
                            arguments_.accrualTimes[i] *
                            model_->forwardRate(fixingDate, fixingDate,
                                                z[j], iborIndex) *
                            model_->zerobond(paymentDate, fixingDate,
                                             z[j], discountCurve_);
                    else
                        floatingLegNpv =
                            (model_->zerobond(valueDate, fixingDate,
                                              z[j]) -
                             model_->zerobond(paymentDate, fixingDate,
                                              z[j]));
                    Real fixedLegNpv =
                        arguments_.capRates[i] *
                        arguments_.accrualTimes[i] *
                        model_->zerobond(paymentDate, fixingDate, z[j]);
                    p[j] =
                        std::max((floatingLegNpv - fixedLegNpv), 0.0) /
                        model_->numeraire(fixingTime, z[j],
                                          discountCurve_);
                }
                CubicInterpolation payoff(
                    z.begin(), z.end(), p.begin(),
                    CubicInterpolation::Spline, true,
                    CubicInterpolation::Lagrange, 0.0,
                    CubicInterpolation::Lagrange, 0.0);
                Real price = 0.0;
                for (Size j = 0; j < z.size() - 1; j++) {
                    price += model_->gaussianShiftedPolynomialIntegral(
                        0.0, payoff.cCoefficients()[j],
                        payoff.bCoefficients()[j],
                        payoff.aCoefficients()[j], p[j], z[j], z[j],
                        z[j + 1]);
                }
                if (extrapolatePayoff_) {
                    if (flatPayoffExtrapolation_) {
                        price +=
                            model_->gaussianShiftedPolynomialIntegral(
                                0.0, 0.0, 0.0, 0.0, p[z.size() - 2],
                                z[z.size() - 2], z[z.size() - 1],
                                100.0);
                        price +=
                            model_->gaussianShiftedPolynomialIntegral(
                                0.0, 0.0, 0.0, 0.0, p[0], z[0], -100.0,
                                z[0]);
                    } else {
                        price +=
                            model_->gaussianShiftedPolynomialIntegral(
                                0.0,
                                payoff.cCoefficients()[z.size() - 2],
                                payoff.bCoefficients()[z.size() - 2],
                                payoff.aCoefficients()[z.size() - 2],
                                p[z.size() - 2], z[z.size() - 2],
                                z[z.size() - 1], 100.0);
                    }
                }
                values[i] =
                    price *
                    model_->numeraire(0.0, 0.0, discountCurve_) * f;
            }
        }
        if (type == CapFloor::Floor || type == CapFloor::Collar) {
            strike = arguments_.floorRates[i];
            Real floorlet;
            if (fixingDate <= settlement) {
                floorlet =
                    std::max(-(arguments_.forwards[i] - strike), 0.0) *
                    f * arguments_.accrualTimes[i];
            } else {
                for (Size j = 0; j < z.size(); j++) {
                    Real floatingLegNpv;
                    if (iborIndex != NULL)
                        floatingLegNpv =
                            arguments_.accrualTimes[i] *
                            model_->forwardRate(fixingDate, fixingDate,
                                                z[j], iborIndex) *
                            model_->zerobond(paymentDate, fixingDate,
                                             z[j], discountCurve_);
                    else
                        floatingLegNpv =
                            (model_->zerobond(valueDate, fixingDate,
                                              z[j]) -
                             model_->zerobond(paymentDate, fixingDate,
                                              z[j]));
                    Real fixedLegNpv =
                        arguments_.floorRates[i] *
                        arguments_.accrualTimes[i] *
                        model_->zerobond(paymentDate, fixingDate, z[j]);
                    p[j] =
                        std::max(-(floatingLegNpv - fixedLegNpv), 0.0) /
                        model_->numeraire(fixingTime, z[j],
                                          discountCurve_);
                }
                CubicInterpolation payoff(
                    z.begin(), z.end(), p.begin(),
                    CubicInterpolation::Spline, true,
                    CubicInterpolation::Lagrange, 0.0,
                    CubicInterpolation::Lagrange, 0.0);
                Real price = 0.0;
                for (Size j = 0; j < z.size() - 1; j++) {
                    price += model_->gaussianShiftedPolynomialIntegral(
                        0.0, payoff.cCoefficients()[j],
                        payoff.bCoefficients()[j],
                        payoff.aCoefficients()[j], p[j], z[j], z[j],
                        z[j + 1]);
                }
                if (extrapolatePayoff_) {
                    if (flatPayoffExtrapolation_) {
                        price +=
                            model_->gaussianShiftedPolynomialIntegral(
                                0.0, 0.0, 0.0, 0.0, p[z.size() - 2],
                                z[z.size() - 2], z[z.size() - 1],
                                100.0);
                        price +=
                            model_->gaussianShiftedPolynomialIntegral(
                                0.0, 0.0, 0.0, 0.0, p[0], z[0], -100.0,
                                z[0]);
                    } else {
                        price +=
                            model_->gaussianShiftedPolynomialIntegral(
                                0.0, payoff.cCoefficients()[0],
                                payoff.bCoefficients()[0],
                                payoff.aCoefficients()[0], p[0], z[0],
                                -100.0, z[0]);
                    }
                }
                floorlet = price *
                           model_->numeraire(0.0, 0.0, discountCurve_) *
                           f;
            }
            if (type == CapFloor::Floor) {
                values[i] = floorlet;
            } else {
                // a collar is long a cap and short a floor
                values[i] -= floorlet;
            }
        }

        value += values[i];
    }
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/pricingengines/swap/discountingswapengine.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i<n; ++i) {
    try {
        const YieldTermStructure& discount_ref = **discountCurve_;
        CashFlows::npvbps(arguments_.legs[i],
                          discount_ref,
                          includeRefDateFlows,
                          settlementDate,
                          results_.valuationDate,
                          results_.legNPV[i],
                          results_.legBPS[i]);
        results_.legNPV[i] *= arguments_.payer[i];
        results_.legBPS[i] *= arguments_.payer[i];

        if (!arguments_.legs[i].empty()) {
            Date d1 = CashFlows::startDate(arguments_.legs[i]);
            if (d1>=refDate)
                results_.startDiscounts[i] = discountCurve_->discount(d1);
            else
                results_.startDiscounts[i] = Null<DiscountFactor>();

            Date d2 = CashFlows::maturityDate(arguments_.legs[i]);
            if (d2>=refDate)
                results_.endDiscounts[i] = discountCurve_->discount(d2);
            else
                results_.endDiscounts[i] = Null<DiscountFactor>();
        } else {
            results_.startDiscounts[i] = Null<DiscountFactor>();
            results_.endDiscounts[i] = Null<DiscountFactor>();
        }

    } catch (std::exception &e) {
        QL_FAIL(io::ordinal(i+1) << " leg: " << e.what());
    }
    results_.value += results_.legNPV[i];
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/pricingengines/swap/discretizedswap.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i<fixedResetTimes_.size(); ++i)
    fixedResetTimes_[i] =
        dayCounter.yearFraction(referenceDate,
                                args.fixedResetDates[i]);

for (Size i=0; i<fixedPayTimes_.size(); ++i)
    fixedPayTimes_[i] =
        dayCounter.yearFraction(referenceDate,
                                args.fixedPayDates[i]);

for (Size i=0; i<floatingResetTimes_.size(); ++i)
    floatingResetTimes_[i] =
        dayCounter.yearFraction(referenceDate,
                                args.floatingResetDates[i]);

for (Size i=0; i<floatingPayTimes_.size(); ++i)
    floatingPayTimes_[i] =
        dayCounter.yearFraction(referenceDate,
                                args.floatingPayDates[i]);

for (Size i=0; i<fixedResetTimes_.size(); i++) {
    Time t = fixedResetTimes_[i];
    if (t >= 0.0)
        times.push_back(t);
}

for (Size i=0; i<fixedPayTimes_.size(); i++) {
    Time t = fixedPayTimes_[i];
    if (t >= 0.0)
        times.push_back(t);
}

for (Size i=0; i<floatingResetTimes_.size(); i++) {
    Time t = floatingResetTimes_[i];
    if (t >= 0.0)
        times.push_back(t);
}

for (Size i=0; i<floatingPayTimes_.size(); i++) {
    Time t = floatingPayTimes_[i];
    if (t >= 0.0)
        times.push_back(t);
}

for (Size i=0; i<floatingResetTimes_.size(); i++) {
    Time t = floatingResetTimes_[i];
    if (t >= 0.0 && isOnTime(t)) {
        DiscretizedDiscountBond bond;
        bond.initialize(method(), floatingPayTimes_[i]);
        bond.rollback(time_);

        Real nominal = arguments_.nominal;
        Time T = arguments_.floatingAccrualTimes[i];
        Spread spread = arguments_.floatingSpreads[i];
        Real accruedSpread = nominal*T*spread;
        for (Size j=0; j<values_.size(); j++) {
            Real coupon = nominal * (1.0 - bond.values()[j])
                        + accruedSpread * bond.values()[j];
            if (arguments_.type == VanillaSwap::Payer)
                values_[j] += coupon;
            else
                values_[j] -= coupon;
        }
    }
}

for (Size i=0; i<fixedResetTimes_.size(); i++) {
    Time t = fixedResetTimes_[i];
    if (t >= 0.0 && isOnTime(t)) {
        DiscretizedDiscountBond bond;
        bond.initialize(method(), fixedPayTimes_[i]);
        bond.rollback(time_);

        Real fixedCoupon = arguments_.fixedCoupons[i];
        for (Size j=0; j<values_.size(); j++) {
            Real coupon = fixedCoupon*bond.values()[j];
            if (arguments_.type == VanillaSwap::Payer)
                values_[j] -= coupon;
            else
                values_[j] += coupon;
        }
    }
}

for (Size i=0; i<fixedPayTimes_.size(); i++) {
    Time t = fixedPayTimes_[i];
    Time reset = fixedResetTimes_[i];
    if (t >= 0.0 && isOnTime(t) && reset < 0.0) {
        Real fixedCoupon = arguments_.fixedCoupons[i];
        if (arguments_.type==VanillaSwap::Payer)
            values_ -= fixedCoupon;
        else
            values_ += fixedCoupon;
    }
}

for (Size i=0; i<floatingPayTimes_.size(); i++) {
    Time t = floatingPayTimes_[i];
    Time reset = floatingResetTimes_[i];
    if (t >= 0.0 && isOnTime(t) && reset < 0.0) {
        Real currentFloatingCoupon = arguments_.floatingCoupons[i];
        QL_REQUIRE(currentFloatingCoupon != Null<Real>(),
                   "current floating coupon not given");
        if (arguments_.type == VanillaSwap::Payer)
            values_ += currentFloatingCoupon;
        else
            values_ -= currentFloatingCoupon;
    }
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/pricingengines/swaption/jamshidianswaptionengine.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    for (Size i=0; i<size; i++) {
        Real dbValue =
            model_->discountBond(maturity_, times_[i], x) / B;
        value -= amounts_[i]*dbValue;
    }

for (Size i=0; i<fixedPayTimes.size(); i++)
    fixedPayTimes[i] = dayCounter.yearFraction(referenceDate,
                                               arguments_.fixedPayDates[i]);

for (Size i=0; i<size; i++) {
    Real fixedPayTime =
        dayCounter.yearFraction(referenceDate,
                                arguments_.fixedPayDates[i]);
    Real strike = model_->discountBond(maturity,
                                       fixedPayTime,
                                       rStar) / B;
    Real dboValue = model_->discountBondOption(
                                       w, strike, maturity, valueTime,
                                       fixedPayTime);
    value += amounts[i]*dboValue;
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/pricingengines/swaption/discretizedswaption.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i<exerciseTimes_.size(); ++i)
    exerciseTimes_[i] =
        dayCounter.yearFraction(referenceDate,
                                arguments_.exercise->date(i));

for (Size i=0; i<arguments_.exercise->dates().size(); i++) {
    Date exerciseDate = arguments_.exercise->date(i);
    for (Size j=0; j<arguments_.fixedPayDates.size(); j++) {
        if (withinNextWeek(exerciseDate,
                           arguments_.fixedPayDates[j])
            // coupons in the future are dealt with below
            && arguments_.fixedResetDates[j] < referenceDate)
            arguments_.fixedPayDates[j] = exerciseDate;
    }
    for (Size j=0; j<arguments_.fixedResetDates.size(); j++) {
        if (withinPreviousWeek(exerciseDate,
                               arguments_.fixedResetDates[j]))
            arguments_.fixedResetDates[j] = exerciseDate;
    }
    for (Size j=0; j<arguments_.floatingResetDates.size(); j++) {
        if (withinPreviousWeek(exerciseDate,
                               arguments_.floatingResetDates[j]))
            arguments_.floatingResetDates[j] = exerciseDate;
    }
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/pricingengines/swaption/treeswaptionengine.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i<stoppingTimes.size(); ++i)
    stoppingTimes[i] =
        dayCounter.yearFraction(referenceDate,
                                arguments_.exercise->date(i));

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/pricingengines/swaption/gaussian1dswaptionengine.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    for (Size i = 0; i < static_cast<Size>(idx - minIdxAlive + 2); ++i) {
        Array npvTmp0(2 * integrationPoints_ + 1, 0.0);
        Array npvTmp1(2 * integrationPoints_ + 1, 0.0);
        npvp0.push_back(npvTmp0);
        npvp1.push_back(npvTmp1);
    }

        for (Size l = k1; l < arguments_.floatingCoupons.size(); l++) {
            model_->forwardRate(arguments_.floatingFixingDates[l],
                                expiry0, 0.0,
                                arguments_.swap->iborIndex());
            model_->zerobond(arguments_.floatingPayDates[l], expiry0,
                             0.0, discountCurve_);
        }

        for (Size l = j1; l < arguments_.fixedCoupons.size(); l++) {
            model_->zerobond(arguments_.fixedPayDates[l], expiry0, 0.0,
                             discountCurve_);
        }

            for (Size i = 0; i < yg.size(); i++) {
                p[i] = payoff0(yg[i], true);
            }

            for (Size i = 0; i < z.size() - 1; i++) {
                price += model_->gaussianShiftedPolynomialIntegral(
                    0.0, payoff1.cCoefficients()[i],
                    payoff1.bCoefficients()[i],
                    payoff1.aCoefficients()[i], p[i], z[i], z[i],
                    z[i + 1]);
            }

            for (Size m = 0; m < npvp0.size(); m++) {
                Real price = 0.0;
                if (expiry1Time != Null<Real>()) {
                    Array yg = model_->yGrid(
                        stddevs_, integrationPoints_, expiry1Time,
                        expiry0Time, expiry0 > settlement ? z[k] : 0.0);
                    CubicInterpolation payoff0(
                        z.begin(), z.end(), npvp1[m].begin(),
                        CubicInterpolation::Spline, true,
                        CubicInterpolation::Lagrange, 0.0,
                        CubicInterpolation::Lagrange, 0.0);
                    for (Size i = 0; i < yg.size(); i++) {
                        p[i] = payoff0(yg[i], true);
                    }
                    CubicInterpolation payoff1(
                        z.begin(), z.end(), p.begin(),
                        CubicInterpolation::Spline, true,
                        CubicInterpolation::Lagrange, 0.0,
                        CubicInterpolation::Lagrange, 0.0);
                    for (Size i = 0; i < z.size() - 1; i++) {
                        price +=
                            model_->gaussianShiftedPolynomialIntegral(
                                0.0, payoff1.cCoefficients()[i],
                                payoff1.bCoefficients()[i],
                                payoff1.aCoefficients()[i], p[i], z[i],
                                z[i], z[i + 1]);
                    }
                    if (extrapolatePayoff_) {
                        if (flatPayoffExtrapolation_) {
                            price +=
                                model_
                                    ->gaussianShiftedPolynomialIntegral(
                                          0.0, 0.0, 0.0, 0.0,
                                          p[z.size() - 2],
                                          z[z.size() - 2],
                                          z[z.size() - 1], 100.0);
                            price +=
                                model_
                                    ->gaussianShiftedPolynomialIntegral(
                                          0.0, 0.0, 0.0, 0.0, p[0],
                                          z[0], -100.0, z[0]);
                        } else {
                            if (type == Option::Call)
                                price +=
                                    model_
                                        ->gaussianShiftedPolynomialIntegral(
                                              0.0,
                                              payoff1.cCoefficients()
                                                  [z.size() - 2],
                                              payoff1.bCoefficients()
                                                  [z.size() - 2],
                                              payoff1.aCoefficients()
                                                  [z.size() - 2],
                                              p[z.size() - 2],
                                              z[z.size() - 2],
                                              z[z.size() - 1], 100.0);
                            if (type == Option::Put)
                                price +=
                                    model_
                                        ->gaussianShiftedPolynomialIntegral(
                                              0.0,
                                              payoff1
                                                  .cCoefficients()[0],
                                              payoff1
                                                  .bCoefficients()[0],
                                              payoff1
                                                  .aCoefficients()[0],
                                              p[0], z[0], -100.0, z[0]);
                        }
                    }
                }

                npvp0[m][k] = price;
            }

            for (Size l = j1; l < arguments_.fixedCoupons.size(); l++) {
                fixedLegNpv +=
                    arguments_.fixedCoupons[l] *
                    model_->zerobond(arguments_.fixedPayDates[l],
                                     expiry0, z[k], discountCurve_);
            }

        for (Size i = 0; i < npvp0.size(); i++)
            npvp1[i].swap(npvp0[i]);

    for (Size i = 0; i < npvp0.size(); i++) {
        prob[i] = npvp1[i][0] *
                  (probabilities_ == Naive
                       ? 1.0
                       : model_->numeraire(0.0, 0.0, discountCurve_));
    }

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/pricingengines/swaption/fdg2swaptionengine.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i < exerciseDates.size(); ++i) {
    const Time t = dc.yearFraction(referenceDate, exerciseDates[i]);
    QL_REQUIRE(t >= 0, "exercise dates must not contain past date");

    t2d[t] = exerciseDates[i];
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/pricingengines/swaption/gaussian1djamshidianswaptionengine.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    for (Size i = startIndex_; i < size; i++) {
        Real dbValue = model_->zerobond(times_[i], maturityDate_, y) /
                       model_->zerobond(valueDate_, maturityDate_, y);
        value -= amounts_[i] * dbValue;
    }

for (Size i = startIndex; i < size; i++) {
    // Real fixedPayTime =
    // dayCounter.yearFraction(referenceDate,arguments_.fixedPayDates[i]);
    Real strike =
        model_->zerobond(arguments_.fixedPayDates[i],
                         arguments_.exercise->date(0), rStar) /
        model_->zerobond(arguments_.fixedResetDates[startIndex],
                         arguments_.exercise->date(0), rStar);
    Real dboValue =
        model_->zerobondOption(w, arguments_.exercise->date(0),
                               arguments_.fixedResetDates[startIndex],
                               arguments_.fixedPayDates[i], strike);
    value += amounts[i] * dboValue;
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/pricingengines/swaption/fdhullwhiteswaptionengine.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i < exerciseDates.size(); ++i) {
    const Time t = dc.yearFraction(referenceDate, exerciseDates[i]);
    QL_REQUIRE(t >= 0, "exercise dates must not contain past date");

    t2d[t] = exerciseDates[i];
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/pricingengines/swaption/gaussian1dnonstandardswaptionengine.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i = fixedIdx; i < arguments_.fixedResetDates.size(); i++) {
    npv -=
        arguments_.fixedCoupons[i] *
        model_->zerobond(arguments_.fixedPayDates[i], expiry, y,
                         discountCurve_) *
        (oas_.empty()
             ? 1.0
             : exp(-oas_->value() *
                   model_->termStructure()->dayCounter().yearFraction(
                       expiry, arguments_.fixedPayDates[i])));
}

for (Size i = fixedIdx; i < arguments_.fixedResetDates.size(); i++) {
    nominalSum += arguments_.fixedNominal[i];
    Real rate = arguments_.fixedRate[i];
    if (close(rate, 0.0))
        rate = 0.03; // this value is at least better than zero
    weightedRate += arguments_.fixedNominal[i] * rate;
    if (arguments_.fixedNominal[i] > 1E-8) // exclude zero nominal periods
        ind += 1.0;
}

    for (Size i = 0; i < static_cast<Size>(idx - minIdxAlive + 2); ++i) {
        Array npvTmp0(2 * integrationPoints_ + 1, 0.0);
        Array npvTmp1(2 * integrationPoints_ + 1, 0.0);
        npvp0.push_back(npvTmp0);
        npvp1.push_back(npvTmp1);
    }

            for (Size i = 0; i < yg.size(); i++) {
                p[i] = payoff0(yg[i], true);
            }

            for (Size i = 0; i < z.size() - 1; i++) {
                price += model_->gaussianShiftedPolynomialIntegral(
                             0.0, payoff1.cCoefficients()[i],
                             payoff1.bCoefficients()[i],
                             payoff1.aCoefficients()[i], p[i], z[i],
                             z[i], z[i + 1]) *
                         zSpreadDf;
            }

            for (Size m = 0; m < npvp0.size(); m++) {
                Real price = 0.0;
                if (expiry1Time != Null<Real>()) {
                    Real zSpreadDf =
                        oas_.empty()
                            ? 1.0
                            : std::exp(-oas_->value() *
                                       (expiry1Time - expiry0Time));
                    Array yg = model_->yGrid(
                        stddevs_, integrationPoints_, expiry1Time,
                        expiry0Time, expiry0 > settlement ? z[k] : 0.0);
                    CubicInterpolation payoff0(
                        z.begin(), z.end(), npvp1[m].begin(),
                        CubicInterpolation::Spline, true,
                        CubicInterpolation::Lagrange, 0.0,
                        CubicInterpolation::Lagrange, 0.0);
                    for (Size i = 0; i < yg.size(); i++) {
                        p[i] = payoff0(yg[i], true);
                    }
                    CubicInterpolation payoff1(
                        z.begin(), z.end(), p.begin(),
                        CubicInterpolation::Spline, true,
                        CubicInterpolation::Lagrange, 0.0,
                        CubicInterpolation::Lagrange, 0.0);
                    for (Size i = 0; i < z.size() - 1; i++) {
                        price +=
                            model_->gaussianShiftedPolynomialIntegral(
                                0.0, payoff1.cCoefficients()[i],
                                payoff1.bCoefficients()[i],
                                payoff1.aCoefficients()[i], p[i], z[i],
                                z[i], z[i + 1]) *
                            zSpreadDf;
                    }
                    if (extrapolatePayoff_) {
                        if (flatPayoffExtrapolation_) {
                            price +=
                                model_
                                    ->gaussianShiftedPolynomialIntegral(
                                          0.0, 0.0, 0.0, 0.0,
                                          p[z.size() - 2],
                                          z[z.size() - 2],
                                          z[z.size() - 1], 100.0) *
                                zSpreadDf;
                            price +=
                                model_
                                    ->gaussianShiftedPolynomialIntegral(
                                          0.0, 0.0, 0.0, 0.0, p[0],
                                          z[0], -100.0, z[0]) *
                                zSpreadDf;
                        } else {
                            if (type == Option::Call)
                                price +=
                                    model_
                                        ->gaussianShiftedPolynomialIntegral(
                                              0.0,
                                              payoff1.cCoefficients()
                                                  [z.size() - 2],
                                              payoff1.bCoefficients()
                                                  [z.size() - 2],
                                              payoff1.aCoefficients()
                                                  [z.size() - 2],
                                              p[z.size() - 2],
                                              z[z.size() - 2],
                                              z[z.size() - 1], 100.0) *
                                    zSpreadDf;
                            if (type == Option::Put)
                                price +=
                                    model_
                                        ->gaussianShiftedPolynomialIntegral(
                                              0.0,
                                              payoff1
                                                  .cCoefficients()[0],
                                              payoff1
                                                  .bCoefficients()[0],
                                              payoff1
                                                  .aCoefficients()[0],
                                              p[0], z[0], -100.0,
                                              z[0]) *
                                    zSpreadDf;
                        }
                    }
                }

                npvp0[m][k] = price;
            }

            for (Size l = j1; l < arguments_.fixedCoupons.size(); l++) {
                Real zSpreadDf =
                    oas_.empty()
                        ? 1.0
                        : std::exp(
                              -oas_->value() *
                              (model_->termStructure()
                                   ->dayCounter()
                                   .yearFraction(
                                        expiry0,
                                        arguments_.fixedPayDates[l])));
                fixedLegNpv +=
                    arguments_.fixedCoupons[l] *
                    model_->zerobond(arguments_.fixedPayDates[l],
                                     expiry0, z[k], discountCurve_) *
                    zSpreadDf;
            }

        for (Size i = 0; i < npvp0.size(); i++)
            npvp1[i].swap(npvp0[i]);

    for (Size i = 0; i < npvp0.size(); i++) {
        prob[i] = npvp1[i][0] *
                  (probabilities_ == Naive
                       ? 1.0
                       : model_->numeraire(0.0, 0.0, discountCurve_));
    }

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/pricingengines/swaption/basketgeneratingengine.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i = minIdxAlive; i < exercise->dates().size(); i++) {

    Date expiry = exercise->date(i);
    Real rebate = 0.0;
    Date rebateDate = expiry;
    if (rebEx != NULL) {
        rebate = rebEx->rebate(i);
        rebateDate = rebEx->rebatePaymentDate(i);
    }

    boost::shared_ptr<SwaptionHelper> helper;

    switch (basketType) {

    case Naive: {
        Real swapLength = swaptionVolatility->dayCounter().yearFraction(
            standardSwapBase->valueDate(expiry), underlyingLastDate());
        boost::shared_ptr<SmileSection> sec =
            swaptionVolatility->smileSection(
                expiry,
                static_cast<Size>(swapLength * 12.0 + 0.5) * Months,
                true);
        Real atmStrike = sec->atmLevel();
        Real atmVol;
        if (atmStrike == Null<Real>())
            atmVol = sec->volatility(0.03);
        else
            atmVol = sec->volatility(atmStrike);
        Real shift = sec->shift();

        helper = boost::shared_ptr<SwaptionHelper>(new SwaptionHelper(
            expiry, underlyingLastDate(),
            Handle<Quote>(boost::make_shared<SimpleQuote>(atmVol)),
            standardSwapBase->iborIndex(),
            standardSwapBase->fixedLegTenor(),
            standardSwapBase->dayCounter(),
            standardSwapBase->iborIndex()->dayCounter(),
            standardSwapBase->exogenousDiscount()
                ? standardSwapBase->discountingTermStructure()
                : standardSwapBase->forwardingTermStructure(),
            CalibrationHelper::RelativePriceError, Null<Real>(), 1.0, shift));

        break;
    }

    case MaturityStrikeByDeltaGamma: {

        // determine the npv, first and second order derivatives at
        // $y=0$ of the underlying swap

        const Real h = 0.0001; // finite difference step in $y$, make
                               // this a parameter of the engine ?
        Real zSpreadDsc =
            oas_.empty() ? 1.0
                         : exp(-oas_->value() *
                               onefactormodel_->termStructure()
                                   ->dayCounter()
                                   .yearFraction(expiry, rebateDate));

        Real npvm = underlyingNpv(expiry, -h) +
                    rebate *
                        onefactormodel_->zerobond(rebateDate, expiry,
                                                  -h, discountCurve_) *
                        zSpreadDsc;
        Real npv = underlyingNpv(expiry, 0.0) +
                   rebate * onefactormodel_->zerobond(
                                rebateDate, expiry, 0, discountCurve_) *
                       zSpreadDsc;
        Real npvp = underlyingNpv(expiry, h) +
                    rebate *
                        onefactormodel_->zerobond(rebateDate, expiry, h,
                                                  discountCurve_) *
                        zSpreadDsc;

        Real delta = (npvp - npvm) / (2.0 * h);
        Real gamma = (npvp - 2.0 * npv + npvm) / (h * h);

        QL_REQUIRE(npv * npv + delta * delta + gamma * gamma > 0.0,
                   "(npv,delta,gamma) must have a positive norm");

        // debug output
        // std::cout << "EXOTIC npv " << npv << " delta " << delta
        //           << " gamma " << gamma << std::endl;
        // Real xtmp = -5.0;
        // std::cout
        //     << "********************************************EXERCISE "
        //     << expiry << " ******************" << std::endl;
        // std::cout << "globalExoticNpv;";
        // while (xtmp <= 5.0 + QL_EPSILON) {
        //     std::cout << underlyingNpv(expiry, xtmp) << ";";
        //     xtmp += 0.1;
        // }
        // std::cout << std::endl;
        // end debug output

        // play safe, we restrict the maximum maturity so to easily fit
        // in the date class restriction
        Real maxMaturity =
            swaptionVolatility->dayCounter().yearFraction(
                expiry, Date::maxDate() - 365);

        boost::shared_ptr<MatchHelper> matchHelper_;
        matchHelper_ = boost::shared_ptr<MatchHelper>(new MatchHelper(
            underlyingType(), npv, delta, gamma, onefactormodel_,
            standardSwapBase, expiry, maxMaturity, h));

        // Optimize
        Array initial = initialGuess(expiry);
        QL_REQUIRE(initial.size() == 3,
                   "initial guess must have size 3 (but is "
                       << initial.size() << ")");

        EndCriteria ec(1000, 200, 1E-8, 1E-8, 1E-8); // make these
                                                     // criteria and the
                                                     // optimizer itself
                                                     // parameters of
                                                     // the method ?
        Constraint constraint = NoConstraint();
        Problem p(*matchHelper_, constraint, initial);
        LevenbergMarquardt lm;

        EndCriteria::Type ret = lm.minimize(p, ec);
        QL_REQUIRE(ret != EndCriteria::None &&
                       ret != EndCriteria::Unknown &&
                       ret != EndCriteria::MaxIterations,
                   "optimizer returns error (" << ret << ")");
        Array solution = p.currentValue();

        Real maturity = fabs(solution[1]);

        Size years = (Size)std::floor(maturity);
        maturity -= (Real)years;
        maturity *= 12.0;
        Size months = (Size)std::floor(maturity + 0.5);
        if (years == 0 && months == 0)
            months = 1; // ensure a maturity of at least one months
        // maturity -= (Real)months; maturity *= 365.25;
        // Size days = (Size)std::floor(maturity);

        Period matPeriod =
            years * Years + months * Months; //+days*Days;

        boost::shared_ptr<SmileSection> sec =
            swaptionVolatility->smileSection(expiry, matPeriod, true);
        Real shift = sec->shift();

        // we have to floor the strike of the calibration instrument,
        // see warning in the header
        solution[2] = std::max(
            solution[2], 0.00001 - shift); // floor at 0.1bp - shift

        // also the calibrated nominal may be zero, so we floor it, too
        solution[0] =
            std::max(solution[0], 0.000001); // float at 0.01bp

        Real vol = sec->volatility(solution[2]);

        helper = boost::shared_ptr<SwaptionHelper>(new SwaptionHelper(
            expiry, matPeriod,
            Handle<Quote>(boost::make_shared<SimpleQuote>(
                              vol)),
            standardSwapBase->iborIndex(),
            standardSwapBase->fixedLegTenor(),
            standardSwapBase->dayCounter(),
            standardSwapBase->iborIndex()->dayCounter(),
            standardSwapBase->exogenousDiscount()
                ? standardSwapBase->discountingTermStructure()
                : standardSwapBase->forwardingTermStructure(),
            CalibrationHelper::RelativePriceError, solution[2],
            fabs(solution[0]),shift));
        break;
    }

    default:
        QL_FAIL("Calibration basket type not known (" << basketType
                                                      << ")");
    }

    result.push_back(helper);
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/pricingengines/swaption/gaussian1dfloatfloatswaptionengine.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i = idx1; i < arguments_.leg1ResetDates.size(); i++) {
    nominalSum1 += arguments_.nominal1[i];
}

for (Size i = idx1; i < arguments_.leg1ResetDates.size(); i++) {
    weightedMaturity1 +=
        arguments_.leg1AccrualTimes[i] * arguments_.nominal1[i];
}

    for (Size i = 0; i < noEx+1 ; ++i) {
        Array npvTmp0(2 * integrationPoints_ + 1, 0.0);
        Array npvTmp1(2 * integrationPoints_ + 1, 0.0);
        npvp0.push_back(npvTmp0);
        npvp1.push_back(npvTmp1);
    }

    for (Size k = 0; k < (event0 > expiry ? npv0.size() : 1); k++) {

        // roll back

        Real price = 0.0, pricea = 0.0;
        if (event1Time != Null<Real>()) {
            Real zSpreadDf = oas_.empty()
                                 ? 1.0
                                 : std::exp(-oas_->value() *
                                            (event1Time - event0Time));
            Array yg =
                model_->yGrid(stddevs_, integrationPoints_, event1Time,
                              event0Time, event0 > expiry ? z[k] : y);
            CubicInterpolation payoff0(
                z.begin(), z.end(), npv1.begin(),
                CubicInterpolation::Spline, true,
                CubicInterpolation::Lagrange, 0.0,
                CubicInterpolation::Lagrange, 0.0);
            CubicInterpolation payoff0a(
                z.begin(), z.end(), npv1a.begin(),
                CubicInterpolation::Spline, true,
                CubicInterpolation::Lagrange, 0.0,
                CubicInterpolation::Lagrange, 0.0);
            for (Size i = 0; i < yg.size(); i++) {
                p[i] = payoff0(yg[i], true);
                pa[i] = payoff0a(yg[i], true);
            }
            CubicInterpolation payoff1(
                z.begin(), z.end(), p.begin(),
                CubicInterpolation::Spline, true,
                CubicInterpolation::Lagrange, 0.0,
                CubicInterpolation::Lagrange, 0.0);
            CubicInterpolation payoff1a(
                z.begin(), z.end(), pa.begin(),
                CubicInterpolation::Spline, true,
                CubicInterpolation::Lagrange, 0.0,
                CubicInterpolation::Lagrange, 0.0);
            for (Size i = 0; i < z.size() - 1; i++) {
                price += model_->gaussianShiftedPolynomialIntegral(
                             0.0, payoff1.cCoefficients()[i],
                             payoff1.bCoefficients()[i],
                             payoff1.aCoefficients()[i], p[i], z[i],
                             z[i], z[i + 1]) *
                         zSpreadDf;
                pricea += model_->gaussianShiftedPolynomialIntegral(
                              0.0, payoff1a.cCoefficients()[i],
                              payoff1a.bCoefficients()[i],
                              payoff1a.aCoefficients()[i], pa[i], z[i],
                              z[i], z[i + 1]) *
                          zSpreadDf;
            }
            if (extrapolatePayoff_) {
                if (flatPayoffExtrapolation_) {
                    price +=
                        model_->gaussianShiftedPolynomialIntegral(
                            0.0, 0.0, 0.0, 0.0, p[z.size() - 2],
                            z[z.size() - 2], z[z.size() - 1], 100.0) *
                        zSpreadDf;
                    price += model_->gaussianShiftedPolynomialIntegral(
                                 0.0, 0.0, 0.0, 0.0, p[0], z[0], -100.0,
                                 z[0]) *
                             zSpreadDf;
                    pricea +=
                        model_->gaussianShiftedPolynomialIntegral(
                            0.0, 0.0, 0.0, 0.0, pa[z.size() - 2],
                            z[z.size() - 2], z[z.size() - 1], 100.0) *
                        zSpreadDf;
                    pricea += model_->gaussianShiftedPolynomialIntegral(
                                  0.0, 0.0, 0.0, 0.0, pa[0], z[0],
                                  -100.0, z[0]) *
                              zSpreadDf;
                } else {
                    if (type == Option::Call)
                        price +=
                            model_->gaussianShiftedPolynomialIntegral(
                                0.0,
                                payoff1.cCoefficients()[z.size() - 2],
                                payoff1.bCoefficients()[z.size() - 2],
                                payoff1.aCoefficients()[z.size() - 2],
                                p[z.size() - 2], z[z.size() - 2],
                                z[z.size() - 1], 100.0) *
                            zSpreadDf;
                    if (type == Option::Put)
                        price +=
                            model_->gaussianShiftedPolynomialIntegral(
                                0.0, payoff1.cCoefficients()[0],
                                payoff1.bCoefficients()[0],
                                payoff1.aCoefficients()[0], p[0], z[0],
                                -100.0, z[0]) *
                            zSpreadDf;
                    if (type == Option::Call)
                        pricea +=
                            model_->gaussianShiftedPolynomialIntegral(
                                0.0,
                                payoff1a.cCoefficients()[z.size() - 2],
                                payoff1a.bCoefficients()[z.size() - 2],
                                payoff1a.aCoefficients()[z.size() - 2],
                                pa[z.size() - 2], z[z.size() - 2],
                                z[z.size() - 1], 100.0) *
                            zSpreadDf;
                    if (type == Option::Put)
                        pricea +=
                            model_->gaussianShiftedPolynomialIntegral(
                                0.0, payoff1a.cCoefficients()[0],
                                payoff1a.bCoefficients()[0],
                                payoff1a.aCoefficients()[0], pa[0],
                                z[0], -100.0, z[0]) *
                            zSpreadDf;
                }
            }
        }

        npv0[k] = price;
        npv0a[k] = pricea;

        // for probability computation
        if (considerProbabilities && probabilities_ != None) {
            for (Size m = 0; m < npvp0.size(); m++) {
                Real price = 0.0;
                if (event1Time != Null<Real>()) {
                    Real zSpreadDf =
                        oas_.empty()
                            ? 1.0
                            : std::exp(-oas_->value() *
                                       (event1Time - event0Time));
                    Array yg = model_->yGrid(
                        stddevs_, integrationPoints_, event1Time,
                        event0Time, event0 > expiry ? z[k] : 0.0);
                    CubicInterpolation payoff0(
                        z.begin(), z.end(), npvp1[m].begin(),
                        CubicInterpolation::Spline, true,
                        CubicInterpolation::Lagrange, 0.0,
                        CubicInterpolation::Lagrange, 0.0);
                    for (Size i = 0; i < yg.size(); i++) {
                        p[i] = payoff0(yg[i], true);
                    }
                    CubicInterpolation payoff1(
                        z.begin(), z.end(), p.begin(),
                        CubicInterpolation::Spline, true,
                        CubicInterpolation::Lagrange, 0.0,
                        CubicInterpolation::Lagrange, 0.0);
                    for (Size i = 0; i < z.size() - 1; i++) {
                        price +=
                            model_->gaussianShiftedPolynomialIntegral(
                                0.0, payoff1.cCoefficients()[i],
                                payoff1.bCoefficients()[i],
                                payoff1.aCoefficients()[i], p[i], z[i],
                                z[i], z[i + 1]) *
                            zSpreadDf;
                    }
                    if (extrapolatePayoff_) {
                        if (flatPayoffExtrapolation_) {
                            price +=
                                model_
                                    ->gaussianShiftedPolynomialIntegral(
                                          0.0, 0.0, 0.0, 0.0,
                                          p[z.size() - 2],
                                          z[z.size() - 2],
                                          z[z.size() - 1], 100.0) *
                                zSpreadDf;
                            price +=
                                model_
                                    ->gaussianShiftedPolynomialIntegral(
                                          0.0, 0.0, 0.0, 0.0, p[0],
                                          z[0], -100.0, z[0]) *
                                zSpreadDf;
                        } else {
                            if (type == Option::Call)
                                price +=
                                    model_
                                        ->gaussianShiftedPolynomialIntegral(
                                              0.0,
                                              payoff1.cCoefficients()
                                                  [z.size() - 2],
                                              payoff1.bCoefficients()
                                                  [z.size() - 2],
                                              payoff1.aCoefficients()
                                                  [z.size() - 2],
                                              p[z.size() - 2],
                                              z[z.size() - 2],
                                              z[z.size() - 1], 100.0) *
                                    zSpreadDf;
                            if (type == Option::Put)
                                price +=
                                    model_
                                        ->gaussianShiftedPolynomialIntegral(
                                              0.0,
                                              payoff1
                                                  .cCoefficients()[0],
                                              payoff1
                                                  .bCoefficients()[0],
                                              payoff1
                                                  .aCoefficients()[0],
                                              p[0], z[0], -100.0,
                                              z[0]) *
                                    zSpreadDf;
                        }
                    }
                }

                npvp0[m][k] = price;
            }
        }
        // end probability computation

        // event date calculations

        if (isEventDate) {

            Real zk = event0 > expiry ? z[k] : y;

            if (isLeg1Fixing) { // if event is a fixing date and
                                // exercise date,
                // the coupon is part of the exercise into right (by
                // definition)
                Size j = std::find(arguments_.leg1FixingDates.begin(),
                                   arguments_.leg1FixingDates.end(),
                                   event0) -
                         arguments_.leg1FixingDates.begin();
                Real zSpreadDf =
                    oas_.empty()
                        ? 1.0
                        : std::exp(
                              -oas_->value() *
                              (model_->termStructure()
                                   ->dayCounter()
                                   .yearFraction(
                                        event0,
                                        arguments_.leg1PayDates[j])));
                bool done = false;
                do {
                    Real amount;
                    if (arguments_.leg1IsRedemptionFlow[j]) {
                        amount = arguments_.leg1Coupons[j];
                    } else {
                        Real estFixing = 0.0;
                        if(ibor1 != NULL) {
                            estFixing = model_->forwardRate(
                                arguments_.leg1FixingDates[j], event0,
                                zk, ibor1);
                        }
                        if(cms1 != NULL) {
                            estFixing = model_->swapRate(
                                arguments_.leg1FixingDates[j],
                                cms1->tenor(), event0, zk, cms1);
                        }
                        if (cmsspread1 != NULL)
                            estFixing =
                                cmsspread1->gearing1() *
                                    model_->swapRate(
                                        arguments_.leg1FixingDates[j],
                                        cmsspread1->swapIndex1()
                                            ->tenor(),
                                        event0, zk,
                                        cmsspread1->swapIndex1()) +
                                cmsspread1->gearing2() *
                                    model_->swapRate(
                                        arguments_.leg1FixingDates[j],
                                        cmsspread1->swapIndex2()
                                            ->tenor(),
                                        event0, zk,
                                        cmsspread1->swapIndex2());
                        Real rate =
                            arguments_.leg1Spreads[j] +
                            arguments_.leg1Gearings[j] * estFixing;
                        if (arguments_.leg1CappedRates[j] !=
                            Null<Real>())
                            rate = std::min(
                                arguments_.leg1CappedRates[j], rate);
                        if (arguments_.leg1FlooredRates[j] !=
                            Null<Real>())
                            rate = std::max(
                                arguments_.leg1FlooredRates[j], rate);
                        amount = rate * arguments_.nominal1[j] *
                                 arguments_.leg1AccrualTimes[j];
                    }

                    npv0a[k] -=
                        amount *
                        model_->zerobond(arguments_.leg1PayDates[j],
                                         event0, zk, discountCurve_) /
                        model_->numeraire(event0Time, zk,
                                          discountCurve_) *
                        zSpreadDf;

                    if (j < arguments_.leg1FixingDates.size() - 1) {
                        j++;
                        done =
                            (event0 != arguments_.leg1FixingDates[j]);
                    } else
                        done = true;

                } while (!done);
            }

            if (isLeg2Fixing) { // if event is a fixing date and
                                // exercise date,
                // the coupon is part of the exercise into right (by
                // definition)
                Size j = std::find(arguments_.leg2FixingDates.begin(),
                                   arguments_.leg2FixingDates.end(),
                                   event0) -
                         arguments_.leg2FixingDates.begin();
                Real zSpreadDf =
                    oas_.empty()
                        ? 1.0
                        : std::exp(
                              -oas_->value() *
                              (model_->termStructure()
                                   ->dayCounter()
                                   .yearFraction(
                                        event0,
                                        arguments_.leg2PayDates[j])));
                bool done;
                do {
                    Real amount;
                    if (arguments_.leg2IsRedemptionFlow[j]) {
                        amount = arguments_.leg2Coupons[j];
                    } else {
                        Real estFixing = 0.0;
                        if(ibor2 != NULL)
                            estFixing = model_->forwardRate(arguments_.leg2FixingDates[j],event0,zk,ibor2);
                        if(cms2 != NULL)
                            estFixing = model_->swapRate(arguments_.leg2FixingDates[j],cms2->tenor(),event0,zk,cms2);
                        if (cmsspread2 != NULL)
                            estFixing =
                                cmsspread2->gearing1() *
                                    model_->swapRate(
                                        arguments_.leg2FixingDates[j],
                                        cmsspread2->swapIndex1()
                                            ->tenor(),
                                        event0, zk,
                                        cmsspread2->swapIndex1()) +
                                cmsspread2->gearing2() *
                                    model_->swapRate(
                                        arguments_.leg2FixingDates[j],
                                        cmsspread2->swapIndex2()
                                            ->tenor(),
                                        event0, zk,
                                        cmsspread2->swapIndex2());
                        Real rate =
                            arguments_.leg2Spreads[j] +
                            arguments_.leg2Gearings[j] * estFixing;
                        if (arguments_.leg2CappedRates[j] !=
                            Null<Real>())
                            rate = std::min(
                                arguments_.leg2CappedRates[j], rate);
                        if (arguments_.leg2FlooredRates[j] !=
                            Null<Real>())
                            rate = std::max(
                                arguments_.leg2FlooredRates[j], rate);
                        amount = rate * arguments_.nominal2[j] *
                                 arguments_.leg2AccrualTimes[j];
                    }

                    npv0a[k] +=
                        amount *
                        model_->zerobond(arguments_.leg2PayDates[j],
                                         event0, zk, discountCurve_) /
                        model_->numeraire(event0Time, zk,
                                          discountCurve_) *
                        zSpreadDf;
                    if (j < arguments_.leg2FixingDates.size() - 1) {
                        j++;
                        done =
                            (event0 != arguments_.leg2FixingDates[j]);
                    } else
                        done = true;

                } while (!done);
            }

            if (isExercise) {
                Size j = std::find(arguments_.exercise->dates().begin(),
                                   arguments_.exercise->dates().end(),
                                   event0) -
                         arguments_.exercise->dates().begin();
                Real rebate = 0.0;
                Real zSpreadDf = 1.0;
                Date rebateDate = event0;
                if (rebatedExercise_ != NULL) {
                    rebate = rebatedExercise_->rebate(j);
                    rebateDate = rebatedExercise_->rebatePaymentDate(j);
                    zSpreadDf =
                        oas_.empty()
                            ? 1.0
                            : std::exp(-oas_->value() *
                                       (model_->termStructure()
                                            ->dayCounter()
                                            .yearFraction(event0,
                                                          rebateDate)));
                }
                Real exerciseValue =
                    (type == Option::Call ? 1.0 : -1.0) * npv0a[k] +
                    rebate * model_->zerobond(rebateDate, event0) *
                        zSpreadDf / model_->numeraire(event0Time, zk,
                                                      discountCurve_);

                if (considerProbabilities && probabilities_ != None) {
                    if (exIdx == noEx) {
                        // if true we are at the latest date,
                        // so we init
                        // the no call probability
                        npvp0.back()[k] =
                            probabilities_ == Naive
                                ? 1.0
                                : 1.0 / (model_->zerobond(
                                             event0Time, 0.0, 0.0,
                                             discountCurve_) *
                                         model_->numeraire(
                                             event0, z[k],
                                             discountCurve_));
                    }
                    if (exerciseValue >= npv0[k]) {
                        npvp0[exIdx-1][k] =
                            probabilities_ == Naive
                                ? 1.0
                                : 1.0 / (model_->zerobond(
                                             event0Time, 0.0, 0.0,
                                             discountCurve_) *
                                         model_->numeraire(
                                             event0Time, z[k],
                                             discountCurve_));
                        for (Size ii = exIdx; ii < noEx+1; ++ii)
                            npvp0[ii][k] = 0.0;
                    }
                }
                // end probability computation

                npv0[k] = std::max(npv0[k], exerciseValue);
            }
        }
    }

        for(Size i=0;i<npvp0.size();++i) {
            npvp1[i].swap(npvp0[i]);
        }

    for (Size i = 0; i < noEx+1; i++) {
        prob[i] = npvp1[i][0] *
                  (probabilities_ == Naive
                       ? 1.0
                       : model_->numeraire(0.0, 0.0, discountCurve_));
    }

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/pricingengines/inflation/inflationcapfloorengines.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i<optionlets; ++i) {
    Date paymentDate = arguments_.payDates[i];
    if (paymentDate > settlement) { // discard expired caplets
        DiscountFactor d = arguments_.nominals[i] *
            arguments_.gearings[i] *
            nominalTS->discount(paymentDate) *
        arguments_.accrualTimes[i];

        // We explicitly have the index and assume that
        // the fixing is natural, i.e. no convexity adjustment.
        // If that was required then we would also need
        // nominal vols in the pricing engine, i.e. a different engine.
        // This also means that we do not need the coupon to have
        // a pricing engine to return the swaplet rate and then
        // the adjusted fixing in the instrument.
        forwards[i] = yoyTS->yoyRate(arguments_.fixingDates[i],Period(0,Days));
        Rate forward = forwards[i];

        Date fixingDate = arguments_.fixingDates[i];
        Time sqrtTime = 0.0;
        if (fixingDate > volatility_->baseDate()){
            sqrtTime = std::sqrt(
                volatility_->timeFromBase(fixingDate));
        }

        if (type == YoYInflationCapFloor::Cap || type == YoYInflationCapFloor::Collar) {
            Rate strike = arguments_.capRates[i];
            if (sqrtTime>0.0) {
                stdDevs[i] = std::sqrt(
                    volatility_->totalVariance(fixingDate, strike, Period(0,Days)));

            }

            // sttDev=0 for already-fixed dates so everything on forward
            values[i] = optionletImpl(Option::Call, strike,
                                      forward, stdDevs[i], d);
        }
        if (type == YoYInflationCapFloor::Floor || type == YoYInflationCapFloor::Collar) {
            Rate strike = arguments_.floorRates[i];
            if (sqrtTime>0.0) {
                stdDevs[i] = std::sqrt(
                    volatility_->totalVariance(fixingDate, strike, Period(0,Days)));
            }
            Real floorlet = optionletImpl(Option::Put, strike,
                                          forward, stdDevs[i], d);
            if (type == YoYInflationCapFloor::Floor) {
                values[i] = floorlet;
            } else {
                // a collar is long a cap and short a floor
                values[i] -= floorlet;
            }

        }
        value += values[i];
    }
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/pricingengines/credit/midpointcdsengine.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i<arguments_.leg.size(); ++i) {
    if (arguments_.leg[i]->hasOccurred(settlementDate,
                                       includeSettlementDateFlows_))
        continue;

    boost::shared_ptr<FixedRateCoupon> coupon =
        boost::dynamic_pointer_cast<FixedRateCoupon>(arguments_.leg[i]);

    // In order to avoid a few switches, we calculate the NPV
    // of both legs as a positive quantity. We'll give them
    // the right sign at the end.

    Date paymentDate = coupon->date(),
         startDate = coupon->accrualStartDate(),
         endDate = coupon->accrualEndDate();
    // this is the only point where it might not coincide
    if (i==0)
        startDate = arguments_.protectionStart;
    Date effectiveStartDate =
        (startDate <= today && today <= endDate) ? today : startDate;
    Date defaultDate = // mid-point
        effectiveStartDate + (endDate-effectiveStartDate)/2;

    Probability S = probability_->survivalProbability(paymentDate);
    Probability P = probability_->defaultProbability(
                                        effectiveStartDate,
                                        endDate);

    // on one side, we add the fixed rate payments in case of
    // survival...
    results_.couponLegNPV +=
        S * coupon->amount() *
        discountCurve_->discount(paymentDate);
    // ...possibly including accrual in case of default.
    if (arguments_.settlesAccrual) {
        if (arguments_.paysAtDefaultTime) {
            results_.couponLegNPV +=
                P * coupon->accruedAmount(defaultDate) *
                discountCurve_->discount(defaultDate);
        } else {
            // pays at the end
            results_.couponLegNPV +=
                P * coupon->amount() *
                discountCurve_->discount(paymentDate);
        }
    }

    // on the other side, we add the payment in case of default.
    Real claim = arguments_.claim->amount(defaultDate,
                                          arguments_.notional,
                                          recoveryRate_);
    if (arguments_.paysAtDefaultTime) {
        results_.defaultLegNPV +=
            P * claim * discountCurve_->discount(defaultDate);
    } else {
        results_.defaultLegNPV +=
            P * claim * discountCurve_->discount(paymentDate);
    }
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/pricingengines/credit/integralcdsengine.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i<arguments_.leg.size(); ++i) {
    if (arguments_.leg[i]->hasOccurred(settlementDate,
                                       includeSettlementDateFlows_))
        continue;

    boost::shared_ptr<FixedRateCoupon> coupon =
        boost::dynamic_pointer_cast<FixedRateCoupon>(arguments_.leg[i]);

    // In order to avoid a few switches, we calculate the NPV
    // of both legs as a positive quantity. We'll give them
    // the right sign at the end.

    Date paymentDate = coupon->date(),
         startDate = (i == 0 ? arguments_.protectionStart :
                               coupon->accrualStartDate()),
         endDate = coupon->accrualEndDate();
    Date effectiveStartDate =
        (startDate <= today && today <= endDate) ? today : startDate;
    Real couponAmount = coupon->amount();

    Probability S = probability_->survivalProbability(paymentDate);

    // On one side, we add the fixed rate payments in case of
    // survival.
    results_.couponLegNPV +=
        S * couponAmount * discountCurve_->discount(paymentDate);

    // On the other side, we add the payment (and possibly the
    // accrual) in case of default.

    Period step = integrationStep_;
    Date d0 = effectiveStartDate;
    Date d1 = std::min(d0 + step, endDate);
    Probability P0 = probability_->defaultProbability(d0);
    DiscountFactor endDiscount = discountCurve_->discount(paymentDate);
    do {
        DiscountFactor B =
            arguments_.paysAtDefaultTime ?
            discountCurve_->discount(d1) :
            endDiscount;

        Probability P1 = probability_->defaultProbability(d1);
        Probability dP = P1 - P0;

        // accrual...
        if (arguments_.settlesAccrual) {
            if (arguments_.paysAtDefaultTime)
                results_.couponLegNPV +=
                    coupon->accruedAmount(d1) * B * dP;
            else
                results_.couponLegNPV +=
                    couponAmount * B * dP;
        }

        // ...and claim.
        Real claim = arguments_.claim->amount(d1,
                                              arguments_.notional,
                                              recoveryRate_);
        results_.defaultLegNPV += claim * B * dP;

        // setup for next time around the loop
        P0 = P1;
        d0 = d1;
        d1 = std::min(d0 + step, endDate);
    } while (d0 < endDate);
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/instruments/inflationcapfloor.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (i = yoyLeg_.begin(); i != yoyLeg_.end(); ++i)
    registerWith(*i);

for (i = yoyLeg_.begin(); i != yoyLeg_.end(); ++i)
    registerWith(*i);

for (Size i=yoyLeg_.size(); i>0; --i)
    if (!yoyLeg_[i-1]->hasOccurred())
        return false;

for (Size i=0; i<n; ++i) {
    shared_ptr<YoYInflationCoupon> coupon =
    boost::dynamic_pointer_cast<YoYInflationCoupon>(
                                                    yoyLeg_[i]);
    QL_REQUIRE(coupon, "non-YoYInflationCoupon given");
    arguments->startDates[i] = coupon->accrualStartDate();
    arguments->fixingDates[i] = coupon->fixingDate();
    arguments->payDates[i] = coupon->date();

    // this is passed explicitly for precision
    arguments->accrualTimes[i] = coupon->accrualPeriod();

    arguments->nominals[i] = coupon->nominal();
    Spread spread = coupon->spread();
    Real gearing = coupon->gearing();
    arguments->gearings[i] = gearing;
    arguments->spreads[i] = spread;

    if (type_ == Cap || type_ == Collar)
        arguments->capRates[i] = (capRates_[i]-spread)/gearing;
    else
        arguments->capRates[i] = Null<Rate>();

    if (type_ == Floor || type_ == Collar)
        arguments->floorRates[i] = (floorRates_[i]-spread)/gearing;
    else
        arguments->floorRates[i] = Null<Rate>();
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/instruments/dividendbarrieroption.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i = 0; i < cashFlow.size(); i++) {
    QL_REQUIRE(cashFlow[i]->date() <= exerciseDate,
               "the " << io::ordinal(i+1) << " dividend date ("
               << cashFlow[i]->date()
               << ") is later than the exercise date ("
               << exerciseDate << ")");
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/instruments/capfloor.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (i = floatingLeg_.begin(); i != floatingLeg_.end(); ++i)
    registerWith(*i);

for (i = floatingLeg_.begin(); i != floatingLeg_.end(); ++i)
    registerWith(*i);

for (Size i=floatingLeg_.size(); i>0; --i)
    if (!floatingLeg_[i-1]->hasOccurred())
        return false;

for (Size i=0; i<n; ++i) {
    shared_ptr<FloatingRateCoupon> coupon =
        boost::dynamic_pointer_cast<FloatingRateCoupon>(
                                                     floatingLeg_[i]);
    QL_REQUIRE(coupon, "non-FloatingRateCoupon given");
    arguments->startDates[i] = coupon->accrualStartDate();
    arguments->fixingDates[i] = coupon->fixingDate();
    arguments->endDates[i] = coupon->date();

    // this is passed explicitly for precision
    arguments->accrualTimes[i] = coupon->accrualPeriod();

    // this is passed explicitly for precision...
    if (arguments->endDates[i] >= today) { // ...but only if needed
        arguments->forwards[i] = coupon->adjustedFixing();
    } else {
        arguments->forwards[i] = Null<Rate>();
    }

    arguments->nominals[i] = coupon->nominal();
    Spread spread = coupon->spread();
    Real gearing = coupon->gearing();
    arguments->gearings[i] = gearing;
    arguments->spreads[i] = spread;

    if (type_ == Cap || type_ == Collar)
        arguments->capRates[i] = (capRates_[i]-spread)/gearing;
    else
        arguments->capRates[i] = Null<Rate>();

    if (type_ == Floor || type_ == Collar)
        arguments->floorRates[i] = (floorRates_[i]-spread)/gearing;
    else
        arguments->floorRates[i] = Null<Rate>();

    arguments->indexes[i] = coupon->index();
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/instruments/fixedratebondforward.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i = 0; i < cf.size(); ++i) {
    if (!cf[i]->hasOccurred(settlement, false)) {
        if (cf[i]->hasOccurred(maturityDate_, false)) {
            income += cf[i]->amount() *
                      incomeDiscountCurve->discount(cf[i]->date()) ;
        } else {
            break;
        }
    }
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/instruments/vanillaswap.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Leg::const_iterator i = legs_[1].begin(); i < legs_[1].end(); ++i)
    registerWith(*i);

for (Size i=0; i<fixedCoupons.size(); ++i) {
    boost::shared_ptr<FixedRateCoupon> coupon =
        boost::dynamic_pointer_cast<FixedRateCoupon>(fixedCoupons[i]);

    arguments->fixedPayDates[i] = coupon->date();
    arguments->fixedResetDates[i] = coupon->accrualStartDate();
    arguments->fixedCoupons[i] = coupon->amount();
}

for (Size i=0; i<floatingCoupons.size(); ++i) {
    boost::shared_ptr<IborCoupon> coupon =
        boost::dynamic_pointer_cast<IborCoupon>(floatingCoupons[i]);

    arguments->floatingResetDates[i] = coupon->accrualStartDate();
    arguments->floatingPayDates[i] = coupon->date();

    arguments->floatingFixingDates[i] = coupon->fixingDate();
    arguments->floatingAccrualTimes[i] = coupon->accrualPeriod();
    arguments->floatingSpreads[i] = coupon->spread();
    try {
        arguments->floatingCoupons[i] = coupon->amount();
    } catch (Error&) {
        arguments->floatingCoupons[i] = Null<Real>();
    }
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/instruments/bond.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=1; i<notionalSchedule_.size(); ++i) {
    Real R = i < redemptions.size() ? redemptions[i] :
             !redemptions.empty()   ? redemptions.back() :
                                      100.0;
    Real amount = (R/100.0)*(notionals_[i-1]-notionals_[i]);
    shared_ptr<CashFlow> payment;
    if (i < notionalSchedule_.size()-1)
        payment.reset(new AmortizingPayment(amount,
                                            notionalSchedule_[i]));
    else
        payment.reset(new Redemption(amount, notionalSchedule_[i]));
    cashflows_.push_back(payment);
    redemptions_.push_back(payment);
}

for (Size i=0; i<cashflows_.size(); ++i) {
    shared_ptr<Coupon> coupon =
        boost::dynamic_pointer_cast<Coupon>(cashflows_[i]);
    if (!coupon)
        continue;

    Real notional = coupon->nominal();
    // we add the notional only if it is the first one...
    if (notionals_.empty()) {
        notionals_.push_back(coupon->nominal());
        lastPaymentDate = coupon->date();
    } else if (!close(notional, notionals_.back())) {
        // ...or if it has changed.
        QL_REQUIRE(notional < notionals_.back(),
                   "increasing coupon notionals");
        notionals_.push_back(coupon->nominal());
        // in this case, we also add the last valid date for
        // the previous one...
        notionalSchedule_.push_back(lastPaymentDate);
        // ...and store the candidate for this one.
        lastPaymentDate = coupon->date();
    } else {
        // otherwise, we just extend the valid range of dates
        // for the current notional.
        lastPaymentDate = coupon->date();
    }
}

for (Size i=0; i<cashflows.size(); ++i)
    QL_REQUIRE(cashflows[i], "null cash flow provided");

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/instruments/vanillaswingoption.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i < dates_.size(); ++i) {
    QL_REQUIRE(seconds_[i] < secPerDay,
               "a date can not have more than 24*3600 seconds");
    if (i > 0) {
        QL_REQUIRE(dates_[i-1] < dates_[i]
                   || (dates_[i-1] == dates_[i]
                       && seconds_[i-1] < seconds_[i]),
                   "date times must be sorted");
    }
}

for (Size i=0; i<dates().size(); ++i) {
    Time t = dc.yearFraction(refDate, dates()[i]);

    const Time dt
        = dc.yearFraction(refDate, dates()[i]+Period(1u, Days)) - t;

    t += dt*seconds()[i]/(24*3600.);

    QL_REQUIRE(t >= 0, "exercise dates must not contain past date");
    exerciseTimes.push_back(t);
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/instruments/cpiswap.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (i = cpiLeg.begin(); i < cpiLeg.end(); ++i) {
    registerWith(*i);
}

for (i = floatingLeg.begin(); i < floatingLeg.end(); ++i) {
    registerWith(*i);
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/instruments/cliquetoption.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i<resetDates.size(); ++i) {
    QL_REQUIRE(exercise->lastDate() > resetDates[i],
               "reset date greater or equal to maturity");
    QL_REQUIRE(i == 0 || resetDates[i] > resetDates[i-1],
               "unsorted reset dates");
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/instruments/yearonyearinflationswap.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (i = yoyLeg.begin(); i < yoyLeg.end(); ++i)
    registerWith(*i);

for (Size i=0; i<fixedCoupons.size(); ++i) {
    boost::shared_ptr<FixedRateCoupon> coupon =
    boost::dynamic_pointer_cast<FixedRateCoupon>(fixedCoupons[i]);

    arguments->fixedPayDates[i] = coupon->date();
    arguments->fixedResetDates[i] = coupon->accrualStartDate();
    arguments->fixedCoupons[i] = coupon->amount();
}

for (Size i=0; i<yoyCoupons.size(); ++i) {
    boost::shared_ptr<YoYInflationCoupon> coupon =
    boost::dynamic_pointer_cast<YoYInflationCoupon>(yoyCoupons[i]);

    arguments->yoyResetDates[i] = coupon->accrualStartDate();
    arguments->yoyPayDates[i] = coupon->date();

    arguments->yoyFixingDates[i] = coupon->fixingDate();
    arguments->yoyAccrualTimes[i] = coupon->accrualPeriod();
    arguments->yoySpreads[i] = coupon->spread();
    try {
        arguments->yoyCoupons[i] = coupon->amount();
    } catch (Error&) {
        arguments->yoyCoupons[i] = Null<Real>();
    }
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/instruments/bmaswap.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size j=0; j<2; ++j) {
    for (Leg::iterator i = legs_[j].begin(); i!= legs_[j].end(); ++i)
        registerWith(*i);
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/instruments/compositeinstrument.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (const_iterator i=components_.begin(); i!=components_.end(); ++i) {
    if (!i->first->isExpired())
        return false;
}

for (const_iterator i=components_.begin(); i!=components_.end(); ++i) {
    NPV_ += i->second * i->first->NPV();
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/instruments/assetswap.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (i=legs_[1].begin(); i<legs_[1].end(); ++i)
    registerWith(*i);

for (i = bondLeg.begin(); i<bondLeg.end()-1 && (*i)->date()<=dealMaturity; ++i) {
    // whatever might be the choice for the discounting engine
    // bond flows on upfrontDate_ must be discarded
    bool upfrontDateBondFlows = false;
    if (!(*i)->hasOccurred(upfrontDate_, upfrontDateBondFlows))
        legs_[0].push_back(*i);
}

for (i=legs_[0].begin(); i<legs_[0].end(); ++i)
    registerWith(*i);

for (Leg::const_iterator i=legs_[1].begin(); i<legs_[1].end(); ++i)
    registerWith(*i);

for (Leg::const_iterator i=bondLeg.begin(); i<bondLeg.end(); ++i) {
    // whatever might be the choice for the discounting engine
    // bond flows on upfrontDate_ must be discarded
    bool upfrontDateBondFlows = false;
    if (!(*i)->hasOccurred(upfrontDate_, upfrontDateBondFlows))
        legs_[0].push_back(*i);
}

for (Leg::const_iterator i=legs_[0].begin(); i<legs_[0].end(); ++i)
    registerWith(*i);

for (Size i=0; i<fixedCoupons.size(); ++i) {
    shared_ptr<FixedRateCoupon> coupon =
        dynamic_pointer_cast<FixedRateCoupon>(fixedCoupons[i]);

    arguments->fixedPayDates[i] = coupon->date();
    arguments->fixedResetDates[i] = coupon->accrualStartDate();
    arguments->fixedCoupons[i] = coupon->amount();
}

for (Size i=0; i<floatingCoupons.size(); ++i) {
    shared_ptr<FloatingRateCoupon> coupon =
        dynamic_pointer_cast<FloatingRateCoupon>(floatingCoupons[i]);

    arguments->floatingResetDates[i] = coupon->accrualStartDate();
    arguments->floatingPayDates[i] = coupon->date();
    arguments->floatingFixingDates[i] = coupon->fixingDate();
    arguments->floatingAccrualTimes[i] = coupon->accrualPeriod();
    arguments->floatingSpreads[i] = coupon->spread();
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/instruments/zerocouponinflationswap.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size j=0; j<2; ++j) {
    for (Leg::iterator i = legs_[j].begin(); i!= legs_[j].end(); ++i)
        registerWith(*i);
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/instruments/overnightindexedswap.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size j=0; j<2; ++j) {
    for (Leg::iterator i = legs_[j].begin(); i!= legs_[j].end(); ++i)
        registerWith(*i);
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/instruments/dividendvanillaoption.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i = 0; i < cashFlow.size(); i++) {
    QL_REQUIRE(cashFlow[i]->date() <= exerciseDate,
               "the " << io::ordinal(i+1) << " dividend date ("
               << cashFlow[i]->date()
               << ") is later than the exercise date ("
               << exerciseDate << ")");
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/instruments/floatfloatswap.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i = 0; i < cappedRate1_.size(); i++) {
    if (isNull)
        QL_REQUIRE(cappedRate1_[i] == Null<Real>(),
                   "cappedRate1 must be null for all or none entry ("
                       << (i + 1) << "th is " << cappedRate1_[i]
                       << ")");
    else
        QL_REQUIRE(cappedRate1_[i] != Null<Real>(),
                   "cappedRate 1 must be null for all or none entry ("
                       << "1st is " << cappedRate1_[0] << ")");
}

for (Size i = 0; i < cappedRate2_.size(); i++) {
    if (isNull)
        QL_REQUIRE(cappedRate2_[i] == Null<Real>(),
                   "cappedRate2 must be null for all or none entry ("
                       << (i + 1) << "th is " << cappedRate2_[i]
                       << ")");
    else
        QL_REQUIRE(cappedRate2_[i] != Null<Real>(),
                   "cappedRate2 must be null for all or none entry ("
                       << "1st is " << cappedRate2_[0] << ")");
}

for (Size i = 0; i < flooredRate1_.size(); i++) {
    if (isNull)
        QL_REQUIRE(flooredRate1_[i] == Null<Real>(),
                   "flooredRate1 must be null for all or none entry ("
                       << (i + 1) << "th is " << flooredRate1_[i]
                       << ")");
    else
        QL_REQUIRE(flooredRate1_[i] != Null<Real>(),
                   "flooredRate 1 must be null for all or none entry ("
                       << "1st is " << flooredRate1_[0] << ")");
}

for (Size i = 0; i < flooredRate2_.size(); i++) {
    if (isNull)
        QL_REQUIRE(flooredRate2_[i] == Null<Real>(),
                   "flooredRate2 must be null for all or none entry ("
                       << (i + 1) << "th is " << flooredRate2_[i]
                       << ")");
    else
        QL_REQUIRE(flooredRate2_[i] != Null<Real>(),
                   "flooredRate2 must be null for all or none entry ("
                       << "1st is " << flooredRate2_[0] << ")");
}

for (Size i = 0; i < gearing1_.size(); i++)
    if (close(gearing1_[i], 0.0))
        gearing1_[i] = QL_EPSILON;

for (Size i = 0; i < gearing2_.size(); i++)
    if (close(gearing2_[i], 0.0))
        gearing2_[i] = QL_EPSILON;

    for (Size i = 0; i < legs_[0].size() - 1; i++) {
        Real cap = nominal1_[i + 1] - nominal1_[i];
        if (!close(cap, 0.0)) {
            std::vector<boost::shared_ptr<CashFlow> >::iterator it1 =
                legs_[0].begin();
            std::advance(it1, i + 1);
            legs_[0].insert(
                it1, boost::shared_ptr<CashFlow>(
                         new Redemption(cap, legs_[0][i]->date())));
            std::vector<Real>::iterator it2 = nominal1_.begin();
            std::advance(it2, i + 1);
            nominal1_.insert(it2, nominal1_[i]);
            i++;
        }
    }

    for (Size i = 0; i < legs_[1].size() - 1; i++) {
        Real cap = nominal2_[i + 1] - nominal2_[i];
        if (!close(cap, 0.0)) {
            std::vector<boost::shared_ptr<CashFlow> >::iterator it1 =
                legs_[1].begin();
            std::advance(it1, i + 1);
            legs_[1].insert(
                it1, boost::shared_ptr<CashFlow>(
                         new Redemption(cap, legs_[1][i]->date())));
            std::vector<Real>::iterator it2 = nominal2_.begin();
            std::advance(it2, i + 1);
            nominal2_.insert(it2, nominal2_[i]);
            i++;
        }
    }

for (Leg::const_iterator i = legs_[0].begin(); i < legs_[0].end(); ++i)
    registerWith(*i);

for (Leg::const_iterator i = legs_[1].begin(); i < legs_[1].end(); ++i)
    registerWith(*i);

for (Size i = 0; i < leg1Coupons.size(); ++i) {
    boost::shared_ptr<FloatingRateCoupon> coupon =
        boost::dynamic_pointer_cast<FloatingRateCoupon>(leg1Coupons[i]);
    if (coupon) {
        arguments->leg1AccrualTimes[i] = coupon->accrualPeriod();
        arguments->leg1PayDates[i] = coupon->date();
        arguments->leg1ResetDates[i] = coupon->accrualStartDate();
        arguments->leg1FixingDates[i] = coupon->fixingDate();
        arguments->leg1Spreads[i] = coupon->spread();
        arguments->leg1Gearings[i] = coupon->gearing();
        try {
            arguments->leg1Coupons[i] = coupon->amount();
        }
        catch (Error &) {
            arguments->leg1Coupons[i] = Null<Real>();
        }
        boost::shared_ptr<CappedFlooredCoupon> cfcoupon =
            boost::dynamic_pointer_cast<CappedFlooredCoupon>(
                leg1Coupons[i]);
        if (cfcoupon) {
            arguments->leg1CappedRates[i] = cfcoupon->cap();
            arguments->leg1FlooredRates[i] = cfcoupon->floor();
        }
    } else {
        boost::shared_ptr<CashFlow> cashflow =
            boost::dynamic_pointer_cast<CashFlow>(leg1Coupons[i]);
        std::vector<Date>::const_iterator j =
            std::find(arguments->leg1PayDates.begin(),
                      arguments->leg1PayDates.end(), cashflow->date());
        QL_REQUIRE(j != arguments->leg1PayDates.end(),
                   "nominal redemption on "
                       << cashflow->date()
                       << "has no corresponding coupon");
        Size jIdx = j - arguments->leg1PayDates.begin();
        arguments->leg1IsRedemptionFlow[i] = true;
        arguments->leg1Coupons[i] = cashflow->amount();
        arguments->leg1ResetDates[i] = arguments->leg1ResetDates[jIdx];
        arguments->leg1FixingDates[i] =
            arguments->leg1FixingDates[jIdx];
        arguments->leg1AccrualTimes[i] = 0.0;
        arguments->leg1Spreads[i] = 0.0;
        arguments->leg1Gearings[i] = 1.0;
        arguments->leg1PayDates[i] = cashflow->date();
    }
}

for (Size i = 0; i < leg2Coupons.size(); ++i) {
    boost::shared_ptr<FloatingRateCoupon> coupon =
        boost::dynamic_pointer_cast<FloatingRateCoupon>(leg2Coupons[i]);
    if (coupon) {
        arguments->leg2AccrualTimes[i] = coupon->accrualPeriod();
        arguments->leg2PayDates[i] = coupon->date();
        arguments->leg2ResetDates[i] = coupon->accrualStartDate();
        arguments->leg2FixingDates[i] = coupon->fixingDate();
        arguments->leg2Spreads[i] = coupon->spread();
        arguments->leg2Gearings[i] = coupon->gearing();
        try {
            arguments->leg2Coupons[i] = coupon->amount();
        }
        catch (Error &) {
            arguments->leg2Coupons[i] = Null<Real>();
        }
        boost::shared_ptr<CappedFlooredCoupon> cfcoupon =
            boost::dynamic_pointer_cast<CappedFlooredCoupon>(
                leg2Coupons[i]);
        if (cfcoupon) {
            arguments->leg2CappedRates[i] = cfcoupon->cap();
            arguments->leg2FlooredRates[i] = cfcoupon->floor();
        }
    } else {
        boost::shared_ptr<CashFlow> cashflow =
            boost::dynamic_pointer_cast<CashFlow>(leg2Coupons[i]);
        std::vector<Date>::const_iterator j =
            std::find(arguments->leg2PayDates.begin(),
                      arguments->leg2PayDates.end(), cashflow->date());
        QL_REQUIRE(j != arguments->leg2PayDates.end(),
                   "nominal redemption on "
                       << cashflow->date()
                       << "has no corresponding coupon");
        Size jIdx = j - arguments->leg2PayDates.begin();
        arguments->leg2IsRedemptionFlow[i] = true;
        arguments->leg2Coupons[i] = cashflow->amount();
        arguments->leg2ResetDates[i] = arguments->leg2ResetDates[jIdx];
        arguments->leg2FixingDates[i] =
            arguments->leg2FixingDates[jIdx];
        arguments->leg2AccrualTimes[i] = 0.0;
        arguments->leg2Spreads[i] = 0.0;
        arguments->leg2Gearings[i] = 1.0;
        arguments->leg2PayDates[i] = cashflow->date();
    }
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/instruments/nonstandardswap.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    for (Size i = 0; i < legs_[0].size() - 1; i++) {
        Real cap = fixedNominal_[i + 1] - fixedNominal_[i];
        if (!close(cap, 0.0)) {
            std::vector<boost::shared_ptr<CashFlow> >::iterator it1 =
                legs_[0].begin();
            std::advance(it1, i + 1);
            legs_[0].insert(
                it1, boost::shared_ptr<CashFlow>(
                         new Redemption(cap, legs_[0][i]->date())));
            std::vector<Real>::iterator it2 = fixedNominal_.begin();
            std::advance(it2, i + 1);
            fixedNominal_.insert(it2, fixedNominal_[i]);
            i++;
        }
    }

    for (Size i = 0; i < legs_[1].size() - 1; i++) {
        Real cap = floatingNominal_[i + 1] - floatingNominal_[i];
        if (!close(cap, 0.0)) {
            std::vector<boost::shared_ptr<CashFlow> >::iterator it1 =
                legs_[1].begin();
            std::advance(it1, i + 1);
            legs_[1].insert(
                it1, boost::shared_ptr<CashFlow>(
                         new Redemption(cap, legs_[1][i]->date())));
            std::vector<Real>::iterator it2 = floatingNominal_.begin();
            std::advance(it2, i + 1);
            floatingNominal_.insert(it2, floatingNominal_[i]);
            i++;
        }
    }

for (Leg::const_iterator i = legs_[1].begin(); i < legs_[1].end(); ++i)
    registerWith(*i);

for (Size i = 0; i < fixedCoupons.size(); ++i) {
    boost::shared_ptr<FixedRateCoupon> coupon =
        boost::dynamic_pointer_cast<FixedRateCoupon>(fixedCoupons[i]);
    if (coupon) {
        arguments->fixedPayDates[i] = coupon->date();
        arguments->fixedResetDates[i] = coupon->accrualStartDate();
        arguments->fixedCoupons[i] = coupon->amount();
    } else {
        boost::shared_ptr<CashFlow> cashflow =
            boost::dynamic_pointer_cast<CashFlow>(fixedCoupons[i]);
        std::vector<Date>::const_iterator j =
            std::find(arguments->fixedPayDates.begin(),
                      arguments->fixedPayDates.end(), cashflow->date());
        QL_REQUIRE(j != arguments->fixedPayDates.end(),
                   "nominal redemption on "
                       << cashflow->date()
                       << "has no corresponding coupon");
        Size jIdx = j - arguments->fixedPayDates.begin();
        arguments->fixedIsRedemptionFlow[i] = true;
        arguments->fixedCoupons[i] = cashflow->amount();
        arguments->fixedResetDates[i] =
            arguments->fixedResetDates[jIdx];
        arguments->fixedPayDates[i] = cashflow->date();
    }
}

for (Size i = 0; i < floatingCoupons.size(); ++i) {
    boost::shared_ptr<IborCoupon> coupon =
        boost::dynamic_pointer_cast<IborCoupon>(floatingCoupons[i]);
    if (coupon) {
        arguments->floatingResetDates[i] = coupon->accrualStartDate();
        arguments->floatingPayDates[i] = coupon->date();
        arguments->floatingFixingDates[i] = coupon->fixingDate();
        arguments->floatingAccrualTimes[i] = coupon->accrualPeriod();
        arguments->floatingSpreads[i] = coupon->spread();
        arguments->floatingGearings[i] = coupon->gearing();
        try {
            arguments->floatingCoupons[i] = coupon->amount();
        }
        catch (Error &) {
            arguments->floatingCoupons[i] = Null<Real>();
        }
    } else {
        boost::shared_ptr<CashFlow> cashflow =
            boost::dynamic_pointer_cast<CashFlow>(floatingCoupons[i]);
        std::vector<Date>::const_iterator j = std::find(
            arguments->floatingPayDates.begin(),
            arguments->floatingPayDates.end(), cashflow->date());
        QL_REQUIRE(j != arguments->floatingPayDates.end(),
                   "nominal redemption on "
                       << cashflow->date()
                       << "has no corresponding coupon");
        Size jIdx = j - arguments->floatingPayDates.begin();
        arguments->floatingIsRedemptionFlow[i] = true;
        arguments->floatingCoupons[i] = cashflow->amount();
        arguments->floatingResetDates[i] =
            arguments->floatingResetDates[jIdx];
        arguments->floatingFixingDates[i] =
            arguments->floatingFixingDates[jIdx];
        arguments->floatingAccrualTimes[i] = 0.0;
        arguments->floatingSpreads[i] = 0.0;
        arguments->floatingGearings[i] = 1.0;
        arguments->floatingPayDates[i] = cashflow->date();
    }
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/instruments/swap.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Leg::iterator i = legs_[0].begin(); i!= legs_[0].end(); ++i)
    registerWith(*i);

for (Leg::iterator i = legs_[1].begin(); i!= legs_[1].end(); ++i)
    registerWith(*i);

for (Size j=0; j<legs_.size(); ++j) {
    if (payer[j]) payer_[j]=-1.0;
    for (Leg::iterator i = legs_[j].begin(); i!= legs_[j].end(); ++i)
        registerWith(*i);
}

for (Size j=0; j<legs_.size(); ++j) {
    Leg::const_iterator i; 
    for (i = legs_[j].begin(); i!= legs_[j].end(); ++i)
        if (!(*i)->hasOccurred())
            return false;
}

for (Size j=1; j<legs_.size(); ++j)
    d = std::min(d, CashFlows::startDate(legs_[j]));

for (Size j=1; j<legs_.size(); ++j)
    d = std::max(d, CashFlows::maturityDate(legs_[j]));

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/instruments/bonds/btp.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i<k; ++i) {
    QL_REQUIRE(outstandings[i]>=0,
               "negative outstanding for " << io::ordinal(i) <<
               " bond, maturity " << btps[i]->maturityDate());
    // add check for prices ??
}

for (Size i=0; i<n_; ++i)
    outstanding_ += outstandings[i];

for (Size i=0; i<n_; ++i) {
    weights_[i] = outstandings[i]/outstanding_;
    registerWith(quotes_[i]);
}

for (Size i=0; i<nSwaps_; ++i) {
    swapLenghts_[i] = static_cast<Real>(i+1);
    swaps_[i] = MakeVanillaSwap(
        swapLenghts_[i]*Years, euriborIndex_, dummyRate, 1*Days)
                        .withDiscountingTermStructure(discountCurve_);
}

for (Size i=0; i<basket_->size(); ++i) {
    yields_[i] = BondFunctions::yield(
        *btps[i], quotes[i]->value(),
        ActualActual(ActualActual::ISMA), Compounded, Annual,
        bondSettlementDate,
        // accuracy, maxIterations, guess
        1.0e-10, 100, yields_[i]);
    durations_[i] = BondFunctions::duration(
        *btps[i], yields_[i],
        ActualActual(ActualActual::ISMA), Compounded, Annual,
        Duration::Modified, bondSettlementDate);
}

for (Size i=1; i<nSwaps_; ++i) {
    swapRates_[i]= swaps_[i]->fairRate();
    FixedRateBond swapBond(settlDays,
                           100.0,      // faceAmount
                           swaps_[i]->fixedSchedule(),
                           std::vector<Rate>(1, swapRates_[i]),
                           fixedDayCount,
                           Following, // paymentConvention
                           100.0);    // redemption
    swapBondYields_[i] = BondFunctions::yield(swapBond,
        100.0, // floating leg NPV including end payment
        ActualActual(ActualActual::ISMA), Compounded, Annual,
        bondSettlementDate,
        // accuracy, maxIterations, guess
        1.0e-10, 100, swapBondYields_[i]);
    swapBondDurations_[i] = BondFunctions::duration(
        swapBond, swapBondYields_[i],
        ActualActual(ActualActual::ISMA), Compounded, Annual,
        Duration::Modified, bondSettlementDate);
    if (swapBondDurations_[i] > duration_) {
        equivalentSwapIndex_ = i-1;
        break; // exit the loop
    }
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/instruments/bonds/cpibond.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (i = cashflows_.begin(); i < cashflows_.end(); ++i) {
    registerWith(*i);
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/cashflows/rangeaccrual.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for(Size i=0;i<observationsNo_;i++) {
    observationTimes_.push_back(
        dayCounter.yearFraction(referenceDate, observationDates_[i]));
}

for(Size i=0; i<observationDates.size(); i++) {
    initialValues_[i]=index->fixing(
        calendar.advance(observationDates[i],
                         -static_cast<Integer>(coupon_->fixingDays()),
                         Days));
}

for(Size i=0;i<observationsNo_;i++){
    Real digitalFloater = digitalRangePrice(lowerTrigger_, upperTrigger_,initialValues_[i+1],
                                             observationTimes_[i], deflator);
    result += digitalFloater;
}

for (Size i=0; i<n; ++i) {
    refStart = start = schedule_.date(i);
    refEnd   =   end = schedule_.date(i+1);
    paymentDate = calendar.adjust(end, paymentAdjustment_);
    if (i==0   && !schedule_.isRegular(i+1)) {
        BusinessDayConvention bdc = schedule_.businessDayConvention();
        refStart = calendar.adjust(end - schedule_.tenor(), bdc);
    }
    if (i==n-1 && !schedule_.isRegular(i+1)) {
        BusinessDayConvention bdc = schedule_.businessDayConvention();
        refEnd = calendar.adjust(start + schedule_.tenor(), bdc);
    }
    if (detail::get(gearings_, i, 1.0) == 0.0) { // fixed coupon
        leg.push_back(boost::shared_ptr<CashFlow>(new
            FixedRateCoupon(paymentDate,
                            detail::get(notionals_, i, Null<Real>()),
                            detail::get(spreads_, i, 0.0),
                            paymentDayCounter_,
                            start, end, refStart, refEnd)));
    } else { // floating coupon
        observationsSchedules.push_back(
            boost::shared_ptr<Schedule>(new
                Schedule(start, end,
                         observationTenor_, calendar,
                         observationConvention_,
                         observationConvention_,
                         DateGeneration::Forward, false)));

            leg.push_back(boost::shared_ptr<CashFlow>(new
               RangeAccrualFloatersCoupon(
                    paymentDate,
                    detail::get(notionals_, i, Null<Real>()),
                    index_,
                    start, end,
                    detail::get(fixingDays_, i, 2),
                    paymentDayCounter_,
                    detail::get(gearings_, i, 1.0),
                    detail::get(spreads_, i, 0.0),
                    refStart, refEnd,
                    observationsSchedules.back(),
                    detail::get(lowerTriggers_, i, Null<Rate>()),
                    detail::get(upperTriggers_, i, Null<Rate>()))));
    }
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/cashflows/lineartsrpricer.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    for (Size i = 0; i < swap_->fixedLeg().size(); i++) {
        boost::shared_ptr<Coupon> c =
            boost::dynamic_pointer_cast<Coupon>(swap_->fixedLeg()[i]);
        Real yf = c->accrualPeriod();
        Date d = c->date();
        Real pv = yf * discountCurve_->discount(d);
        gx += pv * GsrG(d);
        gy += pv;
    }

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/cashflows/conundrumpricer.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        for (Size i = 1; i < k_ ; ++i) {
            temp *= x;
        }

for (Size i=0; i<n; ++i) {
    boost::shared_ptr<Coupon> coupon =
        boost::dynamic_pointer_cast<Coupon>(fixedLeg[i]);
    accruals_.push_back(coupon->accrualPeriod());
}

for(Size i=0; i<accruals_.size(); i++) {
    product *= 1./(1.+ accruals_[i]*x);
}

for (Size i=0; i<accruals_.size(); i++) {
    Real temp = 1.0/(1.0+ accruals_[i]*x);
    b.push_back(temp);
    c *= temp;
    derC += accruals_[i]*temp;
}

for(Size i=0; i<accruals_.size(); i++) {
    Real temp = 1.0/(1.0+ accruals_[i]*x);
    b.push_back(temp);
    c *= temp;
    sum += accruals_[i]*temp;
    sumOfSquare += std::pow(accruals_[i]*temp, 2.0);
}

for(Size i=0; i<n; ++i) {
    boost::shared_ptr<Coupon> coupon =
        boost::dynamic_pointer_cast<Coupon>(fixedLeg[i]);
    accruals_.push_back(coupon->accrualPeriod());
    const Date paymentDate(coupon->date());
    const double swapPaymentTime(dc.yearFraction(rateCurve->referenceDate(), paymentDate));
    shapedSwapPaymentTimes_.push_back(shapeOfShift(swapPaymentTime));
    swapPaymentDiscounts_.push_back(rateCurve->discount(paymentDate));
}

for(Size i=0; i<accruals_.size(); i++) {
    sqrtDenominator += accruals_[i]*swapPaymentDiscounts_[i]
        *std::exp(-shapedSwapPaymentTimes_[i]*x);
    derSqrtDenominator -= shapedSwapPaymentTimes_[i]* accruals_[i]*swapPaymentDiscounts_[i]
        *std::exp(-shapedSwapPaymentTimes_[i]*x);
}

for(Size i=0; i<accruals_.size(); i++) {
    denOfRfunztion += accruals_[i]*swapPaymentDiscounts_[i]
        *std::exp(-shapedSwapPaymentTimes_[i]*x);
    derDenOfRfunztion -= shapedSwapPaymentTimes_[i]* accruals_[i]*swapPaymentDiscounts_[i]
        *std::exp(-shapedSwapPaymentTimes_[i]*x);
    der2DenOfRfunztion+= shapedSwapPaymentTimes_[i]*shapedSwapPaymentTimes_[i]* accruals_[i]*
        swapPaymentDiscounts_[i]*std::exp(-shapedSwapPaymentTimes_[i]*x);
}

for(Size i=0; i<o_.accruals_.size(); i++) {
    Real temp = o_.accruals_[i]*o_.swapPaymentDiscounts_[i]
        *std::exp(-o_.shapedSwapPaymentTimes_[i]*x);
    result += temp;
    derivative_ -= o_.shapedSwapPaymentTimes_[i] * temp;
}

    for(Size i=0; i<accruals_.size(); i++) {
        N+=accruals_[i]*swapPaymentDiscounts_[i];
        D+=accruals_[i]*swapPaymentDiscounts_[i]*shapedSwapPaymentTimes_[i];
    }

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/cashflows/cpicoupon.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    for (Size i=0; i<n; ++i) {
        refStart = start = schedule_.date(i);
        refEnd   =   end = schedule_.date(i+1);
        Date paymentDate = paymentCalendar_.adjust(end, paymentAdjustment_);

        Date exCouponDate;
        if (exCouponPeriod_ != Period())
        {
            exCouponDate = exCouponCalendar_.advance(paymentDate,
                                                        -exCouponPeriod_,
                                                        exCouponAdjustment_,
                                                        exCouponEndOfMonth_);
        }

        if (i==0   && !schedule_.isRegular(i+1)) {
            BusinessDayConvention bdc = schedule_.businessDayConvention();
            refStart = schedule_.calendar().adjust(end - schedule_.tenor(), bdc);
        }
        if (i==n-1 && !schedule_.isRegular(i+1)) {
            BusinessDayConvention bdc = schedule_.businessDayConvention();
            refEnd = schedule_.calendar().adjust(start + schedule_.tenor(), bdc);
        }
        if (detail::get(fixedRates_, i, 1.0) == 0.0) { // fixed coupon
            leg.push_back(boost::shared_ptr<CashFlow>
                          (new FixedRateCoupon
                           (paymentDate, detail::get(notionals_, i, 0.0),
                            detail::effectiveFixedRate(spreads_,caps_,floors_,i),
                            paymentDayCounter_, start, end, refStart, refEnd, exCouponDate)));
        } else { // zero inflation coupon
            if (detail::noOption(caps_, floors_, i)) { // just swaplet
                boost::shared_ptr<CPICoupon> coup;

                coup = boost::shared_ptr<CPICoupon>
                    (new CPICoupon(baseCPI_,    // all have same base for ratio
                             paymentDate,
                             detail::get(notionals_, i, 0.0),
                             start, end,
                             detail::get(fixingDays_, i, 0.0),
                             index_, observationLag_,
                             observationInterpolation_,
                             paymentDayCounter_,
                             detail::get(fixedRates_, i, 0.0),
                             detail::get(spreads_, i, 0.0),
                             refStart, refEnd, exCouponDate));

                // in this case you can set a pricer
                // straight away because it only provides computation - not data
                boost::shared_ptr<CPICouponPricer> pricer
                    (new CPICouponPricer);
                coup->setPricer(pricer);
                leg.push_back(boost::dynamic_pointer_cast<CashFlow>(coup));

            } else  {     // cap/floorlet
                QL_FAIL("caps/floors on CPI coupons not implemented.");
            }
        }
    }

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/cashflows/timebasket.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i = 0; i < dates.size(); i++)
    self[dates[i]] = values[i];

for (Size i = 0; i < sbuckets.size(); i++)
    result[sbuckets[i]] = 0.0;

for (const_iterator j = begin(); j != end(); ++j) {
    Date date = j->first;
    Real value = j->second;
    Date pDate = Null<Date>(), nDate = Null<Date>();

    std::vector<Date>::const_iterator bi =
        std::lower_bound(sbuckets.begin(), sbuckets.end(), date);

    if (bi == sbuckets.end())
        pDate = sbuckets.back();
    else
        pDate = *bi;

    if (bi != sbuckets.begin() && bi != sbuckets.end())
        nDate = *(bi-1);

    if (pDate == date || nDate == Null<Date>()) {
        result[pDate] += value;
    } else {
        Real pDays = Real(pDate-date);
        Real nDays = Real(date-nDate);
        Real tDays = Real(pDate-nDate);
        result[pDate] += value*(nDays/tDays);
        result[nDate] += value*(pDays/tDays);
    }
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/cashflows/couponpricer.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i<leg.size(); ++i) {
    leg[i]->accept(setter);
}

for (Size i=0; i<nCashFlows; ++i) {
    PricerSetter setter(i<nPricers ? pricers[i] : pricers[nPricers-1]);
    leg[i]->accept(setter);
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/cashflows/averagebmacoupon.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        for (Size i=0; i<fixingDates.size() - 1; ++i) {
            Date valueDate = index->valueDate(fixingDates[i]);
            Date nextValueDate = index->valueDate(fixingDates[i+1]);

            if (fixingDates[i] >= endDate || valueDate >= endDate)
                break;
            if (fixingDates[i+1] < startDate
                || nextValueDate <= startDate)
                continue;

            d2 = std::min(nextValueDate, endDate);

            avgBMA += index->fixing(fixingDates[i]) * (d2 - d1);

            days += d2 - d1;
            d1 = d2;
        }

for (Size i=0; i<fixings.size(); ++i)
    fixings[i] = index_->fixing(fixingSchedule_.date(i));

for (Size i=0; i<n; ++i) {
    refStart = start = schedule_.date(i);
    refEnd   =   end = schedule_.date(i+1);
    paymentDate = calendar.adjust(end, paymentAdjustment_);
    if (i == 0 && !schedule_.isRegular(i+1))
        refStart = calendar.adjust(end - schedule_.tenor(),
                                   paymentAdjustment_);
    if (i == n-1 && !schedule_.isRegular(i+1))
        refEnd = calendar.adjust(start + schedule_.tenor(),
                                 paymentAdjustment_);

    cashflows.push_back(boost::shared_ptr<CashFlow>(new
        AverageBMACoupon(paymentDate,
                         detail::get(notionals_, i, notionals_.back()),
                         start, end,
                         index_,
                         detail::get(gearings_, i, 1.0),
                         detail::get(spreads_, i, 0.0),
                         refStart, refEnd,
                         paymentDayCounter_)));
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/cashflows/yoyinflationcoupon.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i<n; ++i) {
    refStart = start = schedule_.date(i);
    refEnd   =   end = schedule_.date(i+1);
    Date paymentDate = calendar.adjust(end, paymentAdjustment_);
    if (i==0   && !schedule_.isRegular(i+1)) {
        BusinessDayConvention bdc = schedule_.businessDayConvention();
        refStart = schedule_.calendar().adjust(end - schedule_.tenor(), bdc);
    }
    if (i==n-1 && !schedule_.isRegular(i+1)) {
        BusinessDayConvention bdc = schedule_.businessDayConvention();
        refEnd = schedule_.calendar().adjust(start + schedule_.tenor(), bdc);
    }
    if (detail::get(gearings_, i, 1.0) == 0.0) { // fixed coupon
        leg.push_back(boost::shared_ptr<CashFlow>(new
                    FixedRateCoupon(paymentDate,
                    detail::get(notionals_, i, 1.0),
                    detail::effectiveFixedRate(spreads_,caps_,
                            floors_,i),
                            paymentDayCounter_,
                            start, end, refStart, refEnd)));
    } else { // yoy inflation coupon
        if (detail::noOption(caps_, floors_, i)) { // just swaplet
            boost::shared_ptr<YoYInflationCoupon> coup(new
                    YoYInflationCoupon(
                    paymentDate,
                    detail::get(notionals_, i, 1.0),
                    start, end,
                    detail::get(fixingDays_, i, 0),
                    index_,
                    observationLag_,
                    paymentDayCounter_,
                    detail::get(gearings_, i, 1.0),
                    detail::get(spreads_, i, 0.0),
                    refStart, refEnd));

            // in this case you can set a pricer
            // straight away because it only provides computation - not data
            boost::shared_ptr<YoYInflationCouponPricer> pricer(
                                    new YoYInflationCouponPricer);
            coup->setPricer(pricer);
            leg.push_back(boost::dynamic_pointer_cast<CashFlow>(coup));



        } else {    // cap/floorlet
            leg.push_back(boost::shared_ptr<CashFlow>(new
                    CappedFlooredYoYInflationCoupon(
                    paymentDate,
                    detail::get(notionals_, i, 1.0),
                    start, end,
                    detail::get(fixingDays_, i, 0),
                    index_,
                    observationLag_,
                    paymentDayCounter_,
                    detail::get(gearings_, i, 1.0),
                    detail::get(spreads_, i, 0.0),
                    detail::get(caps_,   i, Null<Rate>()),
                    detail::get(floors_, i, Null<Rate>()),
                    refStart, refEnd)));
        }
    }
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/cashflows/cashflows.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i<leg.size(); ++i) {
    shared_ptr<Coupon> c = dynamic_pointer_cast<Coupon>(leg[i]);
    if (c)
        d = std::min(d, c->accrualStartDate());
    else
        d = std::min(d, leg[i]->date());
}

for (Size i=0; i<leg.size(); ++i) {
    shared_ptr<Coupon> c = dynamic_pointer_cast<Coupon>(leg[i]);
    if (c)
        d = std::max(d, c->accrualEndDate());
    else
        d = std::max(d, leg[i]->date());
}

for (Size i=leg.size(); i>0; --i)
    if (!leg[i-1]->hasOccurred(settlementDate,
                               includeSettlementDateFlows))
        return false;

for (i = leg.rbegin(); i<leg.rend(); ++i) {
    if ( (*i)->hasOccurred(settlementDate, includeSettlementDateFlows) )
        return i;
}

for (i = leg.begin(); i<leg.end(); ++i) {
    if ( ! (*i)->hasOccurred(settlementDate, includeSettlementDateFlows) )
        return i;
}

for (; cf<leg.rend() && (*cf)->date()==paymentDate; ++cf)
    result += (*cf)->amount();

for (; cf<leg.end() && (*cf)->date()==paymentDate; ++cf)
    result += (*cf)->amount();

    for (; first<last && (*first)->date()==paymentDate; ++first) {
        shared_ptr<Coupon> cp = dynamic_pointer_cast<Coupon>(*first);
        if (cp) {
            if (firstCouponFound) {
                QL_REQUIRE(nominal       == cp->nominal() &&
                           accrualPeriod == cp->accrualPeriod() &&
                           dc            == cp->dayCounter(),
                           "cannot aggregate two different coupons on "
                           << paymentDate);
            } else {
                firstCouponFound = true;
                nominal = cp->nominal();
                accrualPeriod = cp->accrualPeriod();
                dc = cp->dayCounter();
            }
            result += cp->rate();
        }
    }

for (; cf<leg.end() && (*cf)->date()==paymentDate; ++cf) {
    shared_ptr<Coupon> cp = dynamic_pointer_cast<Coupon>(*cf);
    if (cp)
        return cp->nominal();
}

for (; cf<leg.end() && (*cf)->date()==paymentDate; ++cf) {
    shared_ptr<Coupon> cp = dynamic_pointer_cast<Coupon>(*cf);
    if (cp)
        return cp->accrualStartDate();
}

for (; cf<leg.end() && (*cf)->date()==paymentDate; ++cf) {
    shared_ptr<Coupon> cp = dynamic_pointer_cast<Coupon>(*cf);
    if (cp)
        return cp->accrualEndDate();
}

for (; cf<leg.end() && (*cf)->date()==paymentDate; ++cf) {
    shared_ptr<Coupon> cp = dynamic_pointer_cast<Coupon>(*cf);
    if (cp)
        return cp->referencePeriodStart();
}

for (; cf<leg.end() && (*cf)->date()==paymentDate; ++cf) {
    shared_ptr<Coupon> cp = dynamic_pointer_cast<Coupon>(*cf);
    if (cp)
        return cp->referencePeriodEnd();
}

for (; cf<leg.end() && (*cf)->date()==paymentDate; ++cf) {
    shared_ptr<Coupon> cp = dynamic_pointer_cast<Coupon>(*cf);
    if (cp)
        return cp->accrualPeriod();
}

for (; cf<leg.end() && (*cf)->date()==paymentDate; ++cf) {
    shared_ptr<Coupon> cp = dynamic_pointer_cast<Coupon>(*cf);
    if (cp)
        return cp->accrualDays();
}

for (; cf<leg.end() && (*cf)->date()==paymentDate; ++cf) {
    shared_ptr<Coupon> cp = dynamic_pointer_cast<Coupon>(*cf);
    if (cp)
        return cp->accruedPeriod(settlementDate);
}

for (; cf<leg.end() && (*cf)->date()==paymentDate; ++cf) {
    shared_ptr<Coupon> cp = dynamic_pointer_cast<Coupon>(*cf);
    if (cp)
        return cp->accruedDays(settlementDate);
}

for (; cf<leg.end() && (*cf)->date()==paymentDate; ++cf) {
    shared_ptr<Coupon> cp = dynamic_pointer_cast<Coupon>(*cf);
    if (cp)
        result += cp->accruedAmount(settlementDate);
}

for (Size i=0; i<leg.size(); ++i) {
    if (!leg[i]->hasOccurred(settlementDate,
                             includeSettlementDateFlows) &&
        !leg[i]->tradingExCoupon(settlementDate))
        totalNPV += leg[i]->amount() *
                    discountCurve.discount(leg[i]->date());
}

for (Size i=0; i<leg.size(); ++i) {
    if (!leg[i]->hasOccurred(settlementDate,
                             includeSettlementDateFlows) &&
        !leg[i]->tradingExCoupon(settlementDate))
        leg[i]->accept(calc);
}

for (Size i=0; i<leg.size(); ++i) {
    CashFlow& cf = *leg[i];
    if (!cf.hasOccurred(settlementDate,
                        includeSettlementDateFlows) &&
        !cf.tradingExCoupon(settlementDate)) {
        boost::shared_ptr<Coupon> cp =
            boost::dynamic_pointer_cast<Coupon>(leg[i]);
        Real df = discountCurve.discount(cf.date());
        npv += cf.amount() * df;
        if(cp != NULL)
            bps += cp->nominal() * cp->accrualPeriod() * df;
    }
}

for (Size i=0; i<leg.size(); ++i) {
    CashFlow& cf = *leg[i];
    if (!cf.hasOccurred(settlementDate,
                        includeSettlementDateFlows) &&
        !cf.tradingExCoupon(settlementDate)) {
        npv += cf.amount() *
               discountCurve.discount(cf.date());
        cf.accept(calc);
    }
}

    for (Size i=0; i<leg.size(); ++i) {
        if (leg[i]->hasOccurred(settlementDate,
                                includeSettlementDateFlows))
            continue;

        Real c = leg[i]->amount();
        if (leg[i]->tradingExCoupon(settlementDate)) {
            c = 0.0;
        }

        Date couponDate = leg[i]->date();
        shared_ptr<Coupon> coupon =
            boost::dynamic_pointer_cast<Coupon>(leg[i]);
        if (coupon) {
            refStartDate = coupon->referencePeriodStart();
            refEndDate = coupon->referencePeriodEnd();
        } else {
            if (lastDate == npvDate) {
                // we don't have a previous coupon date,
                // so we fake it
                refStartDate = couponDate - 1*Years;
            } else  {
                refStartDate = lastDate;
            }
            refEndDate = couponDate;
        }

        t += dc.yearFraction(lastDate, couponDate,
                             refStartDate, refEndDate);

        DiscountFactor B = y.discountFactor(t);
        P += c * B;
        dPdy += t * c * B;
        
        lastDate = couponDate;
    }

    for (Size i=0; i<leg.size(); ++i) {
        if (leg[i]->hasOccurred(settlementDate,
                                includeSettlementDateFlows))
            continue;

        Real c = leg[i]->amount();
        if (leg[i]->tradingExCoupon(settlementDate)) {
            c = 0.0;
        }

        Date couponDate = leg[i]->date();
        shared_ptr<Coupon> coupon =
            boost::dynamic_pointer_cast<Coupon>(leg[i]);
        if (coupon) {
            refStartDate = coupon->referencePeriodStart();
            refEndDate = coupon->referencePeriodEnd();
        } else {
            if (lastDate == npvDate) {
                // we don't have a previous coupon date,
                // so we fake it
                refStartDate = couponDate - 1*Years;
            } else  {
                refStartDate = lastDate;
            }
            refEndDate = couponDate;
        }
        
        t += dc.yearFraction(lastDate, couponDate,
                             refStartDate, refEndDate);
        
        DiscountFactor B = y.discountFactor(t);
        P += c * B;
        switch (y.compounding()) {
          case Simple:
            dPdy -= c * B*B * t;
            break;
          case Compounded:
            dPdy -= c * t * B/(1+r/N);
            break;
          case Continuous:
            dPdy -= c * B * t;
            break;
          case SimpleThenCompounded:
            if (t<=1.0/N)
                dPdy -= c * B*B * t;
            else
                dPdy -= c * t * B/(1+r/N);
            break;
          default:
            QL_FAIL("unknown compounding convention (" <<
                    Integer(y.compounding()) << ")");
        }
        lastDate = couponDate;
    }

        for (Size i = 0; i < leg_.size(); ++i) {
            if (!leg_[i]->hasOccurred(settlementDate_,
                                      includeSettlementDateFlows_) &&
                !leg_[i]->tradingExCoupon(settlementDate_)) {
                Integer thisSign = sign(leg_[i]->amount());
                if (lastSign * thisSign < 0) // sign change
                    signChanges++;

                if (thisSign != 0)
                    lastSign = thisSign;
            }
        }

            for (Size i = 0; i < leg.size(); ++i) {
                Real nextAggregateCashFlow =
                    aggregateCashFlow + leg[i]->amount();

                if (aggregateCashFlow * nextAggregateCashFlow < 0.0)
                    signChanges++;

                aggregateCashFlow = nextAggregateCashFlow;
            }

for (Size i=0; i<leg.size(); ++i) {
    if (leg[i]->hasOccurred(settlementDate,
                            includeSettlementDateFlows))
        continue;

    Date couponDate = leg[i]->date();
    Real amount = leg[i]->amount();
    if (leg[i]->tradingExCoupon(settlementDate)) {
        amount = 0.0;
    }

    shared_ptr<Coupon> coupon =
        boost::dynamic_pointer_cast<Coupon>(leg[i]);
    if (coupon) {
        refStartDate = coupon->referencePeriodStart();
        refEndDate = coupon->referencePeriodEnd();
    } else {
        if (lastDate == npvDate) {
            // we don't have a previous coupon date,
            // so we fake it
            refStartDate = couponDate - 1*Years;
        } else  {
            refStartDate = lastDate;
        }
        refEndDate = couponDate;
    }
    DiscountFactor b = y.discountFactor(lastDate, couponDate,
                                        refStartDate, refEndDate);
    discount *= b;
    lastDate = couponDate;

    npv += amount * discount;
}

for (Size i=0; i<leg.size(); ++i) {
    if (leg[i]->hasOccurred(settlementDate,
                                includeSettlementDateFlows))
        continue;
    
    Real c = leg[i]->amount();
    if (leg[i]->tradingExCoupon(settlementDate)) {
        c = 0.0;
    }

    Date couponDate = leg[i]->date();
    shared_ptr<Coupon> coupon =
        boost::dynamic_pointer_cast<Coupon>(leg[i]);
    if (coupon) {
        refStartDate = coupon->referencePeriodStart();
        refEndDate = coupon->referencePeriodEnd();
    } else {
        if (lastDate == npvDate) {
            // we don't have a previous coupon date,
            // so we fake it
            refStartDate = couponDate - 1*Years;
        } else  {
            refStartDate = lastDate;
        }
        refEndDate = couponDate;
    }
    
    t += dc.yearFraction(lastDate, couponDate,
                         refStartDate, refEndDate);
    
    DiscountFactor B = y.discountFactor(t);
    P += c * B;
    switch (y.compounding()) {
      case Simple:
        d2Pdy2 += c * 2.0*B*B*B*t*t;
        break;
      case Compounded:
        d2Pdy2 += c * B*t*(N*t+1)/(N*(1+r/N)*(1+r/N));
        break;
      case Continuous:
        d2Pdy2 += c * B*t*t;
        break;
      case SimpleThenCompounded:
        if (t<=1.0/N)
            d2Pdy2 += c * 2.0*B*B*B*t*t;
        else
            d2Pdy2 += c * B*t*(N*t+1)/(N*(1+r/N)*(1+r/N));
        break;
      default:
        QL_FAIL("unknown compounding convention (" <<
                Integer(y.compounding()) << ")");
    }
    lastDate = couponDate;
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/cashflows/fixedratecoupon.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i<rates.size(); ++i)
    couponRates_[i] = InterestRate(rates[i], dc, comp, freq);

for (Size i=2; i<schedule_.size()-1; ++i) {
    start = end; end = schedule_.date(i);
    paymentDate = calendar_.adjust(end, paymentAdjustment_);
    if (exCouponPeriod_ != Period())
    {
        exCouponDate = exCouponCalendar_.advance(paymentDate,
                                                 -exCouponPeriod_,
                                                 exCouponAdjustment_,
                                                 exCouponEndOfMonth_);
    }
    if ((i-1) < couponRates_.size())
        rate = couponRates_[i-1];
    else
        rate = couponRates_.back();
    if ((i-1) < notionals_.size())
        nominal = notionals_[i-1];
    else
        nominal = notionals_.back();
    leg.push_back(shared_ptr<CashFlow>(new
        FixedRateCoupon(paymentDate, nominal, rate,
                        start, end, start, end, exCouponDate)));
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/cashflows/overnightindexedcoupon.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    for (Size i=0; i<n_; ++i)
        fixingDates_[i] = overnightIndex->fixingDate(valueDates_[i]);

for (Size i=0; i<n_; ++i)
    dt_[i] = dc.yearFraction(valueDates_[i], valueDates_[i+1]);

for (Size i=0; i<n_; ++i)
    fixings_[i] = index_->fixing(fixingDates_[i]);

for (Size i=0; i<n; ++i) {
    refStart = start = schedule_.date(i);
    refEnd   =   end = schedule_.date(i+1);
    paymentDate = calendar.adjust(end, paymentAdjustment_);
    if (i == 0 && !schedule_.isRegular(i+1))
        refStart = calendar.adjust(end - schedule_.tenor(),
                                   paymentAdjustment_);
    if (i == n-1 && !schedule_.isRegular(i+1))
        refEnd = calendar.adjust(start + schedule_.tenor(),
                                 paymentAdjustment_);

    cashflows.push_back(shared_ptr<CashFlow>(new
        OvernightIndexedCoupon(paymentDate,
                               detail::get(notionals_, i,
                                           notionals_.back()),
                               start, end,
                               overnightIndex_,
                               detail::get(gearings_, i, 1.0),
                               detail::get(spreads_, i, 0.0),
                               refStart, refEnd,
                               paymentDayCounter_)));
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/time/schedule.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    for (;;) {
        Date temp = nullCalendar.advance(seed,
            -periods*(*tenor_), convention, *endOfMonth_);
        if (temp < exitDate) {
            if (firstDate_ != Date() &&
                (calendar_.adjust(dates_.front(),convention)!=
                 calendar_.adjust(firstDate_,convention))) {
                dates_.insert(dates_.begin(), firstDate_);
                isRegular_.insert(isRegular_.begin(), false);
            }
            break;
        } else {
            // skip dates that would result in duplicates
            // after adjustment
            if (calendar_.adjust(dates_.front(),convention)!=
                calendar_.adjust(temp,convention)) {
                dates_.insert(dates_.begin(), temp);
                isRegular_.insert(isRegular_.begin(), true);
            }
            ++periods;
        }
    }

    for (;;) {
        Date temp = nullCalendar.advance(seed, periods*(*tenor_),
                                         convention, *endOfMonth_);
        if (temp > exitDate) {
            if (nextToLastDate_ != Date() &&
                (calendar_.adjust(dates_.back(),convention)!=
                 calendar_.adjust(nextToLastDate_,convention))) {
                dates_.push_back(nextToLastDate_);
                isRegular_.push_back(false);
            }
            break;
        } else {
            // skip dates that would result in duplicates
            // after adjustment
            if (calendar_.adjust(dates_.back(),convention)!=
                calendar_.adjust(temp,convention)) {
                dates_.push_back(temp);
                isRegular_.push_back(true);
            }
            ++periods;
        }
    }

    for (Size i=1; i<dates_.size()-1; ++i)
        dates_[i] = Date::nthWeekday(3, Wednesday,
                                     dates_[i].month(),
                                     dates_[i].year());

        for (Size i=1; i<dates_.size()-1; ++i)
            dates_[i] = Date::endOfMonth(dates_[i]);

        for (Size i=1; i<dates_.size()-1; ++i)
            dates_[i] = calendar_.endOfMonth(dates_[i]);

    for (Size i=1; i<dates_.size()-1; ++i)
        dates_[i] = calendar_.adjust(dates_[i], convention);

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/time/ecb.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    for (Size i=0; i<n; ++i)
        knownDateSet.insert(Date(knownDatesArray[i]));

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/time/calendar.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        for (Date d = from; d < to; ++d) {
            if (isBusinessDay(d))
                ++wd;
        }

        for (Date d = to; d < from; ++d) {
            if (isBusinessDay(d))
                ++wd;
        }

for (Date d = from; d <= to; ++d) {
    if (calendar.isHoliday(d)
        && (includeWeekEnds || !calendar.isWeekend(d.weekday())))
        result.push_back(d);
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/time/daycounters/actualactual.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    for (;;) {
        newRefStart = refPeriodEnd + (months*i)*Months;
        newRefEnd = refPeriodEnd + (months*(i+1))*Months;
        if (d2 < newRefEnd) {
            break;
        } else {
            sum += period;
            i++;
        }
    }

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/time/daycounters/business252.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        for (Integer i=1; i<=12; ++i) {
            total += businessDays(cache,calendar,
                                  Month(i), year);
        }

    for (Integer m = Integer(d1.month())+1; m <= 12; ++m) {
        total += businessDays(cache, calendar_,
                              Month(m), d.year());
    }

    for (Integer m = 1; m<Integer(d2.month()); ++m) {
        total += businessDays(cache, calendar_,
                              Month(m), d2.year());
    }

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/time/calendars/jointcalendar.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (i=calendars_.begin()+1; i!=calendars_.end(); ++i)
    out << ", " << i->name();

    for (i=calendars_.begin(); i!=calendars_.end(); ++i) {
        if (i->isWeekend(w))
            return true;
    }

    for (i=calendars_.begin(); i!=calendars_.end(); ++i) {
        if (!i->isWeekend(w))
            return false;
    }

    for (i=calendars_.begin(); i!=calendars_.end(); ++i) {
        if (i->isHoliday(date))
            return false;
    }

    for (i=calendars_.begin(); i!=calendars_.end(); ++i) {
        if (i->isBusinessDay(date))
            return true;
    }

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/termstructures/yieldtermstructure.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i<nJumps_; ++i)
    registerWith(jumps_[i]);

for (Size i=0; i<nJumps_; ++i)
    registerWith(jumps_[i]);

for (Size i=0; i<nJumps_; ++i)
    registerWith(jumps_[i]);

    for (Size i=0; i<nJumps_; ++i)
        jumpDates_[i] = Date(31, December, y+i);

for (Size i=0; i<nJumps_; ++i)
    jumpTimes_[i] = timeFromReference(jumpDates_[i]);

for (Size i=0; i<nJumps_; ++i) {
    if (jumpTimes_[i]>0 && jumpTimes_[i]<t) {
        QL_REQUIRE(jumps_[i]->isValid(),
                   "invalid " << io::ordinal(i+1) << " jump quote");
        DiscountFactor thisJump = jumps_[i]->value();
        QL_REQUIRE(thisJump>0.0 && thisJump<=1.0,
                   "invalid " << io::ordinal(i+1) << " jump value: " <<
                   thisJump);
        jumpEffect *= thisJump;
    }
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/termstructures/defaulttermstructure.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i<nJumps_; ++i)
    registerWith(jumps_[i]);

for (Size i=0; i<nJumps_; ++i)
    registerWith(jumps_[i]);

for (Size i=0; i<nJumps_; ++i)
    registerWith(jumps_[i]);

    for (Size i=0; i<nJumps_; ++i)
        jumpDates_[i] = Date(31, December, y+i);

for (Size i=0; i<nJumps_; ++i)
    jumpTimes_[i] = timeFromReference(jumpDates_[i]);

    for (Size i=0; i<nJumps_ && jumpTimes_[i]<t; ++i) {
        QL_REQUIRE(jumps_[i]->isValid(),
                   "invalid " << io::ordinal(i+1) << " jump quote");
        DiscountFactor thisJump = jumps_[i]->value();
        QL_REQUIRE(thisJump > 0.0 && thisJump <= 1.0,
                   "invalid " << io::ordinal(i+1) << " jump value: " <<
                   thisJump);
        jumpEffect *= thisJump;
    }

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/termstructures/yield/forwardstructure.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Time i=dt; i<t; i+=dt)
    sum += forwardImpl(i);

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/termstructures/yield/fittedbonddiscountcurve.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i<bondHelpers_.size(); ++i) {
    shared_ptr<Bond> bond = bondHelpers_[i]->bond();
    QL_REQUIRE(bondHelpers_[i]->quote()->isValid(),
               io::ordinal(i+1) << " bond (maturity: " <<
               bond->maturityDate() << ") has an invalid price quote");
    Date bondSettlement = bond->settlementDate();
    QL_REQUIRE(bondSettlement>=refDate,
               io::ordinal(i+1) << " bond settlemente date (" <<
               bondSettlement << ") before curve reference date (" <<
               refDate << ")");
    QL_REQUIRE(BondFunctions::isTradable(*bond, bondSettlement),
               io::ordinal(i+1) << " bond non tradable at " <<
               bondSettlement << " settlement date (maturity"
               " being " << bond->maturityDate() << ")");
    maxDate_ = std::max(maxDate_, bondHelpers_[i]->latestDate());
    bondHelpers_[i]->setTermStructure(
                          const_cast<FittedBondDiscountCurve*>(this));
}

for (Size i=0; i<curve_->bondHelpers_.size(); ++i) {
    shared_ptr<Bond> bond = curve_->bondHelpers_[i]->bond();

    Leg leg = bond->cashflows();
    Real cleanPrice = curve_->bondHelpers_[i]->quote()->value();
    
    Date bondSettlement = bond->settlementDate();
    Rate ytm = BondFunctions::yield(*bond, cleanPrice,
                                    yieldDC, yieldComp, yieldFreq,
                                    bondSettlement);

    Time dur = BondFunctions::duration(*bond, ytm,
                                       yieldDC, yieldComp, yieldFreq,
                                       Duration::Modified,
                                       bondSettlement);
    weights_[i] = 1.0/dur;
    squaredSum += weights_[i]*weights_[i];

    const Leg& cf = bond->cashflows();
    for (Size k=0; k<cf.size(); ++k) {
        if (!cf[k]->hasOccurred(bondSettlement, false)) {
            costFunction_->firstCashFlow_[i] = k;
            break;
        }
    }
}

for (Size i=0; i<n; ++i) {

    shared_ptr<Bond> bond =
                    fittingMethod_->curve_->bondHelpers_[i]->bond();
    Date bondSettlement = bond->settlementDate();

    // CleanPrice_i = sum( cf_k * d(t_k) ) - accruedAmount
    Real modelPrice = - bond->accruedAmount(bondSettlement);
    const Leg& cf = bond->cashflows();
    for (Size k=firstCashFlow_[i]; k<cf.size(); ++k) {
        Time tenor = dc.yearFraction(refDate, cf[k]->date());
        modelPrice += cf[k]->amount() *
                            fittingMethod_->discountFunction(x, tenor);
    }

    // adjust price (NPV) for forward settlement
    if (bondSettlement != refDate ) {
        Time tenor = dc.yearFraction(refDate, bondSettlement);
        modelPrice /= fittingMethod_->discountFunction(x, tenor);
    }
    Real marketPrice =
        fittingMethod_->curve_->bondHelpers_[i]->quote()->value();
    Real error = modelPrice - marketPrice;
    Real weightedError = fittingMethod_->weights_[i] * error;
    squaredError += weightedError * weightedError;
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/termstructures/yield/nonlinearfittingmethods.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    for (Size i=0; i<N-1; ++i) {
        d += x[i]* std::exp(-kappa * (i+1) * t);
    }

    for (Size i=0; i<N-1; i++) {
        d += x[i]* std::exp(-kappa * (i+2) * t);
        coeff += x[i];
    }

    for (Size i=0; i<size_; ++i) {
        d += x[i] * splines_(i,t);
    }

    for (Size i=0; i<size_; ++i) {
        if (i < N_) {
            d += x[i] * splines_(i,t);
            sum += x[i] * splines_(i,T);
        } else {
            d += x[i] * splines_(i+1,t);
            sum += x[i] * splines_(i+1,T);
        }
    }

    for (Size i=0; i<size_; ++i)
        d += x[i] * BernsteinPolynomial::get(i,i,t);

    for (Size i=0; i<size_; ++i)
        d += x[i] * BernsteinPolynomial::get(i+1,i+1,t);

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/termstructures/inflation/seasonality.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i = 1; i < nTest; i++) {
    Real factorAt = this->seasonalityFactor(curveBaseDate+Period(i,Years));
    QL_REQUIRE(std::fabs(factorAt-factorBase)<eps,"seasonality is inconsistent with inflation term structure, factors "
               << factorBase << " and later factor " << factorAt << ", " << i << " years later from inflation curve "
               <<" with base date at " << curveBaseDate);
}

for(Size i=0; i<seasonalityFactors.size(); i++) {
    seasonalityFactors_[i] = seasonalityFactors[i];
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/termstructures/volatility/sabrinterpolatedsmilesection.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    for (Size i=0; i<volHandles_.size(); ++i)
        LazyObject::registerWith(volHandles_[i]);

    for (Size i=0; i<volHandles_.size(); ++i)
        volHandles_[i] = Handle<Quote>(boost::shared_ptr<Quote>(new
                                SimpleQuote(volHandles[i])));

for (Size i=0; i<volHandles_.size(); ++i) {
    if (volHandles_[i]->isValid()) {
        if (hasFloatingStrikes_) {
            actualStrikes_.push_back(forwardValue_ + strikes_[i]);
            vols_.push_back(atmVolatility_->value() + volHandles_[i]->value());
        } else {
            actualStrikes_.push_back(strikes_[i]);
            vols_.push_back(volHandles_[i]->value());
        }
    }
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/termstructures/volatility/smilesectionutils.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    for (Size i = 0; i < moneynessGrid.size() - 1; i++) {
        QL_REQUIRE(moneynessGrid[i] < moneynessGrid[i + 1],
                   "moneyness grid should contain strictly increasing "
                   "values ("
                       << moneynessGrid[i] << ","
                       << moneynessGrid[i + 1] << " at indices " << i
                       << ", " << i + 1 << ")");
    }

for (Size i = 0; i < tmp.size(); i++) {
    Real k = tmp[i] * (f_ + shift) - shift;
    if (tmp[i] <= QL_EPSILON ||
        (k >= section.minStrike() && k <= section.maxStrike())) {
        if (!minStrikeAdded || !close(k, section.minStrike())) {
            m_.push_back(tmp[i]);
            k_.push_back(k);
        }
        if (close(k, section.maxStrike()))
            maxStrikeAdded = true;
    } else { // if the section provides a limited strike range
             // we put the respective endpoint in our grid
             // in order to not loose too much information
        if (k < section.minStrike() && !minStrikeAdded) {
            m_.push_back((section.minStrike()+shift) / f_);
            k_.push_back(section.minStrike());
            minStrikeAdded = true;
        }
        if (k > section.maxStrike() && !maxStrikeAdded) {
            m_.push_back((section.maxStrike()+shift)/ f_);
            k_.push_back(section.maxStrike());
            maxStrikeAdded = true;
        }
    }
}

for (Size i = 1; i < k_.size(); i++) {
    c_.push_back(section.optionPrice(k_[i], Option::Call, 1.0));
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/termstructures/volatility/kahalesmilesection.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for(Size i=0;i<k_.size();++i) {
    k_[i] += shift();
}

    for (Size i = leftIndex_; i < rightIndex_; i++) {
        Real k0 = k_[i];
        Real k1 = k_[i + 1];
        Real c0 = c_[i];
        Real c1 = c_[i + 1];
        Real sec = (c_[i + 1] - c_[i]) / (k_[i + 1] - k_[i]);
        if (i == leftIndex_)
            cp0 = leftIndex_ > 0 ? (secl + sec) / 2.0 : sec;
        Real secr;
        if (i == rightIndex_ - 1)
            secr = 0.0;
        else
            secr = (c_[i + 2] - c_[i + 1]) / (k_[i + 2] - k_[i + 1]);
        cp1 = (sec + secr) / 2.0;
        aHelper ah(k0, k1, c0, c1, cp0, cp1);
        Real a;
        bool valid = false;
        try {
            a = brent.solve(
                ah, QL_KAHALE_ACC, 0.5 * (cp1 + (1.0 + cp0)),
                cp1 + QL_KAHALE_EPS, 1.0 + cp0 - QL_KAHALE_EPS);
            // numerical parameters hardcoded here
            valid = true;
        }
        catch (...) {
            // delete the right point of the interval where we try to
            // interpolate
            moneynessGrid_.erase(moneynessGrid_.begin() + (i + 1));
            k_.erase(k_.begin() + (i + 1));
            c_.erase(c_.begin() + (i + 1));
            cFunctions_.erase(cFunctions_.begin() + (i + 1));
            rightIndex_--;
            i--;
        }
        if (valid) {
            ah(a);
            boost::shared_ptr<cFunction> cFct(
                new cFunction(ah.f_, ah.s_, a, ah.b_));
            cFunctions_[leftIndex_ > 0 ? i - leftIndex_ + 1 : 0] = cFct;
            cp0 = cp1;
        }
    }

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/termstructures/volatility/abcdcalibration.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    for (Size i=0; i<times_.size() ; i++) {
        Real stdDev = std::sqrt(blackVols_[i]* blackVols_[i]* times_[i]);
        // when strike==forward, the blackFormulaStdDevDerivative becomes
        weights_[i] = CumulativeNormalDistribution().derivative(.5*stdDev);
        weightsSum += weights_[i];
    }

    for (Size i=0; i<times_.size() ; i++) {
        weights_[i] /= weightsSum;
    }

for (Size i=0; i<t.size() ; i++) {
    k[i]=blackVols[i]/value(t[i]);
}

for (Size i=0; i<times_.size() ; i++) {
    error = (value(times_[i]) - blackVols_[i]);
    squaredError += error * error *(weights_[i]);
}

for (Size i=0; i<times_.size() ; i++) {
    error = std::fabs(value(times_[i]) - blackVols_[i]);
    maxError = std::max(maxError, error);
}

for (Size i=0; i<times_.size() ; i++) {
    results[i] = (value(times_[i]) - blackVols_[i])* std::sqrt(weights_[i]);
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/termstructures/volatility/equityfx/blackvariancecurve.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (j=1; j<=blackVolCurve.size(); j++) {
    times_[j] = timeFromReference(dates[j-1]);
    QL_REQUIRE(times_[j]>times_[j-1],
               "dates must be sorted unique!");
    variances_[j] = times_[j] *
        blackVolCurve[j-1]*blackVolCurve[j-1];
    QL_REQUIRE(variances_[j]>=variances_[j-1]
               || !forceMonotoneVariance,
               "variance must be non-decreasing");
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/termstructures/volatility/equityfx/blackvariancesurface.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (i=0; i<blackVolMatrix.rows(); i++) {
    variances_[i][0] = 0.0;
}

for (j=1; j<=blackVolMatrix.columns(); j++) {
    times_[j] = timeFromReference(dates[j-1]);
    QL_REQUIRE(times_[j]>times_[j-1],
               "dates must be sorted unique!");
    for (i=0; i<blackVolMatrix.rows(); i++) {
        variances_[i][j] = times_[j] *
            blackVolMatrix[i][j-1]*blackVolMatrix[i][j-1];
    }
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/termstructures/volatility/capfloor/capfloortermvolsurface.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i<nOptionTenors_; ++i)
    QL_REQUIRE(volHandles_[i].size()==nStrikes_,
               io::ordinal(i+1) << " row of vol handles has size " <<
               volHandles_[i].size() << " instead of " << nStrikes_);

for (Size i=0; i<vols_.rows(); ++i)
    for (Size j=0; j<vols_.columns(); ++j)
        vols_[i][j] = volHandles_[i][j]->value();

for (Size i=0; i<nOptionTenors_; ++i)
    QL_REQUIRE(volHandles_[i].size()==nStrikes_,
               io::ordinal(i+1) << " row of vol handles has size " <<
               volHandles_[i].size() << " instead of " << nStrikes_);

for (Size i=0; i<vols_.rows(); ++i)
    for (Size j=0; j<vols_.columns(); ++j)
        vols_[i][j] = volHandles_[i][j]->value();

for (Size i=0; i<nOptionTenors_; ++i) {
    volHandles_[i].resize(nStrikes_);
    for (Size j=0; j<nStrikes_; ++j)
        volHandles_[i][j] = Handle<Quote>(boost::shared_ptr<Quote>(new
            SimpleQuote(vols_[i][j])));
}

for (Size i=0; i<nOptionTenors_; ++i) {
    volHandles_[i].resize(nStrikes_);
    for (Size j=0; j<nStrikes_; ++j)
        volHandles_[i][j] = Handle<Quote>(boost::shared_ptr<Quote>(new
            SimpleQuote(vols_[i][j])));
}

for (Size i=1; i<nOptionTenors_; ++i)
    QL_REQUIRE(optionTenors_[i]>optionTenors_[i-1],
               "non increasing option tenor: " << io::ordinal(i) <<
               " is " << optionTenors_[i-1] << ", " <<
               io::ordinal(i+1) << " is " << optionTenors_[i]);

for (Size j=1; j<nStrikes_; ++j)
    QL_REQUIRE(strikes_[j-1]<strikes_[j],
               "non increasing strikes: " << io::ordinal(j) <<
               " is " << io::rate(strikes_[j-1]) << ", " <<
               io::ordinal(j+1) << " is " << io::rate(strikes_[j]));

for (Size i=0; i<nOptionTenors_; ++i)
    for (Size j=0; j<nStrikes_; ++j)
        registerWith(volHandles_[i][j]);

for (Size i=0; i<nOptionTenors_; ++i) {
    optionDates_[i] = optionDateFromTenor(optionTenors_[i]);
    optionTimes_[i] = timeFromReference(optionDates_[i]);
}

for (Size i=0; i<nOptionTenors_; ++i)
    for (Size j=0; j<nStrikes_; ++j)
        vols_[i][j] = volHandles_[i][j]->value();

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/termstructures/volatility/capfloor/capfloortermvolcurve.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i<nOptionTenors_; ++i)
    volHandles_[i] = Handle<Quote>(boost::shared_ptr<Quote>(new
        SimpleQuote(vols_[i])));

for (Size i=0; i<nOptionTenors_; ++i)
    volHandles_[i] = Handle<Quote>(boost::shared_ptr<Quote>(new
        SimpleQuote(vols_[i])));

for (Size i=1; i<nOptionTenors_; ++i)
    QL_REQUIRE(optionTenors_[i]>optionTenors_[i-1],
               "non increasing option tenor: " << io::ordinal(i) <<
               " is " << optionTenors_[i-1] << ", " <<
               io::ordinal(i+1) << " is " << optionTenors_[i]);

for (Size i=0; i<volHandles_.size(); ++i)
    registerWith(volHandles_[i]);

for (Size i=0; i<nOptionTenors_; ++i) {
    optionDates_[i] = optionDateFromTenor(optionTenors_[i]);
    optionTimes_[i] = timeFromReference(optionDates_[i]);
}

for (Size i=0; i<vols_.size(); ++i)
    vols_[i] = volHandles_[i]->value();

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/termstructures/volatility/optionlet/strippedoptionletadapter.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
 for(Size i=0;i<optionletStrikes.size();i++) {
     stddevs.push_back(volatilityImpl(t,optionletStrikes[i])*std::sqrt(t));
 }

for (Size i=0; i<nInterpolations_; ++i)
    vol[i] = strikeInterpolations_[i]->operator()(strike, true);

for (Size i=0; i<nInterpolations_; ++i) {
    const std::vector<Rate>& optionletStrikes =
        optionletStripper_->optionletStrikes(i);
    const std::vector<Volatility>& optionletVolatilities =
        optionletStripper_->optionletVolatilities(i);
    //strikeInterpolations_[i] = boost::shared_ptr<SABRInterpolation>(new
    //            SABRInterpolation(optionletStrikes.begin(), optionletStrikes.end(),
    //                              optionletVolatilities.begin(),
    //                              optionletTimes[i], atmForward[i],
    //                              0.02,0.5,0.2,0.,
    //                              false, true, false, false
    //                              //alphaGuess_, betaGuess_,
    //                              //nuGuess_, rhoGuess_,
    //                              //isParameterFixed_[0],
    //                              //isParameterFixed_[1],
    //                              //isParameterFixed_[2],
    //                              //isParameterFixed_[3]
    //                              ////,
    //                              //vegaWeightedSmileFit_,
    //                              //endCriteria_,
    //                              //optMethod_
    //                              ));
    strikeInterpolations_[i] = boost::shared_ptr<LinearInterpolation>(new
        LinearInterpolation(optionletStrikes.begin(),
                            optionletStrikes.end(),
                            optionletVolatilities.begin()));

    //QL_ENSURE(strikeInterpolations_[i]->endCriteria()!=EndCriteria::MaxIterations,
    //          "section calibration failed: "
    //          "option time " << optionletTimes[i] <<
    //          ": " <<
    //              ", alpha " <<  strikeInterpolations_[i]->alpha()<<
    //              ", beta "  <<  strikeInterpolations_[i]->beta() <<
    //              ", nu "    <<  strikeInterpolations_[i]->nu()   <<
    //              ", rho "   <<  strikeInterpolations_[i]->rho()  <<
    //              ", error " <<  strikeInterpolations_[i]->interpolationError()
    //              );

}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/termstructures/volatility/optionlet/optionletstripper1.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i<nOptionletTenors_; ++i) {
    CapFloor temp = MakeCapFloor(CapFloor::Cap,
                                 capFloorLengths_[i],
                                 iborIndex_,
                                 0.04, // dummy strike
                                 0*Days)
        .withPricingEngine(dummy);
    shared_ptr<FloatingRateCoupon> lFRC =
                                        temp.lastFloatingRateCoupon();
    optionletDates_[i] = lFRC->fixingDate();
    optionletPaymentDates_[i] = lFRC->date();
    optionletAccrualPeriods_[i] = lFRC->accrualPeriod();
    optionletTimes_[i] = dc.yearFraction(referenceDate,
                                         optionletDates_[i]);
    atmOptionletRate_[i] = lFRC->indexFixing();
}

    for (Size i=0; i<nOptionletTenors_; ++i) {
        averageAtmOptionletRate += atmOptionletRate_[i];
    }

    for (Size i=0; i<nOptionletTenors_; ++i)
        capFloors_[i].resize(nStrikes_);

    for (Size j=0; j<nStrikes_; ++j) {
        // using out-of-the-money options
        CapFloor::Type capFloorType = strikes[j] < switchStrike_ ?
                               CapFloor::Floor : CapFloor::Cap;
        for (Size i=0; i<nOptionletTenors_; ++i) {
            volQuotes_[i][j] = shared_ptr<SimpleQuote>(new
                                                        SimpleQuote());
            if (volatilityType_ == ShiftedLognormal) {
              shared_ptr<BlackCapFloorEngine> engine(
                  new BlackCapFloorEngine(
                      discountCurve, Handle<Quote>(volQuotes_[i][j]),
                      dc, displacement_));
              capFloors_[i][j] =
                  MakeCapFloor(capFloorType, capFloorLengths_[i],
                               iborIndex_, strikes[j],
                               0 * Days).withPricingEngine(engine);
            } else if (volatilityType_ == Normal) {
              shared_ptr<BachelierCapFloorEngine> engine(
                  new BachelierCapFloorEngine(
                      discountCurve, Handle<Quote>(volQuotes_[i][j]),
                      dc));
              capFloors_[i][j] =
                  MakeCapFloor(capFloorType, capFloorLengths_[i],
                               iborIndex_, strikes[j],
                               0 * Days).withPricingEngine(engine);
            } else {
              QL_FAIL("unknown volatility type: " << volatilityType_);
            }
        }
    }

for (Size j=0; j<nStrikes_; ++j) {

    Option::Type optionletType = strikes[j] < switchStrike_ ?
                           Option::Put : Option::Call;

    Real previousCapFloorPrice = 0.0;
    for (Size i=0; i<nOptionletTenors_; ++i) {

        capFloorVols_[i][j] = termVolSurface_->volatility(
            capFloorLengths_[i], strikes[j], true);
        volQuotes_[i][j]->setValue(capFloorVols_[i][j]);

        capFloorPrices_[i][j] = capFloors_[i][j]->NPV();
        optionletPrices_[i][j] = capFloorPrices_[i][j] -
                                                previousCapFloorPrice;
        previousCapFloorPrice = capFloorPrices_[i][j];
        DiscountFactor d =
            discountCurve->discount(optionletPaymentDates_[i]);
        DiscountFactor optionletAnnuity=optionletAccrualPeriods_[i]*d;
        try {
          if (volatilityType_ == ShiftedLognormal) {
            optionletStDevs_[i][j] = blackFormulaImpliedStdDev(
                optionletType, strikes[j], atmOptionletRate_[i],
                optionletPrices_[i][j], optionletAnnuity, displacement_,
                optionletStDevs_[i][j], accuracy_, maxIter_);
          } else if (volatilityType_ == Normal) {
            optionletStDevs_[i][j] =
                std::sqrt(optionletTimes_[i]) *
                bachelierBlackFormulaImpliedVol(
                    optionletType, strikes[j], atmOptionletRate_[i],
                    optionletTimes_[i], optionletPrices_[i][j],
                    optionletAnnuity);
          } else {
            QL_FAIL("Unknown volatility type: " << volatilityType_);
          }
        }
        catch (std::exception &e) {
            if(dontThrow_)
                optionletStDevs_[i][j]=0.0;
            else
                QL_FAIL("could not bootstrap optionlet:"
                    "\n type:    " << optionletType <<
                    "\n strike:  " << io::rate(strikes[j]) <<
                    "\n atm:     " << io::rate(atmOptionletRate_[i]) <<
                    "\n price:   " << optionletPrices_[i][j] <<
                    "\n annuity: " << optionletAnnuity <<
                    "\n expiry:  " << optionletDates_[i] <<
                    "\n error:   " << e.what());
        }
        optionletVolatilities_[i][j] = optionletStDevs_[i][j] /
                                        std::sqrt(optionletTimes_[i]);
    }
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/termstructures/volatility/optionlet/strippedoptionlet.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i<nOptionletDates_; ++i)
    optionletTimes_[i] = dc_.yearFraction(refDate, optionletDates_[i]);

for (Size i=1; i<nOptionletDates_; ++i)
    QL_REQUIRE(optionletDates_[i]>optionletDates_[i-1],
               "non increasing option dates: " << io::ordinal(i) <<
               " is " << optionletDates_[i-1] << ", " <<
               io::ordinal(i+1) << " is " << optionletDates_[i]);

for (Size j=1; j<nStrikes_; ++j)
    QL_REQUIRE(optionletStrikes_[0][j-1]<optionletStrikes_[0][j],
               "non increasing strikes: " << io::ordinal(j) <<
               " is " << io::rate(optionletStrikes_[0][j-1]) << ", " <<
               io::ordinal(j+1) << " is " << io::rate(optionletStrikes_[0][j]));

for (Size i=0; i<nOptionletDates_; ++i)
    for (Size j=0; j<nStrikes_; ++j)
        registerWith(optionletVolQuotes_[i][j]);

for (Size i=0; i<nOptionletDates_; ++i)
  for (Size j=0; j<nStrikes_; ++j)
    optionletVolatilities_[i][j] = optionletVolQuotes_[i][j]->value();

for (Size i=0; i<nOptionletDates_; ++i)
    optionletAtmRates_[i] = iborIndex_->fixing(optionletDates_[i], true);

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/termstructures/volatility/optionlet/optionletstripper2.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i<optionletTimes_.size(); ++i) {
    optionletStrikes_[i] = stripper1_->optionletStrikes(i);
    optionletVolatilities_[i] = stripper1_->optionletVolatilities(i);
}

for (Size j=0; j<nOptionExpiries_; ++j) {
    Volatility atmOptionVol = atmCapFloorTermVolCurve_->volatility(
        optionExpiriesTimes[j], 33.3333); // dummy strike
    boost::shared_ptr<BlackCapFloorEngine> engine(new
            BlackCapFloorEngine(iborIndex_->forwardingTermStructure(),
                                atmOptionVol, dc_));
    caps_[j] = MakeCapFloor(CapFloor::Cap,
                            optionExpiriesTenors[j],
                            iborIndex_,
                            Null<Rate>(),
                            0*Days).withPricingEngine(engine);
    atmCapFloorStrikes_[j] =
        caps_[j]->atmRate(**iborIndex_->forwardingTermStructure());
    atmCapFloorPrices_[j] = caps_[j]->NPV();
}

for (Size j=0; j<nOptionExpiries_; ++j) {
    for (Size i=0; i<optionletVolatilities_.size(); ++i) {
        if (i<=caps_[j]->floatingLeg().size()) {
            unadjustedVol = adapter.volatility(optionletTimes_[i],
                                               atmCapFloorStrikes_[j]);
            adjustedVol = unadjustedVol + spreadsVolImplied_[j];

            // insert adjusted volatility
            std::vector<Rate>::const_iterator previous =
                std::lower_bound(optionletStrikes_[i].begin(),
                                 optionletStrikes_[i].end(),
                                 atmCapFloorStrikes_[j]);
            Size insertIndex = previous - optionletStrikes_[i].begin();

            optionletStrikes_[i].insert(
                        optionletStrikes_[i].begin() + insertIndex,
                        atmCapFloorStrikes_[j]);
            optionletVolatilities_[i].insert(
                        optionletVolatilities_[i].begin() + insertIndex,
                        adjustedVol);
        }
    }
}

for (Size j=0; j<nOptionExpiries_; ++j) {
    ObjectiveFunction f(stripper1_, caps_[j], atmCapFloorPrices_[j]);
    solver.setMaxEvaluations(maxEvaluations_);
    Volatility root = solver.solve(f, accuracy_, guess,
                                   minSpread, maxSpread);
    result[j] = root;
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/termstructures/volatility/swaption/swaptionvolcube.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=1; i<nStrikes_; ++i)
    QL_REQUIRE(strikeSpreads_[i-1]<strikeSpreads_[i],
               "non increasing strike spreads: " <<
               io::ordinal(i) << " is " << strikeSpreads_[i-1] << ", " <<
               io::ordinal(i+1) << " is " << strikeSpreads_[i]);

for (Size i=0; i<volSpreads_.size(); i++)
    QL_REQUIRE(nStrikes_==volSpreads_[i].size(),
               "mismatch between number of strikes (" << nStrikes_ <<
               ") and number of columns (" << volSpreads_[i].size() <<
               ") in the " << io::ordinal(i+1) << " row");

for (Size i=0; i<nStrikes_; i++)
    for (Size j=0; j<nOptionTenors_; j++)
        for (Size k=0; k<nSwapTenors_; k++)
            registerWith(volSpreads_[j*nSwapTenors_+k][i]);

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/termstructures/volatility/swaption/cmsmarketcalibration.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i = 0; i < nSwapTenors; ++i)
    volCubeBySabr->recalibration(
        smileAndCms_->betaTransformDirect(x[i]), swapTenors[i]);

for (Size i = 0; i < nSwapTenors; ++i)
    volCubeBySabr->recalibration(
        smileAndCms_->betaTransformDirect(x[i]), swapTenors[i]);

for (Size i = 0; i < nSwapTenors; ++i) {
    std::vector<Real> beta(x.begin() + (i * nSwapLengths),
                           x.begin() + ((i + 1) * nSwapLengths));
    for (Size j = 0; j < beta.size(); ++j)
        beta[j] = smileAndCms_->betaTransformDirect(beta[j]);
    volCubeBySabr->recalibration(swapLengths, beta, swapTenors[i]);
}

for (Size i = 0; i < nSwapTenors; ++i) {
    std::vector<Real> beta(x.begin() + (i * nSwapLengths),
                           x.begin() + ((i + 1) * nSwapLengths));
    for (Size j = 0; j < beta.size(); ++j)
        beta[j] = smileAndCms_->betaTransformDirect(beta[j]);
    volCubeBySabr->recalibration(swapLengths, beta, swapTenors[i]);
}

for (Size i = 0; i < nSwapTenors; ++i) {
    Real betaInf = smileAndCms_->betaTransformDirect(x[0 + 3 * i]);
    Real beta0 = smileAndCms_->betaTransformDirect(x[1 + 3 * i]);
    Real decay = x[2 + 3 * i] * x[2 + 3 * i];
    std::vector<Real> beta(nSwapLengths);
    for (Size j = 0; j < beta.size(); ++j) {
        Real t = smileAndCms_->volCube_->timeFromReference(
            smileAndCms_->volCube_->optionDateFromTenor(swapLengths[j]));
        beta[j] = betaInf + (beta0 - betaInf) * std::exp(-decay * t);
    }
    volCubeBySabr->recalibration(swapLengths, beta, swapTenors[i]);
}

for (Size i = 0; i < nSwapTenors; ++i) {
    Real betaInf = smileAndCms_->betaTransformDirect(x[0 + 3 * i]);
    Real beta0 = smileAndCms_->betaTransformDirect(x[1 + 3 * i]);
    Real decay = x[2 + 3 * i] * x[2 + 3 * i];
    std::vector<Real> beta(nSwapLengths);
    for (Size j = 0; j < beta.size(); ++j) {
        Real t = smileAndCms_->volCube_->timeFromReference(
            smileAndCms_->volCube_->optionDateFromTenor(swapLengths[j]));
        beta[j] = betaInf + (beta0 - betaInf) * std::exp(-decay * t);
    }
    volCubeBySabr->recalibration(swapLengths, beta, swapTenors[i]);
}

    for (Size i = 0; i < nBeta; ++i)
        betasGuess[i] = guess[i];

    for (Size i = 0; i < nBeta; ++i)
        result[i] = betaTransformDirect(tmp[i]);

    for (Size i = 0; i < nBeta; ++i)
        betaReversionGuess[i] = betaTransformInverse(guess[i]);

    for (Size i = 0; i < nBeta; ++i)
        result[i] = betaTransformDirect(result[i]);

    for (Size i = 0; i < nSwapTenors; ++i) {
        for (Size j = 0; j < nSwapLengths; ++j) {
            betasGuess[i * nSwapLengths + j] =
                betaTransformInverse(guess[j][i]);
        }
    }

    for (Size i = 0; i < nSwapTenors; ++i) {
        for (Size j = 0; j < nSwapLengths; ++j) {
            result[j][i] =
                betaTransformDirect(tmp[i * nSwapLengths + j]);
        }
    }

        for (Size j = 0; j < nSwapLengths; ++j) {
            result[j][nSwapTenors] = meanReversionGuess;
        }

    for (Size i = 0; i < nSwapTenors; ++i) {
        for (Size j = 0; j < nSwapLengths; ++j) {
            betasReversionGuess[i * nSwapLengths + j] =
                betaTransformInverse(guess[j][i]);
        }
    }

    for (Size i = 0; i < nSwapTenors; ++i) {
        for (Size j = 0; j < nSwapLengths; ++j) {
            result[j][i] =
                betaTransformDirect(tmp[i * nSwapLengths + j]);
        }
    }

    for (Size j = 0; j < nSwapLengths; ++j) {
        result[j][nSwapTenors] = reversionTransformDirect(tmp[nBeta]);
    }

    for (Size i = 0; i < nSwapTenors; ++i) {
        for (Size j = 0; j < nParams; ++j) {
            betasGuess[i * 3 + j] =
                (j == 0 || j == 1) ? betaTransformInverse(guess[j][i])
                                   : std::sqrt(guess[j][i]);
        }
    }

    for (Size i = 0; i < nSwapTenors; ++i) {
        for (Size j = 0; j < 3; ++j) {
            result[j][i] = (j == 0 || j == 1)
                               ? betaTransformDirect(tmp[i * 3 + j])
                               : tmp[i * 3 + j] * tmp[i * 3 + j];
        }
    }

        for (Size j = 0; j < nSwapLengths; ++j) {
            result[j][nSwapTenors] = meanReversionGuess;
        }

    for (Size i = 0; i < nSwapTenors; ++i) {
        for (Size j = 0; j < nParams; ++j) {
            betasReversionGuess[i * nSwapLengths + j] =
                (j == 0 || j == 1) ? betaTransformInverse(guess[j][i])
                                   : std::sqrt(guess[j][i]);
        }
    }

    for (Size i = 0; i < nSwapTenors; ++i) {
        for (Size j = 0; j < 3; ++j) {
            result[j][i] =
                (j == 0 || j == 1)
                    ? betaTransformDirect(tmp[i * nSwapLengths + j])
                    : tmp[i * 3 + j] * tmp[i * 3 + j];
        }
    }

    for (Size j = 0; j < nSwapLengths; ++j) {
        result[j][nSwapTenors] = reversionTransformDirect(tmp[nParams]);
    }

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/termstructures/volatility/swaption/swaptionvolmatrix.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i<vols.rows(); ++i) {
    volHandles_[i].resize(vols.columns());
    shiftValues_[i].resize(vols.columns());
    for (Size j=0; j<vols.columns(); ++j) {
        volHandles_[i][j] = Handle<Quote>(boost::shared_ptr<Quote>(new
            SimpleQuote(vols[i][j])));
        shiftValues_[i][j] = shifts.rows() > 0 ? shifts[i][j] : 0.0;
    }
}

for (Size i=0; i<vols.rows(); ++i) {
    volHandles_[i].resize(vols.columns());
    shiftValues_[i].resize(vols.columns());
    for (Size j=0; j<vols.columns(); ++j) {
        volHandles_[i][j] = Handle<Quote>(boost::shared_ptr<Quote>(new
            SimpleQuote(vols[i][j])));
        shiftValues_[i][j] = shifts.rows() > 0 ? shifts[i][j] : 0.0;
    }
}

for (Size i=0; i<vols.rows(); ++i) {
    volHandles_[i].resize(vols.columns());
    shiftValues_[i].resize(vols.columns());
    for (Size j=0; j<vols.columns(); ++j) {
        volHandles_[i][j] = Handle<Quote>(boost::shared_ptr<Quote>(new
            SimpleQuote(vols[i][j])));
        shiftValues_[i][j] = shifts.rows() > 0 ? shifts[i][j] : 0.0;
    }
}

for (Size i=0; i<volHandles_.size(); ++i)
    for (Size j=0; j<volHandles_.front().size(); ++j)
        registerWith(volHandles_[i][j]);

for (Size i=0; i<volatilities_.rows(); ++i) {
    for (Size j=0; j<volatilities_.columns(); ++j) {
        volatilities_[i][j] = volHandles_[i][j]->value();
        if(shiftValues_.size() > 0)
            shifts_[i][j] = shiftValues_[i][j];
    }
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/termstructures/volatility/swaption/swaptionvolcube2.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i<nStrikes_; i++) 
    for (Size j=0; j<nOptionTenors_; j++)
        for (Size k=0; k<nSwapTenors_; k++) {
            volSpreadsMatrix_[i][j][k] =
                volSpreads_[j*nSwapTenors_+k][i]->value();
        }

for (Size i=0; i<nStrikes_; i++) {
    volSpreadsInterpolator_[i] = BilinearInterpolation(
        swapLengths_.begin(), swapLengths_.end(),
        optionTimes_.begin(), optionTimes_.end(),
        volSpreadsMatrix_[i]);
    volSpreadsInterpolator_[i].enableExtrapolation();
}

for (Size i=0; i<nStrikes_; ++i) {
    strikes.push_back(atmForward + strikeSpreads_[i]);
    stdDevs.push_back(exerciseTimeSqrt*(
        atmVol + volSpreadsInterpolator_[i](length, optionTime)));
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/termstructures/volatility/swaption/swaptionvoldiscrete.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=1; i<nOptionTenors_; ++i) {
    QL_REQUIRE(optionDates_[i]>optionDates_[i-1],
               "non increasing option dates: " << io::ordinal(i) <<
               " is " << optionDates_[i-1] << ", " << io::ordinal(i+1) <<
               " is " << optionDates_[i]);
}

for (Size i=1; i<nOptionTenors_; ++i)
    QL_REQUIRE(optionTenors_[i]>optionTenors_[i-1],
               "non increasing option tenor: " << io::ordinal(i) <<
               " is " << optionTenors_[i-1] << ", " << io::ordinal(i+1) <<
               " is " << optionTenors_[i]);

for (Size i=1; i<nSwapTenors_; ++i)
    QL_REQUIRE(swapTenors_[i]>swapTenors_[i-1],
               "non increasing swap tenor: " << io::ordinal(i) <<
               " is " << swapTenors_[i-1] << ", " << io::ordinal(i+1) <<
               " is " << swapTenors_[i]);

for (Size i=0; i<nOptionTenors_; ++i) {
    optionDates_[i] = optionDateFromTenor(optionTenors_[i]);
    optionDatesAsReal_[i] =
        static_cast<Real>(optionDates_[i].serialNumber());
}

for (Size i=0; i<nOptionTenors_; ++i)
    optionTimes_[i] = timeFromReference(optionDates_[i]);

for (Size i=0; i<nSwapTenors_; ++i) 
    swapLengths_[i] = swapLength(swapTenors_[i]);

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/termstructures/volatility/swaption/cmsmarket.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size j=0; j<nSwapIndexes_; ++j) {
    swapTenors_[j] = swapIndexes_[j]->tenor();
    // pricers
    registerWith(pricers_[j]);
    for (Size i=0; i<nExercise_; ++i) {
        // market Spread
        registerWith(bidAskSpreads_[i][j*2]);
        registerWith(bidAskSpreads_[i][j*2+1]);
    }
}

for (Size i=0; i<nExercise_; ++i) {
    if (i>0) start = swapLengths_[i-1];
    for (Size j=0; j<nSwapIndexes_; ++j) {
        // never evaluate the spot swap, only its ibor floating leg
        spotSwaps_[i][j] = MakeCms(swapLengths_[i],
                                   swapIndexes_[j],
                                   iborIndex_, 0.0,
                                   Period())
                           .operator shared_ptr<Swap>();
        fwdSwaps_[i][j]  = MakeCms(swapLengths_[i]-start,
                                   swapIndexes_[j],
                                   iborIndex_, 0.0,
                                   start)
                           .withCmsCouponPricer(pricers_[j])
                           .withDiscountingTermStructure(discTS_)
                           .operator shared_ptr<Swap>();
    }
}

for (Size j=0; j<nSwapIndexes_; ++j) {
  Real mktPrevPart = 0.0, mdlPrevPart = 0.0;
  for (Size i=0; i<nExercise_; ++i) {

    // **** market

    mktBidSpreads_[i][j] = bidAskSpreads_[i][j*2]->value();
    mktAskSpreads_[i][j] = bidAskSpreads_[i][j*2+1]->value();
    mktSpreads_[i][j] = (mktBidSpreads_[i][j]+mktAskSpreads_[i][j])/2;

    const Leg& spotFloatLeg = spotSwaps_[i][j]->leg(1);
    spotFloatLegNPV_[i][j] = CashFlows::npv(spotFloatLeg,
                                            **discTS_,
                                            false, discTS_->referenceDate());
    spotFloatLegBPS_[i][j] = CashFlows::bps(spotFloatLeg,
                                            **discTS_,
                                            false, discTS_->referenceDate());

    // imply the spot CMS leg NPV from the spot ibor floating leg NPV
    mktSpotCmsLegNPV_[i][j] = -(spotFloatLegNPV_[i][j] +
                        spotFloatLegBPS_[i][j]*mktSpreads_[i][j]/1e-4);
    // fwd CMS legs can be computed as differences between spot legs
    mktFwdCmsLegNPV_[i][j] = mktSpotCmsLegNPV_[i][j] - mktPrevPart;
    mktPrevPart = mktSpotCmsLegNPV_[i][j];

    // **** model

    // calculate the forward swap (the time consuming part)
    mdlFwdCmsLegNPV_[i][j] = fwdSwaps_[i][j]->legNPV(0);
    errFwdCmsLegNPV_[i][j] = mdlFwdCmsLegNPV_[i][j] -
                                        mktFwdCmsLegNPV_[i][j];

    // spot CMS legs can be computed as incremental sum of forward legs
    mdlSpotCmsLegNPV_[i][j] = mdlPrevPart + mdlFwdCmsLegNPV_[i][j];
    mdlPrevPart = mdlSpotCmsLegNPV_[i][j];
    errSpotCmsLegNPV_[i][j] = mdlSpotCmsLegNPV_[i][j] -
                                        mktSpotCmsLegNPV_[i][j];

    // equilibriums spread over ibor leg
    Real npv = spotFloatLegNPV_[i][j] + mdlSpotCmsLegNPV_[i][j];
    mdlSpreads_[i][j] = - npv/spotFloatLegBPS_[i][j]*1e-4;
    errSpreads_[i][j] = mdlSpreads_[i][j] - mktSpreads_[i][j];
  }
}

for (Size j = 0; j < nSwapIndexes_; ++j) {
    // ??
    // set new volatility structure and new mean reversion
    pricers_[j]->setSwaptionVolatility(v);
    if (meanReversion != Null<Real>()) {
        boost::shared_ptr<MeanRevertingPricer> p =
            boost::dynamic_pointer_cast<MeanRevertingPricer>(
                pricers_[j]);
        QL_REQUIRE(p != NULL, "mean reverting pricer required at index "
                                  << j);
        p->setMeanReversion(meanReversionQuote);
    }
}

for (Size i=0; i<nExercise_; ++i) {
    for (Size j=0; j<nSwapIndexes_; ++j) {
        mean += w[i][j]*var[i][j]*var[i][j];
    }
}

for (Size i=0; i<nExercise_; ++i) {
    for (Size j=0; j<nSwapIndexes_; ++j) {
        weightedVars[i*nSwapIndexes_+j] = std::sqrt(w[i][j])*var[i][j];
    }
}

    for (Size j=0; j<nSwapIndexes_; ++j) {
        for (Size i=0; i<nExercise_; ++i) {
        result[j*nExercise_+i][0] = swapTenors_[j].length();
        result[j*nExercise_+i][1] = swapLengths_[i].length();

        // Spreads
        result[j*nExercise_+i][2] = mktBidSpreads_[i][j]*10000;
        result[j*nExercise_+i][3] = mktAskSpreads_[i][j]*10000;
        result[j*nExercise_+i][4] = mktSpreads_[i][j]*10000;
        result[j*nExercise_+i][5] = mdlSpreads_[i][j]*10000;
        result[j*nExercise_+i][6] = errSpreads_[i][j]*10000;
        if (mdlSpreads_[i][j]>mktAskSpreads_[i][j])
            result[j*nExercise_+i][7] = (mdlSpreads_[i][j] -
                                        mktAskSpreads_[i][j])*10000;
        else if (mdlSpreads_[i][j]<mktBidSpreads_[i][j])
            result[j*nExercise_+i][7] = (mktBidSpreads_[i][j] -
                                        mdlSpreads_[i][j])*10000;
        else
            result[j*nExercise_+i][7] = 0.0;

        // spot CMS Leg NPVs
        result[j*nExercise_+i][ 8] = mktSpotCmsLegNPV_[i][j];
        result[j*nExercise_+i][ 9] = mdlSpotCmsLegNPV_[i][j];
        result[j*nExercise_+i][10] = errSpotCmsLegNPV_[i][j];

        // forward CMS Leg NPVs
        result[j*nExercise_+i][11] = mktFwdCmsLegNPV_[i][j];
        result[j*nExercise_+i][12] = mdlFwdCmsLegNPV_[i][j];
        result[j*nExercise_+i][13] = errFwdCmsLegNPV_[i][j];
    }
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/utilities/dataparsers.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=1; i<subStrings.size(); ++i)
    result += parseOnePeriod(subStrings[i]);

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/math/modifiedbessel.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        for (Size k=1; k < 30; ++k) {
            sign*=-1;
            na_k *= (4.0 * nu * nu -
                     (2.0 * static_cast<Real>(k) - 1.0) *
                         (2.0 * static_cast<Real>(k) - 1.0));
            da_k *= (8.0 * k) * x;
            const T a_k = na_k/da_k;

            s2+=a_k;
            s1+=sign*a_k;
        }

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/math/beta.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (m=1; m<=maxIteration; m++) {
    m2=2*m;
    aa=m*(b-m)*x/((qam+m2)*(a+m2));
    d=1.0+aa*d;
    if (std::fabs(d) < QL_EPSILON) d=QL_EPSILON;
    c=1.0+aa/c;
    if (std::fabs(c) < QL_EPSILON) c=QL_EPSILON;
    d=1.0/d;
    result *= d*c;
    aa = -(a+m)*(qab+m)*x/((a+m2)*(qap+m2));
    d=1.0+aa*d;
    if (std::fabs(d) < QL_EPSILON) d=QL_EPSILON;
    c=1.0+aa/c;
    if (std::fabs(c) < QL_EPSILON) c=QL_EPSILON;
    d=1.0/d;
    del=d*c;
    result *= del;
    if (std::fabs(del-1.0) < accuracy)
        return result;
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/math/incompletegamma.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Integer n=1; n<=maxIteration; n++) {
    ++ap;
    del *= x/ap;
    sum += del;
    if (std::fabs(del) < std::fabs(sum)*accuracy) {
        return sum*std::exp(-x+a*std::log(x)-gln);
    }
}

for (i=1; i<=maxIteration; i++) {
    an = -i*(i-a);
    b += 2.0;
    d=an*d+b;
    if (std::fabs(d) < QL_EPSILON) d=QL_EPSILON;
    c=b+an/c;
    if (std::fabs(c) < QL_EPSILON) c=QL_EPSILON;
    d=1.0/d;
    del=d*c;
    h *= del;
    if (std::fabs(del-1.0) < accuracy) {
        return std::exp(-x+a*std::log(x)-gln)*h;
    }
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/math/bspline.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i<knots.size()-1; ++i) {
    QL_REQUIRE(knots[i] <= knots[i+1],
               "knots points must be nondecreasing");
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/math/matrix.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i < m.rows(); ++i) {
    if (pert[i] != i)
        retVal *= -a(i,i);
    else
        retVal *=  a(i,i);
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/math/integrals/gaussianquadratures.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (i=1; i < n; ++i) {
    x_[i] = orthPoly.alpha(i);
    e[i-1] = std::sqrt(orthPoly.beta(i));
}

for (i=0; i<n; ++i) {
    w_[i] = mu_0*ev[0][i]*ev[0][i] / orthPoly.w(x_[i]);
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/math/integrals/kronrodintegral.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (k = 0; k < 5; k++) {
    Real abscissa = halfLength * x1[k];
    Real fval1 = f(center + abscissa);
    Real fval2 = f(center - abscissa);
    Real fval = fval1 + fval2;
    res10 += w10[k] * fval;
    res21 += w21a[k] * fval;
    resAbs += w21a[k] * (std::fabs(fval1) + std::fabs(fval2));
    savfun[k] = fval;
    fv1[k] = fval1;
    fv2[k] = fval2;
}

for (k = 0; k < 5; k++) {
    Real abscissa = halfLength * x2[k];
    Real fval1 = f(center + abscissa);
    Real fval2 = f(center - abscissa);
    Real fval = fval1 + fval2;
    res21 += w21b[k] * fval;
    resAbs += w21b[k] * (std::fabs(fval1) + std::fabs(fval2));
    savfun[k + 5] = fval;
    fv3[k] = fval1;
    fv4[k] = fval2;
}

for (k = 0; k < 5; k++)
    resasc += (w21a[k] * (std::fabs(fv1[k] - mean)
                + std::fabs(fv2[k] - mean))
                + w21b[k] * (std::fabs(fv3[k] - mean)
                + std::fabs(fv4[k] - mean)));

for (k = 0; k < 10; k++)
    res43 += savfun[k] * w43a[k];

for (k = 0; k < 11; k++){
    Real abscissa = halfLength * x3[k];
    Real fval = (f(center + abscissa)
        + f(center - abscissa));
    res43 += fval * w43b[k];
    savfun[k + 10] = fval;
    }

for (k = 0; k < 21; k++)
    res87 += savfun[k] * w87a[k];

for (k = 0; k < 22; k++){
    Real abscissa = halfLength * x4[k];
    res87 += w87b[k] * (f(center + abscissa)
        + f(center - abscissa));
}

    for (j = 1, j2 = 2; j < 4; j++, j2 += 2) {
        t = halflength * k15t[j2];
        fsum = f(center - t) + f(center + t);
        g7  += fsum * g7w[j];
        k15 += fsum * k15w[j2];
    }

    for (j2 = 1; j2 < 8; j2 += 2) {
        t = halflength * k15t[j2];
        fsum = f(center - t) + f(center + t);
        k15 += fsum * k15w[j2];
    }

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/math/integrals/discreteintegrals.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i < n-1; ++i) {
    acc((x[i+1]-x[i])*(f[i]+f[i+1]));
}

for (Size j=0; j < n-2; j+=2) {
    const Real dxj   = x[j+1]-x[j];
    const Real dxjp1 = x[j+2]-x[j+1];

    const Real alpha = -dxjp1*(2*x[j]-3*x[j+1]+x[j+2]);
    const Real dd = x[j+2]-x[j];
    const Real k = dd/(6*dxjp1*dxj);
    const Real beta = dd*dd;
    const Real gamma = dxj*(x[j]-3*x[j+1]+2*x[j+2]);

    acc(k*alpha*f[j]+k*beta*f[j+1]+k*gamma*f[j+2]);
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/math/integrals/filonintegral.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=1; i <= n_; ++i) {
    c_2n   += v[2*i]  *f2(t_*x[2*i]);
    c_2n_1 += v[2*i-1]*f2(t_*x[2*i-1]);
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/math/matrixutilities/basisincompleteordered.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size j=0; j<currentBasis_.size(); ++j) {
    Real innerProd = std::inner_product(newVector_.begin(),
        newVector_.end(),
        currentBasis_[j].begin(), 0.0);

    for (Size k=0; k<euclideanDimension_; ++k)
        newVector_[k] -=innerProd*currentBasis_[j][k];
}

for (Size l=0; l<euclideanDimension_; ++l)
    newVector_[l]/=norm;

for (Size i=0; i<basis.rows(); ++i)
    for (Size j=0; j<basis.columns(); ++j)
        basis[i][j] = currentBasis_[i][j];

    for (Size i=0; i < v.columns(); ++i)
        x += v[row][i]*v[row][i];

    for (Size i=0; i < v.columns(); ++i)
        x += v[row1][i]*w[row2][i];

for (Size j=0; j < numberVectors_; ++j)
{

    if (validVectors_[j])
    {
        for (Size k=0; k< numberVectors_; ++k) // create an orthormal basis not containing j
        {
            for (Size m=0; m < dimension_; ++m)
                orthoNormalizedVectors_[k][m] = originalVectors_[k][m];

            if ( k !=j && validVectors_[k])
            {


                for (Size l=0; l < k; ++l)
                {
                    if (validVectors_[l] && l !=j)
                    {
                        Real dotProduct = innerProduct(orthoNormalizedVectors_, k, orthoNormalizedVectors_,l);
                        for (Size n=0; n < dimension_; ++n)
                            orthoNormalizedVectors_[k][n] -=  dotProduct*orthoNormalizedVectors_[l][n];
                    }

                }

                Real normBeforeScaling= norm(orthoNormalizedVectors_,k);

                if (normBeforeScaling < tolerance)
                {
                    validVectors_[k] = false;
                }
                else
                {
                    Real normBeforeScalingRecip = 1.0/normBeforeScaling;
                    for (Size m=0; m < dimension_; ++m)
                        orthoNormalizedVectors_[k][m] *= normBeforeScalingRecip;

                } // end of else (norm < tolerance)

            } // end of if k !=j && validVectors_[k])

        }// end of  for (Size k=0; k< numberVectors_; ++k)

        // we now have an o.n. basis for everything except  j

        Real prevNormSquared = normSquared(originalVectors_, j);


        for (Size r=0; r < numberVectors_; ++r)
            if (validVectors_[r] && r != j)
            {
                Real dotProduct = innerProduct(orthoNormalizedVectors_, j, orthoNormalizedVectors_,r);

                for (Size s=0; s < dimension_; ++s)
                   orthoNormalizedVectors_[j][s] -= dotProduct*orthoNormalizedVectors_[r][s];

            }

       Real projectionOnOriginalDirection = innerProduct(originalVectors_,j,orthoNormalizedVectors_,j);
       Real sizeMultiplier = prevNormSquared/projectionOnOriginalDirection;

       if (std::fabs(sizeMultiplier) < multiplierCutoff_)
       {
            for (Size t=0; t < dimension_; ++t)
                currentVector[t] = orthoNormalizedVectors_[j][t]*sizeMultiplier;

       }
       else
           validVectors_[j] = false;


    } // end of  if (validVectors_[j])

    projectedVectors_.push_back(currentVector);


} //end of j loop

for (Size i=0; i < numberVectors_; ++i)
    numberValidVectors_ +=  validVectors_[i] ? 1 : 0;

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/math/matrixutilities/tqreigendecomposition.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (i=0; i < ev_.rows(); ++i) {
    ev_[i][i] = 1.0;
}

for (Size k=n-1; k >=1; --k) {
    while (!offDiagIsZero(k, e)) {
        Size l = k;
        while (--l > 0 && !offDiagIsZero(l,e));
        iter_++;

        Real q = d_[l];
        if (strategy != NoShift) {
            // calculated eigenvalue of 2x2 sub matrix of
            // [ d_[k-1] e_[k] ]
            // [  e_[k]  d_[k] ]
            // which is closer to d_[k+1].
            // FLOATING_POINT_EXCEPTION
            const Real t1 = std::sqrt(
                                  0.25*(d_[k]*d_[k] + d_[k-1]*d_[k-1])
                                  - 0.5*d_[k-1]*d_[k] + e[k]*e[k]);
            const Real t2 = 0.5*(d_[k]+d_[k-1]);

            const Real lambda =
                (std::fabs(t2+t1 - d_[k]) < std::fabs(t2-t1 - d_[k]))?
                t2+t1 : t2-t1;

            if (strategy == CloseEigenValue) {
                q-=lambda;
            } else {
                q-=((k==n-1)? 1.25 : 1.0)*lambda;
            }
        }

        // the QR transformation
        Real sine = 1.0;
        Real cosine = 1.0;
        Real u = 0.0;

        bool recoverUnderflow = false;
        for (Size i=l+1; i <= k && !recoverUnderflow; ++i) {
            const Real h = cosine*e[i];
            const Real p = sine*e[i];

            e[i-1] = std::sqrt(p*p+q*q);
            if (e[i-1] != 0.0) {
                sine = p/e[i-1];
                cosine = q/e[i-1];

                const Real g = d_[i-1]-u;
                const Real t = (d_[i]-g)*sine+2*cosine*h;

                u = sine*t;
                d_[i-1] = g + u;
                q = cosine*t - h;

                for (Size j=0; j < ev_.rows(); ++j) {
                    const Real tmp = ev_[j][i-1];
                    ev_[j][i-1] = sine*ev_[j][i] + cosine*tmp;
                    ev_[j][i] = cosine*ev_[j][i] - sine*tmp;
                }
            } else {
                // recover from underflow
                d_[i-1] -= u;
                e[l] = 0.0;
                recoverUnderflow = true;
            }
        }

        if (!recoverUnderflow) {
            d_[k] -= u;
            e[k] = q;
            e[l] = 0.0;
        }
    }
}

for (i=0; i<n; i++) {
    if (ev_.rows() > 0)
        std::copy(ev_.column_begin(i),
                  ev_.column_end(i), eigenVector.begin());
    temp[i] = std::make_pair(d_[i], eigenVector);
}

for (i=0; i<n; i++) {
    d_[i] = temp[i].first;
    Real sign = 1.0;
    if (ev_.rows() > 0 && temp[i].second[0]<0.0)
        sign = -1.0;
    for (Size j=0; j<ev_.rows(); ++j) {
        ev_[j][i] = sign * temp[i].second[j];
    }
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/math/matrixutilities/pseudosqrt.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    for (Size i=0; i<size; ++i)
        for (Size j=0; j<i; ++j)
            QL_REQUIRE(close(matrix[i][j], matrix[j][i]),
                       "non symmetric matrix: " <<
                       "[" << i << "][" << j << "]=" << matrix[i][j] <<
                       ", [" << j << "][" << i << "]=" << matrix[j][i]);

    for (Size i=0; i<size; ++i) {
        Real norm = 0.0;
        for (Size j=0; j<pseudoCols; ++j)
            norm += pseudo[i][j]*pseudo[i][j];
        if (norm>0.0) {
            Real normAdj = std::sqrt(matrix[i][i]/norm);
            for (Size j=0; j<pseudoCols; ++j)
                pseudo[i][j] *= normAdj;
        }
    }

            for (i=0; i<size_; i++) {
                for (k=0; k<size_; k++) {
                    if (k>i) {
                        currentRoot_[i][k]=0;
                    } else {
                        for (j=0; j<=k; j++) {
                            if (j == k && k!=i)
                                currentRoot_[i][k] *=
                                    std::cos(x[i*(i-1)/2+j]);
                            else if (j!=i)
                                currentRoot_[i][k] *=
                                    std::sin(x[i*(i-1)/2+j]);
                        }
                    }
                }
            }

            for (i=0; i<size_; i++) {
                for (k=0; k<size_; k++) {
                    for (j=0; j<=k; j++) {
                        if (j == k && k!=size_-1)
                            currentRoot_[i][k] *=
                                std::cos(x[j*size_+i]);
                        else if (j!=size_-1)
                            currentRoot_[i][k] *=
                                std::sin(x[j*size_+i]);
                    }
                }
            }

        for (i=0;i<size_;i++) {
            for (j=0;j<size_;j++) {
                temp = currentMatrix_[i][j]*targetVariance_[i]
                  *targetVariance_[j]-targetMatrix_[i][j];
                error += temp*temp;
            }
        }

    for (i=0; i<size; i++){
        variance[i]=std::sqrt(targetMatrix[i][i]);
    }

        for (i=0; i<size; i++) {
            for (j=0; j<size; j++) {
                result[i][j]/=std::sqrt(approxMatrix[i][i]);
            }
        }

        for (i=0; i<size; i++) {
            for (j=0; j<size; j++) {
                result[i][j]/=variance[i];
            }
        }

        for (i=1; i<size; i++) {
            for (j=0; j<i; j++) {
                theta[i*(i-1)/2+j]=result[i][j];
                if (theta[i*(i-1)/2+j]>1-eps)
                    theta[i*(i-1)/2+j]=1-eps;
                if (theta[i*(i-1)/2+j]<-1+eps)
                    theta[i*(i-1)/2+j]=-1+eps;
                for (k=0; k<j; k++) {
                    theta[i*(i-1)/2+j] /= std::sin(theta[i*(i-1)/2+k]);
                    if (theta[i*(i-1)/2+j]>1-eps)
                        theta[i*(i-1)/2+j]=1-eps;
                    if (theta[i*(i-1)/2+j]<-1+eps)
                        theta[i*(i-1)/2+j]=-1+eps;
                }
                theta[i*(i-1)/2+j] = std::acos(theta[i*(i-1)/2+j]);
                if (j==i-1) {
                    if (result[i][i]<0)
                        theta[i*(i-1)/2+j]=-theta[i*(i-1)/2+j];
                }
            }
        }

        for (i=0; i<size; i++) {
            for (k=0; k<size; k++) {
                if (k>i) {
                    result[i][k]=0;
                } else {
                    for (j=0; j<=k; j++) {
                        if (j == k && k!=i)
                            result[i][k] *=
                                std::cos(theta[i*(i-1)/2+j]);
                        else if (j!=i)
                            result[i][k] *=
                                std::sin(theta[i*(i-1)/2+j]);
                    }
                }
            }
        }

        for (i=0; i<size; i++) {
            for (j=0; j<size-1; j++) {
                theta[j*size+i]=result[i][j];
                if (theta[j*size+i]>1-eps)
                    theta[j*size+i]=1-eps;
                if (theta[j*size+i]<-1+eps)
                    theta[j*size+i]=-1+eps;
                for (k=0;k<j;k++) {
                    theta[j*size+i] /= std::sin(theta[k*size+i]);
                    if (theta[j*size+i]>1-eps)
                        theta[j*size+i]=1-eps;
                    if (theta[j*size+i]<-1+eps)
                        theta[j*size+i]=-1+eps;
                }
                theta[j*size+i] = std::acos(theta[j*size+i]);
                if (j==size-2) {
                    if (result[i][j+1]<0)
                        theta[j*size+i]=-theta[j*size+i];
                }
            }
        }

        for (i=0; i<size; i++) {
            for (k=0; k<size; k++) {
                for (j=0; j<=k; j++) {
                    if (j == k && k!=size-1)
                        result[i][k] *= std::cos(theta[j*size+i]);
                    else if (j!=size-1)
                        result[i][k] *= std::sin(theta[j*size+i]);
                }
            }
        }

    for (i=0; i<size; i++) {
        for (j=0; j<size; j++) {
            result[i][j]*=variance[i];
        }
    }

    for (Size i=0; i<rows; ++i) {
        Real colSum = 0.0;
        for (Size j=0; j<cols; ++j)
            colSum += std::fabs(M[i][j]);
        norm = std::max(norm, colSum);
    }

    for (Size i=0; i<size; ++i)
        result[i][i] = 1.0;

    for (Size i=0; i<size; ++i)
        diagonal[i][i] = std::max<Real>(jd.eigenvalues()[i], 0.0);

    for (Size i=0; i<maxIterations; ++i) {
        R = Y - deltaS;
        X = projectToPositiveSemidefiniteMatrix(R);
        deltaS = X - R;
        Y = projectToUnitDiagonalMatrix(X);

        // convergence test
        if (std::max(normInf(X-lastX)/normInf(X),
                std::max(normInf(Y-lastY)/normInf(Y),
                        normInf(Y-X)/normInf(Y)))
                <= tolerance)
        {
            break;
        }
        lastX = X;
        lastY = Y;
    }

    for (Size i=0; i<size; ++i)
        for (Size j=0; j<i; ++j)
            Y[i][j] = Y[j][i];

    for (Size i=0; i<size; i++)
        diagonal[i][i] =
            std::sqrt(std::max<Real>(jd.eigenvalues()[i], 0.0));

    for (Size i=0; i<size; ++i){
        diagonal[i][i] =
            std::sqrt(std::max<Real>(jd.eigenvalues()[i], 0.0));
        if (jd.eigenvalues()[i]<0.0) negative=true;
    }

    for (Size i=0; i<size; ++i){
        diagonal[i][i] =
            std::sqrt(std::max<Real>(jd.eigenvalues()[i], 0.0));
        if (jd.eigenvalues()[i]<0.0) negative=true;
    }

    for (Size i=0; i<size; ++i)
        eigenValues[i] = std::max<Real>(eigenValues[i], 0.0);

for (Size i=1; components<enough && i<size; ++i) {
    components += eigenValues[i];
    retainedFactors++;
}

for (Size i=0; i<retainedFactors; ++i)
    diagonal[i][i] = std::sqrt(eigenValues[i]);

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/math/matrixutilities/bicgstab.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (i=0; i < maxIter_ && error >= relTol_; ++i) {
   rho = DotProduct(rTld, r);
   if  (rho == 0.0 || omega == 0.0) 
       break;

   if (i) {
      beta = (rho/rhoTld)*(alpha/omega);
      p = r + beta*(p - omega*v);
   }
   else {
      p = r;
   }

   pTld = ((M_)? M_(p) : p);
   v     = A_(pTld); 

   alpha = rho/DotProduct(rTld, v);
   s     = r-alpha*v;
   if (norm2(s) < relTol_*bnorm2) {
      x += alpha*pTld;
      error = norm2(s)/bnorm2;
      break;
   }
   
   sTld = ((M_) ? M_(s) : s);
   t = A_(sTld);
   omega = DotProduct(t,s)/DotProduct(t,t);
   x += alpha*pTld + omega*sTld;
   r = s - omega*t;
   error = norm2(r)/bnorm2;
   rhoTld = rho;
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/math/matrixutilities/choleskydecomposition.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (i=0; i<S.rows(); i++)
    for (j=0; j<i; j++)
        QL_REQUIRE(S[i][j] == S[j][i],
                   "input matrix is not symmetric");

for (i=0; i<size; i++) {
    for (j=i; j<size; j++) {
        sum = S[i][j];
        for (Integer k=0; k<=Integer(i)-1; k++) {
            sum -= result[i][k]*result[j][k];
        }
        if (i == j) {
            QL_REQUIRE(flexible || sum > 0.0,
                       "input matrix is not positive definite");
            // To handle positive semi-definite matrices take the
            // square root of sum if positive, else zero.
            result[i][i] = std::sqrt(std::max<Real>(sum, 0.0));
        } else {
            // With positive semi-definite matrices is possible
            // to have result[i][i]==0.0
            // In this case sum happens to be zero as well
            result[j][i] =
                (sum==0.0 ? 0.0 : sum/result[i][i]);
        }
    }
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/math/matrixutilities/svd.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (k = 0; k < std::max(nct,nrt); k++) {
    if (k < nct) {

        // Compute the transformation for the k-th column and
        // place the k-th diagonal in s[k].
        // Compute 2-norm of k-th column without under/overflow.
        s_[k] = 0;
        for (i = k; i < m_; i++) {
            s_[k] = hypot(s_[k],A[i][k]);
        }
        if (s_[k] != 0.0) {
            if (A[k][k] < 0.0) {
                s_[k] = -s_[k];
            }
            for (i = k; i < m_; i++) {
                A[i][k] /= s_[k];
            }
            A[k][k] += 1.0;
        }
        s_[k] = -s_[k];
    }
    for (j = k+1; j < n_; j++) {
        if ((k < nct) && (s_[k] != 0.0))  {

            // Apply the transformation.

            Real t = 0;
            for (i = k; i < m_; i++) {
                t += A[i][k]*A[i][j];
            }
            t = -t/A[k][k];
            for (i = k; i < m_; i++) {
                A[i][j] += t*A[i][k];
            }
        }

        // Place the k-th row of A into e for the
        // subsequent calculation of the row transformation.

        e[j] = A[k][j];
    }
    if (k < nct) {

        // Place the transformation in U for subsequent back
        // multiplication.

        for (i = k; i < m_; i++) {
            U_[i][k] = A[i][k];
        }
    }
    if (k < nrt) {

        // Compute the k-th row transformation and place the
        // k-th super-diagonal in e[k].
        // Compute 2-norm without under/overflow.
        e[k] = 0;
        for (i = k+1; i < n_; i++) {
            e[k] = hypot(e[k],e[i]);
        }
        if (e[k] != 0.0) {
            if (e[k+1] < 0.0) {
                e[k] = -e[k];
            }
            for (i = k+1; i < n_; i++) {
                e[i] /= e[k];
            }
            e[k+1] += 1.0;
        }
        e[k] = -e[k];
        if ((k+1 < m_) & (e[k] != 0.0)) {

            // Apply the transformation.

            for (i = k+1; i < m_; i++) {
                work[i] = 0.0;
            }
            for (j = k+1; j < n_; j++) {
                for (i = k+1; i < m_; i++) {
                    work[i] += e[j]*A[i][j];
                }
            }
            for (j = k+1; j < n_; j++) {
                Real t = -e[j]/e[k+1];
                for (i = k+1; i < m_; i++) {
                    A[i][j] += t*work[i];
                }
            }
        }

        // Place the transformation in V for subsequent
        // back multiplication.

        for (i = k+1; i < n_; i++) {
            V_[i][k] = e[i];
        }
    }
}

for (j = nct; j < n_; j++) {
    for (i = 0; i < m_; i++) {
        U_[i][j] = 0.0;
    }
    U_[j][j] = 1.0;
}

for (k = nct-1; k >= 0; --k) {
    if (s_[k] != 0.0) {
        for (j = k+1; j < n_; ++j) {
            Real t = 0;
            for (i = k; i < m_; i++) {
                t += U_[i][k]*U_[i][j];
            }
            t = -t/U_[k][k];
            for (i = k; i < m_; i++) {
                U_[i][j] += t*U_[i][k];
            }
        }
        for (i = k; i < m_; i++ ) {
            U_[i][k] = -U_[i][k];
        }
        U_[k][k] = 1.0 + U_[k][k];
        for (i = 0; i < k-1; i++) {
            U_[i][k] = 0.0;
        }
    } else {
        for (i = 0; i < m_; i++) {
            U_[i][k] = 0.0;
        }
        U_[k][k] = 1.0;
    }
}

for (k = n_-1; k >= 0; --k) {
    if ((k < nrt) & (e[k] != 0.0)) {
        for (j = k+1; j < n_; ++j) {
            Real t = 0;
            for (i = k+1; i < n_; i++) {
                t += V_[i][k]*V_[i][j];
            }
            t = -t/V_[k+1][k];
            for (i = k+1; i < n_; i++) {
                V_[i][j] += t*V_[i][k];
            }
        }
    }
    for (i = 0; i < n_; i++) {
        V_[i][k] = 0.0;
    }
    V_[k][k] = 1.0;
}

    for (k = p-2; k >= -1; --k) {
        if (k == -1) {
            break;
        }
        if (std::fabs(e[k]) <= eps*(std::fabs(s_[k]) +
                                    std::fabs(s_[k+1]))) {
            e[k] = 0.0;
            break;
        }
    }

        for (ks = p-1; ks >= k; --ks) {
            if (ks == k) {
                break;
            }
            Real t = (ks != p ? std::fabs(e[ks]) : 0.) +
                (ks != k+1 ? std::fabs(e[ks-1]) : 0.);
            if (std::fabs(s_[ks]) <= eps*t)  {
                s_[ks] = 0.0;
                break;
            }
        }

          for (j = p-2; j >= k; --j) {
              Real t = hypot(s_[j],f);
              Real cs = s_[j]/t;
              Real sn = f/t;
              s_[j] = t;
              if (j != k) {
                  f = -sn*e[j-1];
                  e[j-1] = cs*e[j-1];
              }
              for (i = 0; i < n_; i++) {
                  t = cs*V_[i][j] + sn*V_[i][p-1];
                  V_[i][p-1] = -sn*V_[i][j] + cs*V_[i][p-1];
                  V_[i][j] = t;
              }
          }

          for (j = k; j < p; j++) {
              Real t = hypot(s_[j],f);
              Real cs = s_[j]/t;
              Real sn = f/t;
              s_[j] = t;
              f = -sn*e[j];
              e[j] = cs*e[j];
              for (i = 0; i < m_; i++) {
                  t = cs*U_[i][j] + sn*U_[i][k-1];
                  U_[i][k-1] = -sn*U_[i][j] + cs*U_[i][k-1];
                  U_[i][j] = t;
              }
          }

          for (j = k; j < p-1; j++) {
              Real t = hypot(f,g);
              Real cs = f/t;
              Real sn = g/t;
              if (j != k) {
                  e[j-1] = t;
              }
              f = cs*s_[j] + sn*e[j];
              e[j] = cs*e[j] - sn*s_[j];
              g = sn*s_[j+1];
              s_[j+1] = cs*s_[j+1];
              for (i = 0; i < n_; i++) {
                  t = cs*V_[i][j] + sn*V_[i][j+1];
                  V_[i][j+1] = -sn*V_[i][j] + cs*V_[i][j+1];
                  V_[i][j] = t;
              }
              t = hypot(f,g);
              cs = f/t;
              sn = g/t;
              s_[j] = t;
              f = cs*e[j] + sn*s_[j+1];
              s_[j+1] = -sn*e[j] + cs*s_[j+1];
              g = sn*e[j+1];
              e[j+1] = cs*e[j+1];
              if (j < m_-1) {
                  for (i = 0; i < m_; i++) {
                      t = cs*U_[i][j] + sn*U_[i][j+1];
                      U_[i][j+1] = -sn*U_[i][j] + cs*U_[i][j+1];
                      U_[i][j] = t;
                  }
              }
          }

              for (i = 0; i <= pp; i++) {
                  V_[i][k] = -V_[i][k];
              }

                  for (i = 0; i < n_; i++) {
                      swap(V_[i][k], V_[i][k+1]);
                  }

                  for (i = 0; i < m_; i++) {
                      swap(U_[i][k], U_[i][k+1]);
                  }

for (Size i = 0; i < Size(n_); i++) {
    for (Size j = 0; j < Size(n_); j++) {
        S[i][j] = 0.0;
    }
    S[i][i] = s_[i];
}

for (Size i = 0; i < s_.size(); i++) {
    if (s_[i] > tol) {
        r++;
    }
}

for (Size i=0; i<numericalRank; i++)
    W[i][i] = 1./s_[i];

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/math/matrixutilities/symmetricschurdecomposition.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size q=0; q<size; q++) {
    diagonal_[q] = s[q][q];
    eigenVectors_[q][q] = 1.0;
}

    for (Size a=0; a<size-1; a++) {
        for (Size b=a+1; b<size; b++) {
            sum += std::fabs(ss[a][b]);
        }
    }

        for (j=0; j<size-1; j++) {
            for (k=j+1; k<size; k++) {
                Real sine, rho, cosin, heig, tang, beta;
                Real smll = std::fabs(ss[j][k]);
                if(ite> 5 &&
                   smll<epsPrec*std::fabs(diagonal_[j]) &&
                   smll<epsPrec*std::fabs(diagonal_[k])) {
                        ss[j][k] = 0;
                } else if (std::fabs(ss[j][k])>threshold) {
                    heig = diagonal_[k]-diagonal_[j];
                    if (smll<epsPrec*std::fabs(heig)) {
                        tang = ss[j][k]/heig;
                    } else {
                        beta = 0.5*heig/ss[j][k];
                        tang = 1.0/(std::fabs(beta)+
                            std::sqrt(1+beta*beta));
                        if (beta<0)
                            tang = -tang;
                    }
                    cosin = 1/std::sqrt(1+tang*tang);
                    sine = tang*cosin;
                    rho = sine/(1+cosin);
                    heig = tang*ss[j][k];
                    tmpAccumulate[j] -= heig;
                    tmpAccumulate[k] += heig;
                    diagonal_[j] -= heig;
                    diagonal_[k] += heig;
                    ss[j][k] = 0.0;
                    for (l=0; l+1<=j; l++)
                        jacobiRotate_(ss, rho, sine, l, j, l, k);
                    for (l=j+1; l<=k-1; l++)
                        jacobiRotate_(ss, rho, sine, j, l, l, k);
                    for (l=k+1; l<size; l++)
                        jacobiRotate_(ss, rho, sine, j, l, k, l);
                    for (l=0;   l<size; l++)
                        jacobiRotate_(eigenVectors_,
                                          rho, sine, l, j, l, k);
                }
            }
        }

        for (k=0; k<size; k++) {
            tmpDiag[k] += tmpAccumulate[k];
            diagonal_[k] = tmpDiag[k];
            tmpAccumulate[k] = 0.0;
        }

for (col=0; col<size; col++) {
    std::copy(eigenVectors_.column_begin(col),
              eigenVectors_.column_end(col), eigenVector.begin());
    temp[col] = std::make_pair(diagonal_[col], eigenVector);
}

for (col=0; col<size; col++) {
    // check for round-off errors
    diagonal_[col] =
        (std::fabs(temp[col].first/maxEv)<1e-16 ? 0.0 :
                                                  temp[col].first);
    Real sign = 1.0;
    if (temp[col].second[0]<0.0)
        sign = -1.0;
    for (row=0; row<size; row++) {
        eigenVectors_[row][col] = sign * temp[col].second[row];
    }
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/math/matrixutilities/tapcorrelations.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size j=1; j<matrixSize; ++j)
    m[0][j] = 0.0;

for (Size i=1; i<m.rows(); ++i) {
    Real sinProduct = 1.0;
    Size bound = std::min(i,rank-1);
    for (Size j=0; j<bound; ++j) {
        m[i][j] = std::cos(angles[k]);
        m[i][j] *= sinProduct;
        sinProduct *= std::sin(angles[k]);
        ++k;
    }
    m[i][bound] = sinProduct;
    for (Size j=bound+1; j<m.rows(); ++j)
        m[i][j] = 0;
}

for (Size i=0; i<m.rows(); ++i) {
    Real cosPhi, sinPhi;
    if (i>0) {
        cosPhi = std::cos(angles[i-1]);
        sinPhi = std::sin(angles[i-1]);
    } else {
        cosPhi = 1.0;
        sinPhi = 0.0;
    }

    for (Size j=0; j<i; ++j)
        m[i][j] = sinPhi * m[i-1][j];

    m[i][i] = cosPhi;

    for (Size j=i+1; j<m.rows(); ++j)
        m[i][j] = 0.0;
}

for (Size i = 0; i < x.size(); ++i)
    angles[i] = M_PI*.5 - std::atan(x[i]);

for (Size i = 0; i < x.size(); ++i)
    angles[i] = M_PI*.5 - std::atan(x[i]);

for (Size i=0; i<m.rows(); ++i) {
    Real t = t0 * (1 - std::exp(epsilon*Real(i)));
    Real phi = std::atan(alpha * t);
    m[i][0] = std::cos(t)*std::cos(phi);
    m[i][1] = std::sin(t)*std::cos(phi);
    m[i][2] = -std::sin(phi);
}

for (Size i=0; i<target_.rows(); ++i) {
    for (Size j=0; j<i; ++j){
        result[k] = differences[i][j];
        ++k;
    }
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/math/matrixutilities/sparseilupreconditioner.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (SparseMatrix::size_type i=0; i < L_.size1(); ++i)
    L_(i,i) = 1.0;

for (Integer ii=0; ii<n; ++ii) {
    Array w(n);
    for(Integer k=0; k<n; ++k) {
        w[k] = A(ii,k);
    }

    std::vector<Integer> levii(n, 0);
    for (Integer i=0; i<n; ++i) {
        if(   w[i] > QL_EPSILON
              || w[i] < -1.0*QL_EPSILON) levii[i] = 1;
    }
    Integer jj = -1;
    while (jj < ii) {
        for (Integer k=jj+1; k<n; ++k) {
            if(levii[k]) {
                jj = k;
                break;
            }
        }
        if (jj >= ii) {
            break;
        }
        Integer jlev = levii[jj];
        if (jlev <= lfilp) {
            std::vector<Integer> nonZeros;
            std::vector<Real> nonZeroEntries;
            nonZeros.reserve(uBandSet.size()+1);
            nonZeroEntries.reserve(uBandSet.size()+1);
            const Real entry = U_(jj,jj);
            if(entry > QL_EPSILON || entry < -1.0*QL_EPSILON) {
                nonZeros.push_back(jj);
                nonZeroEntries.push_back(entry);
            }
            std::set<Integer>::const_iterator iter=uBandSet.begin();
            std::set<Integer>::const_iterator end =uBandSet.end();
            for (; iter != end; ++iter) {
                const Real entry = U_(jj,jj+*iter);
                if(entry > QL_EPSILON || entry < -1.0*QL_EPSILON) {
                    nonZeros.push_back(jj+*iter);
                    nonZeroEntries.push_back(entry);
                }
            }
            Real fact = w[jj];
            if(!nonZeroEntries.empty()) {
                fact /= nonZeroEntries[0];
            }
            for (Size k=0; k<nonZeros.size(); ++k) {
                const Integer j = nonZeros[k] ;
                const Integer temp = levs(jj,j) + jlev ;
                if (levii[j] == 0) {
                    if (temp <= lfilp) {
                        w[j] =  - fact*nonZeroEntries[k];
                        levii[j] = temp;
                    }
                }
                else {
                    w[j] -= fact*nonZeroEntries[k];
                    levii[j] = std::min(levii[j],temp);
                }
            }
            w[jj] = fact;
        }
    }
    std::vector<Integer> wNonZeros;
    std::vector<Real> wNonZeroEntries;
    wNonZeros.reserve(w.size());
    wNonZeroEntries.reserve(w.size());
    for (Size i=0; i<w.size(); ++i) {
        const Real entry = w[i];
        if(entry > QL_EPSILON || entry < -1.0*QL_EPSILON) {
            wNonZeros.push_back(i);
            wNonZeroEntries.push_back(entry);
        }
    }
    std::vector<Integer> leviiNonZeroEntries;
    leviiNonZeroEntries.reserve(levii.size());
    for (Size i=0; i<levii.size(); ++i) {
        const Integer entry = levii[i];
        if(entry > QL_EPSILON || entry < -1.0*QL_EPSILON) {
            leviiNonZeroEntries.push_back(entry);
        }
    }
    for (Size k=0; k<wNonZeros.size(); ++k) {
        Integer j = wNonZeros[k];
        if (j < ii) {
            L_(ii,j) = wNonZeroEntries[k];
            lBandSet.insert(ii-j);
        }
        else {
            U_(ii,j) = wNonZeroEntries[k];
            levs(ii,j) = leviiNonZeroEntries[k];
            if(j-ii > 0) {
                uBandSet.insert(j-ii);
            }
        }
    }
}

for (Integer i=1; i<=n-1; ++i) {
    y[i] = b[i]/L_(i,i);
    for (Integer j=lBands_.size()-1;
         j>=0 && i-Integer(lBands_[j]) <= i-1; --j) {
        const Integer k = i-Integer(lBands_[j]);
        if (k >= 0)
            y[i]-=L_(i,k)*y[k]/L_(i,i);
    }
}

for (Integer i=n-2; i>=0; --i) {
    x[i] = y[i]/U_(i,i);
    for (Size j=0; j<uBands_.size() && i+uBands_[j] <= n-1; ++j) {
        x[i] -= U_(i,i+uBands_[j])*x[i+uBands_[j]]/U_(i,i);
    }
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/math/matrixutilities/qrdecomposition.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i < n; ++i) {
    std::fill(r.row_begin(i), r.row_begin(i)+i, 0.0);
    r[i][i] = rdiag[i];
    if (i < m) {
        std::copy(mT.column_begin(i)+i+1, mT.column_end(i),
                  r.row_begin(i)+i+1);
    }
    else {
        std::fill(r.row_begin(i)+i+1, r.row_end(i), 0.0);
    }
}

for (Size k=0; k < m; ++k) {
    std::fill(w.begin(), w.end(), 0.0);
    w[k] = 1.0;

    for (Size j=0; j < std::min(n, m); ++j) {
        const Real t3 = mT[j][j];
        if (t3 != 0.0) {
            const Real t
                = std::inner_product(mT.row_begin(j)+j, mT.row_end(j),
                                     w.begin()+j, 0.0)/t3;
            for (Size i=j; i<m; ++i) {
                w[i]-=mT[j][i]*t;
            }
        }
        q[k][j] = w[j];
    }
    std::fill(q.row_begin(k) + std::min(n, m), q.row_end(k), 0.0);
}

    for (Size i=0; i < n; ++i)
        ipvt[i] = i;

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/math/matrixutilities/getcovariance.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i<size; ++i)
{
    stdDevs_[i] = std::sqrt(variances_[i]);
    correlationMatrix_[i][i] = 1.0;
    for (Size j=0; j<i; ++j)
    {
        QL_REQUIRE(std::fabs(cov[i][j]-cov[j][i]) <= tolerance,
                   "invalid covariance matrix:" <<
                   "\nc[" << i << ", " << j << "] = " <<
                   cov[i][j] << "\nc[" << j << ", " << i <<
                   "] = " << cov[j][i]);
        correlationMatrix_[i][j] = correlationMatrix_[j][i] =
            cov[i][j]/(stdDevs_[i]*stdDevs_[j]);
    }
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/math/matrixutilities/factorreduction.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size iRow=0; iRow<mtrx.rows(); iRow++)
    for (Size iCol=0; iCol<iRow; iCol++)
        QL_REQUIRE(mtrx[iRow][iCol] == mtrx[iCol][iRow],
                   "input matrix is not symmetric");

for(Size iCol=0; iCol<n; iCol++) {
    for(Size iRow=0; iRow<n; iRow++)
        previousCorrels[iCol] +=
            mtrx[iRow][iCol] * mtrx[iRow][iCol];
    previousCorrels[iCol] =
        std::sqrt((previousCorrels[iCol]-1.)/(n-1.));
}

    for(Size iCol=0; iCol<n; iCol++)
        mtrx[iCol][iCol] =
            previousCorrels[iCol];

    for(Size iCol=0; iCol<n; iCol++) {
        Real thisCorrel = mtrx[iMax][iCol];
        newCorrels.push_back(thisCorrel);
        // strictly is:
        // abs(\sqrt{\rho}- \sqrt{\rho_{old}})/\sqrt{\rho_{old}}
        distances.push_back(
            std::abs(thisCorrel - previousCorrels[iCol])/
                previousCorrels[iCol]);
    }

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/math/statistics/histogram.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    for (Size i=0; i<breaks_.size(); ++i) {
        breaks_[i] = min + (i+1)*h;
    }

    for (Size i=0; i<breaks_.size(); ++i) {
        if (*p < breaks_[i]) {
            ++counts_[i];
            processed = true;
            break;
        }
    }

for (Size i=0; i<bins_; ++i)
    frequency_[i] = static_cast<Real>(counts_[i])/totalCounts;

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/math/statistics/generalstatistics.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (it=samples_.begin(); it!=samples_.end(); ++it) {
    result += it->second;
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/math/statistics/discrepancystatistics.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (i=0; i<N; i++) {
    Real temp = 1.0;
    for (Size k=0; k<dimension_; k++) {
        r_ik = stats_[k].sampleData()[i].first;
        temp *= (1.0 - r_ik*r_ik);
    }
    cdiscr += temp;
}

for (i=0; i<N; i++) {
    for (Size j=0; j<N; j++) {
        Real temp = 1.0;
        for (Size k=0; k<dimension_; k++) {
            r_jk = stats_[k].sampleData()[j].first;
            r_ik = stats_[k].sampleData()[i].first;
            temp *= (1.0 - std::max(r_ik, r_jk));
        }
        adiscr += temp;
    }
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/math/randomnumbers/knuthuniformrng.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (j=0;j<KK;j++) {
    u[j]=ss; ul[j]=0.0;                    // bootstrap the buffer
    ss+=ss; if (ss>=1.0) ss-=1.0-2*ulp; // cyclic shift of 51 bits
}

for (;j<KK+KK-1;j++) u[j]=ul[j]=0.0;

    for (j=KK-1;j>0;--j) ul[j+j]=ul[j],u[j+j]=u[j];    // "square"
    for (j=KK+KK-2;j>KK-LL;j-=2)
        ul[KK+KK-1-j]=0.0,u[KK+KK-1-j]=u[j]-ul[j];

    for (j=KK+KK-2;j>=KK;--j) if(ul[j]) {
        ul[j-(KK-LL)]=ulp-ul[j-(KK-LL)],
            u[j-(KK-LL)]=mod_sum(u[j-(KK-LL)],u[j]);
        ul[j-KK]=ulp-ul[j-KK],u[j-KK]=mod_sum(u[j-KK],u[j]);
    }

        for (j=KK;j>0;--j)  ul[j]=ul[j-1],u[j]=u[j-1];

for (j=0;j<LL;j++) ran_u[j+KK-LL]=u[j];

for (;j<KK;j++) ran_u[j-LL]=u[j];

for (j=0;j<KK;j++) aa[j]=ran_u[j];

for (;j<n;j++) aa[j]=mod_sum(aa[j-KK],aa[j-LL]);

for (i=0;i<LL;i++,j++) ran_u[i]=mod_sum(aa[j-KK],aa[j-LL]);

for (;i<KK;i++,j++) ran_u[i]=mod_sum(aa[j-KK],ran_u[i-LL]);

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/math/randomnumbers/mt19937uniformrng.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (mti=1; mti<N; mti++) {
    mt[mti] =
        (1812433253UL * (mt[mti-1] ^ (mt[mti-1] >> 30)) + mti);
    /* See Knuth TAOCP Vol2. 3rd Ed. P.106 for multiplier. */
    /* In the previous versions, MSBs of the seed affect   */
    /* only MSBs of the array mt[].                        */
    /* 2002/01/09 modified by Makoto Matsumoto             */
    mt[mti] &= 0xffffffffUL;
    /* for >32 bit machines */
}

for (; k; k--) {
    mt[i] = (mt[i] ^ ((mt[i-1] ^ (mt[i-1] >> 30)) * 1664525UL))
        + seeds[j] + j; /* non linear */
    mt[i] &= 0xffffffffUL; /* for WORDSIZE > 32 machines */
    i++; j++;
    if (i>=N) { mt[0] = mt[N-1]; i=1; }
    if (j>=seeds.size()) j=0;
}

for (k=N-1; k; k--) {
    mt[i] = (mt[i] ^ ((mt[i-1] ^ (mt[i-1] >> 30)) * 1566083941UL))
        - i; /* non linear */
    mt[i] &= 0xffffffffUL; /* for WORDSIZE > 32 machines */
    i++;
    if (i>=N) { mt[0] = mt[N-1]; i=1; }
}

for (kk=0;kk<N-M;kk++) {
    y = (mt[kk]&UPPER_MASK)|(mt[kk+1]&LOWER_MASK);
    mt[kk] = mt[kk+M] ^ (y >> 1) ^ mag01[y & 0x1UL];
}

for (;kk<N-1;kk++) {
    y = (mt[kk]&UPPER_MASK)|(mt[kk+1]&LOWER_MASK);
    mt[kk] = mt[(kk+M)-N] ^ (y >> 1) ^ mag01[y & 0x1UL];
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/math/randomnumbers/faurersg.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (int i2=mbit_-2; i2>=0; --i2)
    powBase_[i2][base_] = powBase_[i2+1][base_] * base_;

for (int ii=0; ii<(int)mbit_; ii++) {
    for (int j1=base_+1; j1<2*(int)base_-1; j1++ )
        powBase_[ii][j1] = powBase_[ii][j1-1] + powBase_[ii][base_];
    for (int j2=base_-1; j2>=0; --j2)
        powBase_[ii][j2] = powBase_[ii][j2+1] - powBase_[ii][base_];
}

for (j=0; j<base_ ; j++)
    addOne_[j] = (j+1) % base_;

for (k=0; k<mbit_; k++) {
    std::vector<std::vector<long int> > mm(dimensionality_+1,
        std::vector<long int>(k+1, 0));
    pascal3D.push_back(mm);
    pascal3D[k][0][k] = 1;
    pascal3D[k][1][0] = 1;
    pascal3D[k][1][k] = 1;
}

for (k=2; k<mbit_ ; k++) {
    for (i=1; i<k ; i++) {
        p1 = pascal3D[k-1][1][i-1];
        p2 = pascal3D[k-1][1][i];
        pascal3D[k][1][i] = (p1+p2) % base_;
    }
}

for (j=2; j<dimensionality_; j++) {
  for (long int kk=mbit_-1; kk>=0 ; --kk) {
      diag = mbit_ - kk - 1;
      if (diag==0)
          fact = 1;
      else
          fact = (fact*j) % base_;
      for (long int ii=0; ii<=kk; ii++)
          pascal3D[diag+ii][j][ii] = (fact*
            pascal3D[diag+ii][1][ii]) % base_;
  }
}

for (Size i=0; i<dimensionality_ ; i++) {
    for (Size j=0; j<=bit ; j++) {
        tmp = gray_[i][j];
        gray_[i][j] = (pascal3D[bit][i][j] + tmp) % base_;
        g1 = gray_[i][j];
        g2 = base_ - 1 + g1 - tmp;
        integerSequence_[i] += powBase_[j][g2];
    }
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/math/randomnumbers/latticersg.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size j=0; j < dimensionality_; ++j)
{
    Real theta = i_*z_[j]/N_;
    sequence_.value[j]= std::fmod(theta,1.0);
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/math/randomnumbers/sobolrsg.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (; k<std::min<Size>(dimensionality_,altDegree); k++,index++)
{
    ppmt[k] = AltPrimitivePolynomials[currentDegree-1][index];
    if (ppmt[k]==-1)
    {
        ++currentDegree;
        index=0;
        ppmt[k] = AltPrimitivePolynomials[currentDegree-1][index];
    }

    degree[k] = currentDegree;
}

for (; k<dimensionality_; k++,index++)
{
    ppmt[k] = PrimitivePolynomials[currentDegree-1][index];
    if (ppmt[k]==-1)
    {
        ++currentDegree;
        index=0;
        ppmt[k] = PrimitivePolynomials[currentDegree-1][index];
    }
    degree[k] = currentDegree;

}

for (j=0; j<bits_; j++)
    directionIntegers_[0][j] = (1UL<<(bits_-j-1));

        for (k=1; k<maxTabulated; k++) {
            for (Size l=1; l<=degree[k]; l++) {
                directionIntegers_[k][l-1] = 1UL;
                directionIntegers_[k][l-1] <<= (bits_-l);
            }
        }

        for (k=1; k<std::min(dimensionality_, maxTabulated); k++) {
            j = 0;
            // 0UL marks coefficients' end for a given dimension
            while (initializers[k-1][j] != 0UL) {
                directionIntegers_[k][j] = initializers[k-1][j];
                directionIntegers_[k][j] <<= (bits_-j-1);
                j++;
            }
        }

        for (k=1; k<std::min(dimensionality_, maxTabulated); k++) {
            j = 0;
            // 0UL marks coefficients' end for a given dimension
            while (SLinitializers[k-1][j] != 0UL) {
                directionIntegers_[k][j] = SLinitializers[k-1][j];
                directionIntegers_[k][j] <<= (bits_-j-1);
                j++;
            }
        }

        for (k=1; k<std::min(dimensionality_, maxTabulated); k++) {
            j = 0;
            // 0UL marks coefficients' end for a given dimension
            while (Linitializers[k-1][j] != 0UL) {
                directionIntegers_[k][j] = Linitializers[k-1][j];
                directionIntegers_[k][j] <<= (bits_-j-1);
                j++;
            }
        }

        for (k=1; k<std::min(dimensionality_, maxTabulated); k++) {
            j = 0;
            // 0UL marks coefficients' end for a given dimension
            while (JoeKuoD5initializers[k-1][j] != 0UL) {
                directionIntegers_[k][j] = JoeKuoD5initializers[k-1][j];
                directionIntegers_[k][j] <<= (bits_-j-1);
                j++;
            }
        }

        for (k=1; k<std::min(dimensionality_, maxTabulated); k++) {
            j = 0;
            // 0UL marks coefficients' end for a given dimension
            while (JoeKuoD6initializers[k-1][j] != 0UL) {
                directionIntegers_[k][j] = JoeKuoD6initializers[k-1][j];
                directionIntegers_[k][j] <<= (bits_-j-1);
                j++;
            }
        }

        for (k=1; k<std::min(dimensionality_, maxTabulated); k++) {
            j = 0;
            // 0UL marks coefficients' end for a given dimension
            while (JoeKuoD7initializers[k-1][j] != 0UL) {
                directionIntegers_[k][j] = JoeKuoD7initializers[k-1][j];
                directionIntegers_[k][j] <<= (bits_-j-1);
                j++;
            }
        }

        for (k=1; k<std::min(dimensionality_, maxTabulated); k++) {
            j = 0;
            // 0UL marks coefficients' end for a given dimension
            while (Kuoinitializers[k-1][j] != 0UL) {
                directionIntegers_[k][j] = Kuoinitializers[k-1][j];
                directionIntegers_[k][j] <<= (bits_-j-1);
                j++;
            }
        }

        for (k=1; k<std::min(dimensionality_, maxTabulated); k++) {
            j = 0;
            // 0UL marks coefficients' end for a given dimension
            while (Kuo2initializers[k-1][j] != 0UL) {
                directionIntegers_[k][j] = Kuo2initializers[k-1][j];
                directionIntegers_[k][j] <<= (bits_-j-1);
                j++;
            }
        }

        for (k=1; k<std::min(dimensionality_, maxTabulated); k++) {
            j = 0;
            // 0UL marks coefficients' end for a given dimension
            while (Kuo3initializers[k-1][j] != 0UL) {
                directionIntegers_[k][j] = Kuo3initializers[k-1][j];
                directionIntegers_[k][j] <<= (bits_-j-1);
                j++;
            }
        }

    for (k=maxTabulated; k<dimensionality_; k++) {
        for (Size l=1; l<=degree[k]; l++) {
            do {
                // u is in (0,1)
                Real u = uniformRng.next().value;
                // the direction integer has at most the
                // rightmost l bits non-zero
                directionIntegers_[k][l-1] =
                    (unsigned long)(u*(1UL<<l));
            } while (!(directionIntegers_[k][l-1] & 1UL));
            // iterate until the direction integer is odd
            // that is it has the rightmost bit set

            // shifting bits_-l bits to the left
            // we are guaranteed that the l-th leftmost bit
            // is set, and only the first l leftmost bit
            // can be non-zero
            directionIntegers_[k][l-1] <<= (bits_-l);
        }
    }

for (k=1; k<dimensionality_; k++) {
    unsigned int gk = degree[k];
    for (int l=gk; l<bits_; l++) {
        // eq. 8.19 "Monte Carlo Methods in Finance" by P. Jckel
        unsigned long n = (directionIntegers_[k][l-gk]>>gk);
        // a[k][j] are the coefficients of the monomials in ppmt[k]
        // The highest order coefficient a[k][0] is not actually
        // used in the recurrence relation, and the lowest order
        // coefficient a[k][gk] is always set: this is the reason
        // why the highest and lowest coefficient of
        // the polynomial ppmt[k] are not included in its encoding,
        // provided that its degree is known.
        // That is: a[k][j] = ppmt[k] >> (gk-j-1)
        for (Size j=1; j<gk; j++) {
            // XORed with a selection of (unshifted) direction
            // integers controlled by which of the a[k][j] are set
            if ((ppmt[k] >> (gk-j-1)) & 1UL)
                n ^= directionIntegers_[k][l-j];
        }
        // a[k][gk] is always set, so directionIntegers_[k][l-gk]
        // will always enter
        n ^= directionIntegers_[k][l-gk];
        directionIntegers_[k][l]=n;
    }
}

       for (k=0; k<std::min(32UL,dimensionality_); k++) {
           outStream << std::endl << k+1       << "\t"
                                  << degree[k] << "\t"
                                  << ppmt[k]   << "\t";
           for (j=0; j<10; j++) {
               outStream << io::power_of_two(
                   directionIntegers_[k][j]) << "\t";
           }
       }

for (k=0; k<dimensionality_; k++) {
    integerSequence_[k]=directionIntegers_[k][0];
}

for (Size k=0; k<dimensionality_; k++) {
    integerSequence_[k] = 0;
    for (Size index=0; index<ops; index++) {
        if (G>>index & 1)
            integerSequence_[k] ^= directionIntegers_[k][index];
    }
}

for (Size k=0; k<dimensionality_; k++) {
    // XOR the appropriate direction number into each component of
    // the integer sequence to obtain a new Sobol integer for that
    // component
    integerSequence_[k] ^= directionIntegers_[k][j];
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/math/randomnumbers/lecuyeruniformrng.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (int j=bufferSize+7; j>=0; j--) {
    long k = temp1/q1;
    temp1 = a1*(temp1-k*q1)-k*r1;
    if (temp1 < 0)
        temp1 += m1;
    if (j < bufferSize)
        buffer[j] = temp1;
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/math/randomnumbers/seedgenerator.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (unsigned long i=0; i<skip ; i++)
    rng_.nextInt32();

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/math/randomnumbers/haltonrsg.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i<dimensionality_; ++i) {
    h = 0.0;
    b = PrimeNumbers::get(i);
    f = 1.0;
    k = sequenceCounter_+randomStart_[i];
    while (k) {
        f /= b;
        h += (k%b)*f;
        k /= b;
    }
    sequence_.value[i] = h+randomShift_[i];
    sequence_.value[i] -= long(sequence_.value[i]);
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/math/randomnumbers/sobolbrownianbridgersg.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i < steps_; ++i) {
    gen_.nextStep(output);
    std::copy(output.begin(), output.end(),
              seq_.value.begin()+i*factors_);
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/math/optimization/lmdif.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for( i=0; i<n; i++ )
{
xabs = std::fabs(x[i]);
if( (xabs > rdwarf) && (xabs < agiant) )
{
/*
*       sum for intermediate components.
*/
s2 += xabs*xabs;
continue;
}

if(xabs > rdwarf)
{
/*
*          sum for large components.
*/
if(xabs > x1max)
{
temp = x1max/xabs;
s1 = one + s1*temp*temp;
x1max = xabs;
}
else
{
temp = xabs/x1max;
s1 += temp*temp;
}
continue;
}
/*
*          sum for small components.
*/
if(xabs > x3max)
{
temp = x3max/xabs;
s3 = one + s3*temp*temp;
x3max = xabs;
}
else
{
if(xabs != zero)
{
temp = xabs/x3max;
s3 += temp*temp;
}
}
}

for( j=0; j<n; j++ )
{
temp = x[j];
h = eps * std::fabs(temp);
if(h == zero)
h = eps;
x[j] = temp + h;
fcn(m,n,x,wa,iflag);
if( *iflag < 0)
return;
x[j] = temp;
for( i=0; i<m; i++ )
{
fjac[ij] = (wa[i] - fvec[i])/h;
ij += 1;    /* fjac[i+m*j] */
}
}

for( j=0; j<n; j++ )
{
acnorm[j] = enorm(m,&a[ij]);
rdiag[j] = acnorm[j];
wa[j] = rdiag[j];
if(pivot != 0)
ipvt[j] = j;
ij += m; /* m*j */
}

for( j=0; j<minmn; j++ )
{
if(pivot == 0)
goto L40;
/*
*    bring the column of largest norm into the pivot position.
*/
kmax = j;
for( k=j; k<n; k++ )
{
if(rdiag[k] > rdiag[kmax])
kmax = k;
}
if(kmax == j)
goto L40;

ij = m * j;
jj = m * kmax;
for( i=0; i<m; i++ )
{
temp = a[ij]; /* [i+m*j] */
a[ij] = a[jj]; /* [i+m*kmax] */
a[jj] = temp;
ij += 1;
jj += 1;
}
rdiag[kmax] = rdiag[j];
wa[kmax] = wa[j];
k = ipvt[j];
ipvt[j] = ipvt[kmax];
ipvt[kmax] = k;

L40:
/*
*    compute the householder transformation to reduce the
*    j-th column of a to a multiple of the j-th unit vector.
*/
jj = j + m*j;
ajnorm = enorm(m-j,&a[jj]);
if(ajnorm == zero)
goto L100;
if(a[jj] < zero)
ajnorm = -ajnorm;
ij = jj;
for( i=j; i<m; i++ )
{
a[ij] /= ajnorm;
ij += 1; /* [i+m*j] */
}
a[jj] += one;
/*
*    apply the transformation to the remaining columns
*    and update the norms.
*/
jp1 = j + 1;
if(jp1 < n )
{
for( k=jp1; k<n; k++ )
{
sum = zero;
ij = j + m*k;
jj = j + m*j;
for( i=j; i<m; i++ )
{
sum += a[jj]*a[ij];
ij += 1; /* [i+m*k] */
jj += 1; /* [i+m*j] */
}
temp = sum/a[j+m*j];
ij = j + m*k;
jj = j + m*j;
for( i=j; i<m; i++ )
{
a[ij] -= temp*a[jj];
ij += 1; /* [i+m*k] */
jj += 1; /* [i+m*j] */
}
if( (pivot != 0) && (rdiag[k] != zero) )
{
temp = a[j+m*k]/rdiag[k];
temp = dmax1( zero, one-temp*temp );
rdiag[k] *= std::sqrt(temp);
temp = rdiag[k]/wa[k];
if( (p05*temp*temp) <= MACHEP)
    {
    rdiag[k] = enorm(m-j-1,&a[jp1+m*k]);
    wa[k] = rdiag[k];
    }
}
}
}

L100:
rdiag[j] = -ajnorm;
}

for( j=0; j<n; j++ )
{
ij = kk;
ik = kk;
for( i=j; i<n; i++ )
{
r[ij] = r[ik];
ij += 1;   /* [i+ldr*j] */
ik += ldr; /* [j+ldr*i] */
}
x[j] = r[kk];
wa[j] = qtb[j];
kk += ldr+1; /* j+ldr*j */
}

for( j=0; j<n; j++ )
{
/*
*    prepare the row of d to be eliminated, locating the
*    diagonal element using p from the qr factorization.
*/
l = ipvt[j];
if(diag[l] == zero)
goto L90;
for( k=j; k<n; k++ )
sdiag[k] = zero;
sdiag[j] = diag[l];
/*
*    the transformations to eliminate the row of d
*    modify only a single element of (q transpose)*b
*    beyond the first n, which is initially zero.
*/
qtbpj = zero;
for( k=j; k<n; k++ )
{
/*
*       determine a givens rotation which eliminates the
*       appropriate element in the current row of d.
*/
if(sdiag[k] == zero)
continue;
kk = k + ldr * k;
if(std::fabs(r[kk]) < std::fabs(sdiag[k]))
{
cotan = r[kk]/sdiag[k];
sin = p5/std::sqrt(p25+p25*cotan*cotan);
cos = sin*cotan;
}
else
{
tan = sdiag[k]/r[kk];
cos = p5/std::sqrt(p25+p25*tan*tan);
sin = cos*tan;
}
/*
*       compute the modified diagonal element of r and
*       the modified element of ((q transpose)*b,0).
*/
r[kk] = cos*r[kk] + sin*sdiag[k];
temp = cos*wa[k] + sin*qtbpj;
qtbpj = -sin*wa[k] + cos*qtbpj;
wa[k] = temp;
/*
*       accumulate the tranformation in the row of s.
*/
kp1 = k + 1;
if( n > kp1 )
{
ik = kk + 1;
for( i=kp1; i<n; i++ )
    {
    temp = cos*r[ik] + sin*sdiag[i];
    sdiag[i] = -sin*r[ik] + cos*sdiag[i];
    r[ik] = temp;
    ik += 1; /* [i+ldr*k] */
    }
}
}
L90:
/*
*    store the diagonal element of s and restore
*    the corresponding diagonal element of r.
*/
kk = j + ldr*j;
sdiag[j] = r[kk];
r[kk] = x[j];
}

for( j=0; j<n; j++ )
{
if( (sdiag[j] == zero) && (nsing == n) )
nsing = j;
if(nsing < n)
wa[j] = zero;
}

for( k=0; k<nsing; k++ )
{
j = nsing - k - 1;
sum = zero;
jp1 = j + 1;
if(nsing > jp1)
{
ij = jp1 + ldr * j;
for( i=jp1; i<nsing; i++ )
    {
    sum += r[ij]*wa[i];
    ij += 1; /* [i+ldr*j] */
    }
}
wa[j] = (wa[j] - sum)/sdiag[j];
}

for( j=0; j<n; j++ )
{
l = ipvt[j];
x[l] = wa[j];
}

for( j=0; j<n; j++ )
{
wa1[j] = qtb[j];
if( (r[jj] == zero) && (nsing == n) )
nsing = j;
if(nsing < n)
wa1[j] = zero;
jj += ldr+1; /* [j+ldr*j] */
}

for( k=0; k<nsing; k++ )
{
j = nsing - k - 1;
wa1[j] = wa1[j]/r[j+ldr*j];
temp = wa1[j];
jm1 = j - 1;
if(jm1 >= 0)
    {
    ij = ldr * j;
    for( i=0; i<=jm1; i++ )
        {
        wa1[i] -= r[ij]*temp;
        ij += 1;
        }
    }
}

for( j=0; j<n; j++ )
{
l = ipvt[j];
x[l] = wa1[j];
}

for( j=0; j<n; j++ )
wa2[j] = diag[j]*x[j];

for( j=0; j<n; j++ )
{
l = ipvt[j];
wa1[j] = diag[l]*(wa2[l]/dxnorm);
}

for( j=0; j<n; j++ )
{
sum = zero;
jm1 = j - 1;
if(jm1 >= 0)
    {
    ij = jj;
    for( i=0; i<=jm1; i++ )
        {
        sum += r[ij]*wa1[i];
        ij += 1;
        }
    }
wa1[j] = (wa1[j] - sum)/r[j+ldr*j];
jj += ldr; /* [i+ldr*j] */
}

for( j=0; j<n; j++ )
{
sum = zero;
ij = jj;
for( i=0; i<=j; i++ )
{
sum += r[ij]*qtb[i];
ij += 1;
}
l = ipvt[j];
wa1[j] = sum/diag[l];
jj += ldr; /* [i+ldr*j] */
}

for( j=0; j<n; j++ )
wa1[j] = temp*diag[j];

for( j=0; j<n; j++ )
wa2[j] = diag[j]*x[j];

for( j=0; j<n; j++ )
{
l = ipvt[j];
wa1[j] = diag[l]*(wa2[l]/dxnorm);
}

for( j=0; j<n; j++ )
{
wa1[j] = wa1[j]/sdiag[j];
temp = wa1[j];
jp1 = j + 1;
if(jp1 < n)
{
ij = jp1 + jj;
for( i=jp1; i<n; i++ )
    {
    wa1[i] -= r[ij]*temp;
    ij += 1; /* [i+ldr*j] */
    }
}
jj += ldr; /* ldr*j */
}

for( j=0; j<n; j++ )
{
if( diag[j] <= 0.0 )
    goto L300;
}

for( j=0; j<n; j++ )
    {
    diag[j] = wa2[j];
    if( wa2[j] == zero )
        diag[j] = one;
    }

for( j=0; j<n; j++ )
wa3[j] = diag[j] * x[j];

for( i=0; i<m; i++ )
wa4[i] = fvec[i];

for( j=0; j<n; j++ )
{
temp3 = fjac[jj];
if(temp3 != zero)
{
sum = zero;
ij = jj;
for( i=j; i<m; i++ )
    {
    sum += fjac[ij] * wa4[i];
    ij += 1;    /* fjac[i+m*j] */
    }
temp = -sum / temp3;
ij = jj;
for( i=j; i<m; i++ )
    {
    wa4[i] += fjac[ij] * temp;
    ij += 1;    /* fjac[i+m*j] */
    }
}
fjac[jj] = wa1[j];
jj += m+1;  /* fjac[j+m*j] */
qtf[j] = wa4[j];
}

for( j=0; j<n; j++ )
{
l = ipvt[j];
if(wa2[l] != zero)
    {
    sum = zero;
    ij = jj;
    for( i=0; i<=j; i++ )
        {
        sum += fjac[ij]*(qtf[i]/fnorm);
        ij += 1; /* fjac[i+m*j] */
        }
    gnorm = dmax1(gnorm,std::fabs(sum/wa2[l]));
    }
jj += m;
}

for( j=0; j<n; j++ )
diag[j] = dmax1(diag[j],wa2[j]);

for( j=0; j<n; j++ )
{
wa1[j] = -wa1[j];
wa2[j] = x[j] + wa1[j];
wa3[j] = diag[j]*wa1[j];
}

for( j=0; j<n; j++ )
{
wa3[j] = zero;
l = ipvt[j];
temp = wa1[l];
ij = jj;
for( i=0; i<=j; i++ )
{
wa3[i] += fjac[ij]*temp;
ij += 1; /* fjac[i+m*j] */
}
jj += m;
}

for( j=0; j<n; j++ )
{
x[j] = wa2[j];
wa2[j] = diag[j]*x[j];
}

for( i=0; i<m; i++ )
fvec[i] = wa4[i];

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/math/optimization/projection.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i = 0; i < fixParameters_.size(); i++)
    if (!fixParameters_[i])
        numberOfFreeParameters_++;

for (Size j = 0; j < actualParameters_.size(); j++)
    if (!fixParameters_[j])
        actualParameters_[j] = parameterValues[i++];

for (Size j = 0; j < fixParameters_.size(); j++)
    if (!fixParameters_[j])
        projectedParameters[i++] = parameters[j];

for (Size j = 0; j < y.size(); j++)
    if (!fixParameters_[j])
        y[j] = projectedParameters[i++];

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/math/optimization/simplex.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    for (Size i=0; i<vertices.size(); ++i)
        center += vertices[i];

    for (Size i=0; i<vertices.size(); ++i) {
        Array temp =  vertices[i] - center;
        result += std::sqrt(DotProduct(temp,temp));
    }

for (i=0; i<n; i++) {
    Array direction(n, 0.0);
    direction[i] = 1.0;
    P.constraint().update(vertices_[i+1], direction, lambda_);
}

for (i=0; i<=n; i++)
    values_[i] = P.value(vertices_[i]);

    for (i=0; i<=n; i++)
        sum_ += vertices_[i];

    for (i=1;i<=n; i++) {
        if (values_[i]>values_[iHighest]) {
            iNextHighest = iHighest;
            iHighest = i;
        } else {
            if ((values_[i]>values_[iNextHighest]) && i!=iHighest)
                iNextHighest = i;
        }
        if (values_[i]<values_[iLowest])
            iLowest = i;
    }

                for (Size i=0; i<=n; i++) {
                    if (i!=iLowest) {
                        #if defined(QL_ARRAY_EXPRESSIONS)
                        vertices_[i] =
                            0.5*(vertices_[i] + vertices_[iLowest]);
                        #else
                        vertices_[i] += vertices_[iLowest];
                        vertices_[i] *= 0.5;
                        #endif
                        values_[i] = P.value(vertices_[i]);
                    }
                }

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/math/optimization/differentialevolution.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
      for (Size popIter = 0; popIter < population.size(); popIter++) {
          population[popIter].values = population[popIter].values
              + configuration().stepsizeWeight
              * (shuffledPop1[popIter].values - shuffledPop2[popIter].values);
      }

      for (Size popIter = 0; popIter < population.size(); popIter++) {
          for (Size jitterIter = 0; jitterIter < jitter.size(); jitterIter++) {
              jitter[jitterIter] = rng_.nextReal();
          }
          population[popIter].values = bestMemberEver_.values
              + (shuffledPop1[popIter].values - population[popIter].values)
              * (0.0001 * jitter + configuration().stepsizeWeight);
      }

      for (Size popIter = 0; popIter < population.size(); popIter++) {
          population[popIter].values = oldPopulation[popIter].values
              + configuration().stepsizeWeight
              * (bestMemberEver_.values - oldPopulation[popIter].values)
              + configuration().stepsizeWeight
              * (population[popIter].values - shuffledPop1[popIter].values);
      }

      for (Size fwIter = 0; fwIter < FWeight.size(); fwIter++)
          FWeight[fwIter] = (1.0 - configuration().stepsizeWeight)
              * rng_.nextReal() + configuration().stepsizeWeight;
      for (Size popIter = 0; popIter < population.size(); popIter++) {
          population[popIter].values = population[popIter].values
              + FWeight * (shuffledPop1[popIter].values - shuffledPop2[popIter].values);
      }

      for (Size popIter = 0; popIter < population.size(); popIter++) {
          population[popIter].values = population[popIter].values
              + FWeight * (shuffledPop1[popIter].values - shuffledPop2[popIter].values);
      }

          for (Size popIter = 0; popIter < population.size(); popIter++) {
              population[popIter].values = oldPopulation[popIter].values
                  + configuration().stepsizeWeight
                  * (shuffledPop1[popIter].values - shuffledPop2[popIter].values);
          }

          for (Size popIter = 0; popIter < population.size(); popIter++) {
              population[popIter].values = oldPopulation[popIter].values
                  + K
                  * (shuffledPop1[popIter].values - shuffledPop2[popIter].values
                     - 2.0 * population[popIter].values);
          }

      for (Size popIter = 0; popIter < population.size(); popIter++) {
          if (rng_.nextReal() < 0.1){
              population[popIter].values = rotateArray(bestMemberEver_.values);
          }else {
              population[popIter].values = bestMemberEver_.values
                  + currGenSizeWeights_[popIter]
                  * (shuffledPop1[popIter].values - shuffledPop2[popIter].values);
          }
      }

for (Size popIter = 0; popIter < population.size(); popIter++) {
    population[popIter].values = oldPopulation[popIter].values * invCrossoverMask[popIter]
        + mutantPopulation[popIter].values * crossoverMask[popIter];
    // immediately apply bounds if specified
    if (configuration().applyBounds) {
        for (Size memIter = 0; memIter < population[popIter].values.size(); memIter++) {
            if (population[popIter].values[memIter] > upperBound_[memIter])
                population[popIter].values[memIter] = upperBound_[memIter]
                    + rng_.nextReal()
                    * (mirrorPopulation[popIter].values[memIter]
                       - upperBound_[memIter]);
            if (population[popIter].values[memIter] < lowerBound_[memIter])
                population[popIter].values[memIter] = lowerBound_[memIter]
                    + rng_.nextReal()
                    * (mirrorPopulation[popIter].values[memIter]
                       - lowerBound_[memIter]);
        }
    }
    // evaluate objective function as soon as possible to avoid unnecessary loops
    try {
        population[popIter].cost = costFunction.value(population[popIter].values);
    } catch (Error&) {
        population[popIter].cost = QL_MAX_REAL;
    }
}

for (Size cmIter = 0; cmIter < crossoverMask.size(); cmIter++) {
    for (Size memIter = 0; memIter < crossoverMask[cmIter].size(); memIter++) {
        if (rng_.nextReal() < mutationProbabilities[cmIter]) {
            invCrossoverMask[cmIter][memIter] = 0.0;
        } else {
            crossoverMask[cmIter][memIter] = 0.0;
        }
    }
}

    for (Size coIter = 0;coIter< currGenCrossover_.size(); coIter++){
        mutationProbabilities[coIter] =
            (1.0 - std::pow(currGenCrossover_[coIter],
                            (int) population.front().values.size()))
            / (population.front().values.size()
               * (1.0 - currGenCrossover_[coIter]));
    }

for (Size coIter = 0;coIter < currGenSizeWeights_.size(); coIter++){
    if (rng_.nextReal() < sizeWeightChangeProb)
        currGenSizeWeights_[coIter] = sizeWeightLowerBound + rng_.nextReal() * sizeWeightUpperBound;
}

for (Size coIter = 0;coIter < currGenCrossover_.size(); coIter++){
    if (rng_.nextReal() < crossoverChangeProb)
        currGenCrossover_[coIter] = rng_.nextReal();
}

for (Size j = 1; j < population.size(); ++j) {
    for (Size i = 0; i < p.currentValue().size(); ++i) {
        Real l = lowerBound_[i], u = upperBound_[i];
        population[j].values[i] = l + (u-l)*rng_.nextReal();
    }
    population[j].cost = p.costFunction().value(population[j].values);
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/math/optimization/bfgs.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    for (Size i = 0; i < P.currentValue().size(); ++i)
        inverseHessian_[i][i] = 1.;

for (Size i = 0; i < P.currentValue().size(); ++i)
    for (Size j = 0; j < P.currentValue().size(); ++j)
        diffGradientWithHessianApplied[i] += inverseHessian_[i][j] * diffGradient[j];

for (Size i = 0; i < P.currentValue().size(); ++i)
{
    fac += diffGradient[i] * lineSearch_->searchDirection()[i];
    fae += diffGradient[i] * diffGradientWithHessianApplied[i];
    sumdg += std::pow(diffGradient[i], 2.);
    sumxi += std::pow(lineSearch_->searchDirection()[i], 2.);
}

    for (Size i = 0; i < P.currentValue().size(); ++i)
        diffGradient[i] = fac * lineSearch_->searchDirection()[i] - fad * diffGradientWithHessianApplied[i];

    for (Size i = 0; i < P.currentValue().size(); ++i)
        for (Size j = 0; j < P.currentValue().size(); ++j)
        {
            inverseHessian_[i][j] += fac * lineSearch_->searchDirection()[i] * lineSearch_->searchDirection()[j];
            inverseHessian_[i][j] -= fad * diffGradientWithHessianApplied[i] * diffGradientWithHessianApplied[j];
            inverseHessian_[i][j] += fae * diffGradient[i] * diffGradient[j];
        }

for (Size i = 0; i < P.currentValue().size(); ++i)
{
    direction[i] = 0.0;
    for (Size j = 0; j < P.currentValue().size(); ++j)
        direction[i] -= inverseHessian_[i][j] * lineSearch_->lastGradient()[j];
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/math/distributions/gammadistribution.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    for (Size n=1; n<=100; n++) {
        ap += 1.0;
        del *= x/ap;
        sum += del;
        if (std::fabs(del) < std::fabs(sum)*3.0e-7)
            return sum*std::exp(-x + a_*std::log(x) - gln);
    }

    for (Size n=1; n<=100; n++) {
        Real an = -1.0*n*(n-a_);
        b += 2.0;
        d = an*d + b;
        if (std::fabs(d) < QL_EPSILON) d = QL_EPSILON;
        c = b + an/c;
        if (std::fabs(c) < QL_EPSILON) c = QL_EPSILON;
        d = 1.0/d;
        Real del = d*c;
        h *= del;
        if (std::fabs(del - 1.0)<QL_EPSILON)
            return 1.0-h*std::exp(-x + a_*std::log(x) - gln);
    }

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/math/distributions/bivariatestudenttdistribution.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            for (Natural j = 3; j <= n / 2; ++j) {
                f_j *= (j - 1.5) / (Real) (j - 1) / divK;
                dgj *= (Real) (j - 2) / (2 * j - 3) * dgM;
                g_j += dgj;
                sum += f_j * g_j;
            }

            for (Natural j = 3; j <= n / 2; ++j) {
                f_j *= (j - 1.5) / (Real) (j - 1) / divH;
                dgj *= (Real) (j - 2) / (2 * j - 3) * dgM;
                g_j += dgj;
                sum += f_j * g_j;
            }

            for (Natural j = 2; j <= (n - 1) / 2; ++j) {
                f_j *= (Real) (j - 1) / (j - 0.5) / divK;
                dgj *= (Real) (2 * j - 3) / (j - 1) * mult;
                g_j += dgj;
                sum += f_j * g_j;
            }

            for (Natural j = 2; j <= (n - 1) / 2; ++j) {
                f_j *= (Real) (j - 1) / (j - 0.5) / divH;
                dgj *= (Real) (2 * j - 3) / (j - 1) * mult;
                g_j += dgj;
                sum += f_j * g_j;
            }

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/math/distributions/bivariatenormaldistribution.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    for (Size i=0; i<5; i++) {
        for (Size j=0;j<5; j++) {
            sum += x_[i]*x_[j]*
                std::exp(a1*(2.0*y_[i]-a1)+b1*(2.0*y_[j]-b1)
                         +2.0*rho_*(y_[i]-a1)*(y_[j]-b1));
        }
    }

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/math/distributions/chisquaredistribution.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (;;) {
    if (f_x_2n > 0) {
        flag = true;
        goto L10;
    }
    for (;;) {
        u *= lam / n;
        v += u;
        t *= x / f_2n;
        ans += v*t;
        n++;
        f_2n += 2.0;
        f_x_2n += 2.0;
        if (!flag && n <= itrmax)
            break;
    L10:
        bound = t * x / f_x_2n;
        if (bound <= errmax || n > itrmax)
            goto L_End;
    }
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/methods/lattices/trinomialtree.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i<nTimeSteps; i++) {
    Time t = timeGrid[i];
    Time dt = timeGrid.dt(i);

    //Variance must be independent of x
    Real v2 = process->variance(t, 0.0, dt);
    Volatility v = std::sqrt(v2);
    dx_.push_back(v*std::sqrt(3.0));

    Branching branching;
    for (Integer j=jMin; j<=jMax; j++) {
        Real x = x0_ + j*dx_[i];
        Real m = process->expectation(t, x, dt);
        Integer temp = Integer(std::floor((m-x0_)/dx_[i+1] + 0.5));

        if (isPositive) {
            while (x0_+(temp-1)*dx_[i+1]<=0) {
                temp++;
            }
        }

        Real e = m - (x0_ + temp*dx_[i+1]);
        Real e2 = e*e;
        Real e3 = e*std::sqrt(3.0);

        Real p1 = (1.0 + e2/v2 - e3/v)/6.0;
        Real p2 = (2.0 - e2/v2)/3.0;
        Real p3 = (1.0 + e2/v2 + e3/v)/6.0;

        branching.add(temp, p1, p2, p3);
    }
    branchings_.push_back(branching);

    jMin = branching.jMin();
    jMax = branching.jMax();
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/methods/montecarlo/lsmbasissystem.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        for(Size i=0; i<order_; ++i)
            ret *= x;

        for(Size i=1; i<b_.size(); ++i)
            ret *= b_[i].operator()(a[i]);

    for(Size i=0; i<v.size(); ++i) {
        QL_REQUIRE(dim==v[i].size(), "wrong tuple size");
        QL_REQUIRE(order==std::accumulate(v[i].begin(), v[i].end(), 0u),
            "wrong tuple order");
    }

    for(Size i=0; i<dim; ++i) {
        // increase i-th value in every tuple by 1
        for(Size j=0; j<v.size(); ++j) {
            x = v[j];
            x[i] += 1;
            tuples.insert(x);
        }
    }

for (Size i=0; i<=order; ++i) {
    switch (polyType) {
      case Monomial:
        ret[i] = MonomialFct(i);
        break;
      case Laguerre:
        ret[i] = boost::bind(ptr_w, GaussLaguerrePolynomial(), i, _1);
        break;
      case Hermite:
        ret[i] = boost::bind(ptr_w, GaussHermitePolynomial(), i, _1);
        break;
      case Hyperbolic:
        ret[i] = boost::bind(ptr_w, GaussHyperbolicPolynomial(), i, _1);
        break;
      case Legendre:
        ret[i] = boost::bind(ptr_w, GaussLegendrePolynomial(), i, _1);
        break;
      case Chebyshev:
        ret[i] = boost::bind(ptr_w, GaussChebyshevPolynomial(), i, _1);
        break;
      case Chebyshev2nd:
        ret[i] = boost::bind(ptr_w,GaussChebyshev2ndPolynomial(),i, _1);
        break;
      default:
        QL_FAIL("unknown regression type");
    }
}

for(Size i=1; i<=order; ++i) {
    tuples = next_order_tuples(tuples);
    // now we have all tuples of order i
    // for each tuple add the corresponding term
    for(Size j=0; j<tuples.size(); ++j) {
        for(Size k=0; k<dim; ++k)
            term[k] = pathBasis[tuples[j][k]];
        ret.push_back(MultiDimFct(term));
    }
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/methods/montecarlo/genericlsregression.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=steps-1; i!=0; --i) {

    std::vector<NodeData>& exerciseData = simulationData[i];

    // 1) find the covariance matrix of basis function values and
    //    deflated cash-flows
    Size N = exerciseData.front().values.size();
    std::vector<Real> temp(N+1);
    SequenceStatistics stats(N+1);

    Size j;
    for (j=0; j<exerciseData.size(); ++j) {
        if (exerciseData[j].isValid) {
            std::copy(exerciseData[j].values.begin(),
                      exerciseData[j].values.end(),
                      temp.begin());
            temp.back() = exerciseData[j].cumulatedCashFlows
                        - exerciseData[j].controlValue;

            stats.add(temp);
        }
    }

    std::vector<Real> means = stats.mean();
    Matrix covariance = stats.covariance();

    Matrix C(N,N);
    Array target(N);
    for (Size k=0; k<N; ++k) {
        target[k] = covariance[k][N] + means[k]*means[N];
        for (Size l=0; l<=k; ++l)
            C[k][l] = C[l][k] = covariance[k][l] + means[k]*means[l];
    }

    // 2) solve for least squares regression
    Array alphas = SVD(C).solveFor(target);
    basisCoefficients[i-1].resize(N);
    std::copy(alphas.begin(), alphas.end(),
              basisCoefficients[i-1].begin());

    // 3) use exercise strategy to divide paths into exercise and
    //    non-exercise domains
    for (j=0; j<exerciseData.size(); ++j) {
        if (exerciseData[j].isValid) {
            Real exerciseValue = exerciseData[j].exerciseValue;
            Real continuationValue =
                exerciseData[j].cumulatedCashFlows;
            Real estimatedContinuationValue =
                std::inner_product(
                         exerciseData[j].values.begin(),
                         exerciseData[j].values.end(),
                         alphas.begin(),
                         exerciseData[j].controlValue);

            // for exercise paths, add deflated rebate to
            // deflated cash-flows at previous time frame;
            // for non-exercise paths, add deflated cash-flows to
            // deflated cash-flows at previous time frame
            Real value = estimatedContinuationValue <= exerciseValue ?
                         exerciseValue :
                         continuationValue;

            simulationData[i-1][j].cumulatedCashFlows += value;
        }
    }
}

for (Size j=0; j<estimatedData.size(); ++j)
    estimate.add(estimatedData[j].cumulatedCashFlows);

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/methods/montecarlo/parametricexercise.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    for (Size i=0; i<simulationData_.size(); ++i) {
        if (simulationData_[i].isValid)
            return;
    }

    for (Size i=0; i<simulationData_.size(); ++i) {
        if (simulationData_[i].isValid) {
            ++n;
            if (exercise_.exercise(exerciseIndex_,
                                   parameters_,
                                   simulationData_[i].values))
                sum += simulationData_[i].exerciseValue;
            else
                sum += simulationData_[i].cumulatedCashFlows;
        }
    }

for (Size i=steps-1; i!=0; --i) {
    const std::vector<NodeData>& exerciseData = simulationData[i];

    parameters[i-1].resize(exercise.numberOfParameters()[i-1]);


    // optimize
    ValueEstimate f(exerciseData, exercise, i-1);

    Array guess(parameters[i-1].size());
    exercise.guess(i-1, parameters[i-1]);
    std::copy(parameters[i-1].begin(), parameters[i-1].end(),
              guess.begin());

    NoConstraint c;

    Problem p(f, c, guess);
    method.minimize(p, endCriteria);

    Array result = p.currentValue();
    std::copy(result.begin(), result.end(),
              parameters[i-1].begin());

    std::vector<NodeData>& previousData = simulationData[i-1];
    for (Size j=0; j<previousData.size(); ++j) {
        if (exerciseData[j].isValid) {
            if (exercise.exercise(i-1,
                                  parameters[i-1],
                                  exerciseData[j].values))
                previousData[j].cumulatedCashFlows +=
                    exerciseData[j].exerciseValue;
            else
                previousData[j].cumulatedCashFlows +=
                    exerciseData[j].cumulatedCashFlows;
        }
    }
}

for (Size i=0; i<initialData.size(); ++i)
    sum += initialData[i].cumulatedCashFlows;

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/methods/montecarlo/brownianbridge.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i<size_; ++i)
    t_[i] = static_cast<Time>(i+1);

for (Size i=0; i<size_; ++i)
    t_[i] = timeGrid[i+1];

for (Size i=1; i<size_; ++i)
    sqrtdt_[i] = std::sqrt(t_[i]-t_[i-1]);

for (Size j=0, i=1; i<size_; ++i) {
    // Find the next unpopulated entry in the map.
    while (map[j])
        ++j;
    Size k = j;
    // Find the next populated entry in the map from there.
    while (!map[k])
        ++k;
    // l-1 is now the index of the point to be constructed next.
    Size l = j + ((k-1-j)>>1);
    map[l] = i;
    // The i-th Gaussian variate will be used to set point l-1.
    bridgeIndex_[i] = l;
    leftIndex_[i]   = j;
    rightIndex_[i]  = k;
    if (j != 0) {
        leftWeight_[i]= (t_[k]-t_[l])/(t_[k]-t_[j-1]);
        rightWeight_[i] = (t_[l]-t_[j-1])/(t_[k]-t_[j-1]);
        stdDev_[i] =
            std::sqrt(((t_[l]-t_[j-1])*(t_[k]-t_[l]))
                      /(t_[k]-t_[j-1]));
    } else {
        leftWeight_[i]  = (t_[k]-t_[l])/t_[k];
        rightWeight_[i] =  t_[l]/t_[k];
        stdDev_[i] = std::sqrt(t_[l]*(t_[k]-t_[l])/t_[k]);
    }
    j=k+1;
    if (j>=size_)
        j=0;    //  wrap around
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/methods/finitedifferences/tridiagonaloperator.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size j=1; j<=n_-2; j++)
    result[j] += lowerDiagonal_[j-1]*v[j-1]+
        upperDiagonal_[j]*v[j+1];

for (Size j=1; j<=n_-1; ++j) {
    temp_[j] = upperDiagonal_[j-1]/bet;
    bet = diagonal_[j]-lowerDiagonal_[j-1]*temp_[j];
    QL_ENSURE(!close(bet, 0.0), "division by zero");
    result[j] = (rhs[j] - lowerDiagonal_[j-1]*result[j-1])/bet;
}

for (Size j=n_-2; j>0; --j)
    result[j] -= temp_[j+1]*result[j+1];

for (Size sorIteration=0; err>tol ; ++sorIteration) {
    QL_REQUIRE(sorIteration<100000,
               "tolerance (" << tol << ") not reached in " <<
               sorIteration << " iterations. " <<
               "The error still is " << err);

    temp = omega * (rhs[0]     -
                    upperDiagonal_[0]   * result[1]-
                    diagonal_[0]        * result[0])/diagonal_[0];
    err = temp*temp;
    result[0] += temp;
    Size i;
    for (i=1; i<n_-1 ; ++i) {
        temp = omega *(rhs[i]     -
                       upperDiagonal_[i]   * result[i+1]-
                       diagonal_[i]        * result[i] -
                       lowerDiagonal_[i-1] * result[i-1])/diagonal_[i];
        err += temp * temp;
        result[i] += temp;
    }

    temp = omega * (rhs[i]     -
                    diagonal_[i]        * result[i] -
                    lowerDiagonal_[i-1] * result[i-1])/diagonal_[i];
    err += temp*temp;
    result[i] += temp;
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/methods/finitedifferences/meshers/uniformgridmesher.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i < layout->dim().size(); ++i) {
    dx_[i] = (boundaries[i].second - boundaries[i].first)
        / (layout->dim()[i]-1);

    locations_[i] = std::vector<Real>(layout->dim()[i]);
    for (Size j=0; j < layout->dim()[i]; ++j) {
        locations_[i][j] = boundaries[i].first + j*dx_[i];
    }
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/methods/finitedifferences/meshers/concentrating1dmesher.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    for (Size i=1; i < size-1; ++i) {
        const Real li = requireCPoint ? (*transform)(i*dx) : i*dx;
        locations_[i] = cPoint
            + density*std::sinh(c1*(1.0-li)+c2*li);
    }

    for (Size i=1; i < size-1; ++i) {
        locations_[i] = start + i*dx*(end-start);
    }

for (Size i=0; i < size-1; ++i) {
    dplus_[i] = dminus_[i+1] = locations_[i+1] - locations_[i];
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/methods/finitedifferences/meshers/fdmmeshercomposite.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        for (Size i=0; i < dim.size(); ++i) {
            dim[i] = meshers[i]->size();
        }

for (Size i=0; i < mesher.size(); ++i) {
    QL_REQUIRE(mesher[i]->size() == layout->dim()[i],
               "size of 1d mesher " << i << " does not fit to layout");
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/methods/finitedifferences/meshers/fdmblackscholesmultistrikemesher.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i < locations_.size(); ++i) {
    dplus_[i]  = helper->dplus(i);
    dminus_[i] = helper->dminus(i);
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/methods/finitedifferences/meshers/fdmblackscholesmesher.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i < locations_.size(); ++i) {
    dplus_[i]  = helper->dplus(i);
    dminus_[i] = helper->dminus(i);
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/methods/finitedifferences/meshers/fdmhestonvariancemesher.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    for (Size l=1; l<=tAvgSteps; ++l) {
        const Real t = (maturity*l)/tAvgSteps;
        const Real ncp = 4*process->kappa()*std::exp(-process->kappa()*t)
            /(square<Real>()(process->sigma())
            *(1-std::exp(-process->kappa()*t)))*process->v0();
        const Real k = square<Real>()(process->sigma())
            *(1-std::exp(-process->kappa()*t))/(4*process->kappa());

        const Real qMin = 0.0; // v_min = 0.0;
        const Real qMax = std::max(process->v0(),
            k*InverseNonCentralChiSquareDistribution(
                                    df, ncp, 1000,  1e-8)(1-epsilon));

        const Real minVStep=(qMax-qMin)/(50*size);
        Real ps,p = 0.0;

        Real vTmp = qMin;
        grid.insert(std::pair<Real, Real>(qMin, epsilon));
        
        for (Size i=1; i < size; ++i) {
            ps = (1 - epsilon - p)/(size-i);
            p += ps;
            const Real tmp = k*InverseNonCentralChiSquareDistribution(
                df, ncp, 1000, 1e-8)(p);

            const Real vx = std::max(vTmp+minVStep, tmp);
            p = NonCentralChiSquareDistribution(df, ncp)(vx/k);
            vTmp=vx;
            grid.insert(std::pair<Real, Real>(vx, p));
        }
    }

    for (Size i=0; i < size; ++i) {
        const Size b = (i*tp.size())/size;
        const Size e = ((i+1)*tp.size())/size;
        for (Size j=b; j < e; ++j) {
            vGrid[i]+=tp[j].first/(e-b);
            pGrid[i]+=tp[j].second/(e-b);
        }
    }

    for (Size i=0; i < size; ++i) {
        pGrid[i] = i/(size-1.0);
        vGrid[i] = lowerBound + i*(upperBound-lowerBound)/(size-1.0);
    }

for (Size i=1; i<vGrid.size(); ++i) {
    if (vGrid[i-1] <= v0 && vGrid[i] >= v0) {
        if (std::fabs(vGrid[i-1] - v0) < std::fabs(vGrid[i] - v0))
            vGrid[i-1] = v0;
        else
            vGrid[i] = v0;
    }
}

for (Size i=0; i < size-1; ++i) {
    dminus_[i+1] = dplus_[i] = vGrid[i+1] - vGrid[i];
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/methods/finitedifferences/meshers/exponentialjump1dmesher.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i < steps; ++i) {
    const Real p = start + i*dx;
    locations_[i] = -1.0/eta*std::log(1.0-p);
}

for (Size i=0; i < steps-1; ++i) {
    dminus_[i+1] = dplus_[i] = locations_[i+1]-locations_[i];
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/methods/finitedifferences/meshers/fdmsimpleprocess1dmesher.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size l=1; l<=tAvgSteps; ++l) {
    const Real t = (maturity*l)/tAvgSteps;
    
    const Real mp = (mandatoryPoint != Null<Real>()) ? mandatoryPoint
                                                     : process->x0();

    const Real qMin = std::min(std::min(mp, process->x0()),
        process->evolve(0, process->x0(), t, 
                        InverseCumulativeNormal()(eps)));
    const Real qMax = std::max(std::max(mp, process->x0()),
        process->evolve(0, process->x0(), t,
                        InverseCumulativeNormal()(1-eps)));
    
    const Real dp = (1-2*eps)/(size-1);
    Real p = eps;
    locations_[0] += qMin;
    
    for (Size i=1; i < size-1; ++i) {
        p += dp;
        locations_[i] += process->evolve(0, process->x0(), t, 
                                         InverseCumulativeNormal()(p));
    }
    locations_.back() += qMax;
}

for (Size i=0; i < size-1; ++i) {
    dminus_[i+1] = dplus_[i] = locations_[i+1] - locations_[i];
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/methods/finitedifferences/operators/secondordermixedderivativeop.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (FdmLinearOpIterator iter = layout->begin(); iter!=endIter; ++iter) {
    const Size i = iter.index();
    const Real hm_d0 = mesher->dminus(iter, d0_);
    const Real hp_d0 = mesher->dplus(iter, d0_);
    const Real hm_d1 = mesher->dminus(iter, d1_);
    const Real hp_d1 = mesher->dplus(iter, d1_);

    const Real zetam1 = hm_d0*(hm_d0+hp_d0);
    const Real zeta0  = hm_d0*hp_d0;
    const Real zetap1 = hp_d0*(hm_d0+hp_d0);
    const Real phim1  = hm_d1*(hm_d1+hp_d1);
    const Real phi0   = hm_d1*hp_d1;
    const Real phip1  = hp_d1*(hm_d1+hp_d1);

    const Size c0 = iter.coordinates()[d0_];
    const Size c1 = iter.coordinates()[d1_];
    if (c0 == 0 && c1 == 0) {
        // lower left corner
        a00_[i] = a01_[i] = a02_[i] = a10_[i] = a20_[i] = 0.0;
        a21_[i] = a12_[i] = -(a11_[i] = a22_[i] = 1.0/(hp_d0*hp_d1));
    }
    else if (c0 == layout->dim()[d0_]-1 && c1 == 0) {
        // upper left corner
        a22_[i] = a21_[i] = a20_[i] = a10_[i] = a00_[i] = 0.0;
        a11_[i] = a02_[i] = -(a01_[i] = a12_[i] = 1.0/(hm_d0*hp_d1));
    }
    else if (c0 == 0 && c1 == layout->dim()[d1_]-1) {
        // lower right corner
        a00_[i] = a01_[i] = a02_[i] = a12_[i] = a22_[i] = 0.0;
        a20_[i] = a11_[i] = -(a10_[i] = a21_[i] = 1.0/(hp_d0*hm_d1));
    }
    else if (c0 == layout->dim()[d0_]-1 && c1 == layout->dim()[d1_]-1) {
        // upper right corner
        a20_[i] = a21_[i] = a22_[i] = a12_[i] = a02_[i] = 0.0;
        a10_[i] = a01_[i] = -(a00_[i] = a11_[i] = 1.0/(hm_d0*hm_d1));
    }
    else if (c0 == 0) {
        // lower side
        a00_[i] = a01_[i] = a02_[i] = 0.0;

        a20_[i] = -(a10_[i] = hp_d1/(hp_d0*phim1));
        a11_[i] = -(a21_[i] = (hp_d1-hm_d1)/(hp_d0*phi0));
        a12_[i] = -(a22_[i] = hm_d1/(hp_d0*phip1));
    }
    else if (c0 == layout->dim()[d0_]-1) {
        // upper side
        a20_[i] = a21_[i] = a22_[i] = 0.0;

        a10_[i] = -(a00_[i] = hp_d1/(hm_d0*phim1));
        a01_[i] = -(a11_[i] = (hp_d1-hm_d1)/(hm_d0*phi0));
        a02_[i] = -(a12_[i] = hm_d1/(hm_d0*phip1));
    }
    else if (c1 == 0) {
        // left side
        a00_[i] = a10_[i] = a20_[i] = 0.0;

        a02_[i] = -(a01_[i] = hp_d0/(zetam1*hp_d1));
        a11_[i] = -(a12_[i] = (hp_d0-hm_d0)/(zeta0*hp_d1));
        a21_[i] = -(a22_[i] = hm_d0/(zetap1*hp_d1));
    }
    else if (c1 == layout->dim()[d1_]-1) {
        // right side
        a22_[i] = a12_[i] = a02_[i] = 0.0;

        a01_[i] = -(a00_[i] = hp_d0/(zetam1*hm_d1));
        a10_[i] = -(a11_[i] = (hp_d0-hm_d0)/(zeta0*hm_d1));
        a20_[i] = -(a21_[i] = hm_d0/(zetap1*hm_d1));
    }
    else {
        a00_[i] =  hp_d0*hp_d1/(zetam1*phim1);
        a10_[i] = -(hp_d0-hm_d0)*hp_d1/(zeta0*phim1);
        a20_[i] = -hm_d0*hp_d1/(zetap1*phim1);
        a01_[i] = -hp_d0*(hp_d1-hm_d1)/(zetam1*phi0);
        a11_[i] = (hp_d0-hm_d0)*(hp_d1-hm_d1)/(zeta0*phi0);
        a21_[i] =  hm_d0*(hp_d1-hm_d1)/(zetap1*phi0);
        a02_[i] = -hp_d0*hm_d1/(zetam1*phip1);
        a12_[i] =  hm_d1*(hp_d0-hm_d0)/(zeta0*phip1);
        a22_[i] =  hm_d0*hm_d1/(zetap1*phip1);
    }
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/methods/finitedifferences/operators/secondderivativeop.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (FdmLinearOpIterator iter = layout->begin(); iter!=endIter; ++iter) {
    const Size i = iter.index();
    const Real hm = mesher->dminus(iter, direction_);
    const Real hp = mesher->dplus(iter, direction_);

    const Real zetam1 = hm*(hm+hp);
    const Real zeta0  = hm*hp;
    const Real zetap1 = hp*(hm+hp);

    const Size co = iter.coordinates()[direction_];
    if (co == 0 || co == layout->dim()[direction]-1) {
        lower_[i] = diag_[i] = upper_[i] = 0.0;
    }
    else {
        lower_[i] =  2.0/zetam1;
        diag_[i]  = -2.0/zeta0;
        upper_[i] =  2.0/zetap1;
    }
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/methods/finitedifferences/operators/fdmbatesop.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i < f.rows(); ++i) {
    interpl[i] = shared_ptr<LinearInterpolation>(
        new LinearInterpolation(x.begin(), x.end(), f.row_begin(i)));
}

for (FdmLinearOpIterator iter=layout->begin(); iter!=endIter; ++iter) {
    const Size i = iter.coordinates()[0];
    const Size j = iter.coordinates()[1];

    integral[iter.index()] = M_1_SQRTPI* 
        gaussHermiteIntegration_(
              IntegroIntegrand(interpl[j], bcSet_, x[i], delta_, nu_));
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/methods/finitedifferences/operators/firstderivativeop.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (FdmLinearOpIterator iter = layout->begin(); iter!=endIter; ++iter) {
    const Size i = iter.index();
    const Real hm = mesher->dminus(iter, direction_);
    const Real hp = mesher->dplus(iter, direction_);

    const Real zetam1 = hm*(hm+hp);
    const Real zeta0  = hm*hp;
    const Real zetap1 = hp*(hm+hp);

    if (iter.coordinates()[direction_] == 0) {
        //upwinding scheme
        lower_[i] = 0.0;
        diag_[i]  = -(upper_[i] = 1/hp);
    }
    else if (   iter.coordinates()[direction_]
             == layout->dim()[direction]-1) {
         // downwinding scheme
        lower_[i] = -(diag_[i] = 1/hm);
        upper_[i] = 0.0;
    }
    else {
        lower_[i] = -hp/zetam1;
        diag_[i]  = (hp-hm)/zeta0;
        upper_[i] = hm/zetap1;
    }
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/methods/finitedifferences/operators/ninepointlinearop.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (FdmLinearOpIterator iter = layout->begin(); iter!=endIter; ++iter) {
    const Size i = iter.index();

    i10_[i] = layout->neighbourhood(iter, d1_, -1);
    i01_[i] = layout->neighbourhood(iter, d0_, -1);
    i21_[i] = layout->neighbourhood(iter, d0_,  1);
    i12_[i] = layout->neighbourhood(iter, d1_,  1);
    i00_[i] = layout->neighbourhood(iter, d0_, -1, d1_, -1);
    i20_[i] = layout->neighbourhood(iter, d0_,  1, d1_, -1);
    i02_[i] = layout->neighbourhood(iter, d0_, -1, d1_,  1);
    i22_[i] = layout->neighbourhood(iter, d0_,  1, d1_,  1);
}

for (Size i=0; i < retVal.size(); ++i) {
    retVal[i] =   a00[i]*u[i00[i]]
                + a01[i]*u[i01[i]]
                + a02[i]*u[i02[i]]
                + a10[i]*u[i10[i]]
                + a11[i]*u[i]
                + a12[i]*u[i12[i]]
                + a20[i]*u[i20[i]]
                + a21[i]*u[i21[i]]
                + a22[i]*u[i22[i]];
}

for (Size i=0; i < index->size(); ++i) {
    retVal(i, i00_[i]) += a00_[i];
    retVal(i, i01_[i]) += a01_[i];
    retVal(i, i02_[i]) += a02_[i];
    retVal(i, i10_[i]) += a10_[i];
    retVal(i, i      ) += a11_[i];
    retVal(i, i12_[i]) += a12_[i];
    retVal(i, i20_[i]) += a20_[i];
    retVal(i, i21_[i]) += a21_[i];
    retVal(i, i22_[i]) += a22_[i];
}

for (Size i=0; i < size; ++i) {
    const Real s = u[i];
    retVal.a11_[i]=a11_[i]*s; retVal.a00_[i]=a00_[i]*s;
    retVal.a01_[i]=a01_[i]*s; retVal.a02_[i]=a02_[i]*s;
    retVal.a10_[i]=a10_[i]*s; retVal.a20_[i]=a20_[i]*s;
    retVal.a21_[i]=a21_[i]*s; retVal.a12_[i]=a12_[i]*s;
    retVal.a22_[i]=a22_[i]*s;
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/methods/finitedifferences/operators/triplebandlinearop.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (FdmLinearOpIterator iter = layout->begin(); iter!=endIter; ++iter) {
    const Size i = iter.index();

    i0_[i] = layout->neighbourhood(iter, direction, -1);
    i2_[i] = layout->neighbourhood(iter, direction,  1);

    const std::vector<Size>& coordinates = iter.coordinates();
    const Size newIndex =
          std::inner_product(coordinates.begin(), coordinates.end(),
                             newSpacing.begin(), Size(0));
    reverseIndex_[newIndex] = i;
}

        for (Size i=0; i < size; ++i) {
            diag[i]  = y_diag[i];
            lower[i] = y_lower[i];
            upper[i] = y_upper[i];
        }

        for (Size i=0; i < size; ++i) {
            diag[i]  = y_diag[i] + bptr[i*binc];
            lower[i] = y_lower[i];
            upper[i] = y_upper[i];
        }

    for (Size i=0; i < size; ++i) {
        const Real s = aptr[i*ainc];
        diag[i]  = y_diag[i]  + s*x_diag[i];
        lower[i] = y_lower[i] + s*x_lower[i];
        upper[i] = y_upper[i] + s*x_upper[i];
    }

    for (Size i=0; i < size; ++i) {
        const Real s = aptr[i*ainc];
        diag[i]  = y_diag[i]  + s*x_diag[i] + bptr[i*binc];
        lower[i] = y_lower[i] + s*x_lower[i];
        upper[i] = y_upper[i] + s*x_upper[i];
    }

for (Size i=0; i < size; ++i) {
    retVal.lower_[i]= lower_[i] + m.lower_[i];
    retVal.diag_[i] = diag_[i]  + m.diag_[i];
    retVal.upper_[i]= upper_[i] + m.upper_[i];
}

for (Size i=0; i < size; ++i) {
    const Real s = u[i];
    retVal.lower_[i]= lower_[i]*s;
    retVal.diag_[i] = diag_[i]*s;
    retVal.upper_[i]= upper_[i]*s;
}

for (Size i=0; i < size; ++i) {
    retVal.lower_[i]= lower_[i];
    retVal.upper_[i]= upper_[i];
    retVal.diag_[i] = diag_[i]+u[i];
}

for (Size i=0; i < index->size(); ++i) {
    retVal[i] = r[i0ptr[i]]*lptr[i]+r[i]*dptr[i]+r[i2ptr[i]]*uptr[i];
}

for (Size i=0; i < n; ++i) {
    retVal(i, i0_[i]) += lower_[i];
    retVal(i, i     ) += diag_[i];
    retVal(i, i2_[i]) += upper_[i];
}

for (Size j=1; j<=layout->size()-1; j++){
    const Size ri = reverseIndex_[j];
    tmp[j] = a*uptr[rim1]*bet;

    bet=b+a*(dptr[ri]-tmp[j]*lptr[ri]);
    QL_ENSURE(bet != 0.0, "division by zero");
    bet=1.0/bet;

    retVal[ri] = (r[ri]-a*lptr[ri]*retVal[rim1])*bet;
    rim1 = ri;
}

for (Size j=layout->size()-2; j>0; --j)
    retVal[reverseIndex_[j]] -= tmp[j+1]*retVal[reverseIndex_[j+1]];

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/methods/finitedifferences/solvers/fdm3dimsolver.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i < z_.size(); ++i) {
    std::copy(rhs.begin()+i    *y_.size()*x_.size(),
              rhs.begin()+(i+1)*y_.size()*x_.size(),
              resultValues_[i].begin());

    interpolation_[i] = boost::shared_ptr<BicubicSpline> (
        new BicubicSpline(x_.begin(), x_.end(),
                          y_.begin(), y_.end(),
                          resultValues_[i]));
}

for (Size i=0; i < z_.size(); ++i) {
    zArray[i] = interpolation_[i]->operator()(x, y);
}

for (Size i=0; i < z_.size(); ++i) {
    std::copy(rhs.begin()+i    *y_.size()*x_.size(),
              rhs.begin()+(i+1)*y_.size()*x_.size(),
              thetaValues[i].begin());
}

for (Size i=0; i < z_.size(); ++i) {
    zArray[i] = BicubicSpline(x_.begin(),x_.end(),
                              y_.begin(),y_.end(), thetaValues[i])(x,y);
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/methods/finitedifferences/utilities/fdmquantohelper.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i < retVal.size(); ++i) {
    retVal[i]
        = rDomestic - rForeign + equityVol[i]*fxVol*equityFxCorrelation_;
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/methods/finitedifferences/utilities/fdminnervaluecalculator.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i < x.size(); ++i) {
    x[i] = std::exp(mesher_->location(iter, i));
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/methods/finitedifferences/utilities/fdmdividendhandler.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
 for (Size i = 0; i < x_.size(); ++i) {
     x_[i] = std::exp(tmp[i*spacing]);
 }

        for (Size k=0; k<x_.size(); ++k) {
            a[k] = interp(std::max(x_[0], x_[k]-dividend), true);
        }

        for (Size i=0; i<mesher_->layout()->dim().size(); ++i) {
            if (i!=equityDirection_) {
                Size ySpacing = mesher_->layout()->spacing()[i];
                for (Size j=0; j<mesher_->layout()->dim()[i]; ++j) {
                    for (Size k=0; k<x_.size(); ++k) {
                        Size index = j*ySpacing + k*xSpacing;
                        tmp[k] = aCopy[index];
                    }
                    LinearInterpolation interp(x_.begin(), x_.end(),
                                               tmp.begin());
                    for (Size k=0; k<x_.size(); ++k) {
                        Size index = j*ySpacing + k*xSpacing;
                        a[index] = interp(
                                std::max(x_[0], x_[k]-dividend), true);
                    }
                }
            }
        }

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/methods/finitedifferences/utilities/fdmmesherintegral.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i < x.size(); ++i) {
    std::copy(f.begin() + i    *subSize,
              f.begin() + (i+1)*subSize, fSub.begin());

    g[i] = subMesherIntegral.integrate(fSub);
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/methods/finitedifferences/schemes/craigsneydscheme.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i < map_->size(); ++i) {
    Array rhs = y - theta_*dt_*map_->apply_direction(i, a);
    y = map_->solve_splitting(i, rhs, -theta_*dt_);
}

for (Size i=0; i < map_->size(); ++i) {
    Array rhs = yt - theta_*dt_*map_->apply_direction(i, a);
    yt = map_->solve_splitting(i, rhs, -theta_*dt_);
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/methods/finitedifferences/schemes/hundsdorferscheme.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i < map_->size(); ++i) {
    Array rhs = y - theta_*dt_*map_->apply_direction(i, a);
    y = map_->solve_splitting(i, rhs, -theta_*dt_);
}

for (Size i=0; i < map_->size(); ++i) {
    Array rhs = yt - theta_*dt_*map_->apply_direction(i, y);
    yt = map_->solve_splitting(i, rhs, -theta_*dt_);
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/methods/finitedifferences/schemes/modifiedcraigsneydscheme.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i < map_->size(); ++i) {
    Array rhs = y - theta_*dt_*map_->apply_direction(i, a);
    y = map_->solve_splitting(i, rhs, -theta_*dt_);
}

for (Size i=0; i < map_->size(); ++i) {
    Array rhs = yt - theta_*dt_*map_->apply_direction(i, a);
    yt = map_->solve_splitting(i, rhs, -theta_*dt_);
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/methods/finitedifferences/schemes/douglasscheme.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i < map_->size(); ++i) {
    Array rhs = y - theta_*dt_*map_->apply_direction(i, a);
    y = map_->solve_splitting(i, rhs, -theta_*dt_);
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/methods/finitedifferences/stepconditions/fdmbermudanstepcondition.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        for (Size i=0; i < dims; ++i)
            locations[i] = mesher_->location(iter, i);

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/methods/finitedifferences/stepconditions/fdmarithmeticaveragecondition.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i = 0; i < x_.size(); ++i) {
    x_[i] = std::exp(tmp[i*xSpacing]);
}

for (Size i = 0; i < a_.size(); ++i) {
    a_[i] = std::exp(tmp[i*aSpacing]);
}

    for (Size i=0; i<x_.size(); ++i) {
        for (Size j=0; j<a_.size(); ++j) {
            Size index = i*xSpacing + j*aSpacing;
            tmp[j] = aCopy[index];
        }
        MonotonicCubicNaturalSpline interp(a_.begin(), a_.end(),
                                   tmp.begin());
        for (Size j=0; j<a_.size(); ++j) {
            Size index = i*xSpacing + j*aSpacing;
            a[index] = interp((iT-nTimes)/(double)(iT)*a_[j] +
                              nTimes/(double)(iT)*x_[i], true);
        }
    }

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/processes/jointstochasticprocess.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (const_iterator iter=l_.begin(); iter != l_.end(); ++iter) {
    registerWith(*iter);
}

for (const_iterator iter = l_.begin(); iter != l_.end(); ++iter) {
    vsize_.push_back(size_);
    size_ += (*iter)->size();

    vfactors_.push_back(modelFactors_);
    modelFactors_ += (*iter)->factors();
}

for (const_iterator iter = l_.begin(); iter != l_.end(); ++iter) {
    const Array& pInitValues = (*iter)->initialValues();

    std::copy(pInitValues.begin(), pInitValues.end(),
              retVal.begin()+vsize_[iter - l_.begin()]);
}

for (Size i=0; i < l_.size(); ++i) {

    const Array& pDrift = l_[i]->drift(t, slice(x,i));

    std::copy(pDrift.begin(), pDrift.end(),
              retVal.begin()+vsize_[i]);
}

for (Size i=0; i < l_.size(); ++i) {

    const Array& pExpectation = l_[i]->expectation(t0, slice(x0,i), dt);

    std::copy(pExpectation.begin(), pExpectation.end(),
              retVal.begin()+ vsize_[i]);
}

for (Size j=0; j < l_.size(); ++j) {

    const Size vs = vsize_[j];
    const Matrix& pCov = l_[j]->covariance(t0, slice(x0,j), dt);

    for (Size i=0; i < pCov.rows(); ++i) {
        std::copy(pCov.row_begin(i), pCov.row_end(i),
                  retVal.row_begin(vs+i) + vs);
    }
}

for (Size i=0; i < size(); ++i) {
    for (Size j=0; j < size(); ++j) {
        crossModelCovar[i][j] *= volatility[i]*volatility[j];
    }
}

for (Size i=0; i < l_.size(); ++i) {
    const Array& pApply = l_[i]->apply(slice(x0,i), slice(dx,i));

    std::copy(pApply.begin(), pApply.end(),
              retVal.begin()+vsize_[i]);
}

    for (Size i=0; i < cov.rows(); ++i) {
        for (Size j=i; j < cov.columns(); ++j) {
            const Real div = sqrtDiag[i]*sqrtDiag[j];

            cov[i][j] = cov[j][i] = ( div > 0) ? cov[i][j]/div : 0.0;
        }
    }

    for (Size j = 0; j < l_.size(); ++j) {
        const Size vs = vsize_   [j];
        const Size vf = vfactors_[j];

        Matrix stdDev = l_[j]->stdDeviation(t0, slice(x0,j), dt);

        for (Size i=0; i < stdDev.rows(); ++i) {
            const Volatility vol = std::sqrt(
                std::inner_product(stdDev.row_begin(i),
                                   stdDev.row_end(i),
                                   stdDev.row_begin(i), 0.0));
            if (vol > 0.0) {
                std::transform(stdDev.row_begin(i), stdDev.row_end(i),
                               stdDev.row_begin(i),
                               std::bind2nd(std::divides<Real>(),
                                            vol));
            }
            else {
                // keep the svd happy
                std::fill(stdDev.row_begin(i), stdDev.row_end(i),
                          100*i*QL_EPSILON);
            }
        }

        SVD svd(stdDev);
        const Array& s = svd.singularValues();
        Matrix w(s.size(), s.size(), 0.0);
        for (Size i=0; i < s.size(); ++i) {
            if (std::fabs(s[i]) > std::sqrt(QL_EPSILON)) {
                w[i][i] = 1.0/s[i];
            }
        }

        const Matrix inv = svd.U() * w * transpose(svd.V());

        for (Size i=0; i < stdDev.rows(); ++i) {
            std::copy(inv.row_begin(i), inv.row_end(i),
                      diff.row_begin(i+vs)+vf);
        }
    }

        for (Size i=0; i < cov.rows(); ++i) {
            std::copy(rs.row_begin(i), rs.row_end(i),
                      tmp.row_begin(i));
        }

for (const_iterator iter = l_.begin(); iter != l_.end(); ++iter) {
    const Size i = iter - l_.begin();

    Array dz((*iter)->factors());
    std::copy(dv.begin()+vfactors_[i],
              dv.begin()+vfactors_[i] + (*iter)->factors(),
              dz.begin());
    Array x((*iter)->size());
    std::copy(x0.begin()+vsize_[i],
              x0.begin()+vsize_[i] + (*iter)->size(),
              x.begin());
    const Array r = (*iter)->evolve(t0, x, dt, dz);
    std::copy(r.begin(), r.end(), retVal.begin()+vsize_[i]);
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/processes/stochasticprocessarray.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i<processes_.size(); i++)
    registerWith(processes_[i]);

for (Size i=0; i<size(); ++i)
    tmp[i] = processes_[i]->x0();

for (Size i=0; i<size(); ++i)
    tmp[i] = processes_[i]->drift(t, x[i]);

for (Size i=0; i<size(); ++i) {
    Real sigma = processes_[i]->diffusion(t, x[i]);
    std::transform(tmp.row_begin(i), tmp.row_end(i),
                   tmp.row_begin(i),
                   std::bind2nd(std::multiplies<Real>(),sigma));
}

for (Size i=0; i<size(); ++i)
    tmp[i] = processes_[i]->expectation(t0, x0[i], dt);

for (Size i=0; i<size(); ++i) {
    Real sigma = processes_[i]->stdDeviation(t0, x0[i], dt);
    std::transform(tmp.row_begin(i), tmp.row_end(i),
                   tmp.row_begin(i),
                   std::bind2nd(std::multiplies<Real>(),sigma));
}

for (Size i=0; i<size(); ++i)
    tmp[i] = processes_[i]->evolve(t0, x0[i], dt, dz[i]);

for (Size i=0; i<size(); ++i)
    tmp[i] = processes_[i]->apply(x0[i],dx[i]);

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/processes/mfstateprocess.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (int i = 0; i < ((int)times.size()) - 1; i++)
    QL_REQUIRE(times[i] < times[i + 1], "times must be increasing ("
                                            << times[i] << "@" << i
                                            << " , " << times[i + 1]
                                            << "@" << i + 1 << ")");

for (Size i = 0; i < vols.size(); i++)
    QL_REQUIRE(vols[i] >= 0.0, "volatilities must be non negative ("
                                   << vols[i] << "@" << i << ")");

for (Size k = i; k < j; k++) {
    if (reversionZero_)
        v += vols_[k] * vols_[k] *
             (times_[k] - std::max(k > 0 ? times_[k - 1] : 0.0, t));
    else
        v += 1.0 / (2.0 * reversion_) * vols_[k] * vols_[k] *
             (std::exp(2.0 * reversion_ * times_[k]) -
              std::exp(2.0 * reversion_ *
                       std::max(k > 0 ? times_[k - 1] : 0.0, t)));
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/processes/hestonprocess.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    for (Integer i=m-1; i >= 0; --i) {
        n = (n+nominator[i])*x;
        d = (d+denominator[i])*x;
    }

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/processes/gsrprocess.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (int i = 0; i < ((int)times.size()) - 1; i++)
    QL_REQUIRE(times[i] < times[i + 1], "times must be increasing ("
                                            << times[i] << "@" << i
                                            << " , " << times[i + 1]
                                            << "@" << i + 1 << ")");

for (int i = 0; i < (int)reversions_.size(); i++)
    // if (close(reversions_[i], 0.0))
    if (std::fabs(reversions_[i]) < 1E-4)
        revZero_[i] = true;

for (int i = lowerIndex(w); i <= upperIndex(t) - 1; i++) {
    res2 *= exp(-rev(i) * (cappedTime(i + 1, t) - flooredTime(i, w)));
}

for (int k = lowerIndex(w); k <= upperIndex(t) - 1; k++) {
    // l<k
    for (int l = 0; l <= k - 1; l++) {
        Real res2 = 1.0;
        // alpha_l
        res2 *= revZero(l) ? vol(l) * vol(l) * (time2(l + 1) - time2(l))
                           : vol(l) * vol(l) / (2.0 * rev(l)) *
                                 (1.0 - exp(-2.0 * rev(l) *
                                            (time2(l + 1) - time2(l))));
        // zeta_i (i>k)
        for (int i = k + 1; i <= upperIndex(t) - 1; i++)
            res2 *= exp(-rev(i) * (cappedTime(i + 1, t) - time2(i)));
        // beta_j (j<k)
        for (int j = l + 1; j <= k - 1; j++)
            res2 *= exp(-2.0 * rev(j) * (time2(j + 1) - time2(j)));
        // zeta_k beta_k
        res2 *=
            revZero(k)
                ? 2.0 * time2(k) - flooredTime(k, w) -
                      cappedTime(k + 1, t) -
                      2.0 * (time2(k) - cappedTime(k + 1, t))
                : (exp(rev(k) * (2.0 * time2(k) - flooredTime(k, w) -
                                 cappedTime(k + 1, t))) -
                   exp(2.0 * rev(k) *
                       (time2(k) - cappedTime(k + 1, t)))) /
                      rev(k);
        // add to sum
        res += res2;
    }
    // l=k
    Real res2 = 1.0;
    // alpha_k zeta_k
    res2 *=
        revZero(k)
            ? vol(k) * vol(k) / 4.0 *
                  (4.0 * pow(cappedTime(k + 1, t) - time2(k), 2.0) -
                   (pow(flooredTime(k, w) - 2.0 * time2(k) +
                            cappedTime(k + 1, t),
                        2.0) +
                    pow(cappedTime(k + 1, t) - flooredTime(k, w), 2.0)))
            : vol(k) * vol(k) / (2.0 * rev(k) * rev(k)) *
                  (exp(-2.0 * rev(k) *
                       (cappedTime(k + 1, t) - time2(k))) +
                   1.0 -
                   (exp(-rev(k) * (flooredTime(k, w) - 2.0 * time2(k) +
                                   cappedTime(k + 1, t))) +
                    exp(-rev(k) *
                        (cappedTime(k + 1, t) - flooredTime(k, w)))));
    // zeta_i (i>k)
    for (int i = k + 1; i <= upperIndex(t) - 1; i++)
        res2 *= exp(-rev(i) * (cappedTime(i + 1, t) - time2(i)));
    // no beta_j in this case ...
    res += res2;
}

for (int k = lowerIndex(w); k <= upperIndex(t) - 1; k++) {
    Real res2 = 0.0;
    // l>k
    for (int l = k + 1; l <= upperIndex(T) - 1; l++) {
        Real res3 = 1.0;
        // eta_l
        res3 *= revZero(l)
                    ? cappedTime(l + 1, T) - time2(l)
                    : (1.0 - exp(-rev(l) *
                                 (cappedTime(l + 1, T) - time2(l)))) /
                          rev(l);
        // zeta_i (i>k)
        for (int i = k + 1; i <= upperIndex(t) - 1; i++)
            res3 *= exp(-rev(i) * (cappedTime(i + 1, t) - time2(i)));
        // gamma_j (j>k)
        for (int j = k + 1; j <= l - 1; j++)
            res3 *= exp(-rev(j) * (time2(j + 1) - time2(j)));
        // zeta_k gamma_k
        res3 *=
            revZero(k)
                ? (cappedTime(k + 1, t) - time2(k + 1) -
                   (2.0 * flooredTime(k, w) - cappedTime(k + 1, t) -
                    time2(k + 1))) /
                      2.0
                : (exp(rev(k) * (cappedTime(k + 1, t) - time2(k + 1))) -
                   exp(rev(k) *
                       (2.0 * flooredTime(k, w) - cappedTime(k + 1, t) -
                        time2(k + 1)))) /
                      (2.0 * rev(k));
        // add to sum
        res2 += res3;
    }
    // l=k
    Real res3 = 1.0;
    // eta_k zeta_k
    res3 *=
        revZero(k)
            ? (-pow(cappedTime(k + 1, t) - cappedTime(k + 1, T), 2.0) -
               2.0 *
                   pow(cappedTime(k + 1, t) - flooredTime(k, w), 2.0) +
               pow(2.0 * flooredTime(k, w) - cappedTime(k + 1, T) -
                       cappedTime(k + 1, t),
                   2.0)) /
                  4.0
            : (2.0 - exp(rev(k) * (cappedTime(k + 1, t) -
                                   cappedTime(k + 1, T))) -
               (2.0 * exp(-rev(k) *
                          (cappedTime(k + 1, t) - flooredTime(k, w))) -
                exp(rev(k) *
                    (2.0 * flooredTime(k, w) - cappedTime(k + 1, T) -
                     cappedTime(k + 1, t))))) /
                  (2.0 * rev(k) * rev(k));
    // zeta_i (i>k)
    for (int i = k + 1; i <= upperIndex(t) - 1; i++)
        res3 *= exp(-rev(i) * (cappedTime(i + 1, t) - time2(i)));
    // no gamma_j in this case ...
    res2 += res3;
    // add to main accumulator
    res += -vol(k) * vol(k) * res2;
}

for (int k = lowerIndex(w); k <= upperIndex(t) - 1; k++) {
    Real res2 = vol(k) * vol(k);
    // zeta_k^2
    res2 *= revZero(k)
                ? -(flooredTime(k, w) - cappedTime(k + 1, t))
                : (1.0 - exp(2.0 * rev(k) * (flooredTime(k, w) -
                                             cappedTime(k + 1, t)))) /
                      (2.0 * rev(k));
    // zeta_i (i>k)
    for (int i = k + 1; i <= upperIndex(t) - 1; i++) {
        res2 *= exp(-2.0 * rev(i) * (cappedTime(i + 1, t) - time2(i)));
    }
    res += res2;
}

for (int i = 0; i <= upperIndex(t) - 1; i++) {
    Real res2 = 1.0;
    for (int j = i + 1; j <= upperIndex(t) - 1; j++) {
        res2 *= exp(-2.0 * rev(j) * (cappedTime(j + 1, t) - time2(j)));
    }
    res2 *= revZero(i)
                ? vol(i) * vol(i) * (cappedTime(i + 1, t) - time2(i))
                : (vol(i) * vol(i) / (2.0 * rev(i)) *
                   (1.0 - exp(-2.0 * rev(i) *
                              (cappedTime(i + 1, t) - time2(i)))));
    res += res2;
}

for (int i = lowerIndex(t); i <= upperIndex(w) - 1; i++) {
    Real res2 = 1.0;
    for (int j = lowerIndex(t); j <= i - 1; j++) {
        res2 *= exp(-rev(j) * (time2(j + 1) - flooredTime(j, t)));
    }
    res2 *= revZero(i) ? cappedTime(i + 1, w) - flooredTime(i, t)
                       : (1.0 - exp(-rev(i) * (cappedTime(i + 1, w) -
                                               flooredTime(i, t)))) /
                             rev(i);
    res += res2;
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/legacy/libormarketmodels/lfmcovarparam.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i<size_; ++i) {
    for (Size j=0; j<=i;++j) {
        Var_Helper helper(this, i, j);
        GaussKronrodAdaptive integrator(1e-10, 10000);
        for (Size k=0; k < 64; ++k) {
            tmp[i][j]+=integrator(helper, k*t/64.,(k+1)*t/64.);
        }
        tmp[j][i]=tmp[i][j];
    }
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/legacy/libormarketmodels/lmlinexpvolmodel.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i<size_; ++i) {
    const Time T = fixingTimes_[i];
    if (T>t) {
        tmp[i] = (a*(T-t)+d)*std::exp(-b*(T-t)) + c;
    }
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/legacy/libormarketmodels/lmextlinexpvolmodel.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i <size_; ++i) {
    arguments_[i+4] = ConstantParameter(1.0, PositiveConstraint());
}

for (Size i=0; i<size_; ++i) {
    tmp[i]*=arguments_[i+4](0.0);
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/legacy/libormarketmodels/lfmprocess.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i = 0; i < size_; ++i) {
    const boost::shared_ptr<IborCoupon> coupon =
       boost::dynamic_pointer_cast<IborCoupon>(flows[i]);

    QL_REQUIRE(coupon->date() == coupon->accrualEndDate(),
               "irregular coupon types are not suppported");

    initialValues_[i] = coupon->rate();
    accrualPeriod_[i] = coupon->accrualPeriod();

    fixingDates_[i] = coupon->fixingDate();
    fixingTimes_[i] =
        dayCounter.yearFraction(startDate, coupon->fixingDate());
    accrualStartTimes_[i] =
        dayCounter.yearFraction(settlement,coupon->accrualStartDate());
    accrualEndTimes_[i]   =
        dayCounter.yearFraction(settlement,coupon->accrualEndDate());
}

for (Size k=m; k<size_; ++k) {
    m1[k] = accrualPeriod_[k]*x[k]/(1+accrualPeriod_[k]*x[k]);
    f[k]  = std::inner_product(m1.begin()+m, m1.begin()+k+1,
                               covariance.column_begin(k)+m,0.0)
            - 0.5*covariance[k][k];
}

for (Size k=0; k<size_; ++k) {
    tmp[k] = x0[k] * std::exp(dx[k]);
}

for (Size k=m; k<size_; ++k) {
    const Real y = accrualPeriod_[k]*x0[k];
    m1[k] = y/(1+y);
    const Real d = (
        std::inner_product(m1.begin()+m, m1.begin()+k+1,
                           covariance.column_begin(k)+m,0.0)
        -0.5*covariance[k][k]) * dt;

    const Real r = std::inner_product(
        diff.row_begin(k), diff.row_end(k), dw.begin(), 0.0)*sdt;

    const Real x = y*std::exp(d + r);
    m2[k] = x/(1+x);
    f[k] = x0[k] * std::exp(0.5*(d+
         (std::inner_product(m2.begin()+m, m2.begin()+k+1,
                             covariance.column_begin(k)+m,0.0)
          -0.5*covariance[k][k])*dt)+ r);
}

for (Size i = 1; i < size_; ++i) {
    discountFactors[i] =
        discountFactors[i-1]/(1.0 + rates[i]*accrualPeriod_[i]);
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/legacy/libormarketmodels/lfmcovarproxy.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i<size_; ++i) {
    std::transform(pca.row_begin(i), pca.row_end(i),
                   pca.row_begin(i),
                   std::bind2nd(std::multiplies<Real>(), vol[i]));
}

for (Size i=0; i<size_; ++i) {
    for (Size j=0; j<size_; ++j) {
        tmp[i][j] = volatility[i]*correlation[i][j]*volatility[j];
    }
}

for (Size k=0; k<64; ++k) {
    tmp+=integrator(helper, k*t/64., (k+1)*t/64.);
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/legacy/libormarketmodels/lmfixedvolmodel.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i = 1; i < startTimes_.size(); i++) {
    QL_REQUIRE(startTimes_[i] > startTimes_[i-1],
               "invalid time (" << startTimes_[i] << ", vs "
               << startTimes_[i-1] << ")");
}

for (Size i=ti; i<size_; ++i) {
    tmp[i] = volatilities_[i-ti];
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/legacy/libormarketmodels/lmlinexpcorrmodel.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i<size_; ++i) {
    for (Size j=i; j<size_; ++j) {
        corrMatrix_[i][j] = corrMatrix_[j][i]
            = rho + (1-rho)*std::exp(-beta*std::fabs(Real(i)-Real(j)));
    }
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/legacy/libormarketmodels/liborforwardmodel.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
 for (Size i=0; i < process->size(); ++i) {
     accrualPeriod_[i] =  process->accrualEndTimes()[i]
                        - process->accrualStartTimes()[i];
     f_[i] = 1.0/(1.0+accrualPeriod_[i]*process_->initialValues()[i]);
 }

for (Size k=alpha+1; k<=beta; ++k) {
    Real b=accrualPeriod_[k];
    for (Size j=alpha+1; j<=k; ++j) {
        b*=f_[j];
    }
    s+=b;
}

for (Size i=alpha+1; i<=beta; ++i) {
    Real a=accrualPeriod_[i];
    for (Size j=alpha+1; j<=i; ++j) {
        a*=f_[j];
    }

    omega[i] = a/s;
}

for (Size i=alpha+1; i <=beta; ++i) {
    fwdRate+=w[i]*f[i];
}

for (Size i=0; i < size; ++i) {
    lengths[i] = (i+1)*index->tenor();
}

for (Size k=0; k < size; ++k) {
    const Size alpha  =k;
    const Time t_alpha=process_->fixingTimes()[alpha+1];

    Matrix var(size, size);
    for (Size i=alpha+1; i <= k+size; ++i) {
        for (Size j=i; j <= k+size; ++j) {
            var[i-alpha-1][j-alpha-1] = var[j-alpha-1][i-alpha-1] =
                covarProxy_->integratedCovariance(i, j, t_alpha);
        }
    }

    for (Size l=1; l <= size; ++l) {
        const Size beta =l + k;
        const Array w = w_0(alpha, beta);

        Real sum=0.0;
        for (Size i=alpha+1; i <= beta; ++i) {
            for (Size j=alpha+1; j <= beta; ++j) {
                sum+=w[i]*w[j]*f[i]*f[j]*var[i-alpha-1][j-alpha-1];
            }
        }
        volatilities[k][l-1] =
            std::sqrt(sum/t_alpha)/S_0(alpha, beta);
    }
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/legacy/libormarketmodels/lmexpcorrmodel.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i<size_; ++i) {
    for (Size j=i; j<size_; ++j) {
        corrMatrix_[i][j] = corrMatrix_[j][i]
            = std::exp(-rho*std::fabs(Real(i)-Real(j)));
    }
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/legacy/libormarketmodels/lfmhullwhiteparam.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    for (Size i=0; i < size_-1; ++i) {
        std::transform(
            tmpSqrtCorr[i], tmpSqrtCorr[i]+factors_, sqrtCorr[i],
            std::bind2nd(std::divides<Real>(),
                         std::sqrt(std::inner_product(
                             tmpSqrtCorr[i],tmpSqrtCorr[i]+factors_,
                             tmpSqrtCorr[i], 0.0))));
    }

for (Size i = 1; i < size_; ++i) {
    Real cumVar = 0.0;
    for (Size j = 1; j < i; ++j) {
        cumVar +=  lambda[i-j-1] * lambda[i-j-1]
                 * (fixingTimes[j+1] - fixingTimes[j]);
    }

    const Volatility vol =  capletVol->volatility(fixingDates[i], 0.0);
    const Volatility var = vol * vol
        * capletVol->dayCounter().yearFraction(fixingDates[0],
                                               fixingDates[i]);

    lambda.push_back(std::sqrt(  (var - cumVar)
                               / (fixingTimes[1] - fixingTimes[0])) );

    for (Size q=0; q<factors_; ++q) {
        diffusion_[i-1][q] = sqrtCorr[i-1][q] * lambda.back();
    }
}

for (Size k=m; k<size_; ++k) {
    for (Size q=0; q<factors_; ++q) {
        tmp[k][q] = diffusion_[k-m][q];
    }
}

for (Size k=m; k<size_; ++k) {
    for (Size i=m; i<size_; ++i) {
        tmp[k][i] = covariance_[k-m][i-m];
    }
}

for (Size i=0; i<last; ++i) {
    const Time dt = ((i+1<last)? fixingTimes_[i+1] : t )
        - fixingTimes_[i];

    for (Size k=i; k<size_-1; ++k) {
        for (Size l=i; l<size_-1; ++l) {
            tmp[k+1][l+1]+= covariance_[k-i][l-i]*dt;
        }
    }
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/Examples/CallableBonds/CallableBonds.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i< numberOfCallDates; i++) {
    Calendar nullCalendar = NullCalendar();

    Callability::Price myPrice(callPrice,
                               Callability::Price::Clean);
    callSchedule.push_back(
        boost::shared_ptr<Callability>(
            new Callability(myPrice,
                            Callability::Call,
                            callDate )));
    callDate = nullCalendar.advance(callDate, 3, Months);
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/Examples/DiscreteHedging/DiscreteHedging.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size step = 0; step < n-1; step++){

// time flows
t += dt;

// accruing on the money account
money_account *= std::exp( r_*dt );

// stock growth:
stock = path[step+1];

// recalculate option value at the current stock value,
// and the current time to maturity
rDiscount = std::exp(-r_*(maturity_-t));
qDiscount = std::exp(-stockDividendYield*(maturity_-t));
forward = stock*qDiscount/rDiscount;
stdDev = std::sqrt(sigma_*sigma_*(maturity_-t));
BlackCalculator black(payoff,forward,stdDev,rDiscount);

// recalculate delta
delta = black.delta(stock);

// re-hedging
money_account -= (delta - stockAmount)*stock;
stockAmount = delta;
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/Examples/Replication/Replication.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (i=12; i>=1; i--) {
    // First, we instantiate the option...
    Date innerMaturity = today + i*Months;
    boost::shared_ptr<Exercise> innerExercise(
                                 new EuropeanExercise(innerMaturity));
    boost::shared_ptr<StrikedTypePayoff> innerPayoff(
                        new PlainVanillaPayoff(Option::Put, barrier));
    boost::shared_ptr<Instrument> putn(
                      new EuropeanOption(innerPayoff, innerExercise));
    putn->setPricingEngine(europeanEngine);
    // ...second, we evaluate the current portfolio and the
    // latest put at (B,t)...
    Date killDate = today + (i-1)*Months;
    Settings::instance().evaluationDate() = killDate;
    underlying->setValue(barrier);
    Real portfolioValue = portfolio1.NPV();
    Real putValue = putn->NPV();
    // ...finally, we estimate the notional that kills the
    // portfolio value at that point...
    Real notional = portfolioValue/putValue;
    // ...and we subtract from the portfolio a put with such
    // notional.
    portfolio1.subtract(putn, notional);
}

for (i=52; i>=2; i-=2) {
    // Same as above.
    Date innerMaturity = today + i*Weeks;
    boost::shared_ptr<Exercise> innerExercise(
                                 new EuropeanExercise(innerMaturity));
    boost::shared_ptr<StrikedTypePayoff> innerPayoff(
                        new PlainVanillaPayoff(Option::Put, barrier));
    boost::shared_ptr<Instrument> putn(
                      new EuropeanOption(innerPayoff, innerExercise));
    putn->setPricingEngine(europeanEngine);
    Date killDate = today + (i-2)*Weeks;
    Settings::instance().evaluationDate() = killDate;
    underlying->setValue(barrier);
    Real portfolioValue = portfolio2.NPV();
    Real putValue = putn->NPV();
    Real notional = portfolioValue/putValue;
    portfolio2.subtract(putn, notional);
}

for (i=52; i>=1; i--) {
    // Same as above.
    Date innerMaturity = today + i*Weeks;
    boost::shared_ptr<Exercise> innerExercise(
                                 new EuropeanExercise(innerMaturity));
    boost::shared_ptr<StrikedTypePayoff> innerPayoff(
                        new PlainVanillaPayoff(Option::Put, barrier));
    boost::shared_ptr<Instrument> putn(
                      new EuropeanOption(innerPayoff, innerExercise));
    putn->setPricingEngine(europeanEngine);
    Date killDate = today + (i-1)*Weeks;
    Settings::instance().evaluationDate() = killDate;
    underlying->setValue(barrier);
    Real portfolioValue = portfolio3.NPV();
    Real putValue = putn->NPV();
    Real notional = portfolioValue/putValue;
    portfolio3.subtract(putn, notional);
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/Examples/MarketModels/MarketModels.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i< numberRates-1; i=i+1)
{
    VolatilityBumpInstrumentJacobian::Cap nextCap;
    nextCap.startIndex_ = i;
    nextCap.endIndex_ = i+1;
    nextCap.strike_ = capStrike;
    caps.push_back(nextCap);
}

for (Size i=0; i < numberRates; ++i)
{
swaptions[i].startIndex_ = i;
swaptions[i].endIndex_ = numberRates;

}

for (Size i=0; i < rateTimes.size(); ++i)
rateTimes[i] = firstTime + i*accrual;

for (Size i=0; i < paymentTimes.size(); ++i)
paymentTimes[i] = firstTime + (i+1)*accrual;

for (Size i=0; i < means.size(); ++i)
std::cout << means[i] << "\n";

for (Size i=0; i < 4; ++i)
{

bool allowFactorwiseBumping = i % 2 > 0 ;

bool doCaps = i / 2 > 0 ;





LogNormalFwdRateEuler evolverEuler(marketModel,
    generatorFactory,
    numeraires
    ) ;

MarketModelPathwiseSwap receiverPathwiseSwap(  rateTimes,
    accruals,
    strikes,
    receive);
Clone<MarketModelPathwiseMultiProduct> receiverPathwiseSwapPtr(receiverPathwiseSwap.clone());

//  callable receiver swap
CallSpecifiedPathwiseMultiProduct callableProductPathwise(receiverPathwiseSwapPtr,
    exerciseStrategy);

Clone<MarketModelPathwiseMultiProduct> callableProductPathwisePtr(callableProductPathwise.clone());


std::vector<std::vector<Matrix> > theBumps(theVegaBumps(allowFactorwiseBumping,
    marketModel,
    doCaps));

PathwiseVegasOuterAccountingEngine
    accountingEngineVegas(boost::shared_ptr<LogNormalFwdRateEuler>(new LogNormalFwdRateEuler(evolverEuler)),
    callableProductPathwisePtr,
    marketModel,
    theBumps,
    initialNumeraireValue);

std::vector<Real> values,errors;

accountingEngineVegas.multiplePathValues(values,errors,pathsToDoVegas);


std::cout << "vega output \n";
std::cout << " factorwise bumping " << allowFactorwiseBumping << "\n";
std::cout << " doCaps " << doCaps << "\n";



Size r=0;

std::cout << " price estimate, " << values[r++] << "\n";

for (Size i=0; i < numberRates; ++i, ++r)
    std::cout << " Delta, " << i << ", " << values[r] << ", " << errors[r] << "\n";

Real totalVega = 0.0;

for (; r < values.size(); ++r)
{
    std::cout << " vega, " << r - 1 -  numberRates<< ", " << values[r] << " ," << errors[r] << "\n";
    totalVega +=  values[r];
}

std::cout << " total Vega, " << totalVega << "\n";
}

for (Size s=0; s < isExerciseTime.size(); ++s)
{
    if (isExerciseTime[s])
    {
        MTBrownianGeneratorFactory iFactory(seed+s);
        boost::shared_ptr<MarketModelEvolver> e =boost::shared_ptr<MarketModelEvolver> (static_cast<MarketModelEvolver*>(new   LogNormalFwdRatePc(boost::shared_ptr<MarketModel>(new FlatVol(calibration)),
            uFactory,
            numeraires ,  // numeraires for each step
            s)));

        innerEvolvers.push_back(e);
    }
}

for (Size i=0; i < rateTimes.size(); ++i)
rateTimes[i] = firstTime + i*accrual;

for (Size i=0; i < paymentTimes.size(); ++i)
paymentTimes[i] = firstTime + (i+1)*accrual;

for (Size i=0; i < means.size(); ++i)
std::cout << means[i] << "\n";

for (Size i=0; i < 4; ++i)
{

bool allowFactorwiseBumping = i % 2 > 0 ;

bool doCaps = i / 2 > 0 ;


LogNormalFwdRateEuler evolverEuler(marketModel,
    generatorFactory,
    numeraires
    ) ;

MarketModelPathwiseInverseFloater pathwiseInverseFloater(
                                                 rateTimes,
                                                 accruals,
                                                 accruals,
                                                 fixedStrikes,
                                                 fixedMultipliers,
                                                 floatingSpreads,
                                                 paymentTimes,
                                                 payer);

Clone<MarketModelPathwiseMultiProduct> pathwiseInverseFloaterPtr(pathwiseInverseFloater.clone());

//  callable inverse floater
CallSpecifiedPathwiseMultiProduct callableProductPathwise(pathwiseInverseFloaterPtr,
                                                                                                                                       exerciseStrategy);

Clone<MarketModelPathwiseMultiProduct> callableProductPathwisePtr(callableProductPathwise.clone());


std::vector<std::vector<Matrix> > theBumps(theVegaBumps(allowFactorwiseBumping,
    marketModel,
    doCaps));

PathwiseVegasOuterAccountingEngine
    accountingEngineVegas(boost::shared_ptr<LogNormalFwdRateEuler>(new LogNormalFwdRateEuler(evolverEuler)),
//         pathwiseInverseFloaterPtr,
    callableProductPathwisePtr,
    marketModel,
    theBumps,
    initialNumeraireValue);

std::vector<Real> values,errors;

accountingEngineVegas.multiplePathValues(values,errors,pathsToDoVegas);


std::cout << "vega output \n";
std::cout << " factorwise bumping " << allowFactorwiseBumping << "\n";
std::cout << " doCaps " << doCaps << "\n";



Size r=0;

std::cout << " price estimate, " << values[r++] << "\n";

for (Size i=0; i < numberRates; ++i, ++r)
    std::cout << " Delta, " << i << ", " << values[r] << ", " << errors[r] << "\n";

Real totalVega = 0.0;

for (; r < values.size(); ++r)
{
    std::cout << " vega, " << r - 1 -  numberRates<< ", " << values[r] << " ," << errors[r] << "\n";
    totalVega +=  values[r];
}

std::cout << " total Vega, " << totalVega << "\n";
}

for (Size s=0; s < isExerciseTime.size(); ++s)
{
    if (isExerciseTime[s])
    {
        MTBrownianGeneratorFactory iFactory(seed+s);
        boost::shared_ptr<MarketModelEvolver> e =boost::shared_ptr<MarketModelEvolver> (static_cast<MarketModelEvolver*>(new   LogNormalFwdRatePc(boost::shared_ptr<MarketModel>(new FlatVol(calibration)),
            uFactory,
            numeraires ,  // numeraires for each step
            s)));

        innerEvolvers.push_back(e);
    }
}

for (Size i=5; i < 10; ++i)
    InverseFloater(i/100.0);

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/Examples/ConvertibleBonds/ConvertibleBonds.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i<LENGTH(callLength); i++) {
    callability.push_back(
           boost::shared_ptr<Callability>(
               new SoftCallability(Callability::Price(
                                           callPrices[i],
                                           Callability::Price::Clean),
                                   schedule.date(callLength[i]),
                                   1.20)));
}

for (Size j=0; j<LENGTH(putLength); j++) {
    callability.push_back(
           boost::shared_ptr<Callability>(
                   new Callability(Callability::Price(
                                           putPrices[j],
                                           Callability::Price::Clean),
                                   Callability::Put,
                                   schedule.date(putLength[j]))));
}

for (Date d = today + 6*Months; d < exerciseDate; d += 6*Months) {
    dividends.push_back(
              boost::shared_ptr<Dividend>(new FixedDividend(1.0, d)));
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/Examples/Gaussian1dModels/Gaussian1dModels.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size j = 0; j < basket.size(); ++j) {
boost::shared_ptr<SwaptionHelper> helper =
    boost::dynamic_pointer_cast<SwaptionHelper>(basket[j]);
Date endDate = helper->underlyingSwap()->fixedSchedule().dates().back();
Real nominal = helper->underlyingSwap()->nominal();
Real vol = helper->volatility()->value();
Real rate = helper->underlyingSwap()->fixedRate();
Date expiry = helper->swaption()->exercise()->date(0);
VanillaSwap::Type type = helper->swaption()->type();
std::ostringstream expiryString, endDateString;
expiryString << expiry;
endDateString << endDate;
std::cout << std::setw(20) << expiryString.str() << std::setw(20)
          << endDateString.str() << std::setw(20) << nominal
          << std::setw(14) << rate << std::setw(12)
          << (type == VanillaSwap::Payer ? "Payer" : "Receiver")
          << std::setw(14) << vol << std::endl;
}

for (Size j = 0; j < basket.size(); ++j) {
boost::shared_ptr<SwaptionHelper> helper =
    boost::dynamic_pointer_cast<SwaptionHelper>(basket[j]);
Date expiry = helper->swaption()->exercise()->date(0);
std::ostringstream expiryString;
expiryString << expiry;
std::cout << std::setw(20) << expiryString.str() << std::setw(14)
          << volatility[j] << std::setw(20) << basket[j]->modelValue()
          << std::setw(20) << basket[j]->marketValue() << std::setw(14)
          << basket[j]->impliedVolatility(basket[j]->modelValue(), 1E-6,
                                          1000, 0.0, 2.0)
          << std::setw(14) << basket[j]->volatility()->value()
          << std::endl;
}

for (Size i = 1; i < 10; ++i)
    exerciseDates.push_back(
        TARGET().advance(fixedSchedule[i], -2 * Days));

for (Size i = 0; i < basket.size(); ++i)
    basket[i]->setPricingEngine(swaptionEngine);

for (Size i = 0; i < basket.size(); ++i)
    basket[i]->setPricingEngine(swaptionEngine);

for (Size i = 0; i < fixedSchedule.size() - 1; ++i) {
    Real tmpNom = 1.0 - (Real)i / (fixedSchedule.size() - 1);
    nominalFixed.push_back(tmpNom);
    nominalFloating.push_back(tmpNom);
    nominalFloating.push_back(
        tmpNom); // we use that the swap is 6m vs. 1y here
}

for (Size i = 0; i < basket.size(); i++)
    basket[i]->setPricingEngine(swaptionEngine);

for (Size i = 0; i < basket.size(); i++)
    basket[i]->setPricingEngine(swaptionEngine);

for (Size i = 0; i < basket.size(); ++i)
    basket[i]->setPricingEngine(swaptionEngine);

for (Size i = 0; i < basket.size(); ++i)
    basket[i]->setPricingEngine(swaptionEngineMarkov);

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/Examples/EquityOption/EquityOption.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Integer i=1; i<=4; i++)
    exerciseDates.push_back(settlementDate + 3*i*Months);

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/Examples/CDS/CDS.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i<4; i++) {
    maturities.push_back(calendar.adjust(todaysDate + tenors[i],
                                         Following));
}

for (Size i=0; i<4; i++) {
    instruments.push_back(boost::shared_ptr<DefaultProbabilityHelper>(
        new SpreadCdsHelper(
                      Handle<Quote>(boost::shared_ptr<Quote>(
                                 new SimpleQuote(quoted_spreads[i]))),
                      tenors[i],
                      0,
                      calendar,
                      Quarterly,
                      Following,
                      DateGeneration::TwentiethIMM,
                      Actual365Fixed(),
                      recovery_rate,
                      tsCurve)));
}

for (Size i=0; i<hr_curve_data.size(); i++) {
    cout << "hazard rate on " << hr_curve_data[i].first << " is "
         << hr_curve_data[i].second << endl;
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/Examples/MultidimIntegral/MultidimIntegral.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for(Size i=0; i<arg.size(); i++) 
    sum *= std::exp(-arg[i]*arg[i]) * std::cos(arg[i]);

for(Size i=0; i<dimension; i++)
integrals.push_back(
boost::make_shared<TrapezoidIntegral<Default> >(1.e-4, 20));

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/Examples/FRA/FRA.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (i=0; i<LENGTH(monthsToStart); i++) {

    Date fraValueDate = fraCalendar.advance(
                               settlementDate,monthsToStart[i],Months,
                               fraBusinessDayConvention);

    Date fraMaturityDate = fraCalendar.advance(
                                    fraValueDate,FraTermMonths,Months,
                                    fraBusinessDayConvention);

    Rate fraStrikeRate = threeMonthFraQuote[monthsToStart[i]];

    ForwardRateAgreement myFRA(fraValueDate, fraMaturityDate,
                               fraFwdType,fraStrikeRate,
                               fraNotional, euribor3m,
                               discountingTermStructure);

    cout << "3m Term FRA, Months to Start: "
         << monthsToStart[i]
         << endl;
    cout << "strike FRA rate: "
         << io::rate(fraStrikeRate)
         << endl;
    cout << "FRA 3m forward rate: "
         << myFRA.forwardRate()
         << endl;
    cout << "FRA market quote: "
         << io::rate(threeMonthFraQuote[monthsToStart[i]])
         << endl;
    cout << "FRA spot value: "
         << myFRA.spotValue()
         << endl;
    cout << "FRA forward value: "
         << myFRA.forwardValue()
         << endl;
    cout << "FRA implied Yield: "
         << myFRA.impliedYield(myFRA.spotValue(),
                               myFRA.forwardValue(),
                               settlementDate,
                               Simple,
                               fraDayCounter)
         << endl;
    cout << "market Zero Rate: "
         << discountingTermStructure->zeroRate(fraMaturityDate,
                                               fraDayCounter,
                                               Simple)
         << endl;
    cout << "FRA NPV [should be zero]: "
         << myFRA.NPV()
         << endl
         << endl;

}

for (i=0; i<LENGTH(monthsToStart); i++) {

    Date fraValueDate = fraCalendar.advance(
                               settlementDate,monthsToStart[i],Months,
                               fraBusinessDayConvention);

    Date fraMaturityDate = fraCalendar.advance(
                                    fraValueDate,FraTermMonths,Months,
                                    fraBusinessDayConvention);

    Rate fraStrikeRate =
        threeMonthFraQuote[monthsToStart[i]] - BpsShift;

    ForwardRateAgreement myFRA(fraValueDate, fraMaturityDate,
                               fraFwdType, fraStrikeRate,
                               fraNotional, euribor3m,
                               discountingTermStructure);

    cout << "3m Term FRA, 100 notional, Months to Start = "
         << monthsToStart[i]
         << endl;
    cout << "strike FRA rate: "
         << io::rate(fraStrikeRate)
         << endl;
    cout << "FRA 3m forward rate: "
         << myFRA.forwardRate()
         << endl;
    cout << "FRA market quote: "
         << io::rate(threeMonthFraQuote[monthsToStart[i]])
         << endl;
    cout << "FRA spot value: "
         << myFRA.spotValue()
         << endl;
    cout << "FRA forward value: "
         << myFRA.forwardValue()
         << endl;
    cout << "FRA implied Yield: "
         << myFRA.impliedYield(myFRA.spotValue(),
                               myFRA.forwardValue(),
                               settlementDate,
                               Simple,
                               fraDayCounter)
         << endl;
    cout << "market Zero Rate: "
         << discountingTermStructure->zeroRate(fraMaturityDate,
                                               fraDayCounter,
                                               Simple)
         << endl;
    cout << "FRA NPV [should be positive]: "
         << myFRA.NPV()
         << endl
         << endl;
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/Examples/LatentModel/LatentModel.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for(Size i=0; i<hazardRates.size(); i++)
    names.push_back(std::string("Acme") + 
        boost::lexical_cast<std::string>(i));

for(Size i=0; i<hazardRates.size(); i++)
    defTS.push_back(Handle<DefaultProbabilityTermStructure>(
        boost::make_shared<FlatHazardRate>(0, TARGET(), hazardRates[i], 
            Actual365Fixed())));

for(Size i=0; i<hazardRates.size(); i++) {
    std::vector<QuantLib::Issuer::key_curve_pair> curves(1, 
        std::make_pair(NorthAmericaCorpDefaultKey(
            EURCurrency(), QuantLib::SeniorSec,
            Period(), 1. // amount threshold
            ), defTS[i]));
    issuers.push_back(Issuer(curves));
}

for(Size i=0; i<hazardRates.size(); i++)
    thePool->add(names[i], issuers[i], NorthAmericaCorpDefaultKey(
            EURCurrency(), QuantLib::SeniorSec, Period(), 1.));

for(Size numEvts=0; numEvts <=theBskt->size(); numEvts++) {
    probEventsTLatent.push_back(lmT->probAtLeastNEvents(numEvts, 
        calcDate));
 }

for(Size numEvts=0; numEvts <=theBskt->size(); numEvts++) {
    probEventsGLatent.push_back(lmG->probAtLeastNEvents(numEvts, 
        calcDate));
 }

for(Size numEvts=0; numEvts <=theBskt->size(); numEvts++) {
    probEventsTRandLoss.push_back(theBskt->probAtLeastNEvents(numEvts, 
        calcDate));
 }

for(Size numEvts=0; numEvts <=theBskt->size(); numEvts++) {
    probEventsGRandLoss.push_back(theBskt->probAtLeastNEvents(numEvts, 
        calcDate));
 }

for(Size iName1=0; iName1 <theBskt->size(); iName1++) {
    std::vector<Real> tmp;
    for(Size iName2=0; iName2 <theBskt->size(); iName2++)
        tmp.push_back(lmG->defaultCorrelation(correlDate, 
            iName1, iName2));
    correlsGlm.push_back(tmp);
}

for(Size iName1=0; iName1 <theBskt->size(); iName1++) {
    std::vector<Real> tmp;
    for(Size iName2=0; iName2 <theBskt->size(); iName2++)
        tmp.push_back(lmT->defaultCorrelation(correlDate, 
            iName1, iName2));
    correlsTlm.push_back(tmp);
}

for(Size iName1=0; iName1 <theBskt->size(); iName1++) {
    std::vector<Real> tmp;
    for(Size iName2=0; iName2 <theBskt->size(); iName2++)
        tmp.push_back(theBskt->defaultCorrelation(correlDate, 
            iName1, iName2));
    correlsGrand.push_back(tmp);
}

for(Size iName1=0; iName1 <theBskt->size(); iName1++) {
    std::vector<Real> tmp;
    for(Size iName2=0; iName2 <theBskt->size(); iName2++)
        tmp.push_back(theBskt->defaultCorrelation(correlDate, 
            iName1, iName2));
    correlsTrand.push_back(tmp);
}

for(Size numEvts=0; numEvts <=theBskt->size(); numEvts++) {
    std::cout << "-Prob of " << numEvts << " events... " <<
        probEventsGLatent[numEvts] << " ** " << 
        probEventsTLatent[numEvts] << " ** " << 
        probEventsGRandLoss[numEvts]<< " ** " << 
        probEventsTRandLoss[numEvts] 
    << std::endl;
}

for(Size iName1=0; iName1 <theBskt->size(); iName1++) {
    for(Size iName2=0; iName2 <theBskt->size(); iName2++)
        cout << 
            correlsGlm[iName1][iName2] << " , ";
    ;
        cout << endl;
}

for(Size iName1=0; iName1 <theBskt->size(); iName1++) {
    for(Size iName2=0; iName2 <theBskt->size(); iName2++)
        cout << 
            correlsTlm[iName1][iName2] << " , ";
    ;
        cout << endl;
}

for(Size iName1=0; iName1 <theBskt->size(); iName1++) {
    for(Size iName2=0; iName2 <theBskt->size(); iName2++)
        cout << 
            correlsGrand[iName1][iName2] << " , ";
    ;
        cout << endl;
}

for(Size iName1=0; iName1 <theBskt->size(); iName1++) {
    for(Size iName2=0; iName2 <theBskt->size(); iName2++)
        cout << 
            correlsTrand[iName1][iName2] << " , ";
    ;
        cout << endl;
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/Examples/BasketLosses/BasketLosses.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for(Size i=0; i<hazardRates.size(); i++)
    names.push_back(std::string("Acme") + 
        boost::lexical_cast<std::string>(i));

for(Size i=0; i<hazardRates.size(); i++) {
    defTS.push_back(Handle<DefaultProbabilityTermStructure>(
        boost::make_shared<FlatHazardRate>(0, TARGET(), hazardRates[i], 
            Actual365Fixed())));
    defTS.back()->enableExtrapolation();
}

for(Size i=0; i<hazardRates.size(); i++) {
    std::vector<QuantLib::Issuer::key_curve_pair> curves(1, 
        std::make_pair(NorthAmericaCorpDefaultKey(
            EURCurrency(), QuantLib::SeniorSec,
            Period(), 1. // amount threshold
            ), defTS[i]));
    issuers.push_back(Issuer(curves));
}

for(Size i=0; i<hazardRates.size(); i++)
    thePool->add(names[i], issuers[i], NorthAmericaCorpDefaultKey(
            EURCurrency(), QuantLib::SeniorSec, Period(), 1.));

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/Examples/BermudanSwaption/BermudanSwaption.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i<numRows; i++) {
Size j = numCols - i -1; // 1x5, 2x4, 3x3, 4x2, 5x1
Size k = i*numCols + j;
Real npv = helpers[i]->modelValue();
Volatility implied = helpers[i]->impliedVolatility(npv, 1e-4,
                                                   1000, 0.05, 0.50);
Volatility diff = implied - swaptionVols[k];

std::cout << i+1 << "x" << swapLenghts[j]
          << std::setprecision(5) << std::noshowpos
          << ": model " << std::setw(7) << io::volatility(implied)
          << ", market " << std::setw(7)
          << io::volatility(swaptionVols[k])
          << " (" << std::setw(7) << std::showpos
          << io::volatility(diff) << std::noshowpos << ")\n";
}

for (i=0; i<numRows; i++) {
    Size j = numCols - i -1; // 1x5, 2x4, 3x3, 4x2, 5x1
    Size k = i*numCols + j;
    boost::shared_ptr<Quote> vol(new SimpleQuote(swaptionVols[k]));
    swaptions.push_back(boost::shared_ptr<CalibrationHelper>(new
        SwaptionHelper(swaptionMaturities[i],
                       Period(swapLenghts[j], Years),
                       Handle<Quote>(vol),
                       indexSixMonths,
                       indexSixMonths->tenor(),
                       indexSixMonths->dayCounter(),
                       indexSixMonths->dayCounter(),
                       rhTermStructure)));
    swaptions.back()->addTimesTo(times);
}

for (i=0; i<swaptions.size(); i++)
    swaptions[i]->setPricingEngine(boost::shared_ptr<PricingEngine>(
        new G2SwaptionEngine(modelG2, 6.0, 16)));

for (i=0; i<swaptions.size(); i++)
    swaptions[i]->setPricingEngine(boost::shared_ptr<PricingEngine>(
        new JamshidianSwaptionEngine(modelHW)));

for (i=0; i<swaptions.size(); i++)
    swaptions[i]->setPricingEngine(boost::shared_ptr<PricingEngine>(
                             new TreeSwaptionEngine(modelHW2, grid)));

for (i=0; i<swaptions.size(); i++)
    swaptions[i]->setPricingEngine(boost::shared_ptr<PricingEngine>(
                              new TreeSwaptionEngine(modelBK, grid)));

for (i=0; i<leg.size(); i++) {
    boost::shared_ptr<Coupon> coupon =
        boost::dynamic_pointer_cast<Coupon>(leg[i]);
    bermudanDates.push_back(coupon->accrualStartDate());
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/Examples/Bonds/Bonds.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=0; i<numberOfBonds; i++) {
    boost::shared_ptr<SimpleQuote> cp(new SimpleQuote(marketQuotes[i]));
    quote.push_back(cp);
}

for (Size i=0; i<numberOfBonds; i++) {
    quoteHandle[i].linkTo(quote[i]);
}

for (Size i=0; i<numberOfBonds; i++) {

    Schedule schedule(issueDates[i], maturities[i], Period(Semiannual), UnitedStates(UnitedStates::GovernmentBond),
            Unadjusted, Unadjusted, DateGeneration::Backward, false);

    boost::shared_ptr<FixedRateBondHelper> bondHelper(new FixedRateBondHelper(
            quoteHandle[i],
            settlementDays,
            100.0,
            schedule,
            std::vector<Rate>(1,couponRates[i]),
            ActualActual(ActualActual::Bond),
            Unadjusted,
            redemption,
            issueDates[i]));

    // the above could also be done by creating a
    // FixedRateBond instance and writing:
    //
    // boost::shared_ptr<BondHelper> bondHelper(
    //         new BondHelper(quoteHandle[i], bond));
    //
    // This would also work for bonds that still don't have a
    // specialized helper, such as floating-rate bonds.


    bondsHelpers.push_back(bondHelper);
}

 for (Size i=0; i<numberOfBonds; i++) {
     bondInstruments.push_back(bondsHelpers[i]);
 }

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/Examples/FittedBondCurve/FittedBondCurve.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (Size i=1; i<dates.size(); ++i) {
dt = resultDayCounter.yearFraction(dates[i-1], dates[i]);
QL_REQUIRE(dt>0.0, "unsorted dates");
sum += yts.discount(dates[i]) * dt;
}

for (Size i=0; i<numberOfBonds; i++) {
    cleanPrice[i]=100.0;
}

for (Size i=0; i<numberOfBonds; i++) {
    boost::shared_ptr<SimpleQuote> cp(new SimpleQuote(cleanPrice[i]));
    quote.push_back(cp);
}

for (Size i=0; i<numberOfBonds; i++) {
    quoteHandle[i].linkTo(quote[i]);
}

for (Size j=0; j<LENGTH(lengths); j++) {

    Date maturity = calendar.advance(bondSettlementDate, lengths[j]*Years);

    Schedule schedule(bondSettlementDate, maturity, Period(frequency),
                      calendar, accrualConvention, accrualConvention,
                      DateGeneration::Backward, false);

    boost::shared_ptr<BondHelper> helperA(
             new FixedRateBondHelper(quoteHandle[j],
                                     bondSettlementDays,
                                     100.0,
                                     schedule,
                                     std::vector<Rate>(1,coupons[j]),
                                     dc,
                                     convention,
                                     redemption));

    boost::shared_ptr<RateHelper> helperB(
             new FixedRateBondHelper(quoteHandle[j],
                                     bondSettlementDays,
                                     100.0,
                                     schedule,
                                     std::vector<Rate>(1, coupons[j]),
                                     dc,
                                     convention,
                                     redemption));
    instrumentsA.push_back(helperA);
    instrumentsB.push_back(helperB);
}

for (Size i=0; i< LENGTH(knots); i++) {
    knotVector.push_back(knots[i]);
}

for (Size i=0; i<instrumentsA.size(); i++) {

    std::vector<boost::shared_ptr<CashFlow> > cfs =
        instrumentsA[i]->bond()->cashflows();

    Size cfSize = instrumentsA[i]->bond()->cashflows().size();
    std::vector<Date> keyDates;
    keyDates.push_back(bondSettlementDate);

    for (Size j=0; j<cfSize-1; j++) {
        if (!cfs[j]->hasOccurred(bondSettlementDate, false)) {
            Date myDate =  cfs[j]->date();
            keyDates.push_back(myDate);
        }
    }

    Real tenor = dc.yearFraction(today, cfs[cfSize-1]->date());

    cout << setw(6) << fixed << setprecision(3) << tenor << " | "
         << setw(6) << fixed << setprecision(3)
         << 100.*coupons[i] << " | "
         // piecewise bootstrap
         << setw(6) << fixed << setprecision(3)
         << 100.*parRate(*ts0,keyDates,dc) << " | "
         // exponential splines
         << setw(6) << fixed << setprecision(3)
         << 100.*parRate(*ts1,keyDates,dc) << " | "
         // simple polynomial
         << setw(6) << fixed << setprecision(3)
         << 100.*parRate(*ts2,keyDates,dc) << " | "
         // Nelson-Siegel
         << setw(6) << fixed << setprecision(3)
         << 100.*parRate(*ts3,keyDates,dc) << " | "
         // cubic bsplines
         << setw(6) << fixed << setprecision(3)
         << 100.*parRate(*ts4,keyDates,dc) << " | "
         // Svensson
         << setw(6) << fixed << setprecision(3)
         << 100.*parRate(*ts5,keyDates,dc) << endl;
}

for (Size i=0; i<instrumentsA.size(); i++) {

    std::vector<boost::shared_ptr<CashFlow> > cfs =
        instrumentsA[i]->bond()->cashflows();

    Size cfSize = instrumentsA[i]->bond()->cashflows().size();
    std::vector<Date> keyDates;
    keyDates.push_back(bondSettlementDate);

    for (Size j=0; j<cfSize-1; j++) {
        if (!cfs[j]->hasOccurred(bondSettlementDate, false)) {
            Date myDate =  cfs[j]->date();
            keyDates.push_back(myDate);
        }
    }

    Real tenor = dc.yearFraction(today, cfs[cfSize-1]->date());

    cout << setw(6) << fixed << setprecision(3) << tenor << " | "
         << setw(6) << fixed << setprecision(3)
         << 100.*coupons[i] << " | "
         // piecewise bootstrap
         << setw(6) << fixed << setprecision(3)
         << 100.*parRate(*ts0,keyDates,dc) << " | "
         // exponential splines
         << setw(6) << fixed << setprecision(3)
         << 100.*parRate(*ts1,keyDates,dc) << " | "
         // simple polynomial
         << setw(6) << fixed << setprecision(3)
         << 100.*parRate(*ts2,keyDates,dc) << " | "
         // Nelson-Siegel
         << setw(6) << fixed << setprecision(3)
         << 100.*parRate(*ts3,keyDates,dc) << " | "
         // cubic bsplines
         << setw(6) << fixed << setprecision(3)
         << 100.*parRate(*ts4,keyDates,dc) << " | "
         // Svensson
         << setw(6) << fixed << setprecision(3)
         << 100.*parRate(*ts5,keyDates,dc) << endl;
}

for (Size i=0; i<instrumentsA.size(); i++) {

    std::vector<boost::shared_ptr<CashFlow> > cfs =
        instrumentsA[i]->bond()->cashflows();

    Size cfSize = instrumentsA[i]->bond()->cashflows().size();
    std::vector<Date> keyDates;
    keyDates.push_back(bondSettlementDate);

    for (Size j=0; j<cfSize-1; j++) {
        if (!cfs[j]->hasOccurred(bondSettlementDate, false)) {
            Date myDate =  cfs[j]->date();
            keyDates.push_back(myDate);
        }
    }

    Real tenor = dc.yearFraction(today, cfs[cfSize-1]->date());

    cout << setw(6) << fixed << setprecision(3) << tenor << " | "
         << setw(6) << fixed << setprecision(3)
         << 100.*coupons[i+1] << " | "
         // piecewise bootstrap
         << setw(6) << fixed << setprecision(3)
         << 100.*parRate(*ts00,keyDates,dc) << " | "
         // exponential splines
         << setw(6) << fixed << setprecision(3)
         << 100.*parRate(*ts11,keyDates,dc) << " | "
         // simple polynomial
         << setw(6) << fixed << setprecision(3)
         << 100.*parRate(*ts22,keyDates,dc) << " | "
         // Nelson-Siegel
         << setw(6) << fixed << setprecision(3)
         << 100.*parRate(*ts33,keyDates,dc) << " | "
         // cubic bsplines
         << setw(6) << fixed << setprecision(3)
         << 100.*parRate(*ts44,keyDates,dc) << " | "
         // Svensson
         << setw(6) << fixed << setprecision(3)
         << 100.*parRate(*ts55,keyDates,dc) << endl;
}

for (Size k=0; k<LENGTH(lengths)-1; k++) {

    Real P = instrumentsA[k]->quote()->value();
    const Bond& b = *instrumentsA[k]->bond();
    Rate ytm = BondFunctions::yield(b, P,
                                    dc, Compounded, frequency,
                                    today);
    Time dur = BondFunctions::duration(b, ytm,
                                       dc, Compounded, frequency,
                                       Duration::Modified,
                                       today);

    const Real bpsChange = 5.;
    // dP = -dur * P * dY
    Real deltaP = -dur * P * (bpsChange/10000.);
    quote[k+1]->setValue(P + deltaP);
}

for (Size i=0; i<instrumentsA.size(); i++) {

    std::vector<boost::shared_ptr<CashFlow> > cfs =
        instrumentsA[i]->bond()->cashflows();

    Size cfSize = instrumentsA[i]->bond()->cashflows().size();
    std::vector<Date> keyDates;
    keyDates.push_back(bondSettlementDate);

    for (Size j=0; j<cfSize-1; j++) {
        if (!cfs[j]->hasOccurred(bondSettlementDate, false)) {
            Date myDate =  cfs[j]->date();
            keyDates.push_back(myDate);
        }
    }

    Real tenor = dc.yearFraction(today, cfs[cfSize-1]->date());

    cout << setw(6) << fixed << setprecision(3) << tenor << " | "
         << setw(6) << fixed << setprecision(3)
         << 100.*coupons[i+1] << " | "
         // piecewise bootstrap
         << setw(6) << fixed << setprecision(3)
         << 100.*parRate(*ts00,keyDates,dc) << " | "
         // exponential splines
         << setw(6) << fixed << setprecision(3)
         << 100.*parRate(*ts11,keyDates,dc) << " | "
         // simple polynomial
         << setw(6) << fixed << setprecision(3)
         << 100.*parRate(*ts22,keyDates,dc) << " | "
         // Nelson-Siegel
         << setw(6) << fixed << setprecision(3)
         << 100.*parRate(*ts33,keyDates,dc) << " | "
         // cubic bsplines
         << setw(6) << fixed << setprecision(3)
         << 100.*parRate(*ts44,keyDates,dc) << " | "
         // Svensson
         << setw(6) << fixed << setprecision(3)
         << 100.*parRate(*ts55,keyDates,dc) << endl;
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/ObjectHandler/xlsdk/framewrk.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (i = 0; i<count; i++)
{
px = va_arg(ppxArgs, LPXLOPER);

if (px == NULL)
{
    FreeAllTempMemory();
    return;
}
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/ObjectHandler/oh/utilities.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    for (size_t i=0; i<symbols.size()-1; ++i)
        ret << symbols[i] << delim;

for(; yearOffset < size; ++yearOffset){

    if(tmp < YearOffset[yearOffset]){
        years = yearOffset - 1 + 1900;
        b = true;
        break;
    }
}

for(; monthoffset < size; ++monthoffset){

    if(days <= pMonth[monthoffset]){
        monthes = monthoffset;
        b = true;
        break;
    }
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/ObjectHandler/oh/processor.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for(; it != processorMap_.end(); ++it)
    it->second->postProcess();

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/ObjectHandler/oh/serializationfactory.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (i=objectList.begin(); i!=objectList.end(); ++i) {
    boost::shared_ptr<ObjectHandler::Object> object = *i;
    // FIXME just call ValueObject::objectId()?
    std::string objectID
        = boost::get<std::string>(object->properties()->getProperty("OBJECTID"));
    if (seen.find(objectID) == seen.end()) {
        valueObjects.push_back(object->properties());
        seen.insert(objectID);
    }
}

    for (i=valueObjects.begin(); i!=valueObjects.end(); ++i) {
        try {
            processedIDs.push_back(
                ProcessorFactory::instance().getProcessor(*i)->process(
                    *this, *i, overwriteExisting));
            count++;
        } catch (const std::exception &e) {
            OH_FAIL("Error processing item " << count << ": " << e.what());
        }
    }

    for (i=valueObjects.begin(); i!=valueObjects.end(); ++i) {
        try {
            returnValue.push_back(
                ProcessorFactory::instance().getProcessor(*i)->process(
                    *this, *i, overwriteExisting));
            count++;
        } catch (const std::exception &e) {
            OH_FAIL("Error processing item " << count << ": " << e.what());
        }
    }

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/ObjectHandler/oh/repository.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for(; iter != relationObs.end();  iter++) {
    shared_ptr<ObjectWrapper> objServable =
                                    getObjectWrapper(formatID(*iter));
    objWrapper->registerWith(objServable);
}

for (i = objectIDs.begin(); i != objectIDs.end(); ++i)
    deleteObject(*i);

for (i=objectMap_.begin(); i!=objectMap_.end(); ++i) {
        shared_ptr<Object> object = i->second->object();
        out << "Object with ID = " << i->first << ":" << endl <<object;
}

    for (i=objectMap_.begin(); i!=objectMap_.end(); ++i)
        objectIDs.push_back(i->first);

    for (i=objectMap_.begin(); i!=objectMap_.end(); ++i) {
        string objectID = i->first;
        if (regex_match(objectID, r))
            objectIDs.push_back(objectID);
    }

for (i = objectList.begin(); i != objectList.end(); ++i) {
        ret.push_back(objectExists(formatID(*i)));
}

for (i = objectList.begin(); i != objectList.end(); ++i) {
    string realID = formatID(*i);
    if(objectExists(realID)){
        ObjectMap::const_iterator result = objectMap_.find(realID);
        ret.push_back(result->second->creationTime());
    } else {
        OH_FAIL("Unable to retrieve object with ID "<<*i);
    }
}

	for(; it != relationObs.end(); ++it){
		vecRelationObs.push_back(formatID(*it));
	}

for(i = group->list().begin(); i != group->list().end(); ++i) {
	if (objectExists(*i))
        ret.push_back(*i);
}

for (i = objectList.begin(); i != objectList.end(); ++i) {
    string realID = formatID(*i);
    if (objectExists(realID)){
        ObjectMap::const_iterator result = objectMap_.find(realID);
        ret.push_back(result->second->object()->permanent());
    } else {
        OH_FAIL("Unable to retrieve object with ID "<<*i);
    }
}

for (i = objectList.begin(); i != objectList.end(); ++i) {
    string realID = formatID(*i);
    if (objectExists(realID)){

        ObjectMap::const_iterator result = objectMap_.find(realID);

        ret.push_back(result->second->object()->properties()->className());

    } else {
        OH_FAIL("Unable to retrieve object with ID "<<*i);
    }
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/ObjectHandler/Examples/C++/example.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
 for(unsigned int i = 0; i < vecTime.size(); ++i)
    OH_LOG_MESSAGE(vecOb[i] <<"  "<< ObjectHandler::formatTime(vecTime[i]));

 for(unsigned int i = 0; i < vecTime.size(); ++i)
    OH_LOG_MESSAGE(vecOb[i] << "  "<< ObjectHandler::formatTime(vecTime[i]));

for(unsigned int i = 0; i < relationIDs.size(); ++i)
    show += relationIDs[i];

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/ObjectHandler/ohxl/repositoryxl.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (i = errorMessageMap_.begin(); i != errorMessageMap_.end(); ++i) {
    if (i->second->contains(selectionReference))
        return i->second->errorMessage();
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/ObjectHandler/ohxl/functions/manual.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (int numValidRows=xMulti.val.array.rows; numValidRows; --numValidRows) {
for (int i=0; i<xMulti.val.array.columns; ++i) {
    int index = (numValidRows - 1) * xMulti.val.array.columns + i;
    if (!(xMulti.val.array.lparray[index].xltype & (xltypeErr | xltypeNil)))
        return numValidRows;
}
}

for (int numValidCols=xMulti.val.array.columns; numValidCols; --numValidCols) {
for (int i=0; i<xMulti.val.array.rows; ++i) {
    int index = (numValidCols - 1) + i * xMulti.val.array.columns;
    if (!(xMulti.val.array.lparray[index].xltype & (xltypeErr | xltypeNil)))
        return numValidCols;
}
}

for (int i=0; i<numValidRows; ++i) {
    for (int j=0; j<numValidCols; ++j) {
        int indexSource = i * xMulti->val.array.columns + j;
        int indexTarget = i * numValidCols + j;
        operToOper(&xRet.val.array.lparray[indexTarget], 
            &xMulti->val.array.lparray[indexSource]);
    }
}

    for (int i=0; i<xRet.val.array.columns * xRet.val.array.rows; ++i) {
        if (xRet.val.array.lparray[i].xltype & xltypeStr && xRet.val.array.lparray[i].val.str)
            delete [] xRet.val.array.lparray[i].val.str;
    }

for (int j=0; j<xMulti.val.array.columns; ++j) {
int index = i * xMulti.val.array.columns + j;
if (xMulti.val.array.lparray[index].xltype & (xltypeErr | xltypeNil))
    return false;
}

for (int i=0; i<xMulti.val.array.rows; ++i)
ret += rowIsValid(xMulti, i);

for (int i=0; i<xMulti->val.array.rows; ++i) {
    if (rowIsValid(xMulti(), i)) {
        for (int j=0; j<numCols; ++j) {
            int indexSource = i * numCols + j;
            int indexTarget = i2 * numCols + j;
            operToOper(&xRet.val.array.lparray[indexTarget], 
                &xMulti->val.array.lparray[indexSource]);
        }
        i2++;
    }
}

    for (int i=0; i<xRet.val.array.columns * xRet.val.array.rows; ++i) {
        if (xRet.val.array.lparray[i].xltype & xltypeStr && xRet.val.array.lparray[i].val.str)
            delete [] xRet.val.array.lparray[i].val.str;
    }

for (int i=0; i<xMulti.val.array.rows; ++i) {
int index = i * xMulti.val.array.columns + j;
if (xMulti.val.array.lparray[index].xltype & (xltypeErr | xltypeNil))
    return false;
}

for (int j=0; j<xMulti.val.array.columns; ++j)
ret += columnIsValid(xMulti, j);

for (int i=0; i<xMulti->val.array.rows; ++i) {
	int j2 = 0;
    for (int j=0; j<xMulti->val.array.columns; ++j) {
		if (columnIsValid(xMulti(), j)) {
			int indexSource = i * xMulti->val.array.columns + j;
			int indexTarget = i * numValidCols + j2;
			operToOper(&xRet.val.array.lparray[indexTarget], 
				&xMulti->val.array.lparray[indexSource]);
			j2++;
		}
    }
}

    for (int i=0; i<xRet.val.array.columns * xRet.val.array.rows; ++i) {
        if (xRet.val.array.lparray[i].xltype & xltypeStr && xRet.val.array.lparray[i].val.str)
            delete [] xRet.val.array.lparray[i].val.str;
    }

for (int i=0; i<sizeInput; i++) {
    if (flagsCpp[i]) {
        operToOper(&xRet.val.array.lparray[idx++], &xMulti->val.array.lparray[i]);
    }
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/ObjectHandler/ohxl/conversions/validations.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (int i=0; i<xMulti->val.array.rows * xMulti->val.array.columns; ++i)
    if (xMulti->val.array.lparray[i].xltype & xltypeErr)
        return false;

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/ObjectHandler/ohxl/utilities/xlutilities.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (int i=0; i<size; ++i) {                            // ..Then iterate through the array...
    if (px->val.array.lparray[i].xltype & xltypeStr     // ...If this element is a string...
        &&  px->val.array.lparray[i].val.str) {         // ....And if the pointer is not null...
        delete [] px->val.array.lparray[i].val.str;     // .....Then delete the string...
    }
}

for (unsigned char i=1; i<=xValue->val.str[0]; i++) {
    if (xValue->val.str[i] == ',' || xValue->val.str[i] == ';')
        return true;
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/log4cxx/src/test/cpp/abts.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (i = 0; testlist[i] != NULL; i++) {
if (!strcmp(testlist[i], testname)) {
    return 1;
}
}

for (dptr = suite->head; dptr; dptr = dptr->next) {
count += dptr->failed;
}

for (i = 1; i < argc; i++) {
if (!strcmp(argv[i], "-v")) {
    verbose = 1;
    continue;
}
if (!strcmp(argv[i], "-x")) {
    exclude = 1;
    continue;
}
if (!strcmp(argv[i], "-l")) {
    list_tests = 1;
    continue;
}
if (!strcmp(argv[i], "-q")) {
    quiet = 1;
    continue;
}
if (argv[i][0] == '-') {
    fprintf(stderr, "Invalid option: `%s'\n", argv[i]);
    exit(1);
}
list_provided = 1;
}

for (i = 1; i < argc; i++) {
    testlist[i - 1] = argv[i];
}

for(sub_suite* head = suite->head; head != NULL; head = next) {
next = head->next;
   free((void*) head->name);
free(head);
 }

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/log4cxx/src/test/cpp/l7dtestcase.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        for (int i = 0; i < 3; i++)
        {
                root->setResourceBundle(bundles[i]);

                LOG4CXX_L7DLOG(root, Level::getDebug(), LOG4CXX_TEST_STR("bogus1"));
                LOG4CXX_L7DLOG(root, Level::getInfo(), LOG4CXX_TEST_STR("test"));
                LOG4CXX_L7DLOG(root, Level::getWarn(), LOG4CXX_TEST_STR("hello_world"));


                StringBuffer os;
                os << (i + 1);
                LOG4CXX_L7DLOG2(root, Level::getDebug(), LOG4CXX_TEST_STR("msg1"), os.str().c_str(),
                         LOG4CXX_TEST_STR("log4j"));
                LOG4CXX_L7DLOG2(root, Level::getError(), LOG4CXX_TEST_STR("bogusMsg"), os.str().c_str(),
                         LOG4CXX_TEST_STR("log4j"));
                LOG4CXX_L7DLOG2(root, Level::getError(), LOG4CXX_TEST_STR("msg1"), os.str().c_str(),
                         LOG4CXX_TEST_STR("log4j"));
                LOG4CXX_L7DLOG(root, Level::getInfo(), LOG4CXX_TEST_STR("bogus2"));
        }

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/log4cxx/src/test/cpp/asyncappendertestcase.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        for (size_t i = 0; i < LEN; i++) {
                LOG4CXX_DEBUG(root, "message" << i);
        }

    for (int i = 0; i < 100; i++) {
           LOG4CXX_INFO(rootLogger, "Hello, World");
           Thread::sleep(1);
    }

      for (size_t i = 0; i < LEN; i++) {
                LOG4CXX_DEBUG(root, "message" << i);
      }

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/log4cxx/src/test/cpp/util/binarycompare.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (int i = 0; i < BUFSIZE; i++) {
if (contents1[i] != contents2[i]) {
 std::string msg("Contents differ at position ");
 msg += apr_itoa(pool, i);
 msg += ": [";
 msg += filename1;
 msg += "] has ";
 msg += apr_itoa(pool, contents1[i]);
 msg += ", [";
 msg += filename2;
 msg += "] has ";
 msg += apr_itoa(pool, contents2[i]);
 msg += ".";
 LOGUNIT_FAIL(msg);
}
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/log4cxx/src/test/cpp/util/serializationtesthelper.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (int i = 0; i < endScan; i++) {
  if (((unsigned char) expected[i]) != actual[i]) {
    printf("Difference at offset %d, expected %x, actual %x\n", i, expected[i], actual[i]);
    return false;
  }
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/log4cxx/src/test/cpp/helpers/charsetencodertestcase.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  for(size_t i = 0; i < out.limit(); i++) {
     LOGUNIT_ASSERT_EQUAL((int) utf8_greet[i], (int) out.data()[i]);
  }

  for(int i = 0; i < package->getRepetitions(); i++) {
    bool pass = true;
    char buf[BUFSIZE];
    ByteBuffer out(buf, BUFSIZE);
    LogString::const_iterator iter = greeting.begin();
    log4cxx_status_t stat = package->getEncoder()->encode(greeting, iter, out);
    pass = (false == CharsetEncoder::isError(stat));
    if (pass) {
        stat = package->getEncoder()->encode(greeting, iter, out);
        pass = (false == CharsetEncoder::isError(stat));
        if (pass) {
            out.flip();
            pass = (sizeof(expected) == out.limit());
            for(size_t i = 0; i < out.limit() && pass; i++) {
                pass = (expected[i] == out.data()[i]);
            }
            pass = pass && (iter == greeting.end());
        }
    }
    if (pass) {
        package->pass();
    } else {
        package->fail();
    }
  }

      { for(int i = 0; i < THREAD_COUNT; i++) {
          threads[i].run(thread1Action, package);
      } }

      for(int i = 0; i < THREAD_COUNT; i++) {
          threads[i].join();
      }

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/log4cxx/src/test/cpp/helpers/cyclicbuffertestcase.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (int i = 0; i < MAX; i++)
{
 event = new LoggingEvent(LOG4CXX_STR("x"), Level::getDebug(), LOG4CXX_STR("e"),
                  log4cxx::spi::LocationInfo::getLocationUnavailable());
 e.push_back(event);
}

for (int bufSize = 1; bufSize <= 128; bufSize *= 2)
 doTest1(bufSize);

for (i = -(size + 10); i < (size + 10); i++)
{
 LOGUNIT_ASSERT(cb.get(i) == 0);
}

for (i = 0; i < MAX; i++)
{
 cb.add(e[i]);

 int limit = (i < (size - 1)) ? i : (size - 1);

 //System.out.println("\nLimit is " + limit + ", i="+i);
 for (int j = limit; j >= 0; j--)
 {
    //System.out.println("i= "+i+", j="+j);
    LOGUNIT_ASSERT_EQUAL(e[i - (limit - j)], cb.get(j));
 }

 LOGUNIT_ASSERT(cb.get(-1) == 0);
 LOGUNIT_ASSERT(cb.get(limit + 1) == 0);
}

for (int isize = 1; isize <= 128; isize *= 2)
{
 doTestResize(isize, (isize / 2) + 1, (isize / 2) + 1);
 doTestResize(isize, (isize / 2) + 1, isize + 10);
 doTestResize(isize, isize + 10, (isize / 2) + 1);
 doTestResize(isize, isize + 10, isize + 10);
}

for (int i = 0; i < numberOfAdds; i++)
{
 cb.add(e[i]);
}

for (int j = 0; j < len; j++)
{
 LOGUNIT_ASSERT_EQUAL(e[offset + j], cb.get(j));
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/log4cxx/src/test/cpp/rolling/obsoletedailyrollingfileappendertest.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (int i = 0; i < 25; i++) {
apr_sleep(100000);
msg[8] = (char) ('0' + (i / 10));
msg[9] = (char) ('0' + (i % 10));
LOG4CXX_DEBUG(logger, msg);
}

for (int i = 0; i < 25; i++) {
apr_sleep(100000);
msg[8] = (char) ('0' + i / 10);
msg[9] = (char) ('0' + i % 10);
LOG4CXX_DEBUG(logger, msg);
}

for (size_t i = 0; i < files.size(); i++) {
if (StringHelper::startsWith(files[i], initial)) {
count++;
}
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/log4cxx/src/test/cpp/rolling/manualrollingtest.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (int i = 0; i < 25; i++) {
if (i < 10) {
msg[8] = '0' + i;
} else if (i < 100) {
int digit = i % 10;
if (digit == 0) {
  rfa->rollover(pool);
}
msg[7] = '0' + i / 10;
msg[8] = '0' + digit;
}
LOG4CXX_DEBUG(logger1, msg);
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/log4cxx/src/test/cpp/rolling/filterbasedrollingtest.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (int i = 0; i < 25; i++) {
char msg[10];
#if defined(__STDC_LIB_EXT1__) || defined(__STDC_SECURE_LIB__)
strcpy_s(msg, sizeof msg, "Hello---?");
#else
strcpy(msg, "Hello---?");
#endif
if (i < 10) {
msg[8] = (char) ('0' + i);
LOG4CXX_DEBUG(logger, msg);
} else if (i < 100) {
msg[7] = (char) ('0' + (i / 10));
msg[8] = (char) ('0' + (i % 10));
if ((i % 10) == 0) {
  LOG4CXX_WARN(logger, msg);
} else {
  LOG4CXX_DEBUG(logger, msg);
}
}
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/log4cxx/src/test/cpp/rolling/timebasedrollingtest.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
{ for (int i = 0; i < 4; i++) {
filenames[i] = LOG4CXX_STR("output/test1-");
sdf.format(filenames[i], now, p);
now += APR_USEC_PER_SEC;
} }

{ for (int i = 0; i < 5; i++) {
std::string message("Hello---");
message.append(pool.itoa(i));
LOG4CXX_DEBUG(logger, message);
apr_sleep(APR_USEC_PER_SEC/2);
} }

for (int i = 0; i < 4; i++) {
LogString witness(LOG4CXX_STR("witness/rolling/tbr-test1."));
StringHelper::toString(i, pool, witness);
LOGUNIT_ASSERT(Compare::compare(filenames[i], File(witness)));
}

{ for (int i = 0; i < 4; i++) {
filenames[i] = LOG4CXX_STR("output/test2-");
sdf.format(filenames[i], now, pool);
now += APR_USEC_PER_SEC;
} }

{ for (int i = 0; i <= 2; i++) {
std::string message("Hello---");
message.append(pool.itoa(i));
LOG4CXX_DEBUG(logger, message);
apr_sleep(APR_USEC_PER_SEC/2);
} }

{ for (int i = 3; i <= 4; i++) {
std::string message("Hello---");
message.append(pool.itoa(i));
LOG4CXX_DEBUG(logger, message);
apr_sleep(APR_USEC_PER_SEC/2);
} }

for (int i = 0; i < 4; i++) {
LogString witness(LOG4CXX_STR("witness/rolling/tbr-test2."));
StringHelper::toString(i, pool, witness);
LOGUNIT_ASSERT(Compare::compare(filenames[i], File(witness)));
}

{ for (int i = 0; i < 4; i++) {
filenames[i] = LOG4CXX_STR("output/test3-");
sdf->format(filenames[i], now, p);
filenames[i].append(LOG4CXX_STR(".gz"));
now += APR_USEC_PER_SEC;
} }

{ for (int i = 0; i < 5; i++) {
std::string message("Hello---");
message.append(p.itoa(i));
LOG4CXX_DEBUG(logger, message);
apr_sleep(APR_USEC_PER_SEC/2);
} }

{ for (int i = 0; i < 3; i++) {
filenames[i] = LOG4CXX_STR("output/test4-");
sdf.format(filenames[i], now, pool);
now += APR_USEC_PER_SEC;
} }

{ for (int i = 0; i <= 2; i++) {
std::string message("Hello---");
message.append(pool.itoa(i));
LOG4CXX_DEBUG(logger, message);
apr_sleep(APR_USEC_PER_SEC/2);
} }

{ for (int i = 3; i <= 4; i++) {
std::string message("Hello---");
message.append(pool.itoa(i));
LOG4CXX_DEBUG(logger, message);
apr_sleep(APR_USEC_PER_SEC/2);
} }

for (int i = 0; i < 4; i++) {
LogString witness(LOG4CXX_STR("witness/rolling/tbr-test4."));
StringHelper::toString(i, pool, witness);
LOGUNIT_ASSERT(Compare::compare(filenames[i], File(witness)));
}

{ for (int i = 0; i < 3; i++) {
filenames[i] = LOG4CXX_STR("output/test5-");
sdf.format(filenames[i], now, pool);
now += APR_USEC_PER_SEC;
} }

{ for (int i = 0; i < 5; i++) {
std::string message("Hello---");
message.append(pool.itoa(i));
LOG4CXX_DEBUG(logger, message);
apr_sleep(APR_USEC_PER_SEC/2);
} }

for (int i = 0; i < 4; i++) {
LogString witness(LOG4CXX_STR("witness/rolling/tbr-test5."));
StringHelper::toString(i, pool, witness);
LOGUNIT_ASSERT(Compare::compare(filenames[i], File(witness)));
}

{ for (int i = 0; i < 3; i++) {
filenames[i] = LOG4CXX_STR("output/test6-");
sdf->format(filenames[i], now, p);
filenames[i].append(LOG4CXX_STR(".gz"));
now += APR_USEC_PER_SEC;
} }

{ for (int i = 0; i < 5; i++) {
std::string message("Hello---");
message.append(p.itoa(i));
LOG4CXX_DEBUG(logger, message);
apr_sleep(APR_USEC_PER_SEC/2);
} }

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/log4cxx/src/test/cpp/rolling/sizebasedrollingtest.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (int i = 0; i < 25; i++) {
if (i < 10) {
msg[8] = '0' + i;
} else if (i < 100) {
msg[7] = '0' + i / 10;
msg[8] = '0' + i % 10;
}
LOG4CXX_DEBUG(logger1, msg);
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/log4cxx/src/test/cpp/rolling/obsoleterollingfileappendertest.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (int i = 0; i < 25; i++) {
apr_sleep(100000);

if (i < 10) {
msg[8] = (char) ('0' + i);
LOG4CXX_DEBUG(logger, msg);
} else if (i < 100) {
msg[7] = (char) ('0' + i / 10);
msg[8] = (char) ('0' + i % 10);
LOG4CXX_DEBUG(logger, msg);
}
}

for (int i = 0; i < 25; i++) {
apr_sleep(100000);

if (i < 10) {
msg[8] = (char) ('0' + i);
LOG4CXX_DEBUG(logger, msg);
} else if (i < 100) {
msg[7] = (char) ('0' + i / 10);
msg[8] = (char) ('0' + i % 10);
LOG4CXX_DEBUG(logger, msg);
}
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/log4cxx/src/test/cpp/net/telnetappendertestcase.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    for (int i = 0; i < 50; i++) {
        LOG4CXX_INFO(root, "Hello, World " << i);
    }

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/log4cxx/src/test/cpp/net/sockethubappendertestcase.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    for(int i = 0; i < 50; i++) {
        LOG4CXX_INFO(root, "Hello, World " << i);
    }

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/log4cxx/src/test/cpp/varia/levelmatchfiltertestcase.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        for (int x = 0; x < length; x++)
        {
                // set the level to match
                matchFilter->setLevelToMatch(levelArray[x]->toString());
                LogString sbuf(LOG4CXX_STR("pass "));
                StringHelper::toString(x, pool, sbuf);
                sbuf.append(LOG4CXX_STR("; filter set to accept only "));
                sbuf.append(levelArray[x]->toString());
                sbuf.append(LOG4CXX_STR(" msgs"));
                common(sbuf);
        }

        for (int x = 0; x < length; x++)
        {
                // set the level to match
                matchFilter->setLevelToMatch(levelArray[x]->toString());
                LogString sbuf(LOG4CXX_STR("pass "));

                StringHelper::toString(x, pool, sbuf);
                sbuf.append(LOG4CXX_STR("; filter set to deny only "));
                sbuf.append(levelArray[x]->toString());
                sbuf.append(LOG4CXX_STR(" msgs"));
                common(sbuf);
        }

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/log4cxx/src/test/cpp/varia/levelrangefiltertestcase.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        for (int x = 0; x < length; x++)
        {
                // set the min level to match
                rangeFilter->setLevelMin(levelArray[x]);

                for (int y = length - 1; y >= 0; y--)
                {
                        // set max level to match
                        rangeFilter->setLevelMax(levelArray[y]);

                        sbuf.assign(LOG4CXX_STR("pass "));
                        StringHelper::toString(passCount, pool, sbuf);
                        sbuf.append(LOG4CXX_STR("; filter set to accept between "));
                        sbuf.append(levelArray[x]->toString());
                        sbuf.append(LOG4CXX_STR(" and "));
                        sbuf.append(levelArray[y]->toString());
                        sbuf.append(LOG4CXX_STR(" msgs"));
                        common(sbuf);

                        // increment passCount
                        passCount++;
                }
        }

        for (int x = 0; x < length; x++)
        {
                // set the min level to match
                rangeFilter->setLevelMin(levelArray[x]);

                for (int y = length - 1; y >= 0; y--)
                {
                        // set max level to match
                        rangeFilter->setLevelMax(levelArray[y]);

                        sbuf.assign(LOG4CXX_STR("pass "));
                        StringHelper::toString(passCount, pool, sbuf);
                        sbuf.append(LOG4CXX_STR("; filter set to accept between "));
                        sbuf.append(levelArray[x]->toString());
                        sbuf.append(LOG4CXX_STR(" and "));
                        sbuf.append(levelArray[y]->toString());
                        sbuf.append(LOG4CXX_STR(" msgs"));
                        common(sbuf);

                        // increment passCount
                        passCount++;
                }
        }

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/log4cxx/src/main/cpp/dailyrollingfileappender.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (size_t i = 0; i < datePattern.length(); i++) {
if (datePattern[i] == 0x27 /* '\'' */) {
inLiteral = !inLiteral;

if (inLiteral && inPattern) {
pattern.append(1, (logchar) 0x7D /* '}' */);
inPattern = false;
}
} else {
if (!inLiteral && !inPattern) {
const logchar dbrace[] = { 0x25, 0x64, 0x7B, 0 }; // "%d{"
pattern.append(dbrace);
inPattern = true;
}

pattern.append(1, datePattern[i]);
}
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/log4cxx/src/main/cpp/filterbasedtriggeringpolicy.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for(log4cxx::spi::FilterPtr f = headFilter; f != NULL; f = f->getNext()) {
switch(f->decide(event)) {
case Filter::DENY:
 return false;

case Filter::ACCEPT:
 return true;

case Filter::NEUTRAL:
 break;
}
}

for(log4cxx::spi::FilterPtr f = headFilter; f != NULL; f = f->getNext()) {
f->activateOptions(p);
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/log4cxx/src/main/cpp/nameabbreviator.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (LogString::size_type i = count; i > 0; i--) {
end = buf.rfind(0x2E /* '.' */, end - 1);

if ((end == LogString::npos) || (end < nameStart)) {
  return;
}
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/log4cxx/src/main/cpp/logger.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for(AppenderList::iterator it=appenders.begin(); it!=appenders.end(); ++it)
{
(*it)->close();
}

for(const Logger * l = this; l != 0; l=l->parent)
{
        if(l->level != 0)
        {
                return l->level;
        }
}

for (LoggerPtr l(const_cast<Logger*>(this)); l != 0; l = l->parent)
{
        if (l->resourceBundle != 0)
        {
                return l->resourceBundle;
        }
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/log4cxx/src/main/cpp/defaultconfigurator.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    for (int i = 0; names[i] != 0; i++) {
        File candidate(names[i]);
        if (candidate.exists(pool)) {
            configuration = candidate;
            break;
        }
    }

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/log4cxx/src/main/cpp/propertysetter.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (it = names.begin(); it != names.end(); it++)
{
        LogString key = *it;

        // handle only properties that start with the desired frefix.
        if (key.find(prefix) == 0)
        {
                // ignore key if it contains dots after the prefix
                if (key.find(0x2E /* '.' */, len + 1) != LogString::npos)
                {
                        continue;
                }

                LogString value = OptionConverter::findAndSubst(key, properties);
                key = key.substr(len);
                if (key == LOG4CXX_STR("layout")
                        && obj != 0
                        && obj->instanceof(Appender::getStaticClass()))
                {
                        continue;
                }
                setProperty(key, value, p);
        }
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/log4cxx/src/main/cpp/file.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for(char* c = src; *c != 0; c++) {
if(*c == '\\') {
*c = '/';
}
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/log4cxx/src/main/cpp/smtpappender.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
      for (int i = 0; i < fields; i++) {
        int flag = request[i].flags & 0x07;
        if (flag == AUTH_USER) {
           result[i] = pThis->user;
        } else if(flag == AUTH_PASS) {
           result[i] = pThis->pwd;
        }
      }

for(int i = 0; i < len; i++)
{
 LoggingEventPtr event = cb.get();
 layout->format(sbuf, event, p);
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/log4cxx/src/main/cpp/loggingevent.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        for (it = mdcCopy->begin(); it != mdcCopy->end(); it++)
        {
                set.push_back(it->first);

        }

            for(MDC::Map::const_iterator it = m.begin(); it != m.end(); it++) {
                set.push_back(it->first);
            }

        for (it = properties->begin(); it != properties->end(); it++)
        {
                set.push_back(it->first);
        }

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/log4cxx/src/main/cpp/properties.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (it = properties->begin(); it != properties->end(); it++)
{
        const LogString& key = it->first;
        names.push_back(key);
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/log4cxx/src/main/cpp/charsetdecoder.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
          for (; i < in.limit() && ((unsigned int) *p) < 0x80; i++, p++) {
              out.append(1, *p);
          }

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/log4cxx/src/main/cpp/simpledateformat.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
                for(; valueIter != values.end(); valueIter++) {
                    PUT_FACET(facet, os, &time, (wchar_t) wspec);
                    Transcoder::decode(os.str().substr(start), *valueIter);
                    start = os.str().length();
                    (*inc)(time, aprtime);
                }

                for(; valueIter != values.end(); valueIter++) {
                    PUT_FACET(facet, os, &time, spec);
                    Transcoder::decode(os.str().substr(start), *valueIter);
                    start = os.str().length();
                    (*inc)(time, aprtime);
                }

        for(; valueIter != values.end(); valueIter++) {
            apr_status_t stat = apr_strftime(buf, &retsize, BUFSIZE, aprspec, &aprtime);
            (*inc)(time, aprtime);
            if (stat == APR_SUCCESS) {
                Transcoder::decode(std::string(buf, retsize), *valueIter);
            } else {
                valueIter->append(1, (logchar) 0x3F);
            }
        }

for ( size_t i = hours.length(); i-- > 0; )
{
s[hourPos--] = hours[i];
}

for ( size_t j = min.length(); j-- > 0; )
{
s[minPos--] = min[j];
}

       for ( iter++; iter != fmt.end(); iter++ )
       {
         if ( * iter == prevChar )
         {
           repeat++;
         }
         else
         {
           addToken( prevChar, repeat, locale, pattern );
           prevChar = * iter;
           repeat = 1;
         }
       }

for ( PatternTokenList::iterator iter = pattern.begin(); iter != pattern.end(); iter++ )
{
( * iter )->setTimeZone( timeZone );
}

for ( PatternTokenList::iterator iter = pattern.begin(); iter != pattern.end(); iter++ )
{
( * iter )->setTimeZone( timeZone );
}

for ( PatternTokenList::iterator iter = pattern.begin(); iter != pattern.end(); iter++ )
{
delete * iter;
}

for ( PatternTokenList::const_iterator iter = pattern.begin(); iter != pattern.end(); iter++ )
{
( * iter )->format( s, exploded, p );
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/log4cxx/src/main/cpp/cyclicbuffer.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for(i = 0; i < loopLen; i++)
{
        temp[i] = ea[first];
        ea[first] = 0;
        if(++first == numElems)
        first = 0;
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/log4cxx/src/main/cpp/fixedwindowrollingpolicy.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (int i = lowIndex; i <= highIndex; i++) {
File toRenameCompressed;
toRenameCompressed.setPath(lowFilename);
File toRenameBase;
toRenameBase.setPath(lowFilename.substr(0, lowFilename.length() - suffixLength));
File* toRename = &toRenameCompressed;
bool isBase = false;
bool exists = toRenameCompressed.exists(p);

if (suffixLength > 0) {
if (exists) {
if (toRenameBase.exists(p)) {
  toRenameBase.deleteFile(p);
}
} else {
toRename = &toRenameBase;
exists = toRenameBase.exists(p);
isBase = true;
}
}

if (exists) {
//
//    if at upper index then
//        attempt to delete last file
//        if that fails then abandon purge
if (i == highIndex) {
if (!toRename->deleteFile(p)) {
  return false;
}

break;
}

//
//   if intermediate index
//     add a rename action to the list
buf.erase(buf.begin(), buf.end());
obj = new Integer(i + 1);
formatFileName(obj, buf, p);

LogString highFilename(buf);
LogString renameTo(highFilename);

if (isBase) {
renameTo =
  highFilename.substr(0, highFilename.length() - suffixLength);
}

renames.push_back(new FileRenameAction(*toRename, File().setPath(renameTo), true));
lowFilename = highFilename;
} else {
break;
}
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/log4cxx/src/main/cpp/patternparser.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (int i = converterId.length(); i > 0; i--) {
converterName = converterName.substr(0, i);
PatternMap::const_iterator iter = rules.find(converterName);
if (iter != rules.end()) {
currentLiteral.erase(currentLiteral.begin(),
  currentLiteral.end() - (converterId.length() - i));
return (iter->second)(options);
}
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/log4cxx/src/main/cpp/cacheddateformat.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (LogString::size_type i = 0; i < formatted.length(); i++) {
if (formatted[i] != plusMagic[i]) {
   //
   //   determine the expected digits for the base time
   const logchar abc[] = { 0x41, 0x42, 0x43, 0 };
   LogString formattedMillis(abc);
   millisecondFormat(millis, formattedMillis, 0);

   LogString plusZero;
   formatter->format(plusZero, slotBegin, pool);

   //   If the next 3 characters match the magic
   //      strings and the remaining fragments are identical
   //
   //
   if (plusZero.length() == formatted.length()
      && regionMatches(magicString, 0, plusMagic, i, magicString.length())
      && regionMatches(formattedMillis, 0, formatted, i, magicString.length())
      && regionMatches(zeroString, 0, plusZero, i, 3)
      && (formatted.length() == i + 3
         || plusZero.compare(i + 3,
               LogString::npos, plusMagic, i+3, LogString::npos) == 0)) {
      return i;
   } else {
      return UNRECOGNIZED_MILLISECONDS;
  }
}
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/log4cxx/src/main/cpp/hierarchy.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for(it = clonedList.begin(); it != itEnd; it++)
{
        listener = *it;
        listener->addAppenderEvent(logger, appender);
}

for(it = clonedList.begin(); it != itEnd; it++)
{
        listener = *it;
        listener->removeAppenderEvent(logger, appender);
}

for (it = loggers->begin(); it != itEnd; it++)
{
        v.push_back(it->second);
}

for (it = loggers1.begin(); it != itEnd; it++)
{
        LoggerPtr& logger = *it;
        logger->setLevel(0);
        logger->setAdditivity(true);
        logger->setResourceBundle(0);
}

for (it = loggers1.begin(); it != itEnd; it++)
{
        LoggerPtr& logger = *it;
        logger->closeNestedAppenders();
}

for (it = loggers1.begin(); it != itEnd; it++)
{
        LoggerPtr& logger = *it;
        logger->removeAllAppenders();
}

for(it = pn.begin(); it != itEnd; it++)
{
        LoggerPtr& l = *it;

        // Unless this child already points to a correct (lower) parent,
        // make cat.parent point to l.parent and l.parent to cat.
        if(!StringHelper::startsWith(l->parent->name, logger->name))
        {
                logger->parent = l->parent;
                l->parent = logger;
        }
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/log4cxx/src/main/cpp/appenderattachableimpl.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for(it = appenderList.begin(); it != itEnd; it++)
{
        appender = *it;
        if(name == appender->getName())
        {
                return appender;
        }
}

for(it = appenderList.begin(); it != itEnd; it++)
{
a = *it;
a->close();
}

for(it = appenderList.begin(); it != itEnd; it++)
{
        appender = *it;
        if(name == appender->getName())
        {
                appenderList.erase(it);
                return;
        }
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/log4cxx/src/main/cpp/odbcappender.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (i = buffer.begin(); i != buffer.end(); i++)
{
try
{
 const LoggingEventPtr& logEvent = *i;
 LogString sql = getLogStatement(logEvent, p);
 execute(sql, p);
}
catch (SQLException& e)
{
 errorHandler->error(LOG4CXX_STR("Failed to excute sql"), e,
    ErrorCode::FLUSH_FAILURE);
}
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/log4cxx/src/main/cpp/fallbackerrorhandler.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for(size_t i = 0; i < loggers.size(); i++)
{
        LoggerPtr& l = (LoggerPtr&)loggers.at(i);
        LogLog::debug(((LogString) LOG4CXX_STR("FB: Searching for ["))
            + primary->getName() + LOG4CXX_STR("] in logger [")
            + l->getName() + LOG4CXX_STR("]."));
        LogLog::debug(((LogString) LOG4CXX_STR("FB: Replacing ["))
           + primary->getName() + LOG4CXX_STR("] by [")
           + backup->getName() + LOG4CXX_STR("] in logger [")
           + l->getName() + LOG4CXX_STR("]."));
        l->removeAppender(primary);
        LogLog::debug(((LogString) LOG4CXX_STR("FB: Adding appender ["))
            + backup->getName() + LOG4CXX_STR("] to logger ")
            + l->getName());
        l->addAppender(backup);
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/log4cxx/src/examples/cpp/console.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (int i = 1; i < argc; i++) {
if (strcmp("-err", argv[i]) == 0) {
    err = true;
} else if (strcmp("puts", argv[i]) == 0) {
    fputs("Hello, fputs\n", err ? stderr : stdout);
#if LOG4CXX_WCHAR_T_API
} else if (strcmp("putws", argv[i]) == 0) {
    fputws(L"Hello, fputws\n", err ? stderr : stdout);
#endif
} else if (strcmp("cout", argv[i]) == 0) {
    if (err) {
        std::cerr << "Hello, cout" << std::endl;
    } else {
        std::cout << "Hello, cout" << std::endl;
    }
} else if (strcmp("wcout", argv[i]) == 0) {
    if (err) {
    #if LOG4CXX_HAS_STD_WCOUT
        std::wcerr << L"Hello, wcout" << std::endl;
    #else
        std::cerr << "Log4cxx has not wcout" << std::endl;
    #endif
    } else {
    #if LOG4CXX_HAS_STD_WCOUT
        std::wcout << L"Hello, wcout" << std::endl;
    #else
        std::cout << "Log4cxx has not wcout" << std::endl;
    #endif
    }
} else if (strcmp("configure", argv[i]) == 0) {
    configure(err);
    configured = true;
} else if (strcmp("log", argv[i]) == 0) {
    if (!configured) {
        configure(err);
        configured = true;
    }
    log4cxx::Logger::getRootLogger()->info("Hello, log4cxx");
#if LOG4CXX_WCHAR_T_API
} else if (strcmp("wide", argv[i]) == 0) {
    fwide(err ? stderr : stdout, 1);
} else if (strcmp("byte", argv[i]) == 0) {
    fwide(err ? stderr : stdout, -1);
#endif
} else {
    fputs("Unrecognized option: ", stderr);
    fputs(argv[i], stderr);
    fputs("\n", stderr);
    fflush(stderr);
}
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLibXL/qlxl/conversions/opertovector.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    for (int i=0; i<size; ++i) {
        a[i] = ObjectHandler::convert2<double>(ObjectHandler::ConvertOper(xMulti->val.array.lparray[i]));
    }

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLibXL/qlxl/conversions/matrixtooper.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (unsigned int i=0; i<m.rows(); ++i)
    for (unsigned int j=0; j<m.columns(); ++j)
        scalarToOper(m[i][j], xMatrix.val.array.lparray[i * m.columns() + j]);

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLibXL/qlxl/conversions/opertomatrix.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
for (int i=0; i<fpVector.rows; ++i)
    for (int j=0; j<fpVector.columns; ++j)
        m[i][j] = fpVector.array[i * fpVector.columns + j];

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

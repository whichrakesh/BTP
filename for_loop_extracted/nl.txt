for(i = 0; i < m1 * n1; i++)
    {
        
        newMatrixOfDouble[i] = matrixOfDouble[i] * 2;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < m2 * n2; i++)
    {
        
        newMatrixOfBoolean[i] = matrixOfBoolean[i] == TRUE ? FALSE : TRUE;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < m1 * n1; i++)
    {
        
        matrixOfDouble[i] = multiplybypi(matrixOfDouble[i]);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i<size1; i++) {
      jstring j_string = (jstring)(*jenv)->GetObjectArrayElement(jenv, jarg1, i);
      const char * c_string = (*jenv)->GetStringUTFChars(jenv, j_string, 0);
      arg1[i] = MALLOC((strlen(c_string)+1)*sizeof(const char *));
      strcpy(arg1[i], c_string);
      (*jenv)->ReleaseStringUTFChars(jenv, j_string, c_string);
      (*jenv)->DeleteLocalRef(jenv, j_string);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<size1-1; i++) {
      FREE(arg1[i]);
      arg1[i] = NULL;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
    {
        putchar(' ');
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < sizedictionary; i++)
        {
            int newlenLine = lenCurrentLine + (int)strlen(dictionary[i]) + (int)strlen(" ");

            if ((lenCurrentLine + newlenLine) > MAX_LINE_SIZE)
            {
                printf("\n");
                lenCurrentLine = 0;
            }
            else
            {
                lenCurrentLine = newlenLine;
            }
            printf("%s", dictionary[i]);
            printf("%s", " ");
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i < argc; i++)
    {
        if (strcmp(argv[i], "-nw") == 0)
        {
            setScilabMode(SCILAB_NW);
        }
        else if (strcmp(argv[i], "-nwni") == 0 || strcmp(argv[i], "-nogui") == 0)
        {
            setScilabMode(SCILAB_NWNI);
        }
        else if (strcmp(argv[i], "-display") == 0 || strcmp(argv[i], "-d") == 0)
        {
            
            char dpy[128];

            sprintf(dpy, "DISPLAY=%s", argv[++i]);
            putenv(dpy);
        }
        else if (strcmp(argv[i], "-l") == 0)
        {
            char *argLang = strdup(argv[++i]);

            

            if (strcmp(argLang, "en") == 0)
            {
                
                setenvc("LANG", "en_US");
            }
            else
            {
                if (strcmp(argLang, "fr") == 0)
                {
                    
                    setenvc("LANG", "fr_FR");
                }
                else
                {
                    setenvc("LANG", argLang);
                }
            }

	    free(argLang);

        }
        else if (strcmp(argv[i], "-ns") == 0)
        {
            no_startup_flag = 1;
        }
        else if (strcmp(argv[i], "-mem") == 0)
        {
            i++;
            memory = Max(atoi(argv[i]), MIN_STACKSIZE);
        }
        else if (strcmp(argv[i], "-f") == 0)
        {
            initial_script = argv[++i];
        }
        else if (strcmp(argv[i], "-e") == 0)
        {
            initial_script = argv[++i];
            initial_script_type = SCILAB_CODE;
        }
        else if (strcmp(argv[i], "--texmacs") == 0)
        {
            setScilabMode(SCILAB_NW);
            settexmacs();
        }
        else if (strcmp(argv[i], "-nocolor") == 0)
        {
            setCLIColor(FALSE);
        }
        else if (strcmp(argv[i], "-version") == 0)
        {
            disp_scilab_version();
            exit(1);
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < argc; i++)
        {
            pNewArgv[i] = (char *)malloc((strlen(argv[i]) + 1) * sizeof(char));
            strcpy(pNewArgv[i], argv[i]);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < CURRENT_MAX_LINE_SIZE; i++)
        {
            cur_line[i] = '\0';
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = cur_pos; i < max_pos; i++)
    {
        cur_line[i] = '\0';
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = cur_pos; i < max_pos; i++)
    {
        TerminalPutc(VK_SPACE);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = cur_pos; i < max_pos; i++)
    {
        backSpace ();
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = cur_pos; i < max_pos; i++)
        {
            cur_line[i] = cur_line[i + 1];
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = cur_pos; i < max_pos; i++)
            {
                cur_line[i] = cur_line[i + 1];
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = max_pos; i > cur_pos; i--)
    {
        backSpace ();
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = cur_pos; i < max_pos; i++)
    {
        TerminalPutc(cur_line[i]);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = max_pos + 1; i > cur_pos; i--)
    {
        backSpace ();
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < max_pos; i++)
    {
        cur_line[i] = '\0';
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < max_pos; i++)
    {
        TerminalPutc(VK_SPACE);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = max_pos; i > cur_pos; i--)
    {
        cur_line[i] = cur_line[i - 1];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0;i < sizedictionary;i++)
        {
            int newlenLine = lenCurrentLine + (int)strlen(dictionary[i]) + (int)strlen(" ");
            if ( newlenLine >= (getColumnsSize() - 10) )
            {
                TerminalPrintf("\n");
                lenCurrentLine = 0;
            }
            else
            {
                lenCurrentLine = newlenLine;
            }

            TerminalPrintf(dictionary[i]);
            TerminalPrintf(" ");
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(;;)
	{
		unsigned char cur_char = TerminalGetchar();

		if (cur_char <= 0) return NULL;

		
		if (ismenu () == 1)
		{
			
			return NULL;
		}

		if ( (cur_char == CR_1) || (cur_char == CR_2) )
		{
			if ( isHistorySearch() )
			{
				putLineSearchedHistory();
			}
			else
			{
				char *line = getCurrentLine();
				TerminalPutc('\n');
				appendLineToScilabHistory(line);
				return line;
			}
		}
		else
		{
			TerminalPutc(cur_char);
			addCharacterCurrentLine(cur_char);
		}
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < gdim->rank; i++)
            {
                Sci_Plan->gdim.dims[i].n  = gdim->dims[i].n;
                Sci_Plan->gdim.dims[i].is = gdim->dims[i].is;
                Sci_Plan->gdim.dims[i].os = gdim->dims[i].os;
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < gdim->rank; i++)
                {
                    Sci_Plan->kind[i]  = kind[i];
                }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < gdim->howmany_rank; i++)
            {
                Sci_Plan->gdim.howmany_dims[i].n  = gdim->howmany_dims[i].n;
                Sci_Plan->gdim.howmany_dims[i].is = gdim->howmany_dims[i].is;
                Sci_Plan->gdim.howmany_dims[i].os = gdim->howmany_dims[i].os;
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < gdim1->rank; i++)
        {
            if (gdim1->dims[i].n  != gdim2->dims[i].n)
            {
                return(0);
            }
            if (gdim1->dims[i].is != gdim2->dims[i].is)
            {
                return(0);
            }
            if (gdim1->dims[i].os != gdim2->dims[i].os)
            {
                return(0);
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < gdim1->howmany_rank; i++)
        {
            if (gdim1->howmany_dims[i].n  != gdim2->howmany_dims[i].n)
            {
                return(0);
            }
            if (gdim1->howmany_dims[i].is != gdim2->howmany_dims[i].is)
            {
                return(0);
            }
            if (gdim1->howmany_dims[i].os != gdim2->howmany_dims[i].os)
            {
                return(0);
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < rank; i++)
    {
        if (kind1[i]  != kind2[i])
        {
            return(0);
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < ndims; i++)
    {
        lA = lA * dims[i];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < lA; i++)
        {
            if (Ai[i] != zero)
            {
                t = 0;
                break;
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i < nas2; i++)
        {
            if (Ar[iA * i] != Ar[iA * (nA - i)])
            {
                return 0;
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i <= nas2; i++)
        {
            if (Ar[iA * i] != Ar[iA * (nA - i)])
            {
                return 0;
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i < nas2; i++)
        {
            if (Ai[iA * i] != -Ai[iA * (nA - i)])
            {
                return 0;
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i <= nas2; i++)
        {
            if (Ai[iA * i] != -Ai[iA * (nA - i)])
            {
                return 0;
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 1; k < nAs2; k++)
        {
            l1 = jA * k + iA ;
            l2 = jA * (nA - k) + iA * (mA - 1);
            for(l = 1; l < mA; l++)
            {
                if (Ar[l1] != Ar[l2])
                {
                    return 0;
                }
                l1 += iA;
                l2 -= iA;
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 1; k < nAs2; k++)
        {
            l1 = jA * k + iA ;
            l2 = jA * (nA - k) + iA * (mA - 1);
            for(l = 1; l < mA; l++)
            {
                if ((Ar[l1] != Ar[l2]) || (Ai[l1] != -Ai[l2]))
                {
                    return 0;
                }
                l1 += iA;
                l2 -= iA;
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < ndims; i++)
    {
        
        l = 0;
        for(j = 0; j < ndims; j++)
        {
            if (j != i)
            {
                dims1[l] = dims[j];
                incr1[l] = incr[j];
                l++;
            }
        }
        r = check_ND_symmetry(Ar, Ai, ndims - 1, dims1, incr1);
        if (r != 1)
        {
            dims1 = NULL;
            incr1 = NULL;
            FREE(temp);
            return r;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < ndims; i++)
    {
        l1 += incr[i];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < ndims; i++)
    {
        l2 += (dims[i] - 1) * incr[i];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i < (ndims - 1); i++)
    {
        incr1[i] = incr1[i - 1] * (dims[i] - 1) ;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i < (ndims - 1); i++)
    {
        dims1[i] = dims1[i - 1] + (dims[i] - 2) * incr[i];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < ndims; i++)
    {
        nSub *= (dims[i] - 1);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nSubs2; i++)
        {

            if (Ar[l1] != Ar[l2])
            {
                return 0;
            }
            step = incr[0];
            for(j = ndims - 2; j >= 0; j--)
            {
                if ((i + 1) % incr1[j] == 0)
                {
                    step = -dims1[j] + incr[j + 1] ;
                    break;
                }
            }
            l1 += step;
            l2 -= step;
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nSubs2; i++)
        {
            if (Ar[l1] != Ar[l2] || Ai[l1] != -Ai[l2])
            {
                return 0;
            }
            step = incr[0];
            for(j = ndims - 2; j >= 0; j--)
            {
                if ((i + 1) % incr1[j] == 0)
                {
                    step = -dims1[j] + incr[j + 1] ;
                    break;
                }
            }
            l1 += step;
            l2 -= step;
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < ndims; i++)
                {
                    dims[i] = gdim.dims[i].n;
                    incr[i] = gdim.dims[i].is;
                }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i < gdim.howmany_rank; i++)
        {
            dims1[i] = dims1[i - 1] * gdim.howmany_dims[i].n;
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < gdim.howmany_rank; i++)
        {
            p += (gdim.howmany_dims[i].n - 1) * gdim.howmany_dims[i].is;
            incr1[i] = p;
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ir = 0; ir < gdim.howmany_rank; ir++)
                    {
                        j = 0;
                        for(i = 1; i <= m; i++)
                        {
                            if ((r = check_1D_symmetry(Ar + j, NULL, gdim.dims[0].n, gdim.dims[0].is)) != 1 )
                            {
                                return r;
                            }
                            j += gdim.howmany_dims[0].is;
                            for(k = gdim.howmany_rank - 2; k >= 0; k--)
                            {
                                if (i % dims1[k] == 0)
                                {
                                    j += -incr1[k] + gdim.howmany_dims[k + 1].is;
                                    break;
                                }
                            }
                        }
                    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ir = 0; ir < gdim.howmany_rank; ir++)
                    {
                        j = 0;
                        for(i = 1; i <= m; i++)
                        {
                            if ((r = check_1D_symmetry(Ar + j, Ai + j, gdim.dims[0].n, gdim.dims[0].is)) != 1 )
                            {
                                return r;
                            }
                            j += gdim.howmany_dims[0].is;
                            for(k = gdim.howmany_rank - 2; k >= 0; k--)
                            {
                                if (i % dims1[k] == 0)
                                {
                                    j += -incr1[k] + gdim.howmany_dims[k + 1].is;
                                    break;
                                }
                            }
                        }
                    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ir = 0; ir < gdim.howmany_rank; ir++)
                    {
                        j = 0;
                        for(i = 1; i <= m; i++)
                        {
                            if ((r = check_2D_symmetry(Ar + j, NULL, gdim.dims[0].n, gdim.dims[0].is,
                                                       gdim.dims[1].n, gdim.dims[1].is)) != 1 )
                            {
                                return r;
                            }
                            j += gdim.howmany_dims[0].is;

                            for(k = gdim.howmany_rank - 2; k >= 0; k--)
                            {
                                if (i % dims1[k] == 0)
                                {
                                    j += -incr1[k] + gdim.howmany_dims[k + 1].is;
                                    break;
                                }
                            }
                        }
                    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ir = 0; ir < gdim.howmany_rank; ir++)
                    {
                        j = 0;
                        for(i = 1; i <= m; i++)
                        {
                            if ((r = check_2D_symmetry(Ar + j, Ai + j, gdim.dims[0].n, gdim.dims[0].is,
                                                       gdim.dims[1].n, gdim.dims[1].is)) != 1 )
                            {
                                return r;
                            }
                            j += gdim.howmany_dims[0].is;
                            for(k = gdim.howmany_rank - 2; k >= 0; k--)
                            {
                                if (i % dims1[k] == 0)
                                {
                                    j += -incr1[k] + gdim.howmany_dims[k + 1].is;
                                    break;
                                }
                            }
                        }
                    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < ndims; i++)
                {
                    dims[i] = gdim.dims[i].n;
                    incr[i] = gdim.dims[i].is;
                }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ir = 0; ir < gdim.howmany_rank; ir++)
                {
                    j = 0;
                    for(i = 1; i <= m; i++)
                    {
                        if (Ai == NULL)
                        {
                            r = check_ND_symmetry(Ar + j, NULL, ndims, dims, incr);
                        }
                        else
                        {
                            r = check_ND_symmetry(Ar + j, Ai + j, ndims, dims, incr);
                        }
                        if (r <= 0)
                        {
                            FREE(dims);
                            FREE(incr);
                            FREE(dims1);
                            return r;
                        }
                        j += gdim.howmany_dims[0].is;
                        for(k = gdim.howmany_rank - 2; k >= 0; k--)
                        {
                            if (i % dims1[k] == 0)
                            {
                                j += -incr1[k] + gdim.howmany_dims[k + 1].is;
                                break;
                            }
                        }
                    }
                }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
            {
                Ar[l2] = Ar[l1];
                l1 += iA;
                l2 -= iA;
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
            {
                Ar[l2] = Ar[l1];
                Ai[l2] = -Ai[l1];
                l1 += iA;
                l2 -= iA;
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < n; j++)
            {
                for(i = 1; i < mA; i++)
                {
                    Ar[l2] = Ar[l1];
                    l1 += iA;
                    l2 -= iA;
                }
                step = -(mA - 1) * iA + jA;
                l1 += step;
                l2 -= step;
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < n; j++)
            {
                for(i = 1; i < mA; i++)
                {
                    Ar[l2] = Ar[l1];
                    Ai[l2] = -Ai[l1];
                    l1 += iA;
                    l2 -= iA;
                }
                step = -(mA - 1) * iA + jA;
                l1 += step;
                l2 -= step;
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < ndims; i++)
    {
        
        l = 0;
        for(j = 0; j < ndims; j++)
        {
            if (j != i)
            {
                dims1[l] = dims[j];
                incr1[l] = incr[j];
                l++;
            }
        }
        r = complete_ND_array(Ar, Ai, ndims - 1, dims1, incr1);
        if (r < 0)
        {
            dims1 = NULL;
            incr1 = NULL;
            FREE(temp);
            return r;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < ndims; i++)
    {
        l1 += incr[i];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < ndims; i++)
    {
        l2 += (dims[i] - 1) * incr[i];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i < (ndims - 1); i++)
    {
        incr1[i] = incr1[i - 1] * (dims[i] - 1) ;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i < (ndims - 1); i++)
    {
        dims1[i] = dims1[i - 1] + (dims[i] - 2) * incr[i];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < ndims; i++)
    {
        nSub *= (dims[i] - 1);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nSubs2; i++)
        {
            Ar[l2] = Ar[l1];
            step = incr[0];
            for(j = ndims - 2; j >= 0; j--)
            {
                if ((i + 1) % incr1[j] == 0)
                {
                    step = -dims1[j] + incr[j + 1] ;
                    break;
                }
            }
            l1 += step;
            l2 -= step;
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nSubs2; i++)
        {
            Ar[l2] = Ar[l1];
            Ai[l2] = -Ai[l1];
            step = incr[0];
            for(j = ndims - 2; j >= 0; j--)
            {
                if ((i + 1) % incr1[j] == 0)
                {
                    step = -dims1[j] + incr[j + 1] ;
                    break;
                }
            }
            l1 += step;
            l2 -= step;
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < ndims; i++)
                {
                    dims[i] = gdim.dims[i].n;
                    incr[i] = gdim.dims[i].is;
                }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i < hrank; i++)
        {
            dims1[i] = dims1[i - 1] * gdim.howmany_dims[i].n;
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i < hrank; i++)
        {
            incr1[i] = incr1[i - 1] + (gdim.howmany_dims[i].n - 1) * gdim.howmany_dims[i].is;;
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i <= m; i++)
                    {
                        complete_1D_array(Ar + j, NULL, gdim.dims[0].n, gdim.dims[0].is);
                        j += gdim.howmany_dims[0].is;
                        for(k = hrank - 2; k >= 0; k--)
                        {
                            if (i % dims1[k] == 0)
                            {
                                j += -incr1[k] + gdim.howmany_dims[k + 1].is;
                                break;
                            }
                        }
                    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i <= m; i++)
                    {
                        complete_1D_array(Ar + j, Ai + j, gdim.dims[0].n, gdim.dims[0].is);
                        j += gdim.howmany_dims[0].is;
                        for(k = hrank - 2; k >= 0; k--)
                        {
                            if (i % dims1[k] == 0)
                            {
                                j += -incr1[k] + gdim.howmany_dims[k + 1].is;
                                break;
                            }
                        }
                    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i <= m; i++)
                    {
                        complete_2D_array(Ar + j, NULL, gdim.dims[0].n, gdim.dims[0].is, gdim.dims[1].n, gdim.dims[1].is);
                        j += gdim.howmany_dims[0].is;
                        for(k = hrank - 2; k >= 0; k--)
                        {
                            if (i % dims1[k] == 0)
                            {
                                j += -incr1[k] + gdim.howmany_dims[k + 1].is;
                                break;
                            }
                        }
                    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i <= m; i++)
                    {
                        complete_2D_array(Ar + j, Ai + j, gdim.dims[0].n, gdim.dims[0].is, gdim.dims[1].n, gdim.dims[1].is);

                        j += gdim.howmany_dims[0].is;
                        for(k = hrank - 2; k >= 0; k--)
                        {
                            if (i % dims1[k] == 0)
                            {
                                j += -incr1[k] + gdim.howmany_dims[k + 1].is;
                                break;
                            }
                        }
                    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < ndims; i++)
                {
                    dims[i] = gdim.dims[i].n;
                    incr[i] = gdim.dims[i].is;
                }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i <= m; i++)
                {
                    if (Ai == NULL)
                    {
                        r = complete_ND_array(Ar + j, NULL, ndims, dims, incr);
                    }
                    else
                    {
                        r = complete_ND_array(Ar + j, Ai + j, ndims, dims, incr);
                    }
                    if (r < 0)
                    {
                        FREE(dims);
                        FREE(incr);
                        FREE(dims1);
                        return r;
                    }
                    j += gdim.howmany_dims[0].is;
                    for(k = hrank - 2; k >= 0; k--)
                    {
                        if (i % dims1[k] == 0)
                        {
                            j += -incr1[k] + gdim.howmany_dims[k + 1].is;
                            break;
                        }
                    }
                }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i < nA; i++)
        {
            Ar[i * iA] *= s;
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i < nA; i++)
        {
            Ar[i * iA] *= s;
            Ai[i * iA] *= s;
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 1; j < nA; j++)
        {
            dct_scale_1D_array(&Ar[j * jA], NULL, mA, iA, isn, s);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 1; j < nA; j++)
        {
            dct_scale_1D_array(&Ar[j * jA], &Ai[j * jA], mA, iA, isn, s);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i < dims[0]; i++)
            {
                dct_scale_ND_array(&Ar[i * incr[0]], NULL, ndims - 1, dims + 1, incr + 1, isn, s);
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i < dims[0]; i++)
            {
                dct_scale_ND_array(&Ar[i * incr[0]], &Ai[i * incr[0]], ndims - 1, dims + 1, incr + 1, isn, s);
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < gdim.rank; i++)
                {
                    dims[i] = gdim.dims[i].n;
                    incr[i] = gdim.dims[i].is;
                }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i < hrank; i++)
        {
            dims1[i] = dims1[i - 1] * gdim.howmany_dims[i].n;
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i < hrank; i++)
        {
            incr1[i] = incr1[i - 1] + (gdim.howmany_dims[i].n - 1) * gdim.howmany_dims[i].is;;
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i <= m; i++)
                    {
                        dct_scale_1D_array(Ar + j, NULL, gdim.dims[0].n, gdim.dims[0].is, isn, (double)1.0);
                        j += gdim.howmany_dims[0].is;
                        for(k = hrank - 2; k >= 0; k--)
                        {
                            if (i % dims1[k] == 0)
                            {
                                j += -incr1[k] + gdim.howmany_dims[k + 1].is;
                                break;
                            }
                        }
                    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i <= m; i++)
                    {
                        dct_scale_1D_array(Ar + j, Ai + j, gdim.dims[0].n, gdim.dims[0].is, isn, (double)1.0);
                        j += gdim.howmany_dims[0].is;
                        for(k = hrank - 2; k >= 0; k--)
                        {
                            if (i % dims1[k] == 0)
                            {
                                j += -incr1[k] + gdim.howmany_dims[k + 1].is;
                                break;
                            }
                        }
                    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i <= m; i++)
                    {
                        dct_scale_2D_array(&Ar[j], NULL, gdim.dims[0].n, gdim.dims[0].is, gdim.dims[1].n, gdim.dims[1].is, isn, (double)1.0);
                        j += gdim.howmany_dims[0].is;
                        for(k = hrank - 2; k >= 0; k--)
                        {
                            if (i % dims1[k] == 0)
                            {
                                j += -incr1[k] + gdim.howmany_dims[k + 1].is;
                                break;
                            }
                        }
                    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i <= m; i++)
                    {
                        dct_scale_2D_array(&Ar[j], &Ai[j], gdim.dims[0].n, gdim.dims[0].is, gdim.dims[1].n, gdim.dims[1].is, isn, (double)1.0);

                        j += gdim.howmany_dims[0].is;
                        for(k = hrank - 2; k >= 0; k--)
                        {
                            if (i % dims1[k] == 0)
                            {
                                j += -incr1[k] + gdim.howmany_dims[k + 1].is;
                                break;
                            }
                        }
                    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < gdim.rank; i++)
                {
                    dims[i] = gdim.dims[i].n;
                    incr[i] = gdim.dims[i].is;
                }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i <= m; i++)
                {
                    if (Ai == NULL)
                    {
                        dct_scale_ND_array(Ar + j, NULL, gdim.rank, dims, incr, isn, (double)1.0);
                    }
                    else
                    {
                        dct_scale_ND_array(Ar + j, Ai + j, gdim.rank, dims, incr, isn, (double)1.0);
                    }

                    j += gdim.howmany_dims[0].is;
                    for(k = hrank - 2; k >= 0; k--)
                    {
                        if (i % dims1[k] == 0)
                        {
                            j += -incr1[k] + gdim.howmany_dims[k + 1].is;
                            break;
                        }
                    }
                }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nA; i++)
        {
            Ar[i * iA] *= s;
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nA; i++)
        {
            Ar[i * iA] *= s;
            Ai[i * iA] *= s;
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < nA; j++)
        {
            dst_scale_1D_array(&Ar[j * jA], NULL, mA, iA, isn, s);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < nA; j++)
        {
            dst_scale_1D_array(&Ar[j * jA], &Ai[j * jA], mA, iA, isn, s);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < dims[0]; i++)
            {
                dst_scale_ND_array(&Ar[i * incr[0]], NULL, ndims - 1, dims + 1, incr + 1, isn, s);
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < dims[0]; i++)
            {
                dst_scale_ND_array(&Ar[i * incr[0]], &Ai[i * incr[0]], ndims - 1, dims + 1, incr + 1, isn, s);
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < gdim.rank; i++)
                {
                    dims[i] = gdim.dims[i].n;
                    incr[i] = gdim.dims[i].is;
                }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i < hrank; i++)
        {
            dims1[i] = dims1[i - 1] * gdim.howmany_dims[i].n;
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i < hrank; i++)
        {
            incr1[i] = incr1[i - 1] + (gdim.howmany_dims[i].n - 1) * gdim.howmany_dims[i].is;;
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i <= m; i++)
                    {
                        dst_scale_1D_array(Ar + j, NULL, gdim.dims[0].n, gdim.dims[0].is, isn, (double)1.0);
                        j += gdim.howmany_dims[0].is;
                        for(k = hrank - 2; k >= 0; k--)
                        {
                            if (i % dims1[k] == 0)
                            {
                                j += -incr1[k] + gdim.howmany_dims[k + 1].is;
                                break;
                            }
                        }
                    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i <= m; i++)
                    {
                        dst_scale_1D_array(Ar + j, Ai + j, gdim.dims[0].n, gdim.dims[0].is, isn, (double)1.0);
                        j += gdim.howmany_dims[0].is;
                        for(k = hrank - 2; k >= 0; k--)
                        {
                            if (i % dims1[k] == 0)
                            {
                                j += -incr1[k] + gdim.howmany_dims[k + 1].is;
                                break;
                            }
                        }
                    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i <= m; i++)
                    {
                        dst_scale_2D_array(&Ar[j], NULL, gdim.dims[0].n, gdim.dims[0].is, gdim.dims[1].n, gdim.dims[1].is, isn, (double)1.0);
                        j += gdim.howmany_dims[0].is;
                        for(k = hrank - 2; k >= 0; k--)
                        {
                            if (i % dims1[k] == 0)
                            {
                                j += -incr1[k] + gdim.howmany_dims[k + 1].is;
                                break;
                            }
                        }
                    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i <= m; i++)
                    {
                        dst_scale_2D_array(&Ar[j], &Ai[j], gdim.dims[0].n, gdim.dims[0].is, gdim.dims[1].n, gdim.dims[1].is, isn, (double)1.0);

                        j += gdim.howmany_dims[0].is;
                        for(k = hrank - 2; k >= 0; k--)
                        {
                            if (i % dims1[k] == 0)
                            {
                                j += -incr1[k] + gdim.howmany_dims[k + 1].is;
                                break;
                            }
                        }
                    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < gdim.rank; i++)
                {
                    dims[i] = gdim.dims[i].n;
                    incr[i] = gdim.dims[i].is;
                }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i <= m; i++)
                {
                    if (Ai == NULL)
                    {
                        dst_scale_ND_array(Ar + j, NULL, gdim.rank, dims, incr, isn, (double)1.0);
                    }
                    else
                    {
                        dst_scale_ND_array(Ar + j, Ai + j, gdim.rank, dims, incr, isn, (double)1.0);
                    }

                    j += gdim.howmany_dims[0].is;
                    for(k = hrank - 2; k >= 0; k--)
                    {
                        if (i % dims1[k] == 0)
                        {
                            j += -incr1[k] + gdim.howmany_dims[k + 1].is;
                            break;
                        }
                    }
                }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < ndims; i++)   n *= dims[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < ndims; i++) n *= dims[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < ndims; i++)  Dim[i] = (int)(p_d[i]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < ndims; i++) Dim[i]  = (int)(p_c[i]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < ndims; i++) Dim[i]  = (int)(p_s[i]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < ndims; i++)  Dim[i]  = (int)(p_i[i]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < ndims; i++) Dim[i]  = (int)(p_uc[i]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < ndims; i++) Dim[i]  = (int) p_us[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < ndims; i++) Dim[i]  = (int)(p_ui[i]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < ndimsA; i++)
    {
        if (dimsA[i] > 1)
        {
            ndims++;
            if (first_nonsingleton < 0)
            {
                first_nonsingleton = i;
            }
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = (first_nonsingleton); i < ndimsA; i++)
    {
        if (dimsA[i] > 1)
        {
            gdim.dims[j].n = dimsA[i];
            gdim.dims[j].is = prd;
            gdim.dims[j].os = prd;
            prd *= dimsA[i];
            j++;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < ndimsA; i++)
    {
        if (dimsA[i] > 1)
        {
            ndims++;
            if (first_nonsingleton < 0)
            {
                first_nonsingleton = i;
            }
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < rank; i++)
    {
        if (Sel[i] <= 0)
        {
            Scierror(999, _("%s: Wrong values for input argument #%d: Positive integers expected.\n"), fname, 3);
            FREE(gdim.dims);
            FREE(gdim.howmany_dims);
            return 0;
        }
        if (Sel[i] > ndimsA)
        {
            Scierror(999, _("%s: Wrong values for input argument #%d: Elements must be less than %d.\n"), fname, 3, ndimsA);
            FREE(gdim.dims);
            FREE(gdim.howmany_dims);
            return 0;
        }
        if (i > 0 && Sel[i] <= Sel[i - 1])
        {
            Scierror(999, _("%s: Wrong values for input argument #%d: Elements must be in increasing order.\n"), fname, 3);
            FREE(gdim.dims);
            FREE(gdim.howmany_dims);
            return 0;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < ndimsA; i++)
    {
        if (j >= gdim.rank)
        {
            break;
        }
        if (Sel[j] == i + 1)
        {
            gdim.dims[j].n = dimsA[i];
            gdim.dims[j].is = pd;
            gdim.dims[j].os = pd;
            j++;
        }
        pd *= dimsA[i];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i <= rank - 1; i++)
    {
        if (Sel[i] != Sel[i - 1] + 1)
        {
            


            for(j = Sel[i - 1] + 1; j <= Sel[i] - 1; j++)
            {
                if (dimsA[j - 1] != 1)
                {
                    gdim.howmany_rank++;
                    break;
                }
            }
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 1; j <= (Sel[0] - 1); j++)
        {
            pd *= dimsA[j - 1];    
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i <= rank - 1; i++)
        {
            
            if (Sel[i] != Sel[i - 1] + 1)
            {
                pds = 1;
                for(j = (Sel[i - 1] + 1); j <= (Sel[i] - 1); j++)
                {
                    pds *= dimsA[j - 1];    
                }
                


                for(j = (Sel[i - 1] + 1); j <= (Sel[i] - 1); j++)
                {
                    if (dimsA[j - 1] != 1)
                    {
                        gdim.howmany_dims[ih].is = pd;
                        gdim.howmany_dims[ih].os = pd;
                        gdim.howmany_dims[ih].n = pds;
                        ih++;
                        break;
                    }
                }
            }
            pd *= pds * dimsA[Sel[i] - 1]; 
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = (Sel[rank - 1] + 1); j <= ndimsA; j++)
            {
                pds *= dimsA[j - 1];    
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < ndimsA; i++)
    {
        lA *= dimsA[i];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < ndims; i++)
    {
        if (Dim1[i] <= 1)
        {
            Scierror(999, _("%s: Wrong values for input argument #%d: Elements must be greater than %d.\n"), fname, 3, 1);
            FREE(Dim1);
            FREE(Incr);
            FREE(Dim);
            FREE(Sel);
            FREE(gdim.dims);
            FREE(gdim.howmany_dims);
            return 0;
        }
        pd *= Dim1[i];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < ndims; i++)
    {
        if (lA % Incr[i])
        {
            Scierror(999, _("%s: Wrong values for input argument #%d: Elements must be divisors of %d.\n"), fname, 3, lA);
            FREE(Dim1);
            FREE(Incr);
            FREE(Dim);
            FREE(Sel);
            FREE(gdim.dims);
            FREE(gdim.howmany_dims);
            return 0;
        }
        if (i > 0 && (Incr[i] <= Incr[i - 1]))
        {
            Scierror(999, _("%s: Wrong values for input argument #%d: Elements must be in increasing ""order.\n"), fname, 4);
            FREE(Dim1);
            FREE(Incr);
            FREE(Dim);
            FREE(Sel);
            FREE(gdim.dims);
            FREE(gdim.howmany_dims);
            return 0;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 1; k < ndims; k++)
    {
        if (Incr[k] % pd != 0)
        {
            Scierror(999, _("%s: Incompatible input arguments #%d and #%d.\n"), fname, 3, 4);
            FREE(Dim1);
            FREE(Incr);
            FREE(Dim);
            FREE(Sel);
            FREE(gdim.dims);
            FREE(gdim.howmany_dims);
            return 0;
        }
        if (Incr[k] != pd)
        {
            Dim[nd++] = (int)(Incr[k] / pd);
            pd = Incr[k];
        }
        Dim[nd++] = Dim1[k];
        pd *= Dim1[k];
        Sel[k] = nd;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < ndims; i++)
    {
        if (j >= gdim.rank)
        {
            break;
        }
        if (Sel[j] == i + 1)
        {
            gdim.dims[j].n = Dim[i];
            gdim.dims[j].is = pd;
            gdim.dims[j].os = pd;
            j++;
        }
        pd *= Dim[i];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i <= rank - 1; i++)
    {
        if (Sel[i] != Sel[i - 1] + 1)
        {
            


            for(j = Sel[i - 1] + 1; j <= Sel[i] - 1; j++)
            {
                if (Dim[j - 1] != 1)
                {
                    gdim.howmany_rank++;
                    break;
                }
            }
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 1; j <= (Sel[0] - 1); j++)
        {
            pd *= Dim[j - 1];    
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i <= rank - 1; i++)
        {
            
            if (Sel[i] != Sel[i - 1] + 1)
            {
                pds = 1;
                for(j = (Sel[i - 1] + 1); j <= (Sel[i] - 1); j++)
                {
                    pds *= Dim[j - 1];    
                }
                


                for(j = (Sel[i - 1] + 1); j <= (Sel[i] - 1); j++)
                {
                    if (Dim[j - 1] != 1)
                    {
                        gdim.howmany_dims[ih].is = pd;
                        gdim.howmany_dims[ih].os = pd;
                        gdim.howmany_dims[ih].n = pds;
                        ih++;
                        break;
                    }
                }
            }

            pd *= pds * Dim[Sel[i] - 1]; 
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = (Sel[rank - 1] + 1); j <= ndims; j++)
            {
                pds *= Dim[j - 1];    
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < ndimsA; i++)
    {
        lA *= dimsA[i];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < gdim.rank; i++)
            {
                kind[i] = FFTW_REDFT10;
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < gdim.rank; i++)
            {
                kind[i] = FFTW_REDFT00;
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < gdim.rank; i++)
            {
                kind[i] = FFTW_REDFT11;
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < gdim.rank; i++)
            {
                kind[i] = FFTW_REDFT01;
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < gdim.rank; i++)
            {
                kind[i] = FFTW_REDFT00;
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < gdim.rank; i++)
            {
                kind[i] = FFTW_REDFT11;
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i < howmany_rank; i++)
        {
            dims1[i] = dims1[i - 1] * howmany_dims[i].n;
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < howmany_rank; i++)
        {
            t += (howmany_dims[i].n - 1) * howmany_dims[i].is;
            incr1[i] = t;
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i1 = 1; i1 <= nloop; i1++)
        {
            


            ExecuteFFTWPlan(type, p, &Ar[i], NULL, &Ar[i], NULL);
            if (!isrealA)
            {
                ExecuteFFTWPlan(type, p, &Ai[i], NULL, &Ai[i], NULL);
            }

            i += howmany_dims[0].is;
            
            for(i2 = howmany_rank - 2; i2 >= 0; i2--)
            {
                if ((i1 % dims1[i2]) == 0)
                {
                    
                    i += howmany_dims[i2 + 1].is - incr1[i2];
                    break;
                }
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < m1 * n1; j++)
            {
                for(i = 0; i < nb_flag; i++)
                {
                    if (strcmp(Str1[j], Str[i]) == 0) break;
                }

                if (i == nb_flag)
                {
                    freeArrayOfString(Str1, m1 * n1);
                    Scierror(999, _("%s: Wrong values for input argument #%d: FFTW flag expected.\n"), fname, 1);
                    return 0;
                }
                else
                {
                    if (i > 0)
                    {
                        flagv = ( flagv | (1U << (i - 1)) );
                    }
                }
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1;i < nb_flag; i++)
        {
            if((getCurrentFftwFlags() & flagt[i]) == flagt[i])
            {
                j++;
                if (Str3)
                {
                    Str3 = (char **)REALLOC(Str3,sizeof(char *) * j);
                }
                else
                {
                    Str3 = (char **)MALLOC(sizeof(char *) * j);
                }

                if ( Str3 == NULL)
                {
                    Scierror(999, _("%s: No more memory.\n"), fname);
                    return 0;
                }

                Str3[j - 1] = strdup(Str[i]);
                if (Str3[j - 1] == NULL)
                {
                    freeArrayOfString(Str3, j);
                    Scierror(999, _("%s: No more memory.\n"), fname);
                    return 0;
                }
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < ndimsA; i++)
    {
        if (dimsA[i] > 1)
        {
            ndims++;
            if (first_nonsingleton < 0)
            {
                first_nonsingleton = i;
            }
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = (first_nonsingleton); i < ndimsA; i++)
    {
        if (dimsA[i] > 1)
        {
            gdim.dims[j].n = dimsA[i];
            gdim.dims[j].is = prd;
            gdim.dims[j].os = prd;
            prd *= dimsA[i];
            j++;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < ndimsA; i++)
    {
        if (dimsA[i] > 1)
        {
            ndims++;
            if (first_nonsingleton < 0)
            {
                first_nonsingleton = i;
            }
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < rank; i++)
    {
        if (Sel[i] <= 0)
        {
            Scierror(999, _("%s: Wrong values for input argument #%d: Positive integers expected.\n"), fname, 3);
            FREE(gdim.dims);
            FREE(gdim.howmany_dims);
            return 0;
        }
        if (Sel[i] > ndimsA)
        {
            Scierror(999, _("%s: Wrong values for input argument #%d: Elements must be less than %d.\n"), fname, 3, ndimsA);
            FREE(gdim.dims);
            FREE(gdim.howmany_dims);
            return 0;
        }
        if (i > 0 && Sel[i] <= Sel[i - 1])
        {
            Scierror(999, _("%s: Wrong values for input argument #%d: Elements must be in increasing order.\n"), fname, 3);
            FREE(gdim.dims);
            FREE(gdim.howmany_dims);
            return 0;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < ndimsA; i++)
    {
        if (j >= gdim.rank)
        {
            break;
        }
        if (Sel[j] == i + 1)
        {
            gdim.dims[j].n = dimsA[i];
            gdim.dims[j].is = pd;
            gdim.dims[j].os = pd;
            j++;
        }
        pd *= dimsA[i];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i <= rank - 1; i++)
    {
        if (Sel[i] != Sel[i - 1] + 1)
        {
            


            for(j = Sel[i - 1] + 1; j <= Sel[i] - 1; j++)
            {
                if (dimsA[j - 1] != 1)
                {
                    gdim.howmany_rank++;
                    break;
                }
            }
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 1; j <= (Sel[0] - 1); j++)
        {
            pd *= dimsA[j - 1];    
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i <= rank - 1; i++)
        {
            
            if (Sel[i] != Sel[i - 1] + 1)
            {
                pds = 1;
                for(j = (Sel[i - 1] + 1); j <= (Sel[i] - 1); j++)
                {
                    pds *= dimsA[j - 1];    
                }
                


                for(j = (Sel[i - 1] + 1); j <= (Sel[i] - 1); j++)
                {
                    if (dimsA[j - 1] != 1)
                    {
                        gdim.howmany_dims[ih].is = pd;
                        gdim.howmany_dims[ih].os = pd;
                        gdim.howmany_dims[ih].n = pds;
                        ih++;
                        break;
                    }
                }
            }
            pd *= pds * dimsA[Sel[i] - 1]; 
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = (Sel[rank - 1] + 1); j <= ndimsA; j++)
            {
                pds *= dimsA[j - 1];    
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < ndimsA; i++)
    {
        lA *= dimsA[i];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < ndims; i++)
    {
        if (Dim1[i] <= 1)
        {
            Scierror(999, _("%s: Wrong values for input argument #%d: Elements must be greater than %d.\n"), fname, 3, 1);
            FREE(Dim1);
            FREE(Incr);
            FREE(Dim);
            FREE(Sel);
            FREE(gdim.dims);
            FREE(gdim.howmany_dims);
            return 0;
        }
        pd *= Dim1[i];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < ndims; i++)
    {
        if (lA % Incr[i])
        {
            Scierror(999, _("%s: Wrong values for input argument #%d: Elements must be divisors of %d.\n"), fname, 3, lA);
            FREE(Dim1);
            FREE(Incr);
            FREE(Dim);
            FREE(Sel);
            FREE(gdim.dims);
            FREE(gdim.howmany_dims);
            return 0;
        }
        if (i > 0 && (Incr[i] <= Incr[i - 1]))
        {
            Scierror(999, _("%s: Wrong values for input argument #%d: Elements must be in increasing ""order.\n"), fname, 4);
            FREE(Dim1);
            FREE(Incr);
            FREE(Dim);
            FREE(Sel);
            FREE(gdim.dims);
            FREE(gdim.howmany_dims);
            return 0;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 1; k < ndims; k++)
    {
        if (Incr[k] % pd != 0)
        {
            Scierror(999, _("%s: Incompatible input arguments #%d and #%d.\n"), fname, 3, 4);
            FREE(Dim1);
            FREE(Incr);
            FREE(Dim);
            FREE(Sel);
            FREE(gdim.dims);
            FREE(gdim.howmany_dims);
            return 0;
        }
        if (Incr[k] != pd)
        {
            Dim[nd++] = (int)(Incr[k] / pd);
            pd = Incr[k];
        }
        Dim[nd++] = Dim1[k];
        pd *= Dim1[k];
        Sel[k] = nd;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < ndims; i++)
    {
        if (j >= gdim.rank)
        {
            break;
        }
        if (Sel[j] == i + 1)
        {
            gdim.dims[j].n = Dim[i];
            gdim.dims[j].is = pd;
            gdim.dims[j].os = pd;
            j++;
        }
        pd *= Dim[i];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i <= rank - 1; i++)
    {
        if (Sel[i] != Sel[i - 1] + 1)
        {
            


            for(j = Sel[i - 1] + 1; j <= Sel[i] - 1; j++)
            {
                if (Dim[j - 1] != 1)
                {
                    gdim.howmany_rank++;
                    break;
                }
            }
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 1; j <= (Sel[0] - 1); j++)
        {
            pd *= Dim[j - 1];    
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i <= rank - 1; i++)
        {
            
            if (Sel[i] != Sel[i - 1] + 1)
            {
                pds = 1;
                for(j = (Sel[i - 1] + 1); j <= (Sel[i] - 1); j++)
                {
                    pds *= Dim[j - 1];    
                }
                


                for(j = (Sel[i - 1] + 1); j <= (Sel[i] - 1); j++)
                {
                    if (Dim[j - 1] != 1)
                    {
                        gdim.howmany_dims[ih].is = pd;
                        gdim.howmany_dims[ih].os = pd;
                        gdim.howmany_dims[ih].n = pds;
                        ih++;
                        break;
                    }
                }
            }

            pd *= pds * Dim[Sel[i] - 1]; 
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = (Sel[rank - 1] + 1); j <= ndims; j++)
            {
                pds *= Dim[j - 1];    
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < ndimsA; i++)
    {
        lA *= dimsA[i];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < gdim.rank; i++)
            {
                kind[i] = FFTW_RODFT00;
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < gdim.rank; i++)
            {
                kind[i] = FFTW_RODFT10;
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < gdim.rank; i++)
            {
                kind[i] = FFTW_RODFT11;
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < gdim.rank; i++)
            {
                kind[i] = FFTW_RODFT00;
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < gdim.rank; i++)
            {
                kind[i] = FFTW_RODFT01;
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < gdim.rank; i++)
            {
                kind[i] = FFTW_RODFT11;
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i < howmany_rank; i++)
        {
            dims1[i] = dims1[i - 1] * howmany_dims[i].n;
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < howmany_rank; i++)
        {
            t += (howmany_dims[i].n - 1) * howmany_dims[i].is;
            incr1[i] = t;
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i1 = 1; i1 <= nloop; i1++)
        {
            


            ExecuteFFTWPlan(type, p, &Ar[i], NULL, &Ar[i], NULL);
            if (!isrealA)
            {
                ExecuteFFTWPlan(type, p, &Ai[i], NULL, &Ai[i], NULL);
            }

            i += howmany_dims[0].is;
            
            for(i2 = howmany_rank - 2; i2 >= 0; i2--)
            {
                if ((i1 % dims1[i2]) == 0)
                {
                    
                    i += howmany_dims[i2 + 1].is - incr1[i2];
                    break;
                }
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < (int)strlen(Str); i++)
        {
            if (Str[i] == '\n')
            {
                int len = 0;
                int k = 0;

                n1++;

                if (Str1)
                {
                    Str1 = (char **)REALLOC(Str1, sizeof(char *)*n1);
                }
                else
                {
                    Str1 = (char **)MALLOC(sizeof(char *)*n1);
                }

                if (Str1 == NULL)
                {
                    Scierror(999, _("%s: No more memory.\n"), fname);
                    if (Str)
                    {
                        // According to the FFTW documentation we should free Str
                        // string but doing makes Scilab crash!?
                        //free(Str);
                    }
                    return(0);
                }

                len = i - j;

                if ((Str1[n1 - 1] = (char *)MALLOC(sizeof(char) * (len + 1))) == NULL)
                {
                    freeArrayOfString(Str1, n1 - 1);
                    if (Str)
                    {
                        // According to the FFTW documentation we should free Str
                        // string but doing makes Scilab crash!?
                        //free(Str);
                    }
                    Scierror(999, _("%s: No more memory.\n"), fname);
                    return(0);
                }

                for(k = 0; k < len; k++)
                {
                    Str1[n1 - 1][k] = Str[k + j];
                }
                Str1[n1 - 1][len] = '\0';
                j = i + 1;
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < m1*n1; j++)
        {
            int i = 0;

            len += (int)strlen(Str1[j])+1;

            if (Str) Str = (char *)REALLOC(Str,sizeof(char)*(len));
            else Str = (char *)MALLOC(sizeof(char)*(len));

            if (Str == NULL)
            {
                freeArrayOfString(Str1,m1*n1);
                Scierror(999,_("%s: Cannot allocate more memory.\n"),fname);
                return(0);
            }

            for(i = 0; i < (int)strlen(Str1[j]); i++)
            {
                Str[k+i] = Str1[j][i];
            }
            Str[k+strlen(Str1[j])] = '\n';
            k += (int)strlen(Str1[j])+1;
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < ndimsA; i++)
    {
        if (dimsA[i] > 1)
        {
            ndims++;
            if (first_nonsingleton < 0) first_nonsingleton = i;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = (first_nonsingleton); i < ndimsA; i++)
    {
        if (dimsA[i] > 1)
        {
            gdim.dims[j].n = dimsA[i];
            gdim.dims[j].is = prd;
            gdim.dims[j].os = prd;
            prd *= dimsA[i];
            j++;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < ndimsA; i++)
    {
        if (dimsA[i] > 1)
        {
            ndims++;
            if (first_nonsingleton < 0) first_nonsingleton = i;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < rank; i++)
    {
        if (Sel[i] <= 0)
        {
            Scierror(999, _("%s: Wrong values for input argument #%d: Positive integers expected.\n"), fname, 3);
            FREE(gdim.dims);
            FREE(gdim.howmany_dims);
            return 0;
        }
        if (Sel[i] > ndimsA)
        {
            Scierror(999, _("%s: Wrong values for input argument #%d: Elements must be less than %d.\n"), fname, 3, ndimsA);
            FREE(gdim.dims);
            FREE(gdim.howmany_dims);
            return 0;
        }
        if (i > 0 && Sel[i] <= Sel[i - 1])
        {
            Scierror(999, _("%s: Wrong values for input argument #%d: Elements must be in increasing order.\n"), fname, 3);
            FREE(gdim.dims);
            FREE(gdim.howmany_dims);
            return 0;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < ndimsA; i++)
    {
        if (j >= gdim.rank) break;
        if (Sel[j] == i + 1)
        {
            gdim.dims[j].n = dimsA[i];
            gdim.dims[j].is = pd;
            gdim.dims[j].os = pd;
            j++;
        }
        pd *= dimsA[i];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i <= rank - 1; i++)
      {
        if (Sel[i] != Sel[i-1] + 1)
          {
            


            for(j = Sel[i - 1] + 1; j <= Sel[i] - 1; j++)
              {
                if (dimsA[j - 1] != 1)
                  {
                    gdim.howmany_rank++;
                    break;
                  }
              }
          }
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 1; j <= (Sel[0] - 1); j++) pd *= dimsA[j - 1]; 



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i <= rank -1; i++)
          {
            
            if (Sel[i] != Sel[i - 1] + 1)
              {
                pds = 1;
                for(j = (Sel[i - 1] + 1); j <= (Sel[i] - 1); j++) pds *= dimsA[j - 1]; 
                


                for(j = (Sel[i - 1] + 1); j <= (Sel[i] - 1); j++)
                  {
                    if (dimsA[j - 1] != 1)
                      {
                        gdim.howmany_dims[ih].is = pd;
                        gdim.howmany_dims[ih].os = pd;
                        gdim.howmany_dims[ih].n = pds;
                        ih++;
                        break;
                      }
                  }
              }
            pd *= pds * dimsA[Sel[i] - 1]; 
          }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = (Sel[rank - 1] + 1); j <= ndimsA; j++) pds *= dimsA[j - 1]; 



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < ndimsA; i++)
    {
        lA *= dimsA[i];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < ndims; i++)
    {
        if (Dim1[i] <= 1)
        {
            Scierror(999, _("%s: Wrong values for input argument #%d: Elements must be greater than %d.\n"), fname, 3, 1);
            FREE(Dim1);
            FREE(Incr);
            FREE(Dim);
            FREE(Sel);
            FREE(gdim.dims);
            FREE(gdim.howmany_dims);
            return 0;
        }
        pd *= Dim1[i];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < ndims; i++)
    {
        if (lA % Incr[i])
        {
            Scierror(999, _("%s: Wrong values for input argument #%d: Elements must be divisors of %d.\n"), fname, 3, lA);
            FREE(Dim1);
            FREE(Incr);
            FREE(Dim);
            FREE(Sel);
            FREE(gdim.dims);
            FREE(gdim.howmany_dims);
            return 0;
        }
        if (i > 0 && (Incr[i] <= Incr[i - 1]))
        {
            Scierror(999, _("%s: Wrong values for input argument #%d: Elements must be in increasing ""order.\n"), fname, 4);
            FREE(Dim1);
            FREE(Incr);
            FREE(Dim);
            FREE(Sel);
            FREE(gdim.dims);
            FREE(gdim.howmany_dims);
            return 0;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 1; k < ndims; k++)
    {
        if (Incr[k] % pd != 0)
        {
            Scierror(999, _("%s: Incompatible input arguments #%d and #%d.\n"), fname, 3, 4);
            FREE(Dim1);
            FREE(Incr);
            FREE(Dim);
            FREE(Sel);
            FREE(gdim.dims);
            FREE(gdim.howmany_dims);
            return 0;
        }
        if (Incr[k] != pd)
        {
            Dim[nd++] = (int)(Incr[k] / pd);
            pd = Incr[k];
        }
        Dim[nd++] = Dim1[k];
        pd *= Dim1[k];
        Sel[k] = nd;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < ndims; i++)
    {
        if (j >= gdim.rank) break;
        if (Sel[j] == i + 1)
        {
            gdim.dims[j].n = Dim[i];
            gdim.dims[j].is = pd;
            gdim.dims[j].os = pd;
            j++;
        }
        pd *= Dim[i];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i <= rank - 1; i++)
    {
        if (Sel[i] != Sel[i - 1] + 1) gdim.howmany_rank++;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 1; j <= (Sel[0] - 1); j++) pd *= Dim[j - 1]; 



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 2; i <= rank; i++)
        {
            
            if (Sel[i - 1] != Sel[i - 2] + 1)
            {
                pds = 1;
                for(j = (Sel[i - 2] + 1); j <= (Sel[i - 1] - 1); j++) pds *= Dim[j - 1]; 
                gdim.howmany_dims[ih].is = pd;
                gdim.howmany_dims[ih].os = pd;
                gdim.howmany_dims[ih].n = pds;
                ih++;
            }
            pd *= pds * Dim[Sel[i - 1] - 1]; 
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = (Sel[rank - 1] + 1); j <= ndims; j++) pds *= Dim[j - 1]; 



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < ndimsA; i++)
    {
        lA *= dimsA[i];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < gdim.rank; i++) ak = ak * ((double)(gdim.dims[i].n));



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i < howmany_rank; i++) dims1[i] = dims1[i - 1] * howmany_dims[i].n;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < howmany_rank; i++)
        {
            t += (howmany_dims[i].n - 1) * howmany_dims[i].is;
            incr1[i] = t;
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i1 = 1; i1 <= nloop; i1++)
        {
            


            ExecuteFFTWPlan(type, p, &ri[i], &ii[i], &ro[i], &io[i]);
            i += howmany_dims[0].is;
            
            for(i2 = howmany_rank - 2; i2 >= 0; i2--)
            {
                if ((i1 % dims1[i2]) == 0)
                {
                    
                    i += howmany_dims[i2 + 1].is - incr1[i2];
                    break;
                }
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < mOut; i++ ) 
    {
         
        ai= Max(0,i-edgM) ;
        ci= mC-1-Max(0,edgM-i);
        l=Min(ci+1,mA-ai);
        for(j=0; j < nA; j++ ) 
        {
            T[j]=C2F(ddot)(&l,A+ai+mA*j,&one,C+ci-l+1,&minusone);
        } 
        
        for(j=0; j < nOut; j++ ) 
        {
            rj = nR-1-Max(0,edgN-j);
            tj = Max(0, j-edgN) ;
            l = Min(rj+1,nA-tj);
            Out[i+j*mOut] = C2F(ddot)(&l,T+tj,&one,R+rj-l+1,&minusone);
        } 
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < mOut; i++ ) 
    {
         
        ai = Max(0,i-edgM) ;
        ci = mC-1-Max(0,edgM-i);
        l = Min(ci+1,mA-ai);
        if (Ai != NULL && Ci != NULL)
        {
            for(j = 0; j < nA; j++ ) 
            {
                Tr[j] = C2F(ddot)(&l,Ar+ai+mA*j,&one,Cr+ci-l+1,&minusone)-
                    C2F(ddot)(&l,Ai+ai+mA*j,&one,Ci+ci-l+1,&minusone);

                Ti[j] = C2F(ddot)(&l,Ar+ai+mA*j,&one,Ci+ci-l+1,&minusone)+
                    C2F(ddot)(&l,Ai+ai+mA*j,&one,Cr+ci-l+1,&minusone);
            } 
        }
        else if (Ci != NULL) 
        {
            for(j = 0; j < nA; j++ ) 
            {
                Tr[j] = C2F(ddot)(&l,Ar+ai+mA*j,&one,Cr+ci-l+1,&minusone);
                Ti[j] = C2F(ddot)(&l,Ar+ai+mA*j,&one,Ci+ci-l+1,&minusone);
            }
        }
        else if (Ai != NULL) 
        {
            for(j = 0; j < nA; j++ ) 
            {
                Tr[j] = C2F(ddot)(&l,Ar+ai+mA*j,&one,Cr+ci-l+1,&minusone);
                Ti[j] = C2F(ddot)(&l,Ai+ai+mA*j,&one,Cr+ci-l+1,&minusone);
            }
        }
        else 
        {
            for(j = 0; j < nA; j++ ) 
            {
                Tr[j] = C2F(ddot)(&l,Ar+ai+mA*j,&one,Cr+ci-l+1,&minusone);
                Ti[j] = 0.0;
            }
        }
        
        for(j = 0; j < nOut; j++ ) 
        {
            rj = nR-1-Max(0,edgN-j);
            tj = Max(0, j-edgN) ;
            l = Min(rj+1,nA-tj);
            Outr[i+j*mOut] = C2F(ddot)(&l,Tr+tj,&one,Rr+rj-l+1,&minusone);
            Outi[i+j*mOut] = C2F(ddot)(&l,Ti+tj,&one,Rr+rj-l+1,&minusone);
            if (Ri != NULL)
            {
                Outr[i+j*mOut] -= C2F(ddot)(&l,Ti+tj,&one,Ri+rj-l+1,&minusone);
                Outi[i+j*mOut] = C2F(ddot)(&l,Tr+tj,&one,Ri+rj-l+1,&minusone);
            } 
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i < mOut; i++ ) 
        {
            bi = mB-1-Max(0,edgM-i);
            ai = Max(0,i-edgM);
            l = Min(bi+1,mA-ai);
            Out[i] = C2F(ddot)(&l,A+ai,&one,B+bi-l+1,&minusone);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < nOut; j++ ) 
        {
            bj = nB-1-Max(0,edgN-j);
            aj = Max(0,j-edgN);
            l = Min(bj+1,nA-aj);
            Out[j] = C2F(ddot)(&l,A+aj,&one,B+bj-l+1,&minusone);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < mOut; i++ ) 
        {
            bi = mB-1-Max(0,edgM-i);
            ai = Max(0,i-edgM);
            for(j=0; j < nOut; j++ ) 
            {
                sum = 0;
                for(bj= nB-1-Max(0,edgN-j),aj= Max(0,j-edgN);bj >= 0 && aj < nA;bj--, aj++) 
                {
                    l = Min(bi+1,mA-ai);
                    sum += C2F(ddot)(&l,A+ai+mA*aj,&one,B+bi-l+1+mB*bj,&minusone);
                } 
                Out[i+j*mOut] = sum;
            } 
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i < mOut; i++ ) 
            {
                bi = mB-1-Max(0,edgM-i);
                ai = Max(0,i-edgM);
                l = Min(bi+1,mA-ai);
                Outr[i] = C2F(ddot)(&l,Ar+ai,&one,Br+bi-l+1,&minusone)-
                    C2F(ddot)(&l,Ai+ai,&one,Bi+bi-l+1,&minusone);

                Outi[i] = C2F(ddot)(&l,Ar+ai,&one,Bi+bi-l+1,&minusone)+
                    C2F(ddot)(&l,Ai+ai,&one,Br+bi-l+1,&minusone);
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < mOut; i++ ) 
            {
                bi = mB-1-Max(0,edgM-i);
                ai = Max(0,i-edgM);
                for(j = 0; j < nOut; j++ ) 
                {
                    sumr = 0;
                    sumi = 0;
                    for(bj = nB-1-Max(0,edgN-j),aj= Max(0,j-edgN);bj >= 0 && aj < nA;bj--, aj++) 
                    {
                        l = Min(bi+1,mA-ai);
                        sumr += C2F(ddot)(&l,Ar+ai+mA*aj,&one,Br+bi-l+1+mB*bj,&minusone)
                            -C2F(ddot)(&l,Ai+ai+mA*aj,&one,Bi+bi-l+1+mB*bj,&minusone);

                        sumi += C2F(ddot)(&l,Ar+ai+mA*aj,&one,Bi+bi-l+1+mB*bj,&minusone)+
                            C2F(ddot)(&l,Ai+ai+mA*aj,&one,Br+bi-l+1+mB*bj,&minusone);
                    }
                    Outr[i+j*mOut] = sumr;
                    Outi[i+j*mOut] = sumi;
                } 
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < mOut; i++ ) 
            {
                bi = mB-1-Max(0,edgM-i);
                ai = Max(0,i-edgM);
                l = Min(bi+1,mA-ai);
                Outr[i] = C2F(ddot)(&l,Ar+ai,&one,Br+bi-l+1,&minusone);
                Outi[i] = C2F(ddot)(&l,Ai+ai,&one,Br+bi-l+1,&minusone);
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < mOut; i++ ) 
            {
                bi = mB-1-Max(0,edgM-i);
                ai = Max(0,i-edgM);
                for(j = 0; j < nOut; j++ ) 
                {
                    sumr = 0;
                    sumi = 0;
                    for(bj = nB-1-Max(0,edgN-j),aj= Max(0,j-edgN);bj >= 0 && aj < nA;bj--, aj++) 
                    {
                        l = Min(bi+1,mA-ai);
                        sumr += C2F(ddot)(&l,Ar+ai+mA*aj,&one,Br+bi-l+1+mB*bj,&minusone);
                        sumi += C2F(ddot)(&l,Ai+ai+mA*aj,&one,Br+bi-l+1+mB*bj,&minusone);
                    }
                    Outr[i+j*mOut] = sumr;
                    Outi[i+j*mOut] = sumi;
                } 
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i < mOut; i++ ) 
            {
                bi = mB-1-Max(0,edgM-i);
                ai = Max(0,i-edgM);
                l = Min(bi+1,mA-ai);
                Outr[i] = C2F(ddot)(&l,Ar+ai,&one,Br+bi-l+1,&minusone);
                Outi[i] = C2F(ddot)(&l,Ar+ai,&one,Bi+bi-l+1,&minusone);
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < mOut; i++ ) 
            {
                bi = mB-1-Max(0,edgM-i);
                ai = Max(0,i-edgM);
                for(j = 0; j < nOut; j++ ) 
                {
                    sumr = 0;
                    sumi = 0;
                    for(bj = nB-1-Max(0,edgN-j),aj= Max(0,j-edgN);bj >= 0 && aj < nA;bj--, aj++) 
                    {
                        l = Min(bi+1, mA-ai);
                        sumr += C2F(ddot)(&l,Ar+ai+mA*aj,&one,Br+bi-l+1+mB*bj,&minusone);
                        sumi += C2F(ddot)(&l,Ar+ai+mA*aj,&one,Bi+bi-l+1+mB*bj,&minusone);
                    }
                    Outr[i+j*mOut] = sumr;
                    Outi[i+j*mOut] = sumi;
                } 
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0; i < m * n ; i++)
        *stk(ly + i) = f(*stk(lx + i));



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < m * n ; i++)
            fprintf(stdout, "x[%d] = %5.2f\n", i, *stk(i + lp));



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < m * n ; i++)
            fprintf(stdout, "x[%d] = %5.2f\n", i, *stk(i + lp));



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < m * n; i++)
        {
            fprintf(stdout, "x[%d] = %5.2f\n", i, cxtmp[i]);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < SizeJOBS; i++)
    {
        JOBS[i] = (char*)malloc(sizeof(char*) * 1024);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < SizeJOBS; i++)
    {
        if (JOBS[i])
        {
            free(JOBS[i]);
            JOBS[i] = NULL;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < m * n; i++)
        {
            fprintf(stdout, "x[%d] = %5.2f\n", i, cxtmp[i]);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < SizeJOBS; i++)
    {
        JOBS[i] = (char*)malloc(sizeof(char*) * 1024);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < SizeJOBS; i++)
    {
        printf("JOBS[%d] = %s\n", i, JOBS[i]);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < m * n; i++)
    {
        fprintf(stdout, "C[%d] = %5.2f\n", i, cxtmp[i]);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < SizeJOBS; i++)
    {
        if (JOBS[i])
        {
            free(JOBS[i]);
            JOBS[i] = NULL;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < m * n; i++)
        {
            fprintf(stdout, "x[%d] = %5.2f\n", i, cxtmp[i]);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < SizeJOBS; i++)
    {
        JOBS[i] = (char*)malloc(sizeof(char*) * 1024);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < SizeJOBS; i++)
    {
        if (JOBS[i])
        {
            free(JOBS[i]);
            JOBS[i] = NULL;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < rowA_ * colA_; i++)
        {
            fprintf(stdout, "A[%d] = %5.2f\n", i, matrixOfDouble[i]);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < rowB_ * colB_; i++)
        {
            
            fprintf(stdout, "B[%d] = %5.2f\n", i, matrixOfDoubleB[i]);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0 ; j < rowB_ ; j++)
        {
            for(i = 0 ; i < colB_ ; i++)
            {
                

                printf("%5.2f ", matrixOfDoubleB[i * rowB_ + j]);
            }
            printf("\n"); 
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < rowA_ * colA_; i++)
        {
            fprintf(stdout, "A[%d] = %d\n", i, matrixOfBoolean[i]);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < rowB_ * colB_; i++)
        {
            
            fprintf(stdout, "B[%d] = %d\n", i, matrixOfBooleanB[i]);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0 ; j < rowB_ ; j++)
        {
            for(i = 0 ; i < colB_ ; i++)
            {
                

                printf("%d ", matrixOfBooleanB[i * rowB_ + j]);
            }
            printf("\n"); 
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < rowA_ * colA_ * 2; i++) 


        {
            fprintf(stdout, "A[%d] = %5.2f\n", i, matrixOfComplex[i]);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < rowA_ * colA_; i++)
        {
            fprintf(stdout, "%5.2f + %5.2f.i ", matrixOfComplex[i], matrixOfComplex[i + colA_]);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < rowB_ * colB_; i++) 


        {
            
            fprintf(stdout, "B[%d] = %5.2f\n", i, matrixOfComplexB[i]);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < rowB_ * colB_; i++) 


        {
            
            fprintf(stdout, "B[%d] = %5.2f\n", i, matrixOfComplexB_img[i]);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0 ; j < rowB_ ; j++)
        {
            for(i = 0 ; i < colB_ ; i++)
            {
                

                printf("%5.2f + %5.2f.i  ", matrixOfComplexB[i * rowB_ + j], matrixOfComplexB_img[i * rowB_ + j]);
            }
            printf("\n"); 
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0 ; i < iRows * iCols ; i++)
        {
            pstData[i] = (char*)malloc(sizeof(char) * (piLen[i] + 1));//+ 1 for null termination
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0 ; j < iCols ; j++)
        {
            for(i = 0 ; i < iRows ; i++)
            {
                
                printf("[%d,%d] = %s\n", j + 1, i + 1, pstData[j * iRows + i]);
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0 ; i < iRows * iCols ; i++)
        {
            free(pstData[i]);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0 ; i < iRows * iCols ; i++)
        {
            pstData[i] = (char*)malloc(sizeof(char) * (piLen[i] + 1));//+ 1 for null termination
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0 ; j < iCols ; j++)
        {
            for(i = 0 ; i < iRows ; i++)
            {
                
                printf("[%d,%d] = %s\n", j + 1, i + 1, pstData[j * iRows + i]);
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0 ; i < iRows * iCols ; i++)
        {
            free(pstData[i]);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < iNbLines; i++)
    {
        nbChar += (int)strlen(msgs[i]);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < iNbLines; i++)
    {
        strcat(concat, msgs[i]);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < numberjobs; i++)
            {
                if (jobs[i])
                {
                    nbcharsjobs = nbcharsjobs + (int)strlen(jobs[i]);
                    LOCALJOBS[i] = (char *)MALLOC(sizeof(char) * (strlen(jobs[i]) + BUFFERSECURITYSIZE));
                    if (LOCALJOBS[i])
                    {
                        strcpy(LOCALJOBS[i], jobs[i]);
                    }
                    else
                    {
                        CleanBuffers(bufCommands, LOCALJOBS, numberjobs);
                        fprintf(stderr, "Error: SendScilabJobs (1) 'LOCALJOBS[%d] MALLOC'.\n", i);
                        return retcode;
                    }
                }
                else
                {
                    fprintf(stderr, "Error: SendScilabJobs (2) 'jobs[%d] == NULL'.\n", i);
                    FREE(LOCALJOBS);
                    return retcode;
                }
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(jobsloop = 0; jobsloop < numberjobs; jobsloop++)
                {
                    if (jobs[jobsloop])
                    {
                        char *currentline = NULL;
                        BOOL AddSemiColon;

                        if (jobsloop == 0)
                        {
                            AddSemiColon = FALSE;
                        }
                        else
                        {
                            AddSemiColon = TRUE;
                        }

DOTDOTLOOP:
                        currentline = LOCALJOBS[jobsloop];

                        RemoveCharsFromEOL(currentline, '\n');
                        RemoveComments(currentline);
                        RemoveCharsFromEOL(currentline, ' ');

                        if (RemoveCharsFromEOL(currentline, '.'))
                        {
                            RemoveCharsFromEOL(currentline, ' ');
                            strcat(bufCommands, currentline);
                            jobsloop++;
                            AddSemiColon = FALSE;
                            goto DOTDOTLOOP;
                        }
                        else
                        {
                            if (!AddSemiColon)
                            {
                                strcat(currentline, ";");
                            }
                            else
                            {
                                strcat(bufCommands, ";");
                            }

                            strcat(bufCommands, currentline);
                        }
                    }
                }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(l = (len - 1); l > 0; l--)
    {
        if (line[l] == CharToRemove)
        {
            line[l] = '\0';
            bOK = TRUE;
        }
        else
        {
            break;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(l = len - 1; l > 0; l--)
    {
        if (line[l] == '/')
        {
            if (l - 1 >= 0)
            {
                if (line[l - 1] == '/')
                {
                    idx = l - 1;
                    l = l - 2;
                }
            }
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i<size1; i++) {
      jstring j_string = (jstring)(*jenv)->GetObjectArrayElement(jenv, jarg1, i);
      const char * c_string = (*jenv)->GetStringUTFChars(jenv, j_string, 0);
      arg1[i] = MALLOC((strlen(c_string)+1)*sizeof(const char *));
      strcpy(arg1[i], c_string);
      (*jenv)->ReleaseStringUTFChars(jenv, j_string, c_string);
      (*jenv)->DeleteLocalRef(jenv, j_string);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<size1-1; i++) {
      FREE(arg1[i]);
      arg1[i] = NULL;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<len; i++) {
        temp_string = (*jenv)->NewStringUTF(jenv, result[i]);
        (*jenv)->SetObjectArrayElement(jenv, jresult, i, temp_string);
        (*jenv)->DeleteLocalRef(jenv, temp_string);
        FREE(result[i]);
        result[i] = NULL;
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0;i < length_input_string; i++)
				{
					if ( isalpha(input_string[i]) ) returnedValues[i] = TRUE;
					else returnedValues[i] = FALSE;
				}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0;i < length_input_string; i++)
				{
					if ( iswalpha(wcInput_string[i]) ) returnedValues[i] = TRUE;
					else returnedValues[i] = FALSE;
				}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(x =0 ; x < mn; x++)
	{
		int y = 0;
		for(y = 0;y < (int)strlen(Input_Matrix[x]);y++)
		{
			
			if ( (typ == UPPER) || (typ == UPPER_B) )
			{
				
				Output_Matrix[x][y] = (char)toupper(Input_Matrix[x][y]);
			}
			else if ( (typ==LOW) || (typ==LOW_B) )
			{
				
				Output_Matrix[x][y] = (char)tolower(Input_Matrix[x][y]);
			}
		}
        Output_Matrix[x][y] = 0;
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0;i < Dim_Input_strings;i++)
			{
				Output_strings[i] = scistrrev(Input_strings[i]);
				if (!Output_strings[i])
				{
					freeArrayOfString(Output_strings,i);
					return Output_strings;
				}
			}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = i-1; j > (i/2 -t) ; j-- )
		{
			
			
			wchar_t ch  = wcstr[j]; 
			wcstr[j]   = wcstr[k]; 
			wcstr[k++] = ch;
		}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 1 ; i < *nstring + 1 ; i++)
	{
		ni = ptrstrings[i] - li;
		li = ptrstrings[i];
		F2C(cvstr)(&ni,SciS,s,&job,(long int)ni);
		SciS += ni;
		s += ni;
		if (i < *nstring) 
		{
			*s = '\n';
			s++;
		}
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < *n; ++j)
    {
        (*strh)[j] = convertScilabCodeToAsciiCode(Scistring[j]);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i < *nstring + 1; i++)
    {
        ni = ptrstrings[i] - li;
        li = ptrstrings[i];
        
        ScilabStr2C(&ni, SciS, &p, ierr);
        if (*ierr == 1)
        {
            freeArrayOfString(strings, i - 1);
            return;
        }
        strings[i - 1] = p;
        SciS += ni;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i < *nd + 1; i++)
    {
        int j = 0;
        int ni = 0;
        int li = 1;
        int di = 0;
        char *p = NULL;

        p = &(description[di]);
        ni = ptrdesc[i] - li;

        
        for(j = 0; j < ni; ++j)
        {
            p[j] = convertScilabCodeToAsciiCode(SciS[j]);
        }
        SciS += ni;
#ifdef _MSC_VER
        p[ni] = '\r';
        ni++;
#endif
        p[ni] = '\n';
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( x = 0;x < Dim_Input_Matrix; x++)                     
	{
		Output_Matrix[0][x] = convertScilabCodeToAsciiCode(Input_Matrix[x]);
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0;i < nbOutput_Matrix ;i++)
    {
		Output_Matrix[i] = convertAsciiCodeToScilabCode(Input_String[0][i]);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0;i < m1n1; i++)  
		{
			OutputStrings[i] = (char*)MALLOC(sizeof(char)*(strlen(EMPTY_STRING)+1));
			if (OutputStrings[i])
			{
				strcpy(OutputStrings[i],EMPTY_STRING);
			}
			else
			{
				freeArrayOfString(OutputStrings,m1n1);
				return NULL;
			}
		}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0;i < Dim_InputStrings; i++)
            {
                int c = 0;
                wchar_t *ptrStr = NULL;

                if (Dim_InputChar == 1) c = InputChar[0][0];
                else  c = InputChar[i][0];

                if (do_strchr) ptrStr = wcschr(InputStrings[i], (wchar_t)c);
                else ptrStr = wcsrchr(InputStrings[i], (wchar_t)c);

                if (ptrStr)
                {
                    wcOutput_Strings[i] = (wchar_t*)MALLOC(sizeof(wchar_t) * (wcslen(ptrStr) + 1));
                    wcscpy(wcOutput_Strings[i], ptrStr);
                }
                else
                {
                    wcOutput_Strings[i] = (wchar_t*)MALLOC(sizeof(wchar_t) * (wcslen(EMPTY_WCSTR) + 1));
                    wcscpy(wcOutput_Strings[i], EMPTY_WCSTR);
                }
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(nn = l - 1 ; nn >= 0; --nn) 
		{
			unsigned char current_char = str[nn];
			line[nn] = convertAsciiCodeToScilabCode(current_char);
		}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < strings_dim; i++)
        {
            char *str = strings_input[i];
            replacedStrings[i] = strsub (str, string_to_search, replacement_string);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < strings_dim; i++)
        {
            char *str = strings_input[i];
            replacedStrings[i] = strsub_reg(str, string_to_search, replacement_string, ierr);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0;i < length_input_string; i++)
				{
					if ( iswdigit(input_string[i]) ) returnedValues[i] = TRUE;
					else returnedValues[i] = FALSE;
				}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0;i < dim_One; i++)
		{
			if (dim_Two == 1) j = 0;
			else j = i;

			if (dostricmp) 
			{
				returnedValues[i] = sign(stricmp(Input_String_One[i],Input_String_Two[j]));
			}
			else returnedValues[i] = sign(strcmp(Input_String_One[i],Input_String_Two[j]));
		}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( x = 0; x < InputStringsDim ; x++)   
    {
        int lengthInput_One = 0;
        int lengthInput_Two = 0;
        int i = 0;

        
        for( i = (int)strlen(InputStrings[x]) - 1 ; i > 0 ; i--)
        {
            if (withTAB)
            {
                if ( (InputStrings[x][i] == (char)BLANK_CHARACTER) ||
                        (InputStrings[x][i] == (char)TAB_CHARACTER) )
                {
                    continue;
                }
                else
                {
                    lengthInput_Two = i;
                    break;
                }
            }
            else
            {
                if (InputStrings[x][i] == (char)BLANK_CHARACTER)
                {
                    continue;
                }
                else
                {
                    lengthInput_Two = i;
                    break;
                }
            }
        }
        
        if (lengthInput_Two > 0)
        {
            for(i = 0; i < (int)strlen(InputStrings[x]); i++)
            {
                if (withTAB)
                {
                    if ( (InputStrings[x][i] == (char)BLANK_CHARACTER) ||
                            (InputStrings[x][i] == (char)TAB_CHARACTER) )
                    {
                        continue;
                    }
                    else
                    {
                        lengthInput_One = i;
                        break;
                    }
                }
                else
                {
                    if (InputStrings[x][i] == (char)BLANK_CHARACTER)
                    {
                        continue;
                    }
                    else
                    {
                        lengthInput_One = i;
                        break;
                    }
                }
            }
        }

        if (lengthInput_One <= lengthInput_Two )
        {
            if ( (lengthInput_Two == 0)
                    && ( (InputStrings[x][0] == (char)BLANK_CHARACTER )
                         || (withTAB && (InputStrings[x][0] == (char)TAB_CHARACTER)) ) )
            {
                strcpy(OutputStrings[x], "\0");
            }
            else
            {
                
                replacedstr = substr(InputStrings[x], lengthInput_One, lengthInput_Two + 1 );
                
                strcpy(OutputStrings[x], replacedstr);
            }

            if (replacedstr)
            {
                FREE(replacedstr);
                replacedstr = NULL;
            }
        }
        else
        {
            strcpy(OutputStrings[x], InputStrings[x]);
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(;;)
    {
        *limit = mid;

        count = pcre_exec(re, extra, (char *)bptr, len, start_offset, options,
                          use_offsets, use_size_offsets);

        if (count == errnumber)
        {
            min = mid;
            mid = (mid == max - 1) ? max : (max > 0) ? (min + max) / 2 : mid * 2;
        }

        else if (count >= 0 || count == PCRE_ERROR_NOMATCH ||
                 count == PCRE_ERROR_PARTIAL)
        {
            if (mid == min + 1)
            {
                break;
            }
            max = mid;
            mid = (min + mid) / 2;
        }
        else
        {
            break;    
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(;; gmatched++)    
            {

                



                if (find_match_limit)
                {
                    if (extra == NULL)
                    {
                        extra = (pcre_extra *)MALLOC(sizeof(pcre_extra));
                        extra->flags = 0;
                    }

                    (void)check_match_limit(re, extra, bptr, len, start_offset,
                                            options | g_notempty, use_offsets, use_size_offsets,
                                            PCRE_EXTRA_MATCH_LIMIT, &(extra->match_limit),
                                            PCRE_ERROR_MATCHLIMIT);

                    count = check_match_limit(re, extra, bptr, len, start_offset,
                                              options | g_notempty, use_offsets, use_size_offsets,
                                              PCRE_EXTRA_MATCH_LIMIT_RECURSION, &(extra->match_limit_recursion),
                                              PCRE_ERROR_RECURSIONLIMIT);
                }
                
                else if (callout_data_set)
                {
                    if (extra == NULL)
                    {
                        extra = (pcre_extra *)MALLOC(sizeof(pcre_extra));
                        extra->flags = 0;
                    }
                    extra->flags |= PCRE_EXTRA_CALLOUT_DATA;
                    extra->callout_data = &callout_data;
                    count = pcre_exec(re, extra, (char *)bptr, len, start_offset,
                                      options | g_notempty, use_offsets, use_size_offsets);

                    extra->flags &= ~PCRE_EXTRA_CALLOUT_DATA;
                }
                

                else
                {
                    count = pcre_exec(re, extra, (char *)bptr, len,
                                      start_offset, options | g_notempty, use_offsets, use_size_offsets);
                    if (count == 0)
                    {
                        count = use_size_offsets / 3;
                    }

                    //to retrieve backref count and values
                    if (count > 0 && _pstCapturedString != NULL && _piCapturedStringCount != NULL)
                    {
                        int iBackrefmax = 0;
                        int iNameCount = 0;
                        int i = 0;
                        int iErr = 0;

                        iErr = pcre_fullinfo(re, extra, PCRE_INFO_CAPTURECOUNT, _piCapturedStringCount);
                        //sciprint("PCRE_INFO_CAPTURECOUNT %d\n", *_piCapturedStringCount);

                        if (*_piCapturedStringCount > 0)
                        {
                            *_pstCapturedString = (char**)MALLOC(sizeof(char*) * *_piCapturedStringCount);
                            for(i = 0 ; i < *_piCapturedStringCount ; i++)
                            {
                                char* pstSubstring = NULL;
                                pcre_get_substring(bptr, use_offsets, count, i + 1, &pstSubstring);
                                if (pstSubstring != NULL)
                                {
                                    (*_pstCapturedString)[i] = strdup(pstSubstring);
                                }
                                pcre_free_substring(pstSubstring);
                            }
                        }
                    }
                }
                
                if (count >= 0)
                {
                    int i, maxcount;
                    maxcount = use_size_offsets / 3;
                    
                    if (count > maxcount)
                    {
                        if (buffer)
                        {
                            FREE(buffer);
                            buffer = NULL;
                        }
                        if (offsets)
                        {
                            FREE(offsets);
                            offsets = NULL;
                        }
                        if (re)
                        {
                            (*pcre_free)(re);
                            re = NULL;
                        }
                        if (tables)
                        {
                            (*pcre_free)((void*)tables);
                            tables = NULL;
                        }
                        if (extra)
                        {
                            FREE(extra);
                            extra = NULL;
                        }
                        if (back_p)
                        {
                            FREE(back_p);
                            back_p = NULL;
                        }
                        return TOO_BIG_FOR_OFFSET_SIZE;
                    }

                    for(i = 0; i < count * 2; i += 2)
                    {
                        if (use_offsets[i] >= 0)
                        {
                            *Output_Start = use_offsets[i];
                            *Output_End = use_offsets[i + 1];
                            if (buffer)
                            {
                                FREE(buffer);
                            }

                            
                            if (offsets)
                            {
                                FREE(offsets);
                            }

                            
                            if (re)
                            {
                                (*pcre_free)(re);
                            }

                            if (extra)
                            {
                                FREE(extra);
                            }
                            if (tables)
                            {
                                
                                (*pcre_free)((void *)tables);
                                tables = NULL;
                                setlocale(LC_CTYPE, "C");
                            }

                            if (back_p)
                            {
                                FREE(back_p);
                                back_p = NULL;
                            }
                            return PCRE_FINISHED_OK;
                        }
                    }

                    for(copynamesptr = copynames; *copynamesptr != 0; copynamesptr += (int)strlen((char*)copynamesptr) + 1)
                    {
                        char copybuffer[256];
                        pcre_copy_named_substring(re, (char *)bptr, use_offsets, count, (char *)copynamesptr, copybuffer, sizeof(copybuffer));
                    }

                    for(i = 0; i < 32; i++)
                    {
                        if ((getstrings & (1 << i)) != 0)
                        {
                            const char *substring;
                            pcre_get_substring((char *)bptr, use_offsets, count, i, &substring);
                        }
                    }

                    for(getnamesptr = getnames; *getnamesptr != 0; getnamesptr += (int)strlen((char*)getnamesptr) + 1)
                    {
                        const char *substring;
                        pcre_get_named_substring(re, (char *)bptr, use_offsets, count, (char *)getnamesptr, &substring);
                    }

                }
                











                else
                {
                    if (count == PCRE_ERROR_NOMATCH)
                    {
                        if (gmatched == 0)
                        {
                            if (tables)
                            {
                                (*pcre_free)((void *)tables);
                                tables = NULL;
                            }
                            if (re)
                            {
                                (*pcre_free)((void *)re);
                                re = NULL;
                            }
                            if (buffer)
                            {
                                FREE(buffer);
                                buffer = NULL;
                            }
                            if (offsets)
                            {
                                FREE(offsets);
                            }
                            if (p)
                            {
                                FREE(back_p);
                                back_p = NULL;
                            }
                            return NO_MATCH;
                        }
                    }

                    if (count == PCRE_ERROR_MATCHLIMIT )
                    {
                        if (tables)
                        {
                            (*pcre_free)((void *)tables);
                            tables = NULL;
                        }
                        if (re)
                        {
                            (*pcre_free)((void *)re);
                            re = NULL;
                        }
                        if (buffer)
                        {
                            FREE(buffer);
                            buffer = NULL;
                        }
                        if (offsets)
                        {
                            FREE(offsets);
                            offsets = NULL;
                        }
                        if (back_p)
                        {
                            FREE(back_p);
                            back_p = NULL;
                        }
                        return MATCH_LIMIT;
                    }
                    break;  
                }

                
                if (!do_g && !do_G)
                {
                    break;
                }

                






                g_notempty = 0;

                if (use_offsets[0] == use_offsets[1])
                {
                    if (use_offsets[0] == len)
                    {
                        break;
                    }
                    g_notempty = PCRE_NOTEMPTY | PCRE_ANCHORED;
                }

                

                if (do_g)
                {
                    start_offset = use_offsets[1];
                }
                
                else
                {
                    bptr += use_offsets[1];
                    len -= use_offsets[1];
                }
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0;i < length_input_string; i++)
				{
					if ( iswalnum(input_string[i]) ) returnedValues[i] = TRUE;
					else returnedValues[i] = FALSE;
				}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0;i < mn; i++)
	{
		int j = 0;
		int lengthstringInput = 0;
		wchar_t *wcInput = to_wide_string(stringInput[i]);
		wchar_t *wcOutput = NULL;
		if (wcInput) lengthstringInput = (int)wcslen(wcInput);

		wcOutput = (wchar_t*)MALLOC(sizeof(wchar_t)*((row)+1));

		for(j = 0;j < row; j++)
		{
			if ( vectInput[j] > lengthstringInput )
			{
				wcOutput[j] = L' ';
			}
			else
			{
				wcOutput[j] = wcInput[vectInput[j]-1];
			}
		}
		wcOutput[j] ='\0';
		parts[i] = wide_string_to_UTF8(wcOutput);
		if (wcOutput) {FREE(wcOutput); wcOutput = NULL;}
		if (wcInput) {FREE(wcInput); wcInput = NULL;}
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < sizeIndices; i++)
        {
            
            if ( ((int)indices[i] <= 0) || ((int)indices[i] >= lenString) )
            {
                *ierr = STRSPLIT_INCORRECT_VALUE_ERROR;
                return NULL;
            }

            
            if (sizeIndices > 1)
            {
                if ( i < (sizeIndices - 1) )
                {
                    if ((int)indices[i] > (int)indices[i + 1])
                    {
                        *ierr = STRSPLIT_INCORRECT_ORDER_ERROR;
                        return NULL;
                    }
                }
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < sizeIndices; i++)
        {

            if (i == 0)
            {
                lengthToCopy = (int)indices[i];
            }
            else
            {
                lengthToCopy = (int)indices[i] - (int)indices[i - 1];
            }

            splitted[i] = (wchar_t*)MALLOC(sizeof(wchar_t) * (lengthToCopy + 1));
            wcStrDest = splitted[i];

            if (splitted[i] == NULL)
            {
                freeArrayOfWideString(splitted, sizeIndices);
                *ierr = STRSPLIT_MEMORY_ALLOCATION_ERROR;
                return NULL;
            }
            wcStrSrc = &wcstringToSplit[j];
            memcpy(wcStrDest, wcStrSrc, lengthToCopy * sizeof(wchar_t));
            wcStrDest[lengthToCopy] = 0;

            j = (int)indices[i];
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0;i < sizedelim; i++)
			{
				wchar_t * wcdelim = to_wide_string(delim[i]);
				wcdelimiters[i] = wcdelim[0];
				FREE(wcdelim); wcdelim = NULL;
			}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < nbOutput_Matrix ; i++ )
                {
                    stk(outIndex)[i] = (double)Output_Matrix[i] ;
                }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( x = 0; x < m1n1; x++ )
				{
					stk(outIndex)[x] = values[x];
				}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < mOne * nOne; i++)
                        {
                            pStVarOne[i] = (char *)MALLOC(sizeof(char) * (lenStVarOne[i] + 1));
                            if (pStVarOne[i] == NULL)
                            {
                                FREE(pStVarThree);
                                pStVarThree = NULL;
                                FREE(pStVarTwo);
                                pStVarTwo = NULL;
                                FREE(lenStVarOne);
                                lenStVarOne = NULL;
                                freeArrayOfString(pStVarOne, i);
                                Scierror(999, _("%s: No more memory.\n"), fname);
                                return 0;
                            }
                        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nbr_characters; i++) 
	{
		int scilab_code = *istk(l + i);
		*stk(lr + i) = convertScilabCodeToAsciiCode(scilab_code);
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(x = 0; x < len; x++) 
		{
			if ( FirstWarning ) 
			{
				if ( (Input_IntMatrix[x] < ASCII_MIN) || (Input_IntMatrix[x] > ASCII_MAX) )
				{
					if (getWarningMode())
					{
						sciprint(_("WARNING : \n"));
						sciprint(_("%s: Wrong value for input argument #%d: Must be between %d and %d.\n"),fname,1,ASCII_MIN,ASCII_MAX);
					}
					FirstWarning = FALSE;
				}
			}

			if (isascii(Input_IntMatrix[x]))
			{
				Output_StringMatrix[x] = (char)toascii(Input_IntMatrix[x]);
			}
			else
			{
				Output_StringMatrix[x] = (char)Input_IntMatrix[x];
			}
		}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < mn ; i++)  
	{
		Output_String_Matrix[i] = (char*)MALLOC(sizeof(char)*(strlen(Input_String_Matrix_One[i])+1));
		if (Output_String_Matrix[i] == NULL)
		{
			freeArrayOfString(Input_String_Matrix_One,mn);
			freeArrayOfString(Output_String_Matrix,i);
			Scierror(999,_("%s : No more memory.\n"),fname);
			return 0;
		}
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0;i < mn;i++)
	{
		Output_Matrix[i] = (char*)MALLOC( sizeof(char*) * (strlen(Input_Matrix[i])+1) );
		if (Output_Matrix[i] == NULL)
		{
			freeArrayOfString(Output_Matrix,i);
			Scierror(999,("%s: No more memory.\n"),fname);
			return 0;
		}
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(x = 0; x < mn2; ++x)
        {
            char *save = strdup(Str2[x]);
            if (save)
            {
                char *pointer = Str[0];
                start_point = 0;
                wcstart_point = 0;
                do
                {
                    strcpy(save, Str2[x]);
                    Output_Start = 0;
                    Output_End = 0;

                    answer = pcre_private(pointer, save, &Output_Start, &Output_End, &pstCapturedString[nbposition], &piCapturedStringCount[nbposition]);
                    if ( answer == PCRE_FINISHED_OK )
                    {
                        


                        if (Output_Start != Output_End)
                        {
                            char *	strOutput_Start = strdup(pointer);
                            char *  strOutput_End =  strdup(pointer);

                            wchar_t *wcstrOutput_Start = NULL;
                            wchar_t *wcstrOutput_End = NULL;

                            
                            strOutput_Start[Output_Start] = '\0';
                            strOutput_End[Output_End] = '\0';

                            wcstrOutput_Start = to_wide_string(strOutput_Start);
                            wcstrOutput_End = to_wide_string(strOutput_End);

                            if (wcstrOutput_Start)
                            {
                                wcOutput_Start = (int)wcslen(wcstrOutput_Start);
                                FREE(wcstrOutput_Start);
                                wcstrOutput_Start = NULL;
                            }
                            else
                            {
                                wcOutput_Start = 0;
                            }

                            if (wcstrOutput_End)
                            {
                                wcOutput_End = (int)wcslen(wcstrOutput_End);
                                FREE(wcstrOutput_End);
                                wcstrOutput_End = NULL;
                            }
                            else
                            {
                                wcOutput_End = 0;
                            }

                            if (strOutput_Start)
                            {
                                FREE(strOutput_Start);
                                strOutput_Start = NULL;
                            }
                            if (strOutput_End)
                            {
                                FREE(strOutput_End);
                                strOutput_End = NULL;
                            }

                            
                            values_start[nbValues_start] = Output_Start + start_point + 1;
                            values_end[nbValues_end] = Output_End + start_point;

                            wcvalues_start[nbValues_start] = wcOutput_Start + wcstart_point + 1;
                            wcvalues_end[nbValues_end] = wcOutput_End + wcstart_point;

                            nbValues_start++;
                            nbValues_end++;

                            
                            nbposition++;
                        }
                        else if (Output_End == 0 && *pointer != '\0')
                        {
                            
                            pointer++;
                        }

                        pointer = &pointer[Output_End];
                        start_point = start_point + Output_End ;
                        wcstart_point = wcstart_point + wcOutput_End ;
                    }
                    else
                    {
                        if (answer != NO_MATCH)
                        {
                            pcre_error(fname, answer);
                            freeArrayOfString(Str, mn);
                            freeArrayOfString(Str2, mn2);
                            return 0;
                        }
                    }
                }
                while ( (answer == PCRE_FINISHED_OK) && (*pointer != '\0') &&  (typ != STR_ONCE) );

                if (save)
                {
                    FREE(save);
                    save = NULL;
                }
            }
            else
            {
                freeArrayOfString(Str, mn);
                freeArrayOfString(Str2, mn2);
                Scierror(999, _("%s: No more memory.\n"), fname);
                return 0;
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < nbValues_start ; i++ )
    {
        stk(outIndex)[i] = (double)wcvalues_start[i] ;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < nbposition ; i++ )
        {
            stk(outIndex)[i] = (double)wcvalues_end[i] ;
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0; i < nbValues_start; i++)
            {
                int len = values_end[i] - values_start[i] + 1;
                match[i] = (char*)MALLOC(sizeof(char) * (len + 1));
                strncpy(match[i], Str[0] + values_start[i] - 1, len);

                
                match[i][len] = '\0';
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0 ; i < nbposition ; i++)
        {
            iMax = Max(iMax, piCapturedStringCount[i]);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0 ; i < iMax ; i++)
            {
                int j = 0;
                for(j = 0 ; j < numRow ; j++)
                {
                    if (i < piCapturedStringCount[j])
                    {
                        pstOutpuStr[index] = strdup(pstCapturedString[j][i]);
                    }
                    else
                    {
                        pstOutpuStr[index] = strdup("");
                    }

                    index++;
                }
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0 ; i < nbposition ; i++)
        {
            freeArrayOfString(pstCapturedString[i], piCapturedStringCount[i]);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < mn; i++)
                nchars += (int)strlen(Input_String_One[i]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < mn; i++)
            {
                int j = 0;

                for(j = 0; j < (int)strlen(Input_String_One[i]); j++)
                    *cstk(l3 + k++) = Input_String_One[i][j];
                if (i != mn - 1)
                    for(j = 0; j < (int)strlen(Input_String_Two); j++)
                        *cstk(l3 + k++) = Input_String_Two[j];
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < Row_One; i++)
            {
                int j = 0;

                
                nchars = 0;
                for(j = 0; j < Col_One; j++)
                    nchars += (int)strlen(Input_String_One[i + Row_One * j]);
                nchars += (Col_One - 1) * (int)strlen(Input_String_Two);

                Output_String[i] = (char *)MALLOC((nchars + 1) * sizeof(char));
                if (Output_String[i] == NULL)
                {
                    freeArrayOfString(Output_String, i);
                    freeArrayOfString(Input_String_One, mn);
                    Scierror(999, _("%s: No more memory.\n"), fname);
                    return 0;
                }
                
                strcpy(Output_String[i], Input_String_One[i]);

                for(j = 1; j < Col_One; j++)
                {
                    strcat(Output_String[i], Input_String_Two);
                    strcat(Output_String[i], Input_String_One[i + Row_One * j]);
                }
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < Col_One; j++)
            {
                Output_String[j] = strdup(Input_String_One[j * Row_One]);

                if (Output_String[j] == NULL)
                {
                    freeArrayOfString(Output_String, j);
                    freeArrayOfString(Input_String_One, mn);
                    Scierror(999, _("%s: No more memory.\n"), fname);
                    return 0;
                }

                for(i = 1; i < Row_One; i++)
                {
                    int lenOutput = 0;
                    int lenInput = 0;
                    int lenNew = 0;

                    if (Input_String_Two)
                    {
                        lenOutput = (int)strlen(Output_String[j]);
                        lenInput = (int)strlen(Input_String_Two);
                        lenNew = lenOutput + lenInput + 1;

                        Output_String[j] = (char *)REALLOC(Output_String[j], sizeof(char *) * lenNew);
                        if (Output_String[j] == NULL)
                        {
                            freeArrayOfString(Output_String, j);
                            freeArrayOfString(Input_String_One, mn);
                            Scierror(999, _("%s: No more memory.\n"), fname);
                            return 0;
                        }
                        strcat(Output_String[j], Input_String_Two);
                    }

                    if (Input_String_One[i + Row_One * j])
                    {
                        lenOutput = (int)strlen(Output_String[j]);
                        lenInput = (int)strlen(Input_String_One[i + Row_One * j]);
                        lenNew = lenOutput + lenInput + 1;

                        Output_String[j] = (char *)REALLOC(Output_String[j], sizeof(char *) * lenNew);
                        if (Output_String[j] == NULL)
                        {
                            freeArrayOfString(Output_String, j);
                            freeArrayOfString(Input_String_One, mn);
                            Scierror(999, _("%s: No more memory.\n"), fname);
                            return 0;
                        }
                        strcat(Output_String[j], Input_String_One[i + Row_One * j]);
                    }
                }
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i < Number_Inputs_One; i++)
                {
                    strcat(Output_String, Input_String_One[i]);
                    (i < Number_Inputs_OneLessOne) ? strcat(Output_String, Input_String_Two[0]) : 0;
                }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < mn; i++)
                {
                    
                    
                    
                    if (i == 0)
                    {
                        memcpy(Output_String, Input_String_One[i], lengths[i]);
                    }
                    else
                    {
                        memcpy(Output_String + l, Input_String_One[i], lengths[i]);
                    }
                    l = l + lengths[i];
                }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < sizelengths; i++)
        {
            sumlength = sumlength + lengths[i];
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(x = 0; x < mn; x++)
        {
            StringsLength[x] = (int)(*istk(ilrd + x + 1) - *istk(ilrd + x));
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0;j < m1n1; j++)
                {
                    int i = 0;

                    if (m2n2 == 1) 
                    {
                        i = 0; 
                    }
                    else 
                    {
                        i = j; 
                    }

                    if (strlen(InputString_Parameter1[j])< strlen(InputString_Parameter2[i]))
                    {
                        OutputStrings[j] = strdup("");
                        if (OutputStrings[j] == NULL)
                        {
                            freeArrayOfString(OutputStrings,m1n1);
                            freeArrayOfString(InputString_Parameter1,m1n1);
                            freeArrayOfString(InputString_Parameter2,m2n2);
                            Scierror(999,_("%s: No more memory.\n"),fname);
                            return 0;
                        }
                    }
                    else
                    {
                        char *ptrstrstr = strstr(InputString_Parameter1[j],InputString_Parameter2[i]);
                        if (ptrstrstr)
                        {
                            OutputStrings[j] = strdup(ptrstrstr);
                            if (OutputStrings[j] == NULL)
                            {
                                freeArrayOfString(OutputStrings,m1n1);
                                freeArrayOfString(InputString_Parameter1,m1n1);
                                freeArrayOfString(InputString_Parameter2,m2n2);
                                Scierror(999,_("%s: No more memory.\n"),fname);
                                return 0;
                            }
                        }
                        else
                        {
                            OutputStrings[j] = strdup("");
                            if (OutputStrings[j] == NULL)
                            {
                                freeArrayOfString(OutputStrings,m1n1);
                                freeArrayOfString(InputString_Parameter1,m1n1);
                                freeArrayOfString(InputString_Parameter2,m2n2);
                                Scierror(999,_("%s: No more memory.\n"),fname);
                                return 0;
                            }
                        }
                    }
                }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 0; k < m2 * n2; k++)
                        {
                            if (isValidRegExp(pStrsTwo[k]))
                            {
                                freeAllocatedMatrixOfWideString(m2, n2, pStrsTwo);
                                pStrsTwo = NULL;

                                Scierror(999, _("%s: Wrong value for input argument #%d: a string expected, not a regexp pattern.\n"), fname, 2);
                                return 0;
                            }
                        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < m2n2;j++)
				{
					int len = 0;
					wchar_t *wcstring = to_wide_string(InputString_Parameter1[j]);
					if (wcstring)
					{
						len = (int)wcslen(wcstring);
						FREE(wcstring);
						wcstring = NULL;
					}
					if ( len < InputLength_Parameter2[j] ) InputLength_Parameter2_checked[j] = len;
					else
					{
						if ( InputLength_Parameter2[j] < 0 ) InputLength_Parameter2_checked[j] = 0;
						else InputLength_Parameter2_checked[j] = (int)InputLength_Parameter2[j];
					}
				}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i < m1n1 ; i++)
			{
				wchar_t *wcInput = NULL;
				wchar_t *wcOutput = NULL;

				int j = 0;
				
				if (m2n2 == 1) 
				{
					j = 0; 
				}
				else 
				{
					j = i; 
				}

				wcInput = to_wide_string(InputString_Parameter1[i]);
				wcOutput = (wchar_t*)MALLOC(sizeof(wchar_t)*(InputLength_Parameter2_checked[j]+1));
				if (wcInput && wcOutput)
				{
					wcsncpy(wcOutput,wcInput,InputLength_Parameter2_checked[j]);
					wcOutput[InputLength_Parameter2_checked[j]] = L'\0';

					OutputStrings[i] = wide_string_to_UTF8(wcOutput);
					FREE(wcOutput); wcOutput = NULL;
					FREE(wcInput); wcInput = NULL;
				}
				else
				{
					if (InputLength_Parameter2_checked) 
					{
						FREE(InputLength_Parameter2_checked);
						InputLength_Parameter2_checked = NULL;
					}
					freeArrayOfString(InputString_Parameter1,m1n1);
					freeArrayOfString(OutputStrings,i);
					Scierror(999,_("%s: No more memory.\n"),fname);
					return 0;
				}
			}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < m1 * n1; i++)
    {
        pStVarOne[i] = (char*)MALLOC(sizeof(char) * (lenStVarOne[i] + 1));
        if (pStVarOne[i] == NULL)
        {
            FREE(lenStVarOne);
            lenStVarOne = NULL;
            freeArrayOfString(pStVarOne, i);
            Scierror(999, _("%s: No more memory.\n"), "length");
            return 0;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < m_out * n_out; i++)
    {
        int clen = (int)strlen(pStVarOne[i]);
        int scilen = lenStVarOne[i];

        int trueLength = scilen;

        wchar_t *wcStr = NULL;

        if (scilen > clen)
        {
            int j = 0;
            
            
            
            for(j = 0; j < lenStVarOne[i]; j++)
            {
                if (pStVarOne[i][j] == 0)
                {
                    pStVarOne[i][j] = ' ';
                }
            }

            wcStr = to_wide_string(pStVarOne[i]);
            if (wcStr)
            {
                trueLength = (int) wcslen(wcStr);
                FREE(wcStr);
                wcStr = NULL;
            }
        }
        else
        {
            wcStr = to_wide_string(pStVarOne[i]);
            if (wcStr)
            {
                char *cStr = wide_string_to_UTF8(wcStr);
                if (cStr)
                {
                    
                    if (strlen(cStr) != strlen(pStVarOne[i]))
                    {
                        trueLength = clen;
                    }
                    else
                    {
                        trueLength = (int) wcslen(wcStr);
                    }
                    FREE(cStr);
                    cStr = NULL;
                }
                else
                {
                    trueLength = (int) wcslen(wcStr);
                }
                FREE(wcStr);
                wcStr = NULL;

            }
        }

        pdOut[i] = (double)trueLength;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0 ; i < m2n2 ; i++)
        {
            wStrings_Input2[i] = to_wide_string(Strings_Input2[i]);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(x = 0; x < m2n2; ++x)
            {
                w = pcre_private(Strings_Input1[0], Strings_Input2[x], &Output_Start, &Output_End, NULL, NULL);
                if ( w == PCRE_FINISHED_OK)
                {
                    char *partStr = strdup(Strings_Input1[0]);
                    wchar_t *wcpartStr = NULL;
                    partStr[Output_Start] = '\0';
                    wcpartStr = to_wide_string(partStr);
                    values[nbValues++].data = (int)wcslen(wcpartStr) + 1; 
                    values[nbposition++].position = x + 1;      

                    if (partStr)
                    {
                        FREE(partStr);
                        partStr = NULL;
                    }
                    if (wcpartStr)
                    {
                        FREE(wcpartStr);
                        wcpartStr = NULL;
                    }
                }
                else
                {
                    if (w != NO_MATCH)
                    {
                        freeArrayOfString(Strings_Input1, m1n1);
                        freeArrayOfString(Strings_Input2, m2n2);
                        pcre_error(fname, w);
                        return 0;
                    }
                    break;
                }
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(x = 0; x < m2n2 ; ++x)
            {
                if ( wcslen(wStrings_Input2[x]) == 0 )
                {
                    freeArrayOfWideString(wStrings_Input2, m2n2);
                    freeArrayOfString(Strings_Input2, m2n2);
                    freeArrayOfString(Strings_Input1, m1n1);
                    if (next)
                    {
                        FREE(next);
                        next = NULL;
                    }
                    if (values)
                    {
                        FREE(values);
                        values = NULL;
                    }
                    Scierror(999, _("%s: Wrong size for input argument #%d: Non-empty string expected.\n"), fname, 2);
                    return 0;
                }
                if (Strings_Input2)
                {
                    wchar_t *pCur = wStrings_Input1;
                    do
                    {
                        pCur = wcsstr(pCur, wStrings_Input2[x]);
                        if (pCur != NULL)
                        {
                            pCur++;
                            values[nbValues++].data = (int)(pCur - wStrings_Input1);
                            values[nbposition++].position = x + 1;
                        }
                    }
                    while (pCur != NULL && *pCur != 0); //Plus tard

                    
                    qsort(values, nbValues, sizeof(values[0]), cmp);
                }
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < nbValues ; i++ )
        {
            stk(outIndex)[i] = (double)values[i].data ;
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < nbposition ; i++ )
            {
                stk(outIndex)[i] = (double)values[i].position ;
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nbElems; i++)
			{
				int iVal = (int)pdVarOne[i];

				if (isascii(iVal)) bOutputMatrix[i] = (int)TRUE;
				else bOutputMatrix[i] = (int)FALSE;
			}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < (m1 * n1); i++)
		{
			lengthAllStrings = lengthAllStrings + lenStVarOne[i];

			pwcStVarOne[i] = (wchar_t*)MALLOC(sizeof(wchar_t) * (lenStVarOne[i]+1));

			if (pwcStVarOne[i] == NULL)
			{
				if (lenStVarOne)
				{
					FREE(lenStVarOne);
					lenStVarOne = NULL;
				}

				freeArrayOfWideString(pwcStVarOne, m1 * n1);
				Scierror(999,_("%s: Memory allocation error.\n"), fname);
				return 0;
			}
		}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < (m1 * n1); i++)
			{
				int j = 0;
				wchar_t* wcInput = pwcStVarOne[i];
				int len = (int)wcslen(wcInput);

				for(j = 0; j < len; j++)
				{
					if (iswascii(wcInput[j]))
					{
						bOutputMatrix[x] = (int)TRUE;
					}
					else
					{
						bOutputMatrix[x] = (int)FALSE;
					}
					x++;
				}
			}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < m1n1 ; i++ )
			{
				wchar_t *wcParam1 = NULL;
				wchar_t *wcParam2 = NULL;

				if (m2n2 == 1) j = 0;
				else j = i;

				wcParam1 = to_wide_string(InputString_Parameter1[i]);
				wcParam2 = to_wide_string(InputString_Parameter2[j]);

				if (wcParam1 && wcParam2)
				{
					stk(outIndex)[i] = (double) wcscspn( wcParam1, wcParam2 );
				}
				else
				{
					stk(outIndex)[i] = (double) strcspn( InputString_Parameter1[i], InputString_Parameter2[j] );
				}

				if (wcParam1) { FREE(wcParam1); wcParam1 = NULL;}
				if (wcParam2) { FREE(wcParam2); wcParam2 = NULL;}
				
			}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(x = 0 ; x < iRowsiCols ; x++)
    {
        //Double part
        char *stopstring = NULL;
        int iLen = (int)strlen(Input_StringMatrix_1[x]);
        int iSign = (int)strcspn(Input_StringMatrix_1[x], symbol);
        first_nb = (int)strcspn(Input_StringMatrix_1[x], keys);

        //symbol can be use only if it is before key
        if (iSign == first_nb - 1)
        {
            //let strtod do with symbol
            first_nb -= 1;
        }

        //special case for "-.3"
        if (iSign == first_nb - 2 && Input_StringMatrix_1[x][iSign + 1] == '.')
        {

            //let strtod do with symbol
            first_nb -= 2;
        }

        //Check if there is a number in the string
        if (first_nb != 0)
        {
            flag = 0;

            for(y = 0 ; y < first_nb ; y++)
            {
                if (Input_StringMatrix_1[x][y] != ' ') // spaces are accepted
                {
                    OutputDoubles[x] = not_a_number;
                    flag = 1;
                    stopstring = Input_StringMatrix_1[x];
                    break;
                }
            }

            //it is still a number
            if (flag == 0)
            {
                //only spaces ?
                if (strlen(Input_StringMatrix_1[x]) == first_nb) // strtod("  ")
                {
                    OutputDoubles[x] = not_a_number;
                    stopstring = Input_StringMatrix_1[x];
                }
                else // strtod("  000xxx")
                {
                    OutputDoubles[x] = (double)strtod(Input_StringMatrix_1[x] + first_nb, &stopstring);
                }
            }
        }
        else if (strlen(Input_StringMatrix_1[x]) == 0) //case strtod("")
        {
            OutputDoubles[x] = not_a_number;
        }
        else //all characters are digits
        {
            OutputDoubles[x] = (double)strtod(Input_StringMatrix_1[x], &stopstring);
        }

        if (iLhs == 2)
        {
            //String part
            if (stopstring)
            {
                OutputStrings[x] = (char*)MALLOC(sizeof(char) * (strlen(stopstring) + 1));
            }
            else
            {
                OutputStrings[x] = (char*)MALLOC(sizeof(char) * (strlen("") + 1));
            }

            if (OutputStrings[x] == NULL)
            {
                freeAllocatedMatrixOfString(iRows, iCols, Input_StringMatrix_1);
                freeAllocatedMatrixOfString(iRows, iCols, OutputStrings);
                FREE(OutputDoubles);
                OutputDoubles = NULL;
                Scierror(999, _("%s: No more memory.\n"), fname);
                return 0;
            }

            if (stopstring)
            {
                strcpy(OutputStrings[x], stopstring);
            }
            else
            {
                strcpy(OutputStrings[x], "");
            }
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < mn_Two ; i++)
					{
						if (Delimiters[i])
						{
							wchar_t *wcDelim = to_wide_string(Delimiters[i]);
							if ( (int)wcslen(wcDelim) > 1)
							{
								if (wcDelim) {FREE(wcDelim); wcDelim = NULL;}
								freeArrayOfString(Input_Strings,mn_One);
								Scierror(999,_("%s: Wrong type for input argument #%d: A character or a vector of single characters expected.\n"),fname,2);
								return 0;
							}

							if (wcDelim) {FREE(wcDelim); wcDelim = NULL;}
						}
					}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < m2 * n2; i++)
    {
		if (wcslen(pStrVarTwo[i]) != 1)
        {
            if (pStrVarOne) {freeAllocatedMatrixOfWideString(m1, n1, pStrVarOne); pStrVarOne = NULL;}
            if (pStrVarTwo) {freeAllocatedMatrixOfWideString(m2, n2, pStrVarTwo); pStrVarTwo = NULL;}
            Scierror(999, _("%s: Wrong size for input argument #%d: A character expected.\n"), fname, 2);
            return 0;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(x = 0; x < mn_one; x++)
    {
        results->sizeArraysMax = results->sizeArraysMax + (int)strlen(Inputs_param_one[x]);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(y = 0; y < mn_one; ++y)
    {
        for(x = 0; x < mn_two; ++x)
        {
            int Output_Start = 0;
            int Output_End = 0;

            save = strdup(Inputs_param_two[x]);
            answer = pcre_private(Inputs_param_one[y], save, &Output_Start, &Output_End, NULL, NULL);

            if (answer == PCRE_FINISHED_OK)
            {
                if (results->currentLength < results->sizeArraysMax)
                {
                    results->values[results->currentLength] = y + 1;
                    results->positions[results->currentLength] = x + 1;
                    results->currentLength++;
                }
            }
            else
            {
                pcre_error("grep", answer);
            }
            if (save)
            {
                FREE(save);
                save = NULL;
            }
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(y = 0; y < mn_one; ++y)
    {
        for(x = 0; x < mn_two; ++x)
        {
            wchar_t *wcInputOne = to_wide_string(Inputs_param_one[y]);
            wchar_t *wcInputTwo = to_wide_string(Inputs_param_two[x]);

            if (wcInputOne && wcInputTwo)
            {
                if (wcsstr(wcInputOne, wcInputTwo) != NULL)
                {
                    results->values[results->currentLength] = y + 1;
                    results->positions[results->currentLength] = x + 1;
                    results->currentLength++;
                }
            }

            if (wcInputOne)
            {
                FREE(wcInputOne);
                wcInputOne = NULL;
            }
            if (wcInputTwo)
            {
                FREE(wcInputTwo);
                wcInputTwo = NULL;
            }
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < m2n2; i++)
    {
        if (strlen(Strings_Input_Two[i]) == 0)
        {
            freeArrayOfString(Strings_Input_One, m1n1);
            freeArrayOfString(Strings_Input_Two, m2n2);
            Scierror(249, _("%s: Wrong values for input argument #%d: Non-empty strings expected.\n"), fname, 2);
            return 0;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(x = 0; x < grepresults.currentLength; x++)
            {
                stk(outIndex)[x] = (double)grepresults.values[x];
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(x = 0; x < grepresults.currentLength; x++)
                {
                    stk(outIndex)[x] = (double)grepresults.positions[x];
                }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < m1n1 ; i++ )
			{
				wchar_t *wcParam1 = NULL;
				wchar_t *wcParam2 = NULL;

				if (m2n2 == 1) j = 0;
				else j = i;
				
				wcParam1 = to_wide_string(InputString_Parameter1[i]);
				wcParam2 = to_wide_string(InputString_Parameter2[j]);

				if (wcParam1 && wcParam2)
				{
					stk(outIndex)[i] = (double) wcsspn( wcParam1, wcParam2 );
				}
				else
				{
					stk(outIndex)[i] = (double) strspn( InputString_Parameter1[i], InputString_Parameter2[j] );
				}

				if (wcParam1) { FREE(wcParam1); wcParam1 = NULL;}
				if (wcParam2) { FREE(wcParam2); wcParam2 = NULL;}
			}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0;i < m2n2 ;i++)
    {
		if (SecondParamaterValue[i] < 1)
		{
			freeArrayOfString(Input_StringMatrix,m1n1);
			Scierror(36,_("%s: Wrong values for input argument #%d: Must be >= 1.\n"),fname,2);
			return 0;
		}
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < m; i++)
    {
        pdblColorMap[i] = (double)(defcolors[3 * i] / 255.0);
        pdblColorMap[i + m] = (double)(defcolors[3 * i + 1] / 255.0);
        pdblColorMap[i + 2 * m] = (double)(defcolors[3 * i + 2] / 255.0);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < defaultNumberTicks; i++)
    {
        sprintf(labelBuffer, "%.1f", tab[i]);
        stringVector[i] = strdup(labelBuffer);

        if (stringVector[i] == NULL)
        {
            return -1;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < defaultNumberTicks; i++)
    {
        FREE(stringVector[i]);

        sprintf(labelBuffer, "%.1f", tabZTicksLocations[i]);
        stringVector[i] = strdup(labelBuffer);

        if (stringVector[i] == NULL)
        {
            return -1;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < nbRow * nbCol ; i++ )
  {
    
    newMat->data[i] = MALLOC( (strlen(textMat[i]) + 1) * sizeof(char) ) ;
    strcpy( newMat->data[i], textMat[i] ) ;
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < nbRow * nbCol ; i++ )
  {
    
    newMat->data[i] = MALLOC( (strlen("") + 1) * sizeof(char) ) ;
    strcpy( newMat->data[i], "" ) ;
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nbRow; i++)
  {
    int j = 0;
    for(j = 0; j < nbCol; j++)
    {
      printf("%s ", getStrMatElement(mat, i, j));
    }
    printf("\n");
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < aaint[1]; i++)
                {
                    dXGrads[i] = drect[0] + pas * i;
                }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < aaint[3]; i++)
                {
                    dYGrads[i] = drect[2] + pas * i;
                }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < aaint[1]; i++)
            {
                iSize = 6;
                if (dXGrads[i] < 0)
                {
                    iSize += 2;
                }
                dblFabs = fabs(dXGrads[i]);
                if (dblFabs >= 10)
                {
                    iSize = iSize + (int)floor(log10(dblFabs));
                }

                stringVector[i] = (char*) malloc(iSize * sizeof(char));
                sprintf(stringVector[i], "%.3f", dXGrads[i]);
                stringVector[i][iSize - 1] = '\0';
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < aaint[1]; i++)
            {
                free(stringVector[i]);
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < aaint[3]; i++)
            {
                iSize = 6;
                if (dYGrads[i] < 0)
                {
                    iSize += 2;
                }
                dblFabs = fabs(dYGrads[i]);
                if (dblFabs >= 10)
                {
                    iSize = iSize + (int)floor(log10(dblFabs));
                }
                stringVector[i] = (char*) malloc(iSize * sizeof(char));
                sprintf(stringVector[i], "%.3f", dYGrads[i]);
                stringVector[i][iSize - 1] = '\0';
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < aaint[3]; i++)
            {
                free(stringVector[i]);
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(jj = 0; jj < *n1; jj++)
        {
            char *pobjUID = NULL;

            if (style[jj] > 0)
            {
                BOOL isline = TRUE;

                if (ptype == 3)
                {
                    isline = FALSE;
                }
                pobjUID = ConstructPolyline((char*)getCurrentSubWin(), &(x[jj * (*n2)]),
                                            &(y[jj * (*n2)]), PD0, closeflag, *n2, ptype,
                                            &style[jj], NULL, NULL, NULL, NULL, isline, FALSE, FALSE, FALSE);
            }
            else
            {
                int minusstyle = -style[jj];

                pobjUID = ConstructPolyline((char*)getCurrentSubWin(), &(x[jj * (*n2)]),
                                            &(y[jj * (*n2)]), PD0, closeflag, *n2, ptype,
                                            NULL, NULL, &minusstyle, NULL, NULL, FALSE, FALSE, TRUE, FALSE);
            }
            if (pobjUID == NULL)
            {
                // skip
                Scierror(999, _("%s: No more memory.\n"), "plot2d");
            }
            else
            {
                setCurrentObject(pobjUID);

                hdl = getHandle(pobjUID);
                releaseGraphicObjectProperty(__GO_PARENT__, pobjUID, jni_string, 1);
                pobjUID = NULL;
                if (with_leg)
                {
                    tabofhandles[cmpt] = hdl;
                }

                hdltab[cmpt] = hdl;
                cmpt++;
            }

        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<num;i++)
    {
      sciDeleteWindow(ArrayWGraph[i]);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < (*n1); i++)
    {
        style[i] = i;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1 ; i < n ; i++)
    {
        if (x[i] > 0.0 && x[i] < min)
        {
            min = x[i] ;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 1 ; i < nbElement - 1 ; i++ )
        {
            if ( vector[i + 1] < vector[i] )
            {
                
                return 0 ;
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 1 ; i < nbElement - 1 ; i++ )
        {
            if ( vector[i + 1] > vector[i] )
            {
                
                return 0 ;
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nbElement; i++)
    {
        if (finite(vector[i]))
        {
            return TRUE;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < nbElement ; i++ )
    {
        int elemSize =  (int)strlen( src[i] ) + 1 ;
        FREE( dest[i] ) ;

        dest[i] = MALLOC( elemSize * sizeof(char) ) ;

        if ( dest[i] == NULL )
        {
            destroyStringArray( dest, nbElement ) ;
            return ;
        }

        strcpy( dest[i], src[i] ) ;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < nbElement ; i++ )
    {
        dest[i] = value ;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = endCopy ; i < destSize ; i++ )
    {
        dest[i] = 0.0 ;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < nbElement; i++ )
    {
        res[i] = NULL ;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < nbRow * nbCol ; i++ )
    {
        if (text[i][0] == '$' && !loadedDepLatex) 
        {
            loadOnUseClassPath("graphics_latex_textrendering");
            loadedDepLatex = TRUE;
        }

        if (text[i][0] == '<' && !loadedDepMathML) 
        {
            loadOnUseClassPath("graphics_mathml_textrendering");
            loadedDepMathML = TRUE;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < *numrow ; i++ )
                {
                    tab[i] = dataX[i];
                    tab[*numrow + i] = dataY[i];
                    tab[(2 * (*numrow)) + i] = 0.;
                }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < *numrow ; i++ )
                {
                    tab[i] = dataX[i];
                    tab[*numrow + i] = dataY[i];
                    if (*numcol == 3)
                    {
                        tab[(2 * (*numrow)) + i] = dataZ[i];
                    }
                }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < *numrow; i++)
            {
                tab[2 * i] = arrowBases[3 * i];
                tab[2 * i + 1] = arrowDirections[3 * i];
                tab[2 * (*numrow) + 2 * i] = arrowBases[3 * i + 1];
                tab[2 * (*numrow) + 2 * i + 1] = arrowDirections[3 * i + 1];
                if (*numcol == 3)
                {
                    tab[4 * (*numrow) + 2 * i] = arrowBases[3 * i + 2];
                    tab[4 * (*numrow) + 2 * i + 1] = arrowDirections[3 * i + 2];
                }
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nx * ny; i++)
            {
                tab[i] = data[i];
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < *numrow; i++)
            {
                tab[i] = coordinates[3 * i];
                tab[*numrow + i] = coordinates[3 * i + 1];
                tab[*numrow * 2 + i] = values[i];

            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++)
    {
        getGraphicObjectProperty(pObjUID, logflagPropertyNames[i], jni_bool, (void **)&piLogFlag);

        if (piLogFlag == NULL)
        {
            printSetGetErrorMessage("log_flags");
            return;
        }

        if (iLogFlag)
        {
            flags[i] = 'l';
        }
        else
        {
            flags[i] = 'n';
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( des = 0 ; des < 5 ; des++)
    {
        if (Fsepare("%.*f", des, &len, xmin, xmax, xpas))
        {
            break;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( des = 0 ; des < 5 ; des++)
        {
            if (Fsepare("%.*e", des, &len, xmin, xmax, xpas))
            {
                break;
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( des = 0 ; des < 5 ; des++)
    {
        if (Fsepare1("%.*f", des, &len, xx, nx))
        {
            break;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( des = 0 ; des < 5 ; des++)
        {
            if (Fsepare1("%.*e", des, &len, xx, nx))
            {
                break;
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 1 ; i < nx ; i++)
    {
        strcpy(buf2, buf1);
        sprintf(buf1, fmt, dec, xx[i]);
        *l = (((int)strlen(buf1) >= *l) ? (int) strlen(buf1) : *l) ;
        if ( strcmp(buf1, buf2) == 0)
        {
            return(0);
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 2 ; i <= 10 ; i++)
    {
        if ( *np2 % i == 0)
        {
            *np1 = i, *np2 /= i;
            return;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = ind + 1 ; i < size ; i++ )
    {
        changedArray[i - 1] = changedArray[i] ;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = *nbTicks - 1 ; i >= 0 ; i-- )
    {
        if ( removedTicks[i] )
        {
            removeIndex( curTicks, *nbTicks, i ) ;
            *nbTicks = *nbTicks - 1 ;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < initSize ; i++ )
        {
            removedTicks[i] = FALSE ;
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < nbRemove ; i++ )
        {
            int remIndex = 1 + (int) round(  i  * ((double) initSize - 2 ) / ( (double) nbRemove ) ) ;
            removedTicks[remIndex] = TRUE ;
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < size; i++)
        {
            _grads[i] = log_min + i;
            *n_grads = (*n_grads) + 1;
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = val - 1; j > 1; j--)
            if (val % j == 0)
            {
                old_pas = pas;
                pas = j;
                passed = 1;

                if ((MAX_LOG_TICKS * pas) <= val)
                {
                    if (old_pas != 0)
                    {
                        pas = old_pas;
                    }
                    break;
                }
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i <= (int )(size / pas); i++)
            {
                _grads[i] = log_min + (i * pas);

                *n_grads = (*n_grads) + 1;
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nx; i++)
    {
        x[i] = tmpx[i];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < ny; i++)
    {
        y[i] = tmpy[i];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = x3 - 1; j > 1; j--)
                    {
                        if (x3 % j == 0)
                        {
                            x[3] = j;
                            xpassed = 1;
                        }
                    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = y3 - 1; j > 1; j--)
                    {
                        if (y3 % j == 0)
                        {
                            y[3] = j;
                            ypassed = 1;
                        }
                    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
        {
            (*vector)[i] = val[i];
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n - 1; i++)
        {
            (*vector)[i] = val[0] + i * step;
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n - 1; i++)
        {
            (*vector)[i] = val[0] * exp10(val[2]) + i * step;
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < nbTics ; i++ )
    {
        sprintf(curLabelBuffer, c_format, vector[i]) ; 
        
        copyStrMatElement(ticsLabels, 0, i, curLabelBuffer);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < nbStrings ; i++ )
    {
        res[i] = copyFormatedValue( values[i], format, bufferSize ) ;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(; i < n ; i++)
    {
        
        if (finite(vect[i]) == 1 && vect[i] < vmin)
        {
            vmin = vect[i];
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(; i < n ; i++)
    {
        
        if (finite(vect[i]) == 1 && vect[i] > maxi)
        {
            maxi = vect[i];
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(; i < n ; i++)
    {
        
        if (finite(vect[i]) == 1)
        {
            if (vect[i] < _min)
            {
                _min = vect[i];
            }
            if (vect[i] > _max)
            {
                _max = vect[i];
            }
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 4; i++)
    {
        for(j = 0; j < 4; j++)
        {
            mat4D[i][j] = 0.0;
        }
        mat4D[i][i] = 1.0;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 4; i++)
    {
        res4D[i]  =  vect3D[0] * mat4D[i][0] + vect3D[1] * mat4D[i][1]
                     + vect3D[2] * mat4D[i][2] + mat4D[i][3];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<(int)strlen(legend);i++) 
	{
		if ( legend[i] == '@') count++;  
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < count; i++) Str[i]=NULL;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < count; i++) 
	{
		while( legend[arobaseIndex] != '@' && legend[arobaseIndex] != 0)
		{
			arobaseIndex++;
		}
		
		stringLength =  arobaseIndex - prevIndex;
		Str[i]=(char *)MALLOC((stringLength+1)*sizeof(char));

		if (Str[i]==NULL) 
		{
			freeArrayOfString(Str,i-1);
			return 1;
		}

		for(j = 0; j < stringLength; j++) 
		{
			Str[i][j] = legend[prevIndex + j];
		}
		Str[i][stringLength] = 0;

		
		arobaseIndex++;
		prevIndex = arobaseIndex;
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0 ; i < iChildrenCount ; ++i)
      {
          deleteGraphicObject(pstChildrenUID[i]);
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0 ; i < iChildrenCount ; ++i)
        {
            moveObj(pstChildrenUID[i], displacement, displacementSize);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < iNumVPG * iNum; i++)
        {
            dataX[i] += x;
            dataY[i] += y;
            dataZ[i] += z;
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < iNum; i++)
        {
            pdblData[3 * i] += x;
            pdblData[3 * i + 1] += y;
            pdblData[3 * i + 2] += z;
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < iNumX; i++)
        {
            dataX[i] += x;
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < iNumY; i++)
        {
            dataY[i] += y;
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < iNumX; i++)
            {
                dataX[i] += x;
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < iNumY; i++)
            {
                dataY[i] += y;
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < iNum; i++)
        {
            dataX[i] += x;
            dataY[i] += y;
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < iNum; i++)
            {
                dataZ[i] += z;
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < iNumX; i++)
        {
            dataX[i] += x;
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < iNumY; i++)
        {
            dataY[i] += y;
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < iNumZ; i++)
        {
            dataZ[i] += z;
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < champDimensions[0]; i++)
        {
            pdblData[i] += x;
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < champDimensions[1]; i++)
        {
            pdblDataY[i] += y;
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < champDimensions[0]*champDimensions[1]; i++)
            {
                pdblDataZ[i] += z;
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < iNum; i++)
        {
            pdblData[3 * i] += x;
            pdblData[3 * i + 1] += y;
            pdblData[3 * i + 2] += z;
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < iNum; i++)
        {
            pdblDirection[3 * i] += x;
            pdblDirection[3 * i + 1] += y;
            pdblDirection[3 * i + 2] += z;
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i <  n2 ; i++)
  {
    ybd_cont[i] = i ;
    xbd_cont[i] = 0 ;
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 1 ; i <  n1 ; i++)
  {
    ybd_cont[n2+i-1] = n2-1 ;
    xbd_cont[n2+i-1] = i  ;
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = n2-2;  i >= 0  ; i--)
  {
    ybd_cont[2*n2 +n1-3-i] = i ;
    xbd_cont[2*n2 +n1-3-i] = n1-1  ;
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = n1-2 ; i >= 0 ; i--)
  {
    ybd_cont[2*n2 +2*n1-4-i] = 0 ;
    xbd_cont[2*n2 +2*n1-4-i] = i  ;
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( c= 0 ; c < ncont ; c++)
  {
    stylec = ( style != (int *) 0) ? style[c] : c;
    
    for( i = 0 ; i < n1; i++)
      for( j =0 ; j < n2 ; j++)
        itg_cont[i+n1*j]=0 ;
    
    for( k = 1 ; k < n5 ; k++)
    { int ib,jb;
    i = xbd_cont[k] ; j = ybd_cont[k];
    ib = xbd_cont[k-1] ; jb= ybd_cont[k-1];
    if  (not_same_sign (phi_cont(i,j)-zCont[c] , 
      phi_cont(ib,jb)-zCont[c]))
      look(func,i,j,ib,jb,1L,zCont[c],stylec);
    }
    
    for( i = 1 ; i < n1-1; i++)
      for( j = 1 ; j < n2-1 ; j++)
        if  (not_same_sign ( phi_cont(i,j)-zCont[c] , 
          phi_cont(i, j-1)-zCont[c]))
          look(func,i,j,i,j-1,2L,zCont[c],stylec);
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i =0 ; i < *nz ; i++) 
	zconst[i]=zmin + (i+1)*(zmax-zmin)/(*nz+1);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ;  ; i++)
    { int l1,k1;
      double phi;
      if ( not_same_sign ( phi1,phi2))    break ; 
      if  ( phiav != 0.0 ) 
	{
	  (*func)(1,Cont,f_intercept(0.0,phi2,x_cont(i2),phiav,xav),
		    f_intercept(0.0,phi2,y_cont(jj2),phiav,yav));
	} 
      
      l1=i1; k1= jj1;
      i1=i2;jj1=jj2;i2=i3;jj2=jj3;i3=i4;jj3=jj4;i4=l1;jj4=k1;
      phi=phi1; phi1=phi2;phi2=phi3;phi3=phi4;phi4=phi;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(iChild = iNbChildren - 1; iChild >= 0; iChild--)
    {
        getGraphicObjectProperty(pChildren[iChild], __GO_TYPE__, jni_int, (void **)&piChildType);
        if (iChildType == __GO_UIMENU__)
        {
            pChildUID = cloneGraphicObject(pChildren[iChild]);

            setGraphicObjectRelationship(pCloneUID, pChildUID);
            cloneMenus(pChildren[iChild], pChildUID);

            releaseGraphicObjectProperty(__GO_PARENT__, pChildUID, jni_string, 1);
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nblegends; i++)
    {
        char * tmpObjUID;

        tmpObjUID = (char*)getObjectFromHandle((long)tabofhandles[i]);

        



        lineIDS[nblegends - i - 1] = tmpObjUID;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n1; i++)
            {
                dataVector[i] = pvecx[i];
                dataVector[n1 + i] = pvecy[i];
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n1; i++)
            {
                dataVector[i] = 0.0;
                dataVector[n1 + i] = 0.0;
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n1; i++)
            {
                dataVector[2 * n1 + i] = 0.0;
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n1; i++)
            {
                dataVector[2 * n1 + i] = pvecz[i];
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nb_tics_labels; i++)
        {
            if (str[i] == NULL)
            {
                deleteGraphicObject(pobjUID);
                releaseGraphicObjectProperty(__GO_PARENT__, pobjUID, jni_string, 1);
                return NULL;
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < numberArrows; i++)
        {
            arrowCoords[3 * i] = vx[2 * i];
            arrowCoords[3 * i + 1] = vy[2 * i];

            if (vz != NULL)
            {
                arrowCoords[3 * i + 2] = vz[2 * i];
            }
            else
            {
                arrowCoords[3 * i + 2] = 0.0;
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < numberArrows; i++)
        {
            arrowCoords[3 * i] = vx[2 * i + 1];
            arrowCoords[3 * i + 1] = vy[2 * i + 1];

            if (vz != NULL)
            {
                arrowCoords[3 * i + 2] = vz[2 * i + 1];
            }
            else
            {
                arrowCoords[3 * i + 2] = 0.0;
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < numberArrows; i++)
        {
            arrowCoords[3 * i] = vfx[i];
            arrowCoords[3 * i + 1] = vfy[i];
            arrowCoords[3 * i + 2] = 0.0;
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < number; i++)
    {
        char *movedObjectUID = (char*)getObjectFromHandle((long)handelsvalue[i]);

        setGraphicObjectRelationship(compoundUID, movedObjectUID);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < number; i++)
    {
        




        setGraphicObjectRelationship(pobjUID, children[number - i - 1]);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < nbRow * nbCol ; i++ )
  {
    newMat->data[i] = NULL ;
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < mat->nbRow * mat->nbCol ; i++ )
  {
    FREE( mat->data[i] ) ;
    mat->data[i] = NULL ;
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(  i = 0 ; i < nbCol ; i++ )
    {
        int curValue = (int) values[i];
        if ( values[i] < -1 || !sciCheckColorIndex(pobjUID, curValue) )
        {
            Scierror(999, _("Wrong value for '%s' property: Must be -1 or a valid color index.\n"), "grid");
            return SET_PROPERTY_ERROR ;
        }
        gridStyles[i] = curValue ;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0 ; i < iLinksCount ; i++)
    {
        char* polylineParentAxes;
        char* polylineObjectUID = (char*)getObjectFromHandle( getHandleFromStack( stackPointer + i ) );

        getGraphicObjectProperty(polylineObjectUID, __GO_TYPE__, jni_int, (void **)&piType);

        if (type != __GO_POLYLINE__)
        {
            Scierror(999, _("%s: Input argument #%d must be a '%s' handle.\n"), "links", i, "polyline");
            status = FALSE;
            break;
        }

        links[i] = polylineObjectUID;

        getGraphicObjectProperty(polylineObjectUID, __GO_PARENT_AXES__, jni_string, (void **)&polylineParentAxes);

        if (strcmp(polylineParentAxes, parentAxes) != 0)
        {
            Scierror(999, _("%s: Input argument and the legend must have the same parent axes.\n"), "links");
            status = FALSE;
            break;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0; i < nbCol; i++ )
        {
            if ( strcmp(values[i], "off") == 0 )
            {
                reverse = FALSE;
            }
            else if ( strcmp(values[i], "on") == 0 )
            {
                reverse = TRUE;
            }
            else
            {
                Scierror(999, _("Wrong value for '%s' property: '%s' or '%s' expected.\n"), "axes_reverse", "on", "off");
                return SET_PROPERTY_ERROR ;
            }

            status[i] = setGraphicObjectProperty(pobjUID, axesReversePropertiesNames[i], &reverse, jni_bool, 1);

            if (status[i] != TRUE)
            {
                Scierror(999, _("'%s' property does not exist for this handle.\n"), "axes_reverse");
                result = SET_PROPERTY_ERROR;
            }

        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0; i < nbCol ; i++ )
        {
            nbTicks = (int) values[i];

            if ( nbTicks < 0 )
            {
                nbTicks = 0;
            }

            status = setGraphicObjectProperty(pobjUID, axisSubticksPropertiesNames[i], &nbTicks, jni_int, 1);

            if (status == FALSE)
            {
                result = SET_PROPERTY_ERROR;
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < 3 ; i++ )
    {
        getGraphicObjectProperty(pobjUID, axesReversePropertiesNames[i], jni_bool, (void **)&piAxesReverse);

        if (piAxesReverse == NULL)
        {
            Scierror(999, _("'%s' property does not exist for this handle.\n"), "axes_reverse");
            return -1;
        }

        if (iAxesReverse)
        {
            axes_reverse[i] = strdup("on");
        }
        else
        {
            axes_reverse[i] = strdup("off");
        }

        if (axes_reverse[i] == NULL)
        {
            for( j = 0 ; j < i ; j++ )
            {
                FREE(axes_reverse[j]);
            }

            Scierror(999, _("%s: No more memory.\n"), "get_axes_reverse_property");
            return -1;
        }

    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < 3 ; i++ )
    {
        FREE( axes_reverse[i] );
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < nbElement ; i++ )
    {
        dest[i] = (int) values[i] ;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < nbElement ; i++ )
    {
        int size =  (int)strlen( values[i] ) + 1 ;
        res[i] = MALLOC( size * sizeof(char) ) ;

        if ( res[i] == NULL )
        {
            
            freeArrayOfString(res, i);
            return NULL ;
        }

        strcpy( res[i], values[i] ) ;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++)
    {
        if (logFlags[i] == 0)
        {
            logFlagsString[i] = 'n';
        }
        else
        {
            logFlagsString[i] = 'l';
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < NB_PROPERTIES; i++)
    {
        insertSetHashtable(setHashTable, propertyTable[i].key, propertyTable[i].accessor);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < NB_PROPERTIES; i++)
        {
            dictionary[i] = strdup(propertyTable[i].key);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < iLinksCount; i++)
    {
        handles[i] = getHandle(links[i]);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 11; i++)
    {
        if (strcmp(legendLocation, legendLocationsNames[i]) == 0)
        {
            index = i;
            break;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < piChildrenCount[0]; ++i)
        {
            getGraphicObjectProperty(pstChildrenUID[i], __GO_HIDDEN__, jni_bool, (void **)&piHidden);
            if (iHidden == 0)
            {
                iNotHiddenChildrenNumber++;
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < piChildrenCount[0]; ++i)
    {
        getGraphicObjectProperty(pstChildrenUID[i], __GO_HIDDEN__, jni_bool, (void **)&piHidden);
        if (iHidden == 0 || iShowHiddenHandles == 1)
        {
            plChildren[iChildIndex++] = getHandle(pstChildrenUID[i]);
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < 3 ; i++ )
    {
        getGraphicObjectProperty(pobjUID, axesAutoTicksPropertiesNames[i], jni_bool, (void **)&piAutoTicks);

        if (piAutoTicks == NULL)
        {
            Scierror(999, _("'%s' property does not exist for this handle.\n"), "auto_ticks");
            return -1;
        }

        if (iAutoTicks)
        {
            auto_ticks[i] = strdup("on");
        }
        else
        {
            auto_ticks[i] = strdup("off");
        }

        if (auto_ticks[i] == NULL)
        {
            for( j = 0 ; j < i ; j++ )
            {
                FREE(auto_ticks[j]);
            }

            Scierror(999, _("%s: No more memory.\n"), "get_auto_ticks_property");
            return -1;
        }

    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < 3 ; i++ )
    {
        FREE( auto_ticks[i] );
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0; i < mSize; i++ )
        {
            if ( strcmp(values[i], "off") == 0 )
            {
                autoTicks[i] = FALSE;
            }
            else if ( strcmp(values[i], "on") == 0 )
            {
                autoTicks[i] = TRUE;
            }
            else
            {
                Scierror(999, _("Wrong value for '%s' property: '%s' or '%s' expected.\n"), "auto_ticks", "on", "off");
                return SET_PROPERTY_ERROR ;
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nbtics; i++)
    {
        if (u_xgrads[i] <= 0)
        {
            sciprint("Warning: graduation number %d is ignored : when switching to logarithmic scale, we must have strictly positive graduations!\n", i);
        }
        else
        {
            u_xgrads[cmpteur] = log10(u_xgrads[i]);
            cmpteur++;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < cmpteur; i++)
        {
            if ((ticklabel[cmpteur2] = (char *)MALLOC((strlen(u_xlabels[i + offset]) + 1) * sizeof(char ))) == NULL)
            {
                Scierror(999, _("%s: No more memory.\n"), "CaseLogflagN");
            }
            strcpy(ticklabel[cmpteur2], u_xlabels[i + offset]);
            cmpteur2++;
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nbtics; i++) u_xgrads[i] = exp10(u_xgrads[i]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++)
    {
        if (logFlags[i] == 1)
        {
            curLogFlags[i] = 'l';
        }
        else
        {
            curLogFlags[i] = 'n';
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 3; i++)
    {
        if (curLogFlags[i] == 'l')
        {
            logFlags[i] = 1;
        }
        else
        {
            logFlags[i] = 0;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < 3 ; i++ )
    {
        getGraphicObjectProperty(pobjUID, axesVisiblePropertiesNames[i], jni_bool, (void **)&piAxesVisible);

        if (piAxesVisible == NULL)
        {
            Scierror(999, _("'%s' property does not exist for this handle.\n"), "axes_visible");
            return -1;
        }

        if (iAxesVisible)
        {
            axes_visible[i] = strdup("on");
        }
        else
        {
            axes_visible[i] = strdup("off");
        }

        if (axes_visible[i] == NULL)
        {
            for( j = 0 ; j < i ; j++ )
            {
                FREE(axes_visible[j]);
            }

            Scierror(999, _("%s: No more memory.\n"), "get_axes_visible_property");
            return -1;
        }

    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < 3 ; i++ )
    {
        FREE( axes_visible[i] );
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0; i < nbCol ; i++ )
        {
            if ( strcmp( values[i], "off" ) == 0)
            {
                visible = FALSE;
            }
            else if ( strcmp( values[i], "on" ) == 0 )
            {
                visible = TRUE;
            }
            else
            {
                Scierror(999, _("Wrong value for '%s' property: '%s' or '%s' expected.\n"), "axes_visible", "on", "off");
                return SET_PROPERTY_ERROR ;
            }

            status[i] = setGraphicObjectProperty(pobjUID, axesVisiblePropertiesNames[i], &visible, jni_bool, 1);

            if (status[i] != TRUE)
            {
                Scierror(999, _("'%s' property does not exist for this handle.\n"), "axes_visible");
                result = SET_PROPERTY_ERROR;
            }

        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < NB_PROPERTIES; i++)
    {
        insertGetHashtable(getHashTable, propertyTable[i].key, propertyTable[i].accessor);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < NB_PROPERTIES; i++)
        {
            char *propertyname = (char *)MALLOC(sizeof(char) * (strlen(propertyTable[i].key) + 1));

            if (propertyname)
                strcpy(propertyname, propertyTable[i].key);
            dictionary[i] = propertyname;
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < childrenCount; i++)
        {
          sciZoomRect(children[i], zoomRect);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < childrenCount; i++)
    {
      getGraphicObjectProperty(pstChildrenUID[i], __GO_TYPE__, jni_int, (void **) &piType);
      if (iType == __GO_AXES__)
      {
          setGraphicObjectProperty(pstChildrenUID[i], __GO_ZOOM_ENABLED__, (void **) &zoomEnabled, jni_bool, 1);
      }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nbObjects; i++)
  {
    getGraphicObjectProperty(objectsUID[i], __GO_TYPE__, jni_int, (void **) &piType);
    if (iType == __GO_FIGURE__)
    {
      
      sciUnzoomFigure(objectsUID[i]);
    }
    else if (iType == __GO_AXES__)
    {
      
      sciUnzoomSubwin(objectsUID[i]);
    }

  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < n1 ; ++i )
      {
        *istk(l + i) = i+1 ;
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0 ; i < n1 ; ++i)
    {
      *istk(l + i) = i+1;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<4;i++)
					if(finite((*rect)[i]) == 0){
						Scierror(999,"%s: Wrong values (Nan or Inf) for input argument: %d finite values expected\n",fname,4);
						return 0;
					}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<4;i++)
			if(finite((*rect)[i]) == 0){
				Scierror(999,"%s: Wrong values (Nan or Inf) for input argument: %d finite values expected\n",fname,4);
				return 0;
			}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0 ; i < 4; ++i)
      {
        // When i = 1 or 3 we talk about the number of ticks, this value can be -1 to say 'AutoTicks'
        *istk(l+i) = Max((int)  *istk(l+i),-(i%2));
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0 ; i < 4; ++i)
    {
      // When i = 1 or 3 we talk about the number of ticks, this value can be -1 to say 'AutoTicks'
      *istk(l+i) = Max((int)  *istk(l+i),-(i%2));
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < numArrows; i++)
        {
            arrowPoints[3 * i] = tab[2 * i];
            arrowPoints[3 * i + 1] = tab[2 * numArrows + 2 * i];

            if (*numcol == 3)
            {
                arrowPoints[3 * i + 2] = tab[4 * numArrows + 2 * i];
            }
            else
            {
                arrowPoints[3 * i + 2] = 0.0;
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < numArrows; i++)
        {
            arrowPoints[3 * i] = tab[2 * i + 1];
            arrowPoints[3 * i + 1] = tab[2 * numArrows + 2 * i + 1];

            if (*numcol == 3)
            {
                arrowPoints[3 * i + 2] = tab[4 * numArrows + 2 * i + 1];
            }
            else
            {
                arrowPoints[3 * i + 2] = 0.0;
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nbCoords; i++)
    {
        // specify a default value for Z
        double curCoords[3] = {xCoords[i], yCoords[i], 0.0};
        int curPixCoords[2];
        sciGet2dViewPixelCoordinates(selectedSubwinUID, curCoords, curPixCoords);
        xPixCoords[i] = curPixCoords[0];
        yPixCoords[i] = curPixCoords[1];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nbCoords; i++)
    {
        // specify a default value for Z
        int curPixCoords[2] = {xPixCoords[i], yPixCoords[i]};
        double curCoords[2];
        sciGet2dViewCoordFromPixel(selectedSubwinUID, curPixCoords, curCoords);
        xUserCoords[i] = curCoords[0];
        yUserCoords[i] = curCoords[1];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < *n; ++i)
        {
            





            if ((*n > 0) && (zcol != (double *)NULL))
            {
                if ((int) zcol[i] > 0)
                {
                    int intzcol = (int) zcol[i];
                    pNewPolylineUID = ConstructPolyline
                        (currentSubwinUID,
                         &(x[*m * i]), &(y[*m * i]), &(z[*m * i]), 0, *m, 1,
                         &intzcol, NULL, NULL, NULL, NULL, TRUE, FALSE, FALSE, FALSE);
                }
                else
                {
                    int intzcol = (int) - zcol[i];
                    pNewPolylineUID = ConstructPolyline
                        (currentSubwinUID,
                         &(x[*m * i]), &(y[*m * i]), &(z[*m * i]), 0, *m, 1,
                         NULL, NULL, &intzcol, NULL, NULL, FALSE, FALSE, TRUE, FALSE);
                }
            }
            else
            {
                
                int curcolor = 0;
                int *piCurColor = &curcolor;

                getGraphicObjectProperty(currentSubwinUID, __GO_LINE_COLOR__, jni_int, (void**)&piCurColor);

                pNewPolylineUID = ConstructPolyline(currentSubwinUID,
                                                    &(x[*m * i]), &(y[*m * i]), &(z[*m * i]), 0, *m, 1,
                                                    &curcolor, NULL, NULL, NULL, NULL, TRUE, FALSE, FALSE, FALSE);
            }

            if (pNewPolylineUID == NULL)
            {
                Scierror(999, _("%s: No more memory.\n"), fname);
                FREE(hdltab);
                return;
            }

            setCurrentObject(pNewPolylineUID);
            setGraphicObjectRelationship(currentSubwinUID, pNewPolylineUID);
            releaseGraphicObjectProperty(__GO_PARENT__, pNewPolylineUID, jni_string, 1);
            pNewPolylineUID = NULL;

            pobjUID = (char*)getCurrentObject();

            
            clipState = 1;
            setGraphicObjectProperty(pobjUID, __GO_CLIP_STATE__, &clipState, jni_int, 1);

            hdltab[i] = getHandle(pobjUID);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < m2 ; ++i) 
      for(j = 0 ; j < n2 ;  ++j)
        *stk( l1 + i + m2*j) = (double) i+1;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < m2 ; ++i)
      {
        for(j = 0 ; j < n2 ;  ++j)
        {
          *stk( lt + i + m2*j) = (double) i+1;
        }
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < m2 ; ++i)
      {
        for(j = 0 ; j < n2 ;  ++j)
        {
          *stk( lt + i + m2*j) = *stk(l1 +i);
        }
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0 ; j < n2 ;  ++j)
      {
        *stk( lt + j ) = *stk(l1);
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0 ; i < iChildrenCount ; ++i)
        {
            hstk(outindex)[i] = getHandle(pstChildrenUID[i]);
            




            setGraphicObjectRelationship(pstParentUID, pstChildrenUID[iChildrenCount - i - 1]);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n2; ++i)
        {
            *istk(l2 + i) = 0;
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n1; ++i)
    {
        
        if (*istk(l2 + i) == 0)
        {
            
            

            Objrect(stk(l1 + (4 * i)), stk(l1 + (4 * i) + 1), stk(l1 + (4 * i) + 2), stk(l1 + (4 * i) + 3),
                    &foreground, NULL, FALSE, TRUE, &hdl);
        }
        else
        {
            if (*istk(l2 + i) < 0)
            {
                
                int tmp = - (*istk(l2 + i));
                Objrect(stk(l1 + (4 * i)), stk(l1 + (4 * i) + 1), stk(l1 + (4 * i) + 2), stk(l1 + (4 * i) + 3),
                        &tmp, NULL, FALSE, TRUE, &hdl);
            }
            else
            {
                
                Objrect(stk(l1 + (4 * i)), stk(l1 + (4 * i) + 1), stk(l1 + (4 * i) + 2), stk(l1 + (4 * i) + 3),
                        NULL, istk(l2 + i), TRUE, FALSE, &hdl);
            }
        }
        // Add newly created object to Compound
        setGraphicObjectRelationship(pstCompoundUID, getObjectFromHandle(hdl));
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
    {
        char* subwinUID;

        handlesvalue = (unsigned long) (hstk(l1))[n - 1 - i];
        pobjUID = (char*)getObjectFromHandle(handlesvalue);

        if (pobjUID == NULL)
        {
            freeArrayOfString(Str, n);
            FREE(tabofhandles);
            Scierror(999, _("%s: The handle is no more valid.\n"), fname);
            return 0;
        }

       


        if (i == 0)
        {
            getGraphicObjectProperty(pobjUID, __GO_PARENT_FIGURE__, jni_string, (void **)&pFigureUID);
            getGraphicObjectProperty(pobjUID, __GO_PARENT_AXES__, jni_string, (void **)&psubwinUID);
        }

        


        getGraphicObjectProperty(pobjUID, __GO_PARENT_AXES__, jni_string, (void **)&subwinUID);

        if (strcmp(psubwinUID, subwinUID) != 0)
        {
            Scierror(999, _("%s: Objects must have the same axes.\n"), fname);
            FREE(tabofhandles);
            return 0;
        }

        getGraphicObjectProperty(pobjUID, __GO_TYPE__, jni_int, (void **)&piType);

        if (type != __GO_POLYLINE__)
        {
            freeArrayOfString(Str, n);
            FREE(tabofhandles);
            Scierror(999, _("%s: The %d th handle is not a polyline handle.\n"), fname, i + 1);
            return 0;
        }

        tabofhandles[i] = handlesvalue;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0 ; i < iChildrenCount ; ++i)
      {
          if (strcmp(pstChildrenUID[i], pstHandle_1) == 0)
          {
              pstChildrenUID[i] = pstHandle_2;
          }
          else if (strcmp(pstChildrenUID[i], pstHandle_2) == 0)
          {
              pstChildrenUID[i] = pstHandle_1;
          }
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nbHandle; i++)
  {
    children = (long) *hstk( handleStkIndex + i );
    childrenID = (char*)getObjectFromHandle(children);
    setGraphicObjectRelationship(parentID, childrenID);
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < NUMSETFONC ; i++)
    {
        if ( strcmp(cstk(l1), KeyTab_[i]) == 0 )
        {
            keyFound = TRUE ;
            break ;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 4; i++)
    {
        rect[i] = rectVect[i];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < childrencount[0]; ++i)
                {
                    getGraphicObjectProperty(childrenUID[i], __GO_HIDDEN__, jni_bool, (void **)&piHidden);
                    if (iHidden == 0)
                    {
                        status = sciZoom2D(childrenUID[i], rect);
                    }
                }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i2 = 0; i2 < n2; ++i2)
        {
            *istk(l2 + i2) = iCurrentSubWinForeground;
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n1; ++i)
    {
        angle1 = DEG2RAD(*stk(l1 + (6 * i) + 4) / 64.0);
        angle2 = DEG2RAD(*stk(l1 + (6 * i) + 5) / 64.0);
        Objarc(&angle1, &angle2, stk(l1 + (6 * i)), stk(l1 + (6 * i) + 1),
               stk(l1 + (6 * i) + 2), stk(l1 + (6 * i) + 3), istk(l2 + i), NULL, FALSE, TRUE, &hdl);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i <= Lhs ; i++)
    {
        LhsVar(i) = i;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < childrencount[0]; ++i)
                    {
                        getGraphicObjectProperty(childrenUID[i], __GO_HIDDEN__, jni_bool, (void **)&piHidden);
                        if (iHidden == 0)
                        {
                            deleteGraphicObject(childrenUID[i]);
                        }
                    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nb_handles; i++)
    {
        char* pstTemp = NULL;
        if (Rhs != 0)
        {
            hdl = (unsigned long) * hstk(l1 + i); 
        }

        pobjUID = (char*)getObjectFromHandle(hdl);

        if (pobjUID == NULL)
        {
            Scierror(999, _("%s: The handle is not valid.\n"), fname);
            return 0;
        }

        if (isFigureModel(pobjUID) || isAxesModel(pobjUID))
        {
            Scierror(999, _("This object cannot be deleted.\n"));
            return 0;
        }

        
        getGraphicObjectProperty(pobjUID, __GO_TYPE__, jni_int, (void **)&piObjType);
        if (iObjType == __GO_AXES__)
        {
            
            getGraphicObjectProperty(pobjUID, __GO_PARENT__, jni_string, (void **)&pstParentUID);
            
            getGraphicObjectProperty(pstParentUID, __GO_TYPE__, jni_int, (void **)&piParentType);
        }

        if (iObjType == __GO_LABEL__)
        {
            Scierror(999, _("A Label object cannot be deleted.\n"));
            return 0;
        }

        //bug #11485 : duplicate pobjUID before delete it.
        pstTemp = strdup(pobjUID);
        deleteGraphicObject(pobjUID);

        



        if (iObjType == __GO_AXES__ && iParentType == __GO_FIGURE__)
        {
            int iChild = 0;
            int iChildCount = 0;
            int *piChildCount = &iChildCount;
            char **pstChildren = NULL;
            int iChildType = -1;
            int *piChildType = &iChildType;
            int iAxesFound = 0;

            getGraphicObjectProperty(pstParentUID, __GO_CHILDREN_COUNT__, jni_int, (void **)&piChildCount);
            getGraphicObjectProperty(pstParentUID, __GO_CHILDREN__, jni_string_vector, (void **)&pstChildren);
            for(iChild = 0; iChild < iChildCount; iChild++)
            {
                getGraphicObjectProperty(pstChildren[iChild], __GO_TYPE__, jni_int, (void **)&piChildType);
                if (iChildType == __GO_AXES__)
                {
                    if (strcmp(getCurrentSubWin(), pstTemp) == 0) // Current axes has been deleted
                    {
                        setCurrentSubWin(pstChildren[iChild]);
                    }
                    iAxesFound = 1;
                    break;
                }
            }
            if (!iAxesFound)
            {
                



                cloneAxesModel(pstParentUID);
            }
        }

        FREE(pstTemp);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i =0 ; i < ix4 ; ++i) *istk(l5 + i ) = i+1;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nbObjects; i++ )
    {
      objectUID = (char*)getObjectFromHandle(getHandleFromStack(stackPointer + i));
      getGraphicObjectProperty(objectUID, __GO_TYPE__, jni_int, (void **) &piType);
      if (iType != __GO_FIGURE__ && iType != __GO_AXES__)
      {
        FREE(objectsId);
        Scierror(999, _("%s: Wrong type for input argument: Vector of Axes and Figure handles expected.\n"),fname);
        return -1;
      }
      objectsId[i] = objectUID;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < m2 ; ++i)
        {
            for(j = 0 ; j < n2 ;  ++j)
            {
                *stk( l1 + i + m2 * j) = (double) i + 1;
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < m2 ; ++i)
            {
                for(j = 0 ; j < n2 ;  ++j)
                {
                    *stk( lt + i + m2 * j) = (double) i + 1;
                }
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < m2 ; ++i)
            {
                for(j = 0 ; j < n2 ;  ++j)
                {
                    *stk( lt + i + m2 * j) = *stk(l1 + i);
                }
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0 ; j < n2 ;  ++j)
            {
                *stk( lt + j ) = *stk(l1);
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nbHandle; i++)
  {
      *istk(resultStackPointer + i) =  (getObjectFromHandle(getHandleFromStack(handleStackPointer + i)) != NULL ? TRUE : FALSE);
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nbElement; i++)
        {
            if (m1 * n1 == nbElement)
                x = *(stk(l1) + i);
            if (m2 * n2 == nbElement)
                y = *(stk(l2) + i);
            if (m3 * n3 == nbElement)
            {
                sendStr = Str + i;
                sendm3 = sendn3 = 1;
            }
            if (Rhs >= 4 && m4 * n4 == nbElement)
                angle = DEG2RAD(*(stk(l4) + i));
            if (Rhs >= 5 && m5 * n5 == nbElement)
                isboxed = (*stk(l5) != 0);

            Objstring(sendStr, sendm3, sendn3, x, y, &angle, rect, TRUE, NULL, &hdlstr, 0, NULL, NULL, isboxed
                      && (angle == 0), TRUE, FALSE, ALIGN_LEFT);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n2; ++i)
        {
            *istk(l2 + i) = i + 1;
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n1; ++i)
    {
        angle1 = DEG2RAD(*stk(l1 + (6 * i) + 4) / 64.0);
        angle2 = DEG2RAD(*stk(l1 + (6 * i) + 5) / 64.0);
        Objarc(&angle1, &angle2, stk(l1 + (6 * i)), stk(l1 + (6 * i) + 1),
               stk(l1 + (6 * i) + 2), stk(l1 + (6 * i) + 3), istk(l2 + i), istk(l2 + i), TRUE, FALSE, &hdl);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n1; ++i)
        {
            Objpoly(stk(l1 + (i * m1)), stk(l2 + (i * m2)), m1, 0, *istk(l3 + i), &hdl);
            // Add newly created object to Compound
            setGraphicObjectRelationship(pstCompoundUID, getObjectFromHandle(hdl));
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n1; ++i)
        {
            Objpoly(stk(l1 + (i * m1)), stk(l2 + (i * m2)), m1, 0, 1, &hdl);
            // Add newly created object to Compound
            setGraphicObjectRelationship(pstCompoundUID, getObjectFromHandle(hdl));
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 4; i++)
    {
        initRect[i] = 0.0;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nbDims; i++)
    {
        initRect[i] = rect[i];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0; i < _iSelectedRectSize / 2; i++)
    {
        j = i + _iSelectedRectSize / 2;
        stk(rectStackPointer)[i] = _piJavaValues[i + 1];
        stk(rectStackPointer)[j] = _piJavaValues[i + 4];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i < n; i++)
        {
            long long i1 = (long long) * hstk(l2 + i);
            long long i2 = (long long) * hstk(l2 + i - 1);

            if (i1 == i2)
            {
                Scierror(999, _("%s: Each handle should not appear twice.\n"), fname);
                return 0;
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0 ; i < n ; i++)
    {
        handelsvalue[i] = (unsigned long) (hstk(l1))[i];
        pobjUID = (char*)getObjectFromHandle(handelsvalue[i]);
        if (pobjUID == NULL)
        {
            FREE(handelsvalue);
            Scierror(999, _("%s: The handle is not or no more valid.\n"), fname);
            return 0;
        }

        getGraphicObjectProperty(pobjUID, __GO_PARENT__, jni_string, (void **)&pstCurrentParentUID);
        if (i == 0)
        {
            pstParentUID = pstCurrentParentUID;
        }

        if  (strcmp(pstParentUID, pstCurrentParentUID) != 0)
        {
            FREE(handelsvalue);
            Scierror(999, _("%s: Objects must have the same parent.\n"), fname);
            return 0;
        }

    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < NUMSETFONC ; i++ )
    {
        if ( strcmp(cstk(l1), KeyTab_[i]) == 0 )
        {
            keyFound = TRUE ;
            break ;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 2 ; i <= Rhs ; i++ )
    {
        GetRhsVar(i, MATRIX_OF_DOUBLE_DATATYPE, &xm[i - 2], &xn[i - 2], &lr);
        x[i - 2] = (int)  * stk(lr);
        xx[i - 2] = *stk(lr);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 4 ; i++)
            {
                xx[i] = *stk(lr + i);
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < childrencount[0]; ++i)
            {
                getGraphicObjectProperty(childrenUID[i], __GO_HIDDEN__, jni_bool, (void **)&piHidden);
                if (iHidden == 0)
                {
                    deleteGraphicObject(childrenUID[i]);
                }
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < m; i++)
        {
            pdblColorMap[i]         = (double)(defcolors[3 * i] / 255.0);
            pdblColorMap[i + m]     = (double)(defcolors[3 * i + 1] / 255.0);
            pdblColorMap[i + 2 * m] = (double)(defcolors[3 * i + 2] / 255.0);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
    {
        double userCoords[3] = {x[i], y[i], z[i]};
        sciGet2dViewCoordinate(psubwinUID, userCoords, userCoords2d);
        x[i] = userCoords2d[0];
        y[i] = userCoords2d[1];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < m1 * n1; i++)
        {
            if (!sciIsExistingFigure((int) windowNumbers[i]))
            {
                Scierror(999, "%s: Figure with figure_id %d does not exist.\n", fname, (int) windowNumbers[i]);
                return -1;
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < m1 * n1 ; i++)
        {
            sciDeleteWindow( (int) windowNumbers[i] ) ;
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ix = 0; ix < n2; ++ix)
        {
            *istk(l3 + ix) = 0;
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n1; ++i)
    {
        if (m3 == 1 || n3 == 1) 
        {
            if (*istk(l3 + i) == 0)
            {
                if (iForeGround == -1)
                {
                    iSubWinForeground = iColorMapSize + 1;
                }
                else if (iForeGround == -2)
                {
                    iSubWinForeground = iColorMapSize + 2;
                }
                else
                {
                    iSubWinForeground = iForeGround;
                }

                Objpoly(stk(l1 + (i * m1)), stk(l2 + (i * m1)), m1, 1, iSubWinForeground, &hdl);
            }
            else
            {
                Objfpoly(stk(l1 + (i * m1)), stk(l2 + (i * m1)), m1, istk(l3 + i), &hdl, v1);
            }
        }
        else                    
        {
            Objfpoly(stk(l1 + (i * m1)), stk(l2 + (i * m1)), m1, istk(l3 + i * m3), &hdl, v1);
        }

        // Add newly created object to Compound
        setGraphicObjectRelationship(pstCompoundUID, getObjectFromHandle(hdl));
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 4; i++)
        {
            numrow[i] = 0;
            numcol[i] = 0;
            lxyzcol[i] = 0;
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < NB_PROPERTIES_SUPPORTED; i++)
            {

                if (strcmp(propertiesSupported[i], propertyField) == 0)
                {
                    iPropertyFounded = 1;
                }
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( narg = 1 ; narg <= nbLabels ; narg++)
    {
        int m = 0,n = 0;
        char **Str = NULL;
        char * modifiedLabel = NULL;

        GetRhsVar(narg,MATRIX_OF_STRING_DATATYPE,&m,&n,&Str);
        if ( m*n == 0 )
        {
            continue;
        }

        switch(narg)
        {
            case 1:
                getGraphicObjectProperty(psubwinUID, __GO_TITLE__, jni_string, (void **)&modifiedLabel);
                break;
            case 2:
                getGraphicObjectProperty(psubwinUID, __GO_X_AXIS_LABEL__, jni_string, (void **)&modifiedLabel);
            break;
            case 3:
                getGraphicObjectProperty(psubwinUID, __GO_Y_AXIS_LABEL__, jni_string, (void **)&modifiedLabel);
                break;
            case 4:
                getGraphicObjectProperty(psubwinUID, __GO_Z_AXIS_LABEL__, jni_string, (void **)&modifiedLabel);
                break;
            default:
                break;
        }

#if 0
        startFigureDataWriting(pFigure);
#endif

        sciSetText(modifiedLabel, Str, m, n);

        setGraphicObjectProperty(modifiedLabel, __GO_FILL_MODE__, &box, jni_bool, 1);

#if 0
        endFigureDataWriting(pFigure);
#endif

        freeArrayOfString(Str,m*n);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( k = 0 ; k < new_dimsize ; k++)
    {
        new_dims[k] = H->dims[k];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( k = new_dimsize ; k < H->dimsize ; k++ )
    {
        new_dims[new_dimsize - 1] *= H->dims[k];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( k = 0 ; k < mn ; k++ )
    {
        val = (int) td[k];
        if ( val <= 0 )
        {
            return 0;
        }
        if ( val > *ind_max )
        {
            *ind_max = val;
        }
        ti[k] = val - 1;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( k = 0 ; k < *mn ; k++ )
                {
                    ti[k] = k;
                }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < *mn ; i++ )
                {
                    if ( ti[i] <= 0 )
                    {
                        return 0;
                    }
                    if ( ti[i] > *ind_max )
                    {
                        *ind_max = ti[i];
                    }
                    ti[i]--;
                }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( k = 1 ; k < *mn ; k++ )
                {
                    ti[k] = ti[k - 1] + ipas;
                }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( k = 0 ; k < nmax ; k++ )
                if ( *istk(l + k) != 0 )
                {
                    (*mn)++;
                }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( k = 0 ; k < nmax ; k++ )
                if ( *istk(l + k) != 0 )
                {
                    ti[i] = k;
                    i++;
                }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( k = 0 ; k < nmax ; k++ )
                if ( P[k] != 0 )
                {
                    (*mn)++;
                }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( k = 0 ; k < nmax ; k++ )
                if ( P[k] != 0 )
                {
                    ti[i] = k;
                    i++;
                }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( k = 0 ; k < B.nel ; k++ )
                {
                    ti[k] = B.jcol[k] - 1;
                }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( k = 0 ; k < B.m ; k++ )
                    if ( B.mnel[k] != 0 )
                    {
                        ti[i] = k;
                        i++;
                    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < B.m ; i++ )
                    for( l = 0 ; l < B.mnel[i] ; l++ )
                    {
                        j = B.jcol[k] - 1;
                        ti[k] = j * B.m + i;
                        k++;
                    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( k = 0 ; k < K ; k++ )
    {
        j[k] = id[k];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = dimsize - 1 ; i > 0 ; i-- )
    {
        get_length_and_pointer(dec + i, &nd, &id);
        Knew = K * nd;
        m = Knew - 1;
        for( k = K - 1 ; k >= 0 ; k--)
        {
            temp = dims[i - 1] * j[k];
            for( p = nd - 1 ; p >= 0 ; p-- )
            {
                j[m] = id[p] + temp;
                m--;
            }
        }
        K = Knew;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 1 ; i <= nb_index_vectors ; i++ )
    {
        ier = create_index_vector(i, dec + i, &mn, H.dims[i - 1], &ind_max);
        if ( ier == 0  ||  ind_max > H.dims[i - 1] )
        {
            Scierror(999, _("Bad (%d th) index in hypermatrix extraction. "), i);
            return 0;
        }
        if ( mn == 0 )   
        {
            CreateVar(dec + i + 1, MATRIX_OF_DOUBLE_DATATYPE, &zero, &zero, &l);
            LhsVar(1) = dec + i + 1;
            PutLhsVar();
            return 0;
        }
        ntot *= mn;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( k = 0 ; k < final_dimsize ; k++ )
        {
            He.dims[k] = get_length(dec + k + 1);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( k = 0 ; k < ntot ; k++ )
            {
                He.R[k] = H.R[j[k]];
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( k = 0 ; k < ntot ; k++ )
                {
                    He.I[k] = H.I[j[k]];
                }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( k = 0 ; k < ntot ; k++ )
            {
                Pe[k] = P[j[k]];
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( k = 0 ; k < ntot ; k++ )
                {
                    Pe[k] = P[j[k]];
                }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( k = 0 ; k < ntot ; k++ )
                {
                    siPe[k] = siP[j[k]];
                }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( k = 0 ; k < ntot ; k++ )
                {
                    cPe[k] = cP[j[k]];
                }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 1 ; i <= nb_index_vectors ; i++ )
    {
        if (! create_index_vector(i, dec + i, &mn, A.dims[i - 1], &ind_max))
        {
            return 0;
        }
        if ( mn == 0 )   
        {
            if ( B_is_scalar )
                
            {
                goto the_end;
            }
            else   
            {
                Scierror(999, _(" Bad hypermatrix insertion. "));
                return 0;
            }
        }
        else if ( ind_max > A.dims[i - 1] )
        {
            
            Fin = -Fin;
            return 0;
        }
        else if ( !B_is_scalar  &&  mn != 1 )  
        {
            while ( iconf < B.dimsize  &&  B.dims[iconf] == 1 )
            {
                iconf++;
            }
            if ( iconf >= B.dimsize  ||  B.dims[iconf] != mn )
            {
                Scierror(999, _(" Bad hypermatrix insertion. "));
                return 0;
            }
            iconf++;
        }
        ntot *= mn;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( k = 0 ; k < ntot ; k++ )
                {
                    A.R[j[k]] = B.R[0];
                }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( k = 0 ; k < ntot ; k++ )
                    {
                        A.I[j[k]] = B.I[0];
                    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( k = 0 ; k < ntot ; k++ )
                {
                    A.R[j[k]] = B.R[k];
                }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( k = 0 ; k < ntot ; k++ )
                    {
                        A.I[j[k]] = B.I[k];
                    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( k = 0 ; k < ntot ; k++ )
                {
                    PA[j[k]] = PB[0];
                }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( k = 0 ; k < ntot ; k++ )
                {
                    PA[j[k]] = PB[k];
                }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( k = 0 ; k < ntot ; k++ )
                    {
                        PA[j[k]] = PB[0];
                    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( k = 0 ; k < ntot ; k++ )
                    {
                        PA[j[k]] = PB[k];
                    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( k = 0 ; k < ntot ; k++ )
                    {
                        siPA[j[k]] = siPB[0];
                    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( k = 0 ; k < ntot ; k++ )
                    {
                        siPA[j[k]] = siPB[k];
                    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( k = 0 ; k < ntot ; k++ )
                    {
                        cPA[j[k]] = cPB[0];
                    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( k = 0 ; k < ntot ; k++ )
                    {
                        cPA[j[k]] = cPB[k];
                    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i <= *ns; ++i) 
    {
        int k = ptr[i - 1];
        int l = ptr[i];

        if ((l - k) == *n) 
        {
            if (memcmp(str, &chars[k - 1], sizeof(int) * (*n)) == 0) 
            {
                return i;
            }
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k=0; k< *nz;k++) nels=nels*sz[k];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k=0; k< *nf;k++)
      {
	creonevoid(&l,&next);
	n1 = next - l;
	l += n1;
	*istk(il + 5 + k) = *istk(il + 4 + k) + n1;
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k=0; k< *nf;k++)
      {
	crelistofvoids(&l,&next,&nels);
	n1 = next - l;
	l += n1;
	*istk(il + 5 + k) = *istk(il + 4 + k) + n1;
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k=0; k<*nels; k++) *istk(il+3+k) = *istk(il+2+k) + 2;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k=0; k<*nels; k++) {
    *istk(il  )=1;
    *istk(il+1)=0;
    *istk(il+2)=0;
    *istk(il+3)=0;
    il += 4;
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( k= 0; k < *nf; k++) ls += (int)strlen(fnames[k]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k=0; k < *nf; k++) {
	shft = (int)strlen(fnames[k]);
	C2F(cvstr)(&shft,&ivt[l],fnames[k],(Job=0,&Job),shft);
	ivt[stp+1] = ivt[stp] + shft;
	l += shft;stp++;
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=mp; i<=ix; i++) f *= (g/i-r);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=ix1; i<=m; i++) f /= (g/i-r);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k=j; k<=l; k++) {
        if(u <= *(pp+k-1)) goto S180;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k=l; k<=35; k++) {
        p = p* *mu/(double)k;
        q += p;
        *(pp+k-1) = q;
        if(u <= q) goto S170;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < 4; j++)
    {
        aw [j] = a [j];
        for(i = 1; i <= w; i++)
            aw [j]  = MultModM (aw [j], aw [j], m[j]);
        avw [j] = aw [j];
        for(i = 1; i <= v; i++)
            avw [j] = MultModM (avw [j], avw [j], m[j]);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < 4; j++)  s [j] = (double) Cg [j][g];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < 4; j++)
    {
        switch (Where)
        {
        case InitialSeed :
            Lg [j][g] = Ig [j][g];   break;
        case NewSeed :
            Lg [j][g] = MultModM (aw [j], Lg [j][g], m [j]);   break;
        case LastSeed :
            break;
        }
        Cg [j][g] = Lg [j][g];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( j = 0 ; j < 4 ; j++ )
    {
        b[j] = a[j];
        for( i = 1 ; i <= k ; i++ )
            b[j] = MultModM( b[j], b[j], m[j]);
        Ig[j][g] = MultModM ( b[j], Cg[j][g], m[j] );
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(g = 1; g <= Maxgen; g++)
    {
        for(j = 0; j < 4; j++)
            Ig [j][g] = MultModM (avw [j], Ig [j][g-1], m [j]);
        init_generator_clcg4(g, InitialSeed);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(kk=0;kk<N-M;kk++) {
            y = (mt[kk]&UPPER_MASK)|(mt[kk+1]&LOWER_MASK);
            mt[kk] = mt[kk+M] ^ (y >> 1) ^ mag01[y & 0x1];
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(;kk<N-1;kk++) {
            y = (mt[kk]&UPPER_MASK)|(mt[kk+1]&LOWER_MASK);
            mt[kk] = mt[kk+(M-N)] ^ (y >> 1) ^ mag01[y & 0x1];
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(mti=1; mti<N; mti++)
        {
            mt[mti] =  (1812433253UL * (mt[mti-1] ^ (mt[mti-1] >> 30)) + mti); 
            
            
            
            
            mt[mti] &= 0xffffffffUL;   
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<N;i++) 
        mt[i] = ((unsigned int) seed_array[i+1]) & 0xffffffff;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<N;i++) 
        state[i+1] = (double) mt[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;  i<N2; i++) 
        SWB(swb_flag,swb_state[i+N-N2],swb_state[i],swb_state[i]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=N2; i<N;  i++) 
        SWB(swb_flag,swb_state[i  -N2],swb_state[i],swb_state[i]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i=0 ; i<N ; i++)
        {
            for( j=32 ; j>0 ; j--)
            { 
                cong_state = cong_state * 69069;
                shrgx = shrgx ^ (shrgx >> 15);
                shrgx = shrgx ^ (shrgx << 17);
                tidbits = (tidbits>>1) | (0x80000000 & (cong_state^shrgx));
            }
            swb_state[i] = tidbits;
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0 ; i < N ; i++) 
        swb_state[i] = (int) (((unsigned int) s[i+3]) & 0xffffffff);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0 ; i < N ; i++) 
        s[i+3] = (double) (unsigned int) swb_state[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < ResL * ResC ; i++)
        {
            *stk(lr + i) = C2F(genbet)(stk(la), stk(lb));
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < ResL * ResC ; i++)
        {
            *stk(lr + i) = C2F(genf)(stk(la), stk(lb));
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( l_i = 0 ; l_i < ncat - 1 ; l_i++ )
        {
            if ( *stk(lb + l_i) < 0.0 )
            {
                Scierror(999, _("P(%d) < 0\n"), l_i + 1);
                return 0;
            }
            if ( *stk(lb + l_i) > 1.0 )
            {
                Scierror(999, _("P(%d) > 1\n"), l_i + 1);
                return 0;
            }
            ptot += *stk(lb + l_i);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( l_i = 0 ; l_i < nn ; l_i++)
        {
            C2F(genmul)(istk(la), stk(lb), &ncat, istk(lr + ncat * l_i));
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < ResL * ResC ; i++)
        {
            


            *stk(lr + i) = C2F(gengam)(stk(lb), stk(la));
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < ResL * ResC ; i++)
        {
            *stk(lr + i) = C2F(gennor)(stk(la), stk(lb));
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < ResL * ResC ; i++)
        {
            *stk(lr + i) = low + (high - low) * C2F(ranf)();
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < ResL * ResC ; i++)
        {
            *stk(lr + i) = C2F(ignuin)(stk(la), stk(lb));
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < ResL * ResC ; i++)
        {
            *stk(lr + i) = ignlgi();
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < nn ; i++)
        {
            int j ;
            for(j = 0; j < m1 ; j++ )
            {
                *stk(lr + (m1)*i + j) = *stk(la + j);
            }
            C2F(genprm)(stk(lr + (m1)*i), &m1);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < ResL * ResC ; i++)
        {
            *stk(lr + i) = (double) C2F(ignnbn)(istk(la), stk(lb));
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < ResL * ResC ; i++)
        {
            *stk(lr + i) = (double) C2F(ignbin)(istk(la), stk(lb));
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < nn ; i++)
        {
            C2F(genmn)(stk(parm), stk(lr + (m1)*i), stk(work));
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < m2 * n2 ; i++)
            if ( *istk(lb + i) - 1 < 0 || *istk(lb + i) - 1 >= n1 )
            {
                Scierror(999, _("%s: X0(%d) must be in the range [1,%d[\n"), fname, i + 1, n1 + 1);
                return 0;
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < m1 ; i++ )
        {
            double ptot = 0.0;
            for( j = 0 ; j < n1 ; j++ )
            {
                if ( *stk(la + i + m1 * j) < 0 )
                {
                    Scierror(999, _("P(%d,%d) < 0\n"), i + 1, j + 1);
                    return 0;
                }
                if ( *stk(la + i + m1 * j) > 1 )
                {
                    Scierror(999, _("P(%d,%d) > 1\n"), i + 1, j + 1);
                    return 0;
                }
                ptot += *stk(la + i + m1 * j) ;
            }
            if ( fabs(ptot - 1.0) > 1e-8 )
            {
                Scierror(999, _("Sum of P(%d,1:%d)=%f ~= 1\n"), i + 1, n1, ptot);
                return 0;
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < m1 ; i++)
        {
            double cumsum = 0.0;
            *stk(lr1 + i) = cumsum;
            for( j = 1; j < n1p1 ; j++ )
            {
                cumsum += *stk(la + i + m1 * (j - 1));
                *stk(lr1 + i + m1 * j) = cumsum;
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( jj = 0 ; jj < mm ; jj++)
        {
            icur = *istk(lb + jj) - 1;
            for( i = 0 ; i < nn ; i++)
            {
                int niv = 0;
                double rr = C2F(ranf)();
                if ( m1 == 1 )
                {
                    icur = 0;
                }
                while ( rr >= *stk(lr1 + icur + m1 * niv) && niv < n1p1 )
                {
                    niv++;
                }
                
                niv = Max(Min(niv, n1), 1);
                *istk(lr + jj + mm * i) = niv ;
                icur = niv - 1;
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < ResL * ResC ; i++)
        {
            *stk(lr + i) = C2F(ranf)();
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < ResL * ResC ; i++)
        {
            *stk(lr + i) = C2F(gennch)(stk(la), stk(lb));
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < ResL * ResC ; i++)
        {
            *stk(lr + i) = C2F(gennf)(stk(la), stk(lb), stk(lc));
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < ResL * ResC ; i++)
        {
            *stk(lr + i) = C2F(genchi)(stk(la));
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < ResL * ResC ; i++)
        {
            *stk(lr + i) = (double) C2F(ignpoi)(stk(la));
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < ResL * ResC ; i++)
        {
            *stk(lr + i) = igngeom(p);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < ResL * ResC ; i++)
        {
            *stk(lr + i) = C2F(genexp)(stk(la));
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<n; i++) len[i] = 0;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0; j<n; j++)
  {
	for(ip = (m->colptr)[j]; ip < (m->colptr)[j+1]; ip++) 
    {
		i = (m->rowind)[ip];
		if (i != j) 
		{
			len[i] ++;
			len[j] ++;
		}
    }
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=1; i<=n; i++) xadj[i] = xadj[i-1] + len[i-1];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<n; i++) next[i] = xadj[i] - 1;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0; j<n; j++)
  {
    for(ip = (m->colptr)[j]; ip < (m->colptr)[j+1]; ip++) 
    {
		i = (m->rowind)[ip];
		assert( next[i] < 2*nnz-n );
		assert( next[j] < 2*nnz-n );
		if (i != j) 
		{
			adjncy[ next[i] ] = j+1;
			adjncy[ next[j] ] = i+1;
			next[i] ++;
			next[j] ++;
		}
    }
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<n; i++) prm[i] --;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<n; i++) invp[ prm[i] ] = i;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0; j<n; j++) len[j] = 0;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0; j<n; j++) 
  {
    for(ip = (A->colptr)[j]; ip < (A->colptr)[j+1]; ip++) 
	{
      
      i = (A->rowind)[ip];

      I = invperm[i];
      J = invperm[j];

      if (I < J) 
	  {
		int T = I; 
		J = T;
      }
      len[J] ++;
    }
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=1; j<=n; j++) (PAPT->colptr)[j] = (PAPT->colptr)[j-1] + len[j-1];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0; j<n; j++) len[j] = (PAPT->colptr)[j];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0; j<n; j++) 
  {
    for(ip = (A->colptr)[j]; ip < (A->colptr)[j+1]; ip++) 
	{
      
      i   = (A->rowind)[ip];
      AIJ = (A->values)[ip];

      I = invperm[i];
      J = invperm[j];

      if (I < J) 
	  {
		int T = I; 
		I = J;
		J = T;
      }

      
      (PAPT->rowind)[ len[J] ] = I;
      (PAPT->values)[ len[J] ] = AIJ;

      len[J] ++;
    }
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<n; i++) pv[i] = v[p[i]];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<n; i++) v[invp[i]] = pv[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(sn=0; sn<L->n_sn; sn++)
      FREE(L->sn_struct[sn]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(sn=0; sn<L->n_sn; sn++)
      FREE(L->sn_blocks[sn]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(sn=0; sn<L->n_sn; sn++)
      FREE(L->up_blocks[sn]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<mtr->sn_size;i++) bitmap[mtr->sn_vertices[i]] = i;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<mtr->up_size;i++) bitmap[mtr->up_vertices[i]] = mtr->sn_size + i;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<(mtr->sn_size);j++) 
  {
    ind = &(A->rowind[A->colptr[*(firstcol_in_supernode+j)]]);
    re  = &(A->values[A->colptr[*(firstcol_in_supernode+j)]]); 
    for(i=0;i < A->colptr[*(firstcol_in_supernode+j)+1]- A->colptr[*(firstcol_in_supernode+j)];	i++) 
	{
      if (bitmap[ind[i]] < mtr->sn_size)
	  {
		mtr->f1[ (mtr->sn_size)*j + bitmap[ind[i]]] += re[i];
	  }
      else
	  {
		mtr->f2[ (mtr->up_size)*j + bitmap[ind[i]] - mtr->sn_size] += re[i];
	  }
    }
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<parent_mtr->sn_size;i++) bitmap[parent_mtr->sn_vertices[i]] = i;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<parent_mtr->up_size;i++) bitmap[parent_mtr->up_vertices[i]] = (parent_mtr->sn_size)+i;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<my_mtr->up_size;j++) 
  {
    for(i=j;i<my_mtr->up_size;i++) 
	{
      parent_j = bitmap[ my_mtr->up_vertices[j] ];
      parent_i = bitmap[ my_mtr->up_vertices[i] ];
      
      if (parent_j>parent_i) 
	  {
		int tmp = parent_j;
		parent_j = parent_i;
		parent_i = tmp;
      }

      v = (my_mtr->u)[(my_mtr->up_size)*j+i];

      if (parent_j < parent_mtr->sn_size) 
	  {
		if (parent_i < parent_mtr->sn_size) 
		{
			(parent_mtr->f1)[ (parent_mtr->sn_size)*parent_j + parent_i] += v;
		} 
		else 
		{
			(parent_mtr->f2)[ (parent_mtr->up_size)*parent_j + (parent_i-parent_mtr->sn_size)] += v;
		}
      } 
	  else 
	  {
		(parent_mtr->u)[ (parent_mtr->up_size)*(parent_j-parent_mtr->sn_size) + (parent_i-parent_mtr->sn_size)] += v;
      }
    }
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(c=first_child[j]; c != -1; c = next_child[c]) 
  {
    recursive_postorder(c,first_child,next_child,
			postorder,ipostorder,next);
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(c=first_child[j]; c != -1; c = next_child[c]) 
  {
    tree_level(c,
	       FALSE,
	       first_child,
	       next_child,
	       level,
	       level_j+1);
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(c=first_child[j]; c != -1; c = next_child[c]) 
  {
    tree_first_descendant(c,
			  FALSE,
			  first_child,
			  next_child,
			  ipostorder,
			  first_descendant);
    if (first_descendant[c] < fd) fd = first_descendant[c]; 
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i <=n; i++) rowcount[i] = 0;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0; j < n; j++) {
    jnnz = (A->colptr)[j+1] - (A->colptr)[j];
    for(ip=0; ip<jnnz; ip++) {
      i = (A->rowind)[(A->colptr)[j] + ip];
      if (j < i) rowcount[i]++;
    }
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i <= n; i++) {
    int next_ip = ip + rowcount[i];
    rowcount[i] = ip;
    rowptr  [i] = ip;
    ip = next_ip;
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0; j < n; j++) {
    jnnz = (A->colptr)[j+1] - (A->colptr)[j];
    for(ip=0; ip<jnnz; ip++) {
      i = (A->rowind)[(A->colptr)[j] + ip];
      if (i==j) continue;
      assert( rowcount[i] < rowptr[i+1] );
      colind[ rowcount[i] ] = j;
      rowcount[i]++;
    }
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<n; i++) {
      uf_makeset(uf,i);
      realroot[i] = i;
      parent[i] = n;
      vroot = i;
      for(kp=rowptr[i]; kp<rowptr[i+1]; kp++) {
	k=colind[kp];
	u2 = uf_find(uf,k);
	t = realroot[u2];
	if (parent[t] == n && t != i) {
	  parent[t] = i;
	  vroot = uf_union(uf,vroot,u2);
	  realroot[vroot] = i;
	}
      }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0; j<=n; j++) first_child[j] = -1;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=n-1; j>=0; j--) {
      next_child[j] = first_child[parent[j]];
      first_child[parent[j]] = j;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(u=0; u < n; u++) prev_p  [u] = -1;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(u=0; u < n; u++) l_rc    [u] =  1;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(u=0; u < n; u++) ordered_uf_makeset(uf,u);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(u=0; u < n; u++) {
      if (first_child[u] == -1)
	wt[u] = 1; 
      else
	wt[u] =  0; 
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(u=0; u < n; u++) prev_nbr[u] = -1;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(p=0; p<n; p++) {
      jp = postorder[p];
      if (parent[jp] != n) wt[parent[jp]] --;
      for(ip = (A->colptr)[jp]; ip < (A->colptr)[jp+1]; ip++) {
	ju = (A->rowind)[ip];
	if (ju==jp) continue; 
#ifdef GILBERT_NG_PEYTON_ANALYSIS_SUP
	if (first_descendant[jp] > prev_nbr[u]) {
#else
	if (1) {
#endif
	  wt[jp] ++;
	  pprime = prev_p[ju];
	  if (pprime == -1) 
	    l_rc[ju] += level[jp] - level[ju];
	  else {
	    q = ordered_uf_find(uf,pprime);
	    l_rc[ju] += level[jp] - level[q];
	    wt[q] --;
	  }
	  prev_p[ju] = jp;
	}
#ifdef GILBERT_NG_PEYTON_ANALYSIS_SUP
	prev_nbr[u] = p;
#endif
      }
      if (parent[jp] != n) {
	if (!(ipostorder[parent[jp]] > ipostorder[jp])) {
	  sciprint("jp %d parent %d (ipo_j %d ipo_parent %d\n\r",
		   jp,parent[jp],ipostorder[jp],ipostorder[parent[jp]]);
	}
	assert(ipostorder[parent[jp]] > ipostorder[jp]);
	ordered_uf_union(uf,jp,parent[jp]);
      }
    }

    *l_nz = 0;
    for(u2=0; u2<n; u2++) {
      l_cc[u2] = wt[u2];
      *l_nz += wt[u2];
    }
    for(u2=0; u2<n; u2++) {
      if (parent[u2] != n) {
	l_cc[parent[u2]] += l_cc[u2];
	*l_nz += l_cc[u2];
      }
    }

    

    if (!l_colcount) FREE(l_cc);
    if (!l_rowcount) FREE(l_rc);

    

    FREE(postorder);
    FREE(ipostorder);
    FREE(wt);
    FREE(level);
    FREE(prev_p);
    
#ifdef GILBERT_NG_PEYTON_ANALYSIS_SUP
    FREE(prev_nbr);
    FREE(first_descendant);
#endif
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i <=n; i++) rowcount[i] = 0;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0; j < n; j++) {
    
    jnnz = (A->colptr)[j+1] - (A->colptr)[j];

    for(ip=0; ip<jnnz; ip++) {
      i = (A->rowind)[(A->colptr)[j] + ip];
      if (j < i) rowcount[i]++;
    }
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i <= n; i++) {
    int next_ip = ip + rowcount[i];
    rowcount[i] = ip;
    rowptr  [i] = ip;
    ip = next_ip;
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0; j < n; j++) {
    jnnz = (A->colptr)[j+1] - (A->colptr)[j];

    for(ip=0; ip<jnnz; ip++) {
      i = (A->rowind)[(A->colptr)[j] + ip];
      if (i==j) continue;
      assert( rowcount[i] < rowptr[i+1] );
      colind[ rowcount[i] ] = j;
      rowcount[i]++;
    }
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<n; i++) {
      uf_makeset(uf,i);
      realroot[i] = i;
      parent[i] = n;
      vroot = i;
      for(kp=rowptr[i]; kp<rowptr[i+1]; kp++) {
	k=colind[kp];
	u = uf_find(uf,k);
	t = realroot[u];
	if (parent[t] == n && t != i) {
	  parent[t] = i;
	  vroot = uf_union(uf,vroot,u);
	  realroot[vroot] = i;
	}
      }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0; j < n; j++) l_cc[j] = 1;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<n; i++) marker[i] = n; 



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<n; i++) {
      l_rc[i] = 1;
      marker[ i ] = i;
      for(kp=rowptr[i]; kp<rowptr[i+1]; kp++) {
	k=colind[kp];
	j=k;
	while (marker[j] != i) {
	  l_cc[j]++;
	  l_rc[i]++;
	  (*l_nz)++;
	  marker[j] = i;
	  j = parent[j];
	}
      }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(c=first_child[j]; c != -1; c = next_child[c]) {
    recursive_symbolic_elimination(c,A,
				   first_child,next_child,
				   n_sn,
				   sn_size,sn_up_size,sn_rowind,
				   sn_first_child,sn_next_child,
				   rowind, 
				   column_to_sn_map,
				   map,
				   do_order,ipostorder
				   );
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ip=(A->colptr)[j]; ip<(A->colptr)[j+1]; ip++) {
      i = (A->rowind)[ip];
      in_previous_sn = in_previous_sn && (map[i] == c);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ip=sn_size[c_sn]; ip<sn_up_size[c_sn]; ip++) 
      if (sn_rowind[c_sn][ip] == j) break;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ip=sn_size[c_sn]; ip<sn_up_size[c_sn]; ip++) 
      map[ sn_rowind[c_sn][ip] ] = j;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(c=first_child[j]; c != -1; c = next_child[c]) {
      c_sn = column_to_sn_map[c];
      for(ip=sn_size[c_sn]; ip<sn_up_size[c_sn]; ip++) {
	i = sn_rowind[c_sn][ip];
	if (i > j && map[i] != j) { 
	  map[i] = j;
	  rowind[nnz] = i;
	  nnz++;
	}
      }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ip=(A->colptr)[j]; ip<(A->colptr)[j+1]; ip++) {
      i = (A->rowind)[ip];
      if (map[i] != j) { 
	map[i] = j;
	rowind[nnz] = i;
	nnz++;
      }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(c=first_child[j]; c != -1; c = next_child[c]) {
    c_sn = column_to_sn_map[c];
    
    if (c==first_child[j])
      sn_first_child[*n_sn] = c_sn;
    else {
      sn_next_child[ c_sn ] = sn_first_child[*n_sn];
      sn_first_child[*n_sn] = c_sn;
    }
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ip=0; ip<nnz; ip++) sn_rowind[*n_sn][ip] = rowind[ip];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(c_sn=sn_first_child[sn]; c_sn != -1; c_sn = sn_next_child[c_sn])
    nchildren++;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(c_sn=sn_first_child[sn]; c_sn != -1; c_sn = sn_next_child[c_sn]) {
    c_znz[i] = 
      recursive_amalgamate_supernodes(c_sn,
				      n_sn,
				      sn_size,sn_up_size,sn_rowind,
				      sn_first_child,sn_next_child,
				      rowind, 
				      column_to_sn_map,
				      map,
				      do_order,ipostorder
				      );
    assert(c_znz[i].zeros + c_znz[i].nonzeros ==
	   (double) (((sn_up_size[c_sn] - sn_size[c_sn]) * sn_size[c_sn]) 
		     + (sn_size[c_sn] * (sn_size[c_sn] + 1))/2 ));
    i++;
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<nchildren; i++) {
    merged_znz.nonzeros += (c_znz[i]).nonzeros;
    merged_znz.zeros    += (c_znz[i]).zeros;
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(c_sn=sn_first_child[sn]; c_sn != -1; c_sn = sn_next_child[c_sn]) {
    for(ip=0; ip<sn_size[c_sn]; ip++) {
      i = sn_rowind[c_sn][ip];
      assert( map[i] != sn );
      map[i] = sn;
      rowind[nnz] = i;
      nnz++;
    }
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ip=0; ip<sn_size[sn]; ip++) {
    i = sn_rowind[sn][ip];
    assert( map[i] != sn );
    map[i] = sn;
    rowind[nnz] = i;
    nnz++;
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(c_sn=sn_first_child[sn]; c_sn != -1; c_sn = sn_next_child[c_sn]) {
    for(ip=sn_size[c_sn]; ip<sn_up_size[c_sn]; ip++) {
      i = sn_rowind[c_sn][ip];
      if (map[i] != sn) { 
	map[i] = sn;
	rowind[nnz] = i;
	nnz++;
      }
    }
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ip=sn_size[sn]; ip<sn_up_size[sn]; ip++) {
    i = sn_rowind[sn][ip];
    if (map[i] != sn) { 
      map[i] = sn;
      rowind[nnz] = i;
      nnz++;
    }
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ip=0; ip<nnz; ip++) {
      i = rowind[ip];
      if (i >= n) n = i+1;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ip=0; ip<new_sn_size; ip++) {
      i = rowind[ip]; assert(i<n);
      zcount[i] = (double) (ip+1);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ip=new_sn_size; ip<new_sn_up_size; ip++) {
      i = rowind[ip]; assert(i<n);
      zcount[i] = (double) new_sn_size;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(c_sn=sn_first_child[sn]; c_sn != -1; c_sn = sn_next_child[c_sn]) {
      for(ip=0; ip<sn_size[c_sn]; ip++) {
	i = sn_rowind[c_sn][ip]; assert(i<n);
	zcount[i] -= (double) (ip+1);
      }
      for(ip=sn_size[c_sn]; ip<sn_up_size[c_sn]; ip++) {
	i = sn_rowind[c_sn][ip]; assert(i<n);
	zcount[i] -= (double) sn_size[c_sn];
      }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ip=0; ip<sn_size[sn]; ip++) {
      i = sn_rowind[sn][ip]; assert(i<n);
      zcount[i] -= (double) (ip+1);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ip=sn_size[sn]; ip<sn_up_size[sn]; ip++) {
      i = sn_rowind[sn][ip]; assert(i<n);
      zcount[i] -= (double) sn_size[sn];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ip=0; ip<new_sn_up_size; ip++) {
      i = rowind[ip]; assert(i<n);
      assert(zcount[i] >= 0.0);
      merged_znz.zeros += zcount[i];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ip=0; ip<new_sn_up_size; ip++) sn_rowind[sn][ip] = rowind[ip];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(c_sn=sn_first_child[sn]; c_sn != -1; c_sn = sn_next_child[c_sn]) {
    for(ip=0; ip<sn_size[c_sn]; ip++) {
      i = (sn_rowind[c_sn])[ip];
      assert(column_to_sn_map[i] == c_sn);
      column_to_sn_map[i] = sn;
    }

    for(gc_sn=sn_first_child[c_sn]; gc_sn != -1; gc_sn = sn_next_child[gc_sn]) {
      rowind[nchildren] = gc_sn;
      nchildren++;
    }
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(c_sn=sn_first_child[sn]; c_sn != -1; c_sn = sn_next_child[c_sn]) {
    FREE( sn_rowind[c_sn] );
    sn_rowind[c_sn]  = NULL;
    sn_size[c_sn]    = 0;
    sn_up_size[c_sn] = 0;
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<nchildren; i++) {
    sn_next_child[ rowind[i] ] = sn_first_child[sn];
    sn_first_child[sn] = rowind[i];
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0; j<(A->n); j++) assert(parent[j]==p1[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0; j<(A->n); j++) {
      if (cc1[j]!=cc2[j]) sciprint("j=%d cc1=%d cc2=%d\n",j,cc1[j],cc2[j]);
      assert(cc1[j]==cc2[j]);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0; j<(A->n); j++) {
      if (rc1[j]!=rc2[j]) sciprint("j=%d rc1=%d rc2=%d\n",j,rc1[j],rc2[j]);
      assert(rc1[j]==rc2[j]);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0; j <= (A->n); j++) first_child[j] = -1;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = (A->n)-1; j >= 0; j--) {
    int p = parent[j];
    next_child[j] = first_child[p];
    first_child[p] = j;
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0; j < (A->n); j++) map[j] = -1;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0; j <= (A->n); j++) (L->first_child)[j] = (L->next_child)[j] = -1;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(sn=0; sn<(L->n_sn); sn++) {
      for(i=0, colnnz = (L->sn_up_size)[sn]; 
	   i<(L->sn_size)[sn]; 
	   i++, colnnz--) {
	flops += ((double)(colnnz) - 1.0) * ((double)(colnnz) + 2.0) / 2.0;
	nnz   += (double) (colnnz);
      }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0; j < (A->n); j++) map[j] = -1;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(sn=0; sn<(L->n_sn); sn++) {
      for(i=0, colnnz = (L->sn_up_size)[sn]; 
	   i<(L->sn_size)[sn]; 
	   i++, colnnz--) {
	flops += ((double)(colnnz) - 1.0) * ((double)(colnnz) + 2.0) / 2.0;
	nnz   += (double) (colnnz);
      }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(child = first_child[sn]; child != -1; child = next_child[child]) {
    child_matrix = 
      recursive_multifrontal_supernodal_factor_llt(child,
						   FALSE,
						   bitmap,
						   A,snL,fail);
    if (*fail) { 
      if (child_matrix) supernodal_frontal_free(child_matrix);
      return NULL;
    }

    if (!is_root) {
      if (!my_matrix) {
	my_matrix =  supernodal_frontal_create(v,sn_size,
					       snL->sn_up_size[sn],
					       snL->sn_struct[sn]);
	if (!my_matrix) {
	  *fail = TRUE;
	  supernodal_frontal_free(child_matrix);
	  return NULL;
	}
      }

      multifrontal_supernodal_front_extend_add(my_matrix,child_matrix,bitmap);
      supernodal_frontal_free(child_matrix);
    }
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(child = first_child[sn]; child != -1; child = next_child[child]) {
    recursive_supernodal_solve_l(child,
				 FALSE,
				 first_child,next_child,
 				 sn_struct,sn_sizes,sn_up_sizes,
				 sn_blocks_ld,sn_blocks,
				 up_blocks_ld,up_blocks,
				 x,b,t);
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<sn_size; i++)
	xdense[i] = b[ sn_struct[ sn ][ i ] ];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<up_size; i++)
	bdense[i] = 0.0;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<sn_size; i++)
	x[ sn_struct[ sn][ i ] ]  = xdense[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<up_size; i++)
	b[ sn_struct[ sn ][ sn_size + i ] ] -= bdense[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<sn_size; i++)
	xdense[i] = b[ sn_struct[ sn ][ i ] ];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<up_size; i++)
	bdense[i] = 0.0;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(jp=0; jp<sn_size; jp++) {
	xdense[jp] = xdense[jp] / sn_blocks[sn][ sn_blocks_ld[sn]*jp + jp];

	for(ip=jp+1; ip<sn_size; ip++) {
	  xdense[ip] -= xdense[jp] * sn_blocks[sn][ sn_blocks_ld[sn]*jp + ip];
	}
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(jp=0; jp<sn_size; jp++) {
	for(ip=0; ip<up_size; ip++) {
	  bdense[ip] += xdense[jp] * up_blocks[sn][ up_blocks_ld[sn]*jp + ip];
	}
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<sn_size; i++)
	x[ sn_struct[ sn][ i ] ]  = xdense[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<up_size; i++)
	b[ sn_struct[ sn ][ sn_size + i ] ] -= bdense[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(jp=0; jp<sn_size; jp++) {
	j = sn_struct[sn][jp];
	x[j] = b[j] / sn_blocks[sn][ sn_blocks_ld[sn]*jp + jp];
	for(ip=jp+1; ip<sn_size; ip++) {
	  i = sn_struct[sn][ip];
	  b[i] -= x[j] * sn_blocks[sn][ sn_blocks_ld[sn]*jp + ip];
	}

	for(ip=0; ip<up_size; ip++) {
	  i = sn_struct[sn][sn_size + ip];
	  b[i] -= x[j] * up_blocks[sn][ up_blocks_ld[sn]*jp + ip];
	}
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<sn_size; i++)
	bdense[i] = b[ sn_struct[ sn][ i ] ];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<up_size; i++)
	xdense[i] = x[ sn_struct[sn][sn_size+i] ];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<sn_size; i++)
	x[ sn_struct[ sn][ i ] ]  = bdense[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<sn_size; i++)
	bdense[i] = b[ sn_struct[ sn][ i ] ];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<up_size; i++)
	xdense[i] = x[ sn_struct[sn][sn_size+i] ];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ip=sn_size-1; ip>=0; ip--) {
	for(jp=0; jp<up_size; jp++) {
	  bdense[ip] -= xdense[jp] * up_blocks[sn][ up_blocks_ld[sn]*ip + jp];
	}
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ip=sn_size-1; ip>=0; ip--) {
	for(jp=sn_size-1; jp>ip; jp--) {
	  bdense[ip] -= bdense[jp] * sn_blocks[sn][ sn_blocks_ld[sn]*ip + jp];
	}
	bdense[ip] = bdense[ip] / sn_blocks[sn][ sn_blocks_ld[sn]*ip + ip];
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<sn_size; i++)
	x[ sn_struct[ sn][ i ] ]  = bdense[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ip=sn_size-1; ip>=0; ip--) {
	i = sn_struct[sn][ip];

	for(jp=0; jp<up_size; jp++) {
	  j = sn_struct[sn][sn_size + jp];
	  b[i] -= x[j] * up_blocks[sn][ up_blocks_ld[sn]*ip + jp];
	}

	for(jp=sn_size-1; jp>ip; jp--) {
	  j = sn_struct[sn][jp];
	  b[i] -= x[j] * sn_blocks[sn][ sn_blocks_ld[sn]*ip + jp];
	}
	x[i] = b[i] / sn_blocks[sn][ sn_blocks_ld[sn]*ip + ip];

      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(child = first_child[sn]; child != -1; child = next_child[child]) {
    recursive_supernodal_solve_lt(child,
				  FALSE,
				  first_child,next_child,
				  sn_struct,sn_sizes,sn_up_sizes,
				  sn_blocks_ld,sn_blocks,
				  up_blocks_ld,up_blocks,
				  x,b,t);
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<L->n; i++) x[i] = b[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(sn=0; sn<L->n_sn; sn++) {
    for(jp=0; jp<(L->sn_size)[sn]; jp++) {
      j = (L->sn_struct)[sn][jp];
      len[j] = 0;

      for(ip=jp; ip<(L->sn_size)[sn]; ip++) {
	v = (L->sn_blocks)[sn][ jp*(L->sn_blocks_ld)[sn] + ip ];

	if (v) { 
	  len[j] ++;
	  nnz ++;
	}
      }
      for(ip=(L->sn_size)[sn]; ip<(L->sn_up_size)[sn]; ip++) {
	v = (L->up_blocks)[sn][ jp*(L->up_blocks_ld)[sn] + (ip-(L->sn_size)[sn]) ];

	if (v) { 
	  len[j] ++;
	  nnz ++;
	}
      }
    }
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=1; j<=n; j++) (C->colptr)[j] = (C->colptr)[j-1] + len[j-1];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(sn=0; sn<L->n_sn; sn++) {
    for(jp=0; jp<(L->sn_size)[sn]; jp++) {
      j = (L->sn_struct)[sn][jp];

      next = (C->colptr)[j];

      for(ip=jp; ip<(L->sn_size)[sn]; ip++) {
	i = (L->sn_struct)[sn][ ip ];
	v = (L->sn_blocks)[sn][ jp*(L->sn_blocks_ld)[sn] + ip ];

	if (v == 0.0) continue;

	(C->rowind)[next] = i;
	(C->values)[next] = v;
	next++;
      }
      for(ip=(L->sn_size)[sn]; ip<(L->sn_up_size)[sn]; ip++) {
	i = (L->sn_struct)[sn][ ip ];
	v = (L->up_blocks)[sn][ jp*(L->up_blocks_ld)[sn] + (ip-(L->sn_size)[sn]) ];

	if (v == 0.0) continue;

	(C->rowind)[next] = i;
	(C->values)[next] = v;
	next++;
      }
    }
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(sn=0; sn<L->n_sn; sn++)
    for(jp=0; jp<(L->sn_size)[sn]; jp++) 
      nnz += (L->sn_up_size)[sn] - jp;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( j = 0 ; j < ma ; j++ )
        for( i = 0 ; i < na ; i++ )
        {
            At[i + na * j] = A[j + ma * i];
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i <= n ; i++ )
    {
        B->p[i] = 0;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( k = 0 ; k < nel ; k++ )
    {
        B->p[A->icol[k]]++;    
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 2 ; i <= n ; i++ )
    {
        B->p[i] += B->p[i - 1];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < m ; i++ )
        for( count = 0 ; count < A->mnel[i] ; count++ )
        {
            j = A->icol[k] - 1;
            kb = B->p[j];  
            B->irow[kb] = i;
            B->R[kb] = A->R[k];
            if (it == 1)
            {
                B->I[kb] = A->I[k];
            }
            B->p[j]++;
            k++;
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = n - 1 ; i > 0 ; i-- )
    {
        B->p[i] = B->p[i - 1];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < A->m ; i++ )
    {
        nb_elem_row_i = A->mnel[i];
        if (nb_elem_row_i > 0  &&  A->icol[k] <= i)
        {
            return 0;
        }
        k += nb_elem_row_i;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < n ; i++ )
    {
        if ( A->mnel[i] > 0 )
        {
            l = 0;
            while ( l < A->mnel[i]  &&  A->icol[k + l] < i + 1 ) 
            {
                l++;
            }
            if ( l >= A->mnel[i] )          
            {
                return ( MAT_IS_NOT_SPD );
            }
            else if ( A->icol[k + l] > i + 1 ) 
            {
                return ( MAT_IS_NOT_SPD );
            }
            else if ( A->R[k + l] <= 0 )    
            {
                return ( MAT_IS_NOT_SPD );
            }
            else                            
            {
                if ( nnz + A->mnel[i] - l > B_nel )
                {
                    return ( MAT_IS_NOT_SPD );
                }
                B->colptr[i] = nnz;
                for( p = l ; p < A->mnel[i] ; p++)
                {
                    B->values[nnz] = A->R[k + p];
                    B->rowind[nnz] = A->icol[k + p] - 1;
                    nnz++;
                }
                k = k + A->mnel[i];
            }
        }
        else
        {
            return ( MAT_IS_NOT_SPD );
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < A->m ; i++ )
    {
        temp = 0.0;
        for( l = 0 ; l < A->mnel[i] ; l++ )
        {
            j = A->icol[k] - 1;
            temp += (long double) A->R[k]  *  (long double) x[j];
            k++;
        }
        temp -=  (long double) b[i];
        r[i] = (double) temp;
        norm2 += temp * temp;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < A->m ; i++ )
        {
            wk[i] = -(long double) b[i];
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < A->m ; i++ )
        {
            for( l = 0 ; l < A->mnel[i] ; l++ )
            {
                j = A->icol[k] - 1;
                wk[i] += (long double) A->R[k]  *  (long double) x[j];
                if ( j != i )
                {
                    wk[j] += (long double) A->R[k]  *  (long double) x[i];
                }
                k++;
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < A->m ; i++ )
        {
            r[i] = (double) wk[i];
            norm2 += wk[i] * wk[i];
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < A->m ; i++ )
    {
        tempr = 0.0;
        tempi = 0.0;
        for( l = 0 ; l < A->mnel[i] ; l++ )
        {
            j = A->icol[k] - 1;
            tempr +=   (long double) A->R[k]  *  (long double) xr[j]
                       - (long double) A->I[k]  *  (long double) xi[j];
            tempi +=   (long double) A->I[k]  *  (long double) xr[j]
                       + (long double) A->R[k]  *  (long double) xi[j];
            k++;
        }
        tempr -=  (long double) br[i];
        tempi -=  (long double) bi[i];
        rr[i] = (double) tempr;
        ri[i] = (double) tempi;
        norm2 += tempr * tempr + tempi * tempi;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < n_row ; i++ ) Rs[i] = 1.0 / Rs[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < n_row ; i++ ) 
	{
		L_mnel[i] = L_ptrow[i+1] - L_ptrow[i];
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < n ; i++ ) 
	{
		U_mnel[i] = U_ptrow[i+1] - U_ptrow[i];
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < lnz ; i++ ) L_icol[i]++;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < unz ; i++ ) U_icol[i]++;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < n_row ; i++ ) p[i]++; 



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < n_col ; i++ ) q[i]++; 



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < nb ; i++ )
			residu_with_prec(&A, stk(lxr+i*mx), stk(lbr+i*mb), stk(lrr+i*mb), stk(ln+i));



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < mx*nx ; i++ ) *stk(lxi+i) = 0.0;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < mb*nb ; i++ ) *stk(lbi+i) = 0.0;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < nb ; i++ )
						residu_with_prec(&A, stk(lxr+i*mx), stk(lbr+i*mb), stk(lrr+i*mb), stk(ln+i));



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < nb ; i++ )
						residu_with_prec(&A, stk(lxi+i*mx), stk(lbi+i*mb), stk(lri+i*mb), stk(lni+i));



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < nb ; i++ )
						*stk(ln+i) = sqrt( *stk(ln+i)**stk(ln+i) +  *stk(lni+i)**stk(lni+i) );



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < nb ; i++ )
					cmplx_residu_with_prec(&A, stk(lxr+i*mx), stk(lxi+i*mx),



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < mb * nb ; i++ ) bi[i] = 0.0;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( j = 0; j < nb ; j++ )
        {
            umfpack_di_wsolve(umf_flag, A.p, A.irow, A.R, &xr[j * mb], &br[j * mb], Numeric, Control, Info, Wi, W);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( j = 0; j < nb ; j++ )
            {
                umfpack_di_wsolve(umf_flag, A.p, A.irow, A.R, &xi[j * mb], &bi[j * mb], Numeric, Control, Info, Wi, W);
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( j = 0; j < nb ; j++ )
        {
            umfpack_zi_wsolve(umf_flag, A.p, A.irow, A.R, A.I, &xr[j * mb], &xi[j * mb], &br[j * mb], &bi[j * mb], Numeric, Control, Info, Wi, W);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0 ; i < C->m ; i++)
		{
			C->colptr[i] = C->colptr[i+1] - C->colptr[i];
			nnz += C->colptr[i];
		}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < nnz ; i++ )
		C->rowind[i]++;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0 ; i < S.m ; i++) *istk(lp+i) = pC->p[i]+1;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( j = 0; j < nb ; j++ )
    {
        taucs_vec_permute(n, &b[j * mb], &x[j * mb], pC->p);
        taucs_supernodal_solve_llt(pC->C, v, &x[j * mb]); 
        taucs_vec_ipermute(n, v, &x[j * mb], pC->p);
        if ( Refinement )
        {
            
            residu_with_prec_for_chol(&A, &x[j * mb], &b[j * mb], res, &norm_res, A_is_upper_triangular, wk);
            


            taucs_vec_permute(n, res, v, pC->p);
            taucs_supernodal_solve_llt(pC->C, res, v);  
            taucs_vec_ipermute(n, res, v, pC->p);
            for( i = 0 ; i < n ; i++ )
                v[i] = x[j * mb + i] - v[i]; 
            residu_with_prec_for_chol(&A, v, &b[j * mb], res, &norm_res_bis, A_is_upper_triangular, wk);
            
            if ( norm_res_bis < norm_res )
                for( i = 0 ; i < n ; i++ )
                    x[j * mb + i] = v[i];
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < mb*nb ; i++ ) bi[i] = 0.0;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < nb ; i++ )
			{
				umfpack_di_wsolve(UMFPACK_A, A.p, A.irow, A.R, &xr[i*mb], &br[i*mb],
								  Numeric, Control, Info, Wi, W);
			}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < nb ; i++ )
				{
					umfpack_di_wsolve(UMFPACK_A, A.p, A.irow, A.R, &xi[i*mb], &bi[i*mb],
									  Numeric, Control, Info, Wi, W);
				}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < nb ; i++ )
			{
				umfpack_zi_wsolve(UMFPACK_A, A.p, A.irow, A.R, A.I, &xr[i*mb], &xi[i*mb], 
								  &br[i*mb], &bi[i*mb], Numeric, Control, Info, Wi, W);
			}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i=0 ; i < mb ; i++ )
			{
				umfpack_di_wsolve(UMFPACK_At, A.p, A.irow, A.R, &br[i*nb], &xr[i*nb],
								  Numeric, Control, Info, Wi, W);      
			}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i=0 ; i < mb ; i++ )
				{
					umfpack_di_wsolve(UMFPACK_At, A.p, A.irow, A.R, &bi[i*nb], &xi[i*nb], 
									  Numeric, Control, Info, Wi, W);      
				}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i=0 ; i < mb ; i++ )
			{
				umfpack_zi_wsolve(UMFPACK_Aat, A.p, A.irow, A.R, A.I, &br[i*nb], &bi[i*nb],
								  &xr[i*nb], &xi[i*nb], Numeric, Control, Info, Wi, W);
			}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < (int)wcslen(duplicate_path); i++)
		{
#ifdef _MSC_VER
			if (duplicate_path[i] == L'/') duplicate_path[i] = L'\\';
#else
			if (duplicate_path[i] == L'\\') duplicate_path[i] = L'/';
#endif
		}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i=0; i< n; i++) {				\
	swap_generic((char *)val,(char *)&temp, sizeof(Type));	\
        val++;						\
	fwrite(&temp,sizeof(Type),1,fa);		\
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i=0; i< n; i++) {			\
      Type  val = (char) *res++;		\
      fwrite(&val,sizeof(Type),1,fa);		\
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i=0; i< n; i++) {					\
      val =(Type)res[i];					\
      if ( swap) {						\
	unsigned long long temp;				\
	swap_generic((char *)&val,(char *)&temp, sizeof(Type));	\
	fwrite(&temp,sizeof(Type),1,fa);			\
      }								\
      else fwrite(&val,sizeof(Type),1,fa);			\
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < NB_ALIAS; i++)
		{
			int lenAlias = 0;

			
			if (wcscmp(VARIABLES_words[i].Alias, wcstr) == 0)
			{
				wchar_t *wcexpanded = getVariableValueDefinedInScilab(VARIABLES_words[i].VariableName);
				if (wcexpanded)
				{
					 return convertFileSeparators(wcexpanded);
				}
			}

			lenAlias = (int)wcslen(VARIABLES_words[i].Alias);

			if (lenStr > lenAlias)
			{
				wchar_t *wcBegin = (wchar_t *)MALLOC(sizeof(wchar_t) * (lenAlias + 1));
				if (wcBegin)
				{
					wcsncpy(wcBegin, wcstr, lenAlias);
					wcBegin[lenAlias] = 0;

					if (wcscmp(wcBegin,VARIABLES_words[i].Alias)== 0 )
					{
						if ( (wcstr[lenAlias] == L'/') || (wcstr[lenAlias] == L'\\') )
						{
							wchar_t * newBegin = getVariableValueDefinedInScilab(VARIABLES_words[i].VariableName);
							if (newBegin)
							{
								int lengthnewBegin = (int)wcslen(newBegin);
								wcexpanded = (wchar_t *)MALLOC(sizeof(wchar_t)* (lengthnewBegin + (int)wcslen(&wcstr[lenAlias]) + 1));
								if (wcexpanded)
								{
									wcscpy(wcexpanded, newBegin);
									wcscat(wcexpanded, &wcstr[lenAlias]);
									FREE(wcBegin); wcBegin = NULL;
									FREE(newBegin); newBegin = NULL;
									return convertFileSeparators(wcexpanded);
								}
								FREE(newBegin); newBegin = NULL;
							}
						}
					}
					FREE(wcBegin);wcBegin = NULL;
				}
			}
		}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k=0 ; k < len ;k++) if (wcStr[k] == L'/') wcStr[k] = L'\\';



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k=0 ; k < len ;k++) if (wcStr[k] == L'\\') wcStr[k] = L'/';



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < len; i++)
            {
                unsigned char *outUtfChar = NULL;
                unsigned char inAnsiChar = 0;

                if (_inString[i] < 0)
                {
                    inAnsiChar = 256 + _inString[i];
                }
                else
                {
                    inAnsiChar = _inString[i];
                }

                if (inAnsiChar < 128)
                {
                    outUtfChar = (char *)CALLOC(2, sizeof(char));
                    if (outUtfChar)
                    {
                        outUtfChar[0] = inAnsiChar;
                        outUtfChar[1] = 0;
                    }
                }
                else
                {
                    outUtfChar = (char *)CALLOC(3, sizeof(char));
                    if (outUtfChar)
                    {
                        outUtfChar[0] = (inAnsiChar >> 6) | 0xC0;
                        outUtfChar[1] = (inAnsiChar & 0x3F) | 0x80;
                        outUtfChar[2] = 0;
                    }
                }

                if (outUtfChar)
                {
                    strcat(outString, outUtfChar);
                    FREE(outUtfChar);
                    outUtfChar = NULL;
                }
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < *_iSize ; i++)
            {
                uint32_t val;
                val = *(uint32_t*)RES_ul++;
                writeInt(val, fa, iEndian);
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < *_iSize ; i++)
            {
                unsigned short val;
                val = *(unsigned short*)RES_us++;
                writeShort(val, fa, iEndian);
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < *_iSize ; i++)
            {
                unsigned char val;
                val = *(unsigned char*)RES_uc++;
                writeChar(val, fa, iEndian);
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0 ; i < *_iSize ; i++)
            {
                uint32_t val;
                val = readInt(fa, iEndian);
                if (feof(fa))
                {
                    iCount = i;
                    break;
                }

                *RES_ul++ = val;
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0 ; i < *_iSize ; i++)
            {
                unsigned short val;
                val = readShort(fa, iEndian);
                if (feof(fa))
                {
                    iCount = i;
                    break;
                }

                *RES_us++ = val;
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0 ; i < *_iSize ; i++)
            {
                unsigned char val;
                val = readChar(fa, iEndian);
                if (feof(fa))
                {
                    iCount = i;
                    break;
                }

                *RES_uc++ = val;
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < sizeTextAdded; i++) 
            {
                if (textAdded[i])
                {
                    fprintf(fd, "%s\n", textAdded[i]);
                }
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0 ; i < m ; i++ )
    {
        int j = 0;
        for( j = 0 ; j < n ; j++)
        {
            if (ISNAN(MatrixValues[i + m*j]))
            {
                char *localFormat = replaceInFormat(format);
                if (localFormat)
                {
                    fprintf(fd, localFormat, NanString);
                    FREE(localFormat);
                    localFormat = NULL;
                }
                else
                {
                    fprintf(fd, format, MatrixValues[i + m*j]);
                }
            }
            else if (finite(MatrixValues[i + m*j]))
            {
                fprintf(fd, format, MatrixValues[i + m*j]);
            }
            else
            {
                if ( signbit(MatrixValues[i + m*j]) )
                {
                    char *localFormat = replaceInFormat(format);
                    if (localFormat)
                    {
                        fprintf(fd, localFormat, NegInfString);
                        FREE(localFormat);
                        localFormat = NULL;
                    }
                    else
                    {
                        fprintf(fd, format, MatrixValues[i + m*j]);
                    }
                }
                else
                {
                    char *localFormat = replaceInFormat(format);
                    if (localFormat)
                    {
                        fprintf(fd, localFormat,InfString);
                        FREE(localFormat);
                        localFormat = NULL;
                    }
                    else
                    {
                        fprintf(fd, format, MatrixValues[i + m*j]);
                    }
                }
            }

            fprintf(fd, "%s", separator);
        }
        fprintf(fd, EOL);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < NB_FORMAT_SUPPORTED; i++)
            {
                char *token = strstr(percent, supportedFormat[i]);
                if (token)
                {
                    int nbcharacters = (int)(strlen(percent) - strlen(token));          
                    cleanedFormat = strdup(percent);
                    cleanedFormat[nbcharacters] = 0;
                    if ( ((nbcharacters - 1 > 0) && (isdigit(cleanedFormat[nbcharacters-1])) ||
                        (cleanedFormat[nbcharacters-1]) == '.') ||
                        (cleanedFormat[nbcharacters-1]) == '%')
                    {
                        strcat(cleanedFormat, supportedFormat[i]);
                        return cleanedFormat;
                    }
                    else
                    {
                        FREE(cleanedFormat);
                        cleanedFormat = NULL;
                    }
                }
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 1 ; i < GetMaximumFileOpenedInScilab() ; i++) 
	{
		if ( GetFileTypeOpenedInScilab(i) == 0 ) 
		{
			*fd = i;
			return ;
		}
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( fd1=0; fd1< GetMaximumFileOpenedInScilab(); fd1++) 
		{
			FILE* stream=GetFileOpenedInScilab(fd1) ;
			if ( stream )
			{
				int res1 = 1;
				res1=fclose( stream );
				// this function previously called ferror on a just before fclosed FILE* that could lead to crash at exit, depending on libc implementation.
				if (res1 != 0) *res =1;
				C2F(delfile)(&fd1);
				
				
				SetCurrentFileId(-1);
			}
		}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i <= *nargs; i++)
    {
        if (type[i - 1] == SF_C)
        {
            sval = (char *)ptrtab[i - 1];
            sval[nc[i - 1]] = '\0';
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0 ; i < _len ; i++)
    {
        _out[i] = _in[(_len - 1) - i];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < dim_filenames; i++)
		{
			int k = 0;
			int ierr = 0;
			double * FILEINFO_ARRAY = fileinfo(filenames[i],&ierr);
			if (FILEINFO_ARRAY == NULL)
			{
				FILEINFO_ARRAY = (double*)MALLOC(sizeof(double)*FILEINFO_ARRAY_SIZE);

				FILEINFO_ARRAY[FILEINFO_TOTAL_SIZE_INDICE] = C2F(returnanan)();
				FILEINFO_ARRAY[FILEINFO_MODE_INDICE] = C2F(returnanan)();
				FILEINFO_ARRAY[FILEINFO_UID_INDICE] =  C2F(returnanan)();
				FILEINFO_ARRAY[FILEINFO_GID_INDICE] =  C2F(returnanan)();
				FILEINFO_ARRAY[FILEINFO_DEV_INDICE] =  C2F(returnanan)();
				FILEINFO_ARRAY[FILEINFO_MTIME_INDICE] =  C2F(returnanan)();
				FILEINFO_ARRAY[FILEINFO_CTIME_INDICE] =  C2F(returnanan)();
				FILEINFO_ARRAY[FILEINFO_ATIME_INDICE] =  C2F(returnanan)();
				FILEINFO_ARRAY[FILEINFO_RDEV_INDICE] =  C2F(returnanan)();
				FILEINFO_ARRAY[FILEINFO_BLKSIZE_INDICE] =  C2F(returnanan)();
				FILEINFO_ARRAY[FILEINFO_BLOCKS_INDICE] =  C2F(returnanan)();
				FILEINFO_ARRAY[FILEINFO_INO_INDICE] =  C2F(returnanan)();
				FILEINFO_ARRAY[FILEINFO_NLINK_INDICE] =  C2F(returnanan)();
			}

			for(k = 0;k < FILEINFO_ARRAY_SIZE; k++)
			{
				FILES_INFO_ARRAY[j+k] = FILEINFO_ARRAY[k];
			}
			j = j + FILEINFO_ARRAY_SIZE;
			FREE(FILEINFO_ARRAY);
			FILEINFO_ARRAY = NULL;
			ierrs[i] = ierr;
		}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < sizeStrings; i++)
    {
        if (fw == stdout)
        {
            sciprint(MPUTL_FORMAT, pStrings[i]);
        }
        else
        {
            fprintf(fw, MPUTL_FORMAT, pStrings[i]);
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 2; i <= Lhs ; i++)
      {
	iarg++;
	CreateVar(iarg,MATRIX_OF_DOUBLE_DATATYPE,&zero,&zero,&l);
	LhsVar(i) = iarg;
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i=0 ; i < ncol ; i++) {
      if ( (type[i] == SF_C) || (type[i] == SF_S) ) {
	if( (temp = (char **) MALLOC(nrow*ncol*sizeof(char **)))==NULL) return MEM_LACK;
	k=0;
	for(j=0;j<nrow;j++) temp[k++]=data[i+ncol*j].s;
	CreateVarFromPtr(++iarg,MATRIX_OF_STRING_DATATYPE, &nrow, &one, temp);
	FREE(temp);
	
      }
      else {
	CreateVar(++iarg,MATRIX_OF_DOUBLE_DATATYPE, &nrow, &one, &l);
	for( j=0 ; j < nrow ; j++)
	  *stk(l+j)= data[i+ncol*j].d;
      }

      LhsVar(i+2)=iarg;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = ncol+2; i <= Lhs ; i++)
      {
	iarg++;
	CreateVar(iarg,MATRIX_OF_DOUBLE_DATATYPE,&zero,&zero,&l);
	LhsVar(i) = iarg;
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<ncol;i++)
      if (type[i] != cur_type) 	{
	multi=1;
	break;
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i1=cur_i;i1<i;i1++)
	      for(j=0;j<nrow;j++) temp[k++]=data[i1+ncol*j].s;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i1=cur_i;i1<i;i1++) {
	      for( j=0 ; j < nrow ; j++)
		*stk(l+j+nrow*ii)= data[i1+ncol*j].d;
	      ii++;
	    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i1=0;i1<ncol;i1++)
	  for(j=0;j<nrow;j++) temp[k++]=data[i1+ncol*j].s;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i1=0;i1<ncol;i1++) {
	  for( j=0 ; j < nrow ; j++)
	    *stk(l+j+nrow*ii)= data[i1+ncol*j].d;
	  ii++;
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i=0 ; i < MAXSCAN ; i++) type_s[i]=SF_F; 



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i=0 ; i < nc ; i++) type_s[i]=type[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i=0 ; i < nc ; i++)
      if (type[i] != type_s[i]) {
	err=MISMATCH;
	goto bad2;
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i=0 ; i < nc ; i++)
    {
      switch ( type_s[i] )
	{
	case SF_C:
	case SF_S:
	  Data[i+nc*rowcount].s=buf[i].c;
	  break;
	case SF_LUI:
	  Data[i+nc*rowcount].d=(double)buf[i].lui;
	  break;
	case SF_SUI:
	  Data[i+nc*rowcount].d=(double)buf[i].sui;
	  break;
	case SF_UI:
	  Data[i+nc*rowcount].d=(double)buf[i].ui;
	  break;
	case SF_LI:
	  Data[i+nc*rowcount].d=(double)buf[i].li;
	  break;
	case SF_SI:
	  Data[i+nc*rowcount].d=(double)buf[i].si;
	  break;
	case SF_I:
	  Data[i+nc*rowcount].d=(double)buf[i].i;
	  break;
	case SF_LF:
	  Data[i+nc*rowcount].d=buf[i].lf;
	  break;
	case SF_F:
	  Data[i+nc*rowcount].d=(double)buf[i].f;
	  break;
	}
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( j=0 ; j < MAXSCAN ; j++)
    if ( (type_s[j] ==  SF_C) || (type_s[j] ==  SF_S))  FREE(buf[j].c);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( j=0 ; j < ncol ; j++)
      if ( (type_s[j] ==  SF_C) || (type_s[j] ==  SF_S) )
	
	for( i=0 ; i < nrow ; i++) {
	  FREE(Data[j+ncol*i].s);
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0; i < lenPath; i++)
        {
#ifdef _MSC_VER
            if (wcPath[i] == L'/') wcPath[i] = L'\\';
#else
            if (wcPath[i] == L'\\') wcPath[i] = L'/';
#endif
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i < CurrentMaxFiles; i++)
            {
                scilabfile *ptrScilabFile = &ScilabFileList[i];
                memcpy(ptrScilabFile, &initializedScilabFile, sizeof(scilabfile));
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=CurrentMaxFiles;i<NewSize;i++)
                {
                    ScilabFileList[i].ftformat=NULL;
                    ScilabFileList[i].ftmode=0;
                    ScilabFileList[i].ftname=NULL;
                    ScilabFileList[i].ftswap=0;
                    ScilabFileList[i].fttype=0;
                }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<CurrentMaxFiles;i++)
        {
            if ( (ScilabFileList[i].ftformat) && ScilabFileList[i].ftname)
            {
                if (strcmp(ScilabFileList[i].ftname,fullpath) == 0) return TRUE;
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < CurrentMaxFiles; i++)
        {
            if ( (ScilabFileList[i].ftformat) && ScilabFileList[i].ftname)
            {
                if (strcmp(ScilabFileList[i].ftname,fullpath) == 0) return i;
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < GetMaximumFileOpenedInScilab(); i++)
    {
        if (GetFileTypeOpenedInScilab(i) != 0)
        {
            ArrayIdUsed[j] = (double)i;
            j++;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < GetMaximumFileOpenedInScilab(); i++)
    {
        if (GetFileTypeOpenedInScilab(i) != 0)
        {
            ArraySwapUsed[j] = (double)GetSwapStatus(i);
            j++;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < GetMaximumFileOpenedInScilab(); i++)
    {
        if (GetFileTypeOpenedInScilab(i) != 0)
        {
            ArrayModeUsed[j] = (double)GetFileModeOpenedInScilab(i);
            j++;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < GetMaximumFileOpenedInScilab(); i++)
    {
        if (GetFileTypeOpenedInScilab(i) != 0)
        {
            ArrayTypeUsed[j] = GetFileTypeOpenedInScilab(i);
            j++;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < GetMaximumFileOpenedInScilab(); i++)
    {
        if (GetFileTypeOpenedInScilab(i) != 0)
        {
            ArrayTypeUsedAsString[j] = GetFileTypeOpenedInScilabAsString(i);
            j++;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < GetMaximumFileOpenedInScilab(); i++)
    {
        if (GetFileTypeOpenedInScilab(i) != 0)
        {
            if (GetFileNameOpenedInScilab(i))
            {
                FilenamesArray[j] = strdup(GetFileNameOpenedInScilab(i));
            }
            else
            {
                FilenamesArray[j] = strdup("");
            }
            j++;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < GetMaximumFileOpenedInScilab(); i++)
    {
        if (GetFileTypeOpenedInScilab(i) != 0)
        {
            numberOfIds++;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i=0; i< n; i++)  {					\
	unsigned long long tmp;					\
	items+=(int)fread(&tmp,sizeof(Type),1,fa);		\
	swap_generic((char *)&tmp,(char *)val, sizeof(Type));	\
	val++;							\
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = items-1 ; i >=0 ; i--)		\



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k=0;k<n;k++)
	{
		if (status[k]=='r') md = 1;
		else if (status[k]=='w') md = 2;	
		else if (status[k]=='a') md = 3;	
		else if (status[k]=='+') plus = 1;
		else if (status[k]=='b') bin = 1;
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < levels; i++)
    {
        relativeFilename[rfMarker++] = '.';
        relativeFilename[rfMarker++] = '.';
        relativeFilename[rfMarker++] = DIR_SEPARATOR[0];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < (int)wcslen(convertedPath); i++)
            {
                if (PTypelocal == WINDOWS_STYLE)
                {
                    if (convertedPath[i] == L'/') convertedPath[i] = L'\\';
                }
                else
                {
                    if (convertedPath[i] == L'\\') convertedPath[i] = L'/';
                }
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = nbLinesTextDetected; i < nblines; i++)
                    {
                        if (lines[i])
                        {
                            FREE(lines[i]);
                            lines[i] = NULL;
                        }
                    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < sizelines; i++)
        {
            if (!itCanBeMatrixLine(lines[i], format, separator))
            {
                numberOfLines++;
            }
            else
            {
                return numberOfLines;
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = firstLinesMatrix; i < sizelines; i++)
        {
            NbColumns = getNbColumnsInLine(lines[i], format, separator);
            if (firstLine)
            {
                previousNbColumns = NbColumns;
                firstLine = FALSE;
            }
            else
            {
                if (previousNbColumns != NbColumns)
                {
                    return 0;
                }
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nbTokens; i++)
            {
                double dValue = 0.;
                int ierr = sscanf(splittedStr[i], format, &dValue);
                if ((ierr != 0) && (ierr != EOF))
                {
                    nbColums++;
                }
                else
                {
                    char *str = strdup(splittedStr[i]);
                    strcpy(str, "");

                    ierr = sscanf(splittedStr[i], "%4s", str);

                    if ((ierr != 0) && (ierr != EOF))
                    {
                        if ( (strcmp(str, NanString) == 0) ||
                                (strcmp(str, NegInfString) == 0) ||
                                (strcmp(str, InfString) == 0) )
                        {
                            nbColums++;
                        }
                        else
                        {
                            freeArrayOfString(splittedStr, nbTokens);
                            
                            if (nbColums)
                            {
                                nbColums--;
                            }
                            FREE(str);
                            str = NULL;
                            return nbColums;
                        }
                    }
                    else
                    {
                        FREE(str);
                        str = NULL;
                        freeArrayOfString(splittedStr, nbTokens);
                        return nbColums;
                    }

                    FREE(str);
                    str = NULL;
                }
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = firstLinesMatrix; i < sizelines; i++)
        {
            double *dValsTmp = getDoubleValuesInLine(lines[i], format, separator, m);
            if (dValsTmp)
            {
                int j = 0;
                for(j = 0; j < m; j++)
                {
                    dValues[(i - firstLinesMatrix) + n * j] = dValsTmp[j];
                }
                FREE(dValsTmp);
                dValsTmp = NULL;
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nbColumnsMax; i++)
            {
                double dValue = 0.;
                int ierr = sscanf(splittedStr[i], format, &dValue);
                if ((ierr != 0) && (ierr != EOF))
                {
                    dValues[i] = dValue;
                }
                else
                {
                    char *str = strdup(line);
                    strcpy(str, "");
                    ierr = sscanf(splittedStr[i], "%4s", str);
                    if ((ierr != 0) && (ierr != EOF))
                    {
                        if ( (strcmp(str, NanString) == 0) ||
                                (strcmp(str, NegInfString) == 0) ||
                                (strcmp(str, InfString) == 0) )
                        {
                            if (strcmp(str, NanString) == 0)
                            {
                                dValues[i] = returnNAN();
                            }

                            if (strcmp(str, NegInfString) == 0)
                            {
                                dValues[i] = returnINF(FALSE);
                            }

                            if (strcmp(str, InfString) == 0)
                            {
                                dValues[i] = returnINF(TRUE);
                            }
                        }
                        else
                        {
                            freeArrayOfString(splittedStr, nbTokens);
                            FREE(dValues);
                            dValues = NULL;
                            FREE(str);
                            str = NULL;
                            return NULL;
                        }
                    }
                    else
                    {
                        freeArrayOfString(splittedStr, nbTokens);
                        FREE(dValues);
                        dValues = NULL;
                        FREE(str);
                        str = NULL;
                        return NULL;
                    }
                    FREE(str);
                    str = NULL;
                }
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < NB_FORMAT_SUPPORTED; i++)
            {
                char *token = strstr(percent, supportedFormat[i]);
                if (token)
                {
                    int nbcharacters = (int)(strlen(percent) - strlen(token));
                    cleanedFormat = strdup(percent);
                    cleanedFormat[nbcharacters] = 0;
                    if ( (nbcharacters - 1 > 0) && (isdigit(cleanedFormat[nbcharacters - 1]) ||
                                                    (cleanedFormat[nbcharacters - 1]) == '.') ||
                            (cleanedFormat[nbcharacters - 1]) == '%')
                    {
                        strcat(cleanedFormat, supportedFormat[i]);
                        return cleanedFormat;
                    }
                    else
                    {
                        FREE(cleanedFormat);
                        cleanedFormat = NULL;
                    }
                }
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = *sizelines - 1; i >= 0; i--)
        {
            if (lines[i])
            {
                if ( (strcmp(lines[i], "") == 0) || (isOnlyBlankLine(lines[i])) )
                {
                    FREE(lines[i]);
                    lines[i] = NULL;
                    nbLinesToRemove++;
                }
                else
                {
                    break;
                }
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < (int) strlen(line); i++)
        {
            if (line[i] != ' ')
            {
                return FALSE;
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = *sizelines - 1; i > 0; i--)
    {
        if (itCanBeMatrixLine(lines[i], format, separator) == FALSE)
        {
            nbLinesToRemove++;
        }
        else
        {
            break;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < m1 * n1; i++)
        {
            pStVarOne[i] = (wchar_t *) MALLOC(sizeof(wchar_t) * (lenStVarOne[i] + 1));
            if (pStVarOne[i] == NULL)
            {
                if (lenStVarOne)
                {
                    FREE(lenStVarOne);
                    lenStVarOne = NULL;
                }
                freeArrayOfWideString(pStVarOne, m1 * n1);
                Scierror(999, _("%s: Memory allocation error.\n"), fname);
                FREE(results);
                return 0;
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < m1 * n1; i++)
        {
            results[i] = pathconvertW(pStVarOne[i], flagtrail, flagexpand, PType);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0; i < n5 ; i++) 
			{
				*stk(l5+i) = *stk(l4+i);
			}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < m1 * n1; i++)
    {
        pStVarOne[i] = (wchar_t*)MALLOC(sizeof(wchar_t) * (lenStVarOne[i] + 1));
        if (pStVarOne[i] == NULL)
        {
            if (i == 0)
            {
                FREE(pStVarOne);
            }
            else
            {
                freeArrayOfWideString(pStVarOne, i - 1);
            }
            if (lenStVarOne)
            {
                FREE(lenStVarOne);
                lenStVarOne = NULL;
            }
            FREE(results);
            Scierror(999, _("%s: Memory allocation error.\n"), fname);
            return 0;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < m1 * n1; i++)
    {
        wchar_t *expandedPath = expandPathVariableW(pStVarOne[i]);
        if (expandedPath)
        {
            results[i] = isdirW(expandedPath);
            FREE(expandedPath);
            expandedPath = NULL;
        }
        else
        {
            results[i] = FALSE;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < mnOne; i++)
    {
        char fullpathtmp[PATH_MAX*4];
        strcpy(fullpathtmp, "");
        if( get_full_path(fullpathtmp, pStVarOne[i], PATH_MAX*4 ) != NULL )
        {
            pStFullPath[i] = strdup(fullpathtmp);
        }
        else
        {
            Scierror(999,_("%s: Wrong value for input argument #%d: '%s' is an invalid path.\n"),fname,1, pStVarOne[i]);
            freeAllocatedMatrixOfString(mOne, nOne, pStVarOne);
            freeArrayOfString(pStFullPath, mnOne);
            return 0;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < m1*n1; i++)
			{
				if (Input_filenames[i])
				{
					
					Output_extensions[i] = FindFileExtension(Input_filenames[i]);
				}
				else
				{
					Output_extensions[i] = NULL;
				}

				if (Output_extensions[i] == NULL)
				{
					Output_extensions[i] = strdup("");
				}
			}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=fdmax-1;i>=0;i--)
				{
					FILE fa;
					int swap2 = 0;
					int type = 0;
					int mode = 0;

					int lf = 0;
					int ierr = 0;

					int posBeginFileName = 0;

					C2F(getfileinfo)(&i, &fa, &swap2,&type,&mode,fileNameFormList,&lf,&ierr);
					if (ierr == 0)
					{
						posBeginFileName = (int)(strlen(fileNameFormList)-strlen(filename));

						if ( posBeginFileName > 0 )
						{
							char *cmptmp = NULL;
							cmptmp = &fileNameFormList[posBeginFileName];
#if _MSC_VER
							// path on windows are not really case sensitive
							if ( _stricmp(cmptmp,filename) == 0 )
#else
							if ( strcmp(cmptmp,filename) == 0 )
#endif
							{	
								absolute_file_path=(char *)MALLOC(sizeof(char)*(strlen(fileNameFormList)+1));
								if (absolute_file_path)
								{
									strncpy(absolute_file_path,fileNameFormList,posBeginFileName);
									absolute_file_path[posBeginFileName]='\0';
									break;
								}
							}
						}
					}
				}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < m1 * n1; i++)
    {
        pStVarOne[i] = (wchar_t*)MALLOC(sizeof(wchar_t) * (lenStVarOne[i] + 1));
        if (pStVarOne[i] == NULL)
        {
            if (i == 0)
            {
                FREE(pStVarOne);
            }
            else
            {
                freeArrayOfWideString(pStVarOne, i - 1);
            }
            if (lenStVarOne)
            {
                FREE(lenStVarOne);
                lenStVarOne = NULL;
            }
            FREE(results);
            Scierror(999, _("%s: Memory allocation error.\n"), fname);
            return 0;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < m1 * n1; i++)
    {
        wchar_t *expandedPath = expandPathVariableW(pStVarOne[i]);
        if (expandedPath)
        {
            results[i] = !isdirW(expandedPath) && FileExistW(expandedPath);
            FREE(expandedPath);
            expandedPath = NULL;
        }
        else
        {
            results[i] = FALSE;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < mn; i++)
                    {
                        *stk(l_out + i) = (double) results[i];
                    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0;i < m1n1; i++)
		{
			LongNames[i] = getlongpathname(ShortNames[i],&bOK[i]);
		}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < NB_DEFAULT_SUPPORTED_SEPARATORS; i++)
        {
            results = fscanfMat(expandedFilename, Format, supportedSeparators[i]);
            if (results && results->err == FSCANFMAT_NO_ERROR)
            {
                break;
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < (m1 * n1); i++)
		{
			pStVarOne[i] = (wchar_t*)MALLOC(sizeof(wchar_t) * (lenStVarOne[i] + 1));
			if (pStVarOne[i] == NULL)
			{
				freeArrayOfWideString(pStVarOne, m1 * n1);
				if (lenStVarOne) {FREE(lenStVarOne); lenStVarOne = NULL;}
				Scierror(999,_("%s: Memory allocation error.\n"),fname);
				return 0;
			}
		}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i< m1 * n1; i++)
		{
			pStResult[i] = basenameW(pStVarOne[i], flagexpand);
		}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < (m4 * n4); i++)
        {
            textAdded[i] = (char*)MALLOC(sizeof(char) * (lengthStrings[i] + 1));
            if (textAdded[i] == NULL)
            {
                freeArrayOfString(textAdded, m4 * n4);
                if (Format) {FREE(Format); Format = NULL;}
                if (lengthStrings) {FREE(lengthStrings); lengthStrings = NULL;}
                Scierror(999,_("%s: Memory allocation error.\n"),fname);
                return 0;
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0;i < m1n1; i++)
		{
			ShortNames[i] = getshortpathname(LongNames[i], &bOK[i]);
		}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < mnOne; i++)
    {
        pStVarOne[i] = (char*)MALLOC(sizeof(char) * (lenStVarOne[i] + 1));
        if (pStVarOne[i] == NULL)
        {
            freeArrayOfString(pStVarOne, i);
            if (lenStVarOne)
            {
                FREE(lenStVarOne);
                lenStVarOne = NULL;
            }
            Scierror(999, _("%s: No more memory.\n"), fname);
            return 0;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( k = 3; k <= Rhs; k++) 
	{
		if (VarType(k) !=sci_matrix && VarType(k) !=sci_strings) 
		{
			OverLoad(k);
			return 0;
		}
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < (int)strlen(ptrFormat); i++)
	{
		if (ptrFormat[i] == '%') 
		{
			NumberPercent++;
			if (ptrFormat[i+1] == '%') 
			{
				NumberPercent--;
				i++;
			}
		}
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 4; k <= Rhs; k++) 
		{
			GetMatrixdims(k, &mk, &nk);
			mx = Min(mx, mk);
		}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i <= Rhs ; i++)
            {
                if (GetType(i) != sci_strings)
                {
                    Scierror(999, _("%s: Wrong type for input argument #%d: String expected.\n"), fname, i);
                    return 0;
                }
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i <= RhsBackup; i++)
                {
                    GetRhsVar(i, STRING_DATATYPE, &m1, &n1, &l1);
                    Str[i - 1] = strdup(cstk(l1));
                }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < numberelemnts ; i++)
    {

        int resultstat = 0;
        char *FileName = NULL;

        FileName = expandPathVariable(ListFilename[i]);

#ifdef _MSC_VER
        if (FileName)
        {
            if ( (FileName[strlen(FileName) - 1] == '/') || (FileName[strlen(FileName) - 1] == '\\') )
            {
                FileName[strlen(FileName) - 1] = '\0';
            }

        }

        {
            wchar_t *pszFileName = to_wide_string(FileName);
            resultstat = _wstat(pszFileName, &buf );
            FREE(pszFileName);
        }
#else
        resultstat = stat(FileName, &buf );
#endif
        if (resultstat == 0)
        {
            if ((long int)buf.st_mtime > MaxTime)
            {
                MaxTime = (long int)buf.st_mtime;
                RetIndex = i + 1;
            }
        }

        FREE(FileName);
        FileName = NULL;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < inarg ; i++ )
    {
        GetRhsVar(i + 2, MATRIX_OF_DOUBLE_DATATYPE, &m[i], &n[i], &l[i]);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 1 ; i < inarg ; i++)
    {
        if ( m[i] != m[i-1] || n[i] != n[i-1])
        {
            Scierror(999,_("%s and %s must have same size.\n"),fname,errnames);
            return 1;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < oarg ; i++)
    {
        CreateVar(i+2+inarg,MATRIX_OF_DOUBLE_DATATYPE,&m[0],&n[0],&l[i+inarg]);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i=0 ; i < m[0]*n[0]; i++)
        {
            (*fonc)(&which,stk(l[callpos[0]]+i),stk(l[callpos[1]]+i),
                stk(l[callpos[2]] +i),stk(l[callpos[3]]+i),
                stk(l[callpos[4]]+i),
                &status,&bound);

            if (status != 0)
            {
                (*foncErr)(status,bound); return 1;
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i=0 ; i < m[0]*n[0]; i++)
        {
            (*fonc)(&which,stk(l[callpos[0]]+i),stk(l[callpos[1]]+i),
                stk(l[callpos[2]] +i),stk(l[callpos[3]]+i),
                stk(l[callpos[4]] +i),stk(l[callpos[5]]+i),
                &status,&bound);

            if (status != 0)
            {
                
                (*foncErr)(status,bound); return 1;
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i=0 ; i < m[0]*n[0]; i++)
        {
            (*fonc)(&which,stk(l[callpos[0]]+i),stk(l[callpos[1]]+i),
                stk(l[callpos[2]] +i),stk(l[callpos[3]]+i),
                &status,&bound);

            if (status != 0)
            {
                (*foncErr)(status,bound); return 1;
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < oarg ; i++)
    {
        LhsVar(i+1) = i+2+inarg;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < sizelines; i++)
        {
            NbColumns = getNumbersOfColumnsInLine(lines[i], separator);
            if (firstLine)
            {
                previousNbColumns = NbColumns;
                firstLine = FALSE;
            }
            else
            {
                if (previousNbColumns != NbColumns)
                {
                    if (getWarningMode())
                    {
                        sciprint(_("%s: Inconsistency found in the columns. At line %d, found %d columns while the previous had %d.\n"), _("Warning"), i + 1, NbColumns, previousNbColumns);
                    }

                    return 0;
                }
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < sizelines; i++)
        {
            int nbTokens = 0;
            char **lineStrings = splitLineCSV(lines[i], separator, &nbTokens, 0);
            int j = 0;

            if (lineStrings == NULL)
            {
                lineStrings = (char**)MALLOC(sizeof(char*) * 1);
                lineStrings[0] = strdup(lines[i]);
                nbTokens = 1;
            }

            if (m != nbTokens)
            {
                freeArrayOfString(results, nbTokens * n);
                FREE(lineStrings);
                return NULL;
            }

            for(j = 0; j < m; j++)
            {

                if (!decimal)
                {
                    results[i + n * j] = strdup(lineStrings[j]);
                }
                else
                {
                    

                    results[i + n * j] = csv_strsubst(lineStrings[j], decimal, getCsvDefaultDecimal());
                }

                if (lineStrings[j])
                {
                    FREE(lineStrings[j]);
                    lineStrings[j] = NULL;
                }
            }
            FREE(lineStrings);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = *sizelines - 1; i >= 0; i--)
            {
                char *cleanedLine = stripCharacters(lines[i]);
                if (cleanedLine)
                {
                    int len = (int) strlen(cleanedLine);
                    FREE(cleanedLine);
                    cleanedLine = NULL;
                    if (len == 0)
                    {
                        nbLinesToRemove++;
                        FREE((char*)lines[i]);
                        lines[i] = NULL;
                    }
                    else
                    {
                        break;
                    }
                }
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < *sizelines; i++)
                {
                    returnedLines[i] = strdup(lines[i]);
                }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < *sizelines; i++)
        {
            char *cleanedLine = stripCharacters(lines[i]);
            if (cleanedLine)
            {
                int len = (int) strlen(cleanedLine);
                FREE(cleanedLine);
                cleanedLine = NULL;
                if (len != 0)
                {
                    if (nbLines == 0)
                    {
                        nbLines++;
                        returnedLines = (char**)MALLOC(sizeof(char*) * nbLines);
                    }
                    else
                    {
                        nbLines++;
                        returnedLines = (char**)REALLOC(returnedLines, sizeof(char*) * nbLines);
                    }

                    if (returnedLines)
                    {
                        returnedLines[nbLines - 1] = strdup(lines[i]);
                    }
                    else
                    {
                        *sizelines = 0;
                        return NULL;
                    }
                }
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < nbLines; j++)
            {
                replacedStrings[j] = strdup(lines[j]);
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nr; i = i++)
            {
                for(j = 0; j < nbLines; j++)
                {
                    replacedStrings[j] = csv_strsubst(replacedStrings[j], toreplace[i], toreplace[nr + i]);
                }
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nbLines; i++)
    {
        int Output_Start = 0;
        int Output_End = 0;
        pcre_error_code answer = pcre_private((char*)lines[i], (char*)regexpcomments, &Output_Start, &Output_End, NULL, NULL);

        if ( (answer == CAN_NOT_COMPILE_PATTERN) || (answer == DELIMITER_NOT_ALPHANUMERIC))
        {
            *nbcomments = 0;
            *iErr = answer;
            return NULL;
        }
        if ( answer == PCRE_FINISHED_OK )
        {
            (*nbcomments)++;
            if (pComments == NULL)
            {
                pComments = (char **)MALLOC(sizeof(char*) * (*nbcomments));
            }
            else
            {
                pComments = (char **)REALLOC(pComments, sizeof(char*) * (*nbcomments));
            }

            if (pComments == NULL)
            {
                *nbcomments = 0;
                *iErr = 1;
                return NULL;
            }
            pComments[(*nbcomments) - 1] = strdup(lines[i]);
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nbLines; i++)
    {
        int Output_Start = 0;
        int Output_End = 0;
        pcre_error_code answer = pcre_private((char*)lines[i], (char*)regexpcomments, &Output_Start, &Output_End, NULL, NULL);
        if ( answer == PCRE_FINISHED_OK )
        {
            FREE((char*)lines[i]);
            lines[i] = NULL;
        }
        else
        {
            (*newNbLines)++;
            if (pLinesCleaned == NULL)
            {
                pLinesCleaned = (char **)MALLOC(sizeof(char*) * (*newNbLines));
            }
            else
            {
                pLinesCleaned = (char **)REALLOC(pLinesCleaned, sizeof(char*) * (*newNbLines));
            }

            if (pLinesCleaned == NULL)
            {
                *newNbLines = 0;
                *iErr = 1;
                return NULL;
            }

            pLinesCleaned[(*newNbLines) - 1] = (char*)lines[i];
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nbSize; i++)
            {
                if (imagpart[i] != 0)
                {
                    pCsvComplexArray->isComplex = 1;
                    break;
                }
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < pCsvComplexArray->nbElements; i++)
            {
                if (pCsvComplexArray->imagPart[i] != 0)
                {
                    isComplex = 1;
                    break;
                }
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < ncol; i++)
                {
                    C2F(mgetnc) (fd, (void*) &ixfe, &one, typ_short, err);
                    if (*err > 0) goto ErrL;
                    C2F(mgetnc) (fd, (void*) &rkvalue, &one, typ_int, err);
                    if (*err > 0) goto ErrL;
                    valeur[row + (colFirst + i)*hauteur] = NumFromRk2(rkvalue);
                }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i <= capacite; i++)
                {
                    (*chainesind)[i] = 0;
                    valeur[i] = NaN;
                }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 0; k < *nsheets; k++) (*Abspos)[k] += init_pos;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nm; i++) (*sst)[i] = NULL;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nm; i++) 
            {
                *err = i; 
                getString(fd, &count, &Len, 1, &((*sst)[i]), err);
                if (*err > 0) goto ErrL;
                
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nm; i++)
            if ( (*sst)[i] != NULL ) FREE((*sst)[i]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < l1; j++)
                {
                    C2F(mgetnc) (fd, (void*)(*str + strindex), &one, typ_char, err);
                    if (*err > 0) goto ErrL;
                    (*str)[strindex + 1] = '\0';
                    strindex += 2;
                    *PosInRecord += 2;
                    UTFEncoding = 0;
                }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < bytesRead; j++)
                {
                    (*str)[strindex] = str1[j];
                    (*str)[strindex + 1] = '\0';
                    strindex += 2;
                }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < BytesToBeRead; j += 2)
        {
            (*str)[strindex] = (*str)[j];
            strindex++;
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < ns; i++)
            if ( (*Sheetnames)[i] != NULL ) FREE((*Sheetnames)[i]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(current_byte = 0; current_byte < ubytes; current_byte++)
    {
        printf("%02X ", *(sector + current_byte));
        if (((current_byte + 1) % 32) == 0)
        {
            int j;

            for(j = current_byte - 31; j <= current_byte; j++)
            {
                if (isalnum(*(sector + j)))
                {
                    printf("%c", *(sector + j));
                }
                else
                {
                    printf(".");
                }
            }
            printf("\n");
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < h->fat_sector_count; i++)
    {
        if (i >= OLE_HEADER_FAT_SECTOR_COUNT_LIMIT)
        {
            break;
        }
        h->FAT[i] = get_4byte_value(fat_start + (LEN_ULONG * i));
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < h->fat_sector_count; i++)
    {
        if (i >= OLE_HEADER_FAT_SECTOR_COUNT_LIMIT)
        {
            break;    
        }
        printf("FAT[%d] = %d\n", i, h->FAT[i]);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < sector_count; i++)
        {
            int getblock_result = 0;

            DOLE LOGGER_log("%s:%d:OLE_load_FAT:DEBUG: Loading sector %d", FL, i);

            getblock_result = OLE_get_block(ole, ole->header.FAT[i], fat_position);
            if (getblock_result != 0)
            {
                
                
                
                
                
                
                
                
                return getblock_result;
            }

            fat_position += ole->header.sector_size;
            if (fat_position > ole->FAT_limit)
            {
                LOGGER_log("%s:%d:OLE_load_FAT:DEBUG: FAT boundary limit exceeded %p > %p", FL, fat_position, ole->FAT_limit);
                return -1;
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < ole->header.dif_sector_count; i++)
            {
                int import_sector;
                unsigned char *DIF = fat_block;
                int tick = 0;
                int getblock_result;

                DOLE LOGGER_log("%s:%d:OLE_load_FAT:DEBUG: Reading DIF/XBAT index-data[%d] from sector 0x%x", FL, i, current_sector);

                getblock_result = OLE_get_block(ole, current_sector, fat_block);
                if (getblock_result != OLE_OK)
                {
                    if (fat_block)
                    {
                        FREE(fat_block);
                    }
                    return getblock_result;
                }

                if (OLE_DPEDANTIC(ole->debug))
                {
                    OLE_print_sector(ole, fat_block, ole->header.sector_size);
                }

                
                
                
                
                

                do
                {
                    import_sector = get_4byte_value(DIF);
                    DOLE LOGGER_log("%s:%d:OLE_load_FAT:DEBUG: import sector = 0x%x", FL, import_sector);

                    if (import_sector >= 0)
                    {
                        if (fat_position + ole->header.sector_size <= ole->FAT_limit)
                        {
                            DOLE LOGGER_log("%s:%d:OLE_load_FAT:DEBUG: Reading DIF/XBAT-data[%d] from sector 0x%x", FL, tick, import_sector);

                            getblock_result = OLE_get_block(ole, import_sector, fat_position);
                            if (getblock_result != OLE_OK)
                            {
                                LOGGER_log(_("%s:%d:OLE_load_FAT:ERROR: Not able to load block, import sector = 0x%x, fat position = 0x%x"), FL,
                                           import_sector, fat_position);
                                if (fat_block)
                                {
                                    FREE(fat_block);
                                }
                                return getblock_result;
                            }

                            fat_position += ole->header.sector_size;
                            DOLE LOGGER_log("%s:%d:OLE_load_FAT:DEBUG: FAT position = 0x%x (start = 0x%x, end = 0x%x)", FL, fat_position, fat_block,
                                            ole->FAT_limit);

                            
                            if (fat_position > ole->FAT_limit)
                            {
                                DOLE LOGGER_log(_("%s:%d:OLE_load_FAT:ERROR: FAT memory boundary limit exceeded %p >= %p"), FL, fat_position,
                                                ole->FAT_limit);
                                if (fat_block)
                                {
                                    FREE(fat_block);
                                }
                                return OLEER_MEMORY_OVERFLOW;
                            }
                            tick++;
                            DIF += LEN_ULONG;
                        }
                        else
                        {
                            LOGGER_log(_("%s:%d:OLE_load_FAT:ERROR: FAT memory boundary limit exceeded %p >= %p"), FL, fat_position, ole->FAT_limit);
                            if (fat_block)
                            {
                                FREE(fat_block);
                            }
                            return OLEER_MEMORY_OVERFLOW;
                        }
                    }
                    else
                    {
                        VOLE LOGGER_log(_("%s:%d:OLE_load_FAT:ERROR: sector request was negative (%d)"), FL, import_sector);
                    }

                    DOLE LOGGER_log("%s:%d:OLE_load_FAT:DEBUG: DIF = 0x%x", FL, DIF);
                }
                while ((import_sector >= 0) && (DIF < fat_block_end));

                
                
                
                
                
                
                if (i < ole->header.dif_sector_count - 1)
                {
                    current_sector = get_4byte_value(fat_block_end);
                    DOLE LOGGER_log("%s:%d:OLE_load_FAT:DEBUG: Next DIF/XBAT index sector located at 0x%x", FL, current_sector);

                    if ((int)current_sector < 0)
                    {
                        break;
                    }
                }
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nbElements; i++)
            {
                doublecomplex dComplexValue = stringToComplex(pSTRs[i], decimal, bConvertByNAN, ierr);
                if (*ierr != STRINGTOCOMPLEX_NO_ERROR)
                {
                    freeCsvComplexArray(pCsvComplexArray);
                    return NULL;
                }
                else
                {
                    pCsvComplexArray->realPart[i] = dComplexValue.r;
                    pCsvComplexArray->imagPart[i] = dComplexValue.i;
                }
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < NB_FORMAT_SUPPORTED; i++)
        {
            char *cleanedFormat = getCleanedFormat(format);
            if (cleanedFormat)
            {
                newFormat = strdup("%s");
                FREE(cleanedFormat);
                cleanedFormat = NULL;
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < NB_FORMAT_SUPPORTED; i++)
            {
                char *token = strstr(percent, supportedFormat[i]);
                if (token)
                {
                    size_t nbcharacters = strlen(percent) - strlen(token);
                    cleanedFormat = strdup(percent);
                    cleanedFormat[nbcharacters] = 0;
                    if ( ((nbcharacters - 1 > 0) && (isdigit(cleanedFormat[nbcharacters - 1])) ||
                            (cleanedFormat[nbcharacters - 1]) == '.') ||
                            (cleanedFormat[nbcharacters - 1]) == '%')
                    {
                        strcat(cleanedFormat, supportedFormat[i]);
                        return cleanedFormat;
                    }
                    else
                    {
                        FREE(cleanedFormat);
                        cleanedFormat = NULL;
                    }
                }
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = C1 - 1 ; j < C2 ; j++)
                {
                    for(i = R1 - 1 ; i < R2 ; i++ )
                    {
                        newStrArray[k] = strdup(pStrsValues[i + nbRows * j]);
                        k++;
                    }
                }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = C1 - 1 ; j < C2 ; j++)
                {
                    for(i = R1 - 1 ; i < R2 ; i++)
                    {
                        newComplexArray->realPart[k] = pComplex->realPart[i + (nbRows * j)];
                        if (pComplex->isComplex)
                        {
                            newComplexArray->imagPart[k] = pComplex->imagPart[i + (nbRows * j)];
                        }
                        k++;
                    }
                }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nbHeadersLines; i++)
        {
            if (isIsoLatin)
            {
                char *converted = utftolatin((char*)headersLines[i]);
                if (converted)
                {
                    fprintf(fd, DEFAULT_CSV_WRITE_STRING_FORMAT, converted);
                    FREE(converted);
                }
                else
                {
                    fprintf(fd, DEFAULT_CSV_WRITE_STRING_FORMAT, headersLines[i]);
                }
            }
            else
            {
                fprintf(fd, DEFAULT_CSV_WRITE_STRING_FORMAT, headersLines[i]);
            }
            fprintf(fd, "%s", getCsvDefaultEOL());
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < m; i++)
    {
        for(j = 0; j < n; j++)
        {
            if (ISNAN(pdValues[i + m * j]))
            {
                fprintf(fd, DEFAULT_CSV_WRITE_STRING_FORMAT, NanString);
            }
            else if (finite(pdValues[i + m * j]))
            {
                char buffer[65535];
                char *result = NULL;
                sprintf(buffer, precisionFormat, pdValues[i + m * j]);
                result = csv_strsubst(buffer, getCsvDefaultDecimal(), decimal);
                if (result)
                {
                    fprintf(fd, DEFAULT_CSV_WRITE_STRING_FORMAT, result);
                    FREE(result);
                    result = NULL;
                }
                else
                {
                    fprintf(fd, DEFAULT_CSV_WRITE_DOUBLE_FORMAT, pdValues[i + m * j]);
                }
            }
            else
            {
                if ( signbit(pdValues[i + m * j]) )
                {
                    fprintf(fd, DEFAULT_CSV_WRITE_STRING_FORMAT, NegInfString);
                }
                else
                {
                    fprintf(fd, DEFAULT_CSV_WRITE_STRING_FORMAT, InfString);
                }
            }
            if (j + 1 < n)
            {
                fprintf(fd, "%s", separator);
            }
        }
        fprintf(fd, "%s", getCsvDefaultEOL());
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nbHeadersLines; i++)
        {
            if (isIsoLatin)
            {
                const char *converted = utftolatin((char*)headersLines[i]);
                if (converted)
                {
                    fprintf(fd, DEFAULT_CSV_WRITE_STRING_FORMAT, converted);
                    FREE((char*)converted);
                    converted = NULL;
                }
                else
                {
                    fprintf(fd, DEFAULT_CSV_WRITE_STRING_FORMAT, headersLines[i]);
                }
            }
            else
            {
                fprintf(fd, DEFAULT_CSV_WRITE_STRING_FORMAT, headersLines[i]);
            }
            fprintf(fd, "%s", getCsvDefaultEOL());
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < m; i++)
    {
        for(j = 0; j < n; j++)
        {
            char StringValue[65535];

            double realValue = pdValuesReal[i + m * j];
            double imagValue = pdValuesImag[i + m * j];
            int hasReal = 0;

            if (ISNAN(realValue))
            {
                strcpy(StringValue, NanString);
                hasReal = 1;
            }
            else if (finite(realValue))
            {
                if ((realValue != 0) || (finite(imagValue) && (imagValue == 0)))
                {
                    char buffer[65535];
                    char *result = NULL;

                    sprintf(buffer, precisionFormat, pdValuesReal[i + m * j]);
                    result = csv_strsubst(buffer, getCsvDefaultDecimal(), decimal);
                    if (result)
                    {
                        strcpy(StringValue, result);
                        FREE(result);
                    }
                    else
                    {
                        sprintf(StringValue, DEFAULT_CSV_WRITE_DOUBLE_FORMAT, pdValuesReal[i + m * j]);
                    }
                    hasReal = 1;
                }
            }
            else
            {
                if (signbit(realValue))
                {
                    strcpy(StringValue, NegInfString);
                }
                else
                {
                    strcpy(StringValue, InfString);
                }
                hasReal = 1;
            }

            if (ISNAN(imagValue))
            {
                if (hasReal)
                {
                    strcat(StringValue, PlusStr);
                    strcat(StringValue, NanString);
                }
                else
                {
                    strcpy(StringValue, NanString);
                }
                strcat(StringValue, ComplexStr);
            }
            else if (finite(imagValue))
            {
                if (imagValue != 0)
                {
                    char buffer[65535];
                    char *result = NULL;

                    if (hasReal && (imagValue > 0))
                    {
                        strcat(StringValue, PlusStr);
                    }
                    else if (imagValue < 0)
                    {
                        if (hasReal)
                        {
                            strcat(StringValue, LessStr);
                        }
                        else
                        {
                            strcpy(StringValue, LessStr);
                        }
                    }

                    sprintf(buffer, precisionFormat, fabs(imagValue));
                    result = csv_strsubst(buffer, getCsvDefaultDecimal(), decimal);
                    if (result)
                    {
                        if ((hasReal) || (imagValue < 0))
                        {
                            strcat(StringValue, result);
                        }
                        else
                        {
                            strcpy(StringValue, result);
                        }
                        FREE(result);
                    }
                    else
                    {
                        sprintf(StringValue, DEFAULT_CSV_WRITE_DOUBLE_FORMAT, imagValue);
                    }
                    strcat(StringValue, ComplexStr);
                }
            }
            else
            {
                if (hasReal && (signbit(imagValue) == 0))
                {
                    strcat(StringValue, PlusStr);
                }
                else if (signbit(realValue) > 0)
                {
                    if (hasReal)
                    {
                        strcat(StringValue, LessStr);
                    }
                    else
                    {
                        strcpy(StringValue, LessStr);
                    }
                }
                strcat(StringValue, InfString);
                strcat(StringValue, ComplexStr);
            }
            fprintf(fd, DEFAULT_CSV_WRITE_STRING_FORMAT, StringValue);
            if (j + 1 < n)
            {
                fprintf(fd, "%s", separator);
            }
        }
        fprintf(fd, "%s", getCsvDefaultEOL());
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nbHeadersLines; i++)
        {
            if (isIsoLatin)
            {
                const char *converted = utftolatin((char*)headersLines[i]);
                if (converted)
                {
                    fprintf(fd, DEFAULT_CSV_WRITE_STRING_FORMAT, converted);
                    FREE((char*)converted);
                    converted = NULL;
                }
                else
                {
                    fprintf(fd, DEFAULT_CSV_WRITE_STRING_FORMAT, headersLines[i]);
                }
            }
            else
            {
                fprintf(fd, DEFAULT_CSV_WRITE_STRING_FORMAT, headersLines[i]);
            }
            fprintf(fd, "%s", getCsvDefaultEOL());
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0 ; i < m ; i++ )
    {
        for( j = 0 ; j < n ; j++)
        {
            if (decimal == NULL)
            {
                if (isIsoLatin)
                {
                    const char *converted = utftolatin((char*)pStrValues[i + m * j]);
                    if (converted)
                    {
                        fprintf(fd, DEFAULT_CSV_WRITE_STRING_FORMAT, converted);
                        FREE((char*)converted);
                        converted = NULL;
                    }
                    else
                    {
                        fprintf(fd, DEFAULT_CSV_WRITE_STRING_FORMAT, pStrValues[i + m * j]);
                    }
                }
                else
                {
                    fprintf(fd, DEFAULT_CSV_WRITE_STRING_FORMAT, pStrValues[i + m * j]);
                }
            }
            else
            {
                char *result = NULL;
                result = csv_strsubst((char*)(pStrValues[i + m * j]), getCsvDefaultDecimal(), decimal);
                if (result)
                {
                    if (isIsoLatin)
                    {
                        char *converted = utftolatin(result);
                        if (converted)
                        {
                            fprintf(fd, DEFAULT_CSV_WRITE_STRING_FORMAT, converted);
                            FREE(converted);
                            converted = NULL;
                        }
                        else
                        {
                            fprintf(fd, DEFAULT_CSV_WRITE_STRING_FORMAT, result);
                        }
                    }
                    else
                    {
                        fprintf(fd, DEFAULT_CSV_WRITE_STRING_FORMAT, result);
                    }
                    FREE(result);
                    result = NULL;
                }
                else
                {
                    fprintf(fd, DEFAULT_CSV_WRITE_STRING_FORMAT, pStrValues[i + m * j]);
                }
            }
            if (j + 1 < n)
            {
                fprintf(fd, "%s", separator);
            }
        }
        fprintf(fd, "%s", getCsvDefaultEOL());
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(count = 0, p = input_string; (q = strstr(p, string_to_search)) != NULL; p = q + string_to_searchlen)
        {
            count++;
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(r = result, p = input_string; (q = strstr(p, string_to_search)) != NULL; p = q + string_to_searchlen)
        {

            ptrdiff_t l = q - p;
            memcpy(r, p, l);
            r += l;
            memcpy(r, replacement_string, replacement_stringlen);
            r += replacement_stringlen;
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nbRows * nbCols; i++)
            {
                pResults[i] = csv_isNum(pStrs[i]);
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = len - 1; i >= 0; i--)
            {
                if (filename_IN[i] == ' ')
                    filename_IN[i] = '\0';
                else
                    break;
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nsheets; i++)
            *stk(l2 + i) = Abspos[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < m_ * n_; j++)
    {
        int iVal = (int)dArray[j];
        if ((double)iVal != dArray[j])
        {
            *iErr = API_ERROR_GET_DOUBLE;
            Scierror(999, _("%s: Wrong value for input argument #%d: A matrix of double, with integer values, expected.\n"), fname, _iVar);
            return NULL;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < m_ * n_; j++)
    {
        iReturnedArray[j] = (int)dArray[j];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 0; k < m * n; k++)
            {
                if (!v[k]) 
                {
                    r[0] = FALSE;
                    break;
                }
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(l = 0; l < m; l++) 
            {
                int k = 0;
                int i = l;

                r[l] = TRUE;
                for(k = 0; k < n; k++) 
                {
                    if (!v[i]) 
                    {
                        r[l] = FALSE;
                        break;
                    }
                    i += m;
                }
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 0; k < n; k++) 
            {
                int l = 0;
                int i = k * m;
                r[k] = TRUE;
                for(l = 0; l < m; l++)
                {
                    if (!v[i++]) 
                    {
                        r[k] = FALSE;
                        break;
                    }
                }
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j <= mn1 - 1; ++j) 
			{
				e1 = *stk(l1 + j);
				if (e1 == 0.) 
				{
					*istk(il1 + 3 + j) = 1;
				}
				else
				{
					*istk(il1 + 3 + j) = 0;
				}
			}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j <= mn1 - 1; ++j) 
			{
				int j_m_i1 = (int)(j * i1);
				int j_m_i2 = (int)(j * i2);

				int e1tmp = (int)*stk(l1 + j_m_i1);
				int e2tmp = (int)*stk(l2 + j_m_i2);

				if (e1tmp || e2tmp) 
				{
					matBool[j] = TRUE;
				}
				else 
				{
					matBool[j] = FALSE;
				}
			}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j <= mn1 - 1; ++j) 
			{
				int j_m_i1 = (int)(j * i1);
				int j_m_i2 = (int)(j * i2);

				int e1tmp = (int)*stk(l1 + j_m_i1);
				int e2tmp = (int)*stk(l2 + j_m_i2);

				if (e1tmp && e2tmp) 
				{
					matBool[j] = TRUE;
				}
				else
				{
					matBool[j] = FALSE;
				}
			}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j <= mn1 - 1; ++j) 
		{
			*istk(il1 + 3 + j) = (int)matBool[j];
		}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 0; k < m * n; k++)
            {
                if (v[k]) 
                {
                    r[0] = TRUE;
                    break;
                }
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 0; k < n; k++) 
            {
                int l = 0;
                int i = k * m;
                r[k] = FALSE;
                for(l = 0; l < m; l++)
                {
                    if (v[i++]) 
                    {
                        r[k] = TRUE;
                        break;
                    }
                }
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(l = 0; l < m; l++) 
            {
                int k = 0;
                int i = l;
                r[l] = FALSE;
                for(k = 0; k < n; k++) 
                {
                    if (v[i]) 
                    {
                        r[l] = TRUE;
                        break;
                    }
                    i+=m;
                }
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < *n; ++i) yt[i] = y[i] + hh * dydx[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < *n; ++i) yt[i] = y[i] + hh * dyt[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < *n; ++i) 
    {
		yt[i] = y[i] + *h * dym[i];
		dym[i] = dyt[i] + dym[i];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < *n; ++i) yout[i] = y[i] + h6 * (dydx[i] + dyt[i] + dym[i] * 2.0);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<11;i++) itemp[i]=info[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<sz; i++)
    (*carr)[i] = (signed char)(*jarr)[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<sz; i++)
    jarr[i] = (jbyte)carr[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<sz; i++)
    arr[i] = (jbyte)result[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<sz; i++)
    (*carr)[i] = (unsigned char)(*jarr)[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<sz; i++)
    jarr[i] = (jshort)carr[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<sz; i++)
    arr[i] = (jshort)result[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<sz; i++)
    (*carr)[i] = (short)(*jarr)[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<sz; i++)
    jarr[i] = (jshort)carr[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<sz; i++)
    arr[i] = (jshort)result[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<sz; i++)
    (*carr)[i] = (unsigned short)(*jarr)[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<sz; i++)
    jarr[i] = (jint)carr[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<sz; i++)
    arr[i] = (jint)result[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<sz; i++)
    (*carr)[i] = (int)(*jarr)[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<sz; i++)
    jarr[i] = (jint)carr[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<sz; i++)
    arr[i] = (jint)result[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<sz; i++)
    (*carr)[i] = (unsigned int)(*jarr)[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<sz; i++)
    jarr[i] = (jlong)carr[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<sz; i++)
    arr[i] = (jlong)result[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<sz; i++)
    (*carr)[i] = (long)(*jarr)[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<sz; i++)
    jarr[i] = (jint)carr[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<sz; i++)
    arr[i] = (jint)result[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<sz; i++)
    (*carr)[i] = (unsigned long)(*jarr)[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<sz; i++)
    jarr[i] = (jlong)carr[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<sz; i++)
    arr[i] = (jlong)result[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<sz; i++)
    (*carr)[i] = (jlong)(*jarr)[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<sz; i++)
    jarr[i] = (jlong)carr[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<sz; i++)
    arr[i] = (jlong)result[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<sz; i++)
    (*carr)[i] = (float)(*jarr)[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<sz; i++)
    jarr[i] = (jfloat)carr[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<sz; i++)
    arr[i] = (jfloat)result[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<sz; i++)
    (*carr)[i] = (double)(*jarr)[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<sz; i++)
    jarr[i] = (jdouble)carr[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<sz; i++)
    arr[i] = (jdouble)result[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<(int)strlen(line);i++)
	{
		if (line[i]==' ') line[i]='\0';
		break;
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<(int)strlen(line);i++)
	{
		if (line[i]==' ') line[i]='\0';
		break;
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<len;i++)
	{
		if (localbuf[i] == ' ')
		{
			localbuf[i]='\0';
			break;
		}
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nbLines; i++)
        {
            iRes = appendStringToInternalLastErrorMessage(multilines[i]);
            if (iRes) break;
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nbcharacters - 1; i++) 
		{
			if (string[i] == 0) string[i] = ' ';
		}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = len; i >= 0; i--)
				{
					if (string[i] == ' ') string[i] = '\0';
					else break;
				}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < iNbLines; i++)
    {
        appendStringToInternalLastErrorMessage(strErrorMessage[i]);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k=2;k<=Rhs;k++)
	{
		if ( (VarType(k) != sci_matrix) && (VarType(k) != sci_strings) )
		{
			OverLoad(k);
			return 0;
		}
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i=0; i<(int)strlen(ptrFormat); i++)
	{
		if (ptrFormat[i]=='%')
		{
			NumberPercent++;
			if (ptrFormat[i+1]=='%')
			{
				NumberPercent--;i++;
			}
		}
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 2 ; i <= Rhs ; i++ )
		{
			int mk = 0;
			int nk = 0;
			
			GetMatrixdims(i,&mk,&nk);
			
			if( NumberRows == 0)
			{
				NumberRows  = mk;
			}
			else
			{
				NumberRows  = Min(NumberRows,mk);
			}
			NumberCols += nk;
		}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(K = 2; K <= Rhs; K++)
    {
        int iTypeK = 0;
        int *piAddressVarK = NULL;

        sciErr = getVarAddressFromPosition(pvApiCtx, K, &piAddressVarK);
        if (sciErr.iErr)
        {
            printError(&sciErr, 0);
            Scierror(999, _("%s: Can not read input argument #%d.\n"), fname, 1);
            return 0;
        }

        sciErr = getVarType(pvApiCtx, piAddressVarK, &iTypeK);
        if (sciErr.iErr)
        {
            printError(&sciErr, 0);
            Scierror(999, _("%s: Can not read input argument #%d.\n"), fname, 1);
            return 0;
        }

        if ( (iTypeK != sci_matrix) && (iTypeK != sci_strings) )
        {
            OverLoad(K);
            return 0;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < lengthFormat; i++)
    {
        if (ptrFormat[i] == PERCENT_CHAR)
        {
            NumberPercent++;
            if ( (i + 1 < lengthFormat) && (ptrFormat[i + 1] == PERCENT_CHAR))
            {
                NumberPercent--;
                i++;
            }
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 2 ; i <= Rhs ; i++ )
        {
            int iRows = 0;
            int iCols = 0;
            int *piAddressVarI = NULL;

            sciErr = getVarAddressFromPosition(pvApiCtx, i, &piAddressVarI);
            if (sciErr.iErr)
            {
                printError(&sciErr, 0);
                Scierror(999, _("%s: Can not read input argument #%d.\n"), fname, i);
                return 0;
            }

            sciErr = getVarDimension(pvApiCtx, piAddressVarI, &iRows, &iCols);
            if (sciErr.iErr)
            {
                printError(&sciErr, 0);
                Scierror(999, _("%s: Can not read input argument #%d.\n"), fname, i);
                return 0;
            }
            NumberCols += iCols;
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<(*ma)*(*na);i++) a[i] = 2*a[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<(*mb)*(*nb);i++) b[i] = 3*b[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i_row=0; i_row<m_in_var; i_row++)
    {
      for(j_col=0; j_col<n_in_var; j_col++)
        {
          *stk(l_out_var + i_row + j_col * m_out_var) = 2 * (*stk(l_in_var + i_row + j_col * m_in_var));
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < bt->size; i++)
        {
            char buffer[32];
            void * p = tr_array[i];

            bt->s_file[i] = NULL;
            bt->s_func[i] = NULL;
            bt->s_addr[i] = NULL;

            if (dladdr(p, infos))
            {
                bt->s_func[i] = infos->dli_sname ? strdup(infos->dli_sname) : strdup(" ");
                bt->s_file[i] = infos->dli_fname ? strdup(infos->dli_fname) : strdup(" ");

                // we calculate the relative address in the library
                snprintf(buffer, 32, "%p", p - infos->dli_fbase);
                bt->s_addr[i] = strdup(buffer);
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < bt->size; i++)
        {

            if (bt->s_file[i] != NULL)
            {
                free(bt->s_file[i]);
            }
            if (bt->s_func[i] != NULL)
            {
                free(bt->s_func[i]);
            }
            if (bt->s_addr[i] != NULL)
            {
                free(bt->s_addr[i]);
            }

        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < bt->size; i++)
        {

            char *s_cplus_func_p = NULL;
            char *s_cplus_func = NULL;
            size_t funcnamesize = 0;
            int status = 0;

            if (bt->s_func[i] == NULL)
            {
                continue;
            }

            s_cplus_func_p = sci_demangle(bt->s_func[i], NULL, &funcnamesize, &status);

            if (s_cplus_func_p == NULL)
            {
                continue;
            }

            if (status)
            {
                free(s_cplus_func_p);
                continue;
            }

            l = strlen(s_cplus_func_p);

            if (l == 0)
            {
                free(s_cplus_func_p);
                continue;
            }

            s_cplus_func = malloc(l + 1);

            if (s_cplus_func != NULL)
            {
                strncpy(s_cplus_func, s_cplus_func_p, l + 1);
                s_cplus_func[l] = '\0';
                free(bt->s_func[i]);
                bt->s_func[i] = s_cplus_func;
            }

            free(s_cplus_func_p);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<ScilabModules->numberofModules;i++)
        {
            if (ScilabModules->ModuleList[i])
            {
                FREE(ScilabModules->ModuleList[i]);
                ScilabModules->ModuleList[i]=NULL;
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < xpathObj->nodesetval->nodeNr; i++)
                {

                    xmlAttrPtr attrib=xpathObj->nodesetval->nodeTab[i]->properties;
                    
                    while (attrib != NULL)
                    {
                        
                        if (xmlStrEqual (attrib->name, (const xmlChar*) "name"))
                        { 
                            
                            const char *str=(const char*)attrib->children->content;
                            name = strdup(str);
                        }
                        else if (xmlStrEqual (attrib->name, (const xmlChar*) "activate"))
                        { 
                            
                            const char *str=(const char*)attrib->children->content;
                            if (stricmp(str,"yes")==0 || strcmp(str,"1")==0) {
                                activate=1;
                            }
                        }
                        attrib = attrib->next;
                    }

                    if ( (name) && (strlen(name) > 0) && (activate) )
                    {
                        if ( VerifyModule(name) )
                        {
                            if (indice==0)
                            {
                                ScilabModules->ModuleList=(char**)MALLOC(sizeof(char*)*(indice+1)); 
                            }
                            else
                            {
                                ScilabModules->ModuleList=(char**)REALLOC(ScilabModules->ModuleList,sizeof(char*)*(indice+1));
                            }

                            ScilabModules->numberofModules=indice+1;
                            
                            ScilabModules->ModuleList[indice]= strdup(name);
                            indice++;
                        }
                        else
                        {
                            sciprint(_("%s module not found.\n"),name);
                        }
                    }
                    if (name) {FREE(name);name = NULL;}
                    activate = 0;
                }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<nrow;i++)
		{
			if ( strcmp(Modules->ModuleList[i],modulename) == 0)
			{
				return TRUE;
			}
		}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(p = Pt; p >= C2F(errgst).errpt; p--)
            {
                if (Rstk[p] <= 502 && Rstk[p] >= 501)
                {
                    k = Lpt[1] - (13 + nsiz);
                    Lpt[1] = Lin[k + 1];
                    Lpt[2] = Lin[k + 2];
                    Lpt[3] = Lin[k + 3];
                    Lpt[4] = Lin[k + 4];
                    Lpt[6] = k;
                    C2F(recu).macr--;
                    if (Rstk[p - 1] == 909) Top--; 
                }
                
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(kmac = 0; kmac < C2F(dbg).nmacs; kmac++) 
        {
            
            if (C2F(eqid)(&(C2F(vstk).idstk[kfin * nsiz]), &(C2F(dbg).macnms[kmac * nsiz])))  
            {
                
                i2 = C2F(dbg).lgptrs[kmac + 1] - 1;
                for(ibpt = C2F(dbg).lgptrs[kmac]; ibpt <= i2; ++ibpt)
                {
                    if (Lct[8] == C2F(dbg).bptlg[ibpt - 1])   
                    {
                        
                        C2F(cvname)(&C2F(dbg).macnms[kmac * nsiz], tmp, &c__1, 24L);
                        sprintf(C2F(cha1).buf, "%s %5d", tmp, Lct[8]);
                        Msgs(32, 0);
                        
                        C2F(basbrk).iflag = TRUE;
                        goto L107;
                    }
                }
                break;
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ir = 1; ir <= Rhs; ++ir)
        {
            i2 = lastindpos - Rhs + ir;
            C2F(createref1)(&i2);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < NB_DEBUG_ELEMENT; i++)
    {
        debug_message msg = staticDebug[i];

        if (msg.description == NULL)    
            break;

        if (outputStaticList)
        {
            
            outputStaticList = (char **)REALLOC(outputStaticList, sizeof(char *) * (i + 1));
        }
        else
        {
            outputStaticList = (char **)MALLOC(sizeof(char *) * (i + 1));
        }

        
        outputStaticList[i] = (char *)MALLOC((strlen(msg.description) + strlen(msg.value) + 3) * sizeof(char)); 
        sprintf(outputStaticList[i], "%s: %s", msg.description, msg.value);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < ndgrec; ++i)
                    {
                        v = v * 10 + digit[i];
                    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i <= i1; ++i)
        {
            *s = *s * 10. + digit[i - 1];
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i <= i1; ++i)
        {
            *s = *s * 10. + digit[i - 1];
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i <= i1; ++i)
    {
        *(unsigned char *)&string[i - 1] = (char) (digit[i - 1] + code0);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ix = 1; ix <= ix1; ++ix)
    {
        nnchar += *nchar;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(kij = ilp + 1; kij <= ix1; ++kij)
    {
        *istk(kij) = *istk(kij - 1) + *nchar;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ix = 0; ix < mn; ++ix)
            {
                *sz += nchar[ix];
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(kij = ilp + 1; kij <= ix1; ++kij)
            {
                *istk(kij) = *istk(kij - 1) + nchar[0];
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(kij = ilp + 1; kij <= ix1; ++kij)
            {
                *istk(kij) = *istk(kij - 2 + 1) + nchar[ix];
                ++ix;
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ix = 0; ix < (*m) * (*n); ++ix)
        {
            nnchar += (int)strlen(Str[ix]);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(kij = ilp + 1; kij <= ix1; ++kij)
    {
        if (Str)
        {
            *istk(kij) = *istk(kij - 1) + (int)strlen(Str[ix]);
            ++ix;
        }
        else
        {
            *istk(kij) = *istk(kij - 1) + 0;
            ++ix;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ix = 0; ix < (*m) * (*n); ix++)
        {
            int l = (int)strlen(Str[ix]);

            C2F(cvstr) (&l, pos, Str[ix], &cx0, l);
            pos += l;
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ix = 1; ix <= ix1; ++ix)
    {
        *istk(il2p + ix) = *istk(il2p - 1 + ix) + *istk(il1j + ix) - *istk(il1j + ix - 2 + 1);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ix = 1; ix <= ix1; ++ix)
    {
        *istk(il2 + ix) = *istk(il2 - 1 + ix) + *istk(il + ix) - *istk(il - 1 + ix);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 0; k < *n + 1; ++k)
    {
        *istk(jc + k) = 0;    
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 0; k < NZMAX; ++k)
    {
        *istk(ir + k) = 0;    
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 0; k < NZMAX; ++k)
    {
        *stk(pr + k) = 0;    
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < (int)minlength; i++)
        if (Fname[i] == ' ')
        {
            Fname[i] = '\0';
            break;
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ix = 0; ix <= nn - 1; ++ix)
        {
            sciprint("%5.2f  ", stk(l + ix));
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ix = 0; ix <= nn - 1; ++ix)
        {
            sciprint("%5d  ", istk(l + ix));
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < (int)name_len; i++)
            {
                namex[i] = ' ';
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i<C; i++) for(j = 0; j < L; j++) 
			{
				buffer[ i*L+j ] = MatrixDouble[ j*C+i ];
			}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < C; i++) for(j = 0; j < L; j++) 
			{
				buffer[ i*L+j ] = MatrixInt[ j*C+i ];
			}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < C; i++) for(j = 0; j <  L; j++) 
			{
				buffer[ i*L+j ] = strdup(MatrixStr[ j*C+i ]);
			}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nsiz; i++)
    {
        id[i] = 0;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ix = 0; namex[ix] != ' ' && namex[ix] != '\0'; ix++)
    {
        ;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(iIndex = _iStart >= 0 ? _iStart : 0; iIndex < _iEnd ; iIndex++)
    {
        iVal += _piArray[iIndex];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(iIndex = 0 ; iIndex < _iRows * _iCols ; iIndex++)
    {
        *istk(iAddrPtr + iIndex) = _piPow[iIndex] + *istk(iAddrPtr - 1 + iIndex);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(iIndex = 0 ; iIndex < iArraySum(_piPow, 0, _iRows * _iCols) ; iIndex++)
    {
        int iTemp = sadr(iAddrData) + iIndex;
        *stk(iTemp) = _pdblRealData[iIndex];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(iIndex = 0 ; iIndex < iArraySum(_piPow, 0, _iRows * _iCols) ; iIndex++)
        {
            int iTemp = sadr(iAddrData) + iArraySum(_piPow, 0, _iRows * _iCols) + iIndex;
            *stk(iTemp) = _pdblImgData[iIndex];
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(iIndex = 0 ; iIndex < _iRows ; iIndex++)
    {
        *istk(iAddElemByRow + iIndex) = _piElemByRow[iIndex];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(iIndex = 0 ; iIndex < _iTotalElem ; iIndex++)
    {
        int iTemp		= 0;
        *istk(iAddrColByRow + iIndex) = _piColByRow[iIndex];
        iTemp			= sadr(iAddrRealData) + iIndex;
        *stk(iTemp)		= _pdblRealData[iIndex];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(iIndex = 0 ; iIndex < _iTotalElem ; iIndex++)
        {
            int iTemp		= 0;
            iTemp		= sadr(iAddrImgData) + iIndex;
            *stk(iTemp)	= _pdblImgData[iIndex];
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(iIndex = 0 ; iIndex < _iRows ; iIndex++)
    {
        *istk(iAddElemByRow + iIndex) = _piElemByRow[iIndex];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(iIndex = 0 ; iIndex < _iTotalElem ; iIndex++)
    {
        //		int iTemp		= 0;
        *istk(iAddrColByRow + iIndex) = _piColByRow[iIndex];
        //		iTemp			= sadr(iAddrRealData) + iIndex;
        //		*stk(iTemp)		= _piRealData[iIndex];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(iIndex = 0 ; iIndex < _iRows * _iCols ; iIndex++)
    {
        *istk(iAddrRealData + iIndex) = _piBoolData[iIndex];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(iIndex = iStart ; iIndex <= iEnd ; iIndex++)
    {
        CheckVarUsed(iIndex);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(iIndex = 0 ; iIndex < _iRows * _iCols ; iIndex++)
    {
        *istk(iAddrPtr + iIndex) = _piPow[iIndex] + *istk(iAddrPtr - 1 + iIndex);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(iIndex = 0 ; iIndex < _iRows * _iCols ; iIndex++)
    {
        *istk(iAddrPtr + iIndex) = _piLen[iIndex] + *istk(iAddrPtr - 1 + iIndex);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(iIndex = 0 ; iIndex < *_piItemNumber ; iIndex++)
    {
        _pElemType[iIndex] = piItem[(piOffset[iIndex] - 1) * 2]; //-/+ 1
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(iIndex = 0 ; iIndex < *_piRows * *_piCols; iIndex++)
    {
        _piPow[iIndex] = *istk(iAddrOffset + iIndex + 1) - *istk(iAddrOffset + iIndex );
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(iIndex = 0 ; iIndex < *_piRows ; iIndex++)
    {
        _piElemByRow[iIndex] = *istk(iAddElemByRow + iIndex);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(iIndex = 0 ; iIndex < *_piTotalElem ; iIndex++)
    {
        _piColByRow[iIndex] = *istk(iAddrColByRow + iIndex);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(iIndex = 0 ; iIndex < *_piRows ; iIndex++)
    {
        _piElemByRow[iIndex] = *istk(iAddElemByRow + iIndex);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(iIndex = 0 ; iIndex < *_piTotalElem ; iIndex++)
    {
        _piColByRow[iIndex] = *istk(iAddrColByRow + iIndex);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(iIndex = 0 ; iIndex < *_piRows * *_piCols; iIndex++)
    {
        _piLen[iIndex] = *istk(iAddrOffset + iIndex + 1) - *istk(iAddrOffset + iIndex );
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(iIndex = 0 ; iIndex < *_piRows * *_piCols; iIndex++)
    {
        _piLen[iIndex] = piOffset[iIndex + 1] - piOffset[iIndex];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(iIndex = 1 ; iIndex <= _iItemNumber ; iIndex++)
    {
        piItemPos[iIndex] = 0;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(iIndex = 0 ; iIndex < _iItemPos ; iIndex++)
    {
        if (piItemPos[iIndex] == 0)
        {
            return 3;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(iIndex = 0 ; iIndex < iItem ; iIndex++)
        {
            int *piChild = iGetAddressFromItemPos(_piStart, iIndex + 1);
            if (piChild == _piToFind)
            {
                *_piPos	= iIndex;
                return _piStart;
            }
            else
            {
                int *piTemp = piGetParentNode(piChild, _piToFind, _piPos);
                if (piTemp != NULL)
                {
                    return piTemp;
                }
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(iIndex = 0 ; iIndex < _iItemPos ; iIndex++)
    {
        if (piItemPos[iIndex] == 0)
        {
            return 3;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(iIndex = 0 ; iIndex < _iItemPos ; iIndex++)
    {
        if (piItemPos[iIndex] == 0)
        {
            return 3;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(x = 1; x <= *m; x++)
    {
        for(y = 1; y <= *n; y++)
        {
            if ( !C2F(cmatsptr)  (name_, m, n, &x, &y, &lp, &lengthAtiposxiposy, name_len) )
            {
                FREE(lengthMatrix);
                *m = -1;
                *n = -1;
                return NULL;
            }
            
            
            lengthMatrix[j] = lengthAtiposxiposy + 1;
            j++;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nbPredefined; i++)
            {
                char *varname = getLocalNamefromId(Lused - i - 1);
                if (varname)
                {
                    if (strcmp(variablename, varname) == 0)
                    {
                        FREE(varname);
                        varname = NULL;
                        return TRUE;
                    }
                    FREE(varname);
                    varname = NULL;
                }
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nbPredefined; i++)
            {
                variablesName[i] = getLocalNamefromId(Lused - i - 1);
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < MAX_SCILAB_DEFINED_TYPE; i++)
	{
		C2F(typnams).tp[i] = i;
		C2F(typnams).ln[i] = 0;
		C2F(typnams).ptr[i] = 0;
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k=0;k<(codelength+ilt+1);k++)
        data[k]=stkdata[k];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<data[ils];i++)
    {
        CvNameL(&data[ils+1+i*nsiz],name[0],&job1,&namelgth);
        (name[0])[namelgth]='\0';
        CreateVariableTList(name);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<data[ile];i++)
    {
        CvNameL(&data[ile+1+i*nsiz],name[0],&job1,&namelgth);
        (name[0])[namelgth]='\0';
        CreateVariableTList(name);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k=1;k<=nbstat;k++)
    {
        newinstr = 0;
        TopSave=Top;
        while(newinstr==0)
        {
            cod_sav=data[cod_ind];
            GetInstruction(data,&cod_ind,&nblines,&newinstr);

            if (cod_sav==25)
            {
                newinstr=0; 
            }
            else if (cod_sav==15)
            {
                if (beginStorage>0) 
                {
                    newinstr=0; 
                }
            }
            else if (cod_sav==31)
            {
                if (beginStorage>0) 
                {
                    newinstr=0; 
                }
            }
            else
            {
                if (newinstr==1)
                {
                    
                    beginStorage = -10;
                    last_eol_pos=-10;
                }
                else if (beginStorage <= 0 && cod_sav!=16 && cod_sav!=21 && cod_sav!=0)
                {
                    
                    beginStorage = Top - 1;
                }
            }

            
            if (Err>0 || C2F(errgst).err1>0)
            {
                
                freeArrayOfString(name,1);
                FREE(data);

                return 0;
            }

            if(cod_sav==15 && (data[cod_ind+1]==29 || (data[cod_ind+1]==2 && data[cod_ind+3+nsiz]!=0))) 
            {
                


                Top--; 
                newinstr=0; 
                deleted ++;
            }

            cod_ind++;
            if(cod_ind>codelength+ilt+1)
            {
                Scierror(999,_("%s: Out of code.\n"),"macr2tree");
            
                
                freeArrayOfString(name,1);
                FREE(data);
                return 0;
            }

        }

        
        if(TopSave!=Top-1)
        {
            Scierror(999,_("%s: Wrong %s value %d instead of %d.\n"),"macr2tree","Top",Top,TopSave+1);
          
            
            freeArrayOfString(name,1);
            FREE(data);
          
            return 0;
        }
      

        
        sz = *Lstk(Top+1) - *Lstk(Top);
      
        
        *istk(il+2+k) = *istk(il+1+k) + sz ;
      
        
        Top--;
      
        
        *Lstk(Top+1) = *Lstk(Top+2);

        
        if (deleted)
        {
            k++;

            CreateEOLList();

            sz = *Lstk(Top+1) - *Lstk(Top);
            *istk(il+2+k) = *istk(il+1+k) + sz ;
            Top--;
            *Lstk(Top+1) = *Lstk(Top+2);
         
            deleted = 0;
        }

    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k=0;k<isizt;k++)
    {
        if(strlen(name)>=strlen(varnames[k]))
        {
            maxlgth=(int)strlen(name);
        }
        else
        {
            maxlgth=(int)strlen(varnames[k]);
        }
        if(varnames[k][0]=='\0')
        {
            index2 = -1;
            break;
        }
        else if(!strncmp(name,varnames[k],maxlgth))
        {
            index2 = k;
            break;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<strlgth;i++)
        {
            *index2=*index2 + 1;
            int_str[i]=data[*index2];
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<strlgth;i++)
    {
        *index2=*index2 + 1;
        int_str[i]=data[*index2];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k=0; k<nCols*nRows; k++)
    {
        lengths[k] =  data[*index2 + 1] - data[*index2];
        if (lengths[k] > maxlength)
        {
            maxlength = lengths[k];
        }
        (*index2)++;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k=0; k< nCols*nRows; k++)
    {
        if((str[k]=(char *)CALLOC(1,sizeof(char)*(lengths[k]+1)))==NULL)
        {
            Scierror(999,_("%s: No more memory.\n"),"CreateInlineTList");
            return 0;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k=0;k<nCols*nRows;k++)
    {
        for(i=0;i<lengths[k];i++)
        {
            *index2=*index2 + 1;
            int_str[i]=data[*index2];
        }
        CvStr(&lengths[k],int_str,str[k],&job1,lengths[k]);
        (str[k])[lengths[k]]='\0';
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k=0;k<32;k++)
    {
        if(operators_num[k]==operator_num)
        {
            operator_index2=k;
            break;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k=nb_operands;k>1;k--)
        {
            orig = Top - nb_operands - 1;
            dest = Top + 1;
            VCopyObj("CreateOperationTList",&orig,&dest,20L);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k=nb_operands;k>0;k--)
        {
            orig = Top - nb_operands;
            dest = Top + 1;
            VCopyObj("CreateOperationTList",&orig,&dest,20L);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k=0;k<nblhs;k++)
        {
            (*index2)++;
            CvNameL(&data[*index2],name[0],&job1,&namelgth);
            (name[0])[namelgth] = '\0';
            *index2 = *index2 + nsiz;
            nbrhs = data[*index2];
            nb_index2es = nbrhs + nb_index2es;

            if(nbrhs==0) 
            {
                CreateVariableTList(name);
            }
            else 
            {
                
                str2sci(op_tlist,m_op_tlist,n_op_tlist);

                
                CreateVariableTList(name);

                
                for(l=0;l<nbrhs;l++)
                {
                    orig = index2es_pos - nbrhs + l + 1;
                    dest = Top + 1;
                    VCopyObj("CreateEqualTList",&orig,&dest,16L);
                }
                index2es_pos = index2es_pos - nbrhs;

                
                nbrhs = nbrhs + 1;
                C2F(mklist)(&nbrhs);

                
                str2sci(operator,one,one);

                
                C2F(mktlist)(&n_op_tlist);
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k=0;k<nblhs;k++)
        {
            orig = Top - 2 * k;
            dest = Top + 1;
            VCopyObj("CreateEqualTList",&orig,&dest,16L);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0 ; i < nbValues ; i++)
  {
    stk(outIndex)[i] = values[i] ;
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0 ; i < nbValues ; i++)
  {
    stk(outIndex)[i] = (double)values[i] ;
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0 ; i < nbValues ; i++)
  {
    istk(outIndex)[i] = values[i] ;
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0 ; i < nbValues ; i++)
  {
    hstk(outIndex)[i] = handles[i] ;
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0 ; i < nbValues ; i++)
  {
    hstk(outIndex)[i] = handles[i] ;
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nbRow * nbCol; i++)
  {
    stk(outIndex)[i] = values[i] ;
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0;i < scilab_nbargs;i++)
			{
				argv[i] = strdup(scilab_argv[i]);
			}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<nbargs;i++)
	{
		scilab_argv[i] = argv[i];
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(pindex = 0; pindex < prime_table_length; pindex++)
    {
        if (primes[pindex] > minsize)
        {
            size = primes[pindex];
            break;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < h->tablelength; i++)
        {
            while (NULL != (e = h->table[i]))
            {
                h->table[i] = e->next;
                index_ = indexFor(newsize, e->h);
                e->next = newtable[index_];
                newtable[index_] = e;
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < h->tablelength; i++)
        {
            for(pE = &(newtable[i]), e = *pE; e != NULL; e = *pE)
            {
                index_ = indexFor(newsize, e->h);
                if (index_ == i)
                {
                    pE = &(e->next);
                }
                else
                {
                    *pE = e->next;
                    e->next = newtable[index_];
                    newtable[index_] = e;
                }
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < h->tablelength; i++)
        {
            e = table[i];
            while (NULL != e)
            {
                f = e;
                e = e->next;
                freekey(f->k);
                FREE(f->v);
                FREE(f);
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < h->tablelength; i++)
        {
            e = table[i];
            while (NULL != e)
            {
                f = e;
                e = e->next;
                freekey(f->k);
                FREE(f);
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < tablelength; i++)
    {
        if (NULL != h->table[i])
        {
            itr->e = h->table[i];
            itr->index = i;
            break;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < xpathObj->nodesetval->nodeNr; i++)
			{
				xmlAttrPtr attrib = xpathObj->nodesetval->nodeTab[i]->properties;
				
				while (attrib != NULL)
				{
					
					if (xmlStrEqual (attrib->name, (const xmlChar*) "gatewayId"))
					{ 
						
						const char *str = (const char*)attrib->children->content;
						GATEWAY_ID = atoi(str);
					}
					else if (xmlStrEqual (attrib->name, (const xmlChar*)"primitiveId"))
					{ 
						
						const char *str = (const char*)attrib->children->content;
						PRIMITIVE_ID = atoi(str);
					}
					else if (xmlStrEqual (attrib->name, (const xmlChar*)"primitiveName"))
					{
						
						const char *str = (const char*)attrib->children->content;
						PRIMITIVE_NAME = strdup(str);
					}
					attrib = attrib->next;
				}

				if ( (GATEWAY_ID != 0) && (PRIMITIVE_ID != 0) && (PRIMITIVE_NAME) )
				{
					if (strlen(PRIMITIVE_NAME) > 0)
					{
						gateway->dimLists++;
						if (gateway->gatewayIdList)
						{
							gateway->gatewayIdList = (int*)REALLOC(gateway->gatewayIdList,
							                      sizeof(int*)*gateway->dimLists);
						}
						else
						{
							gateway->gatewayIdList = (int*)MALLOC(sizeof(int)*gateway->dimLists);
						}

						if (gateway->primitivesList)
						{
							gateway->primitivesList = (char **)REALLOC(gateway->primitivesList,
							                      sizeof(char**)*gateway->dimLists);
						}
						else
						{
							gateway->primitivesList = (char **)MALLOC(sizeof(char*)*gateway->dimLists);
						}

						if (gateway->primiviteIdList)
						{
							gateway->primiviteIdList = (int*)REALLOC(gateway->primiviteIdList,
							                      sizeof(int*)*gateway->dimLists);
						}
						else
						{
							gateway->primiviteIdList = (int*)MALLOC(sizeof(int)*gateway->dimLists);
						}

						if (gateway->gatewayIdList) 
							gateway->gatewayIdList[gateway->dimLists - 1] = GATEWAY_ID;

						if (gateway->primitivesList) 
							gateway->primitivesList[gateway->dimLists - 1] = strdup(PRIMITIVE_NAME);

						if (gateway->primiviteIdList)
							gateway->primiviteIdList[gateway->dimLists - 1] = PRIMITIVE_ID;
					}
				}
				if (PRIMITIVE_NAME) {FREE(PRIMITIVE_NAME); PRIMITIVE_NAME =NULL;}
				GATEWAY_ID = 0;
				PRIMITIVE_ID = 0;
			}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nbDevices; i++)
        {
            str_info = (char*)MALLOC( sizeof(char)*BUFFER_LEN );
            if (str_info)
            {
                sprintf(str_info,"Video card #%d: %s",  i, DevicesName[i]);
                outputDynamicList = appendStringDebugInfo(outputDynamicList,&nb_info,str_info);
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nsiz; i++)
	{
		if (x[i] != y[i])
		{
			return FALSE;
		}
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0;i < dim; i++)
		{
			if (pArray[i])
			{
				FREE(pArray[i]);
				pArray[i] = NULL;
			}
			else bRet = FALSE;
		}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ir = 1; ir <= i__2; ++ir)
        {
            i__3 = lastindpos - Rhs + ir;
            C2F(createref1)(&i__3);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(kmac = 0; kmac < C2F(dbg).nmacs; kmac++) 
        {
            
            if (C2F(eqid)(&(C2F(vstk).idstk[kfin * nsiz]), &(C2F(dbg).macnms[kmac * nsiz])))  
            {
                
                i__2 = Lpt[2] - 1;
                C2F(whatln)(&Lpt[1], &i__2, &Lpt[6], &nlc, &l1, &ifin);
                i__2 = C2F(dbg).lgptrs[kmac + 1] - 1;
                curline = Lct[8] - nlc - 1;
                for(ibpt = C2F(dbg).lgptrs[kmac]; ibpt <= i__2; ++ibpt)
                {
                    //sciprint("la Lct[8]-nlc =%d, bptlg=%d\n",Lct[8] - nlc,C2F(dbg).bptlg[ibpt - 1]);
                    if (curline == C2F(dbg).bptlg[ibpt - 1])   
                    {
                        
                        C2F(cvname)(&C2F(dbg).macnms[kmac * nsiz], tmp, &c__1, nlgh);
                        sprintf(C2F(cha1).buf, "%s %5d", tmp, curline);
                        Msgs(32, 0);
                        
                        C2F(basbrk).iflag = TRUE;
                        goto L79;
                    }
                }
                break;
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i <= n*m; i++){
	  n1=(int)strlen(x[i-1]);
	  *istk(il+4+i) =  *istk(il+4+i-1)+n1;
	  if (n1 > 0) 
		  C2F(cvstr)(&n1,istk(il+m*n+5 -1 + *istk(il+3+i)),x[i-1],&zero,(unsigned long) n1);
	  m1=m1+n1;
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(;;){
		tail = strchr(head, ':');
		if(!tail) break;
		*tail = '\0';
		if(strlen(head) >= sizeof(namebuf)){
			head = tail+1;
			goto nextline;
		}
		strcpy(namebuf,head);
		found = bsearch(&findme, mem_table, mem_table_count,
			sizeof(mem_table_struct), compare_mem_table_structs
			);
		head = tail+1;
		if(!found) goto nextline;
		*(found->slot) = strtoul(head,&tail,10);
nextline:
		tail = strchr(head, '\n');
		if(!tail) break;
		head = tail+1;
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<NB_DEBUG_ELEMENT; i++){
		debug_message msg=dynamicDebug[i];

		if (msg.description==NULL) 
			break;

		

		outputDynamicList[i]=(char*) MALLOC((strlen(msg.description)+strlen(msg.value)+3)*sizeof(char)); 
		sprintf(outputDynamicList[i],"%s: %s",msg.description, msg.value);
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 16; ++i, xp += 4)
		xbuf[i] = xp[0] + (xp[1] << 8) + (xp[2] << 16) + (xp[3] << 24);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(; left >= 64; p += 64, left -= 64)
	md5_process(pms, p);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 8; ++i)
	data[i] = (md5_byte_t)(pms->count[i >> 2] >> ((i & 3) << 3));



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 16; ++i)
	digest[i] = (md5_byte_t)(pms->abcd[i >> 2] >> ((i & 3) << 3));



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(di = 0; di < 16; di++)
	{
		sprintf(hex_output + di * 2, "%02x", digest[di]);
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(di = 0; di < 16; di++)
	{
		sprintf(hex_output + di * 2, "%02x", digest[di]);
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < numberOfTypes; i++)
			{
				TypeNames[i] = (char*)MALLOC(sizeof(char)*(MAX_LENGTH_NAME_DEFINED_TYPE + 1));
				if (TypeNames[i] == NULL)
				{
					freeArrayOfString(TypeNames,i);
					*sizeArray = 0;
					return TypeNames;
				}
			}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0;i < MAX_SCILAB_DEFINED_TYPE; i++)
			{
				if ( C2F(typnams).ln[i] != 0) 
				{
					int job = 1;
					int lengthTypeName = C2F(typnams).ln[i];
					C2F(cvstr)(&lengthTypeName,&C2F(typnams).namrec[C2F(typnams).ptr[i]-1],TypeNames[j],&job,lengthTypeName);
					TypeNames[j][lengthTypeName] = '\0';
					j++;
				}
			}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0;i < MAX_SCILAB_DEFINED_TYPE; i++)
			{
				if ( C2F(typnams).ln[i] != 0) 
				{
					TypeNumbers[j] = C2F(typnams).tp[i];
					j++;
				}
			}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0;i < MAX_SCILAB_DEFINED_TYPE; i++)
	{
		if ( C2F(typnams).ln[i] != 0) NumberOfTypes++;
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0;i < sizeArray; i++)
		{
			if (strcmp(name,TypeNames[i]) == 0)
			{
				freeArrayOfString(TypeNames,sizeArray);
				return TRUE;
			}
		}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i < nlgh;i++)
    {
        if (fortanbuffer[i] == '\0')
        {
            break;
        }
        else if (fortanbuffer[i] == ' ')
        {
            fortanbuffer[i] = '\0';
            break;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0; i < Lused; i++)
        {
            char *varOnStack = getLocalNamefromId(i);
            if (varOnStack)
            {
                if (strcmp(varname, varOnStack) == 0)
                {
                    FREE(varOnStack);
                    varOnStack = NULL;
                    return TRUE;
                }
                FREE(varOnStack);
                varOnStack = NULL;
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0; i < Gused; i++)
        {
            char *varOnStack = getGlobalNamefromId(i);
            if (varOnStack)
            {
                if (strcmp(varname, varOnStack) == 0)
                {
                    FREE(varOnStack);
                    varOnStack = NULL;
                    return TRUE;
                }
                FREE(varOnStack);
                varOnStack = NULL;
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < (int)sizeof(stacktrace_hostname); ++i)
    {
        if (stacktrace_hostname[i] == '.')
        {
            stacktrace_hostname[i] = '\0';
            break;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; signals[j] != -1; ++j)
    {
        if (0 != sigaction(signals[j], &act, NULL))
        {
            fprintf(stderr, "Could not set handler for signal %d\n", signals[j]);
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < start ; i++ )
            {
                whites[i] = ' ';
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0;i < nbrCommands; i++)
		{
			keywords[i] = strdup(CommandWords[i]);
		}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(fin=SizeOfStrs-1;fin>0;fin--)
	{
		int Sorted=FALSE;
		for(i=0;i<fin;i++)
		{
			if(strcmp(Strs[i],Strs[i+1])>0)
			{
				char *tmp;
				memcpy(&tmp,Strs+i,sizeof(char *));
				memcpy(Strs+i,Strs+(i+1),sizeof(char *));
				memcpy(Strs+(i+1),&tmp,sizeof(char *));
				Sorted=TRUE;
			}
		}
		if(!Sorted)break;
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < sizelocalvariables ; i++) variables[i] = localvariables[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = sizelocalvariables; i < sizelocalvariables + sizeglobalvariables; i++)
        {
            variables[i] = globalvariables[i - sizelocalvariables];
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=1;j<Lused+1;++j) variablesLocal[j-1] = getLocalNamefromId(j);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<Gused;++j) variablesGlobal[j] = getGlobalNamefromId(j);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(fin=SizeStrings-1;fin>0;fin--)
    {
        int Sorted=FALSE;
        for(i=0;i<fin;i++)
        {
            if(strcmp(Strings[i],Strings[i+1])>0)
            {
                char *StringTmp;

                StringTmp = Strings[i];

                Strings[i] = Strings[i+1];
                Strings[i+1] = StringTmp;

                Sorted=TRUE;
            }
        }
        if(!Sorted)break;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(fin=*SizeStrings-1;fin>0;fin--)
    {
        int Sorted=FALSE;
        for(i=0;i<fin;i++)
        {
            if (Strings[i])
            {
                if(strcmp(Strings[i],Strings[i+1]) == 0)
                {
                    FREE(Strings[i+1]);
                    Strings[i+1] = NULL;
                    Sorted=TRUE;
                    newsize--;
                }
            }
            else
            {
                Strings[i] = Strings[i+1];
                Strings[i+1] = NULL;
                Sorted=TRUE;
            }
        }
        if(!Sorted)break;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<Modules->numberofModules;j++)
    {
        Load_primitives_from_gateway_xml_file(Modules->ModuleList[j]);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0;i < currentGateway->dimLists; i++)
            {
                if (currentGateway->primitivesList[i])
                {
                    int GATEWAY_ID = currentGateway->gatewayIdList[i];
                    int PRIMITIVE_ID = currentGateway->primiviteIdList[i];

                    Add_a_Scilab_primitive_in_hashtable(currentGateway->primitivesList[i],
                        &GATEWAY_ID,
                        &PRIMITIVE_ID);
                }
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i1 = nlgh - 1; i1 >= 0; i1--)
    {
        if (namex[i1] != ' ')
        {
            break;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 1; k <= Rhs; ++k)
        if (*Infstk(k + Top - Rhs) == 1)
        {
            return k;
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 1; k <= Rhs; ++k)
        if (*Infstk(k + Top - Rhs) == 1)
        {
            ret++;
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = Rhs - nopt + 1; k <= Rhs; k++)
    {
        if (IsOpt(k, name) == 0)
        {
            Scierror(999, _("%s: Optional arguments name=val must be at the end.\n"), fname);
            return 0;
        }
        else
        {
            int isopt = rhs_opt_find(name, opts);

            if (isopt >= 0)
            {
                rhs_opts *ro = &opts[isopt];

                ro->position = k;
                if (ro->type[0] != '?')
                {
                    GetRhsVar(ro->position, ro->type, &ro->m, &ro->n, &ro->l);
                }
            }
            else
            {
                sciprint(_("%s: Unrecognized optional arguments %s.\n"), fname, name);
                rhs_opt_print_names(opts);
                SciError(999);
                return (0);
            }
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ix = 0; ix < (*m) * (*n); ++ix)
            {
                *cstk(*lr + ix) = ' ';
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = *pos; k < *pos + *n; k++)
    {
        C2F(convert2sci) (&k);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = *pos; k < *pos + *n; k++)
    {
        C2F(convert2sci) (&k);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = *pos; k < *pos + *n; k++)
    {
        C2F(convert2sci) (&k);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ix = 1; ix <= ix1; ++ix)
    {
        lw = Top - Rhs + *number + ix - 1;
        C2F(intersci).ntypes[lw - 1] = '$';
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ix = 0; ix < *mlhs; ++ix)
    {
        lw = Top - Rhs + *number + ix;
        C2F(intersci).ntypes[lw - 1] = '$';
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ix = 1; ix <= *mlhs; ++ix)
    {
        lw = Top - Rhs + *number + ix - 1;
        C2F(intersci).ntypes[lw - 1] = '$';
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ix = 0; ix < 23; ++ix) 
    {
        if (iwork[ix] != *istk(junk + ix))
        {
            Scierror(999, _("Invalid system.\n"));
            return FALSE;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ivar = 1; ivar <= Rhs; ++ivar)
    {
        unsigned char Type = (unsigned char)C2F(intersci).ntypes[ivar - 1];

        if (Type != '$')
        {
            int lw = ivar + Top - Rhs;
            int il = iadr(*Lstk(lw));

            if (*istk(il) < 0)
            {
                int m, n, it, size;

                
                if (*istk(il) < 0)
                {
                    il = iadr(*istk(il + 1));
                }
                m = *istk(il + 1);
                n = *istk(il + 2);
                it = *istk(il + 3);
                switch (Type)
                {
                    case 'i':
                    case 'r':
                    case 'd':
                        size = m * n * (it + 1);
                        break;
                    case 'z':
                        size = 0;
                        break;      
                    case 'c':
                        size = *istk(il + 4 + 1) - *istk(il + 4);
                        break;
                    case 'b':
                        size = m * n;
                        break;
                    default:
                        return FALSE;
                }
                ConvertData(&Type, size, C2F(intersci).lad[ivar - 1]);
                C2F(intersci).ntypes[ivar - 1] = '$';
            }
        }
        else
        {
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 1; k <= Lhs; k++)
    {
        if (LhsVar(k))
        {
            plhsk = *Lstk(LhsVar(k) + Top - Rhs);
            if (*istk(iadr(plhsk)) < 0)
            {
                if (*Lstk(Bot) > *Lstk(*istk(iadr(plhsk) + 2)))
                {
                    LhsVar(k) = *istk(iadr(plhsk) + 2);
                    
                }
            }
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 1; k <= Lhs; ++k)
    {
        nbvars1 = Max(nbvars1, LhsVar(k));
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ix = 1; ix <= Lhs; ++ix)
    {
        if (LhsVar(ix) < ibufprec)
        {
            lcres = FALSE;
            break;
        }
        else
        {
            ibufprec = LhsVar(ix);
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ivar = 1; ivar <= Lhs; ++ivar)
        {
            ix2 = Top - Rhs + nbvars1 + ivar;
            if (!C2F(mvfromto) (&ix2, &LhsVar(ivar)))
            {
                return FALSE;
            }
            LhsVar(ivar) = nbvars1 + ivar;
            


            if (nbvars1 + ivar > intersiz)
            {
                Scierror(999, _("%s: intersiz is too small.\n"), "putlhsvar");
                return FALSE;
            }
            C2F(intersci).ntypes[nbvars1 + ivar - 1] = '$';
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ivar = 1; ivar <= Lhs; ++ivar)
    {
        ix2 = Top - Rhs + ivar;
        if (!C2F(mvfromto) (&ix2, &LhsVar(ivar)))
        {
            return FALSE;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < (int)strlen(str2); i++)
    {
        str1[i] = str2[i];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = (int)strlen(str2); i < len; i++)
    {
        str1[i] = ' ';
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nlgh; i++)
        if (Fname[i] == ' ')
        {
            Fname[i] = '\0';
            break;
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < Nbvars; i++)
    {
        loc->state[i].iwhere = C2F(intersci).iwhere[i];
        loc->state[i].ntypes = C2F(intersci).ntypes[i];
        loc->state[i].lad = C2F(intersci).lad[i];
        loc->state[i].lhsvar = C2F(intersci).lhsvar[i];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < Nbvars; i++)
    {
        C2F(intersci).iwhere[i] = loc->state[i].iwhere;
        C2F(intersci).ntypes[i] = loc->state[i].ntypes;
        C2F(intersci).lad[i] = loc->state[i].lad;
        C2F(intersci).lhsvar[i] = loc->state[i].lhsvar;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < size; ++i)
    {
        ptr[2 * i] = tab[i];
        ptr[2 * i + 1] = ptr[lda + i];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < size; ++i)
    {
        tab[i] = ptr[2 * i + 1];
        ptr[i] = ptr[2 * i];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < size; ++i)
    {
        ptr77z[2 * i] = tab[i];
        ptr77z[2 * i + 1] = ptr[lda + i];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < size; ++i)
    {
        tab[i] = ptrz[2 * i + 1]; // imaginary part
        ptrsci[i] = ptrz[2 * i]; // real part
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=lb;i<la;i++) a[i]= ' ';



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(fin=SizeStruct-1;fin>0;fin--)
	 {
		 int Sorted=FALSE;
		 for(i=0;i<fin;i++)
		 {
			 if(strcmp(Vstruct[i].NameVariable,Vstruct[i+1].NameVariable)>0)
			 {
				 struct VariableStruct StructTmp;

				 StructTmp.NameVariable = Vstruct[i].NameVariable;
				 StructTmp.SizeVariable = Vstruct[i].SizeVariable;

				 Vstruct[i].NameVariable = Vstruct[i+1].NameVariable;
				 Vstruct[i].SizeVariable = Vstruct[i+1].SizeVariable;

				 Vstruct[i+1].NameVariable = StructTmp.NameVariable;
				 Vstruct[i+1].SizeVariable = StructTmp.SizeVariable;

				 Sorted=TRUE;
			 }
		 }
		 if(!Sorted)break;
	 }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=1;i<lenStructArray+1;i++)
	 {
		 sciprint("%+24s ",Vstruct[i-1].NameVariable);
		 if (i%4==0) sciprint("\n");
	 }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<lenStructArray;i++)
		 {
			 if (Vstruct[i].NameVariable) {FREE(Vstruct[i].NameVariable);Vstruct[i].NameVariable=NULL;}
			 Vstruct[i].SizeVariable=-1;
		 }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=1;j<*LlenStructArray+1;++j)
		 {
			 (*LVstruct)[j-1].NameVariable = getLocalNamefromId(j);
			 (*LVstruct)[j-1].SizeVariable = getLocalSizefromId(j-1);
		 }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j< *GlenStructArray;j++)
		 {
			 (*GVstruct)[j].NameVariable = getGlobalNamefromId(j);
			 (*GVstruct)[j].SizeVariable = getGlobalSizefromId(j);
		 }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<lenStructArray;i++)
	 {
		 Tab[i] = strdup(Vstruct[i].NameVariable);
		 Size[i]=Vstruct[i].SizeVariable;
	 }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<lenStructArray;i++)
	 {
		 if (strlen(Vstruct[i].NameVariable)>0)
		 {
			 LocalTab[i] = strdup(Vstruct[i].NameVariable);
		 }
	 }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 0; k < nbVariables; k++)
    {
        int *piAddressVar = NULL;
        SciErr sciErr = getVarAddressFromPosition(pvApiCtx, k + 1, &piAddressVar);
        if (!sciErr.iErr)
        {
            if (isScalar(pvApiCtx, piAddressVar) && isStringType(pvApiCtx, piAddressVar))
            {
                char *variablename = NULL;
                if (getAllocatedSingleString(pvApiCtx, piAddressVar, &variablename) == 0)
                {
                    VariableNameToClear[i] =  variablename;
                    i++;
                }
                else
                {
                    freeAllocatedMatrixOfString(i, 1, VariableNameToClear);
                    VariableNameToClear = NULL;
                    Scierror(999, _("%s: No more memory.\n"), fname);
                    return 0;
                }
            }
            else
            {
                freeAllocatedMatrixOfString(i, 1, VariableNameToClear);
                VariableNameToClear = NULL;

                if (isScalar(pvApiCtx, piAddressVar))
                {
                    Scierror(201, _("%s: Wrong type for input argument #%d: A single string expected.\n"), fname, k + 1);
                    return 0;
                }
                else
                {
                    Scierror(999, _("%s: Wrong size for input argument #%d: A single string expected.\n"), fname, k + 1);
                    return 0;
                }
            }
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 0; k < nbVariables; k++)
    {
        deleteNamedVariable(NULL, VariableNameToClear[k]);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<SizeLocalFunctionsTab;i++)
	{
		sciprint("%+24s ",LocalFunctionsTab[i]);
		if ((i+1)%4==0) sciprint("\n");
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i <sizecommandwords;i++)
	{
		sciprint("%+24s ",commandwords[i]);
		if ((i+1)%4==0) sciprint("\n");
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<sizecommandwords ;i++)
	{
		if (strcmp(commandwords[i],primitive)==0)
		{
			freeArrayOfString(commandwords, sizecommandwords);
			return TRUE;
		}
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<SizeTab;i++)
		{
			if ( !IsACommand(LocalFunctionsTabTmp[i]) ) MaxSizeWithoutCommands++;
		}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<SizeTab;i++)
		{
			if ( !IsACommand(LocalFunctionsTabTmp[i]) ) 
			{
				LocalFunctionsTab[j] = strdup(LocalFunctionsTabTmp[i]);
				j++;
			}
		}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < mn; i++)
				{
					FILE *fp = NULL;
					char *MD5 = NULL;
					char *real_path = NULL;

					
					real_path = expandPathVariable(Input_Matrix[i]);

					
					if (isdir(real_path))
					{
						Scierror(999,_("%s: The file %s does not exist.\n"), fname, Input_Matrix[i]);
						freeArrayOfString(Output_Matrix, i);
						freeArrayOfString(Input_Matrix, mn);
						FREE(real_path); real_path = NULL;
						return 0;
					}

					wcfopen(fp, real_path, "rb");

					if (real_path) {FREE(real_path); real_path = NULL;}

					if (fp)
					{
						MD5 = md5_file(fp);
						fclose(fp);
						Output_Matrix[i] = strdup(MD5);
						if (MD5) {FREE(MD5);MD5 = NULL;}
					}
					else
					{
						Scierror(999, _("%s: The file %s does not exist.\n"), fname, Input_Matrix[i]);
						freeArrayOfString(Output_Matrix,i);
						freeArrayOfString(Input_Matrix, mn);
						return 0;
					}
				}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < mn; i++)
					{
						char *MD5 = NULL;

						MD5 = md5_str(Input_Matrix[i]);
						Output_Matrix[i] = strdup(MD5);
						if (MD5) {FREE(MD5);MD5 = NULL;}

						if (Output_Matrix[i] == NULL)
						{
							freeArrayOfString(Input_Matrix, m1*n1);
							freeArrayOfString(Output_Matrix,i);
							Scierror(999,("%s: No more memory.\n"), fname);
							return 0;
						}
					}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nbElements; i++)
    {
        szLength = szLength + strlen(pStrs[i]) + strlen("\n") + 1;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nbElements; i++)
    {
        if (i == 0)
        {
            strcpy(concatenatedString, pStrs[i]);
        }
        else
        {
            strcat(concatenatedString, pStrs[i]);
        }
        if (i < nbElements - 1) strcat(concatenatedString, "\n");
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nsiz; i++) id[i] = 0;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=1;i<(int)strlen(functionname);i++)
            {
                




                if ( (functionname[i] != '_') && (functionname[i] != '?') && (functionname[i] != '!') )
                {
                    if (!isalnum(functionname[i])) return FALSE;
                }
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0;i < m1*n1;i++)
                {
                    if (strlen(Input_Strings[i]) > 0)
                    {
                        if (Input_Strings[i][strlen(Input_Strings[i]) - 1] == '\n')
                        {
                            sciprint(_("WARNING: %s"),Input_Strings[i]);
                        }
                        else
                        {
                            sciprint(_("WARNING: %s\n"),Input_Strings[i]);
                        }
                    }
                    else
                    {
                        sciprint(_("WARNING: %s\n"),"");
                    }
                }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < versionSize; i++)
							{
								versionAsDouble[i] = (double)version[i];
							}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<len; i++) {
        temp_string = (*jenv)->NewStringUTF(jenv, result[i]);
        (*jenv)->SetObjectArrayElement(jenv, jresult, i, temp_string);
        (*jenv)->DeleteLocalRef(jenv, temp_string);
        FREE(result[i]);
        result[i] = NULL;
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<len; i++) {
        temp_string = (*jenv)->NewStringUTF(jenv, result[i]);
        (*jenv)->SetObjectArrayElement(jenv, jresult, i, temp_string);
        (*jenv)->DeleteLocalRef(jenv, temp_string);
        FREE(result[i]);
        result[i] = NULL;
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<len; i++) {
        temp_string = (*jenv)->NewStringUTF(jenv, result[i]);
        (*jenv)->SetObjectArrayElement(jenv, jresult, i, temp_string);
        (*jenv)->DeleteLocalRef(jenv, temp_string);
        FREE(result[i]);
        result[i] = NULL;
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<len; i++) {
        temp_string = (*jenv)->NewStringUTF(jenv, result[i]);
        (*jenv)->SetObjectArrayElement(jenv, jresult, i, temp_string);
        (*jenv)->DeleteLocalRef(jenv, temp_string);
        FREE(result[i]);
        result[i] = NULL;
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<len; i++) {
        temp_string = (*jenv)->NewStringUTF(jenv, result[i]);
        (*jenv)->SetObjectArrayElement(jenv, jresult, i, temp_string);
        (*jenv)->DeleteLocalRef(jenv, temp_string);
        FREE(result[i]);
        result[i] = NULL;
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<len; i++) {
        temp_string = (*jenv)->NewStringUTF(jenv, result[i]);
        (*jenv)->SetObjectArrayElement(jenv, jresult, i, temp_string);
        (*jenv)->DeleteLocalRef(jenv, temp_string);
        FREE(result[i]);
        result[i] = NULL;
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<len; i++) {
        temp_string = (*jenv)->NewStringUTF(jenv, result[i]);
        (*jenv)->SetObjectArrayElement(jenv, jresult, i, temp_string);
        (*jenv)->DeleteLocalRef(jenv, temp_string);
        FREE(result[i]);
        result[i] = NULL;
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<len; i++) {
        temp_string = (*jenv)->NewStringUTF(jenv, result[i]);
        (*jenv)->SetObjectArrayElement(jenv, jresult, i, temp_string);
        (*jenv)->DeleteLocalRef(jenv, temp_string);
        FREE(result[i]);
        result[i] = NULL;
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i<size1; i++) {
      jstring j_string = (jstring)(*jenv)->GetObjectArrayElement(jenv, jarg1, i);
      const char * c_string = (*jenv)->GetStringUTFChars(jenv, j_string, 0);
      arg1[i] = MALLOC((strlen(c_string)+1)*sizeof(const char *));
      strcpy(arg1[i], c_string);
      (*jenv)->ReleaseStringUTFChars(jenv, j_string, c_string);
      (*jenv)->DeleteLocalRef(jenv, j_string);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<size1-1; i++) {
      FREE(arg1[i]);
      arg1[i] = NULL;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0; i < sizedictionaryVariables; i++)
        {
            for( j = 0; j < sizedictionaryMacros; j++)
            {
                if ( strcmp(dictionaryVariables[i], dictionaryMacros[j]) == 0 )
                {
                    nbWordsAlreadyInMacros++;
                }
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0; i < sizedictionaryVariables; i++)
                    {
                        ListWordsTmp[i] = strdup(dictionaryVariables[i]);
                    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0; i < sizedictionaryVariables; i++)
                    {
                        for( j = 0; j < sizedictionaryMacros; j++)
                        {
                            if ( strcmp(dictionaryVariables[i],dictionaryMacros[j]) == 0 )
                            {
                                FREE(ListWordsTmp[i]);
                                ListWordsTmp[i] = NULL;
                            }
                        }
                    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0; i < sizedictionaryVariables; i++)
                        {
                            if (ListWordsTmp[i])
                            {
                                ListWords[k] = strdup(ListWordsTmp[i]);
                                if (k <= sizeListWords) k++;
                            }
                        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < sizearray2; j++)
        {
            array1[pos] = array2[j];
            pos++;
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = j = 0; i < *SizeStrings - 1; i++)
        {
            if (strcmp(Strings[i], Strings[i + 1]))
                Strings[j++] = Strings[i];
            else
            {
                FREE(Strings[i]);
                Strings[i] = NULL;
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < lenstr1; i++)
		{
			if ( s1[i] != s2[i] ) return i;
		}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i < sizeDictionary - 1; i++)
		{
			int current_r = cmpPos(currentstr, dictionary[i+1]);
			if (r > current_r)
			{
				r = current_r;
				currentstr = dictionary[i+1];
			}
		}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0;i < sizearray;i++)
	{
		char *newPath = NULL;
		int newlength = (int)(strlen(dictionary[i]) + strlen(path) + 1);
		newPath = (char *)MALLOC(sizeof(char)*(newlength));
		sprintf(newPath,"%s%s",path,dictionary[i]);
		FREE(dictionary[i]);
		dictionary[i] = newPath;
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0;i < sizearray;i++)
	{
		char *pathextended = NULL;
		char fullpath[PATH_MAX * 2];

		pathextended = expandPathVariable(path);
		if (pathextended)
		{
			strcpy(fullpath, pathextended);
			strcat(fullpath, dictionary[i]);
		}
		else
		{
			strcpy(fullpath, dictionary[i]);
		}

		if ( isdir(fullpath) && (dictionary[i][strlen(dictionary[i])-1] != DIR_SEPARATOR[0]) )
		{
			char *newPath = NULL;
			int newlength = (int)(strlen(dictionary[i]) + strlen(DIR_SEPARATOR) + 1);
			newPath = (char *)MALLOC(sizeof(char)*(newlength));
			sprintf(newPath,"%s%s",dictionary[i],DIR_SEPARATOR);
			FREE(dictionary[i]);
			dictionary[i] = newPath;
		}

		if (pathextended) {FREE(pathextended); pathextended = NULL;}
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0 ; i < rc ; i++)
        {
            pstData[i] = (char*)MALLOC(sizeof(char) * (piLen[i] + 1));
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(rc = 0; fields[rc]; rc++);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(; i < rc ; i++)
        {
            if (strstr(pstData[i], pattern) != pstData[i])
            {
                FREE(pstData[i]);
                pstData[i] = NULL;
            }
            else
            {
                pstData[last] = pstData[i];
                pstData[i] = NULL;
                last++;
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < MAX_SYMBS; i++) 
    {
        int len = 0;
        char *pch = strrchr(line, symbs[i]);
        if (pch) 
        {
            len = (int) (strlen(line) - strlen(pch));
            index = Max(index, len);
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < MAX_SYMBS_F; i++) 
    {
        char *prch = strrchr(lineWithoutSpaceAtBeginning, symbs[i]);
        if (prch) 
        {
            int len = (int) (lenLine - strlen(prch));
            index = Max(index, len);
            symbol_found = 1;
            break;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < l; i++)
        {
            if (line[i] == SPACE_CHAR)
            {
                index++;
            }
            else
            {
                break;
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0;i < sizedictionary;i++)
    {
        if (dictionary[i])
        {
            if ( strnicmp(dictionary[i],somechars,strlen(somechars)) == 0)
            {
                nbElements++;
                
                
                if (results)
                   results = (char**)REALLOC(results,sizeof(char*)*(nbElements+1));
                else
                   results = (char**)MALLOC(sizeof(char*)*(nbElements+1));

                results[nbElements] = NULL; 
                results[nbElements-1] = strdup(dictionary[i]);
            }
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < xpathObj->nodesetval->nodeNr; i++)
                {

                    xmlAttrPtr attrib = xpathObj->nodesetval->nodeTab[i]->properties;
                    
                    while (attrib != NULL)
                    {
                        
                        if (xmlStrEqual (attrib->name, (const xmlChar*) "value"))
                        {
                            
                            classpath = (char*)attrib->children->content;
                        }
                        if (xmlStrEqual (attrib->name, (const xmlChar*) "load"))
                        {
                            
                            load = (char*)attrib->children->content;

                            
                            if (stricmp(load, "background") == 0)
                            {
                                eLoad = BACKGROUND;
                            }
                            else
                            {
                                if (stricmp(load, "onuse") == 0)
                                {
                                    eLoad = ONUSE;
                                }
                            }
                        }
                        else
                        {
                            eLoad = STARTUP;
                        }
                        attrib = attrib->next;
                    }

                    if ( (classpath) && (strlen(classpath) > 0) && (strncmp(classpath, "@", 1) != 0) ) 
                    {
#define KEYWORDSCILAB "$SCILAB"
                        char *sciPath = getSCIpath();
                        char *FullClasspath = NULL;

                        if (strncmp(classpath, KEYWORDSCILAB, strlen(KEYWORDSCILAB)) == 0)
                        {
                            FullClasspath = (char*)MALLOC(sizeof(char) * (strlen(sciPath) + strlen(classpath) + 1));
                            if (FullClasspath)
                            {
                                strcpy(FullClasspath, sciPath);
                                strcat(FullClasspath, &classpath[strlen(KEYWORDSCILAB)]);
                            }
                        }
                        else
                        {
                            FullClasspath = strdup(classpath);
                        }

                        if (FullClasspath)
                        {
                            if (!addToClasspath(FullClasspath, eLoad))
                            {
                                errorOnLoad = TRUE;
                            }
                            FREE(FullClasspath);
                            FullClasspath = NULL;
                        }

                        if (sciPath)
                        {
                            FREE(sciPath);
                            sciPath = NULL;
                        }
                        classpath = NULL;
                    }
                }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < xpathObj->nodesetval->nodeNr; i++)
				{
					xmlAttrPtr attrib=xpathObj->nodesetval->nodeTab[i]->properties;
					
					while (attrib != NULL)
					{
						
						if (xmlStrEqual (attrib->name, (const xmlChar*) "value"))
						{ 
							
							libraryPath = (char*)attrib->children->content;
						}
						attrib = attrib->next;
					}

					if ( (libraryPath) && (strlen(libraryPath) > 0) )
					{
						#define KEYWORDSCILAB "$SCILAB" 
						char *FullLibrarypath = NULL;
						char *sciPath = getSCIpath();
						
						if (strncmp(libraryPath,KEYWORDSCILAB, strlen(KEYWORDSCILAB))==0)
						{
							FullLibrarypath = (char*)MALLOC(sizeof(char)*(strlen(sciPath)+strlen(libraryPath)+1));
							if (FullLibrarypath)
							{
								strcpy(FullLibrarypath,sciPath);
								strcat(FullLibrarypath,&libraryPath[strlen(KEYWORDSCILAB)]);
							}
						}
						else
						{
							FullLibrarypath = strdup(libraryPath);
						}

  					    
						if (FullLibrarypath)
						{
							addToLibrarypath(FullLibrarypath);
							FREE(FullLibrarypath);
							FullLibrarypath = NULL;
						}

						if (sciPath) {FREE(sciPath);sciPath=NULL;}
						libraryPath = NULL;
					}
				}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<*sizeClasspathArray;i++)
					{
						jstring jelement;
						const char *str = NULL;
						char *string = NULL;

						jelement = (jstring)(*currentENV)->GetObjectArrayElement(currentENV, jStrings, i);
						str = (*currentENV)->GetStringUTFChars(currentENV,jelement, 0);
						if (str)
						{
							string = (char*)MALLOC(sizeof(char)*(strlen(str)+1));
							if (string)
							{
								#if _MSC_VER
								if (strlen(str) > 1) 
								{
									if (str[0] == '/') strcpy(string,&str[1]);
									else strcpy(string,str);
								}
								else 
								#endif
								{
									strcpy(string,str);
								}
							}
						}
						ClasspathArray[i] = string;
						(*currentENV)->ReleaseStringUTFChars(currentENV, jelement, str);
					}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < nOptions; j++)
        {
            if (jvm_options[j].optionString)
            {
                FREE(jvm_options[j].optionString);
                jvm_options[j].optionString = NULL;
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < vm_args.nOptions; j++)
                        {
                            fprintf(stderr, "%d: %s\n", j, vm_args.options[j]);
                        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < xpathObj->nodesetval->nodeNr; i++)
            {
                xmlAttrPtr attrib = xpathObj->nodesetval->nodeTab[i]->parent->properties;
                while (attrib != NULL)
                {
                    
                    if (xmlStrEqual (attrib->name, (const xmlChar*) "value"))
                    {
                        // @TODO Check if it has been loaded before
                        
                        
#define KEYWORDSCILAB "$SCILAB"
                        char *FullClasspath = NULL;
                        char *classpath = (char*)attrib->children->content;

                        if (strncmp(classpath, KEYWORDSCILAB, strlen(KEYWORDSCILAB)) == 0)
                        {
                            FullClasspath = (char*)MALLOC(sizeof(char) * (strlen(sciPath) + strlen(classpath) + 1));
                            if (FullClasspath)
                            {
                                strcpy(FullClasspath, sciPath);
                                strcat(FullClasspath, &classpath[strlen(KEYWORDSCILAB)]);
                            }
                        }
                        else
                        {
                            FullClasspath = strdup(classpath);
                        }
                        addToClasspath(FullClasspath, STARTUP);
                        FREE(FullClasspath);
                    }
                    attrib = attrib->next;
                }
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < xpathObj->nodesetval->nodeNr; i++)
                {

                    xmlAttrPtr attrib = xpathObj->nodesetval->nodeTab[i]->properties;
                    
                    while (attrib != NULL)
                    {
                        
                        if (xmlStrEqual (attrib->name, (const xmlChar*) "value"))
                        {
                            
                            const char *str = (const char*)attrib->children->content;
                            if (strstr(str, "-Xmx") == str && heapSize)
                            {
                                jvm_option_string = heapSize;
                                heapSizeUsed = 1;
                            }
                            else
                            {
                                jvm_option_string = strdup(str);
                            }
                        }
                        attrib = attrib->next;
                    }

                    if ( (jvm_option_string) && (strlen(jvm_option_string) > 0) )
                    {
                        char *option_string_path_separator = NULL;
                        char *option_string_sci_path = NULL;

                        option_string_path_separator = strsub(jvm_option_string, "$PATH_SEPARATOR", PATH_SEPARATOR);

                        if (jvm_option_string)
                        {
                            FREE(jvm_option_string);
                        }

                        option_string_sci_path = strsub(option_string_path_separator, "$SCILAB", SCI_PATH);
                        if (option_string_sci_path)
                        {
                            FREE(option_string_path_separator);
                        }

                        jvm_options = (JavaVMOption *)REALLOC(jvm_options, sizeof(JavaVMOption) * (indice + 1));
                        jvm_options[indice].optionString = option_string_sci_path;
                        indice++;
                    }

                }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<*sizeLibrarypathArray;i++)
					{
						jstring jelement;
						const char *str = NULL;
						char *string = NULL;

						jelement = (jstring)(*currentENV)->GetObjectArrayElement(currentENV, jStrings, i);
						str = (*currentENV)->GetStringUTFChars(currentENV,jelement, 0);
						string = (char*)MALLOC(sizeof(char)*(strlen(str)+1));
						strcpy(string,str);
						LibrarypathArray[i]=string;
						(*currentENV)->ReleaseStringUTFChars(currentENV, jelement, str);
					}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < m1 * n1; i++)
            {
                pStVarOne[i] = (char*)MALLOC(sizeof(char*) * (lenStVarOne[i] + 1));
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i<m1*n1 ;i++)
            {
                if (!addToClasspath(pStVarOne[i],STARTUP))
                {
                    Scierror(999,_("%s: Could not add URL to system classloader : %s.\n"),fname,pStVarOne[i]);
                    freeArrayOfString(pStVarOne, m1 * n1);
                    return 0;
                }
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i<m1*n1 ;i++)
			{
				bOK=addToLibrarypath(libraryPaths[i]);
				if (!bOK)
				{
					Scierror(999,_("%s: Could not add path to java.library.path: %s.\n"),fname, libraryPaths[i]);
					freeArrayOfString(libraryPaths,m1*n1);
					return 0;
				}
			}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(; i < NumberOfCharsets; i++)
                        {
                            newlang = (char*)MALLOC(strlen(lang) + strlen(CHARSETS[i]) + 1 + 1);
                            sprintf(newlang, "%s.%s", lang, CHARSETS[i]);
                            ret = setlocale(LC_CTYPE, newlang);
                            if (ret == NULL)
                            {
                                FREE(newlang);
                                newlang = NULL;
                            }
                            else
                            {
                                break;
                            }
                        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < NumberLanguages; i++)
    {
        if (LANGUAGE_COUNTRY_TAB[i].code == code)
        {
            return LANGUAGE_COUNTRY_TAB[i].alphacode;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < NumberLanguages; i++)
    {
        if (strcmp(lang, LANGUAGE_COUNTRY_TAB[i].alphacode) == 0)
        {
            return TRUE;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < NumberLanguages; i++)
    {
        if (strcmp(lang, LANGUAGE_COUNTRY_TAB[i].alphacode) == 0)
        {
            return LANGUAGE_COUNTRY_TAB[i].code;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < NumberLanguagesAlias; i++)
    {
        if (strcmp(LANGUAGE_LOCALE_ALIAS[i].alphacode, lang) == 0)
        {
            return LANGUAGE_LOCALE_ALIAS[i].alias;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < NumberLanguagesAlias; i++)
    {
        if (strcmp(LANGUAGE_LOCALE_ALIAS[i].alias, langAlias) == 0)
        {
            return LANGUAGE_LOCALE_ALIAS[i].alphacode;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < tableIN->tablelength; i++)
			{
				e = table[i];
				while (NULL != e)
				{ 
					struct key_string *Key=NULL;
					Key=e->k;
					return_entries[j]=(char *)MALLOC(sizeof(char)*(strlen(Key->Key_String)+1));
					if (return_entries[j]) strcpy(return_entries[j],Key->Key_String);
					e = e->next;
					j++;
				}
			}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < tableIN->tablelength; i++)
			{
				e = table[i];
				while (NULL != e)
				{ 
					struct value_string *Key=NULL;
					Key=e->v;
					return_entries[j]=(char *)MALLOC(sizeof(char)*(strlen(Key->Value_String)+1));
					if (return_entries[j]) strcpy(return_entries[j],Key->Value_String);
					e = e->next;
					j++;
				}
			}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < tableIN->tablelength; i++)
			{
				e = table[i];
				while (NULL != e)
				{ 
					struct value_string *Key=NULL;
					Key=e->v;
					return_entries[j]=(char *)MALLOC(sizeof(char)*(strlen(Key->Path_String)+1));
					if (return_entries[j]) strcpy(return_entries[j],Key->Path_String);
					e = e->next;
					j++;
				}
			}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < m * n; i++)
        {
            if (strcmp(StringsToTranslate[i], "") == 0)
            {
                TranslatedStrings[i] = strdup("");
            }
            else
            {
                TranslatedStrings[i] = convertString_gettext(StringsToTranslate[i]);
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < m * n; i++)
            {
                if (strcmp(stringsToTranslate[i], "") == 0)
                {
                    TranslatedStrings[i] = strdup("");
                }
                else
                {
                    TranslatedStrings[i] = convertString_dgettext(domain, stringsToTranslate[i]);
                }
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<NumberLanguages;i++)
	{
		char *alphacode=NULL;
		char *language=NULL;

		alphacode=(char*)MALLOC((strlen(LANGUAGE_COUNTRY_TAB[i].alphacode)+1)*sizeof(char));
		strcpy(alphacode,LANGUAGE_COUNTRY_TAB[i].alphacode);

		language=(char*)MALLOC((strlen(LANGUAGE_COUNTRY_TAB[i].languagedescription)+1)*sizeof(char));
		strcpy(language,LANGUAGE_COUNTRY_TAB[i].languagedescription);

		Output[i]=alphacode;
		Output[NumberLanguages+i]=language;

	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<NumberLanguages;i++)
		{
			FREE(Output[i]);
			Output[i]=NULL;
			FREE(Output[NumberLanguages+i]);
			Output[NumberLanguages+i]=NULL;
		}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i <= nblk; ++i)
    {
        if (funtyp[i] < 10000)
        {
            funtyp[i] %= 1000;
        }
        else
        {
            funtyp[i] = funtyp[i] % 1000 + 10000;
        }
        ni = inpptr[i + 1] - inpptr[i];
        no = outptr[i + 1] - outptr[i];
        if (funtyp[i] == 1)
        {
            if (ni + no > 11)
            {
                
                C2F(msgs)(&c__90, &c__0);
                C2F(curblk).kfun = i;
                *ierr = i + 1005;
                return 0;
            }
        }
        else if (funtyp[i] == 2 || funtyp[i] == 3)
        {
            
            if (ni + no > SZ_SIZE)
            {
                C2F(msgs)(&c__90, &c__0);
                C2F(curblk).kfun = i;
                *ierr = i + 1005;
                return 0;
            }
        }
        mxtb = 0;
        if (funtyp[i] == 0)
        {
            if (ni > 1)
            {
                for(j = 1; j <= ni; ++j)
                {
                    k = inplnk[inpptr[i] - 1 + j];
                    mxtb = mxtb + (outtbsz[k - 1] * outtbsz[(k - 1) + nlnk]);
                }
            }
            if (no > 1)
            {
                for(j = 1; j <= no; ++j)
                {
                    k = outlnk[outptr[i] - 1 + j];
                    mxtb = mxtb + (outtbsz[k - 1] * outtbsz[(k - 1) + nlnk]);
                }
            }
            if (mxtb > TB_SIZE)
            {
                C2F(msgs)(&c__91, &c__0);
                C2F(curblk).kfun = i;
                *ierr = i + 1005;
                return 0;
            }
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nx; i++) 
    {
        xprop[i] = 1;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(kf = 0; kf < nblk; ++kf)   
    {
        C2F(curblk).kfun = kf + 1;
        i = funptr[kf];
        Blocks[kf].type = funtyp[kf + 1];
        if (i < 0)
        {
            switch (funtyp[kf + 1])
            {
                case 0:
                    Blocks[kf].funpt = F2C(sciblk);
                    break;
                case 1:
                    sciprint(_("type 1 function not allowed for scilab blocks\n"));
                    *ierr = 1000 + kf + 1;
                    FREE_blocks();
                    return 0;
                case 2:
                    sciprint(_("type 2 function not allowed for scilab blocks\n"));
                    *ierr = 1000 + kf + 1;
                    FREE_blocks();
                    return 0;
                case 3:
                    Blocks[kf].funpt = sciblk2;
                    Blocks[kf].type = 2;
                    break;
                case 5:
                    Blocks[kf].funpt = sciblk4;
                    Blocks[kf].type = 4;
                    break;
                case 99: 
                    Blocks[kf].funpt = sciblk4;
                    
                    debug_block = kf;
                    break;

                case 10005:
                    Blocks[kf].funpt = sciblk4;
                    Blocks[kf].type = 10004;
                    break;
                default :
                    sciprint(_("Undefined Function type\n"));
                    *ierr = 1000 + kf + 1;
                    FREE_blocks();
                    return 0;
            }
            Blocks[kf].scsptr = -i; 
        }
        else if (i <= ntabsim)
        {
            Blocks[kf].funpt = *(tabsim[i - 1].fonc);
            Blocks[kf].scsptr = 0;     


        }
        else
        {
            i -= (ntabsim + 1);
            GetDynFunc(i, &Blocks[kf].funpt);
            if ( Blocks[kf].funpt == (voidf) 0)
            {
                sciprint(_("Function not found\n"));
                *ierr = 1000 + kf + 1;
                FREE_blocks();
                return 0;
            }
            Blocks[kf].scsptr = 0;   


        }

        
        Blocks[kf].ztyp = ztyp[kf + 1];
        Blocks[kf].nx = xptr[kf + 2] - xptr[kf + 1]; 
        Blocks[kf].ng = zcptr[kf + 2] - zcptr[kf + 1]; 
        Blocks[kf].nz = zptr[kf + 2] - zptr[kf + 1]; 
        Blocks[kf].noz = ozptr[kf + 2] - ozptr[kf + 1]; 
        Blocks[kf].nrpar = rpptr[kf + 2] - rpptr[kf + 1]; 
        Blocks[kf].nipar = ipptr[kf + 2] - ipptr[kf + 1]; 
        Blocks[kf].nopar = opptr[kf + 2] - opptr[kf + 1]; 
        Blocks[kf].nin = inpptr[kf + 2] - inpptr[kf + 1]; 
        Blocks[kf].nout = outptr[kf + 2] - outptr[kf + 1]; 

        
        




        
        Blocks[kf].insz = NULL;
        Blocks[kf].inptr = NULL;
        if (Blocks[kf].nin != 0)
        {
            if ((Blocks[kf].insz = MALLOC(Blocks[kf].nin * 3 * sizeof(int))) == NULL )
            {
                FREE_blocks();
                *ierr = 5;
                return 0;
            }
            if ((Blocks[kf].inptr = MALLOC(Blocks[kf].nin * sizeof(double*))) == NULL )
            {
                FREE_blocks();
                *ierr = 5;
                return 0;
            }
        }
        for(in = 0; in < Blocks[kf].nin; in++)
        {
            lprt = inplnk[inpptr[kf + 1] + in];
            Blocks[kf].inptr[in] = outtbptr[lprt - 1]; 
            Blocks[kf].insz[in] = outtbsz[lprt - 1]; 
            Blocks[kf].insz[Blocks[kf].nin + in] = outtbsz[(lprt - 1) + nlnk]; 
            Blocks[kf].insz[2 * Blocks[kf].nin + in] = outtbtyp[lprt - 1]; 
        }
        
        




        
        Blocks[kf].outsz = NULL;
        Blocks[kf].outptr = NULL;
        if (Blocks[kf].nout != 0)
        {
            if ((Blocks[kf].outsz = MALLOC(Blocks[kf].nout * 3 * sizeof(int))) == NULL )
            {
                FREE_blocks();
                *ierr = 5;
                return 0;
            }
            if ((Blocks[kf].outptr = MALLOC(Blocks[kf].nout * sizeof(double*))) == NULL )
            {
                FREE_blocks();
                *ierr = 5;
                return 0;
            }
        }
        
        for(out = 0; out < Blocks[kf].nout; out++) 
        {
            lprt = outlnk[outptr[kf + 1] + out];
            Blocks[kf].outptr[out] = outtbptr[lprt - 1]; 
            Blocks[kf].outsz[out] = outtbsz[lprt - 1]; 
            Blocks[kf].outsz[Blocks[kf].nout + out] = outtbsz[(lprt - 1) + nlnk]; 
            Blocks[kf].outsz[2 * Blocks[kf].nout + out] = outtbtyp[lprt - 1]; 
        }

        
        Blocks[kf].evout = NULL;
        Blocks[kf].nevout = clkptr[kf + 2] - clkptr[kf + 1];
        if (Blocks[kf].nevout != 0)
        {
            if ((Blocks[kf].evout = CALLOC(Blocks[kf].nevout, sizeof(double))) == NULL )
            {
                FREE_blocks();
                *ierr = 5;
                return 0;
            }
        }

        
        Blocks[kf].z = &(z__[zptr[kf + 1] - 1]);

        
        Blocks[kf].ozsz = NULL;
        if (Blocks[kf].noz == 0)
        {
            Blocks[kf].ozptr = NULL;
            Blocks[kf].oztyp = NULL;
        }
        else
        {
            Blocks[kf].ozptr = &(oz[ozptr[kf + 1] - 1]);
            if ((Blocks[kf].ozsz = MALLOC(Blocks[kf].noz * 2 * sizeof(int))) == NULL )
            {
                FREE_blocks();
                *ierr = 5;
                return 0;
            }
            for(i = 0; i < Blocks[kf].noz; i++)
            {
                Blocks[kf].ozsz[i] = ozsz[(ozptr[kf + 1] - 1) + i];
                Blocks[kf].ozsz[i + Blocks[kf].noz] = ozsz[(ozptr[kf + 1] - 1 + noz) + i];
            }
            Blocks[kf].oztyp = &(oztyp[ozptr[kf + 1] - 1]);
        }

        
        Blocks[kf].rpar = &(rpar[rpptr[kf + 1] - 1]);

        
        Blocks[kf].ipar = &(ipar[ipptr[kf + 1] - 1]);

        
        Blocks[kf].oparsz = NULL;
        if (Blocks[kf].nopar == 0)
        {
            Blocks[kf].oparptr = NULL;
            Blocks[kf].opartyp = NULL;
        }
        else
        {
            Blocks[kf].oparptr = &(opar[opptr[kf + 1] - 1]);
            if ((Blocks[kf].oparsz = MALLOC(Blocks[kf].nopar * 2 * sizeof(int))) == NULL)
            {
                FREE_blocks();
                *ierr = 5;
                return 0;
            }
            for(i = 0; i < Blocks[kf].nopar; i++)
            {
                Blocks[kf].oparsz[i] = oparsz[(opptr[kf + 1] - 1) + i];
                Blocks[kf].oparsz[i + Blocks[kf].nopar] = oparsz[(opptr[kf + 1] - 1 + nopar) + i];
            }
            Blocks[kf].opartyp = &(opartyp[opptr[kf + 1] - 1]);
        }

        
        Blocks[kf].res = NULL;
        if (Blocks[kf].nx != 0)
        {
            if ((Blocks[kf].res = MALLOC(Blocks[kf].nx * sizeof(double))) == NULL)
            {
                FREE_blocks();
                *ierr = 5;
                return 0;
            }
        }

        
        i1 = izptr[kf + 2] - izptr[kf + 1];
        if ((Blocks[kf].label = MALLOC(sizeof(char) * (i1 + 1))) == NULL)
        {
            FREE_blocks();
            *ierr = 5;
            return 0;
        }
        Blocks[kf].label[i1] = '\0';
        C2F(cvstr)(&i1, &(iz[izptr[kf + 1] - 1]), Blocks[kf].label, &job, i1);

        
        Blocks[kf].jroot = NULL;
        if (Blocks[kf].ng != 0)
        {
            if ((Blocks[kf].jroot = CALLOC(Blocks[kf].ng, sizeof(int))) == NULL)
            {
                FREE_blocks();
                *ierr = 5;
                return 0;
            }
        }

        
        Blocks[kf].work = (void **)(((double *)work) + kf);

        
        Blocks[kf].nmode = modptr[kf + 2] - modptr[kf + 1];
        if (Blocks[kf].nmode != 0)
        {
            Blocks[kf].mode = &(mod[modptr[kf + 1] - 1]);
        }

        
        Blocks[kf].xprop = NULL;
        if (Blocks[kf].nx != 0)
        {
            Blocks[kf].xprop = &(xprop[xptr[kf + 1] - 1]);
        }

        
        Blocks[kf].g = NULL;
        if (Blocks[kf].ng != 0)
        {
            Blocks[kf].g = &(g[zcptr[kf + 1] - 1]);
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(kf = 0; kf < nblk; ++kf)
        {
            *(Blocks[kf].work) = NULL;
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(jj = 0; jj < nx; jj++) W[jj] = 0.0;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nx; ++i)
            {
                x[i] = W[i];
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ii = 0; ii < nlnk; ii++)
    {
        switch (outtbtyp[ii])
        {
            case SCSREAL_N    :
                szouttbd += outtbsz[ii] * outtbsz[ii + nlnk]; 
                outtbd = (SCSREAL_COP *) REALLOC (outtbd, szouttbd * sizeof(SCSREAL_COP));
                break;

            case SCSCOMPLEX_N :
                szouttbd += 2 * outtbsz[ii] * outtbsz[ii + nlnk]; 
                outtbd = (SCSCOMPLEX_COP *) REALLOC (outtbd, szouttbd * sizeof(SCSCOMPLEX_COP));
                break;

            case SCSINT8_N    :
                szouttbc += outtbsz[ii] * outtbsz[ii + nlnk]; 
                outtbc = (SCSINT8_COP *) REALLOC (outtbc, szouttbc * sizeof(SCSINT8_COP));
                break;

            case SCSINT16_N   :
                szouttbs += outtbsz[ii] * outtbsz[ii + nlnk]; 
                outtbs = (SCSINT16_COP *) REALLOC (outtbs, szouttbs * sizeof(SCSINT16_COP));
                break;

            case SCSINT32_N   :
                szouttbl += outtbsz[ii] * outtbsz[ii + nlnk]; 
                outtbl = (SCSINT32_COP *) REALLOC (outtbl, szouttbl * sizeof(SCSINT32_COP));
                break;

            case SCSUINT8_N   :
                szouttbuc += outtbsz[ii] * outtbsz[ii + nlnk]; 
                outtbuc = (SCSUINT8_COP *) REALLOC (outtbuc, szouttbuc * sizeof(SCSUINT8_COP));
                break;

            case SCSUINT16_N  :
                szouttbus += outtbsz[ii] * outtbsz[ii + nlnk]; 
                outtbus = (SCSUINT16_COP *) REALLOC (outtbus, szouttbus * sizeof(SCSUINT16_COP));
                break;

            case SCSUINT32_N  :
                szouttbul += outtbsz[ii] * outtbsz[ii + nlnk]; 
                outtbul = (SCSUINT32_COP *) REALLOC (outtbul, szouttbul * sizeof(SCSUINT32_COP));
                break;

            default  : 
                break;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(C2F(curblk).kfun = 1; C2F(curblk).kfun <= nblk; ++C2F(curblk).kfun)
    {
        flag__ = 4;
        if (Blocks[C2F(curblk).kfun - 1].nx > 0)
        {
            Blocks[C2F(curblk).kfun - 1].x  = &x[xptr[C2F(curblk).kfun] - 1];
            Blocks[C2F(curblk).kfun - 1].xd = &xd[xptr[C2F(curblk).kfun] - 1];
        }
        Blocks[C2F(curblk).kfun - 1].nevprt = 0;
        if (funtyp[C2F(curblk).kfun] >= 0)   
        {
            
            Jacobian_Flag = 0;
            callf(told, &Blocks[C2F(curblk).kfun - 1], &flag__);
            if (flag__ < 0 && *ierr == 0)
            {
                *ierr = 5 - flag__;
                kfune = C2F(curblk).kfun;
            }
            if ((Jacobian_Flag == 1) && (AJacobian_block == 0)) AJacobian_block = C2F(curblk).kfun;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(jj = 1; jj <= ncord; ++jj)
    {
        C2F(curblk).kfun = cord[jj];
        Blocks[C2F(curblk).kfun - 1].nevprt = 0;
        if (funtyp[C2F(curblk).kfun] >= 0)
        {
            
            callf(told, &Blocks[C2F(curblk).kfun - 1], &flag__);
            if (flag__ < 0)
            {
                *ierr = 5 - flag__;
                freeouttbptr;
                return;
            }
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i <= nblk + 1; ++i)   
    {
        
        for(C2F(curblk).kfun = 1; C2F(curblk).kfun <= nblk; ++C2F(curblk).kfun)
        {
            Blocks[C2F(curblk).kfun - 1].nevprt = 0;
            if (funtyp[C2F(curblk).kfun] >= 0)
            {
                
                callf(told, &Blocks[C2F(curblk).kfun - 1], &flag__);
                if (flag__ < 0)
                {
                    *ierr = 5 - flag__;
                    freeouttbptr;
                    return;
                }
            }
        }

        flag__ = 6;
        for(jj = 1; jj <= ncord; ++jj)   
        {
            C2F(curblk).kfun = cord[jj];
            if (funtyp[C2F(curblk).kfun] >= 0)
            {
                
                callf(told, &Blocks[C2F(curblk).kfun - 1], &flag__);
                if (flag__ < 0)
                {
                    *ierr = 5 - flag__;
                    freeouttbptr;
                    return;
                }
            }
        }

        
        curouttbd = 0;
        curouttbc = 0;
        curouttbs = 0;
        curouttbl = 0;
        curouttbuc = 0;
        curouttbus = 0;
        curouttbul = 0;
        for(jj = 0; jj < nlnk; jj++)
        {
            switch (outtbtyp[jj]) 
            {
                case SCSREAL_N    :
                    outtbdptr = (SCSREAL_COP *)outtbptr[jj]; 
                    sszz = outtbsz[jj] * outtbsz[jj + nlnk];
                    for(kk = 0; kk < sszz; kk++)
                    {
                        if (outtbdptr[kk] != (SCSREAL_COP)outtbd[curouttbd + kk]) goto L30;
                    }
                    curouttbd += sszz;
                    break;

                case SCSCOMPLEX_N :
                    outtbdptr = (SCSCOMPLEX_COP *)outtbptr[jj]; 
                    sszz = 2 * outtbsz[jj] * outtbsz[jj + nlnk];
                    for(kk = 0; kk < sszz; kk++)
                    {
                        if (outtbdptr[kk] != (SCSCOMPLEX_COP)outtbd[curouttbd + kk]) goto L30;
                    }
                    curouttbd += sszz;
                    break;

                case SCSINT8_N    :
                    outtbcptr = (SCSINT8_COP *)outtbptr[jj]; 
                    sszz = outtbsz[jj] * outtbsz[jj + nlnk];
                    for(kk = 0; kk < sszz; kk++)
                    {
                        if (outtbcptr[kk] != (SCSINT8_COP)outtbc[curouttbc + kk]) goto L30;
                    }
                    curouttbc += sszz;
                    break;

                case SCSINT16_N   :
                    outtbsptr = (SCSINT16_COP *)outtbptr[jj]; 
                    sszz = outtbsz[jj] * outtbsz[jj + nlnk];
                    for(kk = 0; kk < sszz; kk++)
                    {
                        if (outtbsptr[kk] != (SCSINT16_COP)outtbs[curouttbs + kk]) goto L30;
                    }
                    curouttbs += sszz;
                    break;

                case SCSINT32_N   :
                    outtblptr = (SCSINT32_COP *)outtbptr[jj]; 
                    sszz = outtbsz[jj] * outtbsz[jj + nlnk];
                    for(kk = 0; kk < sszz; kk++)
                    {
                        if (outtblptr[kk] != (SCSINT32_COP)outtbl[curouttbl + kk]) goto L30;
                    }
                    curouttbl += sszz;
                    break;

                case SCSUINT8_N   :
                    outtbucptr = (SCSUINT8_COP *)outtbptr[jj]; 
                    sszz = outtbsz[jj] * outtbsz[jj + nlnk];
                    for(kk = 0; kk < sszz; kk++)
                    {
                        if (outtbucptr[kk] != (SCSUINT8_COP)outtbuc[curouttbuc + kk]) goto L30;
                    }
                    curouttbuc += sszz;
                    break;

                case SCSUINT16_N  :
                    outtbusptr = (SCSUINT16_COP *)outtbptr[jj]; 
                    sszz = outtbsz[jj] * outtbsz[jj + nlnk];
                    for(kk = 0; kk < sszz; kk++)
                    {
                        if (outtbusptr[kk] != (SCSUINT16_COP)outtbus[curouttbus + kk]) goto L30;
                    }
                    curouttbus += sszz;
                    break;

                case SCSUINT32_N  :
                    outtbulptr = (SCSUINT32_COP *)outtbptr[jj]; 
                    sszz = outtbsz[jj] * outtbsz[jj + nlnk];
                    for(kk = 0; kk < sszz; kk++)
                    {
                        if (outtbulptr[kk] != (SCSUINT32_COP)outtbul[curouttbul + kk]) goto L30;
                    }
                    curouttbul += sszz;
                    break;

                default  : 
                    break;
            }
        }
        freeouttbptr;
        return;

L30:
        
        curouttbd = 0;
        curouttbc = 0;
        curouttbs = 0;
        curouttbl = 0;
        curouttbuc = 0;
        curouttbus = 0;
        curouttbul = 0;
        for(ii = 0; ii < nlnk; ii++) 
        {
            switch (outtbtyp[ii])  
            {
                case SCSREAL_N    :
                    outtbdptr = (SCSREAL_COP *)outtbptr[ii]; 
                    sszz = outtbsz[ii] * outtbsz[ii + nlnk];
                    C2F(dcopy)(&sszz, outtbdptr, &c__1, &outtbd[curouttbd], &c__1);
                    curouttbd += sszz;
                    break;

                case SCSCOMPLEX_N :
                    outtbdptr = (SCSCOMPLEX_COP *)outtbptr[ii]; 
                    sszz = 2 * outtbsz[ii] * outtbsz[ii + nlnk];
                    C2F(dcopy)(&sszz, outtbdptr, &c__1, &outtbd[curouttbd], &c__1);
                    curouttbd += sszz;
                    break;

                case SCSINT8_N    :
                    outtbcptr = (SCSINT8_COP *)outtbptr[ii];  
                    sszz = outtbsz[ii] * outtbsz[ii + nlnk];
                    for(kk = 0; kk < sszz; kk++) outtbc[curouttbc + kk] = (SCSINT8_COP)outtbcptr[kk];
                    curouttbc += sszz;
                    break;

                case SCSINT16_N   :
                    outtbsptr = (SCSINT16_COP *)outtbptr[ii]; 
                    sszz = outtbsz[ii] * outtbsz[ii + nlnk];
                    for(kk = 0; kk < sszz; kk++) outtbs[curouttbs + kk] = (SCSINT16_COP)outtbsptr[kk];
                    curouttbs += sszz;
                    break;

                case SCSINT32_N   :
                    outtblptr = (SCSINT32_COP *)outtbptr[ii];  
                    sszz = outtbsz[ii] * outtbsz[ii + nlnk];
                    for(kk = 0; kk < sszz; kk++) outtbl[curouttbl + kk] = (SCSINT32_COP)outtblptr[kk];
                    curouttbl += sszz;
                    break;

                case SCSUINT8_N   :
                    outtbucptr = (SCSUINT8_COP *)outtbptr[ii]; 
                    sszz = outtbsz[ii] * outtbsz[ii + nlnk];
                    for(kk = 0; kk < sszz; kk++) outtbuc[curouttbuc + kk] = (SCSUINT8_COP)outtbucptr[kk];
                    curouttbuc += sszz;
                    break;

                case SCSUINT16_N  :
                    outtbusptr = (SCSUINT16_COP *)outtbptr[ii]; 
                    sszz = outtbsz[ii] * outtbsz[ii + nlnk];
                    for(kk = 0; kk < sszz; kk++) outtbus[curouttbus + kk] = (SCSUINT16_COP)outtbusptr[kk];
                    curouttbus += sszz;
                    break;

                case SCSUINT32_N  :
                    outtbulptr = (SCSUINT32_COP *)outtbptr[ii]; 
                    sszz = outtbsz[ii] * outtbsz[ii + nlnk];
                    for(kk = 0; kk < sszz; kk++) outtbul[curouttbul + kk] = (SCSUINT32_COP)outtbulptr[kk];
                    curouttbul += sszz;
                    break;

                default  : 
                    break;
            }
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( jj = 0 ; jj < ng ; jj++ )
        jroot[jj] = 0 ;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(C2F(curblk).kfun = 1; C2F(curblk).kfun <= nblk; ++C2F(curblk).kfun)
    {
        if (Blocks[C2F(curblk).kfun - 1].ng >= 1)
        {
            zcros[jj] = C2F(curblk).kfun;
            ++jj;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(jj = 0; jj < ng; ++jj)
            if (g[jj] >= 0) jroot[jj] = 5;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(jj = 0; jj < ng; ++jj)
                    {
                        if ((g[jj] >= 0.0) && (jroot[jj] == -5))
                        {
                            Discrete_Jump = 1;
                            jroot[jj] = 1;
                        }
                        else if ((g[jj] < 0.0) && (jroot[jj] == 5))
                        {
                            Discrete_Jump = 1;
                            jroot[jj] = -1;
                        }
                        else jroot[jj] = 0;
                    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(jj = 0; jj < ng; ++jj)
                    {
                        C2F(curblk).kfun = zcros[ jj];
                        if (C2F(curblk).kfun == -1)
                        {
                            break;
                        }
                        kev = 0;

                        for(j = zcptr[C2F(curblk).kfun] - 1 ;
                                j < zcptr[C2F(curblk).kfun + 1] - 1 ; ++j)
                        {
                            if (jroot[j] != 0)
                            {
                                kev = 1;
                                break;
                            }
                        }
                        
                        if (kev != 0)
                        {
                            Blocks[C2F(curblk).kfun - 1].jroot = &jroot[zcptr[C2F(curblk).kfun] - 1];
                            if (funtyp[C2F(curblk).kfun] > 0)
                            {

                                if (Blocks[C2F(curblk).kfun - 1].nevout > 0)
                                {
                                    flag__ = 3;
                                    if (Blocks[C2F(curblk).kfun - 1].nx > 0)
                                    {
                                        Blocks[C2F(curblk).kfun - 1].x  = &x[xptr[C2F(curblk).kfun] - 1];
                                        Blocks[C2F(curblk).kfun - 1].xd = &xd[xptr[C2F(curblk).kfun] - 1];
                                    }
                                    
                                    Blocks[C2F(curblk).kfun - 1].nevprt = -kev;
                                    
                                    callf(told, &Blocks[C2F(curblk).kfun - 1], &flag__);
                                    if (flag__ < 0)
                                    {
                                        *ierr = 5 - flag__;
                                        freeall;
                                        return;
                                    }
                                    
                                    for(k = 0; k < Blocks[C2F(curblk).kfun - 1].nevout; ++k)
                                    {
                                        if (Blocks[C2F(curblk).kfun - 1].evout[k] >= 0.)
                                        {
                                            i3 = k + clkptr[C2F(curblk).kfun] ;
                                            addevs(Blocks[C2F(curblk).kfun - 1].evout[k] + (*told), &i3, &ierr1);
                                            if (ierr1 != 0)
                                            {
                                                
                                                *ierr = 3;
                                                freeall;
                                                return;
                                            }
                                        }
                                    }
                                }
                                
                                if (Blocks[C2F(curblk).kfun - 1].nx > 0)
                                {
                                    
                                    flag__ = 2;
                                    Blocks[C2F(curblk).kfun - 1].x  = &x[xptr[C2F(curblk).kfun] - 1];
                                    Blocks[C2F(curblk).kfun - 1].xd = &xd[xptr[C2F(curblk).kfun] - 1];
                                    Blocks[C2F(curblk).kfun - 1].nevprt = -kev;
                                    
                                    callf(told, &Blocks[C2F(curblk).kfun - 1], &flag__);

                                    if (flag__ < 0)
                                    {
                                        *ierr = 5 - flag__;
                                        freeall;
                                        return;
                                    }
                                }
                            }
                        }
                    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(jj = 0; jj < ng; ++jj)
                {
                    if (g[jj] >= 0)
                    {
                        jroot[jj] = 5;
                    }
                    else
                    {
                        jroot[jj] = -5;
                    }
                }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(kev = 0; kev < nblk; kev++)
                {
                    if (Blocks[kev].nmode > 0)
                    {
                        sciprint(_("mode of block %d=%d, "), kev, Blocks[kev].mode[0]);
                    }
                }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( jj = 0 ; jj < ng ; jj++ )  jroot[jj] = 0 ;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(C2F(curblk).kfun = 1; C2F(curblk).kfun <= nblk; ++C2F(curblk).kfun)
    {
        if (Blocks[C2F(curblk).kfun - 1].ng >= 1)
        {
            zcros[jj] = C2F(curblk).kfun;
            ++jj;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(jj = 0; jj < ng; ++jj)
            if (g[jj] >= 0) jroot[jj] = 5;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(jj = 0; jj < *neq; jj++)
                    {
                        if (xprop[jj] ==  1) scicos_xproperty[jj] = ONE;
                        if (xprop[jj] == -1) scicos_xproperty[jj] = ZERO;
                    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j <= N_iters; j++)
                    {
                        


                        

                        
                        while (ismenu()) /









                            C2F(coshlt).halt = 0;
                            freeallx;
                            return;
                        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(jj = 0; jj < nmod; ++jj)
                        {
                            Mode_save[jj] = mod[jj];
                        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(jj = 0; jj < nmod; ++jj)
                        {
                            if (Mode_save[jj] != mod[jj])
                            {
                                Mode_change = 1;
                                break;
                            }
                        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(jj = 0; jj < ng; ++jj)
                    {
                        if ((g[jj] >= 0.0) && ( jroot[jj] == -5))
                        {
                            Discrete_Jump = 1;
                            jroot[jj] = 1;
                        }
                        else if ((g[jj] < 0.0) && ( jroot[jj] == 5))
                        {
                            Discrete_Jump = 1;
                            jroot[jj] = -1;
                        }
                        else jroot[jj] = 0;
                    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(jj = 0; jj < ng; ++jj)
                    {
                        C2F(curblk).kfun = zcros[jj];
                        if (C2F(curblk).kfun == -1)
                        {
                            break;
                        }
                        kev = 0;
                        for(j = zcptr[C2F(curblk).kfun] - 1 ;
                                j < zcptr[C2F(curblk).kfun + 1] - 1 ; ++j)
                        {
                            if (jroot[j] != 0)
                            {
                                kev = 1;
                                break;
                            }
                        }
                        if (kev != 0)
                        {
                            Blocks[C2F(curblk).kfun - 1].jroot = &jroot[zcptr[C2F(curblk).kfun] - 1];
                            if (funtyp[C2F(curblk).kfun] > 0)
                            {
                                if (Blocks[C2F(curblk).kfun - 1].nevout > 0)
                                {
                                    flag__ = 3;
                                    if (Blocks[C2F(curblk).kfun - 1].nx > 0)
                                    {
                                        Blocks[C2F(curblk).kfun - 1].x  = &x[xptr[C2F(curblk).kfun] - 1];
                                        Blocks[C2F(curblk).kfun - 1].xd = &xd[xptr[C2F(curblk).kfun] - 1];
                                    }
                                    
                                    Blocks[C2F(curblk).kfun - 1].nevprt = -kev;
                                    
                                    callf(told, &Blocks[C2F(curblk).kfun - 1], &flag__);
                                    if (flag__ < 0)
                                    {
                                        *ierr = 5 - flag__;
                                        freeallx;
                                        return;
                                    }
                                    
                                    for(k = 0; k < Blocks[C2F(curblk).kfun - 1].nevout; ++k)
                                    {
                                        if (Blocks[C2F(curblk).kfun - 1].evout[k] >= 0)
                                        {
                                            i3 = k + clkptr[C2F(curblk).kfun] ;
                                            addevs(Blocks[C2F(curblk).kfun - 1].evout[k] + (*told), &i3, &ierr1);
                                            if (ierr1 != 0)
                                            {
                                                
                                                *ierr = 3;
                                                freeallx;
                                                return;
                                            }
                                        }
                                    }
                                }
                                
                                if ((Blocks[C2F(curblk).kfun - 1].nx > 0) || (*Blocks[C2F(curblk).kfun - 1].work != NULL) )
                                {
                                    
                                    flag__ = 2;
                                    if (Blocks[C2F(curblk).kfun - 1].nx > 0)
                                    {
                                        Blocks[C2F(curblk).kfun - 1].x  = &x[xptr[C2F(curblk).kfun] - 1];
                                        Blocks[C2F(curblk).kfun - 1].xd = &xd[xptr[C2F(curblk).kfun] - 1];
                                    }
                                    Blocks[C2F(curblk).kfun - 1].nevprt = -kev;

                                    Blocks[C2F(curblk).kfun - 1].xprop = &xprop[-1 + xptr[C2F(curblk).kfun]];
                                    
                                    callf(told, &Blocks[C2F(curblk).kfun - 1], &flag__);

                                    if (flag__ < 0)
                                    {
                                        *ierr = 5 - flag__;
                                        freeallx;
                                        return;
                                    }
                                    for(j = 0; j < *neq; j++) 
                                    {
                                        if (xprop[j] ==  1) scicos_xproperty[j] = ONE;
                                        if (xprop[j] == -1) scicos_xproperty[j] = ZERO;
                                    }
                                }
                            }
                        }
                    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(jj = 0; jj < ng; ++jj)
                    {
                        if (g[jj] >= 0)
                        {
                            jroot[jj] = 5;
                        }
                        else
                        {
                            jroot[jj] = -5;
                        }
                    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(C2F(curblk).kfun = 1; C2F(curblk).kfun <= nblk; ++C2F(curblk).kfun)
    {
        flag__ = 5;
        Blocks[C2F(curblk).kfun - 1].nevprt = 0;
        if (funtyp[C2F(curblk).kfun] >= 0)
        {
            if (Blocks[C2F(curblk).kfun - 1].nx > 0)
            {
                Blocks[C2F(curblk).kfun - 1].x  = &x[xptr[C2F(curblk).kfun] - 1];
                Blocks[C2F(curblk).kfun - 1].xd = &xd[xptr[C2F(curblk).kfun] - 1];
            }
            
            callf(told, &Blocks[C2F(curblk).kfun - 1], &flag__);
            if (flag__ < 0 && *ierr == 0)
            {
                *ierr = 5 - flag__;
                kfune = C2F(curblk).kfun;
            }
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < block->ng; ++j)
                {
                    block->g[j] = (double)block->jroot[j];
                }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(in = 0; in < block->nin; in++)
                {
                    szi = block->insz[in] * block->insz[in + block->nin];
                    for(ii = 0; ii < szi; ii++)
                    {
                        intabl[ki++] = *((double *)(block->inptr[in]) + ii);
                    }
                    ni = ni + szi;
                }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(out = 0; out < block->nout; out++)
                {
                    szi = block->outsz[out] * block->outsz[out + block->nout];
                    for(ii = 0; ii < szi; ii++)
                    {
                        outabl[ko++] = *((double *)(block->outptr[out]) + ii);
                    }
                    no = no + szi;
                }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(out = 0; out < block->nout; out++)
                {
                    szi = block->outsz[out] * block->outsz[out + block->nout];
                    for(ii = 0; ii < szi; ii++)
                    {
                        *((double *)(block->outptr[out]) + ii) = outabl[ko++];
                    }
                }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(in = 0; in < block->nevout; ++in)
            {
                block->evout[in] = block->evout[in] - *t;
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < block->ng; ++j)
                {
                    block->g[j] = (double)block->jroot[j];
                }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(in = 0 ; in < block->nin ; in++)
            {
                args[in] = block->inptr[in];
                sz[in] = block->insz[in];
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(out = 0; out < block->nout; out++)
            {
                args[in + out] = block->outptr[out];
                sz[in + out] = block->outsz[out];
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(in = 0; in < block->nevout; ++in)
            {
                block->evout[in] = block->evout[in] - *t;
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < block->ng; ++j)
                {
                    block->g[j] = (double)block->jroot[j];
                }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(in = 0; in < block->nevout; ++in)
            {
                block->evout[in] = block->evout[in] - *t;
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < block->ng; ++j)
                {
                    block->g[j] = (double)block->jroot[j];
                }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(in = 0 ; in < block->nin ; in++)
            {
                args[in] = block->inptr[in];
                sz[in] = block->insz[in];
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(out = 0; out < block->nout; out++)
            {
                args[in + out] = block->outptr[out];
                sz[in + out] = block->outsz[out];
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(in = 0; in < block->nevout; ++in)
            {
                block->evout[in] = block->evout[in] - *t;
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < block->ng; ++j)
                {
                    block->g[j] = (double)block->jroot[j];
                }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(in = 0; in < block->nevout; ++in)
            {
                block->evout[in] = block->evout[in] - *t;
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 0; k < block->nx; k++)
            {
                block->res[k] = block->res[k] - block->xd[k];
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 0; k < block->nx; k++)
            {
                block->xd[k] = block->res[k];
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 0; k < block->nx; k++)
            {
                block->res[k] = block->res[k] - block->xd[k];
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 0; k < block->nx; k++)
            {
                block->xd[k] = block->res[k];
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < *neq; i++)   xd[i] = 0; 



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < *neq; i++) 
        {
            if ((xd[i] - xd[i] != 0))
            {
                sciprint(_("\nWarning: The computing function #%d returns a NaN/Inf"), i);
                nantest = 1;
                break;
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(jj = 0; jj < ng; jj++)
            if (gout[jj] - gout[jj] != 0)
            {
                sciprint(_("\nWarning: The zero_crossing function #%d returns a NaN/Inf"), jj);
                nantest = 1;
                break;
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < *nequations; ++i) res[i] = 0; 



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < *nequations; i++) 
        {
            if ((res[i] - res[i] != 0))
            {
                sciprint(_("\nWarning: The computing function #%d returns a NaN/Inf"), i);
                nantest = 1;
                break;
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(jj = 0; jj < *ngc; jj++)
            if (res[jj] - res[jj] != 0)
            {
                sciprint(_("\nWarning: The zero_crossing function #%d returns a NaN/Inf"), jj);
                nantest = 1;
                break;
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(jj = 0; jj < qlast; jj++)
        alpha = alpha - ONE / (jj + 1);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(jj = 0; jj < *neq; jj++)
            if (residual[jj] - residual[jj] != 0) 
            {
                //sciprint(_("\nWarning: The residual function #%d returns a NaN"),jj);
                nantest = 1;
                break;
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(jj = 0; jj < ng; jj++)
        {
            if (gout[jj] - gout[jj] != 0)
            {
                sciprint(_("\nWarning: The zero-crossing function #%d returns a NaN"), jj);
                nantest = 1;
                break;
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < * (scs_imp->niord); j++)
    {
        kf = &scs_imp->iord[j];
        C2F(curblk).kfun = *kf; 
        if (scs_imp->funtyp[*kf - 1] > -1)
        {
            
            if (scs_imp->blocks[*kf - 1].nx > 0)
            {
                scs_imp->blocks[*kf - 1].x  = &scs_imp->x[scs_imp->xptr[*kf - 1] - 1];
                scs_imp->blocks[*kf - 1].xd = &scs_imp->xd[scs_imp->xptr[*kf - 1] - 1];
            }
            scs_imp->blocks[*kf - 1].nevprt = scs_imp->iord[j + * (scs_imp->niord)];
            
            callf(told, &scs_imp->blocks[*kf - 1], &flag);
            if (flag < 0)
            {
                *ierr = 5 - flag;
                return;
            }
        }
        if (scs_imp->blocks[*kf - 1].nevout > 0)
        {
            if (scs_imp->funtyp[*kf - 1] < 0)
            {
                i = synchro_nev(scs_imp, *kf, ierr);
                if (*ierr != 0)
                {
                    return;
                }
                i2 = i + scs_imp->clkptr[*kf - 1] - 1;
                putevs(told, &i2, &ierr1);
                if (ierr1 != 0)
                {
                    
                    *ierr = 3;
                    return;
                }
                doit(told);
                if (*ierr != 0)
                {
                    return;
                }
            }
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ii = scs_imp->ordptr[kever - 1]; ii <= scs_imp->ordptr[kever] - 1 ; ii++)
    {
        kf = &scs_imp->ordclk[ii - 1];
        C2F(curblk).kfun = *kf;
        if (scs_imp->funtyp[*kf - 1] > -1)
        {
            
            if (scs_imp->blocks[*kf - 1].nx > 0)
            {
                scs_imp->blocks[*kf - 1].x  = &scs_imp->x[scs_imp->xptr[*kf - 1] - 1];
                scs_imp->blocks[*kf - 1].xd = &scs_imp->xd[scs_imp->xptr[*kf - 1] - 1];
            }
            scs_imp->blocks[*kf - 1].nevprt = abs(scs_imp->ordclk[ii + * (scs_imp->nordclk) - 1]);
            flag = 1;
            
            callf(told, &scs_imp->blocks[*kf - 1], &flag);
            if (flag < 0)
            {
                *ierr = 5 - flag;
                return;
            }
        }

        
        if (scs_imp->blocks[*kf - 1].nevout > 0)
        {
            if (scs_imp->funtyp[*kf - 1] < 0)
            {
                i = synchro_nev(scs_imp, *kf, ierr);
                if (*ierr != 0)
                {
                    return;
                }
                i2 = i + scs_imp->clkptr[*kf - 1] - 1;
                putevs(told, &i2, &ierr1);
                if (ierr1 != 0)
                {
                    
                    *ierr = 3;
                    return;
                }
                doit(told);
                if (*ierr != 0)
                {
                    return;
                }
            }
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < * (scs_imp->ncord); j++)
    {
        kf = &scs_imp->cord[j];
        C2F(curblk).kfun = *kf;
        
        if (scs_imp->blocks[*kf - 1].nx > 0)
        {
            scs_imp->blocks[*kf - 1].x  = &scs_imp->x[scs_imp->xptr[*kf - 1] - 1];
            scs_imp->blocks[*kf - 1].xd = &scs_imp->xd[scs_imp->xptr[*kf - 1] - 1];
        }
        scs_imp->blocks[*kf - 1].nevprt = scs_imp->cord[j + * (scs_imp->ncord)];
        if (scs_imp->funtyp[*kf - 1] > -1)
        {
            flag = 1;
            
            callf(told, &scs_imp->blocks[*kf - 1], &flag);
            if (flag < 0)
            {
                *ierr = 5 - flag;
                return;
            }
        }

        
        if (scs_imp->blocks[*kf - 1].nevout > 0)
        {
            if (scs_imp->funtyp[*kf - 1] < 0)
            {
                i = synchro_nev(scs_imp, *kf, ierr);
                if (*ierr != 0)
                {
                    return;
                }
                i2 = i + scs_imp->clkptr[*kf - 1] - 1;
                putevs(told, &i2, &ierr1);
                if (ierr1 != 0)
                {
                    
                    *ierr = 3;
                    return;
                }
                doit(told);
                if (*ierr != 0)
                {
                    return;
                }
            }
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < kiwa; i++)
    {
        keve = iwa[i];
        if (critev[keve] != 0)
        {
            hot = 0;
        }
        i2 = scs_imp->ordptr[keve] - 1;
        for(ii = scs_imp->ordptr[keve - 1]; ii <= i2; ii++)
        {
            kf = &scs_imp->ordclk[ii - 1];
            C2F(curblk).kfun = *kf;
            
            if (scs_imp->blocks[*kf - 1].nx > 0)
            {
                scs_imp->blocks[*kf - 1].x  = &scs_imp->x[scs_imp->xptr[*kf - 1] - 1];
                scs_imp->blocks[*kf - 1].xd = &scs_imp->xd[scs_imp->xptr[*kf - 1] - 1];
            }

            scs_imp->blocks[*kf - 1].nevprt = scs_imp->ordclk[ii + * (scs_imp->nordclk) - 1];

            if (scs_imp->blocks[*kf - 1].nevout > 0)
            {
                if (scs_imp->funtyp[*kf - 1] >= 0)
                {
                    
                    for(j = 0; j < scs_imp->blocks[*kf - 1].nevout; j++)
                    {
                        scs_imp->blocks[*kf - 1].evout[j] = -1;
                    }
                    flag = 3;

                    if (scs_imp->blocks[*kf - 1].nevprt > 0) 
                    {
                        
                        callf(told, &scs_imp->blocks[*kf - 1], &flag);
                        if (flag < 0)
                        {
                            *ierr = 5 - flag;
                            return;
                        }
                    }

                    for(j = 0; j < scs_imp->blocks[*kf - 1].nevout; j++)
                    {
                        if (scs_imp->blocks[*kf - 1].evout[j] >= 0.)
                        {
                            i3 = j + scs_imp->clkptr[*kf - 1] ;
                            addevs(scs_imp->blocks[*kf - 1].evout[j] + (*told), &i3, &ierr1);
                            if (ierr1 != 0)
                            {
                                
                                *ierr = 3;
                                return;
                            }
                        }
                    }
                }
            }

            if (scs_imp->blocks[*kf - 1].nevprt > 0)
            {
                if (scs_imp->blocks[*kf - 1].nx + scs_imp->blocks[*kf - 1].nz + scs_imp->blocks[*kf - 1].noz > 0 || \
                        *scs_imp->blocks[*kf - 1].work != NULL)
                {
                    
                    
                    flag = 2;
                    
                    callf(told, &scs_imp->blocks[*kf - 1], &flag);
                    if (flag < 0)
                    {
                        *ierr = 5 - flag;
                        return;
                    }
                }
            }
            else
            {
                if (*scs_imp->blocks[*kf - 1].work != NULL)
                {
                    flag = 2;
                    scs_imp->blocks[*kf - 1].nevprt = 0; 
                    
                    callf(told, &scs_imp->blocks[*kf - 1], &flag);
                    if (flag < 0)
                    {
                        *ierr = 5 - flag;
                        return;
                    }
                }
            }
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ii = scs_imp->ordptr[kever - 1]; ii <= scs_imp->ordptr[kever] - 1; ii++)
    {
        kf = &scs_imp->ordclk[ii - 1];
        C2F(curblk).kfun = *kf;

        if (scs_imp->funtyp[*kf - 1] > -1)
        {
            
            if (scs_imp->blocks[*kf - 1].nx > 0)
            {
                scs_imp->blocks[*kf - 1].x  = &scs_imp->x[scs_imp->xptr[*kf - 1] - 1];
                scs_imp->blocks[*kf - 1].xd = &scs_imp->xd[scs_imp->xptr[*kf - 1] - 1];
            }

            scs_imp->blocks[*kf - 1].nevprt = abs(scs_imp->ordclk[ii + * (scs_imp->nordclk) - 1]);

            flag = 1;
            
            callf(told, &scs_imp->blocks[*kf - 1], &flag);
            if (flag < 0)
            {
                *ierr = 5 - flag;
                return;
            }
        }

        
        if (scs_imp->blocks[*kf - 1].nevout > 0)
        {
            if (scs_imp->funtyp[*kf - 1] < 0)
            {
                i = synchro_nev(scs_imp, *kf, ierr);
                if (*ierr != 0)
                {
                    return;
                }
                i2 = i + scs_imp->clkptr[*kf - 1] - 1;
                putevs(told, &i2, &ierr1);
                if (ierr1 != 0)
                {
                    
                    *ierr = 3;
                    return;
                }
                edoit(told, kiwa);
                if (*ierr != 0)
                {
                    return;
                }
            }
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(jj = 0; jj < * (scs_imp->noord); jj++)
    {
        kf = &scs_imp->oord[jj];
        C2F(curblk).kfun = *kf;
        
        if (scs_imp->blocks[*kf - 1].nx > 0)
        {
            scs_imp->blocks[*kf - 1].x  = &xt[scs_imp->xptr[*kf - 1] - 1];
            scs_imp->blocks[*kf - 1].xd = &xtd[scs_imp->xptr[*kf - 1] - 1];
            scs_imp->blocks[*kf - 1].res = &residual[scs_imp->xptr[*kf - 1] - 1];
        }

        scs_imp->blocks[*kf - 1].nevprt = scs_imp->oord[jj + * (scs_imp->noord)];
        if (scs_imp->funtyp[*kf - 1] > -1)
        {
            flag = 1;
            
            callf(told, &scs_imp->blocks[*kf - 1], &flag);
            if (flag < 0)
            {
                *ierr = 5 - flag;
                return;
            }
        }

        if (scs_imp->blocks[*kf - 1].nevout > 0)
        {
            if (scs_imp->funtyp[*kf - 1] < 0)
            {
                if (scs_imp->blocks[*kf - 1].nmode > 0)
                {
                    i2 = scs_imp->blocks[*kf - 1].mode[0] + scs_imp->clkptr[*kf - 1] - 1;
                }
                else
                {
                    i = synchro_nev(scs_imp, *kf, ierr);
                    if (*ierr != 0)
                    {
                        return;
                    }
                    i2 = i + scs_imp->clkptr[*kf - 1] - 1;
                }
                putevs(told, &i2, &ierr1);
                if (ierr1 != 0)
                {
                    
                    *ierr = 3;
                    return;
                }
                ozdoit(told, xt, xtd, &kiwa);
                if (*ierr != 0)
                {
                    return;
                }
            }
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ii = 0; ii < * (scs_imp->noord); ii++)
    {
        kf = &scs_imp->oord[ii];
        C2F(curblk).kfun = *kf;
        if (scs_imp->blocks[*kf - 1].nx > 0 || \
                *scs_imp->blocks[*kf - 1].work != NULL)
        {
            
            flag = 0;
            
            if (scs_imp->blocks[*kf - 1].nx > 0)
            {
                scs_imp->blocks[*kf - 1].x  = &xt[scs_imp->xptr[*kf - 1] - 1];
                scs_imp->blocks[*kf - 1].xd = &xtd[scs_imp->xptr[*kf - 1] - 1];
                scs_imp->blocks[*kf - 1].res = &residual[scs_imp->xptr[*kf - 1] - 1];
            }
            scs_imp->blocks[*kf - 1].nevprt = scs_imp->oord[ii + * (scs_imp->noord)];
            
            callf(told, &scs_imp->blocks[*kf - 1], &flag);

            if (flag < 0)
            {
                *ierr = 5 - flag;
                return;
            }
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < kiwa; i++)
    {
        keve = iwa[i];
        for(ii = scs_imp->ordptr[keve - 1]; ii <= scs_imp->ordptr[keve] - 1; ii++)
        {
            kf = &scs_imp->ordclk[ii - 1];
            C2F(curblk).kfun = *kf;
            if (scs_imp->blocks[*kf - 1].nx > 0 || \
                    *scs_imp->blocks[*kf - 1].work != NULL)
            {
                
                flag = 0;
                
                if (scs_imp->blocks[*kf - 1].nx > 0)
                {
                    scs_imp->blocks[*kf - 1].x  = &xt[scs_imp->xptr[*kf - 1] - 1];
                    scs_imp->blocks[*kf - 1].xd = &xtd[scs_imp->xptr[*kf - 1] - 1];
                    scs_imp->blocks[*kf - 1].res = &residual[scs_imp->xptr[*kf - 1] - 1];
                }
                scs_imp->blocks[*kf - 1].nevprt = abs(scs_imp->ordclk[ii + * (scs_imp->nordclk) - 1]);
                
                callf(told, &scs_imp->blocks[*kf - 1], &flag);

                if (flag < 0)
                {
                    *ierr = 5 - flag;
                    return;
                }
            }
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(jj = 0; jj < * (scs_imp->noord); jj++)
    {
        kf = &scs_imp->oord[jj];
        C2F(curblk).kfun = *kf;
        
        if (scs_imp->blocks[*kf - 1].nx > 0)
        {
            scs_imp->blocks[*kf - 1].x  = &scs_imp->x[scs_imp->xptr[*kf - 1] - 1];
            scs_imp->blocks[*kf - 1].xd = &scs_imp->xd[scs_imp->xptr[*kf - 1] - 1];
        }
        scs_imp->blocks[*kf - 1].nevprt = scs_imp->oord[jj + * (scs_imp->noord)];
        if (scs_imp->funtyp[*kf - 1] > -1)
        {
            flag = 1;
            
            callf(told, &scs_imp->blocks[*kf - 1], &flag);
            if (flag < 0)
            {
                *ierr = 5 - flag;
                return;
            }
        }

        if (scs_imp->blocks[*kf - 1].nevout > 0 && scs_imp->funtyp[*kf - 1] < 0)
        {
            i = synchro_nev(scs_imp, *kf, ierr);
            if (*ierr != 0)
            {
                return;
            }
            if (scs_imp->blocks[*kf - 1].nmode > 0)
            {
                scs_imp->blocks[*kf - 1].mode[0] = i;
            }
            i2 = i + scs_imp->clkptr[*kf - 1] - 1;
            putevs(told, &i2, &ierr1);
            if (ierr1 != 0)
            {
                
                *ierr = 3;
                return;
            }
            doit(told);
            if (*ierr != 0)
            {
                return;
            }
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ii = 0; ii < * (scs_imp->noord); ii++)
    {
        kf = &scs_imp->oord[ii];
        C2F(curblk).kfun = *kf;
        if (scs_imp->blocks[*kf - 1].nx > 0)
        {
            flag = 7;
            scs_imp->blocks[*kf - 1].x  = &scs_imp->x[scs_imp->xptr[*kf - 1] - 1];
            scs_imp->blocks[*kf - 1].xd = &scs_imp->xd[scs_imp->xptr[*kf - 1] - 1];
            scs_imp->blocks[*kf - 1].res = &scs_imp->xd[scs_imp->xptr[*kf - 1] - 1];
            scs_imp->blocks[*kf - 1].nevprt = scs_imp->oord[ii + * (scs_imp->noord)];
            scs_imp->blocks[*kf - 1].xprop = &scs_imp->xprop[-1 + scs_imp->xptr[*kf - 1]];
            
            callf(told, &scs_imp->blocks[*kf - 1], &flag);
            if (flag < 0)
            {
                *ierr = 5 - flag;
                return;
            }
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < kiwa; i++)
    {
        keve = iwa[i];
        for(ii = scs_imp->ordptr[keve - 1]; ii <= scs_imp->ordptr[keve] - 1; ii++)
        {
            kf = &scs_imp->ordclk[ii - 1];
            C2F(curblk).kfun = *kf;
            if (scs_imp->blocks[*kf - 1].nx > 0)
            {
                flag = 7;
                scs_imp->blocks[*kf - 1].x  = &scs_imp->x[scs_imp->xptr[*kf - 1] - 1];
                scs_imp->blocks[*kf - 1].xd = &scs_imp->xd[scs_imp->xptr[*kf - 1] - 1];
                scs_imp->blocks[*kf - 1].res = &scs_imp->xd[scs_imp->xptr[*kf - 1] - 1];
                scs_imp->blocks[*kf - 1].nevprt = abs(scs_imp->ordclk[ii + * (scs_imp->nordclk) - 1]);
                scs_imp->blocks[*kf - 1].xprop = &scs_imp->xprop[-1 + scs_imp->xptr[*kf - 1]];
                
                callf(told, &scs_imp->blocks[*kf - 1], &flag);
                if (flag < 0)
                {
                    *ierr = 5 - flag;
                    return;
                }
            }
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ii = scs_imp->ordptr[kever - 1]; ii <= scs_imp->ordptr[kever] - 1; ii++)
    {
        kf = &scs_imp->ordclk[ii - 1];
        C2F(curblk).kfun = *kf;
        if (scs_imp->funtyp[*kf - 1] > -1)
        {
            
            if (scs_imp->blocks[*kf - 1].nx > 0)
            {
                scs_imp->blocks[*kf - 1].x  = &xt[scs_imp->xptr[*kf - 1] - 1];
                scs_imp->blocks[*kf - 1].xd = &xtd[scs_imp->xptr[*kf - 1] - 1];
            }
            scs_imp->blocks[*kf - 1].nevprt = abs(scs_imp->ordclk[ii + * (scs_imp->nordclk) - 1]);
            flag = 1;
            
            callf(told, &scs_imp->blocks[*kf - 1], &flag);
            if (flag < 0)
            {
                *ierr = 5 - flag;
                return;
            }
        }

        
        if (scs_imp->blocks[*kf - 1].nevout > 0)
        {
            if (scs_imp->funtyp[*kf - 1] < 0)
            {
                if (phase == 1 || scs_imp->blocks[*kf - 1].nmode == 0)
                {
                    i = synchro_nev(scs_imp, *kf, ierr);
                    if (*ierr != 0)
                    {
                        return;
                    }
                }
                else
                {
                    i = scs_imp->blocks[*kf - 1].mode[0];
                }
                i2 = i + scs_imp->clkptr[*kf - 1] - 1;
                putevs(told, &i2, &ierr1);
                if (ierr1 != 0)
                {
                    
                    *ierr = 3;
                    return;
                }
                ozdoit(told, xt, xtd, kiwa);
            }
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < * (scs_imp->ng); i++)
    {
        g[i] = 0.;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(jj = 0; jj < * (scs_imp->nzord); jj++)
    {
        kf = &scs_imp->zord[jj];
        C2F(curblk).kfun = *kf;
        
        if (scs_imp->blocks[*kf - 1].nx > 0)
        {
            scs_imp->blocks[*kf - 1].x  = &xt[scs_imp->xptr[*kf - 1] - 1];
            scs_imp->blocks[*kf - 1].xd = &xtd[scs_imp->xptr[*kf - 1] - 1];
        }
        scs_imp->blocks[*kf - 1].nevprt = scs_imp->zord[jj + * (scs_imp->nzord)];

        if (scs_imp->funtyp[*kf - 1] > -1)
        {
            flag = 1;
            
            callf(told, &scs_imp->blocks[*kf - 1], &flag);
            if (flag < 0)
            {
                *ierr = 5 - flag;
                return;
            }
        }

        
        if (scs_imp->blocks[*kf - 1].nevout > 0)
        {
            if (scs_imp->funtyp[*kf - 1] < 0)
            {
                if (phase == 1 || scs_imp->blocks[*kf - 1].nmode == 0)
                {
                    i = synchro_nev(scs_imp, *kf, ierr);
                    if (*ierr != 0)
                    {
                        return;
                    }
                }
                else
                {
                    i = scs_imp->blocks[*kf - 1].mode[0];
                }
                i2 = i + scs_imp->clkptr[*kf - 1] - 1;
                putevs(told, &i2, &ierr1);
                if (ierr1 != 0)
                {
                    
                    *ierr = 3;
                    return;
                }
                ozdoit(told, xt, xtd, &kiwa);
                if (*ierr != 0)
                {
                    return;
                }
            }
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ii = 0; ii < * (scs_imp->nzord); ii++)
    {
        kf = &scs_imp->zord[ii];
        C2F(curblk).kfun = *kf;
        if (scs_imp->blocks[*kf - 1].ng > 0)
        {
            
            scs_imp->blocks[*kf - 1].g = &g[scs_imp->zcptr[*kf - 1] - 1];
            if (scs_imp->funtyp[*kf - 1] > 0)
            {
                flag = 9;
                
                if (scs_imp->blocks[*kf - 1].nx > 0)
                {
                    scs_imp->blocks[*kf - 1].x  = &xt[scs_imp->xptr[*kf - 1] - 1];
                    scs_imp->blocks[*kf - 1].xd = &xtd[scs_imp->xptr[*kf - 1] - 1];
                }
                scs_imp->blocks[*kf - 1].nevprt = scs_imp->zord[ii + * (scs_imp->nzord)];
                
                callf(told, &scs_imp->blocks[*kf - 1], &flag);
                if (flag < 0)
                {
                    *ierr = 5 - flag;
                    return;
                }
            }
            else
            {
                j = synchro_g_nev(scs_imp, g, *kf, ierr);
                if (*ierr != 0)
                {
                    return;
                }
                if ( (phase == 1) && (scs_imp->blocks[*kf - 1].nmode > 0) )
                {
                    scs_imp->blocks[*kf - 1].mode[0] = j;
                }
            }

            // scs_imp->blocks[*kf-1].g = &scs_imp->g[scs_imp->zcptr[*kf]-1];

        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < kiwa; i++)
    {
        keve = iwa[i];
        for(ii = scs_imp->ordptr[keve - 1]; ii <= scs_imp->ordptr[keve] - 1; ii++)
        {
            kf = &scs_imp->ordclk[ii - 1];
            C2F(curblk).kfun = *kf;
            if (scs_imp->blocks[*kf - 1].ng > 0)
            {
                
                scs_imp->blocks[*kf - 1].g = &g[scs_imp->zcptr[*kf - 1] - 1];
                if (scs_imp->funtyp[*kf - 1] > 0)
                {
                    flag = 9;
                    
                    if (scs_imp->blocks[*kf - 1].nx > 0)
                    {
                        scs_imp->blocks[*kf - 1].x  = &xt[scs_imp->xptr[*kf - 1] - 1];
                        scs_imp->blocks[*kf - 1].xd = &xtd[scs_imp->xptr[*kf - 1] - 1];
                    }
                    scs_imp->blocks[*kf - 1].nevprt = abs(scs_imp->ordclk[ii + * (scs_imp->nordclk) - 1]);
                    
                    callf(told, &scs_imp->blocks[*kf - 1], &flag);
                    if (flag < 0)
                    {
                        *ierr = 5 - flag;
                        return;
                    }
                }
                else
                {
                    j = synchro_g_nev(scs_imp, g, *kf, ierr);
                    if (*ierr != 0)
                    {
                        return;
                    }
                    if ((phase == 1) && (scs_imp->blocks[*kf - 1].nmode > 0))
                    {
                        scs_imp->blocks[*kf - 1].mode[0] = j;
                    }
                }

                //scs_imp->blocks[*kf-1].g = &scs_imp->g[scs_imp->zcptr[*kf]-1];
            }
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(jj = 0; jj < * (scs_imp->noord); jj++)
    {
        kf = &scs_imp->oord[jj];
        C2F(curblk).kfun = *kf;
        scs_imp->blocks[*kf - 1].nevprt = scs_imp->oord[jj + * (scs_imp->noord)];
        if (scs_imp->funtyp[*kf - 1] > -1)
        {
            flag = 1;
            
            if ((*job == 2) && (scs_imp->oord[jj] == AJacobian_block))
            {
            }
            else
                
                if (scs_imp->blocks[*kf - 1].nx > 0)
                {
                    scs_imp->blocks[*kf - 1].x  = &xt[scs_imp->xptr[*kf - 1] - 1];
                    scs_imp->blocks[*kf - 1].xd = &xtd[scs_imp->xptr[*kf - 1] - 1];
                    scs_imp->blocks[*kf - 1].res = &residual[scs_imp->xptr[*kf - 1] - 1];
                }

            
            callf(told, &scs_imp->blocks[*kf - 1], &flag);
            if (flag < 0)
            {
                *ierr = 5 - flag;
                return;
            }
        }

        if (scs_imp->blocks[*kf - 1].nevout > 0)
        {
            if (scs_imp->funtyp[*kf - 1] < 0)
            {
                if (scs_imp->blocks[*kf - 1].nmode > 0)
                {
                    i2 = scs_imp->blocks[*kf - 1].mode[0] + scs_imp->clkptr[*kf - 1] - 1;
                }
                else
                {
                    i = synchro_nev(scs_imp, *kf, ierr);
                    if (*ierr != 0)
                    {
                        return;
                    }
                    i2 = i + scs_imp->clkptr[*kf - 1] - 1;
                }
                putevs(told, &i2, &ierr1);
                if (ierr1 != 0)
                {
                    
                    *ierr = 3;
                    return;
                }
                ozdoit(told, xt, xtd, &kiwa);
            }
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ii = 0; ii < * (scs_imp->noord); ii++)
    {
        kf = &scs_imp->oord[ii];
        C2F(curblk).kfun = *kf;
        if (scs_imp->blocks[*kf - 1].nx > 0 || \
                *scs_imp->blocks[*kf - 1].work != NULL)
        {
            
            flag = 0;
            if (((*job == 1) && (scs_imp->oord[ii] == AJacobian_block)) || (*job != 1))
            {
                if (*job == 1)  flag = 10;
                
                if (scs_imp->blocks[*kf - 1].nx > 0)
                {
                    scs_imp->blocks[*kf - 1].x  = &xt[scs_imp->xptr[*kf - 1] - 1];
                    scs_imp->blocks[*kf - 1].xd = &xtd[scs_imp->xptr[*kf - 1] - 1];
                    scs_imp->blocks[*kf - 1].res = &residual[scs_imp->xptr[*kf - 1] - 1];
                }
                scs_imp->blocks[*kf - 1].nevprt = scs_imp->oord[ii + * (scs_imp->noord)];
                
                callf(told, &scs_imp->blocks[*kf - 1], &flag);
            }
            if (flag < 0)
            {
                *ierr = 5 - flag;
                return;
            }
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < kiwa; i++)
    {
        keve = iwa[i];
        for(ii = scs_imp->ordptr[keve - 1]; ii <= scs_imp->ordptr[keve] - 1;  ii++)
        {
            kf = &scs_imp->ordclk[ii - 1];
            C2F(curblk).kfun = *kf;
            if (scs_imp->blocks[*kf - 1].nx > 0 || \
                    *scs_imp->blocks[*kf - 1].work != NULL)
            {
                
                flag = 0;
                if (((*job == 1) && (scs_imp->oord[ii - 1] == AJacobian_block)) || (*job != 1))
                {
                    if (*job == 1)  flag = 10;
                    
                    if (scs_imp->blocks[*kf - 1].nx > 0)
                    {
                        scs_imp->blocks[*kf - 1].x  = &xt[scs_imp->xptr[*kf - 1] - 1];
                        scs_imp->blocks[*kf - 1].xd = &xtd[scs_imp->xptr[*kf - 1] - 1];
                        scs_imp->blocks[*kf - 1].res = &residual[scs_imp->xptr[*kf - 1] - 1];
                    }
                    scs_imp->blocks[*kf - 1].nevprt = abs(scs_imp->ordclk[ii + * (scs_imp->nordclk) - 1]);
                    
                    callf(told, &scs_imp->blocks[*kf - 1], &flag);
                }
                if (flag < 0)
                {
                    *ierr = 5 - flag;
                    return;
                }
            }
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(jj = 0; jj < scs_imp->blocks[kf - 1].nevout - 1; jj++)
                {
                    g[zcptr[kf - 1] - 1 + jj] = *outtbdptr - (double)(jj + 2);
                }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(jj = 0; jj < scs_imp->blocks[kf - 1].nevout - 1; jj++)
                {
                    g[zcptr[kf - 1] - 1 + jj] = *outtbdptr - (double)(jj + 2);
                }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(jj = 0; jj < scs_imp->blocks[kf - 1].nevout - 1; jj++)
                {
                    g[zcptr[kf - 1] - 1 + jj] = (double) * outtbcptr - (double)(jj + 2);
                }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(jj = 0; jj < scs_imp->blocks[kf - 1].nevout - 1; jj++)
                {
                    g[zcptr[kf - 1] - 1 + jj] = (double) * outtbsptr - (double)(jj + 2);
                }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(jj = 0; jj < scs_imp->blocks[kf - 1].nevout - 1; jj++)
                {
                    g[zcptr[kf - 1] - 1 + jj] = (double) * outtblptr - (double)(jj + 2);
                }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(jj = 0; jj < scs_imp->blocks[kf - 1].nevout - 1; jj++)
                {
                    g[zcptr[kf - 1] - 1 + jj] = (double) * outtbucptr - (double)(jj + 2);
                }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(jj = 0; jj < scs_imp->blocks[kf - 1].nevout - 1; jj++)
                {
                    g[zcptr[kf - 1] - 1 + jj] = (double) * outtbusptr - (double)(jj + 2);
                }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(jj = 0; jj < scs_imp->blocks[kf - 1].nevout - 1; jj++)
                {
                    g[zcptr[kf - 1] - 1 + jj] = (double) * outtbulptr - (double)(jj + 2);
                }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(kf = 0; kf < nblk; ++kf)
    {
        if (Blocks[kf].insz != NULL)
        {
            FREE(Blocks[kf].insz);
        }
        else
        {
            break;
        }
        if (Blocks[kf].inptr != NULL)
        {
            FREE(Blocks[kf].inptr);
        }
        else
        {
            break;
        }
        if (Blocks[kf].outsz != NULL)
        {
            FREE(Blocks[kf].outsz);
        }
        else
        {
            break;
        }
        if (Blocks[kf].outptr != NULL)
        {
            FREE(Blocks[kf].outptr);
        }
        else
        {
            break;
        }
        if (Blocks[kf].oparsz != NULL)
        {
            FREE(Blocks[kf].oparsz);
        }
        else
        {
            break;
        }
        if (Blocks[kf].ozsz != NULL)
        {
            FREE(Blocks[kf].ozsz);
        }
        else
        {
            break;
        }
        if (Blocks[kf].label != NULL)
        {
            FREE(Blocks[kf].label);
        }
        else
        {
            break;
        }
        if (Blocks[kf].evout != NULL)
        {
            FREE(Blocks[kf].evout);
        }
        else
        {
            break;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < Blocks[C2F(curblk).kfun - 1].nx; i++)
    {
        Blocks[C2F(curblk).kfun - 1].xprop[i] = pointer[i];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < m; i++)
        for(j = 0; j < ni; j++)
            Kx[j + i * ni] = u[j][0];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < m; i++)
    {
        xi = xc[i];
        xpi = xcdot[i];
        inc = MAX( srur * MAX( ABS(xi), ABS(hh * xpi)), ONE / ewt_data[i] );
        if (hh * xpi < ZERO) inc = -inc;
        inc = (xi + inc) - xi;

        




        // xc[i] += CI*inc;
        // xcdot[i] += CJ*inc;
        xc[i] += inc;
        xcdot[i] += CJJ * inc;
        


        job = 0; 
        Jdoit(&ttx, xc, xcdot, ERR2, &job);
        if (*ierr < 0) return -1;
        inc_inv = ONE / inc;
        for(j = 0; j < m; j++)
            Hx[m * i + j] = (ERR2[j] - residual[j]) * inc_inv;
        for(j = 0; j < ni; j++)
            Kx[j + i * ni] = (u[j][0] - Kx[j + i * ni]) * inc_inv;
        xc[i] = xi;
        xcdot[i] = xpi;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < m; j++)
        {
            Jacque_col = DENSE_COL(Jacque, j);
            for(i = 0; i < m; i++)
            {
                Jacque_col[i] = Hx[i + j * m];
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < no; i++)
        for(j = 0; j < ni; j++)
            Ku[j + i * ni] = u[j][0];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < no; i++)
    {
        ysave = y[i][0];
        inc = srur * MAX( ABS(ysave), 1);
        inc = (ysave + inc) - ysave;
        

        y[i][0] += inc;
        job = 2; 
        Jdoit(&ttx, xc, xcdot, ERR2, &job);
        if (*ierr < 0) return -1;
        inc_inv = ONE / inc;
        for(j = 0; j < m; j++)
            Hu[m * i + j] = (ERR2[j] - ERR1[j]) * inc_inv;
        for(j = 0; j < ni; j++)
            Ku[j + i * ni] = (u[j][0] - Ku[j + i * ni]) * inc_inv;
        y[i][0] = ysave;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < nx; j++)
    {
        Jacque_col = DENSE_COL(Jacque, j + m);
        for(i = 0; i < nx; i++)
        {
            Jacque_col[i + m] = Fx[i + j * nx] + FuKuGx[i + j * nx];
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nx; i++)
    {
        Jacque_col = DENSE_COL(Jacque, i + m);
        for(j = 0; j < m; j++)
        {
            Jacque_col[j] = HuGx[j + i * m];
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < m; i++)
    {
        Jacque_col = DENSE_COL(Jacque, i);
        for(j = 0; j < nx; j++)
        {
            Jacque_col[j + m] = FuKx[j + i * nx];
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < m; j++)
    {
        Jacque_col = DENSE_COL(Jacque, j);
        for(i = 0; i < m; i++)
        {
            Jacque_col[i] = Hx[i + j * m] + HuGuKx[i + j * m];
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < ra; i++)
        for(j = 0; j < cb; j++)
        {
            R[i + ra * j] = 0.0;
            for(k = 0; k < ca; k++)
                R[i + ra * j] += A[i + k * ra] * B[k + j * rb];
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nvar; i++)
    {
        if (strcmp(ids[i], "") != 0)
        {
            result = 1;
            break;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nvar; i++)
    {
        vr = 0.0;
        result = read_id(&elements, ids[i], &vr);
        if (result == 1) svars[i] = vr;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i <= ln - 2; i++) V2[i - 1] = V1[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nvar; i++)
    {
        if (strcmp(ids[i], "") != 0)
        {
            result = 1;
            break;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nvar; i++)
    {
        xv[i] = MALLOC(nvar * 100 * sizeof(char));
        sprintf(xv[i], "%g", x[i]);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nvar; i++)
        {
            FREE(xv[i]);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nvar; i++)
    {
        if (strcmp(ids[i], "") == 0) continue;
        result = write_in_child(&elements, ids[i], xv[i]);
        if (result == 0 )
        {
            
             
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nvar; i++)
        {
            FREE(xv[i]);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
        rho[i] += (-1 + *L) * a[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < N; j++)
            jac[j] = a[j];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < N; j++)
            jac[j] = (jac[j] - work[j]) * inc_inv;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < N; j++)
        jac[j] = (jac[j] - work[j]) * inc_inv;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(jj = 0; jj < N; jj++)
        {
            if (residual[jj] - residual[jj] != 0)
            {
                sciprint(_("\nWarning: The initialization system #%d returns a NaN/Inf"), jj);
                nantest = 1;
                break;
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( j = 0; j < N; j++)
    {
        ysdata[j] = 1;
        fsdata[j] = 1;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 0; k <= N_iters; k++) 
    {
        phase = PH;
        
        for(i = 0; i < 10; i++)
        {
            simblkKinsol(y, fscale, NULL);

            for(j = 0; j < N; j++)
                if (fsdata[j] - fsdata[j] != 0)
                {
                    sciprint(_("\nWarning: The residual function #%d returns a NaN/Inf"), j);
                    sciprint(_("\n The residual function returns NAN/Inf. \n Please verify your model:\n some functions might be called with illegal inputs."));
                    freekinsol;
                    *ierr = 400 - status;
                    C2F(ierode).iero = *ierr;
                    return -1;
                }
            ratio = 0.3;
            for( j = 0; j < N; j++)
            {
                if (x[j] == 0)      ysdata[j] += 1 * ratio;
                else ysdata[j] += ratio / fabs(x[j]);
                if (fsdata[j] == 0) fsdata[j] = 1;
                else fsdata[j] = 1 / fabs(fsdata[j]);
                ysdata[j] /= ratio + 1;
            }
            status = KINSol(kin_mem, y, strategy, yscale, fscale);
            if (status >= 0) break;
            
            while (ismenu()) /















        if (PH == 2 )
        {
            for(j = 0; j < nmod; ++j)
            {
                Mode_save[j] = mod[j];
            }

            if (ng > 0 && nmod > 0)
            {
                phase = 1; // updating the modes
                zdoit(told, x, xd, g);
                if (*ierr != 0)
                {
                    freekinsol;
                    C2F(ierode).iero = *ierr;
                    return -1;
                }
            }

            Mode_change = 0;
            for(j = 0; j < nmod; ++j)
            {
                if (Mode_save[j] != mod[j])
                {
                    Mode_change = 1;
                    break;
                }
            }

            if (Mode_change == 0 && status >= 0 )  break; 

        }
        else
        {
            
            if (status >= 0) break;
        }

    } 

    if (status < 0 )
    {
        *ierr = 400 - status;
        C2F(ierode).iero = *ierr;
    }
    freekinsol;
    return status;
}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k=0;k<*nin;k++) {
	u=(double *)inptr[k];
	nu=insz[k];
	nu2=insz[*nin+k];
//	C2F(dtosci)(u,&nu,&one);
	C2F(dtosci)(u,&nu,&nu2);
	if (C2F(scierr)()!=0) goto err;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k=*nout-1;k>=0;k--) {
	  y=(double *)outptr[k];
	  ny=outsz[k];
	  ny2=outsz[*nout+k];
//	  C2F(scitod)(y,&ny,&one);
	  C2F(scitod)(y,&ny,&ny2);
	  if (C2F(scierr)()!=0) goto err;
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k=*nout-1;k>=0;k--) {
		y=(double *)outptr[k];
		ny=outsz[k];
		C2F(scitod)(y,&ny,&one);
		if (C2F(scierr)()!=0) goto err;
	    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<nout;j++)
     {
      il_outptr = (int *) listentry(il_out,j+1);
      ierr=sci2var(il_outptr,Blocks[0].outptr[j],Blocks[0].outsz[2*nout+j]);
      if (ierr!=0) goto err;
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<Blocks[0].noz;j++)
      {
       il_ozptr = (int *) listentry(il_oz,j+1);
       if (Blocks[0].oztyp[j]==SCSUNKNOW_N)
       { 
        ne1=Blocks[0].ozsz[j];
        C2F(unsfdcopy)(&ne1,(double *)il_ozptr,\
                       (i=1,&i),(double *)Blocks[0].ozptr[j],(k=1,&k));
       }
       else
       {
        ierr=sci2var(il_ozptr,Blocks[0].ozptr[j],Blocks[0].oztyp[j]);
        if (ierr!=0) goto err;
       }
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<Blocks[0].noz;j++)
      {
       il_ozptr = (int *) listentry(il_oz,j+1);
       if (Blocks[0].oztyp[j]==SCSUNKNOW_N)
       {
        ne1=Blocks[0].ozsz[j];
        C2F(unsfdcopy)(&ne1,(double *)il_ozptr,\
                       (i=1,&i),(double *)Blocks[0].ozptr[j],(k=1,&k));
       }
       else
       {
        ierr=sci2var(il_ozptr,Blocks[0].ozptr[j],Blocks[0].oztyp[j]);
        if (ierr!=0) goto err;
       }
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<Blocks[0].noz;j++)
      {
       il_ozptr = (int *) listentry(il_oz,j+1);
       if (Blocks[0].oztyp[j]==SCSUNKNOW_N)
       {
        ne1=Blocks[0].ozsz[j];
        C2F(unsfdcopy)(&ne1,(double *)il_ozptr,\
                       (i=1,&i),(double *)Blocks[0].ozptr[j],(k=1,&k));
       }
       else
       {
        ierr=sci2var(il_ozptr,Blocks[0].ozptr[j],Blocks[0].oztyp[j]);
        if (ierr!=0) goto err;
       }
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<Blocks[0].noz;j++)
      {
       il_ozptr = (int *) listentry(il_oz,j+1);
       if (Blocks[0].oztyp[j]==SCSUNKNOW_N)
       {
        ne1=Blocks[0].ozsz[j];
        C2F(unsfdcopy)(&ne1,(double *)il_ozptr,\
                       (i=1,&i),(double *)Blocks[0].ozptr[j],(k=1,&k));
       }
       else
       {
        ierr=sci2var(il_ozptr,Blocks[0].ozptr[j],Blocks[0].oztyp[j]);
        if (ierr!=0) goto err;
       }
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<nout;j++)
     {
      il_outptr = (int *) listentry(il_out,j+1);
      ierr=sci2var(il_outptr,Blocks[0].outptr[j],Blocks[0].outsz[2*nout+j]);
      if (ierr!=0) goto err;
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(nv=0;nv<Blocks[0].nx;nv++) {
			   Blocks[0].xprop[nv]=(int) l_xprop[nv];
		   }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(nv=0;nv<(il_mode[1]*il_mode[2]);nv++) {
         Blocks[0].mode[nv]=(int) l_mode[nv];
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<n*m;i++) y_i[i] = ptr_i[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<n*m;i++) y_c[i] = ptr_c[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<n*m;i++) y_s[i] = ptr_s[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<n*m;i++) y_l[i] = ptr_l[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<n*m;i++) y_ui[i] = ptr_ui[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<n*m;i++) y_uc[i] = ptr_uc[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<n*m;i++) y_us[i] = ptr_us[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<n*m;i++) y_ul[i] = ptr_ul[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k=0;k<nblk;k++) {
      n1=(int)(scicos_imp.izptr[k]-scicos_imp.izptr[k-1]);
      if (n1==*n) {
	i0=scicos_imp.izptr[k-1]-1;
	i=0;
	while ((lab[i]==scicos_imp.iz[i0+i])&(i<n1)) i++;
	if (i==n1) {
	  *kfun=k+1;
	  return;
	}
      }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k=0;k<nblk;k++) {
      n1=(int)(scicos_imp.izptr[k]-scicos_imp.izptr[k-1]);
      if (n1==*n) {
	i0=scicos_imp.izptr[k-1]-1;
	i=0;
	while ((label[i]==scicos_imp.iz[i0+i])&(i<n1)) i++;
	if (i==n1) {
	  *kfun=k+1;
	  return 0;
	}
      }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<*n;i++)
	    *(y++)=*(u++);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(; xml && idx; idx--) xml = xml->next;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; root->attr[i] && strcmp(xml->name, root->attr[i][0]); i++);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(t = root->s; t < s; t++) if (*t == '\n') line++;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(; *s; s++) { // normalize line endings
        while (*s == '\r') {
            *(s++) = '\n';
            if (*s == '\n') memmove(s, (s + 1), strlen(s));
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(s = r; ; ) {
        while (*s && *s != '&' && (*s != '%' || t != '%') && !isspace(*s)) s++;

        if (! *s) break;
        else if (t != 'c' && ! strncmp(s, "&#", 2)) { // character reference
            if (s[2] == 'x') c = strtol(s + 3, &e, 16); // base 16
            else c = strtol(s + 2, &e, 10); // base 10
            if (! c || *e != ';') { s++; continue; } // not a character ref

            if ((long)c < 0x80) *(s++) = (char)c; // US-ASCII subset
            else { // multi-byte UTF-8 sequence
                for(b = 0, d = c; d; d /= 2) b++; // number of bits in c
                b = (b - 2) / 5; // number of bytes in payload
                *(s++) = (char)(0xFF << (7 - b)) | (char)(c >> (6 * b)); // head
                while (b) *(s++) = 0x80 | ((c >> (6 * --b)) & 0x3F); // payload
            }

            memmove(s, strchr(s, ';') + 1, strlen(strchr(s, ';')));
        }
        else if ((*s == '&' && (t == '&' || t == ' ' || t == '*')) ||
                 (*s == '%' && t == '%')) { // entity reference
            for(b = 0; ent[b] && strncmp(s + 1, ent[b], strlen(ent[b]));
                 b += 2); // find entity in entity list

            if (ent[b++]) { // found a match
                if ((c = (long)strlen(ent[b])) - 1 > (e = strchr(s, ';')) - s) {
                    l = (long)(d = (long)(s - r)) + c + (long)strlen(e); // new length
                    r = (r == m) ? strcpy(MALLOC(l), r) : REALLOC(r, l);
                    e = strchr((s = r + d), ';'); // fix up pointers
                }

                memmove(s + c, e + 1, strlen(e)); // shift rest of string
                strncpy(s, ent[b], c); // copy in replacement text
            }
            else s++; // not a known entity
        }
        else if ((t == ' ' || t == '*') && isspace(*s)) *(s++) = ' ';
        else s++; // no decoding needed
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(s = r; *s; s++) {
            if ((l = (long)strspn(s, " "))) memmove(s, s + l, (long)strlen(s + l) + 1);
            while (*s && *s != ' ') s++;
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(; ; s++) {
        while (*s && *s != '&') s++; // find next entity reference
        if (! *s) return 1;
        if (! strncmp(s + 1, name, strlen(name))) return 0; // circular ref.
        for(i = 0; ent[i] && strncmp(ent[i], s + 1, strlen(ent[i])); i += 2);
        if (ent[i] && ! ezxml_ent_ok(name, ent[i + 1], ent)) return 0;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(s[len] = '\0'; s; ) {
        while (*s && *s != '<' && *s != '%') s++; // find next declaration

        if (! *s) break;
        else if (! strncmp(s, "<!ENTITY", 8)) { // parse entity definitions
            c = s += strspn(s + 8, EZXML_WS) + 8; // skip white space separator
            n = s + strspn(s, EZXML_WS "%"); // find name
            *(s = n + strcspn(n, EZXML_WS)) = ';'; // append ; to name

            v = s + strspn(s + 1, EZXML_WS) + 1; // find value
            if ((q = *(v++)) != '"' && q != '\'') { // skip externals
                s = strchr(s, '>');
                continue;
            }

            for(i = 0, ent = (*c == '%') ? pe : root->ent; ent[i]; i++);
            ent = REALLOC(ent, (i + 3) * sizeof(char *)); // space for next ent
            if (*c == '%') pe = ent;
            else root->ent = ent;

            *(++s) = '\0'; // null terminate name
            if ((s = strchr(v, q))) *(s++) = '\0'; // null terminate value
            ent[i + 1] = ezxml_decode(v, pe, '%'); // set value
            ent[i + 2] = NULL; // null terminate entity list
            if (! ezxml_ent_ok(n, ent[i + 1], ent)) { // circular reference
                if (ent[i + 1] != v) FREE(ent[i + 1]);
                ezxml_err(root, v, "circular entity declaration &%s", n);
                break;
            }
            else ent[i] = n; // set entity name
        }
        else if (! strncmp(s, "<!ATTLIST", 9)) { // parse default attributes
            t = s + strspn(s + 9, EZXML_WS) + 9; // skip whitespace separator
            if (! *t) { ezxml_err(root, t, "unclosed <!ATTLIST"); break; }
            if (*(s = t + strcspn(t, EZXML_WS ">")) == '>') continue;
            else *s = '\0'; // null terminate tag name
            for(i = 0; root->attr[i] && strcmp(n, root->attr[i][0]); i++);

            while (*(n = ++s + strspn(s, EZXML_WS)) && *n != '>') {
                if (*(s = n + strcspn(n, EZXML_WS))) *s = '\0'; // attr name
                else { ezxml_err(root, t, "malformed <!ATTLIST"); break; }

                s += strspn(s + 1, EZXML_WS) + 1; // find next token
                c = (strncmp(s, "CDATA", 5)) ? "*" : " "; // is it cdata?
                if (! strncmp(s, "NOTATION", 8))
                    s += strspn(s + 8, EZXML_WS) + 8;
                s = (*s == '(') ? strchr(s, ')') : s + strcspn(s, EZXML_WS);
                if (! s) { ezxml_err(root, t, "malformed <!ATTLIST"); break; }

                s += strspn(s, EZXML_WS ")"); // skip white space separator
                if (! strncmp(s, "#FIXED", 6))
                    s += strspn(s + 6, EZXML_WS) + 6;
                if (*s == '#') { // no default value
                    s += strcspn(s, EZXML_WS ">") - 1;
                    if (*c == ' ') continue; // cdata is default, nothing to do
                    v = NULL;
                }
                else if ((*s == '"' || *s == '\'')  &&  // default value
                         (s = strchr(v = s + 1, *s))) *s = '\0';
                else { ezxml_err(root, t, "malformed <!ATTLIST"); break; }

                if (! root->attr[i]) { // new tag name
                    root->attr = (! i) ? MALLOC(2 * sizeof(char **))
                                       : REALLOC(root->attr,
                                                 (i + 2) * sizeof(char **));
                    root->attr[i] = MALLOC(2 * sizeof(char *));
                    root->attr[i][0] = t; // set tag name
                    root->attr[i][1] = (char *)(root->attr[i + 1] = NULL);
                }

                for(j = 1; root->attr[i][j]; j += 3); // find end of list
                root->attr[i] = REALLOC(root->attr[i],
                                        (j + 4) * sizeof(char *));

                root->attr[i][j + 3] = NULL; // null terminate list
                root->attr[i][j + 2] = c; // is it cdata?
                root->attr[i][j + 1] = (v) ? ezxml_decode(v, root->ent, *c)
                                           : NULL;
                root->attr[i][j] = n; // attribute name 
            }
        }
        else if (! strncmp(s, "<!--", 4)) s = strstr(s + 4, "-->"); // comments
        else if (! strncmp(s, "<?", 2)) { // processing instructions
            if ((s = strstr(c = s + 2, "?>")))
                ezxml_proc_inst(root, c, s++ - c);
        }
        else if (*s == '<') s = strchr(s, '>'); // skip other declarations
        else if (*(s++) == '%' && ! root->standalone) break;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(sl = 2; sl < *len - 1; sl += 2) {
        c = (be) ? (((*s)[sl] & 0xFF) << 8) | ((*s)[sl + 1] & 0xFF)  //UTF-16BE
                 : (((*s)[sl + 1] & 0xFF) << 8) | ((*s)[sl] & 0xFF); //UTF-16LE
        if (c >= 0xD800 && c <= 0xDFFF && (sl += 2) < *len - 1) { // high-half
            d = (be) ? (((*s)[sl] & 0xFF) << 8) | ((*s)[sl + 1] & 0xFF)
                     : (((*s)[sl + 1] & 0xFF) << 8) | ((*s)[sl] & 0xFF);
            c = (((c & 0x3FF) << 10) | (d & 0x3FF)) + 0x10000;
        }

        while (l + 6 > max) u = REALLOC(u, max += EZXML_BUFSIZE);
        if (c < 0x80) u[l++] = (char)c; // US-ASCII subset
        else { // multi-byte UTF-8 sequence
            for(b = 0, d = c; d; d /= 2) b++; // bits in c
            b = (b - 2) / 5; // bytes in payload
            u[l++] = (char)(0xFF << (7 - b)) | (char)(c >> (6 * b)); // head
            while (b) u[l++] = 0x80 | ((c >> (6 * --b)) & 0x3F); // payload
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; m[i]; i++) {
        if (m[i] & EZXML_NAMEM) FREE(attr[i * 2]);
        if (m[i] & EZXML_TXTM) FREE(attr[(i * 2) + 1]);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(; ; ) {
        attr = (char **)EZXML_NIL;
        d = ++s;
        
        if (isalpha(*s) || *s == '_' || *s == ':' || *s < '\0') { // new tag
            if (! root->cur)
                return ezxml_err(root, d, "markup outside of root element");

            s += strcspn(s, EZXML_WS "/>");
            while (isspace(*s)) *(s++) = '\0'; // null terminate tag name
  
            if (*s && *s != '/' && *s != '>') // find tag in default attr list
                for(i = 0; (a = root->attr[i]) && strcmp(a[0], d); i++);

            for(l = 0; *s && *s != '/' && *s != '>'; l += 2) { // new attrib
                attr = (l) ? REALLOC(attr, (l + 4) * sizeof(char *))
                           : MALLOC(4 * sizeof(char *)); // allocate space
                attr[l + 3] = (l) ? REALLOC(attr[l + 1], (l / 2) + 2)
                                  : MALLOC(2); // mem for list of maloced vals
                strcpy(attr[l + 3] + (l / 2), " "); // value is not malloced
                attr[l + 2] = NULL; // null terminate list
                attr[l + 1] = ""; // temporary attribute value
                attr[l] = s; // set attribute name

                s += strcspn(s, EZXML_WS "=/>");
                if (*s == '=' || isspace(*s)) { 
                    *(s++) = '\0'; // null terminate tag attribute name
                    q = *(s += strspn(s, EZXML_WS "="));
                    if (q == '"' || q == '\'') { // attribute value
                        attr[l + 1] = ++s;
                        while (*s && *s != q) s++;
                        if (*s) *(s++) = '\0'; // null terminate attribute val
                        else {
                            ezxml_free_attr(attr);
                            return ezxml_err(root, d, "missing %c", q);
                        }

                        for(j = 1; a && a[j] && strcmp(a[j], attr[l]); j +=3);
                        attr[l + 1] = ezxml_decode(attr[l + 1], root->ent, (a
                                                   && a[j]) ? *a[j + 2] : ' ');
                        if (attr[l + 1] < d || attr[l + 1] > s)
                            attr[l + 3][l / 2] = EZXML_TXTM; // value malloced
                    }
                }
                while (isspace(*s)) s++;
            }

            if (*s == '/') { // self closing tag
                *(s++) = '\0';
                if ((*s && *s != '>') || (! *s && e != '>')) {
                    if (l) ezxml_free_attr(attr);
                    return ezxml_err(root, d, "missing >");
                }
                ezxml_open_tag(root, d, attr);
                ezxml_close_tag(root, d, s);
            }
            else if ((q = *s) == '>' || (! *s && e == '>')) { // open tag
                *s = '\0'; // temporarily null terminate tag name
                ezxml_open_tag(root, d, attr);
                *s = q;
            }
            else {
                if (l) ezxml_free_attr(attr);
                return ezxml_err(root, d, "missing >"); 
            }
        }
        else if (*s == '/') { // close tag
            s += strcspn(d = s + 1, EZXML_WS ">") + 1;
            if (! (q = *s) && e != '>') return ezxml_err(root, d, "missing >");
            *s = '\0'; // temporarily null terminate tag name
            if (ezxml_close_tag(root, d, s)) return &root->xml;
            if (isspace(*s = q)) s += strspn(s, EZXML_WS);
        }
        else if (! strncmp(s, "!--", 3)) { // xml comment
            if (! (s = strstr(s + 3, "--")) || (*(s += 2) != '>' && *s) ||
                (! *s && e != '>')) return ezxml_err(root, d, "unclosed <!--");
        }
        else if (! strncmp(s, "![CDATA[", 8)) { // cdata
            if ((s = strstr(s, "]]>")))
                ezxml_char_content(root, d + 8, (s += 2) - d - 10, 'c');
            else return ezxml_err(root, d, "unclosed <![CDATA[");
        }
        else if (! strncmp(s, "!DOCTYPE", 8)) { // dtd
            for(l = 0; *s && ((! l && *s != '>') || (l && (*s != ']' || 
                 *(s + strspn(s + 1, EZXML_WS) + 1) != '>')));
                 l = (*s == '[') ? 1 : l) s += strcspn(s + 1, "[]>") + 1;
            if (! *s && e != '>')
                return ezxml_err(root, d, "unclosed <!DOCTYPE");
            d = (l) ? strchr(d, '[') + 1 : d;
            if (l && ! ezxml_internal_dtd(root, d, s++ - d)) return &root->xml;
        }
        else if (*s == '?') { // <?...?> processing instructions
            do { s = strchr(s, '?'); } while (s && *(++s) && *s != '>');
            if (! s || (! *s && e != '>')) 
                return ezxml_err(root, d, "unclosed <?");
            else ezxml_proc_inst(root, d + 1, s - d - 2);
        }
        else return ezxml_err(root, d, "unexpected <");
        
        if (! s || ! *s) break;
        *s = '\0';
        d = ++s;
        if (*s && *s != '<') { // tag character content
            while (*s && *s != '<') s++;
            if (*s) ezxml_char_content(root, d, s - d, '&');
            else break;
        }
        else if (! *s) break;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(e = s + len; s != e; s++) {
        while (*dlen + 10 > *max) *dst = REALLOC(*dst, *max += EZXML_BUFSIZE);

        switch (*s) {
        case '\0': return *dst;
        case '&': *dlen += sprintf(*dst + *dlen, "&amp;"); break;
        case '<': *dlen += sprintf(*dst + *dlen, "&lt;"); break;
        case '>': *dlen += sprintf(*dst + *dlen, "&gt;"); break;
        case '"': *dlen += sprintf(*dst + *dlen, (a) ? "&quot;" : "\""); break;
        case '\n': *dlen += sprintf(*dst + *dlen, (a) ? "&#xA;" : "\n"); break;
        case '\t': *dlen += sprintf(*dst + *dlen, (a) ? "&#x9;" : "\t"); break;
        case '\r': *dlen += sprintf(*dst + *dlen, "&#xD;"); break;
        default: (*dst)[(*dlen)++] = *s;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; xml->attr[i]; i += 2) { // tag attributes
        if (ezxml_attr(xml, xml->attr[i]) != xml->attr[i + 1]) continue;
        while (*len + strlen(xml->attr[i]) + 7 > *max) // reallocate s
            *s = REALLOC(*s, *max += EZXML_BUFSIZE);

        *len += sprintf(*s + *len, " %s=\"", xml->attr[i]);
        ezxml_ampencode(xml->attr[i + 1], (size_t)(-1), s, len, max, 1);
        *len += sprintf(*s + *len, "\"");
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; attr[i] && strcmp(attr[i][0], xml->name); i++);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 1; attr[i] && attr[i][j]; j += 3) { // default attributes
        if (! attr[i][j + 1] || ezxml_attr(xml, attr[i][j]) != attr[i][j + 1])
            continue; // skip duplicates and non-values
        while (*len + strlen(attr[i][j]) + 7 > *max) // reallocate s
            *s = REALLOC(*s, *max += EZXML_BUFSIZE);

        *len += sprintf(*s + *len, " %s=\"", attr[i][j]);
        ezxml_ampencode(attr[i][j + 1], (size_t)(-1), s, len, max, 1);
        *len += sprintf(*s + *len, "\"");
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; ! p && root->pi[i]; i++) { // pre-root processing instructions
        for(k = 2; root->pi[i][k - 1]; k++);
        for(j = 1; (n = root->pi[i][j]); j++) {
            if (root->pi[i][k][j - 1] == '>') continue; // not pre-root
            while (len + strlen(t = root->pi[i][0]) + strlen(n) + 7 > max)
                s = REALLOC(s, max += EZXML_BUFSIZE);
            len += sprintf(s + len, "<?%s%s%s?>\n", t, *n ? " " : "", n);
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; ! p && root->pi[i]; i++) { // post-root processing instructions
        for(k = 2; root->pi[i][k - 1]; k++);
        for(j = 1; (n = root->pi[i][j]); j++) {
            if (root->pi[i][k][j - 1] == '<') continue; // not post-root
            while (len + strlen(t = root->pi[i][0]) + strlen(n) + 7 > max)
                s = REALLOC(s, max += EZXML_BUFSIZE);
            len += sprintf(s + len, "\n<?%s%s%s?>", t, *n ? " " : "", n);
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 10; root->ent[i]; i += 2) // 0 - 9 are default entites (<>&"')
            if ((s = root->ent[i + 1]) < root->s || s > root->e) free(s);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; (a = root->attr[i]); i++) {
            for(j = 1; a[j++]; j += 2) // free malloced attribute values
                if (a[j] && (a[j] < root->s || a[j] > root->e)) FREE(a[j]);
            FREE(a);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; root->pi[i]; i++) {
            for(j = 1; root->pi[i][j]; j++);
            FREE(root->pi[i][j + 1]);
            FREE(root->pi[i]);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(cur = head; cur->ordered && cur->ordered->off <= off;
                 cur = cur->ordered);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(cur = head, prev = NULL; cur && strcmp(cur->name, xml->name);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(cur = head, prev = NULL; cur && cur->off <= off;
                 prev = cur, cur = cur->sibling); // new sibling insert point



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(c = l; xml->attr[c]; c += 2); // find end of attribute list



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(terminal = ezxml_child(*parent, "terminal"); terminal; terminal = terminal->next) {
    if (strcmp(ezxml_child(terminal, "id")->txt, idx)==0) {
      i_value=ezxml_child(terminal, "initial_value");
      ezxml_set_attr(i_value,"value", w);
      return 1; 
    }
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(structx = ezxml_child(*parent, "struct"); structx; structx = structx->next) {
    for(subnode = ezxml_child(structx, "subnodes"); subnode; subnode = subnode->next) {
      result=write_in_child(&subnode, idx, w);
      if (result==1 ) return result;
    }
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(terminal = ezxml_child(*parent, "terminal"); terminal; terminal = terminal->next) {
    if (strcmp(ezxml_child(terminal, "id")->txt, idx)==0) {
      i_value=ezxml_child(terminal, "initial_value");
      teamname = ezxml_attr(i_value, "value");
      strcpy (value, teamname);
      return 1; 
    }
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(structx = ezxml_child(*parent, "struct"); structx; structx = structx->next) {
    for(subnode = ezxml_child(structx, "subnodes"); subnode; subnode = subnode->next) {
      result=search_in_child(&subnode, idx, value);
      if (result==1 ) return result;
    }
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<m*n;j++) ptr_d[j] = x_d[j];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<2*m*n;j++) ptr_d[j] = x_d[j];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<m*n;j++)
		{
			ptr_i = (SCSINT_COP *) istk(il+4);
			ptr_i[j] = x_i[j];
		}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<m*n;j++)
		{
			ptr_c = (SCSINT8_COP *) istk(il+4);
			ptr_c[j] = x_c[j];
		}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<m*n;j++)
		{
			ptr_s = (SCSINT16_COP *) istk(il+4);
			ptr_s[j] = x_s[j];
		}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<m*n;j++)
		{
			ptr_l = (SCSINT32_COP *) istk(il+4);
			ptr_l[j] = x_l[j];
		}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<m*n;j++)
		{
			ptr_ui = (SCSUINT_COP *) istk(il+4);
			ptr_ui[j] = x_ui[j];
		}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<m*n;j++)
		{
			ptr_uc = (SCSUINT8_COP *) istk(il+4);
			ptr_uc[j] = x_uc[j];
		}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<m*n;j++)
		{
			ptr_us = (SCSUINT16_COP *) istk(il+4);
			ptr_us[j] = x_us[j];
		}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<m*n;j++)
		{
			ptr_ul = (SCSUINT32_COP *) istk(il+4);
			ptr_ul[j] = x_ul[j];
		}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<m*n;j++)
		{
			ptr_d = (double *) stk(il+4);
			ptr_d[j] = x_d[j];
		}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i <nb; i++)
    {
      vect[i]=-vect[i];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 1; (j <= nb+2) && (! fini); j++) 
    {
      fini = 1;
      for(i = 0; i < nb; i++) 
        {
          if (vect[i] == j-1 ) 
            {
              if (j == nb + 2) 
                {
                  *ok = 0;
                  *nord=0;
                  return 0;
                }
              if (outoinptr[i+ 1] - outoinptr[i] != 0) 
                {                 
                  for(k = outoinptr[i]; k <= outoinptr[i + 1] - 1; k++) 
		    {
		      ii = outoin[k-1];		      
		      if (vect[ii-1] > -1 && depu[depuptr[ii-1]-2+outoin[outoinptr[nb]+k-2]] == 1) 
			{
			  fini = 0;
			  vect[ii-1] = j;
			}			
                    }
		}
	    }
	}
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(m=0 ; m < nb; m++)
    {
      if (vect[m] < 1){
	if (m == 0) {
	  *nord=nb;
	  return 0;
	} else {
	  *nord=nb-m;
	  for(i=0; i<*nord;i++)
	    ord[i]=ord[i+nb-*nord];
	  return 0;      
	}
      }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i= 0; i < nb; i++)
    {
      if ((vec[i] == 0) && (typl[i] == 1)) vec[i]=1; 
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 1; (j <= nb+2) &&(! fini); j++) 
    {
      fini = 1;
      if (j == nb + 2) 
	{
	  *ok = 0;
	  *nord = 0;
	  return 0;
	}
      
      for(i = 0; i < nb; i++) 
	{
          if (vec[i] > -1 && typl[i] != -1) 
            {
	      if (typl[i] == 1) 
                {
                  nkk = boptr[i + 1] - boptr[i];
                  if (nkk != 0) 
                    {
                      for(m = 0; m < nkk; m++) 
                        {
                          kk = bexe[m + boptr[i] - 1];
			  if (typl[kk-1] == 1) 
			    {
			      if (vec[kk-1] < vec[i]+2)
				{
				  fini=0;
				  vec[kk-1]=vec[i]+2;
				}
			    }
			  else
			    {
			      if (vec[kk-1] < vec[i]+1)
				{
				  fini=0;
				  vec[kk-1]=vec[i]+1;
				} 
			    }
			}
		    }
                } 
              else 
                {
                  nkk = blptr[i+1]-blptr[i];
                  if (nkk != 0) 
                    {
                      for(m = 0; m < nkk; m++) 
                        {
                          kk = blnk[m+blptr[i]-1];
			  if (vec[kk-1] > -1 && (depu[depuptr[kk-1]-2+blnk[blptr[nb]+blptr[i]-2]] == 1 || typl[kk-1] == 1)) 
                            {
			      if (vec[kk-1] < vec[i])
				{
				  fini=0;
				  vec[kk-1]=vec[i];
				}
			    }
                        }
                    }
                }
	    }
          
	}
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(m=0 ; m < nb; m++)
    {
      if (vec[m] < 1){
	if (m == 0) {
	  *nord=nb;
	  return 0;
	} else {
	  *nord=nb-m;
	  for(i=0; i<*nord;i++)
	    ord[i]=ord[i+nb-*nord];
	  return 0;      
	}
      }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 1 ; (j < nb) &&  (! fini); j++){
    fini=1;
    for(i=0;i<nb;i++){
      if (vec[i] > -1){
	if (outoinptr[i+1]-outoinptr[i] !=0){
	  for(k=outoinptr[i];k<outoinptr[i+1];k++){                 
	    ii=outoin[k-1];
	    if(typ_r[ii-1] == 1){
	      nprt=outoin[k+outoinptr[nb]-2];
	      if (nd[nprt+(ii-1)*nnd] == 0){		
		r1[*nr]=ii;
		r2[*nr]=nprt;
		fini=0;
		vec[ii-1]=0;
		nd[nprt+(ii-1)*nnd]=1;
		nr[0]++;
	      }
	    } 
	  } 
	} 
      } 
    } 
    if (fini ==1) return 0;
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k=0;k<Blocks[0].noz;k++)
	{
		nu=Blocks[0].ozsz[k]; 
		mu=Blocks[0].ozsz[Blocks[0].noz+k]; 
		oz_typ=Blocks[0].oztyp[k]; 
		*ierr=var2sci(Blocks[0].ozptr[k],nu,mu,oz_typ);
		if (*ierr!=0) return 0;
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k=0;k<Blocks[0].nin;k++) 
	{
		nu=Blocks[0].insz[k]; 
		mu=Blocks[0].insz[Blocks[0].nin+k]; 
		u_typ=Blocks[0].insz[2*Blocks[0].nin+k]; 
		*ierr=var2sci(Blocks[0].inptr[k],nu,mu,u_typ);
		if (*ierr!=0) return 0;
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k=0;k<Blocks[0].nout;k++) 
	{
		ny=Blocks[0].outsz[k]; 
		my=Blocks[0].outsz[Blocks[0].nout+k]; 
		y_typ=Blocks[0].outsz[2*Blocks[0].nout+k]; 
		*ierr=var2sci(Blocks[0].outptr[k],ny,my,y_typ);
		if (*ierr!=0) return 0;
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k=0;k<Blocks[0].nopar;k++)
	{
		nu=Blocks[0].oparsz[k]; 
		mu=Blocks[0].oparsz[Blocks[0].nopar+k]; 
		opar_typ=Blocks[0].opartyp[k]; 
		*ierr=var2sci(Blocks[0].oparptr[k],nu,mu,opar_typ);
		if (*ierr!=0) return 0;
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<Block->nz;j++) 
		{
			Block->z[j]=*((double *)(&ilh[4]) + j);
		}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<2*Block->noz;j++) 
	{
		Block->ozsz[j]=(int) *((double *)(&ilh[4]) + j);
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<Block->noz;j++) 
	{
		Block->oztyp[j]=(int) *((double *)(&ilh[4]) + j);
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<Block->noz;i++) 
		{
			ilh2 = (int *) (listentry(ilh,i+1));
			mh2  = ilh2[1];
			nh2  = ilh2[2];
			Block->ozptr[i] = NULL;
			switch(Block->oztyp[i])
			{
			case 10  : if ((Block->ozptr[i]=(double *) MALLOC(mh2*nh2*sizeof(double)))==NULL) 
					   {
						FREE(Block->z);
						FREE(Block->ozsz);
						FREE(Block->oztyp);
						for(j=0;j<i;j++) FREE(Block->ozptr[j]);
						*ierr = -39;
						return 0;
					   }
					   memcpy((double *)Block->ozptr[i], \
						   (double *)(&ilh2[4]), \
						   mh2*nh2*sizeof(double));
					   break;

			case 11  : if ((Block->ozptr[i]=(double *) MALLOC(2*mh2*nh2*sizeof(double)))==NULL) 
					   {
						FREE(Block->z);
						FREE(Block->ozsz);
						FREE(Block->oztyp);
						for(j=0;j<i;j++) FREE(Block->ozptr[j]);
						*ierr = -39;
						return 0;
					   }
					   memcpy((double *)Block->ozptr[i], \
						   (double *)(&ilh2[4]), \
						   2*mh2*nh2*sizeof(double));
					   break;

			case 84  : if ((Block->ozptr[i]=(long *) MALLOC(mh2*nh2*sizeof(long)))==NULL) 
					   {
						FREE(Block->z);
						FREE(Block->ozsz);
						FREE(Block->oztyp);
						for(j=0;j<i;j++) FREE(Block->ozptr[j]);
						*ierr = -39;
						return 0;
					   }
					   memcpy((long *)Block->ozptr[i], \
						   (long *)(&ilh2[4]), \
						   mh2*nh2*sizeof(long));
					   break;

			case 82  : if ((Block->ozptr[i]=(short *) MALLOC(mh2*nh2*sizeof(short)))==NULL) 
					   {
						FREE(Block->z);
						FREE(Block->ozsz);
						FREE(Block->oztyp);
						for(j=0;j<i;j++) FREE(Block->ozptr[j]);
						*ierr = -39;
						return 0;
					   }
					   memcpy((short *)Block->ozptr[i], \
						   (short *)(&ilh2[4]), \
						   mh2*nh2*sizeof(short));
					   break;

			case 81  : if ((Block->ozptr[i]=(char *) MALLOC(mh2*nh2*sizeof(char)))==NULL) 
					   {
						FREE(Block->z);
						FREE(Block->ozsz);
						FREE(Block->oztyp);
						for(j=0;j<i;j++) FREE(Block->ozptr[j]);
						*ierr = -39;
						return 0;
					   }
					   memcpy((char *)Block->ozptr[i], \
						   (char *)(&ilh2[4]), \
						   mh2*nh2*sizeof(char));
					   break;

			case 814 : if ((Block->ozptr[i]=(unsigned long *) MALLOC(mh2*nh2*sizeof(unsigned long)))==NULL) 
					   {
						FREE(Block->z);
						FREE(Block->ozsz);
						FREE(Block->oztyp);
						for(j=0;j<i;j++) FREE(Block->ozptr[j]);
						*ierr = -39;
						return 0;
					   }
					   memcpy((unsigned long *)Block->ozptr[i], \
						   (unsigned long *)(&ilh2[4]), \
						   mh2*nh2*sizeof(unsigned long));
					   break;

			case 812 : if ((Block->ozptr[i]=(unsigned short *) MALLOC(mh2*nh2*sizeof(unsigned short)))==NULL) 
					   {
						FREE(Block->z);
						FREE(Block->ozsz);
						FREE(Block->oztyp);
						for(j=0;j<i;j++) FREE(Block->ozptr[j]);
						*ierr = -39;
						return 0;
					   }
					   memcpy((unsigned short *)Block->ozptr[i], \
						   (unsigned short *)(&ilh2[4]), \
						   mh2*nh2*sizeof(unsigned short));
					   break;

			case 811 : if ((Block->ozptr[i]=(unsigned char *) MALLOC(mh2*nh2*sizeof(unsigned char)))==NULL) 
					   {
						FREE(Block->z);
						FREE(Block->ozsz);
						FREE(Block->oztyp);
						for(j=0;j<i;j++) FREE(Block->ozptr[j]);
						*ierr = -39;
						return 0;
					   }
					   memcpy((unsigned char *)Block->ozptr[i], \
						   (unsigned char *)(&ilh2[4]), \
						   mh2*nh2*sizeof(unsigned char));
					   break;
			}
		}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<Block->noz;j++) FREE(Block->ozptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<Block->noz;j++) FREE(Block->ozptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<Block->noz;j++) FREE(Block->ozptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<(mh*nh);j++) 
	{
		Block->x[j]=*((double *)(&ilh[4]) + j);
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<Block->noz;j++) FREE(Block->ozptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<Block->noz;j++) FREE(Block->ozptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<(mh*nh);j++) 
	{
		Block->xd[j]=*((double *)(&ilh[4]) + j);
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<Block->noz;j++) FREE(Block->ozptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<Block->noz;j++) FREE(Block->ozptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<(mh*nh);j++) 
	{
		Block->res[j]=*((double *)(&ilh[4]) + j);
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<Block->noz;j++) FREE(Block->ozptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<Block->noz;j++) FREE(Block->ozptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<Block->noz;j++) FREE(Block->ozptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<3*Block->nin;j++) 
	{
		Block->insz[j]=(int) *((double *)(&ilh[4]) + j);
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<Block->noz;j++) FREE(Block->ozptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<Block->noz;j++) FREE(Block->ozptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<Block->nin;i++) 
		{
			ilh2 = (int *) (listentry(ilh,i+1));
			mh2  = ilh2[1];
			nh2  = ilh2[2];
			Block->inptr[i] = NULL;
			switch(Block->insz[2*Block->nin+i])
			{
			case 10  : if ((Block->inptr[i]=(double *) MALLOC(mh2*nh2*sizeof(double)))==NULL) 
					   {
						FREE(Block->z);
						FREE(Block->ozsz);
						FREE(Block->oztyp);
						for(j=0;j<Block->noz;j++) FREE(Block->ozptr[j]);
						FREE(Block->ozptr);
						FREE(Block->x);
						FREE(Block->xd);
						FREE(Block->res);
						FREE(Block->insz);
						for(j=0;j<i;j++) FREE(Block->inptr[j]);
						*ierr = -39;
						return 0;
					   }
					   memcpy((double *)Block->inptr[i], \
						   (double *)(&ilh2[4]), \
						   mh2*nh2*sizeof(double));
					   break;

			case 11  : if ((Block->inptr[i]=(double *) MALLOC(2*mh2*nh2*sizeof(double)))==NULL) 
					   {
						FREE(Block->z);
						FREE(Block->ozsz);
						FREE(Block->oztyp);
						for(j=0;j<Block->noz;j++) FREE(Block->ozptr[j]);
						FREE(Block->ozptr);
						FREE(Block->x);
						FREE(Block->xd);
						FREE(Block->res);
						FREE(Block->insz);
						for(j=0;j<i;j++) FREE(Block->inptr[j]);
						*ierr = -39;
						return 0;
					   }
					   memcpy((double *)Block->inptr[i], \
						   (double *)(&ilh2[4]), \
						   2*mh2*nh2*sizeof(double));
					   break;

			case 84  : if ((Block->inptr[i]=(long *) MALLOC(mh2*nh2*sizeof(long)))==NULL) 
					   {
						FREE(Block->z);
						FREE(Block->ozsz);
						FREE(Block->oztyp);
						for(j=0;j<Block->noz;j++) FREE(Block->ozptr[j]);
						FREE(Block->ozptr);
						FREE(Block->x);
						FREE(Block->xd);
						FREE(Block->res);
						FREE(Block->insz);
						for(j=0;j<i;j++) FREE(Block->inptr[j]);
						*ierr = -39;
						return 0;
					   }
					   memcpy((long *)Block->inptr[i], \
						   (long *)(&ilh2[4]), \
						   mh2*nh2*sizeof(long));
					   break;

			case 82  : if ((Block->inptr[i]=(short *) MALLOC(mh2*nh2*sizeof(short)))==NULL) 
					   {
						FREE(Block->z);
						FREE(Block->ozsz);
						FREE(Block->oztyp);
						for(j=0;j<Block->noz;j++) FREE(Block->ozptr[j]);
						FREE(Block->ozptr);
						FREE(Block->x);
						FREE(Block->xd);
						FREE(Block->res);
						FREE(Block->insz);
						for(j=0;j<i;j++) FREE(Block->inptr[j]);
						*ierr = -39;
						return 0;
					   }
					   memcpy((short *)Block->inptr[i], \
						   (short *)(&ilh2[4]), \
						   mh2*nh2*sizeof(short));
					   break;

			case 81  : if ((Block->inptr[i]=(char *) MALLOC(mh2*nh2*sizeof(char)))==NULL)
					   {
						FREE(Block->z);
						FREE(Block->ozsz);
						FREE(Block->oztyp);
						for(j=0;j<Block->noz;j++) FREE(Block->ozptr[j]);
						FREE(Block->ozptr);
						FREE(Block->x);
						FREE(Block->xd);
						FREE(Block->res);
						FREE(Block->insz);
						for(j=0;j<i;j++) FREE(Block->inptr[j]);
						*ierr = -39;
						return 0;
					   }
					   memcpy((char *)Block->inptr[i], \
						   (char *)(&ilh2[4]), \
						   mh2*nh2*sizeof(char));
					   break;

			case 814 : if ((Block->inptr[i]=(unsigned long *) MALLOC(mh2*nh2*sizeof(unsigned long)))==NULL) 
					   {
						FREE(Block->z);
						FREE(Block->ozsz);
						FREE(Block->oztyp);
						for(j=0;j<Block->noz;j++) FREE(Block->ozptr[j]);
						FREE(Block->ozptr);
						FREE(Block->x);
						FREE(Block->xd);
						FREE(Block->res);
						FREE(Block->insz);
						for(j=0;j<i;j++) FREE(Block->inptr[j]);
						*ierr = -39;
						return 0;
					   }
					   memcpy((unsigned long *)Block->inptr[i], \
						   (unsigned long *)(&ilh2[4]), \
						   mh2*nh2*sizeof(unsigned long));
					   break;

			case 812 : if ((Block->inptr[i]=(unsigned short *) MALLOC(mh2*nh2*sizeof(unsigned short)))==NULL) 
					   {
						FREE(Block->z);
						FREE(Block->ozsz);
						FREE(Block->oztyp);
						for(j=0;j<Block->noz;j++) FREE(Block->ozptr[j]);
						FREE(Block->ozptr);
						FREE(Block->x);
						FREE(Block->xd);
						FREE(Block->res);
						FREE(Block->insz);
						for(j=0;j<i;j++) FREE(Block->inptr[j]);
						*ierr = -39;
						return 0;
					   }
					   memcpy((unsigned short *)Block->inptr[i], \
						   (unsigned short *)(&ilh2[4]), \
						   mh2*nh2*sizeof(unsigned short));
					   break;

			case 811 : if ((Block->inptr[i]=(unsigned char *) MALLOC(mh2*nh2*sizeof(unsigned char)))==NULL) 
					   {
						FREE(Block->z);
						FREE(Block->ozsz);
						FREE(Block->oztyp);
						for(j=0;j<Block->noz;j++) FREE(Block->ozptr[j]);
						FREE(Block->ozptr);
						FREE(Block->x);
						FREE(Block->xd);
						FREE(Block->res);
						FREE(Block->insz);
						for(j=0;j<i;j++) FREE(Block->inptr[j]);
						*ierr = -39;
						return 0;
					   }
					   memcpy((unsigned char *)Block->inptr[i], \
						   (unsigned char *)(&ilh2[4]), \
						   mh2*nh2*sizeof(unsigned char));
					   break;
			}
		}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<Block->noz;j++) FREE(Block->ozptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<Block->nin;j++) FREE(Block->inptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<Block->noz;j++) FREE(Block->ozptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<Block->nin;j++) FREE(Block->inptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<Block->noz;j++) FREE(Block->ozptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<Block->nin;j++) FREE(Block->inptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<3*Block->nout;j++) 
	{
		Block->outsz[j]=(int) *((double *)(&ilh[4]) + j);
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<Block->noz;j++) FREE(Block->ozptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<Block->nin;j++) FREE(Block->inptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<Block->noz;j++) FREE(Block->ozptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<Block->nin;j++) FREE(Block->inptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<Block->nout;i++) 
		{
			ilh2 = (int *) (listentry(ilh,i+1));
			mh2  = ilh2[1];
			nh2  = ilh2[2];
			Block->outptr[i] = NULL;
			switch(Block->outsz[2*Block->nout+i])
			{
			case 10  : if ((Block->outptr[i]=(double *) MALLOC(mh2*nh2*sizeof(double)))==NULL) 
					   {
						FREE(Block->z);
						FREE(Block->ozsz);
						FREE(Block->oztyp);
						for(j=0;j<Block->noz;j++) FREE(Block->ozptr[j]);
						FREE(Block->ozptr);
						FREE(Block->x);
						FREE(Block->xd);
						FREE(Block->res);
						FREE(Block->insz);
						for(j=0;j<Block->nin;j++) FREE(Block->inptr[j]);
						FREE(Block->inptr);
						FREE(Block->outsz);
						for(j=0;j<i;j++) FREE(Block->outptr[j]);
						*ierr = -39;
						return 0;
					   }
					   memcpy((double *)Block->outptr[i], \
						   (double *)(&ilh2[4]), \
						   mh2*nh2*sizeof(double));
					   break;

			case 11  : if ((Block->outptr[i]=(double *) MALLOC(2*mh2*nh2*sizeof(double)))==NULL) 
					   {
						FREE(Block->z);
						FREE(Block->ozsz);
						FREE(Block->oztyp);
						for(j=0;j<Block->noz;j++) FREE(Block->ozptr[j]);
						FREE(Block->ozptr);
						FREE(Block->x);
						FREE(Block->xd);
						FREE(Block->res);
						FREE(Block->insz);
						for(j=0;j<Block->nin;j++) FREE(Block->inptr[j]);
						FREE(Block->inptr);
						FREE(Block->outsz);
						for(j=0;j<i;j++) FREE(Block->outptr[j]);
						*ierr = -39;
						return 0;
					   }
					   memcpy((double *)Block->outptr[i], \
						   (double *)(&ilh2[4]), \
						   2*mh2*nh2*sizeof(double));
					   break;

			case 84  : if ((Block->outptr[i]=(long *) MALLOC(mh2*nh2*sizeof(long)))==NULL) 
					   {
						FREE(Block->z);
						FREE(Block->ozsz);
						FREE(Block->oztyp);
						for(j=0;j<Block->noz;j++) FREE(Block->ozptr[j]);
						FREE(Block->ozptr);
						FREE(Block->x);
						FREE(Block->xd);
						FREE(Block->res);
						FREE(Block->insz);
						for(j=0;j<Block->nin;j++) FREE(Block->inptr[j]);
						FREE(Block->inptr);
						FREE(Block->outsz);
						for(j=0;j<i;j++) FREE(Block->outptr[j]);
						*ierr = -39;
						return 0;
					   }
					   memcpy((long *)Block->outptr[i], \
						   (long *)(&ilh2[4]), \
						   mh2*nh2*sizeof(long));
					   break;

			case 82  : if ((Block->outptr[i]=(short *) MALLOC(mh2*nh2*sizeof(short)))==NULL) 
					   {
						FREE(Block->z);
						FREE(Block->ozsz);
						FREE(Block->oztyp);
						for(j=0;j<Block->noz;j++) FREE(Block->ozptr[j]);
						FREE(Block->ozptr);
						FREE(Block->x);
						FREE(Block->xd);
						FREE(Block->res);
						FREE(Block->insz);
						for(j=0;j<Block->nin;j++) FREE(Block->inptr[j]);
						FREE(Block->inptr);
						FREE(Block->outsz);
						for(j=0;j<i;j++) FREE(Block->outptr[j]);
						*ierr = -39;
						return 0;
					   }
					   memcpy((short *)Block->outptr[i], \
						   (short *)(&ilh2[4]), \
						   mh2*nh2*sizeof(short));
					   break;

			case 81  : if ((Block->outptr[i]=(char *) MALLOC(mh2*nh2*sizeof(char)))==NULL) 
					   {
						FREE(Block->z);
						FREE(Block->ozsz);
						FREE(Block->oztyp);
						for(j=0;j<Block->noz;j++) FREE(Block->ozptr[j]);
						FREE(Block->ozptr);
						FREE(Block->x);
						FREE(Block->xd);
						FREE(Block->res);
						FREE(Block->insz);
						for(j=0;j<Block->nin;j++) FREE(Block->inptr[j]);
						FREE(Block->inptr);
						FREE(Block->outsz);
						for(j=0;j<i;j++) FREE(Block->outptr[j]);
						*ierr = -39;
						return 0;
					   }
					   memcpy((char *)Block->outptr[i], \
						   (char *)(&ilh2[4]), \
						   mh2*nh2*sizeof(char));
					   break;

			case 814 : if ((Block->outptr[i]=(unsigned long *) MALLOC(mh2*nh2*sizeof(unsigned long)))==NULL) 
					   {
						FREE(Block->z);
						FREE(Block->ozsz);
						FREE(Block->oztyp);
						for(j=0;j<Block->noz;j++) FREE(Block->ozptr[j]);
						FREE(Block->ozptr);
						FREE(Block->x);
						FREE(Block->xd);
						FREE(Block->res);
						FREE(Block->insz);
						for(j=0;j<Block->nin;j++) FREE(Block->inptr[j]);
						FREE(Block->inptr);
						FREE(Block->outsz);
						for(j=0;j<i;j++) FREE(Block->outptr[j]);
						*ierr = -39;
						return 0;
					   }
					   memcpy((unsigned long *)Block->outptr[i], \
						   (unsigned long *)(&ilh2[4]), \
						   mh2*nh2*sizeof(unsigned long));
					   break;

			case 812 : if ((Block->outptr[i]=(unsigned short *) MALLOC(mh2*nh2*sizeof(unsigned short)))==NULL) 
					   {
						FREE(Block->z);
						FREE(Block->ozsz);
						FREE(Block->oztyp);
						for(j=0;j<Block->noz;j++) FREE(Block->ozptr[j]);
						FREE(Block->ozptr);
						FREE(Block->x);
						FREE(Block->xd);
						FREE(Block->res);
						FREE(Block->insz);
						for(j=0;j<Block->nin;j++) FREE(Block->inptr[j]);
						FREE(Block->inptr);
						FREE(Block->outsz);
						for(j=0;j<i;j++) FREE(Block->outptr[j]);
						*ierr = -39;
						return 0;
					   }
					   memcpy((unsigned short *)Block->outptr[i], \
						   (unsigned short *)(&ilh2[4]), \
						   mh2*nh2*sizeof(unsigned short));
					   break;

			case 811 : if ((Block->outptr[i]=(unsigned char *) MALLOC(mh2*nh2*sizeof(unsigned char)))==NULL) 
					   {
						FREE(Block->z);
						FREE(Block->ozsz);
						FREE(Block->oztyp);
						for(j=0;j<Block->noz;j++) FREE(Block->ozptr[j]);
						FREE(Block->ozptr);
						FREE(Block->x);
						FREE(Block->xd);
						FREE(Block->res);
						FREE(Block->insz);
						for(j=0;j<Block->nin;j++) FREE(Block->inptr[j]);
						FREE(Block->inptr);
						FREE(Block->outsz);
						for(j=0;j<i;j++) FREE(Block->outptr[j]);
						*ierr = -39;
						return 0;
					   }
					   memcpy((unsigned char *)Block->outptr[i], \
						   (unsigned char *)(&ilh2[4]), \
						   mh2*nh2*sizeof(unsigned char));
					   break;
			}
		}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<Block->noz;j++) FREE(Block->ozptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<Block->nin;j++) FREE(Block->inptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<Block->nout;j++) FREE(Block->outptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<Block->noz;j++) FREE(Block->ozptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<Block->nin;j++) FREE(Block->inptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<Block->nout;j++) FREE(Block->outptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<Block->noz;j++) FREE(Block->ozptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<Block->nin;j++) FREE(Block->inptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<Block->nout;j++) FREE(Block->outptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<(mh*nh);j++) 
	{
		Block->evout[j]=*((double *)(&ilh[4]) + j);
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<Block->noz;j++) FREE(Block->ozptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<Block->nin;j++) FREE(Block->inptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<Block->nout;j++) FREE(Block->outptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<Block->noz;j++) FREE(Block->ozptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<Block->nin;j++) FREE(Block->inptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<Block->nout;j++) FREE(Block->outptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<Block->noz;j++) FREE(Block->ozptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<Block->nin;j++) FREE(Block->inptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<Block->nout;j++) FREE(Block->outptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < (mh*nh);j++) 
	{
		Block->rpar[j] = *((double *)(&ilh[4]) + j);
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<Block->noz;j++) FREE(Block->ozptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<Block->nin;j++) FREE(Block->inptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<Block->nout;j++) FREE(Block->outptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<Block->noz;j++) FREE(Block->ozptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<Block->nin;j++) FREE(Block->inptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<Block->nout;j++) FREE(Block->outptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<Block->noz;j++) FREE(Block->ozptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<Block->nin;j++) FREE(Block->inptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<Block->nout;j++) FREE(Block->outptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<(mh*nh);j++) 
	{
		Block->ipar[j]=(int) *((double *)(&ilh[4]) + j);
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<Block->noz;j++) FREE(Block->ozptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<Block->nin;j++) FREE(Block->inptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<Block->nout;j++) FREE(Block->outptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<Block->noz;j++) FREE(Block->ozptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<Block->nin;j++) FREE(Block->inptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<Block->nout;j++) FREE(Block->outptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<Block->noz;j++) FREE(Block->ozptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<Block->nin;j++) FREE(Block->inptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<Block->nout;j++) FREE(Block->outptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<2*Block->nopar;j++) 
	{
		Block->oparsz[j]=(int) *((double *)(&ilh[4]) + j);
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<Block->noz;j++) FREE(Block->ozptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<Block->nin;j++) FREE(Block->inptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<Block->nout;j++) FREE(Block->outptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<Block->noz;j++) FREE(Block->ozptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<Block->nin;j++) FREE(Block->inptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<Block->nout;j++) FREE(Block->outptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<Block->nopar;j++) 
	{
		Block->opartyp[j]=(int) *((double *)(&ilh[4]) + j);
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<Block->noz;j++) FREE(Block->ozptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<Block->nin;j++) FREE(Block->inptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<Block->nout;j++) FREE(Block->outptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<Block->noz;j++) FREE(Block->ozptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<Block->nin;j++) FREE(Block->inptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<Block->nout;j++) FREE(Block->outptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<Block->nopar;i++) 
		{
			ilh2 = (int *) (listentry(ilh,i+1));
			mh2  = ilh2[1];
			nh2  = ilh2[2];
			Block->oparptr[i] = NULL;
			switch(Block->opartyp[i])
			{
			case 10  : if ((Block->oparptr[i]=(double *) MALLOC(mh2*nh2*sizeof(double)))==NULL) 
					   {
						FREE(Block->z);
						FREE(Block->ozsz);
						FREE(Block->oztyp);
						for(j=0;j<Block->noz;j++) FREE(Block->ozptr[j]);
						FREE(Block->ozptr);
						FREE(Block->x);
						FREE(Block->xd);
						FREE(Block->res);
						FREE(Block->insz);
						for(j=0;j<Block->nin;j++) FREE(Block->inptr[j]);
						FREE(Block->inptr);
						FREE(Block->outsz);
						for(j=0;j<Block->nout;j++) FREE(Block->outptr[j]);
						FREE(Block->outptr);
						FREE(Block->evout);
						FREE(Block->rpar);
						FREE(Block->ipar);
						FREE(Block->oparsz);
						FREE(Block->opartyp);
						for(j=0;j<i;j++) FREE(Block->oparptr[j]);
						*ierr = -39;
						return 0;
					   }
					   memcpy((double *)Block->oparptr[i], \
						   (double *)(&ilh2[4]), \
						   mh2*nh2*sizeof(double));
					   break;

			case 11  : if ((Block->oparptr[i]=(double *) MALLOC(2*mh2*nh2*sizeof(double)))==NULL) 
					   {
						FREE(Block->z);
						FREE(Block->ozsz);
						FREE(Block->oztyp);
						for(j=0;j<Block->noz;j++) FREE(Block->ozptr[j]);
						FREE(Block->ozptr);
						FREE(Block->x);
						FREE(Block->xd);
						FREE(Block->res);
						FREE(Block->insz);
						for(j=0;j<Block->nin;j++) FREE(Block->inptr[j]);
						FREE(Block->inptr);
						FREE(Block->outsz);
						for(j=0;j<Block->nout;j++) FREE(Block->outptr[j]);
						FREE(Block->outptr);
						FREE(Block->evout);
						FREE(Block->rpar);
						FREE(Block->ipar);
						FREE(Block->oparsz);
						FREE(Block->opartyp);
						for(j=0;j<i;j++) FREE(Block->oparptr[j]);
						*ierr = -39;
						return 0;
					   }
					   memcpy((double *)Block->oparptr[i], \
						   (double *)(&ilh2[4]), \
						   2*mh2*nh2*sizeof(double));
					   break;

			case 84  : if ((Block->oparptr[i]=(long *) MALLOC(mh2*nh2*sizeof(long)))==NULL) 
					   {
						FREE(Block->z);
						FREE(Block->ozsz);
						FREE(Block->oztyp);
						for(j=0;j<Block->noz;j++) FREE(Block->ozptr[j]);
						FREE(Block->ozptr);
						FREE(Block->x);
						FREE(Block->xd);
						FREE(Block->res);
						FREE(Block->insz);
						for(j=0;j<Block->nin;j++) FREE(Block->inptr[j]);
						FREE(Block->inptr);
						FREE(Block->outsz);
						for(j=0;j<Block->nout;j++) FREE(Block->outptr[j]);
						FREE(Block->outptr);
						FREE(Block->evout);
						FREE(Block->rpar);
						FREE(Block->ipar);
						FREE(Block->oparsz);
						FREE(Block->opartyp);
						for(j=0;j<i;j++) FREE(Block->oparptr[j]);
						*ierr = -39;
						return 0;
					   }
					   memcpy((long *)Block->oparptr[i], \
						   (long *)(&ilh2[4]), \
						   mh2*nh2*sizeof(long));
					   break;

			case 82  : if ((Block->oparptr[i]=(short *) MALLOC(mh2*nh2*sizeof(short)))==NULL) 
					   {
						FREE(Block->z);
						FREE(Block->ozsz);
						FREE(Block->oztyp);
						for(j=0;j<Block->noz;j++) FREE(Block->ozptr[j]);
						FREE(Block->ozptr);
						FREE(Block->x);
						FREE(Block->xd);
						FREE(Block->res);
						FREE(Block->insz);
						for(j=0;j<Block->nin;j++) FREE(Block->inptr[j]);
						FREE(Block->inptr);
						FREE(Block->outsz);
						for(j=0;j<Block->nout;j++) FREE(Block->outptr[j]);
						FREE(Block->outptr);
						FREE(Block->evout);
						FREE(Block->rpar);
						FREE(Block->ipar);
						FREE(Block->oparsz);
						FREE(Block->opartyp);
						for(j=0;j<i;j++) FREE(Block->oparptr[j]);
						*ierr = -39;
						return 0;
					   }
					   memcpy((short *)Block->oparptr[i], \
						   (short *)(&ilh2[4]), \
						   mh2*nh2*sizeof(short));
					   break;

			case 81  : if ((Block->oparptr[i]=(char *) MALLOC(mh2*nh2*sizeof(char)))==NULL) 
					   {
						FREE(Block->z);
						FREE(Block->ozsz);
						FREE(Block->oztyp);
						for(j=0;j<Block->noz;j++) FREE(Block->ozptr[j]);
						FREE(Block->ozptr);
						FREE(Block->x);
						FREE(Block->xd);
						FREE(Block->res);
						FREE(Block->insz);
						for(j=0;j<Block->nin;j++) FREE(Block->inptr[j]);
						FREE(Block->inptr);
						FREE(Block->outsz);
						for(j=0;j<Block->nout;j++) FREE(Block->outptr[j]);
						FREE(Block->outptr);
						FREE(Block->evout);
						FREE(Block->rpar);
						FREE(Block->ipar);
						FREE(Block->oparsz);
						FREE(Block->opartyp);
						for(j=0;j<i;j++) FREE(Block->oparptr[j]);
						*ierr = -39;
						return 0;
					   }
					   memcpy((char *)Block->oparptr[i], \
						   (char *)(&ilh2[4]), \
						   mh2*nh2*sizeof(char));
					   break;

			case 814 : if ((Block->oparptr[i]=(unsigned long *) MALLOC(mh2*nh2*sizeof(unsigned long)))==NULL) 
					   {
						FREE(Block->z);
						FREE(Block->ozsz);
						FREE(Block->oztyp);
						for(j=0;j<Block->noz;j++) FREE(Block->ozptr[j]);
						FREE(Block->ozptr);
						FREE(Block->x);
						FREE(Block->xd);
						FREE(Block->res);
						FREE(Block->insz);
						for(j=0;j<Block->nin;j++) FREE(Block->inptr[j]);
						FREE(Block->inptr);
						FREE(Block->outsz);
						for(j=0;j<Block->nout;j++) FREE(Block->outptr[j]);
						FREE(Block->outptr);
						FREE(Block->evout);
						FREE(Block->rpar);
						FREE(Block->ipar);
						FREE(Block->oparsz);
						FREE(Block->opartyp);
						for(j=0;j<i;j++) FREE(Block->oparptr[j]);
						*ierr = -39;
						return 0;
					   }
					   memcpy((unsigned long *)Block->oparptr[i], \
						   (unsigned long *)(&ilh2[4]), \
						   mh2*nh2*sizeof(unsigned long));
					   break;

			case 812 : if ((Block->oparptr[i]=(unsigned short *) MALLOC(mh2*nh2*sizeof(unsigned short)))==NULL) 
					   {
						FREE(Block->z);
						FREE(Block->ozsz);
						FREE(Block->oztyp);
						for(j=0;j<Block->noz;j++) FREE(Block->ozptr[j]);
						FREE(Block->ozptr);
						FREE(Block->x);
						FREE(Block->xd);
						FREE(Block->res);
						FREE(Block->insz);
						for(j=0;j<Block->nin;j++) FREE(Block->inptr[j]);
						FREE(Block->inptr);
						FREE(Block->outsz);
						for(j=0;j<Block->nout;j++) FREE(Block->outptr[j]);
						FREE(Block->outptr);
						FREE(Block->evout);
						FREE(Block->rpar);
						FREE(Block->ipar);
						FREE(Block->oparsz);
						FREE(Block->opartyp);
						for(j=0;j<i;j++) FREE(Block->oparptr[j]);
						*ierr = -39;
						return 0;
					   }
					   memcpy((unsigned short *)Block->oparptr[i], \
						   (unsigned short *)(&ilh2[4]), \
						   mh2*nh2*sizeof(unsigned short));
					   break;

			case 811 : if ((Block->oparptr[i]=(unsigned char *) MALLOC(mh2*nh2*sizeof(unsigned char)))==NULL) 
					   {
						FREE(Block->z);
						FREE(Block->ozsz);
						FREE(Block->oztyp);
						for(j=0;j<Block->noz;j++) FREE(Block->ozptr[j]);
						FREE(Block->ozptr);
						FREE(Block->x);
						FREE(Block->xd);
						FREE(Block->res);
						FREE(Block->insz);
						for(j=0;j<Block->nin;j++) FREE(Block->inptr[j]);
						FREE(Block->inptr);
						FREE(Block->outsz);
						for(j=0;j<Block->nout;j++) FREE(Block->outptr[j]);
						FREE(Block->outptr);
						FREE(Block->evout);
						FREE(Block->rpar);
						FREE(Block->ipar);
						FREE(Block->oparsz);
						FREE(Block->opartyp);
						for(j=0;j<i;j++) FREE(Block->oparptr[j]);
						*ierr = -39;
						return 0;
					   }
					   memcpy((unsigned char *)Block->oparptr[i], \
						   (unsigned char *)(&ilh2[4]), \
						   mh2*nh2*sizeof(unsigned char));
					   break;
			}
		}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<Block->noz;j++) FREE(Block->ozptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<Block->nin;j++) FREE(Block->inptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<Block->nout;j++) FREE(Block->outptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<Block->nopar;j++) FREE(Block->oparptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<Block->noz;j++) FREE(Block->ozptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<Block->nin;j++) FREE(Block->inptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<Block->nout;j++) FREE(Block->outptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<Block->nopar;j++) FREE(Block->oparptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<Block->noz;j++) FREE(Block->ozptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<Block->nin;j++) FREE(Block->inptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<Block->nout;j++) FREE(Block->outptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<Block->nopar;j++) FREE(Block->oparptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<(mh*nh);j++) 
	{
		Block->g[j]=*((double *)(&ilh[4]) + j);
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<Block->noz;j++) FREE(Block->ozptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<Block->nin;j++) FREE(Block->inptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<Block->nout;j++) FREE(Block->outptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<Block->nopar;j++) FREE(Block->oparptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<Block->noz;j++) FREE(Block->ozptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<Block->nin;j++) FREE(Block->inptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<Block->nout;j++) FREE(Block->outptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<Block->nopar;j++) FREE(Block->oparptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<Block->noz;j++) FREE(Block->ozptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<Block->nin;j++) FREE(Block->inptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<Block->nout;j++) FREE(Block->outptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<Block->nopar;j++) FREE(Block->oparptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<(mh*nh);j++) 
	{
		Block->jroot[j]=(int) *((double *)(&ilh[4]) + j);
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<Block->noz;j++) FREE(Block->ozptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<Block->nin;j++) FREE(Block->inptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<Block->nout;j++) FREE(Block->outptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<Block->nopar;j++) FREE(Block->oparptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<Block->noz;j++) FREE(Block->ozptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<Block->nin;j++) FREE(Block->inptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<Block->nout;j++) FREE(Block->outptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<Block->nopar;j++) FREE(Block->oparptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<Block->noz;j++) FREE(Block->ozptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<Block->nin;j++) FREE(Block->inptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<Block->nout;j++) FREE(Block->outptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<Block->nopar;j++) FREE(Block->oparptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<Block->noz;j++) FREE(Block->ozptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<Block->nin;j++) FREE(Block->inptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<Block->nout;j++) FREE(Block->outptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<Block->nopar;j++) FREE(Block->oparptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<Block->noz;j++) FREE(Block->ozptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<Block->nin;j++) FREE(Block->inptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<Block->nout;j++) FREE(Block->outptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<Block->nopar;j++) FREE(Block->oparptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<Block->noz;j++) FREE(Block->ozptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<Block->nin;j++) FREE(Block->inptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<Block->nout;j++) FREE(Block->outptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<Block->nopar;j++) FREE(Block->oparptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<(mh*nh);j++) 
	{
		Block->mode[j]=(int) *((double *)(&ilh[4]) + j);
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<Block->noz;j++) FREE(Block->ozptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<Block->nin;j++) FREE(Block->inptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<Block->nout;j++) FREE(Block->outptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<Block->nopar;j++) FREE(Block->oparptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<Block->noz;j++) FREE(Block->ozptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<Block->nin;j++) FREE(Block->inptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<Block->nout;j++) FREE(Block->outptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<Block->nopar;j++) FREE(Block->oparptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<(mh*nh);j++) 
	{
		Block->xprop[j]=(int) *((double *)(&ilh[4]) + j);
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k=0; k<nf; k++) 
	{
		longueur = Min( headerstr[6+k] - headerstr[5+k] , nlgh);  
		istart = 5 + nf + headerstr[5+k];    

		C2F(cvstr)(&longueur, &headerstr[istart], str, (ilocal=1, &ilocal),longueur);
		str[longueur] = '\0';
		if (strcmp(string, str) == 0) 
		{
			retval = k + 2;
			break;
		}
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < count; j++) {
    vs[j] = NULL;
    vs[j] = N_VClone_Serial(w);
    if (vs[j] == NULL) {
      N_VDestroyVectorArray_Serial(vs, j-1);
      return(NULL);
    }
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < count; j++) {
    vs[j] = NULL;
    vs[j] = N_VCloneEmpty_Serial(w);
    if (vs[j] == NULL) {
      N_VDestroyVectorArray_Serial(vs, j-1);
      return(NULL);
    }
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < count; j++) N_VDestroy_Serial(vs[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++) {
#if defined(SUNDIALS_EXTENDED_PRECISION)
    printf("%11.8Lg\n", xd[i]);
#elif defined(SUNDIALS_DOUBLE_PRECISION)
    printf("%11.8lg\n", xd[i]);
#else
    printf("%11.8g\n", xd[i]);
#endif
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
    zd[i] = (a*xd[i])+(b*yd[i]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++) zd[i] = c;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
    zd[i] = xd[i]*yd[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
    zd[i] = xd[i]/yd[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++) 
      zd[i] = c*xd[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
    zd[i] = ABS(xd[i]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
    zd[i] = ONE/xd[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++) 
    zd[i] = xd[i]+b;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
    sum += xd[i]*yd[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++) {
    if (ABS(xd[i]) > max) max = ABS(xd[i]);
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++) {
    prodi = xd[i]*wd[i];
    sum += SQR(prodi);
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++) {
    if (idd[i] > ZERO) {
      prodi = xd[i]*wd[i];
      sum += SQR(prodi);
    }
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i < N; i++) {
    if (xd[i] < min) min = xd[i];
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++) {
    prodi = xd[i]*wd[i];
    sum += SQR(prodi);
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i<N; i++)  
    sum += ABS(xd[i]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++) {
    zd[i] = (ABS(xd[i]) >= c) ? ONE : ZERO;
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++) {
    if (xd[i] == ZERO) return(FALSE);
    zd[i] = ONE/xd[i];
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++) {
    md[i] = ZERO;
    if (cd[i] == ZERO) continue;
    if (cd[i] > ONEPT5 || cd[i] < -ONEPT5) {
      if ( xd[i]*cd[i] <= ZERO) { test = FALSE; md[i] = ONE; }
      continue;
    }
    if ( cd[i] > HALF || cd[i] < -HALF) {
      if (xd[i]*cd[i] < ZERO ) { test = FALSE; md[i] = ONE; }
    }
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++) {
    if (dd[i] == ZERO) continue;
    else {
      if (!notEvenOnce) min = MIN(min, nd[i]/dd[i]);
      else {
	min = nd[i]/dd[i];
        notEvenOnce = FALSE;
      }
    }
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
    zd[i] = xd[i]; 



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
    zd[i] = xd[i]+yd[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
    zd[i] = xd[i]-yd[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
    zd[i] = -xd[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
    zd[i] = c*(xd[i]+yd[i]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
    zd[i] = c*(xd[i]-yd[i]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
    zd[i] = (a*xd[i])+yd[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
    zd[i] = (a*xd[i])-yd[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
      yd[i] += xd[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
      yd[i] -= xd[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
    yd[i] += a*xd[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
    xd[i] *= a;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < N; j++) {

    

    N_VSetArrayPointer(DENSE_COL(J,j), jthCol);

    yjsaved = y_data[j];
    inc = MAX(srur*ABS(yjsaved), minInc/ewt_data[j]);
    y_data[j] += inc;

    retval = f(tn, y, ftemp, f_data);
    nfeD++;
    if (retval != 0) break;
    
    y_data[j] = yjsaved;

    inc_inv = ONE/inc;
    N_VLinearSum(inc_inv, ftemp, -inc_inv, fy, jthCol);

    DENSE_COL(J,j) = N_VGetArrayPointer(jthCol);
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<nrt; i++) rootsfound[i] = iroots[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i <= 5; i++)
    for(k = 1; k <= 3; k++) 
      cv_mem->cv_ssdat[i-1][k-1] = ZERO;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i <= 5; i++)
    for(k = 1; k <= 3; k++) 
      cv_mem->cv_ssdat[i-1][k-1] = ZERO;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(;;) {
   
    next_h = h;
    next_q = q;
    
    
    if (nst > 0) {

      ewtsetOK = efun(zn[0], ewt, e_data);

      if (ewtsetOK != 0) {

        if (itol == CV_WF)
          CVProcessError(cv_mem, CV_ILL_INPUT, "CVODE", "CVode", MSGCV_EWT_NOW_FAIL, tn);
        else
          CVProcessError(cv_mem, CV_ILL_INPUT, "CVODE", "CVode", MSGCV_EWT_NOW_BAD, tn);
	
        istate = CV_ILL_INPUT;
        tretlast = *tret = tn;
        N_VScale(ONE, zn[0], yout);
        break;

      }
    }
    
    
    if (nstloc >= mxstep) {
      CVProcessError(cv_mem, CV_TOO_MUCH_WORK, "CVODE", "CVode", MSGCV_MAX_STEPS, tn);
      istate = CV_TOO_MUCH_WORK;
      tretlast = *tret = tn;
      N_VScale(ONE, zn[0], yout);
      break;
    }

    
    nrm = N_VWrmsNorm(zn[0], ewt);
    tolsf = uround * nrm;
    if (tolsf > ONE) {
      CVProcessError(cv_mem, CV_TOO_MUCH_ACC, "CVODE", "CVode", MSGCV_TOO_MUCH_ACC, tn);
      istate = CV_TOO_MUCH_ACC;
      tretlast = *tret = tn;
      N_VScale(ONE, zn[0], yout);
      tolsf *= TWO;
      break;
    } else {
      tolsf = ONE;
    }

    
    if (tn + h == tn) {
      nhnil++;
      if (nhnil <= mxhnil) 
        CVProcessError(cv_mem, CV_WARNING, "CVODE", "CVode", MSGCV_HNIL, tn, h);
      if (nhnil == mxhnil) 
        CVProcessError(cv_mem, CV_WARNING, "CVODE", "CVode", MSGCV_HNIL_DONE);
    }

    
    switch (lmm) {
    case CV_DOPRI:
        kflag = CVStepDoPri(cv_mem);
        break;
    case CV_ExpRK:
        kflag = CVStepExpRK(cv_mem);
        break;
    case CV_ImpRK:
        kflag = CVStepImpRK(cv_mem);
        break;
    default:
	kflag = CVStep(cv_mem);
    }

    
    if (kflag != CV_SUCCESS) {
      istate = CVHandleFailure(cv_mem, kflag);
      tretlast = *tret = tn;
      N_VScale(ONE, zn[0], yout);
      break;
    }
    
    nstloc++;

    
    if (nrtfn > 0) {

      retval = CVRcheck3(cv_mem);

      if (retval == RTFOUND) {  
        irfnd = 1;
        istate = CV_ROOT_RETURN;
        tretlast = *tret = tlo;
        break;
      } else if (retval == CV_RTFUNC_FAIL) { 
        CVProcessError(cv_mem, CV_RTFUNC_FAIL, "CVODE", "CVRcheck3", MSGCV_RTFUNC_FAILED, tlo);
        istate = CV_RTFUNC_FAIL;
        break;
      }

	  
	  if (is_sundials_with_extension()) 
	  {
	  if (retval == ZERODETACHING) {  
	irfnd = 1;
        istate = CV_ZERO_DETACH_RETURN;
        tretlast = *tret = tlo;
        break;
      }
	  }

    }

    
    if ( (task == CV_NORMAL) &&  (tn-tout)*h >= ZERO ) {
      istate = CV_SUCCESS;
      tretlast = *tret = tout;
      (void) CVodeGetDky(cv_mem, tout, 0, yout);
      next_q = qprime;
      next_h = hprime;
      break;
    }

    
    if ( istop ) {

      troundoff = FUZZ_FACTOR*uround*(ABS(tn) + ABS(h));
      if ( ABS(tn - tstop) <= troundoff) {
        (void) CVodeGetDky(cv_mem, tstop, 0, yout);
        tretlast = *tret = tstop;
        istate = CV_TSTOP_RETURN;
        break;
      }

      if ( (tn + hprime - tstop)*h > ZERO ) {
        hprime = (tstop - tn)*(ONE-FOUR*uround);
        eta = hprime/h;
      }

    }

    
    if (task == CV_ONE_STEP) {
      istate = CV_SUCCESS;
      tretlast = *tret = tn;
      N_VScale(ONE, zn[0], yout);
      next_q = qprime;
      next_h = hprime;
      break;
    }

  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=q; j >= k; j--) {
    c = ONE;
    for(i=j; i >= j-k+1; i--) c *= i;
    if (j == q) {
      N_VScale(c, zn[q], dky);
    } else {
      N_VLinearSum(c, zn[j], s, dky, dky);
    }
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0; j <= qmax; j++) {
    zn[j] = NULL;
    zn[j] = N_VClone(tmpl);
    if (zn[j] == NULL) {
      N_VDestroy(ewt);
      N_VDestroy(acor);
      N_VDestroy(tempv);
      N_VDestroy(ftemp);
      for(i=0; i < j; i++) N_VDestroy(zn[i]);
      return(FALSE);
    }
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i <= qmax; i++) N_VDestroy(zn[i]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0; j <= maxord; j++) N_VDestroy(zn[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(count1 = 1; count1 <= MAX_ITERS; count1++) {

    

    hgOK = FALSE;

    for(count2 = 1; count2 <= MAX_ITERS; count2++) {
      hgs = hg*sign;
      retval = CVYddNorm(cv_mem, hgs, &yddnrm);
      
      if (retval < 0) return(CV_RHSFUNC_FAIL);
      
      if (retval == CV_SUCCESS) {hgOK = TRUE; break;}
      
      hg *= POINT2;
    }

    

    if (!hgOK) {
      
      if (count1 <= 2) return(CV_REPTD_RHSFUNC_ERR);
      

      hnew = hs;
      break;
    }

    
    hs = hg;

    
    if ( (hnewOK) || (count1 == MAX_ITERS))  {hnew = hg; break;}

    
    hnew = (yddnrm*hub*hub > TWO) ? RSqrt(TWO/yddnrm) : RSqrt(hg*hub);
    hrat = hnew/hg;
    
    
    if ((hrat > HALF) && (hrat < TWO)) {
      hnewOK = TRUE;
    }

    
    if ((count1 > 1) && (hrat > TWO)) {
      hnew = hg;
      hnewOK = TRUE;
    }

    
    hg = hnew;

  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(;;) {  

    CVPredict(cv_mem);  
    CVSet(cv_mem);

    nflag = CVNls(cv_mem, nflag);
    kflag = CVHandleNFlag(cv_mem, &nflag, saved_t, &ncf);

    
    if (kflag == PREDICT_AGAIN) continue;

    
    if (kflag != DO_ERROR_TEST) return(kflag);

    
    eflag = CVDoErrorTest(cv_mem, &nflag, saved_t, &nef, &dsm);

    
    if (eflag == TRY_AGAIN)  continue;

    
    if (eflag != CV_SUCCESS) return(eflag);

    
    break;

  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i <= qmax; i++) l[i] = ZERO;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=1; j <= q-2; j++) {
    hsum += tau[j];
    xi = hsum / hscale;
    for(i=j+1; i >= 1; i--) l[i] = l[i]*xi + l[i-1];
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=1; j <= q-2; j++) l[j+1] = q * (l[j] / (j+1));



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=2; j < q; j++)
    N_VLinearSum(-l[j], zn[q], ONE, zn[j], zn[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i <= qmax; i++) l[i] = ZERO;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=1; j < q; j++) {
      hsum += tau[j+1];
      xi = hsum / hscale;
      prod *= xi;
      alpha0 -= ONE / (j+1);
      alpha1 += ONE / xi;
      for(i=j+2; i >= 2; i--) l[i] = l[i]*xiold + l[i-1];
      xiold = xi;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=2; j <= q; j++) {
    N_VLinearSum(l[j], zn[L], ONE, zn[j], zn[j]);
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i <= qmax; i++) l[i] = ZERO;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=1; j <= q-2; j++) {
    hsum += tau[j];
    xi = hsum /hscale;
    for(i=j+2; i >= 2; i--) l[i] = l[i]*xi + l[i-1];
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=2; j < q; j++)
    N_VLinearSum(-l[j], zn[q], ONE, zn[j], zn[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=1; j <= q; j++) {
    N_VScale(factor, zn[j], zn[j]);
    factor *= eta;
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 1; k <= q; k++)
    for(j = q; j >= k; j--) 
      N_VLinearSum(ONE, zn[j-1], ONE, zn[j], zn[j-1]); 



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=1; i <= q; i++) m[i] = ZERO;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=1; j < q; j++) {
    if ((j==q-1) && (qwait == 1)) {
      sum = CVAltSum(q-2, m, 2);
      tq[1] = m[q-2] / (q * sum);
    }
    xi_inv = h / hsum;
    for(i=j; i >= 1; i--) m[i] += m[i-1] * xi_inv;
    hsum += tau[j];
    
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=1; i <= q; i++) l[i] = M0_inv * (m[i-1] / i);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=q; i >= 1; i--) m[i] += m[i-1] * xi_inv;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i <= iend; i++) {
    sum += sign * (a[i] / (i+k));
    sign = -sign;
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=2; i <= q; i++) l[i] = ZERO;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=2; j < q; j++) {
      hsum += tau[j-1];
      xi_inv = h / hsum;
      alpha0 -= ONE / j;
      for(i=j; i >= 1; i--) l[i] += l[i-1]*xi_inv;
      
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=q; i >= 1; i--) l[i] += l[i-1]*xistar_inv;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(;;) {

    nni++;

    
    N_VLinearSum(h, tempv, -ONE, zn[1], tempv);
    N_VScale(rl1, tempv, tempv);
    N_VLinearSum(ONE, zn[0], ONE, tempv, y);
    
    N_VLinearSum(ONE, tempv, -ONE, acor, acor);
    del = N_VWrmsNorm(acor, ewt);
    N_VScale(ONE, tempv, acor);
    
    

    if (m > 0) crate = MAX(CRDOWN * crate, del / delp);
    dcon = del * MIN(ONE, crate) / tq[4];
    if (dcon <= ONE) {
      acnrm = (m == 0) ? del : N_VWrmsNorm(acor, ewt);
      return(CV_SUCCESS);  
    }

    
    m++;
    if ((m==maxcor) || ((m >= 2) && (del > RDIV * delp))) return(CONV_FAIL);

    
    delp = del;

    retval = f(tn, y, tempv, f_data);
    nfe++;
    if (retval < 0) return(CV_RHSFUNC_FAIL);
    if (retval > 0) return(RHSFUNC_RECVR);

  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(;;) {

    retval = f(tn, zn[0], ftemp, f_data);
    nfe++; 
    if (retval < 0) return(CV_RHSFUNC_FAIL);
    if (retval > 0) return(RHSFUNC_RECVR);

    if (callSetup) {
      ier = lsetup(cv_mem, convfail, zn[0], ftemp, &jcur, 
                   vtemp1, vtemp2, vtemp3);
      nsetups++;
      callSetup = FALSE;
      gamrat = crate = ONE; 
      gammap = gamma;
      nstlp = nst;
      
      if (ier < 0) return(CV_LSETUP_FAIL);
      if (ier > 0) return(CONV_FAIL);
    }

    
    N_VConst(ZERO, acor);
    N_VScale(ONE, zn[0], y);

    
    ier = CVNewtonIteration(cv_mem);

    


    if (ier != TRY_AGAIN) return(ier);
    
    callSetup = TRUE;
    convfail = CV_FAIL_BAD_J;
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(;;) {

    
    N_VLinearSum(rl1, zn[1], ONE, acor, tempv);
    N_VLinearSum(gamma, ftemp, -ONE, tempv, tempv);

    
    b = tempv;
    retval = lsolve(cv_mem, b, ewt, y, ftemp); 
    nni++;
    
    if (retval < 0) return(CV_LSOLVE_FAIL);
    
    

    if (retval > 0) { 
      if ((!jcur) && (setupNonNull)) return(TRY_AGAIN);
      else                           return(CONV_FAIL);
    }

    
    del = N_VWrmsNorm(b, ewt);
    N_VLinearSum(ONE, acor, ONE, b, acor);
    N_VLinearSum(ONE, zn[0], ONE, acor, y);
    
    

    if (m > 0) {
      crate = MAX(CRDOWN * crate, del/delp);
    }
    dcon = del * MIN(ONE, crate) / tq[4];
    
    if (dcon <= ONE) {
      acnrm = (m==0) ? del : N_VWrmsNorm(acor, ewt);
      jcur = FALSE;
      return(CV_SUCCESS); 
    }
    
    mnewt = ++m;
    
    


    if ((m == maxcor) || ((m >= 2) && (del > RDIV*delp))) {
      if ((!jcur) && (setupNonNull)) return(TRY_AGAIN);
      else                           return(CONV_FAIL);
    }
    
    
    delp = del;
    retval = f(tn, y, ftemp, f_data);
    nfe++;
    if (retval < 0) return(CV_RHSFUNC_FAIL);
    if (retval > 0) {
      if ((!jcur) && (setupNonNull)) return(TRY_AGAIN);
      else                           return(RHSFUNC_RECVR);
    }

  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 1; k <= q; k++)
    for(j = q; j >= k; j--)
      N_VLinearSum(ONE, zn[j-1], -ONE, zn[j], zn[j-1]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=q; i >= 2; i--)  tau[i] = tau[i-1];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0; j <= q; j++) 
    N_VLinearSum(l[j], acor, ONE, zn[j], zn[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 1; k <= 3; k++)
      { for(i = 5; i >= 2; i--) ssdat[i][k] = ssdat[i-1][k]; }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i <= q-1; i++) factorial *= i;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k=1; k<=3; k++) {
    smink = ssdat[1][k];
    smaxk = ZERO;
    
    for(i=1; i<=5; i++) {
      smink = MIN(smink,ssdat[i][k]);
      smaxk = MAX(smaxk,ssdat[i][k]);
    }
    
    if (smink < TINY*smaxk) {
      kflag = -1;  
      return(kflag);
    }
    smax[k] = smaxk;
    ssmax[k] = smaxk*smaxk;
    
    sumrat = ZERO;
    sumrsq = ZERO;
    for(i=1; i<=4; i++) {
      rat[i][k] = ssdat[i][k]/ssdat[i+1][k];
      sumrat = sumrat + rat[i][k];
      sumrsq = sumrsq + rat[i][k]*rat[i][k];
    } 
    rav[k] = FOURTH*sumrat;
    vrat[k] = ABS(FOURTH*sumrsq - rav[k]*rav[k]);
    
    qc[5][k] = ssdat[1][k]*ssdat[3][k] - ssdat[2][k]*ssdat[2][k];
    qc[4][k] = ssdat[2][k]*ssdat[3][k] - ssdat[1][k]*ssdat[4][k];
    qc[3][k] = ZERO;
    qc[2][k] = ssdat[2][k]*ssdat[5][k] - ssdat[3][k]*ssdat[4][k];
    qc[1][k] = ssdat[4][k]*ssdat[4][k] - ssdat[3][k]*ssdat[5][k];
    
    for(i=1; i<=5; i++) {
      qco[i][k] = qc[i][k];
    }
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 1;k<=3;k++) {
        adrr = ABS(rav[k] - rr);
        drrmax = MAX(drrmax, adrr);
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=2; i<=5; i++) {
      qco[i][2] = qco[i][2] - tem*qco[i][1];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=2; i<=5; i++) {
      qco[i][3] = qco[i][3] - tem*qco[i][1];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=3; i<=5; i++) {
      qco[i][3] = qco[i][3] - tem*qco[i][2];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k=1; k<=3; k++) {
      qkr[k] = qc[5][k] + rr*(qc[4][k] + rr*rr*(qc[2][k] + rr*qc[1][k]));
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k=1; k<=3; k++) {
      saqk = ABS(qkr[k])/ssmax[k];
      if (saqk > sqmax) sqmax = saqk;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(it=1; it<=3; it++) {
        for(k=1; k<=3; k++) {
          qp = qc[4][k] + rr*rr*(THREE*qc[2][k] + rr*FOUR*qc[1][k]);
          drr[k] = ZERO;
          if (ABS(qp) > TINY*ssmax[k]) drr[k] = -qkr[k]/qp;
          rrc[k] = rr + drr[k];
        } 
        
        for(k=1; k<=3; k++) {
          s = rrc[k];
          sqmaxk = ZERO;
          for(j=1; j<=3; j++) {
            qjk[j][k] = qc[5][j] + s*(qc[4][j] + 
                                      s*s*(qc[2][j] + s*qc[1][j]));
            saqj = ABS(qjk[j][k])/ssmax[j];
            if (saqj > sqmaxk) sqmaxk = saqj;
          } 
          sqmx[k] = sqmaxk;
        } 

        sqmin = sqmx[1]; kmin = 1;
        for(k=2; k<=3; k++) {
          if (sqmx[k] < sqmin) {
            kmin = k;
            sqmin = sqmx[k];
          }
        } 
        rr = rrc[kmin];
        
        if (sqmin < sqtol) {
          kflag = 3;
          
           
          break;
        } else {
          for(j=1; j<=3; j++) {
            qkr[j] = qjk[j][kmin];
          }
        }     
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k=1; k<=3; k++) {
    rsa = ssdat[1][k];
    rsb = ssdat[2][k]*rr;
    rsc = ssdat[3][k]*rr*rr;
    rsd = ssdat[4][k]*rr*rr*rr;
    rd1a = rsa - rsb;
    rd1b = rsb - rsc;
    rd1c = rsc - rsd;
    rd2a = rd1a - rd1b;
    rd2b = rd1b - rd1c;
    rd3a = rd2a - rd2b;
    
    if (ABS(rd1b) < TINY*smax[k]) {
      kflag = -7;
      return(kflag);
    }
    
    cest1 = -rd3a/rd1b;
    if (cest1 < TINY || cest1 > FOUR) {
      kflag = -7;
      return(kflag);
    }
    corr1 = (rd2b/cest1)/(rr*rr);
    sigsq[k] = ssdat[3][k] + corr1;
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nrtfn; i++) iroots[i] = 0;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nrtfn; i++) {
    if (ABS(glo[i]) == ZERO) zroot = TRUE;
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nrtfn; i++) {
    if (ABS(glo[i]) == ZERO) {
      zroot = TRUE;
      iroots[i] = 1;
    }
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nrtfn; i++) iroots[i] = 0;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nrtfn; i++) {
    if (ABS(glo[i]) == ZERO) {
      zroot = TRUE;
      iroots[i] = 1;
    }
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nrtfn; i++) {
    if (ABS(glo[i]) == ZERO) {
      if (iroots[i] == 1) return(CLOSERT);
      zroot = TRUE;
      iroots[i] = 1;
    }
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nrtfn; i++) glo[i] = grout[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0;  i < nrtfn; i++) {
    if (ABS(ghi[i]) == ZERO) {
      zroot = TRUE;
    } else {
      if (glo[i]*ghi[i] < ZERO) {
        gfrac = ABS(ghi[i]/(ghi[i] - glo[i]));
        if (gfrac > maxfrac) {
          sgnchg = TRUE;
          maxfrac = gfrac;
          imax = i;
        }
      }
    }
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nrtfn; i++) grout[i] = ghi[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nrtfn; i++) {
      iroots[i] = 0;
      if (ABS(ghi[i]) == ZERO) iroots[i] = 1;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(;;) {                                    

    









    if (sideprev == side) {
      alpha = (side == 2) ? alpha*TWO : alpha*HALF;
    } else {
      alpha = ONE;
    }

    


    tmid = thi - (thi - tlo)*ghi[imax]/(ghi[imax] - alpha*glo[imax]);
    if (ABS(tmid - tlo) < HALF*ttol) {
      fracint = ABS(thi - tlo)/ttol;
      fracsub = (fracint > FIVE) ? TENTH : HALF/fracint;
      tmid = tlo + fracsub*(thi - tlo);
    }
    if (ABS(thi - tmid) < HALF*ttol) {
      fracint = ABS(thi - tlo)/ttol;
      fracsub = (fracint > FIVE) ? TENTH : HALF/fracint;
      tmid = thi - fracsub*(thi - tlo);
    }

    (void) CVodeGetDky(cv_mem, tmid, 0, y);
    retval = gfun(tmid, y, grout, g_data);
    nge++;
    if (retval != 0) return(CV_RTFUNC_FAIL);

    
  
    maxfrac = ZERO;
    zroot = FALSE;
    sgnchg = FALSE;
    sideprev = side;
    for(i = 0;  i < nrtfn; i++) {
      if (ABS(grout[i]) == ZERO) {
        zroot = TRUE;
      } else {
        if (glo[i]*grout[i] < ZERO) {
          gfrac = ABS(grout[i]/(grout[i] - glo[i]));
          if (gfrac > maxfrac) {
            sgnchg = TRUE;
            maxfrac = gfrac;
            imax = i;
          }
        }
      }
    }
    if (sgnchg) {
      
      thi = tmid;
      for(i = 0; i < nrtfn; i++) ghi[i] = grout[i];
      side = 1;
      
      if (ABS(thi - tlo) <= ttol) break;
      continue;  
    }

    if (zroot) {
      
      thi = tmid;
      for(i = 0; i < nrtfn; i++) ghi[i] = grout[i];
      break;
    }

    

    tlo = tmid;
    for(i = 0; i < nrtfn; i++) glo[i] = grout[i];
    side = 2;
    
    if (ABS(thi - tlo) <= ttol) break;

  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nrtfn; i++) {
    grout[i] = ghi[i];
    iroots[i] = 0;
    if (ABS(ghi[i]) == ZERO) iroots[i] = 1;
    if (glo[i]*ghi[i] < ZERO) iroots[i] = 1;
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nrtfn; i++) iroots[i] = 0;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nrtfn; i++) {
		if (ABS(glo[i]) == ZERO) 
			iroots[i] =MASKED; 
		else 
			iroots[i] =0;
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nrtfn; i++) {
		if (ABS(glo[i]) == ZERO) 
			iroots[i] =MASKED; 
		else 
			iroots[i] =0;
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nrtfn; i++) glo[i] = grout[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0;  i < nrtfn; i++) {
		if ((ABS(ghi[i])==ZERO)&& (iroots[i]!=MASKED))  istuck=i;
		if ((ABS(ghi[i])> ZERO)&& (iroots[i]==MASKED))  iunstuck=i;
		if ((ABS(ghi[i])> ZERO)&& (glo[i]*ghi[i] <= ZERO)) {
			gfrac = ABS(ghi[i]/(ghi[i] - glo[i]));
			if (gfrac > maxfrac) { 
				maxfrac = gfrac;
				imax = i;
			}      
		}
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nrtfn; i++) grout[i] = ghi[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(;;) {                                    

		









		if (sideprev == side) {
			alpha = (side == 2) ? alpha*TWO : alpha*HALF;
		} else {
			alpha = ONE;
		}
		


		if ((ABS(ghi[imax])==ZERO)||(ABS(glo[imax])==ZERO)){
			tmid=(tlo+alpha*thi)/(1+alpha);
		}else{
			tmid = thi - (thi - tlo)*ghi[imax]/(ghi[imax] - alpha*glo[imax]);
		}

		if (tmid+1 ==tmid) {printf("tmid is nan\n\r ");exit(0);};

		if (ABS(tmid - tlo) < HALF*ttol) {
			fracint = ABS(thi - tlo)/ttol;
			fracsub = (fracint > FIVE) ? TENTH : HALF/fracint;
			tmid = tlo + fracsub*(thi - tlo);
		}

		if (ABS(thi - tmid) < HALF*ttol) {
			fracint = ABS(thi - tlo)/ttol;
			fracsub = (fracint > FIVE) ? TENTH : HALF/fracint;
			tmid = thi - fracsub*(thi - tlo);
		}

		(void) CVodeGetDky(cv_mem, tmid, 0, y);
		retval = gfun(tmid, y, grout, g_data);
		nge++;
		if (retval != 0) return(CV_RTFUNC_FAIL);

		
  

		
		zroot = FALSE;
		sideprev = side;
		imaxold=imax;
		imax = -1;
		istuck=-1;iunstuck=-1;
		maxfrac = ZERO;
		for(i = 0;  i < nrtfn; i++) {
			if ((ABS(grout[i])==ZERO)&& (iroots[i]!=MASKED))  istuck=i;
			if ((ABS(grout[i])> ZERO)&& (iroots[i]==MASKED))  iunstuck=i;
			if ((ABS(grout[i])> ZERO)&& (glo[i]*grout[i] <= ZERO)) {
				gfrac = ABS(grout[i]/(grout[i] - glo[i]));
				if (gfrac > maxfrac) { 
					maxfrac = gfrac;
					imax = i;
				}      
			}
		}

		if (imax>=0)
			sgnchg=TRUE;
		else if (istuck>=0) {
			sgnchg=TRUE;
			imax=istuck;
		}else  if (iunstuck>=0) {
			sgnchg=TRUE;
			imax=iunstuck;
		}else{
			sgnchg = FALSE;
			imax=imaxold;
		}

		if (sgnchg) {
			
			thi = tmid;
			for(i = 0; i < nrtfn; i++) ghi[i] = grout[i];
			side = 1;
			
			if (ABS(thi - tlo) <= ttol) break;
			continue;  
		}

		

		

		tlo = tmid;
		for(i = 0; i < nrtfn; i++) glo[i] = grout[i];
		side = 2;
		
		if (ABS(thi - tlo) <= ttol) break;

	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nrtfn; i++) {
		grout[i] = ghi[i];
		if (iroots[i]==MASKED){
			if (ABS(ghi[i]) != ZERO){ 
				iroots[i] = (ghi[i]> ZERO) ? 2 : -2;
				umroot=TRUE;
			}else{
				iroots[i]=0;
			}
		}else{
			if (ABS(ghi[i])== ZERO){ 
				iroots[i] = (glo[i]> ZERO) ? -1 : 1;
				zroot = TRUE;
			}else{
				if (glo[i]*ghi[i] < ZERO){
					iroots[i] = (ghi[i]>glo[i]) ? 1 : -1;
					zroot = TRUE;
				}else
					iroots[i]=0;
			}
		}    
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nrtfn; i++) {
			if ((iroots[i]==2)|| (iroots[i]==-2))  iroots[i]=0;
		}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(nwt = 1; nwt <= 2; nwt++) {
 
    
    for(nh = 1; nh <= mxnh; nh++) {

      
      retval = IDAnlsIC(IDA_mem);

      
      if(retval == IDA_SUCCESS) break;
      ncfn++;
      if(retval < 0) break;
      if(nh == mxnh) break;
      
      if(retval != IC_SLOW_CONVRG) {
        N_VScale(ONE, phi[0], yy0);
        N_VScale(ONE, phi[1], yp0);
      }
      hic *= PT1;
      cj = ONE/hic;
      hh = hic;
    }   

    
    if(retval != IDA_SUCCESS) break;
    ewtsetOK = efun(yy0, ewt, edata);
    if(ewtsetOK != 0) { 
      retval = IDA_BAD_EWT; 
      break; 
    }
    N_VScale(ONE, yy0, phi[0]);
    N_VScale(ONE, yp0, phi[1]);

  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(nj = 1; nj <= maxnj; nj++) {

    
    if(setupNonNull) {
      nsetups++;
      retval = lsetup(IDA_mem, yy0, yp0, delta, tv1, tv2, tv3);
      if(retval < 0) return(IDA_LSETUP_FAIL);
      if(retval > 0) return(IC_FAIL_RECOV);
    }

    
    retval = IDANewtonIC(IDA_mem);
    if(retval == IDA_SUCCESS) return(IDA_SUCCESS);

    
    if(retval == IC_SLOW_CONVRG && setupNonNull) {
      N_VScale(ONE, savres, delta);
      continue;
    } else {
      return(retval);
    }

  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(mnewt = 0; mnewt < maxnit; mnewt++) {

    nni++;
    delnorm = fnorm;
    oldfnrm = fnorm;

    
    retval = IDALineSrch(IDA_mem, &delnorm, &fnorm);
    if(retval != IDA_SUCCESS) return(retval);

    
    rate = fnorm/oldfnrm;
    if(fnorm <= epsNewt) return(IDA_SUCCESS);

    
    N_VScale(ONE, delnew, delta);

  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(;;) {

    
    IDANewyyp(IDA_mem, lambda);
    retval = IDAfnorm(IDA_mem, &fnormp);
    if(retval != IDA_SUCCESS) return(retval);

    
    if(lsoff) break;

    
    f1normp = fnormp*fnormp*HALF;
    if(f1normp <= f1norm + ALPHALS*slpi*lambda) break;
    if(lambda < minlam) return(IC_LINESRCH_FAILED);
    lambda /= TWO;
    nbacktr++;

  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(;;) {
   
    
    
    if (nstloc >= mxstep) {
      IDAProcessError(IDA_mem, IDA_ILL_INPUT, "IDA", "IDASolve", MSG_MAX_STEPS, tn);
      istate = IDA_TOO_MUCH_WORK;
      *tret = tretlast = tn;
      break; 
    }

    

    if (lperf != NULL) lperf(IDA_mem, 1);

    

    if (nst > 0) {

      ier = efun(phi[0], ewt, edata);

      if (ier != 0) {

        if (itol == IDA_WF) 
          IDAProcessError(IDA_mem, IDA_ILL_INPUT, "IDA", "IDASolve", MSG_EWT_NOW_FAIL, tn);
        else
          IDAProcessError(IDA_mem, IDA_ILL_INPUT, "IDA", "IDASolve", MSG_EWT_NOW_BAD, tn);
	
        istate = IDA_ILL_INPUT;
        ier = IDAGetSolution(IDA_mem, tn, yret, ypret);
        *tret = tretlast = tn;
        break;

      }

    }
    
    
    
    nrm = IDAWrmsNorm(IDA_mem, phi[0], ewt, suppressalg);
    tolsf = uround * nrm;
    if (tolsf > ONE) {
      tolsf *= TEN;
      IDAProcessError(IDA_mem, IDA_ILL_INPUT, "IDA", "IDASolve", MSG_TOO_MUCH_ACC, tn);
      istate = IDA_TOO_MUCH_ACC;
      *tret = tretlast = tn;
      if (nst > 0) ier = IDAGetSolution(IDA_mem, tn, yret, ypret);
      break;
    }

    

    sflag = IDAStep(IDA_mem);

    

    if (sflag != IDA_SUCCESS) {
      istate = IDAHandleFailure(IDA_mem, sflag);
      *tret = tretlast = tn;
      ier = IDAGetSolution(IDA_mem, tn, yret, ypret);
      break;
    }
    
    nstloc++;

    

    

    if (nrtfn > 0) {

      ier = IDARcheck3(IDA_mem);

      if (ier == RTFOUND) {  
        irfnd = 1;
        istate = IDA_ROOT_RETURN;
        tretlast = *tret = tlo;
        break;
      } else if (ier == IDA_RTFUNC_FAIL) { 
        IDAProcessError(IDA_mem, IDA_RTFUNC_FAIL, "IDA", "IDARcheck3", MSG_RTFUNC_FAILED, tlo);
        istate = IDA_RTFUNC_FAIL;
        break;
      }

	  
	  if (is_sundials_with_extension()) 
	  {
	   if (ier == ZERODETACHING) {  
	irfnd = 1;
        istate = IDA_ZERO_DETACH_RETURN;
        tretlast = *tret = tlo;
        break;
      }
	  }

    }

    

    istate = IDAStopTest2(IDA_mem, tout, tret, yret, ypret, itask);
    if (istate != CONTINUE_STEPS) break;

  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=1; j <= kord; j++) {
    d = d*gam + c/psi[j-1];
    c = c*gam;
    gam = (delt + psi[j-1])/psi[j];
    N_VLinearSum(ONE,  yret, c, phi[j],  yret);
    N_VLinearSum(ONE, ypret, d, phi[j], ypret);
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0; j <= maxcol; j++) {
    phi[j] = NULL;
    phi[j] = N_VClone(tmpl);
    if (phi[j] == NULL) {
      N_VDestroy(ewt);
      N_VDestroy(ee);
      N_VDestroy(delta);
      N_VDestroy(tempv1);
      N_VDestroy(tempv2);
      for(i=0; i < j; i++) N_VDestroy(phi[i]);
      return(FALSE);
    }
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i <= maxcol; i++) N_VDestroy(phi[i]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0; j <= maxcol; j++) N_VDestroy(phi[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(;;) {  

    



    IDASetCoeffs(IDA_mem, &ck);

    kflag = IDA_SUCCESS;

    


    
    tn = tn + hh;
    if (istop) {
      if ((tn - tstop)*hh > ZERO) tn = tstop;
    }

    



    
    nflag = IDANls(IDA_mem);

    
    if (nflag == IDA_SUCCESS)
      nflag = IDATestError(IDA_mem, ck, &err_k, &err_km1);

    
    if (nflag != IDA_SUCCESS) {

      
      IDARestore(IDA_mem, saved_t);
      kflag = IDAHandleNFlag(IDA_mem, nflag, err_k, err_km1, 
                             &ncfn, &ncf, &netf, &nef);

       
      if (kflag != PREDICT_AGAIN) return(kflag);

      
      if(nst==0) IDAReset(IDA_mem);
      continue;

    }

    
    break;

  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=1;i<=kk;i++){
      temp2 = psi[i-1];
      psi[i-1] = temp1;
      beta[i] = beta[i-1] * psi[i-1] / temp2;
      temp1 = temp2 + hh;
      alpha[i] = hh / temp1;
      sigma[i] = i * sigma[i-1] * alpha[i]; 
      gamma[i] = gamma[i-1] + alpha[i-1] / hh;
   }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<kk;i++){
    alphas = alphas - ONE/(i+1);
    alpha0 = alpha0 - alpha[i];
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=ns;i<=kk;i++) N_VScale(beta[i], phi[i], phi[i]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(;;){

    
    IDAPredict(IDA_mem);

    retval = res(tn, yy, yp, delta, rdata);
    nre++;
    if (retval < 0) return(IDA_RES_FAIL);
    if (retval > 0) return(IDA_RES_RECVR);

    
    if (callSetup){
      nsetups++;
      retval = lsetup(IDA_mem, yy, yp, delta, tempv1, tempv2, tempv3);
      cjold = cj;
      cjratio = ONE;
      ss = TWENTY;
      if (retval < 0) return(IDA_LSETUP_FAIL);
      if (retval > 0) return(IDA_LSETUP_RECVR);
    }

    

    retval = IDANewtonIter(IDA_mem);

    

    tryAgain = (retval>0)&&(setupNonNull) &&(!callSetup);

    if (tryAgain){
      callSetup = TRUE;
      continue;
    }
    else break;

  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=1; j<=kk; j++) {
    N_VLinearSum(ONE,      phi[j], ONE, yy, yy);
    N_VLinearSum(gamma[j], phi[j], ONE, yp, yp);
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(;;) {

    nni++;

    
    N_VScale(ONE, delta, savres);

    
    retval = lsolve(IDA_mem, delta, ewt, yy, yp, savres); 
    if (retval < 0) return(IDA_LSOLVE_FAIL);
    if (retval > 0) return(IDA_LSOLVE_RECVR);

    
    N_VLinearSum(ONE, yy, -ONE, delta, yy);
    N_VLinearSum(ONE, ee, -ONE, delta, ee);
    N_VLinearSum(ONE, yp, -cj,  delta, yp);
    delnrm = IDAWrmsNorm(IDA_mem, delta, ewt, FALSE);

    

    if (mnewt == 0){ 
       oldnrm = delnrm;
       if (delnrm <= toldel) return(IDA_SUCCESS);
    }
    else {
      rate = RPowerR( delnrm/oldnrm, ONE/mnewt );
      if (rate > RATEMAX) return(IDA_NCONV_RECVR); 
      ss = rate/(ONE - rate);
    }

    if (ss*delnrm <= epsNewt) return(IDA_SUCCESS);

    
    mnewt++;
    if (mnewt >= maxcor) {retval = IDA_NCONV_RECVR; break;}

    
    retval = res(tn, yy, yp, delta, rdata);
    nre++;
    if (retval < 0) return(IDA_RES_FAIL);
    if (retval > 0) return(IDA_RES_RECVR);

    

  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 1; j <= kk; j++) 
    psi[j-1] = psi[j] - hh;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = ns; j <= kk; j++) 
    N_VScale(ONE/beta[j], phi[j], phi[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j= kused-1; j>=0; j--)
    N_VLinearSum(ONE, phi[j], ONE, phi[j+1], phi[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nrtfn; i++) iroots[i] = 0;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nrtfn; i++) {
    if (ABS(glo[i]) == ZERO) zroot = TRUE;
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nrtfn; i++) {
    if (ABS(glo[i]) == ZERO) {
      zroot = TRUE;
      iroots[i] = 1;
    }
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nrtfn; i++) iroots[i] = 0;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nrtfn; i++) {
    if (ABS(glo[i]) == ZERO) {
      zroot = TRUE;
      iroots[i] = 1;
    }
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nrtfn; i++) {
    if (ABS(glo[i]) == ZERO) {
      if (iroots[i] == 1) return(CLOSERT);
      zroot = TRUE;
      iroots[i] = 1;
    }
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nrtfn; i++) glo[i] = grout[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0;  i < nrtfn; i++) {
    if (ABS(ghi[i]) == ZERO) {
      zroot = TRUE;
    } else {
      if (glo[i]*ghi[i] < ZERO) {
        gfrac = ABS(ghi[i]/(ghi[i] - glo[i]));
        if (gfrac > maxfrac) {
          sgnchg = TRUE;
          maxfrac = gfrac;
          imax = i;
        }
      }
    }
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nrtfn; i++) grout[i] = ghi[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nrtfn; i++) {
      iroots[i] = 0;
      if (ABS(ghi[i]) == ZERO) iroots[i] = 1;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(;;) {                                    

    









    if (sideprev == side) {
      alph = (side == 2) ? alph*TWO : alph*HALF;
    } else {
      alph = ONE;
    }

    


    tmid = thi - (thi - tlo)*ghi[imax]/(ghi[imax] - alph*glo[imax]);
    if (ABS(tmid - tlo) < HALF*ttol) {
      fracint = ABS(thi - tlo)/ttol;
      fracsub = (fracint > FIVE) ? PT1 : HALF/fracint;
      tmid = tlo + fracsub*(thi - tlo);
    }
    if (ABS(thi - tmid) < HALF*ttol) {
      fracint = ABS(thi - tlo)/ttol;
      fracsub = (fracint > FIVE) ? PT1 : HALF/fracint;
      tmid = thi - fracsub*(thi - tlo);
    }

    (void) IDAGetSolution(IDA_mem, tmid, yy, yp);
    retval = gfun (tmid, yy, yp, grout, g_data);  
    nge++;
    if (retval != 0) return(IDA_RTFUNC_FAIL);

    
  
    maxfrac = ZERO;
    zroot = FALSE;
    sgnchg = FALSE;
    sideprev = side;
    for(i = 0;  i < nrtfn; i++) {
      if (ABS(grout[i]) == ZERO) {
        zroot = TRUE;
      } else {
        if (glo[i]*grout[i] < ZERO) {
          gfrac = ABS(grout[i]/(grout[i] - glo[i]));
          if (gfrac > maxfrac) {
            sgnchg = TRUE;
            maxfrac = gfrac;
            imax = i;
          }
        }
      }
    }
    if (sgnchg) {
      
      thi = tmid;
      for(i = 0; i < nrtfn; i++) ghi[i] = grout[i];
      side = 1;
      
      if (ABS(thi - tlo) <= ttol) break;
    continue;  
    }

    if (zroot) {
      
      thi = tmid;
      for(i = 0; i < nrtfn; i++) ghi[i] = grout[i];
      break;
    }

    

    tlo = tmid;
    for(i = 0; i < nrtfn; i++) glo[i] = grout[i];
    side = 2;
    
    if (ABS(thi - tlo) <= ttol) break;

  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nrtfn; i++) {
    grout[i] = ghi[i];
    iroots[i] = 0;
    if (ABS(ghi[i]) == ZERO) iroots[i] = 1;
    if (glo[i]*ghi[i] < ZERO) iroots[i] = 1;
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nrtfn; i++) iroots[i] = 0;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nrtfn; i++) {
		if (ABS(glo[i]) == ZERO) 
			iroots[i] =MASKED; 
		else 
			iroots[i] =0;
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nrtfn; i++) {
		if (ABS(glo[i]) == ZERO) 
			iroots[i] =MASKED; 
		else 
			iroots[i] =0;
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nrtfn; i++) glo[i] = grout[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0;  i < nrtfn; i++) {
		if ((ABS(ghi[i])==ZERO)&& (iroots[i]!=MASKED))  istuck=i;
		if ((ABS(ghi[i])> ZERO)&& (iroots[i]==MASKED))  iunstuck=i;
		if ((ABS(ghi[i])> ZERO)&& (glo[i]*ghi[i] <= ZERO)) {
			gfrac = ABS(ghi[i]/(ghi[i] - glo[i]));
			if (gfrac > maxfrac) { 
				maxfrac = gfrac;
				imax = i;
			}      
		}
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nrtfn; i++) grout[i] = ghi[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(;;) {                                    

		









		if (sideprev == side) {
			alph = (side == 2) ? alph*TWO : alph*HALF;
		} else {
			alph = ONE;
		}
		


		if ((ABS(ghi[imax])==ZERO)||(ABS(glo[imax])==ZERO)){
			tmid=(tlo+alph*thi)/(1+alph);
		}else{
			tmid = thi - (thi - tlo)*ghi[imax]/(ghi[imax] - alph*glo[imax]);
		}

		if (tmid+1 ==tmid) {printf("tmid is nan\n\r ");exit(0);};

		if (ABS(tmid - tlo) < HALF*ttol) {
			fracint = ABS(thi - tlo)/ttol;
			fracsub = (fracint > FIVE) ? PT1 : HALF/fracint;
			tmid = tlo + fracsub*(thi - tlo);
		}

		if (ABS(thi - tmid) < HALF*ttol) {
			fracint = ABS(thi - tlo)/ttol;
			fracsub = (fracint > FIVE) ? PT1 : HALF/fracint;
			tmid = thi - fracsub*(thi - tlo);
		}

		(void) IDAGetSolution(IDA_mem, tmid, yy, yp);
		retval = gfun (tmid, yy, yp, grout, g_data); 
		nge++;
		if (retval != 0) return(IDA_RTFUNC_FAIL);

		
  

		
		zroot = FALSE;
		sideprev = side;
		imaxold=imax;
		imax = -1;
		istuck=-1;iunstuck=-1;
		maxfrac = ZERO;
		for(i = 0;  i < nrtfn; i++) {
			if ((ABS(grout[i])==ZERO)&& (iroots[i]!=MASKED))  istuck=i;
			if ((ABS(grout[i])> ZERO)&& (iroots[i]==MASKED))  iunstuck=i;
			if ((ABS(grout[i])> ZERO)&& (glo[i]*grout[i] <= ZERO)) {
				gfrac = ABS(grout[i]/(grout[i] - glo[i]));
				if (gfrac > maxfrac) { 
					maxfrac = gfrac;
					imax = i;
				}      
			}
		}

		if (imax>=0)
			sgnchg=TRUE;
		else if (istuck>=0) {
			sgnchg=TRUE;
			imax=istuck;
		}else  if (iunstuck>=0) {
			sgnchg=TRUE;
			imax=iunstuck;
		}else{
			sgnchg = FALSE;
			imax=imaxold;
		}

		if (sgnchg) {
			
			thi = tmid;
			for(i = 0; i < nrtfn; i++) ghi[i] = grout[i];
			side = 1;
			
			if (ABS(thi - tlo) <= ttol) break;
			continue;  
		}

		

		

		tlo = tmid;
		for(i = 0; i < nrtfn; i++) glo[i] = grout[i];
		side = 2;
		
		if (ABS(thi - tlo) <= ttol) break;

	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nrtfn; i++) {
		grout[i] = ghi[i];
		if (iroots[i]==MASKED){
			if (ABS(ghi[i]) != ZERO){ 
				iroots[i] = (ghi[i]> ZERO) ? 2 : -2;
				umroot=TRUE;
			}else{
				iroots[i]=0;
			}
		}else{
			if (ABS(ghi[i])== ZERO){ 
				iroots[i] = (glo[i]> ZERO) ? -1 : 1;
				zroot = TRUE;
			}else{
				if (glo[i]*ghi[i] < ZERO){
					iroots[i] = (ghi[i]>glo[i]) ? 1 : -1;
					zroot = TRUE;
				}else
					iroots[i]=0;
			}
		}    
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nrtfn; i++) {
			if ((iroots[i]==2)|| (iroots[i]==-2))  iroots[i]=0;
		}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0; j < Neq; j++) {

    

    
    N_VSetArrayPointer(DENSE_COL(Jac,j), jthCol);
    yj = y_data[j];
    ypj = yp_data[j];

    



    inc = MAX( srur * MAX( ABS(yj), ABS(hh*ypj) ) , ONE/ewt_data[j] );

    if (hh*ypj < ZERO) inc = -inc;
    inc = (yj + inc) - yj;

    
    if (constraints != NULL) {
      conj = cns_data[j];
      if (ABS(conj) == ONE)      {if((yj+inc)*conj <  ZERO) inc = -inc;}
      else if (ABS(conj) == TWO) {if((yj+inc)*conj <= ZERO) inc = -inc;}
    }

    
    y_data[j] += inc;
    yp_data[j] += c_j*inc;

    retval = res(tt, yy, yp, rtemp, rdata);
    nreD++;
    if (retval != 0) break;

    
    inc_inv = ONE/inc;
    N_VLinearSum(inc_inv, rtemp, -inc_inv, rr, jthCol);

    DENSE_COL(Jac,j) = N_VGetArrayPointer(jthCol);

         
    y_data[j] = yj;
    yp_data[j] = ypj;
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<nrt; i++) rootsfound[i] = iroots[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i <= expt; i++) prod *= base;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=1; j < n; j++) a[j] = a[0] + j * m;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k=0; k < n; k++) {

    col_k  = a[k];

    
    l=k;
    for(i=k+1; i < m; i++)
      if (ABS(col_k[i]) > ABS(col_k[l])) l=i;
    p[k] = l;

    
    if (col_k[l] == ZERO) return(k+1);
    
        
    if ( l!= k ) {
      for(i=0; i<n; i++) {
        temp = a[i][l];
        a[i][l] = a[i][k];
        a[i][k] = temp;
      }
    }

    





    mult = ONE/col_k[k];
    for(i=k+1; i < m; i++) col_k[i] *= mult;

    
    
    
    

    for(j=k+1; j < n; j++) {

      col_j = a[j];
      a_kj = col_j[k];

      
      

      if (a_kj != ZERO) {
	for(i=k+1; i < m; i++)
	  col_j[i] -= a_kj * col_k[i];
      }
    }
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k=0; k<n; k++) {
    pk = p[k];
    if(pk != k) {
      tmp = b[k];
      b[k] = b[pk];
      b[pk] = tmp;
    }
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k=0; k<n-1; k++) {
    col_k = a[k];
    for(i=k+1; i<n; i++) b[i] -= col_k[i]*b[k];
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = n-1; k > 0; k--) {
    col_k = a[k];
    b[k] /= col_k[k];
    for(i=0; i<k; i++) b[i] -= col_k[i]*b[k];
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0; j < n; j++) {
    col_j = a[j];
    for(i=0; i < m; i++)
      col_j[i] =  ZERO;
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0; j < n; j++) {
    a_col_j = a[j];
    b_col_j = b[j];
    for(i=0; i < m; i++)
      b_col_j[i] = a_col_j[i];
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0; j < n; j++) {
    col_j = a[j];
    for(i=0; i < m; i++)
      col_j[i] *= c;
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i < n; i++) a[i][i] += ONE;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i < m; i++) {
    for(j=0; j < n; j++) {
#if defined(SUNDIALS_EXTENDED_PRECISION)
      printf("%12Lg  ", a[j][i]);
#elif defined(SUNDIALS_DOUBLE_PRECISION)
      printf("%12lg  ", a[j][i]);
#else
      printf("%12g  ", a[j][i]);
#endif
    }
    printf("\n");
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < count; j++) {
    vs[j] = NULL;
    vs[j] = N_VCloneEmpty(w);
    if (vs[j] == NULL) {
      N_VDestroyVectorArray(vs, j-1);
      return(NULL);
    }
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < count; j++) {
    vs[j] = NULL;
    vs[j] = N_VClone(w);
    if (vs[j] == NULL) {
      N_VDestroyVectorArray(vs, j-1);
      return(NULL);
    }
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < count; j++) N_VDestroy(vs[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(;;){

    retry_nni = FALSE;

    nni++;

    


    if (inexact_ls) {
      eps = (eta + uround) * fnorm;
      if(!noMinEps) eps = MAX(epsmin, eps);
    }

    repeat_nni:

     

    ret = KINLinSolDrv(kin_mem);
    if (ret != KIN_SUCCESS) break;

    

    sflag = 0;

    if (strategy == KIN_NONE) {

      
      sflag = KINFullNewton(kin_mem, &fnormp, &f1normp, &maxStepTaken);

      
      if ((sflag == KIN_SYSFUNC_FAIL) || (sflag == KIN_REPTD_SYSFUNC_ERR)) {
        ret = sflag;
        break;
      }

    } else if (strategy == KIN_LINESEARCH) {

      
      sflag = KINLineSearch(kin_mem, &fnormp, &f1normp, &maxStepTaken);

      
      if (sflag == KIN_SYSFUNC_FAIL) {
        ret = sflag;
        break;
      }

      
      if (nbcf > mxnbcf) {
        ret = KIN_LINESEARCH_BCFAIL;
        break;
      }

    }

    

    if (callForcingTerm) {
        KINForcingTerm(kin_mem, fnormp);
    }

    fnorm = fnormp;

    

    ret = KINStop(kin_mem, strategy, maxStepTaken, sflag); 

    if (ret == RETRY_ITERATION) {
      retry_nni = TRUE;
      goto repeat_nni;
    }

    

    N_VScale(ONE, unew, uu);

    f1norm = f1normp;

    

    if (printfl>0)
      KINPrintInfo(kin_mem, PRNT_NNI, "KINSOL", "KINSol", INFO_NNI, nni, nfe, fnorm);

    if (ret != CONTINUE_ITERATIONS) break; 

    fflush(errfp);
    
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(;;){

    jacCurrent = FALSE;

    if ((sthrsh > ONEPT5) && setupNonNull) {
      retval = lsetup(kin_mem);
      jacCurrent = TRUE;
      nnilset = nni;
      nnilset_sub = nni;
      if (retval != 0) return(KIN_LSETUP_FAIL);
    }

    

    b = unew;
    x = pp;

    

    N_VScale(-ONE, fval, b);

    

    retval = lsolve(kin_mem, x, b, &res_norm);

    if (retval == 0)                          return(KIN_SUCCESS);
    else if (retval < 0)                      return(KIN_LSOLVE_FAIL);
    else if ((!setupNonNull) || (jacCurrent)) return(KIN_LINSOLV_NO_RECOVERY);

    


    sthrsh = TWO;

  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ircvr = 1; ircvr <= MAX_RECVR; ircvr++) {

    
    N_VLinearSum(ONE, uu, ONE, pp, unew);

    
    retval = func(unew, fval, f_data); nfe++;

    
    if (retval == 0) {fOK = TRUE; break;}

    
    else if (retval < 0) return(KIN_SYSFUNC_FAIL);

    
    ratio *= HALF;
    N_VScale(HALF, pp, pp);
    pnorm *= HALF;
    stepl = pnorm;
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ircvr = 1; ircvr <= MAX_RECVR; ircvr++) {

    
    N_VLinearSum(ONE, uu, ONE, pp, unew);

    
    retval = func(unew, fval, f_data); nfe++;

    
    if (retval == 0) {fOK = TRUE; break;}

    
    else if (retval < 0) return(KIN_SYSFUNC_FAIL);

    
    N_VScale(HALF, pp, pp);
    ratio *= HALF;
    pnorm *= HALF;
    rlmax = ONE;
    stepl = pnorm;

  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(;;) {
    
    

    alpha_cond = f1norm + (alpha * slpi * rl);

    if (printfl > 2)
      KINPrintInfo(kin_mem, PRNT_ALPHA, "KINSOL", "KINLinesearch", 
                   INFO_ALPHA, *fnormp, *f1normp, alpha_cond, rl);

    

    if ((*f1normp) <= alpha_cond) break;

    

    if (firstBacktrack) {

      rltmp = -slpi / (TWO * ((*f1normp) - f1norm - slpi));
      firstBacktrack = FALSE;

    } else {

      tmp1 = (*f1normp) - f1norm - (rl * slpi);
      tmp2 = f1nprv - f1norm - (rlprev * slpi);
      rl_a = ((ONE / (rl * rl)) * tmp1) - ((ONE / (rlprev * rlprev)) * tmp2);
      rl_b = ((-rlprev / (rl * rl)) * tmp1) + ((rl / (rlprev * rlprev)) * tmp2);
      tmp1 = ONE / (rl - rlprev);
      rl_a *= tmp1;
      rl_b *= tmp1;
      disc = (rl_b * rl_b) - (THREE * rl_a * slpi);

      if (ABS(rl_a) < uround) {        
        rltmp = -slpi / (TWO * rl_b);
      } else {                         
        rltmp = (-rl_b + RSqrt(disc)) / (THREE * rl_a);
      }

      if (rltmp > (HALF * rl)) rltmp = HALF * rl;

    }

    

    rlprev = rl;
    f1nprv = (*f1normp);
    pt1trl = POINT1 * rl;
    rl = MAX(pt1trl, rltmp);
    nbktrk_l++;

    

    N_VLinearSum(ONE, uu, rl, pp, unew);

    retval = func(unew, fval, f_data); nfe++;
    if (retval != 0) return(KIN_SYSFUNC_FAIL);

    *fnormp = N_VWL2Norm(fval, fscale);
    *f1normp = HALF * (*fnormp) * (*fnormp) ;

    

    if (rl < rlmin) {
      


      N_VScale(ONE, uu, unew);
      return(STEP_TOO_SMALL);
    }

  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < n; j++) {

    

    N_VSetArrayPointer(DENSE_COL(J,j), jthCol);

    ujsaved = u_data[j];
    ujscale = ONE/uscale_data[j];
    sign = (ujsaved >= ZERO) ? ONE : -ONE;
    inc = sqrt_relfunc*MAX(ABS(ujsaved), ujscale)*sign;
    u_data[j] += inc;

    retval = func(u, ftemp, f_data);
    if (retval != 0) return(-1); 

    u_data[j] = ujsaved;

    inc_inv = ONE/inc;
    N_VLinearSum(inc_inv, ftemp, -inc_inv, fu, jthCol);

  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<(m1*n1);i++) 
				{
					stk(l)[i]  = *((double *)(&il1[4]) + i);
				}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<(2*m1*n1);i++) 
				{
					stk(l)[i]  = *((double *)(&il1[4]) + i);
				}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<(m1*n1);i++) 
				{
					*((long *)(istk(il+4)) + i)  = *((long *)(&il1[4]) + i);
				}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<(m1*n1);i++) 
				{
					*((short *)(istk(il+4)) + i)  = *((short *)(&il1[4]) + i);
				}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<(m1*n1);i++) 
				{
					*((char *)(istk(il+4)) + i)  = *((char *)(&il1[4]) + i);
				}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<(m1*n1);i++) 
				{
					*((unsigned long *)(istk(il+4)) + i)  = *((unsigned long *)(&il1[4]) + i);
				}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<(m1*n1);i++) 
				{
					*((unsigned short *)(istk(il+4)) + i)  = *((unsigned short *)(&il1[4]) + i);
				}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<(m1*n1);i++) 
				{
					*((unsigned char *)(istk(il+4)) + i)  = *((unsigned char *)(&il1[4]) + i);
				}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<(n2h);i++) 
			{
				*((long *)(istk(il+4)) + i)  = *((long *)(&ilh2[4]) + i);
			}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<(m1*n1*p1);i++) 
						{
							stk(l)[i]  = *((double *)(&ilh3[4]) + i);
						}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<(2*m1*n1*p1);i++) 
						{
							stk(l)[i] = *((double *)(&ilh3[4]) + i);
						}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<(m1*n1*p1);i++) 
						{
							*((long *)(istk(il+4)) + i)  = *((long *)(&ilh3[4]) + i);
						}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<(m1*n1*p1);i++) 
						{
							*((short *)(istk(il+4)) + i)  = *((short *)(&ilh3[4]) + i);
						}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<(m1*n1*p1);i++) 
						{
							*((char *)(istk(il+4)) + i)  = *((char *)(&ilh3[4]) + i);
						}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<(m1*n1*p1);i++) 
						{
							*((unsigned long *)(istk(il+4)) + i)  = *((unsigned long *)(&ilh3[4]) + i);
						}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<(m1*n1*p1);i++) 
						{
							*((unsigned short *)(istk(il+4)) + i)  = *((unsigned short *)(&ilh3[4]) + i);
						}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<(m1*n1*p1);i++) 
						{
							*((unsigned char *)(istk(il+4)) + i)  = *((unsigned char *)(&ilh3[4]) + i);
						}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<(*istk(il+1));i++) 
	{
		stk(l)[i]  = (double) i*step_time;
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < Block.nin; i++)
        {
            if ((*((double *)(&ilh[4]) + i)) <= 0.)
            {
                Scierror(888, _("%s : Undetermined Size. in(%d)=%d. Please adjust your model.\n"), \
                         fname, i + 1, (int)(*((double *)(&ilh[4]) + i)));
                return 0;
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < (mh2 * nh2); i++)
        {
            if ((*((double *)(&ilh2[4]) + i)) <= 0.)
            {
                Scierror(888, _("%s : Undetermined Size. in2(%d)=%d. Please adjust your model.\n"), \
                         fname, i + 1, (int)(*((double *)(&ilh2[4]) + i)));
                FREE(Block.insz);
                FREE(Block.inptr);
                return 0;
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < (mh3 * nh3); i++)
        {
            if ((*((double *)(&ilh3[4]) + i)) <= 0.)
            {
                Scierror(888, _("%s : Undetermined Type. intyp(%d)=%d. Please adjust your model.\n"), \
                         fname, i + 1, (int)(*((double *)(&ilh3[4]) + i)));
                FREE(Block.insz);
                FREE(Block.inptr);
                return 0;
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < Block.nin; i++)
            {
                Block.insz[i] = (int) * ((double *)(&ilh[4]) + i);
                Block.insz[Block.nin + i] = (int) * ((double *)(&ilh2[4]) + i);
                type = *((double *)(&ilh3[4]) + i);
                if (type == 1) Block.insz[2 * Block.nin + i] = 10;
                else if (type == 2) Block.insz[2 * Block.nin + i] = 11;
                else if (type == 3) Block.insz[2 * Block.nin + i] = 84;
                else if (type == 4) Block.insz[2 * Block.nin + i] = 82;
                else if (type == 5) Block.insz[2 * Block.nin + i] = 81;
                else if (type == 6) Block.insz[2 * Block.nin + i] = 814;
                else if (type == 7) Block.insz[2 * Block.nin + i] = 812;
                else if (type == 8) Block.insz[2 * Block.nin + i] = 811;
                else Block.insz[2 * Block.nin + i] = 10;
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < Block.nin; i++)
            {
                Block.insz[i] = (int) * ((double *)(&ilh[4]) + i);
                Block.insz[Block.nin + i] = 1;
                Block.insz[2 * Block.nin + i] = 10;
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < Block.nin; i++)
        {
            switch (Block.insz[2 * Block.nin + i])
            {
                case 10  :
                    if ((Block.inptr[i] = (double *) MALLOC(Block.insz[i] * Block.insz[Block.nin + i] * sizeof(double))) == NULL)
                    {
                        for(j = 0; j < i; j++) FREE(Block.inptr[j]);
                        FREE(Block.inptr);
                        FREE(Block.insz);
                        Scierror(888, _("%s : Allocation error.\n"), fname);
                        return 0;
                    }
                    ptr_d = (double *) Block.inptr[i];
                    for(j = 0; j < Block.insz[i]*Block.insz[Block.nin + i]; j++)
                    {
                        ptr_d[j] = 0.;
                    }
                    break;
                case 11  :
                    if ((Block.inptr[i] = (double *) \
                                          MALLOC(2 * Block.insz[i] * Block.insz[Block.nin + i] * sizeof(double))) == NULL)
                    {
                        for(j = 0; j < i; j++) FREE(Block.inptr[j]);
                        FREE(Block.inptr);
                        FREE(Block.insz);
                        Scierror(888, _("%s : Allocation error.\n"), fname);
                        return 0;
                    }
                    ptr_d = (double *) Block.inptr[i];
                    for(j = 0; j < 2 * Block.insz[i]*Block.insz[Block.nin + i]; j++)
                    {
                        ptr_d[j] = 0.;
                    }
                    break;
                case 84  :
                    if ((Block.inptr[i] = (long *) \
                                          MALLOC(Block.insz[i] * Block.insz[Block.nin + i] * sizeof(long))) == NULL)
                    {
                        for(j = 0; j < i; j++) FREE(Block.inptr[j]);
                        FREE(Block.inptr);
                        FREE(Block.insz);
                        Scierror(888, _("%s : Allocation error.\n"), fname);
                        return 0;
                    }
                    ptr_l = (long *) Block.inptr[i];
                    for(j = 0; j < Block.insz[i]*Block.insz[Block.nin + i]; j++)
                    {
                        ptr_l[j] = 0;
                    }
                    break;
                case 82  :
                    if ((Block.inptr[i] = (short *) \
                                          MALLOC(Block.insz[i] * Block.insz[Block.nin + i] * sizeof(short))) == NULL)
                    {
                        for(j = 0; j < i; j++) FREE(Block.inptr[j]);
                        FREE(Block.inptr);
                        FREE(Block.insz);
                        Scierror(888, _("%s : Allocation error.\n"), fname);
                        return 0;
                    }
                    ptr_s = (short *) Block.inptr[i];
                    for(j = 0; j < Block.insz[i]*Block.insz[Block.nin + i]; j++)
                    {
                        ptr_s[j] = 0;
                    }
                    break;
                case 81  :
                    if ((Block.inptr[i] = (char *) \
                                          MALLOC(Block.insz[i] * Block.insz[Block.nin + i] * sizeof(char))) == NULL)
                    {
                        for(j = 0; j < i; j++) FREE(Block.inptr[j]);
                        FREE(Block.inptr);
                        FREE(Block.insz);
                        Scierror(888, _("%s : Allocation error.\n"), fname);
                        return 0;
                    }
                    ptr_c = (char *) Block.inptr[i];
                    for(j = 0; j < Block.insz[i]*Block.insz[Block.nin + i]; j++)
                    {
                        ptr_c[j] = 0;
                    }
                    break;
                case 814 :
                    if ((Block.inptr[i] = (unsigned long *) \
                                          MALLOC(Block.insz[i] * Block.insz[Block.nin + i] * sizeof(unsigned long))) == NULL)
                    {
                        for(j = 0; j < i; j++) FREE(Block.inptr[j]);
                        FREE(Block.inptr);
                        FREE(Block.insz);
                        Scierror(888, _("%s : Allocation error.\n"), fname);
                        return 0;
                    }
                    ptr_ul = (unsigned long *) Block.inptr[i];
                    for(j = 0; j < Block.insz[i]*Block.insz[Block.nin + i]; j++)
                    {
                        ptr_ul[j] = 0;
                    }
                    break;
                case 812 :
                    if ((Block.inptr[i] = (unsigned short *) \
                                          MALLOC(Block.insz[i] * Block.insz[Block.nin + i] * sizeof(unsigned short))) == NULL)
                    {
                        for(j = 0; j < i; j++) FREE(Block.inptr[j]);
                        FREE(Block.inptr);
                        FREE(Block.insz);
                        Scierror(888, _("%s : Allocation error.\n"), fname);
                        return 0;
                    }
                    ptr_us = (unsigned short *) Block.inptr[i];
                    for(j = 0; j < Block.insz[i]*Block.insz[Block.nin + i]; j++)
                    {
                        ptr_us[j] = 0;
                    }
                    break;
                case 811 :
                    if ((Block.inptr[i] = (unsigned char *) \
                                          MALLOC(Block.insz[i] * Block.insz[Block.nin + i] * sizeof(unsigned char))) == NULL)
                    {
                        for(j = 0; j < i; j++) FREE(Block.inptr[j]);
                        FREE(Block.inptr);
                        FREE(Block.insz);
                        Scierror(888, _("%s : Allocation error.\n"), fname);
                        return 0;
                    }
                    ptr_uc = (unsigned char *) Block.inptr[i];
                    for(j = 0; j < Block.insz[i]*Block.insz[Block.nin + i]; j++)
                    {
                        ptr_uc[j] = 0;
                    }
                    break;
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < Block.nout; i++)
        {
            if ((*((double *)(&ilh[4]) + i)) <= 0.)
            {
                Scierror(888, _("%s : Undetermined Size. out(%d)=%d. Please adjust your model.\n"), \
                         fname, i + 1, (int)(*((double *)(&ilh[4]) + i)));
                for(j = 0; j < Block.nin; j++) FREE(Block.inptr[j]);
                FREE(Block.inptr);
                FREE(Block.insz);
                return 0;
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < Block.nin; j++) FREE(Block.inptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < Block.nin; j++) FREE(Block.inptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < (mh2 * nh2); i++)
        {
            if ((*((double *)(&ilh2[4]) + i)) <= 0.)
            {
                Scierror(888, _("%s : Undetermined Size. out2(%d)=%d. Please adjust your model.\n"), \
                         fname, i + 1, (int)(*((double *)(&ilh2[4]) + i)));
                for(j = 0; j < Block.nin; j++) FREE(Block.inptr[j]);
                FREE(Block.insz);
                FREE(Block.inptr);
                FREE(Block.outptr);
                FREE(Block.outsz);
                return 0;
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < (mh3 * nh3); i++)
        {
            if ((*((double *)(&ilh3[4]) + i)) <= 0.)
            {
                Scierror(888, _("%s : Undetermined Type. outtyp(%d)=%d. Please adjust your model.\n"), \
                         fname, i + 1, (int)(*((double *)(&ilh3[4]) + i)));
                FREE(Block.insz);
                FREE(Block.inptr);
                FREE(Block.outptr);
                FREE(Block.outsz);
                return 0;
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < Block.nout; i++)
            {
                Block.outsz[i] = (int) * ((double *)(&ilh[4]) + i);
                Block.outsz[Block.nout + i] = (int) * ((double *)(&ilh2[4]) + i);
                type = *((double *)(&ilh3[4]) + i);
                if (type == 1) Block.outsz[2 * Block.nout + i] = 10;
                else if (type == 2) Block.outsz[2 * Block.nout + i] = 11;
                else if (type == 3) Block.outsz[2 * Block.nout + i] = 84;
                else if (type == 4) Block.outsz[2 * Block.nout + i] = 82;
                else if (type == 5) Block.outsz[2 * Block.nout + i] = 81;
                else if (type == 6) Block.outsz[2 * Block.nout + i] = 814;
                else if (type == 7) Block.outsz[2 * Block.nout + i] = 812;
                else if (type == 8) Block.outsz[2 * Block.nout + i] = 811;
                else Block.outsz[2 * Block.nout + i] = 10;
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < Block.nout; i++)
            {
                Block.outsz[i] = (int) * ((double *)(&ilh[4]) + i);
                Block.outsz[Block.nout + i] = 1;
                Block.outsz[2 * Block.nout + i] = 10;
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < Block.nout; i++)
        {
            switch (Block.outsz[2 * Block.nout + i])
            {
                case 10  :
                    if ((Block.outptr[i] = (double *) \
                                           MALLOC(Block.outsz[i] * Block.outsz[Block.nout + i] * sizeof(double))) == NULL)
                    {
                        for(j = 0; j < Block.nin; j++) FREE(Block.inptr[j]);
                        FREE(Block.inptr);
                        FREE(Block.insz);
                        for(j = 0; j < i; j++) FREE(Block.outptr[j]);
                        FREE(Block.outptr);
                        FREE(Block.outsz);
                        Scierror(888, _("%s : Allocation error.\n"), fname);
                        return 0;
                    }
                    ptr_d = (double *) Block.outptr[i];
                    for(j = 0; j < Block.outsz[i]*Block.outsz[Block.nout + i]; j++)
                    {
                        ptr_d[j] = 0.;
                    }
                    break;
                case 11  :
                    if ((Block.outptr[i] = (double *) \
                                           MALLOC(2 * Block.outsz[i] * Block.outsz[Block.nout + i] * sizeof(double))) == NULL)
                    {
                        for(j = 0; j < Block.nin; j++) FREE(Block.inptr[j]);
                        FREE(Block.inptr);
                        FREE(Block.insz);
                        for(j = 0; j < i; j++) FREE(Block.outptr[j]);
                        FREE(Block.outptr);
                        FREE(Block.outsz);
                        Scierror(888, _("%s : Allocation error.\n"), fname);
                        return 0;
                    }
                    ptr_d = (double *) Block.outptr[i];
                    for(j = 0; j < 2 * Block.outsz[i]*Block.outsz[Block.nout + i]; j++)
                    {
                        ptr_d[j] = 0.;
                    }
                    break;
                case 84  :
                    if ((Block.outptr[i] = (long *) \
                                           MALLOC(Block.outsz[i] * Block.outsz[Block.nout + i] * sizeof(long))) == NULL)
                    {
                        for(j = 0; j < Block.nin; j++) FREE(Block.inptr[j]);
                        FREE(Block.inptr);
                        FREE(Block.insz);
                        for(j = 0; j < i; j++) FREE(Block.outptr[j]);
                        FREE(Block.outptr);
                        FREE(Block.outsz);
                        Scierror(888, _("%s : Allocation error.\n"), fname);
                        return 0;
                    }
                    ptr_l = (long *) Block.outptr[i];
                    for(j = 0; j < Block.outsz[i]*Block.outsz[Block.nout + i]; j++)
                    {
                        ptr_l[j] = 0;
                    }
                    break;
                case 82  :
                    if ((Block.outptr[i] = (short *) \
                                           MALLOC(Block.outsz[i] * Block.outsz[Block.nout + i] * sizeof(short))) == NULL)
                    {
                        for(j = 0; j < Block.nin; j++) FREE(Block.inptr[j]);
                        FREE(Block.inptr);
                        FREE(Block.insz);
                        for(j = 0; j < i; j++) FREE(Block.outptr[j]);
                        FREE(Block.outptr);
                        FREE(Block.outsz);
                        Scierror(888, _("%s : Allocation error.\n"), fname);
                        return 0;
                    }
                    ptr_s = (short *) Block.outptr[i];
                    for(j = 0; j < Block.outsz[i]*Block.outsz[Block.nout + i]; j++)
                    {
                        ptr_s[j] = 0;
                    }
                    break;
                case 81  :
                    if ((Block.outptr[i] = (char *) \
                                           MALLOC(Block.outsz[i] * Block.outsz[Block.nout + i] * sizeof(char))) == NULL)
                    {
                        for(j = 0; j < Block.nin; j++) FREE(Block.inptr[j]);
                        FREE(Block.inptr);
                        FREE(Block.insz);
                        for(j = 0; j < i; j++) FREE(Block.outptr[j]);
                        FREE(Block.outptr);
                        FREE(Block.outsz);
                        Scierror(888, _("%s : Allocation error.\n"), fname);
                        return 0;
                    }
                    ptr_c = (char *) Block.outptr[i];
                    for(j = 0; j < Block.outsz[i]*Block.outsz[Block.nout + i]; j++)
                    {
                        ptr_c[j] = 0;
                    }
                    break;
                case 814 :
                    if ((Block.outptr[i] = (unsigned long *) \
                                           MALLOC(Block.outsz[i] * Block.outsz[Block.nout + i] * sizeof(unsigned long))) == NULL)
                    {
                        for(j = 0; j < Block.nin; j++) FREE(Block.inptr[j]);
                        FREE(Block.inptr);
                        FREE(Block.insz);
                        for(j = 0; j < i; j++) FREE(Block.outptr[j]);
                        FREE(Block.outptr);
                        FREE(Block.outsz);
                        Scierror(888, _("%s : Allocation error.\n"), fname);
                        return 0;
                    }
                    ptr_ul = (unsigned long *) Block.outptr[i];
                    for(j = 0; j < Block.outsz[i]*Block.outsz[Block.nout + i]; j++)
                    {
                        ptr_ul[j] = 0;
                    }
                    break;
                case 812 :
                    if ((Block.outptr[i] = (unsigned short *) \
                                           MALLOC(Block.outsz[i] * Block.outsz[Block.nout + i] * sizeof(unsigned short))) == NULL)
                    {
                        for(j = 0; j < Block.nin; j++) FREE(Block.inptr[j]);
                        FREE(Block.inptr);
                        FREE(Block.insz);
                        for(j = 0; j < i; j++) FREE(Block.outptr[j]);
                        FREE(Block.outptr);
                        FREE(Block.outsz);
                        Scierror(888, _("%s : Allocation error.\n"), fname);
                        return 0;
                    }
                    ptr_us = (unsigned short *) Block.outptr[i];
                    for(j = 0; j < Block.outsz[i]*Block.outsz[Block.nout + i]; j++)
                    {
                        ptr_us[j] = 0;
                    }
                    break;
                case 811 :
                    if ((Block.outptr[i] = (unsigned char *) \
                                           MALLOC(Block.outsz[i] * Block.outsz[Block.nout + i] * sizeof(unsigned char))) == NULL)
                    {
                        for(j = 0; j < Block.nin; j++) FREE(Block.inptr[j]);
                        FREE(Block.inptr);
                        FREE(Block.insz);
                        for(j = 0; j < i; j++) FREE(Block.outptr[j]);
                        FREE(Block.outptr);
                        FREE(Block.outsz);
                        Scierror(888, _("%s : Allocation error.\n"), fname);
                        return 0;
                    }
                    ptr_uc = (unsigned char *) Block.outptr[i];
                    for(j = 0; j < Block.outsz[i]*Block.outsz[Block.nout + i]; j++)
                    {
                        ptr_uc[j] = 0;
                    }
                    break;
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < Block.nin; j++) FREE(Block.inptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < Block.nout; j++) FREE(Block.outptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < Block.nevout; j++)
            {
                Block.evout[j] = *((double *)(&ilh2[4]) + j);
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < Block.nevout; j++)
            {
                Block.evout[j] = -1.0;
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < Block.nin; j++) FREE(Block.inptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < Block.nout; j++) FREE(Block.outptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < Block.nx; j++)
        {
            Block.x[j] = *((double *)(&ilh[4]) + j);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < Block.nin; j++) FREE(Block.inptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < Block.nout; j++) FREE(Block.outptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < Block.nx; j++)
        {
            Block.xd[j] = 0.;
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < Block.nin; j++) FREE(Block.inptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < Block.nout; j++) FREE(Block.outptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < Block.nx; j++)
        {
            Block.xprop[j] = 1;
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < Block.nin; j++) FREE(Block.inptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < Block.nout; j++) FREE(Block.outptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < Block.nx; j++)
        {
            Block.res[j] = 0.;
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < Block.nin; j++) FREE(Block.inptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < Block.nout; j++) FREE(Block.outptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < Block.nz; j++)
        {
            Block.z[j] = *((double *)(&ilh[4]) + j);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < Block.nin; j++) FREE(Block.inptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < Block.nout; j++) FREE(Block.outptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < Block.nin; j++) FREE(Block.inptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < Block.nout; j++) FREE(Block.outptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < Block.nin; j++) FREE(Block.inptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < Block.nout; j++) FREE(Block.outptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < mh * nh; i++)
        {
            ilh2 = (int *) (listentry(ilh, i + 1));
            mh2  = ilh2[1];
            nh2  = ilh2[2];
            Block.ozsz[i] = mh2;
            Block.ozsz[Block.noz + i] = nh2;
            if (ilh2[0] == 1)
            {
                if (ilh2[3] == 0)
                {
                    Block.oztyp[i] = 10;
                    if ((Block.ozptr[i] = (double *) MALLOC(mh2 * nh2 * sizeof(double))) == NULL)
                    {
                        for(j = 0; j < Block.nin; j++) FREE(Block.inptr[j]);
                        FREE(Block.inptr);
                        FREE(Block.insz);
                        for(j = 0; j < Block.nout; j++) FREE(Block.outptr[j]);
                        FREE(Block.outptr);
                        FREE(Block.outsz);
                        FREE(Block.evout);
                        FREE(Block.x);
                        FREE(Block.xd);
                        FREE(Block.xprop);
                        FREE(Block.res);
                        FREE(Block.z);
                        FREE(Block.ozsz);
                        FREE(Block.oztyp);
                        for(j = 0; j < i; j++) FREE(Block.ozptr[j]);
                        Scierror(888, _("%s : Allocation error.\n"), fname);
                        return 0;
                    }
                    ptr_d = (double *) Block.ozptr[i];
                    for(j = 0; j < mh2 * nh2; j++)
                    {
                        ptr_d[j] = *((double *)(&ilh2[4]) + j);
                    }
                }
                else if (ilh2[3] == 1)
                {
                    Block.oztyp[i] = 11;
                    if ((Block.ozptr[i] = (double *) MALLOC(2 * mh2 * nh2 * sizeof(double))) == NULL)
                    {
                        for(j = 0; j < Block.nin; j++) FREE(Block.inptr[j]);
                        FREE(Block.inptr);
                        FREE(Block.insz);
                        for(j = 0; j < Block.nout; j++) FREE(Block.outptr[j]);
                        FREE(Block.outptr);
                        FREE(Block.outsz);
                        FREE(Block.evout);
                        FREE(Block.x);
                        FREE(Block.xd);
                        FREE(Block.xprop);
                        FREE(Block.res);
                        FREE(Block.z);
                        FREE(Block.ozsz);
                        FREE(Block.oztyp);
                        for(j = 0; j < i; j++) FREE(Block.ozptr[j]);
                        Scierror(888, _("%s : Allocation error.\n"), fname);
                        return 0;
                    }
                    ptr_d = (double *) Block.ozptr[i];
                    for(j = 0; j < 2 * mh2 * nh2; j++)
                    {
                        ptr_d[j] = *((double *)(&ilh2[4]) + j);
                    }
                }
            }
            else if (ilh2[0] == 8)
            {
                if (ilh2[3] == 4)
                {
                    Block.oztyp[i] = 84;
                    if ((Block.ozptr[i] = (long *) MALLOC(mh2 * nh2 * sizeof(long))) == NULL)
                    {
                        for(j = 0; j < Block.nin; j++) FREE(Block.inptr[j]);
                        FREE(Block.inptr);
                        FREE(Block.insz);
                        for(j = 0; j < Block.nout; j++) FREE(Block.outptr[j]);
                        FREE(Block.outptr);
                        FREE(Block.outsz);
                        FREE(Block.evout);
                        FREE(Block.x);
                        FREE(Block.xd);
                        FREE(Block.xprop);
                        FREE(Block.res);
                        FREE(Block.z);
                        FREE(Block.ozsz);
                        FREE(Block.oztyp);
                        for(j = 0; j < i; j++) FREE(Block.ozptr[j]);
                        Scierror(888, _("%s : Allocation error.\n"), fname);
                        return 0;
                    }
                    ptr_l = (long *) Block.ozptr[i];
                    for(j = 0; j < mh2 * nh2; j++)
                    {
                        ptr_l[j] = *((long *)(&ilh2[4]) + j);
                    }
                }
                else if (ilh2[3] == 2)
                {
                    Block.oztyp[i] = 82;
                    if ((Block.ozptr[i] = (short *) MALLOC(mh2 * nh2 * sizeof(short))) == NULL)
                    {
                        for(j = 0; j < Block.nin; j++) FREE(Block.inptr[j]);
                        FREE(Block.inptr);
                        FREE(Block.insz);
                        for(j = 0; j < Block.nout; j++) FREE(Block.outptr[j]);
                        FREE(Block.outptr);
                        FREE(Block.outsz);
                        FREE(Block.evout);
                        FREE(Block.x);
                        FREE(Block.xd);
                        FREE(Block.xprop);
                        FREE(Block.res);
                        FREE(Block.z);
                        FREE(Block.ozsz);
                        FREE(Block.oztyp);
                        for(j = 0; j < i; j++) FREE(Block.ozptr[j]);
                        Scierror(888, _("%s : Allocation error.\n"), fname);
                        return 0;
                    }
                    ptr_s = (short *) Block.ozptr[i];
                    for(j = 0; j < mh2 * nh2; j++)
                    {
                        ptr_s[j] = *((short *)(&ilh2[4]) + j);
                    }
                }
                else if (ilh2[3] == 1)
                {
                    Block.oztyp[i] = 81;
                    if ((Block.ozptr[i] = (char *) MALLOC(mh2 * nh2 * sizeof(char))) == NULL)
                    {
                        for(j = 0; j < Block.nin; j++) FREE(Block.inptr[j]);
                        FREE(Block.inptr);
                        FREE(Block.insz);
                        for(j = 0; j < Block.nout; j++) FREE(Block.outptr[j]);
                        FREE(Block.outptr);
                        FREE(Block.outsz);
                        FREE(Block.evout);
                        FREE(Block.x);
                        FREE(Block.xd);
                        FREE(Block.xprop);
                        FREE(Block.res);
                        FREE(Block.z);
                        FREE(Block.ozsz);
                        FREE(Block.oztyp);
                        for(j = 0; j < i; j++) FREE(Block.ozptr[j]);
                        Scierror(888, _("%s : Allocation error.\n"), fname);
                        return 0;
                    }
                    ptr_c = (char *) Block.ozptr[i];
                    for(j = 0; j < mh2 * nh2; j++)
                    {
                        ptr_c[j] = *((char *)(&ilh2[4]) + j);
                    }
                }
                else if (ilh2[3] == 14)
                {
                    Block.oztyp[i] = 814;
                    if ((Block.ozptr[i] = (unsigned long *) MALLOC(mh2 * nh2 * sizeof(unsigned long))) == NULL)
                    {
                        for(j = 0; j < Block.nin; j++) FREE(Block.inptr[j]);
                        FREE(Block.inptr);
                        FREE(Block.insz);
                        for(j = 0; j < Block.nout; j++) FREE(Block.outptr[j]);
                        FREE(Block.outptr);
                        FREE(Block.outsz);
                        FREE(Block.evout);
                        FREE(Block.x);
                        FREE(Block.xd);
                        FREE(Block.xprop);
                        FREE(Block.res);
                        FREE(Block.z);
                        FREE(Block.ozsz);
                        FREE(Block.oztyp);
                        for(j = 0; j < i; j++) FREE(Block.ozptr[j]);
                        Scierror(888, _("%s : Allocation error.\n"), fname);
                        return 0;
                    }
                    ptr_ul = (unsigned long *) Block.ozptr[i];
                    for(j = 0; j < mh2 * nh2; j++)
                    {
                        ptr_ul[j] = *((unsigned long *)(&ilh2[4]) + j);
                    }
                }
                else if (ilh2[3] == 12)
                {
                    Block.oztyp[i] = 812;
                    if ((Block.ozptr[i] = (unsigned short *) MALLOC(mh2 * nh2 * sizeof(unsigned short))) == NULL)
                    {
                        for(j = 0; j < Block.nin; j++) FREE(Block.inptr[j]);
                        FREE(Block.inptr);
                        FREE(Block.insz);
                        for(j = 0; j < Block.nout; j++) FREE(Block.outptr[j]);
                        FREE(Block.outptr);
                        FREE(Block.outsz);
                        FREE(Block.evout);
                        FREE(Block.x);
                        FREE(Block.xd);
                        FREE(Block.xprop);
                        FREE(Block.res);
                        FREE(Block.z);
                        FREE(Block.ozsz);
                        FREE(Block.oztyp);
                        for(j = 0; j < i; j++) FREE(Block.ozptr[j]);
                        Scierror(888, _("%s : Allocation error.\n"), fname);
                        return 0;
                    }
                    ptr_us = (unsigned short *) Block.ozptr[i];
                    for(j = 0; j < mh2 * nh2; j++)
                    {
                        ptr_us[j] = *((unsigned short *)(&ilh2[4]) + j);
                    }
                }
                else if (ilh2[3] == 11)
                {
                    Block.oztyp[i] = 811;
                    if ((Block.ozptr[i] = (unsigned char *) MALLOC(mh2 * nh2 * sizeof(unsigned char))) == NULL)
                    {
                        for(j = 0; j < Block.nin; j++) FREE(Block.inptr[j]);
                        FREE(Block.inptr);
                        FREE(Block.insz);
                        for(j = 0; j < Block.nout; j++) FREE(Block.outptr[j]);
                        FREE(Block.outptr);
                        FREE(Block.outsz);
                        FREE(Block.evout);
                        FREE(Block.x);
                        FREE(Block.xd);
                        FREE(Block.xprop);
                        FREE(Block.res);
                        FREE(Block.z);
                        FREE(Block.ozsz);
                        FREE(Block.oztyp);
                        for(j = 0; j < i; j++) FREE(Block.ozptr[j]);
                        Scierror(888, _("%s : Allocation error.\n"), fname);
                        return 0;
                    }
                    ptr_uc = (unsigned char *) Block.ozptr[i];
                    for(j = 0; j < mh2 * nh2; j++)
                    {
                        ptr_uc[j] = *((unsigned char *)(&ilh2[4]) + j);
                    }
                }
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < Block.nin; j++) FREE(Block.inptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < Block.nout; j++) FREE(Block.outptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < Block.noz; j++) FREE(Block.ozptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < Block.nrpar; j++)
        {
            Block.rpar[j] = *((double *)(&ilh[4]) + j);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < Block.nin; j++) FREE(Block.inptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < Block.nout; j++) FREE(Block.outptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < Block.noz; j++) FREE(Block.ozptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < Block.nipar; j++)
        {
            Block.ipar[j] = (int) * ((double *)(&ilh[4]) + j);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < Block.nin; j++) FREE(Block.inptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < Block.nout; j++) FREE(Block.outptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < Block.noz; j++) FREE(Block.ozptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < Block.nin; j++) FREE(Block.inptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < Block.nout; j++) FREE(Block.outptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < Block.noz; j++) FREE(Block.ozptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < Block.nin; j++) FREE(Block.inptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < Block.nout; j++) FREE(Block.outptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < Block.noz; j++) FREE(Block.ozptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < mh * nh; i++)
        {
            ilh2 = (int *) (listentry(ilh, i + 1));
            mh2  = ilh2[1];
            nh2  = ilh2[2];
            Block.oparsz[i] = mh2;
            Block.oparsz[Block.nopar + i] = nh2;
            if (ilh2[0] == 1)
            {
                if (ilh2[3] == 0)
                {
                    Block.opartyp[i] = 10;
                    if ((Block.oparptr[i] = (double *) MALLOC(mh2 * nh2 * sizeof(double))) == NULL)
                    {
                        for(j = 0; j < Block.nin; j++) FREE(Block.inptr[j]);
                        FREE(Block.inptr);
                        FREE(Block.insz);
                        for(j = 0; j < Block.nout; j++) FREE(Block.outptr[j]);
                        FREE(Block.outptr);
                        FREE(Block.outsz);
                        FREE(Block.evout);
                        FREE(Block.x);
                        FREE(Block.xd);
                        FREE(Block.xprop);
                        FREE(Block.res);
                        FREE(Block.z);
                        FREE(Block.ozsz);
                        FREE(Block.oztyp);
                        for(j = 0; j < Block.noz; j++) FREE(Block.ozptr[j]);
                        FREE(Block.rpar);
                        FREE(Block.ipar);
                        FREE(Block.oparsz);
                        FREE(Block.opartyp);
                        for(j = 0; j < i; j++) FREE(Block.oparptr[j]);
                        Scierror(888, _("%s : Allocation error.\n"), fname);
                        return 0;
                    }
                    ptr_d = (double *) Block.oparptr[i];
                    for(j = 0; j < mh2 * nh2; j++)
                    {
                        ptr_d[j] = *((double *)(&ilh2[4]) + j);
                    }
                }
                else if (ilh2[3] == 1)
                {
                    Block.opartyp[i] = 11;
                    if ((Block.oparptr[i] = (double *) MALLOC(2 * mh2 * nh2 * sizeof(double))) == NULL)
                    {
                        for(j = 0; j < Block.nin; j++) FREE(Block.inptr[j]);
                        FREE(Block.inptr);
                        FREE(Block.insz);
                        for(j = 0; j < Block.nout; j++) FREE(Block.outptr[j]);
                        FREE(Block.outptr);
                        FREE(Block.outsz);
                        FREE(Block.evout);
                        FREE(Block.x);
                        FREE(Block.xd);
                        FREE(Block.xprop);
                        FREE(Block.res);
                        FREE(Block.z);
                        FREE(Block.ozsz);
                        FREE(Block.oztyp);
                        for(j = 0; j < Block.noz; j++) FREE(Block.ozptr[j]);
                        FREE(Block.rpar);
                        FREE(Block.ipar);
                        FREE(Block.oparsz);
                        FREE(Block.opartyp);
                        for(j = 0; j < i; j++) FREE(Block.oparptr[j]);
                        Scierror(888, _("%s : Allocation error.\n"), fname);
                        return 0;
                    }

                    ptr_d = (double *) Block.oparptr[i];
                    for(j = 0; j < 2 * mh2 * nh2; j++)
                    {
                        ptr_d[j] = *((double *)(&ilh2[4]) + j);
                    }
                }
            }
            else if (ilh2[0] == 8)
            {
                if (ilh2[3] == 4)
                {
                    Block.opartyp[i] = 84;
                    if ((Block.oparptr[i] = (long *) MALLOC(mh2 * nh2 * sizeof(long))) == NULL)
                    {
                        for(j = 0; j < Block.nin; j++) FREE(Block.inptr[j]);
                        FREE(Block.inptr);
                        FREE(Block.insz);
                        for(j = 0; j < Block.nout; j++) FREE(Block.outptr[j]);
                        FREE(Block.outptr);
                        FREE(Block.outsz);
                        FREE(Block.evout);
                        FREE(Block.x);
                        FREE(Block.xd);
                        FREE(Block.xprop);
                        FREE(Block.res);
                        FREE(Block.z);
                        FREE(Block.ozsz);
                        FREE(Block.oztyp);
                        for(j = 0; j < Block.noz; j++) FREE(Block.ozptr[j]);
                        FREE(Block.rpar);
                        FREE(Block.ipar);
                        FREE(Block.oparsz);
                        FREE(Block.opartyp);
                        for(j = 0; j < i; j++) FREE(Block.oparptr[j]);
                        Scierror(888, _("%s : Allocation error.\n"), fname);
                        return 0;
                    }
                    ptr_l = (long *) Block.oparptr[i];
                    for(j = 0; j < mh2 * nh2; j++)
                    {
                        ptr_l[j] = *((long *)(&ilh2[4]) + j);
                    }
                }
                else if (ilh2[3] == 2)
                {
                    Block.opartyp[i] = 82;
                    if ((Block.oparptr[i] = (short *) MALLOC(mh2 * nh2 * sizeof(short))) == NULL)
                    {
                        for(j = 0; j < Block.nin; j++) FREE(Block.inptr[j]);
                        FREE(Block.inptr);
                        FREE(Block.insz);
                        for(j = 0; j < Block.nout; j++) FREE(Block.outptr[j]);
                        FREE(Block.outptr);
                        FREE(Block.outsz);
                        FREE(Block.evout);
                        FREE(Block.x);
                        FREE(Block.xd);
                        FREE(Block.xprop);
                        FREE(Block.res);
                        FREE(Block.z);
                        FREE(Block.ozsz);
                        FREE(Block.oztyp);
                        for(j = 0; j < Block.noz; j++) FREE(Block.ozptr[j]);
                        FREE(Block.rpar);
                        FREE(Block.ipar);
                        FREE(Block.oparsz);
                        FREE(Block.opartyp);
                        for(j = 0; j < i; j++) FREE(Block.oparptr[j]);
                        Scierror(888, _("%s : Allocation error.\n"), fname);
                        return 0;
                    }
                    ptr_s = (short *) Block.oparptr[i];
                    for(j = 0; j < mh2 * nh2; j++)
                    {
                        ptr_s[j] = *((short *)(&ilh2[4]) + j);
                    }
                }
                else if (ilh2[3] == 1)
                {
                    Block.opartyp[i] = 81;
                    if ((Block.oparptr[i] = (char *) MALLOC(mh2 * nh2 * sizeof(char))) == NULL)
                    {
                        for(j = 0; j < Block.nin; j++) FREE(Block.inptr[j]);
                        FREE(Block.inptr);
                        FREE(Block.insz);
                        for(j = 0; j < Block.nout; j++) FREE(Block.outptr[j]);
                        FREE(Block.outptr);
                        FREE(Block.outsz);
                        FREE(Block.evout);
                        FREE(Block.x);
                        FREE(Block.xd);
                        FREE(Block.xprop);
                        FREE(Block.res);
                        FREE(Block.z);
                        FREE(Block.ozsz);
                        FREE(Block.oztyp);
                        for(j = 0; j < Block.noz; j++) FREE(Block.ozptr[j]);
                        FREE(Block.rpar);
                        FREE(Block.ipar);
                        FREE(Block.oparsz);
                        FREE(Block.opartyp);
                        for(j = 0; j < i; j++) FREE(Block.oparptr[j]);
                        Scierror(888, _("%s : Allocation error.\n"), fname);
                        return 0;
                    }
                    ptr_c = (char *) Block.oparptr[i];
                    for(j = 0; j < mh2 * nh2; j++)
                    {
                        ptr_c[j] = *((char *)(&ilh2[4]) + j);
                    }
                }
                else if (ilh2[3] == 14)
                {
                    Block.opartyp[i] = 814;
                    if ((Block.oparptr[i] = (unsigned long *) MALLOC(mh2 * nh2 * sizeof(unsigned long))) == NULL)
                    {
                        for(j = 0; j < Block.nin; j++) FREE(Block.inptr[j]);
                        FREE(Block.inptr);
                        FREE(Block.insz);
                        for(j = 0; j < Block.nout; j++) FREE(Block.outptr[j]);
                        FREE(Block.outptr);
                        FREE(Block.outsz);
                        FREE(Block.evout);
                        FREE(Block.x);
                        FREE(Block.xd);
                        FREE(Block.xprop);
                        FREE(Block.res);
                        FREE(Block.z);
                        FREE(Block.ozsz);
                        FREE(Block.oztyp);
                        for(j = 0; j < Block.noz; j++) FREE(Block.ozptr[j]);
                        FREE(Block.rpar);
                        FREE(Block.ipar);
                        FREE(Block.oparsz);
                        FREE(Block.opartyp);
                        for(j = 0; j < i; j++) FREE(Block.oparptr[j]);
                        Scierror(888, _("%s : Allocation error.\n"), fname);
                        return 0;
                    }
                    ptr_ul = (unsigned long *) Block.oparptr[i];
                    for(j = 0; j < mh2 * nh2; j++)
                    {
                        ptr_ul[j] = *((unsigned long *)(&ilh2[4]) + j);
                    }
                }
                else if (ilh2[3] == 12)
                {
                    Block.opartyp[i] = 812;
                    if ((Block.oparptr[i] = (unsigned short *) MALLOC(mh2 * nh2 * sizeof(unsigned short))) == NULL)
                    {
                        for(j = 0; j < Block.nin; j++) FREE(Block.inptr[j]);
                        FREE(Block.inptr);
                        FREE(Block.insz);
                        for(j = 0; j < Block.nout; j++) FREE(Block.outptr[j]);
                        FREE(Block.outptr);
                        FREE(Block.outsz);
                        FREE(Block.evout);
                        FREE(Block.x);
                        FREE(Block.xd);
                        FREE(Block.xprop);
                        FREE(Block.res);
                        FREE(Block.z);
                        FREE(Block.ozsz);
                        FREE(Block.oztyp);
                        for(j = 0; j < Block.noz; j++) FREE(Block.ozptr[j]);
                        FREE(Block.rpar);
                        FREE(Block.ipar);
                        FREE(Block.oparsz);
                        FREE(Block.opartyp);
                        for(j = 0; j < i; j++) FREE(Block.oparptr[j]);
                        Scierror(888, _("%s : Allocation error.\n"), fname);
                        return 0;
                    }
                    ptr_us = (unsigned short *) Block.oparptr[i];
                    for(j = 0; j < mh2 * nh2; j++)
                    {
                        ptr_us[j] = *((unsigned short *)(&ilh2[4]) + j);
                    }
                }
                else if (ilh2[3] == 11)
                {
                    Block.opartyp[i] = 811;
                    if ((Block.oparptr[i] = (unsigned char *) MALLOC(mh2 * nh2 * sizeof(unsigned char))) == NULL)
                    {
                        for(j = 0; j < Block.nin; j++) FREE(Block.inptr[j]);
                        FREE(Block.inptr);
                        FREE(Block.insz);
                        for(j = 0; j < Block.nout; j++) FREE(Block.outptr[j]);
                        FREE(Block.outptr);
                        FREE(Block.outsz);
                        FREE(Block.evout);
                        FREE(Block.x);
                        FREE(Block.xd);
                        FREE(Block.xprop);
                        FREE(Block.res);
                        FREE(Block.z);
                        FREE(Block.ozsz);
                        FREE(Block.oztyp);
                        for(j = 0; j < Block.noz; j++) FREE(Block.ozptr[j]);
                        FREE(Block.rpar);
                        FREE(Block.ipar);
                        FREE(Block.oparsz);
                        FREE(Block.opartyp);
                        for(j = 0; j < i; j++) FREE(Block.oparptr[j]);
                        Scierror(888, _("%s : Allocation error.\n"), fname);
                        return 0;
                    }
                    ptr_uc = (unsigned char *) Block.oparptr[i];
                    for(j = 0; j < mh2 * nh2; j++)
                    {
                        ptr_uc[j] = *((unsigned char *)(&ilh2[4]) + j);
                    }
                }
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < Block.nin; j++) FREE(Block.inptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < Block.nout; j++) FREE(Block.outptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < Block.noz; j++) FREE(Block.ozptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < Block.nopar; j++) FREE(Block.oparptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < Block.nin; j++) FREE(Block.inptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < Block.nout; j++) FREE(Block.outptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < Block.noz; j++) FREE(Block.ozptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < Block.nopar; j++) FREE(Block.oparptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < Block.ng; j++)
        {
            Block.g[j] = 0.;
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < Block.nin; j++) FREE(Block.inptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < Block.nout; j++) FREE(Block.outptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < Block.noz; j++) FREE(Block.ozptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < Block.nopar; j++) FREE(Block.oparptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < Block.ng; j++)
        {
            Block.jroot[j] = 0;
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < Block.nin; j++) FREE(Block.inptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < Block.nout; j++) FREE(Block.outptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < Block.noz; j++) FREE(Block.ozptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < Block.nopar; j++) FREE(Block.oparptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < Block.nmode; j++)
        {
            Block.mode[j] = 0;
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < Block.nin; j++) FREE(Block.inptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < Block.nout; j++) FREE(Block.outptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < Block.noz; j++) FREE(Block.ozptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < Block.nopar; j++) FREE(Block.oparptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < Block.nin; j++) FREE(Block.inptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < Block.nout; j++) FREE(Block.outptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < Block.noz; j++) FREE(Block.ozptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < Block.nopar; j++) FREE(Block.oparptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<n_lnksz;j++)
							{
								lnksz[j]=(int) IC_CHAR(M1.D)[j*2];
								lnksz[n_lnksz+j]=(int) IC_CHAR(M1.D)[2*j+1];
							}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<2*n_lnksz;j++)
								lnksz[j]=(int) IC_CHAR(M1.D)[j];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<n_lnksz;j++)
							{
								lnksz[j]=(int) IC_INT16(M1.D)[j*2];
								lnksz[n_lnksz+j]=(int) IC_INT16(M1.D)[2*j+1];
							}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<2*n_lnksz;j++)
								lnksz[j]=(int) IC_INT16(M1.D)[j];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<n_lnksz;j++)
							{
								lnksz[j]=(int) IC_INT32(M1.D)[j*2];
								lnksz[n_lnksz+j]=(int) IC_INT32(M1.D)[2*j+1];
							}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<2*n_lnksz;j++)
								lnksz[j]=(int) IC_INT32(M1.D)[j];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<n_lnksz;j++)
							{
								lnksz[j]=(int) IC_UCHAR(M1.D)[j*2];
								lnksz[n_lnksz+j]=(int) IC_UCHAR(M1.D)[2*j+1];
							}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<2*n_lnksz;j++)
								lnksz[j]=(int) IC_UCHAR(M1.D)[j];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<n_lnksz;j++)
							{
								lnksz[j]=(int) IC_UINT16(M1.D)[j*2];
								lnksz[n_lnksz+j]=(int) IC_UINT16(M1.D)[2*j+1];
							}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<2*n_lnksz;j++)
								lnksz[j]=(int) IC_UINT16(M1.D)[j];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<n_lnksz;j++)
							{
								lnksz[j]=(int) IC_UINT32(M1.D)[j*2];
								lnksz[n_lnksz+j]=(int) IC_UINT32(M1.D)[2*j+1];
							}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<2*n_lnksz;j++)
								lnksz[j]=(int) IC_UINT32(M1.D)[j];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<n_lnksz;j++)
			{
				lnksz[j]=(int) ((double *) stk(l1))[j*2];
				lnksz[n_lnksz+j]=(int) ((double *) stk(l1))[2*j+1];
			}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<2*n_lnksz;j++)
				lnksz[j]=(int) ((double *) stk(l1))[j];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<n_lnktyp;j++)
							lnktyp[j]=(int) IC_CHAR(M2.D)[j];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<n_lnktyp;j++)
							lnktyp[j]=(int) IC_INT16(M2.D)[j];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<n_lnktyp;j++)
							lnktyp[j]=(int) IC_INT32(M2.D)[j];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<n_lnktyp;j++)
							lnktyp[j]=(int) IC_UCHAR(M2.D)[j];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<n_lnktyp;j++)
							lnktyp[j]=(int) IC_UINT16(M2.D)[j];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<n_lnktyp;j++)
							lnktyp[j]=(int) IC_UINT32(M2.D)[j];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<n_lnktyp;j++)
			lnktyp[j]=(int) ((double *) stk(l2))[j];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<n_lnktyp;i++)
	{
		nm=lnksz[i]*lnksz[i+n_lnktyp];
		switch (lnktyp[i])
		{
		case 1  : if ((ptr_d=MALLOC(nm*sizeof(double)))==NULL)
				  {
					  ierr=-1;
					  break;
				  }
				  for(j=0;j<nm;j++) ptr_d[j]=0;
				  CreateListVarFromPtr(3,i+1,MATRIX_OF_DOUBLE_DATATYPE,&lnksz[i],&lnksz[i+n_lnktyp], &ptr_d);
				  FREE(ptr_d);
				  break;

		case 2  : if ((ptr_d=MALLOC(2*nm*sizeof(double)))==NULL)
				  {
					  ierr=-1;
					  break;
				  }
				  for(j=0;j<2*nm;j++) ptr_d[j]=0;
				  ptr_dc = &ptr_d[nm];
				  CreateListCVarFromPtr(3,i+1,MATRIX_OF_DOUBLE_DATATYPE,(j=1,&j),&lnksz[i],&lnksz[i+n_lnktyp],&ptr_d,&ptr_dc);
				  FREE(ptr_d);
				  break;

		case 3  : if ((ptr_i=MALLOC(nm*sizeof(int)))==NULL)
				  {
					  ierr=-1;
					  break;
				  }
				  for(j=0;j<nm;j++) ptr_i[j]=0;
				  M3.m = lnksz[i];
				  M3.n = lnksz[i+n_lnktyp];
				  M3.it = 4;
				  M3.l = -1;
				  M3.D = ptr_i;
				  CreateListVarFromPtr(3,i+1,MATRIX_OF_VARIABLE_SIZE_INTEGER_DATATYPE,&M3.m,&M3.n,&M3);
				  FREE(ptr_i);
				  break;

		case 4  : if ((ptr_s=MALLOC(nm*sizeof(short)))==NULL)
				  {
					  ierr=-1;
					  break;
				  }
				  for(j=0;j<nm;j++) ptr_s[j]=0;
				  M3.m = lnksz[i];
				  M3.n = lnksz[i+n_lnktyp];
				  M3.it = 2;
				  M3.l = -1;
				  M3.D = ptr_s;
				  CreateListVarFromPtr(3,i+1,MATRIX_OF_VARIABLE_SIZE_INTEGER_DATATYPE,&M3.m,&M3.n,&M3);
				  FREE(ptr_s);
				  break;

		case 5  : if ((ptr_c=MALLOC(nm*sizeof(char)))==NULL)
				  {
					  ierr=-1;
					  break;
				  }
				  for(j=0;j<nm;j++) ptr_c[j]=0;
				  M3.m = lnksz[i];
				  M3.n = lnksz[i+n_lnktyp];
				  M3.it = 1;
				  M3.l = -1;
				  M3.D = ptr_c;
				  CreateListVarFromPtr(3,i+1,MATRIX_OF_VARIABLE_SIZE_INTEGER_DATATYPE,&M3.m,&M3.n,&M3);
				  FREE(ptr_c);
				  break;

		case 6  : if ((ptr_ui=MALLOC(nm*sizeof(unsigned int)))==NULL)
				  {
					  ierr=-1;
					  break;
				  }
				  for(j=0;j<nm;j++) ptr_ui[j]=0;
				  M3.m = lnksz[i];
				  M3.n = lnksz[i+n_lnktyp];
				  M3.it = 14;
				  M3.l = -1;
				  M3.D = ptr_ui;
				  CreateListVarFromPtr(3,i+1,MATRIX_OF_VARIABLE_SIZE_INTEGER_DATATYPE,&M3.m,&M3.n,&M3);
				  FREE(ptr_ui);
				  break;

		case 7  : if ((ptr_us=MALLOC(nm*sizeof(unsigned short)))==NULL)
				  {
					  ierr=-1;
					  break;
				  }
				  for(j=0;j<nm;j++) ptr_us[j]=0;
				  M3.m = lnksz[i];
				  M3.n = lnksz[i+n_lnktyp];
				  M3.it = 12;
				  M3.l = -1;
				  M3.D = ptr_us;
				  CreateListVarFromPtr(3,i+1,MATRIX_OF_VARIABLE_SIZE_INTEGER_DATATYPE,&M3.m,&M3.n,&M3);
				  FREE(ptr_us);
				  break;

		case 8  : if ((ptr_uc=MALLOC(nm*sizeof(unsigned char)))==NULL)
				  {
					  ierr=-1;
					  break;
				  }
				  for(j=0;j<nm;j++) ptr_uc[j]=0;
				  M3.m = lnksz[i];
				  M3.n = lnksz[i+n_lnktyp];
				  M3.it = 11;
				  M3.l = -1;
				  M3.D = ptr_uc;
				  CreateListVarFromPtr(3,i+1,MATRIX_OF_VARIABLE_SIZE_INTEGER_DATATYPE,&M3.m,&M3.n,&M3);
				  FREE(ptr_uc);
				  break;

		default : if ((ptr_d=MALLOC(nm*sizeof(double)))==NULL)
				  {
					  ierr=-1;
					  break;
				  }
				  for(j=0;j<nm;j++) ptr_d[j]=0;
				  CreateListVarFromPtr(3,i+1,MATRIX_OF_DOUBLE_DATATYPE,&lnksz[i],&lnksz[i+n_lnktyp], &ptr_d);
				  FREE(ptr_d);
				  break;
		}

		if (ierr==-1)
		{
			Scierror(999,_("%s : No more free memory.\n"),fname);
			FREE(lnksz);
			FREE(lnktyp);
			return 0;
		}
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<(m1e7*n1e7);i++) l_state_evtspt[i]= (int) ((double *)(il_state_evtspt+4))[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<(m1e8*n1e8);i++) l_pointi[i]= (int) ((double *)(il_pointi+4))[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<(m_xptr*n_xptr);i++) l_sim_xptr[i]= (int) ((double *)(il_sim_xptr+4))[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<(m_zptr*n_zptr);i++) l_sim_zptr[i]= (int) ((double *)(il_sim_zptr+4))[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<(m_ozptr*n_ozptr);i++) l_sim_ozptr[i]= (int) ((double *)(il_sim_ozptr+4))[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<(m_zcptr*n_zcptr);i++) l_sim_zcptr[i]= (int) ((double *)(il_sim_zcptr+4))[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<(m_inpptr*n_inpptr);i++) l_sim_inpptr[i]= (int) ((double *)(il_sim_inpptr+4))[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<(m_outptr*n_outptr);i++) l_sim_outptr[i]= (int) ((double *)(il_sim_outptr+4))[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<(m_inplnk*n_inplnk);i++) l_sim_inplnk[i]= (int) ((double *)(il_sim_inplnk+4))[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<(m_outlnk*n_outlnk);i++) l_sim_outlnk[i]= (int) ((double *)(il_sim_outlnk+4))[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<(m_rpptr*n_rpptr);i++) l_sim_rpptr[i]= (int) ((double *)(il_sim_rpptr+4))[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<(m_ipar*n_ipar);i++) l_sim_ipar[i]= (int) ((double *)(il_sim_ipar+4))[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<(m_ipptr*n_ipptr);i++) l_sim_ipptr[i]= (int) ((double *)(il_sim_ipptr+4))[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<(m_opptr*n_opptr);i++) l_sim_opptr[i]= (int) ((double *)(il_sim_opptr+4))[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<(m_clkptr*n_clkptr);i++) l_sim_clkptr[i]= (int) ((double *)(il_sim_clkptr+4))[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<(m_ordptr*n_ordptr);i++) l_sim_ordptr[i]= (int) ((double *)(il_sim_ordptr+4))[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<(m_execlk*n_execlk);i++) l_sim_execlk[i]= (int) ((double *)(il_sim_execlk+4))[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<(m_ordclk*n_ordclk);i++) l_sim_ordclk[i]= (int) ((double *)(il_sim_ordclk+4))[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<(m_cord*n_cord);i++) l_sim_cord[i]= (int) ((double *)(il_sim_cord+4))[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<(m_oord*n_oord);i++) l_sim_oord[i]= (int) ((double *)(il_sim_oord+4))[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<(m_zord*n_zord);i++) l_sim_zord[i]= (int) ((double *)(il_sim_zord+4))[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<(m_critev*n_critev);i++) l_sim_critev[i]= (int) ((double *)(il_sim_critev+4))[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<(m_nb*n_nb);i++) l_sim_nb[i]= (int) ((double *)(il_sim_nb+4))[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<(m_ztyp*n_ztyp);i++) l_sim_ztyp[i]= (int) ((double *)(il_sim_ztyp+4))[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<(m_nblk*n_nblk);i++) l_sim_nblk[i]= (int) ((double *)(il_sim_ztyp+4))[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<(m_ndcblk*n_ndcblk);i++) l_sim_ndcblk[i]= (int) ((double *)(il_sim_ndcblk+4))[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<(m_subscr*n_subscr);i++) l_sim_subscr[i]= (int) ((double *)(il_sim_subscr+4))[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<(m_funtyp*n_funtyp);i++) l_sim_funtyp[i]= (int) ((double *)(il_sim_funtyp+4))[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<(m_iord*n_iord);i++) l_sim_iord[i]= (int) ((double *)(il_sim_iord+4))[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<(m_modptr*n_modptr);i++) l_sim_modptr[i]= (int) ((double *)(il_sim_modptr+4))[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<4;i++) simpar[i]=l_tol[i];simpar[4]=0;simpar[5]=0;simpar[6]=0;}



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<5;i++) simpar[i]=l_tol[i];simpar[5]=0;simpar[6]=0;}



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<6;i++) simpar[i]=l_tol[i];simpar[6]=0;}



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<7;i++) simpar[i]=l_tol[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<nblk;i++)
	{
		ilf=iadr(lf); 
		subheader=(int *)(listentry(il_sim_fun,i+1));
		
		if ((subheader[0]==11)|(subheader[0]==13)) lfunpt[i]=-lf;
		
		else if(subheader[0]==10)
		{
			sz_str=subheader[5]-1; 
			C2F(cha1).buf[0]=' ';
			C2F(cvstr)(&sz_str,&subheader[6],&C2F(cha1).buf[0],(j=1,&j),sz_str); 
			C2F(cha1).buf[sz_str]='\0';
			ifun=C2F(funnum)(C2F(cha1).buf); 
			
			if (ifun>0) lfunpt[i]=ifun;
			
			else 
			{
				C2F(namstr)(id,&subheader[6],&sz_str,(j=0,&j));
				C2F(com).fin=0;
				C2F(funs)(id);
				if ((C2F(com).fun==-1)|(C2F(com).fun==-2)) lfunpt[i]=-*Lstk(C2F(com).fin);
				else
				{
					C2F(curblk).kfun=i+1;
					Scierror(888, _("%s : unknown block : %s\n"),fname,C2F(cha1).buf);
					FREE(lfunpt);
					freeparam;
					return 0;
				}
			}
		}
		else
		{
			C2F(iop).err=4;
			Scierror(44,_("%s : error\n"),fname);
			FREE(lfunpt);
			freeparam;
			return 0;
		}
		lf=lf+*istk(il4e2+3+i)-*istk(il4e2+i+2);
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<noz;j++)
		{
			subheader=(int *)(listentry(il_state_oz,j+1));

			switch (subheader[0]) 
			{
				
			case 1  : switch (subheader[3])
					  {
			case 0  : oztyp[j]=SCSREAL_N;  
				ozsz[j]=subheader[1];
				ozsz[j+noz]=subheader[2];
				oz[j]=(SCSREAL_COP *)(subheader+4);
				break;

			case 1  : oztyp[j]=SCSCOMPLEX_N;  
				ozsz[j]=subheader[1];
				ozsz[j+noz]=subheader[2];
				oz[j]=(SCSCOMPLEX_COP *)(subheader+4);
				break;

			default : oztyp[j]=SCSUNKNOW_N;
				ozsz[j]=il_state_oz[3+j]-il_state_oz[2+j];
				ozsz[j+noz]=1;
				oz[j]=(SCSUNKNOW_COP *)subheader;
				break;
					  }
					  break;

					  
			case 8  : switch (subheader[3])
					  {
			case 1  : oztyp[j]=SCSINT8_N;  
				ozsz[j]=subheader[1];
				ozsz[j+noz]=subheader[2];
				oz[j]=(SCSINT8_COP *)(subheader+4);
				break;

			case 2  : oztyp[j]=SCSINT16_N;  
				ozsz[j]=subheader[1];
				ozsz[j+noz]=subheader[2];
				oz[j]=(SCSINT16_COP *)(subheader+4);
				break;

			case 4  : oztyp[j]=SCSINT32_N;  
				ozsz[j]=subheader[1];
				ozsz[j+noz]=subheader[2];
				oz[j]=(SCSINT32_COP *)(subheader+4);
				break;

			case 11 : oztyp[j]=SCSUINT8_N; 
				ozsz[j]=subheader[1];
				ozsz[j+noz]=subheader[2];
				oz[j]=(SCSUINT8_COP *)(subheader+4);
				break;

			case 12 : oztyp[j]=SCSUINT16_N; 
				ozsz[j]=subheader[1];
				ozsz[j+noz]=subheader[2];
				oz[j]=(SCSUINT16_COP *)(subheader+4);
				break;

			case 14 : oztyp[j]=SCSUINT32_N; 
				ozsz[j]=subheader[1];
				ozsz[j+noz]=subheader[2];
				oz[j]=(SCSUINT32_COP *)(subheader+4);
				break;

			default : oztyp[j]=SCSUNKNOW_N;
				ozsz[j]=il_state_oz[3+j]-il_state_oz[2+j];
				ozsz[j+noz]=1;
				oz[j]=(SCSUNKNOW_COP *)subheader;
				break;
					  }
					  break;

			default : oztyp[j]=SCSUNKNOW_N;
				ozsz[j]=il_state_oz[3+j]-il_state_oz[2+j];
				ozsz[j+noz]=1;
				oz[j]=(SCSUNKNOW_COP *)subheader;
				break;
			}
		}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<nopar;j++)
		{
			subheader=(int *)(listentry(il_sim_opar,j+1));

			switch (subheader[0]) 
			{
				
			case 1  : switch (subheader[3])
					  {
			case 0  : opartyp[j]=SCSREAL_N;  
				oparsz[j]=subheader[1];
				oparsz[j+nopar]=subheader[2];
				opar[j]=(SCSREAL_COP *)(subheader+4);
				break;

			case 1  : opartyp[j]=SCSCOMPLEX_N;  
				oparsz[j]=subheader[1];
				oparsz[j+nopar]=subheader[2];
				opar[j]=(SCSCOMPLEX_COP *)(subheader+4);
				break;

			default : opartyp[j]=SCSUNKNOW_N;
				oparsz[j]=il_sim_opar[3+j]-il_sim_opar[2+j];
				oparsz[j+nopar]=1;
				opar[j]=(SCSUNKNOW_COP *)subheader;
				break;
					  }
					  break;

					  
			case 8  : switch (subheader[3])
					  {
			case 1  : opartyp[j]=SCSINT8_N;  
				oparsz[j]=subheader[1];
				oparsz[j+nopar]=subheader[2];
				opar[j]=(SCSINT8_COP *)(subheader+4);
				break;

			case 2  : opartyp[j]=SCSINT16_N;  
				oparsz[j]=subheader[1];
				oparsz[j+nopar]=subheader[2];
				opar[j]=(SCSINT16_COP *)(subheader+4);
				break;

			case 4  : opartyp[j]=SCSINT32_N;  
				oparsz[j]=subheader[1];
				oparsz[j+nopar]=subheader[2];
				opar[j]=(SCSINT32_COP *)(subheader+4);
				break;

			case 11 : opartyp[j]=SCSUINT8_N; 
				oparsz[j]=subheader[1];
				oparsz[j+nopar]=subheader[2];
				opar[j]=(SCSUINT8_COP *)(subheader+4);
				break;

			case 12 : opartyp[j]=SCSUINT16_N; 
				oparsz[j]=subheader[1];
				oparsz[j+nopar]=subheader[2];
				opar[j]=(SCSUINT16_COP *)(subheader+4);
				break;

			case 14 : opartyp[j]=SCSUINT32_N; 
				oparsz[j]=subheader[1];
				oparsz[j+nopar]=subheader[2];
				opar[j]=(SCSUINT32_COP *)(subheader+4);
				break;

			default : opartyp[j]=SCSUNKNOW_N;
				oparsz[j]=il_sim_opar[3+j]-il_sim_opar[2+j];
				oparsz[j+nopar]=1;
				opar[j]=(SCSUNKNOW_COP *)subheader;
				break;
					  }
					  break;

			default : opartyp[j]=SCSUNKNOW_N;
				oparsz[j]=il_sim_opar[3+j]-il_sim_opar[2+j];
				oparsz[j+nopar]=1;
				opar[j]=(SCSUNKNOW_COP *)subheader;
				break;
			}
		}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<nlnk;j++) 
		{
			subheader=(int *)(listentry(il_state_outtb,j+1)); 
			outtbsz[j]=subheader[1]; 
			outtbsz[j+nlnk]=subheader[2];

			switch (subheader[0]) 
			{
				
			case 1  : switch (subheader[3])
					  {
			case 0  : outtbtyp[j]=SCSREAL_N;  
				outtbptr[j]=(SCSREAL_COP *)(subheader+4);
				break;

			case 1  : outtbtyp[j]=SCSCOMPLEX_N;  
				outtbptr[j]=(SCSCOMPLEX_COP *)(subheader+4);
				break;

			default : Scierror(888,_("%s : error. Type %d of double scalar matrix not yet supported for outtb.\n"),\
						  fname,subheader[3]);
				FREE(outtbptr); FREE(outtbtyp); FREE(outtbsz);
				FREE(opar); FREE(oparsz); FREE(opartyp);
				FREE(oz); FREE(ozsz); FREE(oztyp);
				FREE(lfunpt);
				freeparam;
				FREE(outtb_elem);
				break;
					  }
					  break;

					  
			case 8  : switch (subheader[3])
					  {
			case 1  : outtbtyp[j]=SCSINT8_N;  
				outtbptr[j]=(SCSINT8_COP *)(subheader+4);
				break;

			case 2  : outtbtyp[j]=SCSINT16_N;  
				outtbptr[j]=(SCSINT16_COP *)(subheader+4);
				break;

			case 4  : outtbtyp[j]=SCSINT32_N;  
				outtbptr[j]=(SCSINT32_COP *)(subheader+4);
				break;

			case 11 : outtbtyp[j]=SCSUINT8_N; 
				outtbptr[j]=(SCSUINT8_COP *)(subheader+4);
				break;

			case 12 : outtbtyp[j]=SCSUINT16_N; 
				outtbptr[j]=(SCSUINT16_COP *)(subheader+4);
				break;

			case 14 : outtbtyp[j]=SCSUINT32_N; 
				outtbptr[j]=(SCSUINT32_COP *)(subheader+4);
				break;

			default : Scierror(888,\
						  _("%s : error. Type %d of int scalar matrix not yet supported for outtb.\n"),\
						  fname,subheader[3]);
				FREE(outtbptr); FREE(outtbtyp); FREE(outtbsz);
				FREE(opar); FREE(oparsz); FREE(opartyp);
				FREE(oz); FREE(ozsz); FREE(oztyp);
				FREE(lfunpt);
				freeparam;
				FREE(outtb_elem);
				break;
					  }
					  break;

			default : Scierror(888,_("%s : error. Type %d not yet supported for outtb.\n"),fname,subheader[0]);
				FREE(outtbptr); FREE(outtbtyp); FREE(outtbsz);
				FREE(opar); FREE(oparsz); FREE(opartyp);
				FREE(oz); FREE(ozsz); FREE(oztyp);
				FREE(lfunpt);
				freeparam;
				FREE(outtb_elem);
				return 0;
				break;
			}

			
			k=nelem;
			nelem+=outtbsz[j]*outtbsz[j+nlnk];
			if ((outtb_elem=(outtb_el *) REALLOC(outtb_elem,nelem*sizeof(outtb_el)))==NULL)
			{
				Scierror(999,_("%s : No more free memory.\n"),fname);
				FREE(outtbptr); FREE(outtbtyp); FREE(outtbsz);
				FREE(opar); FREE(oparsz); FREE(opartyp);
				FREE(oz); FREE(ozsz); FREE(oztyp);
				FREE(lfunpt);
				freeparam;
				FREE(outtb_elem);
				return 0;
			}
			for(i=0;i<outtbsz[j]*outtbsz[j+nlnk];i++)
			{
				outtb_elem[k+i].lnk=j;
				outtb_elem[k+i].pos=i;
			}
		}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<Rhs;i++)
	{
		loc->state[i].iwhere = C2F(intersci).iwhere[i];
		loc->state[i].ntypes = C2F(intersci).ntypes[i];
		loc->state[i].lad    = C2F(intersci).lad[i];
		loc->state[i].lhsvar = C2F(intersci).lhsvar[i];
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<Rhs;i++)
	{
		C2F(intersci).iwhere[i] = loc->state[i].iwhere ;
		C2F(intersci).ntypes[i] = loc->state[i].ntypes ;
		C2F(intersci).lad[i]    = loc->state[i].lad    ;
		C2F(intersci).lhsvar[i] = loc->state[i].lhsvar ;
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<(m1e7*n1e7);i++) ((double *)(il_state_evtspt+4))[i] = (double) l_state_evtspt[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<(m1e8*n1e8);i++) ((double *)(il_pointi+4))[i] = (double) l_pointi[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<*n;i++) {
		for(j=0;j<(int) w[i];j++) {
			ww[k]=v[i];
			k=k+1;
		}
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<n;i++) {
		if (v[i]>0) *nw=*nw+(int) v[i];
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < nentries; j++)
        {
            if (j == nentries - 1) sciprint("\"%s\" ", entry[j]);
            else sciprint("\"%s\", ", entry[j]);
            i++;
            if (i == 6)
            {
                sciprint("\n");
                i = 0;
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < m1 * n1; j++)
    {
        sz_str = il_str[5 + j] - il_str[4 + j]; 
        
        if (j == 0)
            ptr_pos = 5 + m1 * n1;
        else
            ptr_pos += il_str[5 + j - 1] - il_str[4 + j - 1];
        l_str = &il_str[ptr_pos]; 
        
        C2F(cha1).buf[0] = ' ';
        C2F(cvstr)(&sz_str, &l_str[0], &C2F(cha1).buf[0], (i = 1, &i), sz_str);
        C2F(cha1).buf[sz_str] = '\0';
        
        ierr = TRUE;
        for(i = 0; i < nentries; i++)
        {
            if (strcmp(C2F(cha1).buf, entry[i]) == 0)
            {
                
                if ((dyn_char[j + 1] = MALLOC(sizeof(char) * strlen(entry[i]) + 1)) == NULL)
                {
                    FREE(dyn_char);
                    Scierror(999, _("%s : No more memory.\n"), fname);
                    return 0;
                }
                else strcpy(dyn_char[j + 1], entry[i]);

                ierr = FALSE;
                break;
            }
        }
        
        if (ierr == TRUE)
        {
            FREE(dyn_char);
            Scierror(999, _("%s : Undefined field in string matrix position : %d.\n"), fname, j + 1);
            return 0;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < m1 * n1; j++)
    {
        sz_str = il_str[5 + j] - il_str[4 + j]; 
        
        if (j == 0)
            ptr_pos = 5 + m1 * n1;
        else
            ptr_pos += il_str[5 + j - 1] - il_str[4 + j - 1];
        l_str = &il_str[ptr_pos]; 
        
        C2F(cha1).buf[0] = ' ';
        C2F(cvstr)(&sz_str, &l_str[0], &C2F(cha1).buf[0], (i = 1, &i), sz_str);
        C2F(cha1).buf[sz_str] = '\0';

        


        if (strcmp(C2F(cha1).buf, "x") == 0)          
            ierr = CopyVarFromlistentry(j + 2, get_il_state(), 2);
        else if (strcmp(C2F(cha1).buf, "z") == 0)     
            ierr = CopyVarFromlistentry(j + 2, get_il_state(), 3);
        else if (strcmp(C2F(cha1).buf, "oz") == 0)    
            ierr = CopyVarFromlistentry(j + 2, get_il_state(), 4);
        else if (strcmp(C2F(cha1).buf, "outtb") == 0) 
            ierr = CopyVarFromlistentry(j + 2, get_il_state(), 9);
        else if (strcmp(C2F(cha1).buf, "tevts") == 0) 
            ierr = CopyVarFromlistentry(j + 2, get_il_state(), 6);

        


        if (strcmp(C2F(cha1).buf, "opar") == 0)          
            ierr = CopyVarFromlistentry(j + 2, get_il_sim(), 15);

        


        else if ((strcmp(C2F(cha1).buf, "mod") == 0)      || 
                 (strcmp(C2F(cha1).buf, "nmod") == 0)     || 
                 (strcmp(C2F(cha1).buf, "iz") == 0)       || 
                 (strcmp(C2F(cha1).buf, "nblk") == 0)     || 
                 (strcmp(C2F(cha1).buf, "izptr") == 0)    || 
                 (strcmp(C2F(cha1).buf, "outtbptr") == 0) || 
                 (strcmp(C2F(cha1).buf, "outtbsz") == 0)  || 
                 (strcmp(C2F(cha1).buf, "outtbtyp") == 0) || 
                 (strcmp(C2F(cha1).buf, "nlnk") == 0)     || 
                 (strcmp(C2F(cha1).buf, "nsubs") == 0)    || 
                 (strcmp(C2F(cha1).buf, "nevts") == 0)    || 
                 (strcmp(C2F(cha1).buf, "niord") == 0)    || 
                 (strcmp(C2F(cha1).buf, "noord") == 0)    || 
                 (strcmp(C2F(cha1).buf, "nzord") == 0)    || 
                 (strcmp(C2F(cha1).buf, "funptr") == 0)   || 
                 (strcmp(C2F(cha1).buf, "ncord") == 0)    || 
                 (strcmp(C2F(cha1).buf, "nordptr") == 0)  || 
                 (strcmp(C2F(cha1).buf, "iwa") == 0)      || 
                 (strcmp(C2F(cha1).buf, "ng") == 0)       || 
                 (strcmp(C2F(cha1).buf, "nx") == 0)       || 
                 (strcmp(C2F(cha1).buf, "nz") == 0)       || 
                 (strcmp(C2F(cha1).buf, "noz") == 0)      || 
                 (strcmp(C2F(cha1).buf, "ozptr") == 0)    || 
                 (strcmp(C2F(cha1).buf, "ozsz") == 0)     || 
                 (strcmp(C2F(cha1).buf, "oztyp") == 0)    || 
                 (strcmp(C2F(cha1).buf, "nelem") == 0)    || 
                 (strcmp(C2F(cha1).buf, "xptr") == 0)     || 
                 (strcmp(C2F(cha1).buf, "zcptr") == 0)    || 
                 (strcmp(C2F(cha1).buf, "zptr") == 0)     || 
                 (strcmp(C2F(cha1).buf, "rpptr") == 0)    || 
                 (strcmp(C2F(cha1).buf, "ipar") == 0)     || 
                 (strcmp(C2F(cha1).buf, "ipptr") == 0)    || 
                 (strcmp(C2F(cha1).buf, "opptr") == 0)    || 
                 (strcmp(C2F(cha1).buf, "oparsz") == 0)   || 
                 (strcmp(C2F(cha1).buf, "opartyp") == 0)  || 
                 (strcmp(C2F(cha1).buf, "inpptr") == 0)   || 
                 (strcmp(C2F(cha1).buf, "outptr") == 0)   || 
                 (strcmp(C2F(cha1).buf, "inplnk") == 0)   || 
                 (strcmp(C2F(cha1).buf, "outlnk") == 0)   || 
                 (strcmp(C2F(cha1).buf, "subs") == 0)     || 
                 (strcmp(C2F(cha1).buf, "iord") == 0)     || 
                 (strcmp(C2F(cha1).buf, "oord") == 0)     || 
                 (strcmp(C2F(cha1).buf, "zord") == 0)     || 
                 (strcmp(C2F(cha1).buf, "funtyp") == 0)   || 
                 (strcmp(C2F(cha1).buf, "ztyp") == 0)     || 
                 (strcmp(C2F(cha1).buf, "cord") == 0)     || 
                 (strcmp(C2F(cha1).buf, "ordclk") == 0)   || 
                 (strcmp(C2F(cha1).buf, "clkcpr") == 0)   || 
                 (strcmp(C2F(cha1).buf, "ordptr") == 0)   || 
                 (strcmp(C2F(cha1).buf, "critev") == 0)   || 
                 
                 (strcmp(C2F(cha1).buf, "evtspt") == 0)   || 
                 (strcmp(C2F(cha1).buf, "pointi") == 0)     
                )
        {
            
            ierr = getscicosvarsfromimport(C2F(cha1).buf, &ptr, &nv, &mv);

            
            if (ierr == TRUE)
            {
                l_tmp = I_INT32; 
                CreateVar(j + 2, MATRIX_OF_VARIABLE_SIZE_INTEGER_DATATYPE, &nv, &mv, &l_tmp); 
                il_tmp = (int *) istk(l_tmp);      
                ptr_int = (int *) ptr;             
                for(i = 0; i < nv * mv; i++) il_tmp[i] = ptr_int[i]; 
            }
        }

        


        else if ((strcmp(C2F(cha1).buf, "rpar") == 0)   || 
                 (strcmp(C2F(cha1).buf, "g") == 0)      || 
                 (strcmp(C2F(cha1).buf, "t0") == 0)     || 
                 (strcmp(C2F(cha1).buf, "tf") == 0)     || 
                 (strcmp(C2F(cha1).buf, "Atol") == 0)   || 
                 (strcmp(C2F(cha1).buf, "rtol") == 0)   || 
                 (strcmp(C2F(cha1).buf, "ttol") == 0)   || 
                 (strcmp(C2F(cha1).buf, "deltat") == 0) || 
                 (strcmp(C2F(cha1).buf, "hmax") == 0)     
                )
        {
            
            ierr = getscicosvarsfromimport(C2F(cha1).buf, &ptr, &nv, &mv);

            
            if (ierr == TRUE)
            {
                ptr_dd = (double *) ptr;
                CreateVar(j + 2, MATRIX_OF_DOUBLE_DATATYPE, &nv, &mv, &l_tmp); 
                for(i = 0; i < nv * mv; i++) *stk(l_tmp + i) = ptr_dd[i]; 
            }
        }

        


        else if ((strcmp(C2F(cha1).buf, "blocks") == 0)
                )
        {
            
            ierr = getscicosvarsfromimport(C2F(cha1).buf, &ptr, &nv, &mv);

            
            if (ierr == TRUE)
            {
                
                ptr_scsblk = (scicos_block *) ptr;

                
                strcpy(C2F(cha1).buf, "nblk");
                ierr = getscicosvarsfromimport(C2F(cha1).buf, &ptr, &nv, &mv);
                ptr_int = (int *) ptr; 
                nblk = *ptr_int;

                
                strcpy(C2F(cha1).buf, "ng");
                ierr = getscicosvarsfromimport(C2F(cha1).buf, &ptr, &nv, &mv);
                ptr_int = (int *) ptr; 
                ng = *ptr_int;

                
                strcpy(C2F(cha1).buf, "xptr");
                ierr = getscicosvarsfromimport(C2F(cha1).buf, &ptr, &nv, &mv);
                ptr_int = (int *) ptr;
                xptr = ptr_int;

                
                strcpy(C2F(cha1).buf, "zcptr");
                ierr = getscicosvarsfromimport(C2F(cha1).buf, &ptr, &nv, &mv);
                ptr_int = (int *) ptr;
                zcptr = ptr_int;

                
                strcpy(C2F(cha1).buf, "x");
                ierr = getscicosvarsfromimport(C2F(cha1).buf, &ptr, &nv, &mv);
                ptr_dd = (double *) ptr;
                x = ptr_dd;
                xd = &x[xptr[nblk] - 1];

                
                strcpy(C2F(cha1).buf, "g");
                ierr = getscicosvarsfromimport(C2F(cha1).buf, &ptr, &nv, &mv);
                ptr_dd = (double *) ptr;
                g = ptr_dd;

                
                strcpy(C2F(cha1).buf, "funtyp");
                ierr = getscicosvarsfromimport(C2F(cha1).buf, &ptr, &nv, &mv);
                funtyp = (int *) ptr;

                
                Topsave = Top;     
                Top = Top - Rhs + 1 + j; 

                for(k = 0; k < nblk; k++)
                {
                    

                    
                    i = -1;

                    


                    if (ptr_scsblk[k].nx != 0)
                    {
                        if (ptr_scsblk[k].x != &x[xptr[k] - 1])
                        {
                            
                            
                            i = k;
                        }
                    }
                    if (ptr_scsblk[k].ng != 0)
                    {
                        if ((ptr_scsblk[k].g != &g[zcptr[k] - 1]) && (ptr_scsblk[k].g != &x[xptr[k] - 1]))
                        {
                            
                            
                            i = k;
                        }
                    }
                    
                    ierr = createblklist(&ptr_scsblk[k], &errc, i, k + 1);

                    
                    if (ierr == FALSE)
                    {
                        Top = Topsave;
                        break;
                    }
                }
                
                if (ierr == TRUE)
                {
                    C2F(mklist)(&nblk);
                    Top = Topsave; 
                    i = 1;
                    CreateVar(j + 2, LIST_DATATYPE, &nblk, &i, &l_tmp); 
                }

            }
        }

        


        else if ((strcmp(C2F(cha1).buf, "outtb_elem") == 0)) 
        {
            
            ierr = getscicosvarsfromimport(C2F(cha1).buf, &ptr, &nv, &mv);

            
            if (ierr == TRUE)
            {
                l_tmp = I_INT32; 
                CreateVar(j + 2, MATRIX_OF_VARIABLE_SIZE_INTEGER_DATATYPE, &nv, &mv, &l_tmp); 
                il_tmp = (int *) istk(l_tmp);      
                ptr_elem = (outtb_el *) ptr;       
                for(i = 0; i < nv; i++) 
                {
                    il_tmp[i] = ptr_elem[i].lnk + 1; 
                    il_tmp[nv + i] = ptr_elem[i].pos + 1;
                }
            }
        }

        


        if (ierr != TRUE)
        {
            Scierror(999, _("%s : Error.\n"), fname);
            FREE(dyn_char);
            return 0;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0; j < m1*n1; j++)
		{
			sz_str = il_str[5+j]-il_str[4+j]; 
			
			if (j==0)
			{
				ptr_pos = 5+m1*n1;
			}
			else
			{
				ptr_pos += il_str[5+j-1]-il_str[4+j-1];
			}
			l_str = &il_str[ptr_pos]; 
			
			C2F(cha1).buf[0]=' ';
			C2F(cvstr)(&sz_str,&l_str[0],&C2F(cha1).buf[0],(i=1,&i),sz_str);
			C2F(cha1).buf[sz_str]='\0';

			sprintf(coserr.buf,"%s\n%s",coserr.buf,C2F(cha1).buf);
		}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < Block.noz; j++) FREE(Block.ozptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < Block.nin; j++) FREE(Block.inptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < Block.nout; j++) FREE(Block.outptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < Block.nopar; j++) FREE(Block.oparptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < Block.noz; j++) FREE(Block.ozptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < Block.nin; j++) FREE(Block.inptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < Block.nout; j++) FREE(Block.outptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < Block.nopar; j++) FREE(Block.oparptr[j]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k=0; k<size1; k++) 
	{
		if (header1[k] != header2[k]) 
		{
			*stk(l3)=1;
			PutLhsVar();
			return 0;
		}
		*stk(l3)=0;
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < sizelibraries; i++)
			{
				int sizemacrosLib = 0;
				char **macrosLib = getlistmacrosfromlibrary(libraries[i], &sizemacrosLib);

				if (macrosLib && (sizemacrosLib > 0) )
				{
					int j = 0;
					for(j = 0; j < sizemacrosLib; j++)
					{
						if (strcmp(macrosLib[j], macro) == 0)
						{
							nbLibsWhereIsMacro++;
							if (nbLibsWhereIsMacro == 1)
							{
								returnedArray = (char**)MALLOC(sizeof(char*)* nbLibsWhereIsMacro);
							}
							else
							{
								returnedArray = (char**)REALLOC(returnedArray, sizeof(char*)*(nbLibsWhereIsMacro));
							}
							returnedArray[nbLibsWhereIsMacro - 1] = strdup(libraries[i]);
						}
					}
					freeArrayOfString(macrosLib, sizemacrosLib);
				}
			}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=1;j<Lused+1;++j)
			{
				char *NameVariable = getLocalNamefromId(j);
				if (C2F(objptr)(NameVariable,&lw,&fin,(unsigned long)strlen(NameVariable)))
				{
					int *header = istk( iadr(*Lstk(fin)));
					if ( (header) && (header[0] == sci_lib ) )
					{
						librarieslist[i] = strdup(NameVariable);
						i++;
					}
				}
				if (NameVariable) {FREE(NameVariable);NameVariable = NULL;}
			}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=1;j<Lused+1;++j)
	{
		int lw = 0; int fin = 0;
		char *NameVariable = getLocalNamefromId(j);

		if (C2F(objptr)(NameVariable,&lw,&fin,(unsigned long)strlen(NameVariable)))
		{
			int *header = istk( iadr(*Lstk(fin)));
			if ( (header) && (header[0] == sci_lib ) )  nbrlibraries++;
		}
		if (NameVariable) {FREE(NameVariable);NameVariable = NULL;}
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = sizemacrosinlibraries; i < nbMacros; i++)
                {
                    macroslist[i] = strdup(macrosonstack[j++]);
                }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < sizelocalvariables; i++)
        {
            int iType = 0;
            SciErr sciErr = getNamedVarType(pvApiCtx, localvariables[i], &iType);
            if (!sciErr.iErr)
            {
                if (iType == sci_c_function) nbMacros++;
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < sizelocalvariables; i++)
            {
                int iType = 0;
                SciErr sciErr = getNamedVarType(pvApiCtx, localvariables[i], &iType);
                if (!sciErr.iErr)
                {
                    if (iType == sci_c_function)
                    {
                        macroslist[nbMacros++] = strdup(localvariables[i]);
                    }
                }
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0;i < sizelibraries; i++)
                {
                    int j = 0;
                    char **macros = NULL;
                    int sizemacros = 0;

                    macros = getlistmacrosfromlibrary(libraries[i],&sizemacros);

                    if (macros)
                    {
                        for(j=0;j<sizemacros;j++)
                        {
                            dictionary[m] = macros[j];
                            m++;
                        }
                        FREE(macros);
                        macros = NULL;
                    }
                }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0;i < sizelibraries; i++)
        {
            if (libraries[i])
            {
                char **macros = NULL;
                int sizemacros = 0;

                macros = getlistmacrosfromlibrary(libraries[i],&sizemacros);
                if (macros)
                {
                    sizedictionary = sizedictionary + sizemacros;

                    freeArrayOfString(macros, sizemacros);
                }

                FREE(libraries[i]);
                libraries[i] = NULL;
            }

        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(fin = *SizeStrings - 1; fin > 0; fin--)
    {
        int Sorted = FALSE;

        for(i = 0; i < fin; i++)
        {
            if (Strings[i])
            {
                if(strcmp(Strings[i], Strings[i+1]) == 0)
                {
                    FREE(Strings[i + 1]);
                    Strings[i + 1] = NULL;
                    Sorted = TRUE;
                    newsize--;
                }
            }
            else
            {
                Strings[i] = Strings[i+1];
                Strings[i+1] = NULL;
                Sorted = TRUE;
            }
        }

        if (!Sorted)
        {
            break;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(; i < rows * cols; i++)
    {
        mlist_type[i] = (char *)MALLOC(sizeof(char) * (lengths[i] + 1));
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nb && !cmp; i++)
    {
        cmp = !strcmp(mlist_type[0], str[i]);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 0; k < *n; ++k)
      c[k] = a[k] + b[k];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 0; k < *n*(*m); ++k)
      {
	if ( *itra == 1)
	  br[k] = ai[k];
	else
	  br[k] = 0.0;
	bi[k] = ar[k];
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0; i < *m ; i++)
    {
      sciprint("Row %d, %d non zero elements\n",i+1,mnel[i]);
      for( j = 0; j < mnel[i]; j++)
	{
	  if (*it == 1)
	      sciprint("(%d,%d) -> %f +i%f\n",i+1,icol[iof+j],
		       ar[iof+j],ai[iof+j]);
	  else
	      sciprint("(%d,%d) -> %f\n",i+1,icol[iof+j],
		       ar[iof+j]);
	}
      iof += mnel[i];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0; i < *m1 ; i++)
    {
      for( j = 0; j < mnel1[i]; j++)
	{
	  if (*it1 == 1)
	    {
	      ai2[iof+j] = 2*ai1[iof+j];
	    }
	  ar2[iof+j] = 2*ar1[iof+j];
	}
      iof += mnel1[i];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < *m1 ; i++ )
    mnel2[i]= mnel1[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < *nel1 ; i++)
    icol2[i] = icol1[i] ;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0; i < *m ; i++)
    {
      sciprint("Row %d, %d non zero elements\n",i+1,mnel[i]);
      for( j = 0; j < mnel[i]; j++)
	{
	  if (*it == 1)
	      sciprint("(%d,%d) -> %d +i%d\n",i+1,icol[iof+j],
		       ar[iof+j],ai[iof+j]);
	  else
	      sciprint("(%d,%d) -> %d\n",i+1,icol[iof+j],
		       ar[iof+j]);
	}
      iof += mnel[i];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0; i < *m1 ; i++)
    {
      for( j = 0; j < mnel1[i]; j++)
	{
	  if (*it1 == 1)
	    {
	      ai2[iof+j] = 2*ai1[iof+j];
	    }
	  ar2[iof+j] = 2*ar1[iof+j];
	}
      iof += mnel1[i];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < *m1 ; i++ )
    mnel2[i]= mnel1[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < *nel1 ; i++)
    icol2[i] = icol1[i] ;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0; i < *m ; i++)
    {
      for( j = 0; j < mnel[i]; j++)
	{
	  if (*it == 1)
	    {
	      (*x)->I[iof+j] = 2*ai[iof+j];
	    }
	  (*x)->R[iof+j] = 2*ar[iof+j];
	}
      iof += mnel[i];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < *m ; i++ )
    (*x)->mnel[i]= mnel[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < *nel ; i++)
    (*x)->icol[i] = icol[i] ;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i=0; i < (*m)*(*n) ; i++) ar[i]= (ar[i]==1)? 0:1;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0; i < *m*(*n) ; i++) ar2[i] =  (ar1[i]==1)? 0:1;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0; i < (*n) ; i++)
    for( j = 0; j < (*m) ; j++)
      (*ar1)[i+(*n)*j] = i ;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i= 0 ; i < (*m)*(*n) ; i++) (*a)[i] = i ;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i= 0 ; i < (*m)*(*n) ; i++) (*a)->val[i] = i ;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < *n; i++)
      op[i]= (*ip)->val[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i= 0 ; i < (*m)*(*n) ; i++) (*a)[i] = i ;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 0; k < *n*(*m); ++k)
      ar[k]= 2*ar[k];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 0; k < *n; ++k)
      c[k] = a[k] + b[k];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0; i < *m*(*n) ; i++)
    ar2[i] = 2*ar1[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0; i < *m*(*n) ; i++)
    ar2[i] = 2*ar1[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0; i < *m*(*n) ; i++)
    (*ar1)[i] = i;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i=0  ; i< nstring ; i++)
    {
      (*a)[i] = (char *) malloc ((8)*sizeof(char));
      sprintf((*a)[i],"char %d",i);
      *err=0;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < *m*(*n) ; i++)
    {
      char *loc = (*a)[i];
      for( j = 0 ; j < strlen(loc); j++)
	if ( loc[j] =='a' ) loc[j] ='o';
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < *n; i++)
	  op[i]=(*ip)[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < *n; i++) op[i]=(*ip)[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < *n; i++)  op[i]=(*ip)[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < *n; i++)  op[i]=(double)(*ip)[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < *n; i++)
      op[i]=(double)(*ip)[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < *n; i++)  op[i]=(double)(*ip)[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < *n; i++)
      op[i]=(double)(*ip)[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < *n; i++)  op[i]= (*ip)[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < *n; i++)
      op[i]= (*ip)[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < *n; j++) {
    for(i = 0; i < *m; i++) {
      l=(int)strlen((*ip)[ie]);
      sciptr[ie+5]=sciptr[ie+4]+l;
      if (5 + *m * *n + sciptr[ie+5] > *max) {
        *ierr = 1;
        return;
      }
      F2C(cvstr)(&l,&(chars[sciptr[ie+4]-1]),(*ip)[ie],&job,l);
      FREE((*ip)[ie]);
      ie++;
    }
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i=1 ; i<nstring+1 ; i++)
    {
      ni=ptrstrings[i]-li;
      li=ptrstrings[i];
      ScilabStr2C(&ni,SciS,&p,ierr);
      strings[i-1]=p;
      if ( *ierr == 1) return 0;
      SciS += ni;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < *n; i++)  (*ip)[i]=op[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < *n; i++)  (*ip)[i]=op[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i=0 ; i < (*x)->m ; i++)
    mnel[i] = (*x)->mnel[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i=0 ; i < (*x)->nel ; i++)
    {
      icol[i] = (*x)->icol[i];
      R[i] = (*x)->R[i];
      if ( (*x)->it == 1 )I[i] = (*x)->I[i];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 0; k < nVariable ; k++)
	{
	  var1 = variables[k];
	  if ((var1->list_el != 0) &&
	      (strcmp(var1->list_name,var->name) == 0) &&
	      var1->present)
	    {
	      OutLISTarg(f,var,var1,insidelist,nel);
	    }
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < basfun->nin ; i++)
            {
                if (words[i + 1][0] == '{')
                {
                    basfun->maxOpt++;
                    nopt = ParseLine(words[i + 1] + 1, optwords);
                    if (nopt != 2)
                    {
                        printf("Bad syntax for optional argument. Two variables needed\n");
                        exit(1);
                    }
                    ivar = GetVar(optwords[0], 1);
                    basfun->in[i] = ivar;
                    variables[ivar - 1]->opt_type = NAME;
                    variables[ivar - 1]->opt_name =
                        (char *)malloc((unsigned)(strlen(optwords[1]) + 1));
                    variables[ivar - 1]->stack_position = icre++;
                    strcpy(variables[ivar - 1]->opt_name, optwords[1]);
                    variables[ivar - 1]->is_sciarg = 1;
                }
                else if (words[i + 1][0] == '[')
                {
                    basfun->maxOpt++;
                    nopt = ParseLine(words[i + 1] + 1, optwords);
                    if (nopt != 2)
                    {
                        printf("Bad syntax for optional argument. Two variables needed\n");
                        exit(1);
                    }
                    ivar = GetVar(optwords[0], 1);
                    basfun->in[i] = ivar;
                    variables[ivar - 1]->opt_type = VALUE;
                    variables[ivar - 1]->opt_name =
                        (char *)malloc((unsigned)(strlen(optwords[1]) + 1));
                    strcpy(variables[ivar - 1]->opt_name, optwords[1]);
                    variables[ivar - 1]->stack_position = icre++;
                    variables[ivar - 1]->is_sciarg = 1;
                }
                else
                {
                    basfun->in[i] = GetVar(words[i + 1], 1);
                    variables[basfun->in[i] - 1]->stack_position = icre++;
                    variables[basfun->in[i] - 1]->is_sciarg = 1;
                }
            }
            line1 = 0;
            inbas = 1;
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nwords - 1; i++)
            {
                forsub->arg[i] = GetExistVar(words[i + 1]);
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < l; j++)
                    {
                        int k = GetExistVar(words[j + 2]);
                        variables[i]->el[j] = k;
                        variables[k - 1]->out_position = j + 1;
                    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < (int) strlen(optvar) ; i++ )
    {
      if ( optvar[i] == ')' )
	{
	  lsize[j++] = '\0'; break;
	}
      if ( ok ==1 ) lsize[j++]= optvar[i];
      if ( optvar[i] == '(' ) ok =1 ;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < (int) strlen(ldata) ; i++ )
    if ( ldata[i] == '/' )
      {
	if (ok ==0 ) {
	  ldata[i]='{';ok=1;}
	else
	  ldata[i]='}';
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nFun; i++)
    {
        Fprintf(f, indent, "{ ints%s, \"%s\"},\n", funNames[i], funNames[i]);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nFun - 1; i++)
            fprintf(fout, "  '%s';\n", funNames[i]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < basfun->nin - basfun->NewMaxOpt; i++)
    {
        switch (variables[i]->type)
        {
            case LIST:
                WriteListAnalysis(f, i, "l");
                break;
            case TLIST:
                WriteListAnalysis(f, i, "t");
                break;
            case MLIST:
                WriteListAnalysis(f, i, "m");
                break;
            default:
                WriteArgCheck(f, i);
                break;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = basfun->nin - basfun->NewMaxOpt; i < basfun->nin; i++)
        {
            sprintf(str2, "\t{-1,\"%s\",\"%s\",0,0,0},\n", variables[i]->name, SGetForTypeAbrev(variables[i]));
            strcat(str1, str2);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = basfun->nin - basfun->NewMaxOpt; i < basfun->nin; i++)
        {
            WriteOptArgPhase2(f, i);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < vout->length; i++)
            {
                ivar = vout->el[i];
                var = variables[ivar - 1];
                printf("%s", var->name);
                if (i != vout->length - 1)
                    printf(",");
                else
                    printf(")");
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < vout->length; i++)
            {
                ivar = vout->el[i];
                var = variables[ivar - 1];
                printf("%s", var->name);
                if (i != vout->length - 1)
                    printf(",");
                else
                    printf("]");
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < basfun->nin; i++)
    {
        printf("%s(%s)", variables[i]->name, SGetSciType(variables[i]->type));
        if (i != basfun->nin - 1)
            printf(",");
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nVariable; i++)
    {
        var = variables[i];
        if (var->type == DIMFOREXT)
        {
            if (var->nfor_name > 1)
            {
                for(j = 1; j < var->nfor_name; j++)
                {
                    
                    
                    if ((var->for_name_orig[j] != var->for_name_orig[j - 1]) && (var->for_name[j - 1][1] != 'e' && var->for_name[j][1] != 'e'))
                    {
                        Fprintf(f, indent, "CheckDimProp(%d,%d,%s != %s);\n",
                                var->for_name_orig[j - 1], var->for_name_orig[j], var->for_name[j - 1], var->for_name[j]);
                    }
                }
            }
        }
        else if (var->type == SCALAR)
        {
            
            if (var->nfor_name > 1)
            {
                for(j = 1; j < var->nfor_name; j++)
                {
                    int dim = 2;

                    if (var->for_name[j][0] == 'm')
                        dim = 1;
                    if (var->for_name[j][1] != 'e') 
                    {
                        if (strncmp(var->for_name[0], "istk", 4) == 0)
                            Fprintf(f, indent, "CheckOneDim(%d,%d,%s,*%s);\n", var->for_name_orig[j], dim, var->for_name[j], var->for_name[0]);
                        else
                            Fprintf(f, indent, "CheckOneDim(%d,%d,%s,%s);\n", var->for_name_orig[j], dim, var->for_name[j], var->for_name[0]);
                    }
                }
            }
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 0; k < nVariable; k++)
    {
        var = variables[k];
        if ((var->list_el != 0) && (strcmp(var->list_name, variables[i]->name) == 0) && var->present)
        {
            Fprintf(f, indent, "\n", var->list_el, var->name);
            if (RHSTAB[var->type].type != var->type)
            {
                fprintf(stderr, "Bug in intersci : Something wrong in RHSTAB\n");
            }
            (*(RHSTAB[var->type].fonc)) (f, var, 0);
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < forsub->narg; i++)
    {
        ivar = forsub->arg[i];
        if (variables[ivar - 1]->list_el == 0
                && variables[ivar - 1]->is_sciarg == 0 && variables[ivar - 1]->for_type != EXTERNAL && variables[ivar - 1]->for_type != CSTRINGV)
        {
            count++;
            if (min != 10000 && variables[ivar - 1]->stack_position != 0 && variables[ivar - 1]->stack_position < min)
            {
                fprintf(stderr, "Error: declaration for local variables\n");
                fprintf(stderr, "\t must respect the order given in the calling sequence\n");
                fprintf(stderr, "\t declaration for %s must be moved downward\n", variables[ivar - 1]->name);
                exit(1);
            }
            if (variables[ivar - 1]->stack_position != 0)
                min = variables[ivar - 1]->stack_position;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < forsub->narg; i++)
    {
        ivar = forsub->arg[i];
        if (variables[ivar - 1]->list_el != 0)
        {
            
            iivar = GetExistVar(variables[ivar - 1]->list_name);
            if (variables[iivar - 1]->is_sciarg == 0)
            {
                printf("list or tlist \"%s\" must be an argument of SCILAB function\n", variables[ivar - 1]->list_name);
                exit(1);
            }
            strcat(call, variables[ivar - 1]->for_name[0]);
            strcat(call, ",");
        }
        else
        {
            int bCheck = 0;

            if (variables[ivar - 1]->is_sciarg != 1)
            {
                
                

                (*(CRERHSTAB[variables[ivar - 1]->type].fonc)) (f, variables[ivar - 1]);
            }
#ifdef _MSC_VER
            _try
            {
                bCheck = (variables[ivar - 1]->C_name[0] != NULL);
                if (bCheck)
                {
                    char *buffertmp = _strdup(variables[ivar - 1]->C_name[0]);

                    if (buffertmp)
                    {
                        free(buffertmp);
                        buffertmp = NULL;
                    }
                }
            }
            _except(EXCEPTION_EXECUTE_HANDLER)
            {
                bCheck = 0;
            }
#else
            bCheck = (variables[ivar - 1]->C_name[0] != NULL);
#endif
            if (target == 'C' && bCheck)
            {
                strcat(call, "&");
                strcat(call, variables[ivar - 1]->C_name[0]);
            }
            else
                strcat(call, variables[ivar - 1]->for_name[0]);
            strcat(call, ",");
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nVariable; i++)
    {
        if (strcmp(variables[i]->name, "err") == 0)
        {
            AddDeclare(DEC_INT, "err=0");
            Fprintf(f, indent++, "if (err >  0) {\n");
            Fprintf(f, indent, "Scierror(999,\"%%s: Internal Error \\n\",fname);\n");
            Fprintf(f, indent, "return 0;\n");
            Fprintf(f, --indent, "};\n");
            break;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < vout->length; i++)
                {
                    ivar = vout->el[i];
                    var = variables[ivar - 1];
                    Fprintf(f, indent, "\n", i + 1, var->name);
                    WriteVariable(f, var, ivar, 1, i + 1);
                }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < vout->length; i++)
                {
                    ivar = vout->el[i];
                    var = variables[ivar - 1];
                    WriteVariable(f, var, ivar, 0, 0);
                }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < basfun->nin; j++)
            {
                if (ivar2 == basfun->in[j])
                {
                    barg = j + 1;
                    break;
                }
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < forsub->narg; j++)
            {
                if (ivar2 == forsub->arg[j])
                {
                    farg = j + 1;
                    break;
                }
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < basfun->nin; j++)
    {
        if (ivar == basfun->in[j])
        {
            return (j + 1);
            break;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < forsub->narg; j++)
    {
        if (ivar == forsub->arg[j])
        {
            return (j + 1);
            break;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nFun; i++)
        {
            fprintf(fout, "{\"%s\",", funNames[i]);
            for(j = 0; j < 25 - (int)strlen(funNames[i]); j++)
                fprintf(fout, " ");
            fprintf(fout, "\t\tIN_%s,\t%d,\t3},\n", file, i + 1);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i < nFun - 1; i++)
        {
            fprintf(fout, "\t\"%s\",\"ints%s\";\n", funNames[i], funNames[i]);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < (int)strlen(sbuf); i++)
    {
        if (count == 0)
        {
            white(f, indent2);
            count = indent2;
        }
        if (count >= 100 && sbuf[i] != '\n' && (sbuf[i] == ' ' || sbuf[i] == ',' || sbuf[i] == ';' || sbuf[i] == '('))
        {
            fprintf(f, "\n");
            white(f, indent2);
            count = indent2;
        }
        if (sbuf[i] == '\n')
            count = -1;
        fprintf(f, "%c", sbuf[i]);
        count++;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < ind; i++)
        fprintf(f, " ");



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i < nFun; i++)
    {
        Fprintf(f, indent, "%d,", i);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nFun; i++)
    {
        FCprintf(f, "%d      call ints%s('%s')\n", i + 1, funNames[i], funNames[i]);
        Fprintf(f, indent, "return\n");
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nFun - 1; i++)
            fprintf(fout, "  '%s';\n", funNames[i]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nwords - 1; i++)
            {
                if (words[i + 1][0] == '{')
                {
                    maxOpt++;
                    nopt = ParseLine(words[i + 1] + 1, optwords);
                    if (nopt != 2)
                    {
                        printf("Bad syntax for optional argument. Two variables needed\n");
                        exit(1);
                    }
                    ivar = GetVar(optwords[0], 1);
                    basfun->in[i] = ivar;
                    variables[ivar - 1]->opt_type = NAME;
                    variables[ivar - 1]->opt_name = (char *)malloc((unsigned)(strlen(optwords[1]) + 1));
                    strcpy(variables[ivar - 1]->opt_name, optwords[1]);
                }
                else if (words[i + 1][0] == '[')
                {
                    maxOpt++;
                    nopt = ParseLine(words[i + 1] + 1, optwords);
                    if (nopt != 2)
                    {
                        printf("Bad syntax for optional argument. Two variables needed\n");
                        exit(1);
                    }
                    ivar = GetVar(optwords[0], 1);
                    basfun->in[i] = ivar;
                    variables[ivar - 1]->opt_type = VALUE;
                    variables[ivar - 1]->opt_name = (char *)malloc((unsigned)(strlen(optwords[1]) + 1));
                    strcpy(variables[ivar - 1]->opt_name, optwords[1]);
                }
                else
                    basfun->in[i] = GetVar(words[i + 1], 1);
            }
            line1 = 0;
            inbas = 1;
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nwords - 1; i++)
            {
                forsub->arg[i] = GetExistVar(words[i + 1]);
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < l; j++)
                        variables[i]->el[j] = GetExistVar(words[j + 2]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nVariable; i++)
    {
        var = variables[i];
        if (strcmp(var->name, name) == 0)
        {
            var->present = var->present || p;
            return (i + 1);
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nVariable; i++)
    {
        var = variables[i];
        if (strcmp(var->name, name) == 0)
        {
            
            var->present = 1;
            return (i + 1);
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nVariable; i++)
    {
        if (strcmp(variables[i]->name, str) == 0)
            return (i + 1);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nVariable; i++)
    {
        var = variables[i];
        if (var->kp_state != -1)
        {
            var->nfor_name = var->kp_state;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < forsub->narg; i++)
    {
        if (variables[forsub->arg[i] - 1]->for_type == CHAR)
        {
            Fprintf(f, indent, "lbuf = 1\n");
            break;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < basfun->nin; i++)
    {
        switch (variables[i]->type)
        {
            case LIST:
            case TLIST:
                WriteListAnalysis(f, i);
                break;
            default:
                WriteArgCheck(f, i);
                break;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < vout->length; i++)
            {
                ivar = vout->el[i];
                var = variables[ivar - 1];
                printf("%s", var->name);
                if (i != vout->length - 1)
                    printf(",");
                else
                    printf(")");
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < vout->length; i++)
            {
                ivar = vout->el[i];
                var = variables[ivar - 1];
                printf("%s", var->name);
                if (i != vout->length - 1)
                    printf(",");
                else
                    printf("]");
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < basfun->nin; i++)
    {
        printf("%s(%s)", variables[i]->name, SGetSciType(variables[i]->type));
        if (i != basfun->nin - 1)
            printf(",");
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < (int)strlen(optvar); i++)
    {
        if (optvar[i] == ')')
        {
            size[j++] = '\0';
            break;
        }
        if (ok == 1)
            size[j++] = optvar[i];
        if (optvar[i] == '(')
            ok = 1;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nVariable; i++)
    {
        var = variables[i];
        
        if (var->nfor_name != 0 && var->list_el == 0)
        {
            if (strncmp(var->for_name[0], "ne", 2) != 0 && strncmp(var->for_name[0], "me", 2) != 0)
            {
                n1 = Forname2Int(var->for_name[0]);
                for(j = 1; j < var->nfor_name; j++)
                {
                    n2 = Forname2Int(var->for_name[j]);
                    if (strcmp(n1, n2) != 0)
                    {
                        AddDeclare(DEC_LOGICAL, "checkval");
                        Fprintf(f, indent, "if(.not.checkval(fname,%s,%s)) return\n", n1, n2);
                    }
                }
            }
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < forsub->narg; i++)
    {
        ivar = forsub->arg[i];
        ind = 0;
        if (variables[ivar - 1]->list_el != 0)
        {
            
            iivar = GetExistVar(variables[ivar - 1]->list_name);
            for(j = 0; j < basfun->nin; j++)
            {
                if (iivar == basfun->in[j])
                {
                    
                    sprintf(str1, "%de%d", iivar, variables[ivar - 1]->list_el);
                    sprintf(str2, "%de%d", iivar, variables[ivar - 1]->list_el);
                    WriteCallConvertion(f, ivar, str2, str1, call);
                    ind = 1;
                    break;
                }
            }
            if (ind == 0)
            {
                printf("list or tlist \"%s\" must be an argument of SCILAB function\n", variables[ivar - 1]->list_name);
                exit(1);
            }
        }
        else
        {
            for(j = 0; j < basfun->nin; j++)
            {
                if (ivar == basfun->in[j])
                {
                    
                    sprintf(str1, "%d", j + 1);
                    sprintf(str2, "%d", i + 1);
                    WriteCallConvertion(f, ivar, str2, str1, call);
                    ind = 1;
                    break;
                }
            }
        }
        if (ind == 0)
        {
            
            WriteCallRest(f, ivar, i + 1, call);
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < basfun->nin; j++)
            {
                if (strcmp(variables[var->el[iel] - 1]->name, variables[basfun->in[j] - 1]->name) == 0)
                {
                    
                    sprintf(sdim, "%s%d", name, farg);
                    Fprintf(f, indent, "%s= int(stk(lr%d))\n", sdim, j + 1);
                    AddForName1(var->el[iel], sdim);
                    ind = 1;
                    break;
                }
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < vout->length; i++)
            {
                ivar = vout->el[i];
                var = variables[ivar - 1];
                FCprintf(f, "c    \n");
                FCprintf(f, "c       Element %d: %s\n", i + 1, var->name);
                WriteVariable(f, var, ivar, 1, i + 1);
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < vout->length; i++)
            {
                ivar = vout->el[i];
                var = variables[ivar - 1];
                FCprintf(f, "c    \n");
                Fprintf(f, indent++, "if(lhs .ge. %d) then\n", i + 1);
                FCprintf(f, "c       --------------output variable: %s\n", var->name);
                Fprintf(f, indent, "top=topl+%d\n", i + 1);
                WriteVariable(f, var, ivar, 0, 0);
                Fprintf(f, --indent, "endif\n");
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < vout->length; i++)
            {
                Fprintf(f, indent++, "if(lhs .ge. %d) then\n", i + 1);
                Fprintf(f, indent, "call copyobj(fname,topl+%d,topk+%d)\n", i + 1, i + 1);
                Fprintf(f, --indent, "endif\n");
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 0; k < nVariable; k++)
    {
        var = variables[k];
        if ((var->list_el != 0) && (strcmp(var->list_name, variables[i]->name) == 0) && var->present)
        {
            iel = var->list_el;
            FCprintf(f, "c     \n");
            FCprintf(f, "c       --   list element number %d %s --\n", iel, var->name);
            sprintf(str1, "%de%d", i1, iel);
            AddDeclare(DEC_LOGICAL, "getilist");
            switch (var->type)
            {
                case SPARSE:
                    AddDeclare(DEC_LOGICAL, "getlistsparse");
                    Fprintf(f, indent, "if(.not.getlistsparse(fname,topk,top-rhs+%d,%d,it%s,m%s,n%s,nel%s,mnel%s,icol%s,lr%s,lc%s)) return\n",
                            i1, iel, str1, str1, str1, str1, str1, str1, str1, str1);
                    if (var->el[0] == var->el[1])
                    {
                        
                        AddDeclare(DEC_LOGICAL, "checkval");
                        Fprintf(f, indent, "if(.not.checkval(fname,m%s,n%s)) return\n", str1, str1);
                    }
                    sprintf(str, "m%s", str1);
                    AddForName1(var->el[0], str);
                    sprintf(str, "n%s", str1);
                    AddForName1(var->el[1], str);
                    sprintf(str, "nel%s", str1);
                    AddForName1(var->el[2], str);
                    sprintf(str, "it%s", str1);
                    AddForName1(var->el[3], str);
                    break;
                case IMATRIX:
                    AddDeclare(DEC_LOGICAL, "getlistmat");
                    Fprintf(f, indent, "if(.not.getlistmat(fname,topk,top-rhs+%d,%d,it%s,m%s,n%s,lr%s,lc%s)) return\n",
                            i1, iel, str1, str1, str1, str1, str1);
                    if (var->el[0] == var->el[1])
                    {
                        
                        AddDeclare(DEC_LOGICAL, "checkval");
                        Fprintf(f, indent, "if(.not.checkval(fname,m%s,n%s)) return\n", str1, str1);
                    }
                    sprintf(str, "m%s", str1);
                    AddForName1(var->el[0], str);
                    sprintf(str, "n%s", str1);
                    AddForName1(var->el[1], str);
                    sprintf(str, "it%s", str1);
                    AddForName1(var->el[2], str);
                    break;
                case MATRIX:
                    AddDeclare(DEC_LOGICAL, "getlistmat");
                    Fprintf(f, indent, "if(.not.getlistmat(fname,topk,top-rhs+%d,%d,it%s,m%s,n%s,lr%s,lc%s)) return\n",
                            i1, iel, str1, str1, str1, str1, str1);
                    if (var->el[0] == var->el[1])
                    {
                        
                        AddDeclare(DEC_LOGICAL, "checkval");
                        Fprintf(f, indent, "if(.not.checkval(fname,m%s,n%s)) return\n", str1, str1);
                    }
                    sprintf(str, "m%s", str1);
                    AddForName1(var->el[0], str);
                    sprintf(str, "n%s", str1);
                    AddForName1(var->el[1], str);
                    break;
                case BMATRIX:
                    AddDeclare(DEC_LOGICAL, "getlistbmat");
                    Fprintf(f, indent, "if(.not.getlistbmat(fname,topk,top-rhs+%d,%d,m%s,n%s,lr%s)) return\n", i1, iel, str1, str1, str1, str1, str1);
                    if (var->el[0] == var->el[1])
                    {
                        
                        AddDeclare(DEC_LOGICAL, "checkval");
                        Fprintf(f, indent, "if(.not.checkval(fname,m%s,n%s)) return\n", str1, str1);
                    }
                    sprintf(str, "m%s", str1);
                    AddForName1(var->el[0], str);
                    sprintf(str, "n%s", str1);
                    AddForName1(var->el[1], str);
                    break;
                case STRINGMAT:
                    AddDeclare(DEC_LOGICAL, "getlistsimat");
                    Fprintf(f, indent, "if(.not.getlistsimat(fname,topk,top-rhs+%d,%d,m%s,n%s,1,1,lr%s,nlr%s)) return\n",
                            i1, iel, str1, str1, str1, str1);
                    
                    if (var->el[0] == var->el[1])
                    {
                        
                        AddDeclare(DEC_LOGICAL, "checkval");
                        Fprintf(f, indent, "if(.not.checkval(fname,m%s,n%s)) return\n", str1, str1);
                    }
                    sprintf(str, "m%s", str1);
                    AddForName1(var->el[0], str);
                    sprintf(str, "n%s", str1);
                    AddForName1(var->el[1], str);
                    break;
                case ROW:
                    AddDeclare(DEC_LOGICAL, "getlistvectrow");
                    Fprintf(f, indent, "if(.not.getlistvectrow(fname,topk,top-rhs+%d,%d,it%s,m%s,n%s,lr%s,lc%s)) return\n",
                            i1, iel, str1, str1, str1, str1, str1);
                    sprintf(str, "n%s", str1);
                    AddForName1(var->el[0], str);
                    break;
                case COLUMN:
                    AddDeclare(DEC_LOGICAL, "getlistvectcol");
                    Fprintf(f, indent, "if(.not.getlistvectcol(fname,topk,top-rhs+%d,%d,it%s,m%s,n%s,lr%s,lc%s)) return\n",
                            i1, iel, str1, str1, str1, str1, str1);
                    sprintf(str, "n%s", str1);
                    AddForName1(var->el[0], str);
                    break;
                case VECTOR:
                    AddDeclare(DEC_LOGICAL, "getlistvect");
                    Fprintf(f, indent, "if(.not.getlistvect(fname,top,top-rhs+%d,%d,it%s,m%s,n%s,lr%s,lc%s)) return\n",
                            i1, iel, str1, str1, str1, str1, str1);
                    sprintf(str, "n%s*m%s", str1, str1);
                    AddForName1(var->el[0], str);
                    break;
                case POLYNOM:
                    AddDeclare(DEC_LOGICAL, "getlistpoly");
                    Fprintf(f, indent, "if(.not.getlistpoly(fname,topk,top-rhs+%d,%d,it%s,m%s,n%s,name%s,\n", i1, iel, str1, str1, str1, str1);
                    Fprintf(f, indent, "$     namel%s,ilp%s,lr%s,lc%s)\n", str1, str1, str1, str1);
                    AddDeclare(DEC_LOGICAL, "checkval");
                    Fprintf(f, indent, "if(.not.checkval(fname,m%s,n%s)) return\n", str1, str1);
                    break;
                case SCALAR:
                    AddDeclare(DEC_LOGICAL, "getlistscalar");
                    Fprintf(f, indent, "if(.not.getlistscalar(fname,topk,top-rhs+%d,%d,lr%s)) return\n", i1, iel, str1);
                    break;
                case STRING:
                    AddDeclare(DEC_LOGICAL, "getlistsmat");
                    Fprintf(f, indent, "if(.not.getlistsmat(fname,topk,top-rhs+%d,%d,m%s,n%s,1,1,lr%s,nlr%s)) return\n", i1, iel, str1, str1, str1, str1);
                    AddDeclare(DEC_LOGICAL, "checkval");
                    Fprintf(f, indent, "if(.not.checkval(fname,m%s*n%s,1)) return\n", str1, str1);
                    sprintf(str, "n%s", str1);
                    strcpy(str1, variables[var->el[0] - 1]->name);
                    AddForName1(var->el[0], str);
                    break;
                case ANY:
                    break;
            }
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < basfun->nin; j++)
            {
                if (ivar2 == basfun->in[j])
                {
                    barg = j + 1;
                    break;
                }
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < forsub->narg; j++)
            {
                if (ivar2 == forsub->arg[j])
                {
                    farg = j + 1;
                    break;
                }
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < basfun->nin; j++)
    {
        if (ivar == basfun->in[j])
        {
            return (j + 1);
            break;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < forsub->narg; j++)
    {
        if (ivar == forsub->arg[j])
        {
            return (j + 1);
            break;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nFun; i++)
        {
            fprintf(fout, "{\"%s\",", funNames[i]);
            for(j = 0; j < 25 - (int)strlen(funNames[i]); j++)
                fprintf(fout, " ");
            fprintf(fout, "\t\tIN_%s,\t%d,\t3},\n", file, i + 1);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < Init[j].ndecls; i++)
                free((char *)Init[j].decls[i]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < Init[j].ndecls; i++)
            {
                if (strcmp(declaration, Init[j].decls[i]) == 0)
                    return (1);
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < Init[j].ndecls; i++)
        {
            Fprintf(f, indent, "%s", Init[j].decls[i]);
            if (i != Init[j].ndecls - 1)
                Fprintf(f, indent, ",");
            else
                Fprintf(f, indent, "\n");
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < (int)strlen(sbuf); i++)
    {
        if (count == 0)
        {
            white(f, 7 + indent);
            count = 7 + indent;
        }
        if (count == 72 && sbuf[i] != '\n')
        {
            fprintf(f, "\n     $ ");
            count = 7;
        }
        if (sbuf[i] == '\n')
            count = -1;
        fprintf(f, "%c", sbuf[i]);
        count++;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < ind; i++)
        fprintf(f, " ");



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(p = modname + 1; *p; p++)
        {
            if (*p == '\\')
                *p = '/';
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < basfun->nin ; i++)
    {
      int j;
      var = variables[i];
      (*(FORTAB[var->type].fonc))(var);
      
      if ( var->type == LIST || var->type == TLIST )
	{
	  for( j = 0 ; j < nVariable ; j++)
	    {
	      var1 = variables[j];
	      if ( var1->stack_position == i+1  && var1->list_el != 0)
		(*(FORTAB[var1->type].fonc))(var1);
	    }
	}
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = basfun->nin ; i < nVariable ; i++)
    {
      var = variables[i];
      if ( var->for_type == EXTERNAL )
	{
	  (*(FORTAB[var->type].fonc))(var);
	}
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < Init[j].ndecls ; i++ )
                free((char *) Init[j].decls[i]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < Init[j].ndecls ; i++ )
            {
                if ( strcmp(declaration, Init[j].decls[i]) == 0)
                    return(1);
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0 ; i < Init[j].ndecls ; i++)
            {
                Fprintf(f, indent, "%s", Init[j].decls[i]);
                Fprintf(f, indent, ";\n");
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0 ; i < Init[j].ndecls ; i++)
            {
                Fprintf(f, indent, "%s ", Init[j].nameC);
                Fprintf(f, indent, "%s", Init[j].decls[i]);
                Fprintf(f, indent, ";\n");
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0 ; i < Init[j].ndecls ; i++)
            {
                if ( Init[j].type >= DEC_IPTR && target == 'C')
                {
                    
                    Fprintf(f, indent, "*");
                }
                else if ( Init[j].type == DEC_SMAT && target == 'C')
                {
                    Fprintf(f, indent, "**");
                }
                Fprintf(f, indent, "%s", Init[j].decls[i]);
                if ( i != Init[j].ndecls - 1 ) Fprintf(f, indent, ",");
                else
                {
                    Fprintf(f, indent, ";\n");
                }
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nVariable; i++)
    {
      int j;
      var = variables[i];
      fprintf(stderr,"==============variable %d : name %s\n",i+1,var->name);
      fprintf(stderr,"type %s<->%s\n",SGetSciType(var->type),
	      SGetForType(var->for_type));
      fprintf(stderr,"elts : [");
      for(j=0 ; j < var->length ; j++)
	{
	  fprintf(stderr,"{var %d:%s}",var->el[j],
		  variables[var->el[j]-1]->name);
	}
      fprintf(stderr,"]\n");
      


      fprintf(stderr," ?  equal %d\n",var->equal);
      fprintf(stderr,"for_names [");
      if ( var->nfor_name != 0)
	{
	  for(j=0 ; j < var->nfor_name ; j++)
	    {
	      fprintf(stderr,"{%s:%d}",var->for_name[j],
		      var->for_name_orig[j]);
	      if ( j != var->nfor_name-1) fprintf(stderr,",");
	    }
	}
      fprintf(stderr,"]\n");
      fprintf(stderr," position in a list %d\n",var->list_el);
      if ( var->list_el > 0 )
	fprintf(stderr," List name %s\n",var->list_name);
      fprintf(stderr," type of optional variable %d\n",var->opt_type);
      if ( var->opt_type != 0)
	fprintf(stderr," name or value default for optional variable %s\n",
		var->opt_name);
      fprintf(stderr," 1 if the variable is really present %d\n",var->present);
      fprintf(stderr,"sciarg %d, rhs %d, lhs %d\n",
	      var->is_sciarg,
	      var->stack_position,
	      var->out_position);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = nVariable-1 ; i >= 0; i--)
    {
      int j;
      var = variables[i];
      if ( ISNONSTACK(var) )
	{
	  icre--;
	  for( j = 0 ; j < nVariable ; j++ )
	    {
	      var1 = variables[j];
	      if ( var1->stack_position > var->stack_position
		   && ! (ISNONSTACK(var1)))
		var1->stack_position--;
	    }
	}
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nVariable; i++) {
    var = variables[i];
    if (strcmp(var->name,name) == 0) {
      var->present = var->present || p;
      return(i+1);
    }
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nVariable; i++) {
    var = variables[i];
    if (strcmp(var->name,name) == 0) {
      
      var->present = 1;
      return(i+1);
    }
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nVariable; i++) {
    if (strcmp(variables[i]->name,str) == 0)
      return(i+1);
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nVariable; i++) {
    if (strcmp(variables[i]->name,str) == 0)
      return(i+1);
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nVariable; i++) {
    var = variables[i];
    if ( var->kp_state != -1 )
      {
	var->nfor_name = var->kp_state ;
      }
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i=0 ; i < l ; i++)
	{
	  if ( var->for_name_orig[i] == var->stack_position )
	    {
	      pos = i ; break;
	    }
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i=0 ; i < mn ; i++) 
    {
      b[i] = a[i] + 33.0 +i;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 0; k < headerdims[1]*headerdims[2]; k++)
    {
        proddims = proddims * headerdims[4 + k];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 0; k < headerdims[1]*headerdims[2]; k++)
                    {
                        proddims = proddims * headerdims[4 + k];
                    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 0; k < headerdims[1]*headerdims[2]; k++)
                    {
                        proddims = proddims * headerdims[4 + k];
                    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j <= M * commonlength; ++j)
            {
                header[5 + j + M] = header[5 + j + oldM];
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < numberofdim - 2; ++j)
                    {
                        ret = ret * header1[6 + j];
                    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < m; ++i)
            {
                header[5 + i] = header[4 + i] + N;
                
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( k = 0; k < m * n * (it + 1); k++ )
    {
        *stk(lr + k) = 0;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 0; k < headerdims[1]*headerdims[2]; k++)
    {
        proddims = proddims * headerdims[4 + k];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 0; k < headerdims[1]*headerdims[2]; k++)
    {
        proddims = proddims * headerdims[4 + k];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(kk = 0; kk < 2 * isize; ++kk)
    {
        headerobjcopy[kk] = headerobj[kk];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 0; k < nf; k++)
    {
        longueur = Min(headerstr[7 + k] - headerstr[6 + k], nlgh); 
        istart = 6 + nf + headerstr[6 + k]; 
        
        C2F(cvstr)(&longueur, &headerstr[istart], str, (ilocal = 1, &ilocal), longueur);
        str[longueur] = '\0';
        if (strcmp(string, str) == 0)
        {
            retval = k;
            break;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 0; k < headerdims[1]*headerdims[2]; k++)
    {
        proddims = proddims * headerdims[4 + k];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(kk = 0; kk < 2 * isize; ++kk)
    {
        headerobjcopy[kk] = headerobj[kk];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 0; k < headerdims[1]*headerdims[2]; k++)
    {
        proddims = proddims * headerdims[4 + k];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(kk = 0; kk < 2 * isize; ++kk)
    {
        headerobjcopy[kk] = headerobj[kk];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nsize ; i++)
        {
            ((char *) lrd)[i] = 0;
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < rec_size ; i++)
        {
            if (calloc_table[i].keep == 0 )
            {
                
                calloc_table[i].adr = loc;
                calloc_table[i].keep = 1;
                return loc ;
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < rec_size ; i++)
        {
            if (calloc_table[i].keep == 0 )
            {
                
                calloc_table[i].adr = loc;
                calloc_table[i].keep = 1;
                return loc ;
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < rec_size ; i++)
    {
        if (calloc_table[i].adr == ptr)
        {
            if  (calloc_table[i].keep == 1 )
            {
                calloc_table[i].keep = 2;
            }
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < rec_size ; i++)
    {
        if (calloc_table[i].adr == ptr)
        {
            
            if  (calloc_table[i].keep != 0 )
            {
                
                FREE(ptr);
                calloc_table[i].keep = 0;
                calloc_table[i].adr = NULL;
                return;
            }
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < rec_size ; i++)
    {
        if  (calloc_table[i].keep == 1 )
        {
            
            FREE(calloc_table[i].adr);
            calloc_table[i].keep = 0;
            calloc_table[i].adr = NULL;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(kk = 1; kk <= Nbvars; kk++)
        {
            *number = kk;
            if (lst_k == C2F(vstk).lstk[kk + Top - Rhs - 1])
            {
                break;
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(kk = Bot; kk <  C2F(vstk).isiz; kk++)
        {
            *number = kk;
            if (lst_k == C2F(vstk).lstk[kk - 1])
            {
                break;
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(kk = 1; kk <= Nbvars; kk++)
        {
            number = kk;
            if (lst_k == C2F(vstk).lstk[kk + Top - Rhs - 1])
            {
                break;
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(kk = Bot; kk <  C2F(vstk).isiz; kk++)
        {
            number = kk;
            if (lst_k == C2F(vstk).lstk[kk - 1])
            {
                break;
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(kk = 1; kk <= Nbvars; kk++)
        {
            number = kk;
            if (lst_k == C2F(vstk).lstk[kk + Top - Rhs - 1])
            {
                break;
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(kk = Bot; kk <  C2F(vstk).isiz; kk++)
        {
            number = kk;
            if (lst_k == C2F(vstk).lstk[kk - 1])
            {
                break;
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 0; k < size; ++k)
    {
        data[k] = old[k];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 0; k < headerdims[1]*headerdims[2]; k++)
    {
        proddims = proddims * headerdims[4 + k];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(list = 0; list < nb; list++)
        {
            headerlist = listentry(header, list + 3); 
            nbobj = headerlist[1]; 
            for(lindex = 0; lindex < nbobj; lindex++)
            {
                headerobj = listentry( headerlist, lindex + 1);
                
                if (headerobj[0] < 0)
                {
                    sizeobj = headerobj[3];
                }
                else
                {
                    sizeobj = headerlist[lindex + 3] - headerlist[lindex + 2];
                }
                newsize += sizeobj;   
            }
            suite++;
            newsize += (2 + nbobj / 2); 
            headernew[4 + suite] = newsize;
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(list = 0; list < nb; list++)
        {
            headerlist = listentry(header, list + 3);
            headerlistnew = listentry(headernew, list + 3);
            nbobj = headerlist[1];
            headerlistnew[0] = 15;
            headerlistnew[1] = nbobj;
            headerlistnew[2] = 1;
            for(lindex = 0; lindex < nbobj; lindex++)
            {
                headerobj = listentry( headerlist, lindex + 1);
                if (headerobj[0] < 0)
                {
                    sizeobj = headerobj[3];    
                }
                else
                {
                    sizeobj = headerlist[lindex + 3] - headerlist[lindex + 2];
                }
                headerlistnew[3 + lindex] = headerlistnew[2 + lindex] + sizeobj;
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(list = 0; list < nb; list++)
        {
            headerlist = listentry(header, list + 3);
            headerlistnew = listentry(headernew, list + 3);
            nbobj = headerlist[1];
            for(lindex = 0; lindex < nbobj; lindex++)
            {
                headerobj = listentry( headerlist, lindex + 1);
                headerobjnew = listentry( headerlistnew, lindex + 1);
                if (headerobj[0] < 0)   
                {
                    sizeobj = headerobj[3];
                    headerobj = (int *) stk(headerobj[1]);   
                }
                else
                {
                    sizeobj = headerlist[lindex + 3] - headerlist[lindex + 2];
                }
                for(k = 0; k < 2 * sizeobj; k++)
                {
                    headerobjnew[k] = headerobj[k];    
                }
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(obj = 0; obj < nb; obj++)
        {
            headerobj = listentry(header, 3 + obj);
            if (headerobj[0] < 0)
            {
                sizeobj = headerobj[3];
            }
            else
            {
                sizeobj = header[5 + obj] - header[4 + obj];
            }
            newsize += sizeobj;
            suite++;
            newsize += sizeobj;
            headernew[4 + suite] = newsize;
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(obj = 0; obj < nb; obj++)
        {
            headerobj = listentry(header, 3 + obj);
            headerobjnew = listentry(headernew, 3 + obj);
            if (headerobj[0] < 0)
            {
                sizeobj = headerobj[3];
                headerobj = (int *) stk(headerobj[1]);
            }
            else
            {
                sizeobj = header[5 + obj] - header[4 + obj];
            }
            for(k = 0; k < 2 * sizeobj; k++)
            {
                headerobjnew[k] = headerobj[k];
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 0; k < m * n; k++)
    {
        header[3 + k] = 0;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 1; k <= nrhs; ++k)
    {
        for(kk = 1; kk <= nv; ++kk)
            if ((int) prhs[k - 1] == C2F(vstk).lstk[kk + Top - Rhs - 1])
            {
                break;
            }
        if (kk == nv + 1)
        {
            mexErrMsgTxt(_("mexCallSCILAB: invalid pointer passed to called function."));
            return 1;
        }
        else
        {
            ++Nbvars;
            i1 = Top - Rhs + kk;
            i2 = Top - Rhs + Nbvars;
            C2F(vcopyobj)("mexCallSCILAB", &i1, &i2, 13L);
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 1; k <= nlhs; ++k)
    {
        plhs[k - 1] = (mxArray *) C2F(vstk).lstk[nv + k + Top - Rhs - 1];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 0; k < nsubs; k++)
    {
        retval = retval + subs[k] * coeff;
        coeff = coeff * dims[k];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 1; k < m; ++k)
    {
        n = (int)strlen(str[k]);
        if (n > nmax)
        {
            nmax = n;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 0; k < m; ++k)
    {
        n = (int)strlen(str[k]);
        
        C2F(cvstr)(&n, istk(lr1), (char *) str[k], (ilocal = 0, &ilocal), i);
        if (nmax > n)
        {
            for(kk = 0; kk < nmax - n; ++kk)
            {
                *istk(lr1 + n + kk) = 40;
            }
        };
        lr1 = lr1 + nmax;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(output = 1; output <= *nlhs ; ++output)
    {
        plhs[output - 1] = 0;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 1; k <= *nrhs ; ++k)
    {
        RhsVar = k  + Top - Rhs;
        prhs[k - 1] = (mxArray *) C2F(vstk).lstk[RhsVar - 1];
        C2F(intersci).ntypes[k - 1] = AsIs;
        header = (int *) stkptr((long int)prhs[k - 1]);
        


        if (header[0] < 0)
        {
            header = (int *) stk(header[1]);
        }
        switch (header[0])
        {
            case DOUBLEMATRIX:
            case INTMATRIX:
            case SPARSEMATRIX:
                break;
            case STRINGMATRIX:
                if (header[2] != 1)
                {
                    mexErrMsgTxt(_("Invalid string matrix (at most one column!)"));
                }
                m = header[1];
                commonlength = header[5] - header[4];
                if (m > 1)
                {
                    for(line = 1; line < m; line++)
                    {
                        if (header[5 + line] - header[4 + line] != commonlength)
                        {
                            mexErrMsgTxt(_("Column length of string matrix must agree!"));
                        }
                    }
                }
                break;
            case 5:
                mexErrMsgTxt(_("Use mtlb_sparse(sparse( ))!"));
                
                return 0;
            case MLIST:
                header1 = (int *) listentry(header, 2);
                
                
                break;
            case LOGICAL :
                break;
            default:
                mexErrMsgTxt(_("Invalid input"));
                return 0;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 1; k <= *nlhs; k++)
    {
        if (IsstOrce(plhs[k - 1]))
        {
            plhs[k - 1] = UnrefStruct(plhs[k - 1]);
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 1; k <= *nlhs; k++)
    {
        plhsk = (int) plhs[k - 1];
        LhsVar(k) = 0;
        for(kk = 1; kk <= nv; kk++)
        {
            if (plhsk == C2F(vstk).lstk[kk + Top - Rhs - 1])
            {
                LhsVar(k) = kk;
                break;
            }
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 1; k <= nlhs; k++)
        if (  (int)plhs[k - 1] > max )
        {
            max =  (int)plhs[k - 1];
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 1; k <= nrhs; k++)
        if ( (int)  prhs[k - 1] > max )
        {
            max =  (int) prhs[k - 1];
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 1; k <= nv; k++)
        if ( max <  C2F(vstk).lstk[k + Top - Rhs - 1])
        {
            Nbvars--;
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0 ; i < N ; i++)
                    {
                        AMSB[i + i * N] -= SIGMA.r;
                    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
                            {
                                for(j = 0; j < i; j++)
                                {
                                    AMSB[i + j * N] = AMSB[j + i * N] + AR[i + j * N] - AR[j + i * N];
                                }
                            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(y,\lambda) in R^{-T}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(y,\lambda) in R^{-T}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0 ; i < N ; i++)
                    {
                        AMSBC[i + i * N].r -= SIGMA.r;
                        AMSBC[i + i * N].i -= SIGMA.i;
                    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nev + 1; i++)
        {
            eigenvalue[i].r = DR[i];
            eigenvalue[i].i = DI[i];
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < N; j++)
                {
                    eigenvector[i * N + j].r = Z[i * N + j];
                    eigenvector[i * N + j].i = Z[(i + 1) * N + j];
                    eigenvector[(i + 1) * N + j].r = Z[i * N + j];
                    eigenvector[(i + 1) * N + j].i = -Z[(i + 1) * N + j];
                }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < N; j++)
                {
                    eigenvector[i * N + j].r = Z[i * N + j];
                    eigenvector[i * N + j].i = 0;
                }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < iColsOne; i++)
        {
            for(j = 0; j < i; j++)
            {
                elemt1 = Areal[j + i * iColsOne];
                elemt2 = Areal[j * iColsOne + i];
                if (fabs(elemt1 - elemt2) > 0)
                {
                    Asym = 0;
                    break;
                }
            }
            if (Asym == 0)
            {
                break;
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0 ; i < N * N ;  i++)
            {
                Bcplx[i].r = Breal[i];
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0 ; i < N * N ;  i++)
            {
                Acplx[i].r = Areal[i];
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
            {
                for(j = 0; j <= i; j++)
                {
                    if (i == j && Breal[i + j * N] == 0)
                    {
                        Scierror(999, _("%s: B is not positive definite. Try with sigma='SM' or sigma=scalar.\n"), "eigs");
                        return 0;
                    }
                    else
                    {
                        if ( j < i && Breal[i + j * N] != 0 )
                        {
                            Scierror(999, _("%s: If opts.cholB is true, B should be upper triangular.\n"), "eigs");
                            return 0;
                        }
                    }
                }
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < N; i++)
            {
                for(j = 0; j <= i; j++)
                {
                    if (i == j && Bcplx[i + i * N].r == 0 && Bcplx[i + i * N].i == 0)
                    {
                        Scierror(999, _("%s: B is not positive definite. Try with sigma='SM' or sigma=scalar.\n"), "eigs");
                        return 0;
                    }
                    else
                    {
                        if ( j < i && (Bcplx[i + j * N].r != 0 || Bcplx[i + j * N].i != 0) )
                        {
                            Scierror(999, _("%s: If opts.cholB is true, B should be upper triangular.\n"), "eigs");
                            return 0;
                        }
                    }
                }
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < iNEV; i++)
            {
                mat_eigenvalue[i * iNEV + i] = eigenvalue[i];
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < iNEV; i++)
            {
                mat_eigenvalueC[i * iNEV + i] = eigenvalueC[i];
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 1 ; i < n ; i++ )
    if ( ! (x[i-1] < x[i]) )   
      return ( 0 );



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( j = 0; j < n-1; j++)
    {
      temp = temp * dim[j];
      p = 2*p;
      for( i = 0; i < p; i++ )
	ad[p+i] = ad[i] + temp;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( j = 0; j < n; j++ ) k[j] = -1;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0; i < np; i++ )
    {
      
      
      
      for( j = 0; j < n; j++ )
	{
	  xx = xp[j][i];
	  if ( C2F(isanan)(&xx) )
	    {
	      v[0] = C2F(returnanan)(); goto fin;
	    }
	  fast_int_search(xx, x[j], dim[j], &(k[j]));
	  if ( k[j] == -1 )    
	    switch (outmode)
	      {
	      case BY_NAN :
		v[0] = C2F(returnanan)();
		goto fin;

	      case BY_ZERO :
		v[0] = 0.0;
		goto fin;

	      case NATURAL :
		if (xx < x[j][0])
		  k[j] = 0;
		else
		  k[j] = dim[j]-2;
		break;

	      case C0 :
		if (xx < x[j][0])
		  { 
		    u[j] = 0.0; k[j] = 0;
		  }  
		else
		  {
		    u[j] = 1.0; k[j] = dim[j]-2;
		  }
		continue;

	      case PERIODIC :
		coord_by_periodicity(&xx, x[j], dim[j], &(k[j]));
		break;

	      }
	  u[j] = (xx - x[j][k[j]])/( x[j][k[j]+1] -  x[j][k[j]]);  
	}

      
      b = k[n-1];
      for( j = n-2; j >= 0; j-- )
	b = k[j] + dim[j]*b;

      
      for( j = 0; j < two_p_n; j++ )
	v[j] = val[b + ad[j]];

      
      temp = 1; p = two_p_n;
      for( j = 0; j < n ; j++ )
	{
	  for( l = 0; l < two_p_n; l+=2*temp)
	    {
	      v[l] = v[l]*(1.0 - u[j]) + v[l+temp]*u[j];
	    }
	  p = p/2; 
	  temp = 2*temp; 
	}

      
    fin:
      yp[i] = v[0];
    
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i <= minrhs; i++)
    {
        SciErr sciErr;
        int *piAddressVar = NULL;
        sciErr = getVarAddressFromPosition(pvApiCtx, i, &piAddressVar);
        if(sciErr.iErr)
        {
            printError(&sciErr, 0);
            Scierror(999, _("%s: Can not read input argument #%d.\n"), fname, i);
            return 0;
        }

        if (isVarComplex(pvApiCtx, piAddressVar))
        {
            Scierror(202, _("%s: Wrong type for argument #%d: Real matrix expected.\n"), fname, i);
            return 0;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i <= minrhs - 1; i++)
    {
        SciErr sciErr;
        int *piAddressVar = NULL;
        sciErr = getVarAddressFromPosition(pvApiCtx, i, &piAddressVar);
        if(sciErr.iErr)
        {
            printError(&sciErr, 0);
            Scierror(999, _("%s: Can not read input argument #%d.\n"), fname, i);
            return 0;
        }

        if (isVarComplex(pvApiCtx, piAddressVar))
        {
            Scierror(202, _("%s: Wrong type for argument #%d: Real matrix expected.\n"), fname, i);
            return 0;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i <= minrhs; i++)
    {
        SciErr sciErr;
        int *piAddressVar = NULL;
        sciErr = getVarAddressFromPosition(pvApiCtx, i, &piAddressVar);
        if(sciErr.iErr)
        {
            printError(&sciErr, 0);
            Scierror(999, _("%s: Can not read input argument #%d.\n"), fname, i);
            return 0;
        }

        if (isVarComplex(pvApiCtx, piAddressVar))
        {
            Scierror(202, _("%s: Wrong type for argument #%d: Real matrix expected.\n"), fname, i);
            return 0;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i <= minrhs - 1; i++)
    {
        SciErr sciErr;
        int *piAddressVar = NULL;
        sciErr = getVarAddressFromPosition(pvApiCtx, i, &piAddressVar);
        if(sciErr.iErr)
        {
            printError(&sciErr, 0);
            Scierror(999, _("%s: Can not read input argument #%d.\n"), fname, i);
            return 0;
        }

        if (isVarComplex(pvApiCtx, piAddressVar))
        {
            Scierror(202, _("%s: Wrong type for argument #%d: Real matrix expected.\n"), fname, i);
            return 0;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i <= minrhs; i++)
    {
        SciErr sciErr;
        int *piAddressVar = NULL;
        sciErr = getVarAddressFromPosition(pvApiCtx, i, &piAddressVar);
        if(sciErr.iErr)
        {
            printError(&sciErr, 0);
            Scierror(999, _("%s: Can not read input argument #%d.\n"), fname, i);
            return 0;
        }

        if (isVarComplex(pvApiCtx, piAddressVar))
        {
            Scierror(202, _("%s: Wrong type for argument #%d: Real matrix expected.\n"), fname, i);
            return 0;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 2 ; i <= n ; i++ )
    {
        SciErr sciErr;
        int *piAddressVar = NULL;

        GetRhsVar(i, MATRIX_OF_DOUBLE_DATATYPE, &mxpn, &nxpn, &lxpn);
        if ( mxp != mxpn || nxp != nxpn )
        {
            Scierror(999, _("%s: Wrong size for input arguments #%d and #%d: Same sizes expected.\n"), fname, 1, i);
            return 0;
        }

        sciErr = getVarAddressFromPosition(pvApiCtx, i, &piAddressVar);
        if (sciErr.iErr)
        {
            printError(&sciErr, 0);
            Scierror(999, _("%s: Can not read input argument #%d.\n"), fname, i);
            return 0;
        }

        if (isVarComplex(pvApiCtx, piAddressVar))
        {
            Scierror(202, _("%s: Wrong type for argument #%d: Real matrix expected.\n"), fname, i);
            return 0;
        }

        xp[i - 1] = stk(lxpn);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 1 ; i <= n ; i++ )
    {
        GetRhsVar(n + i, MATRIX_OF_DOUBLE_DATATYPE, &mx, &nx, &lx);
        if ( (mx != 1 && nx != 1) && mx * nx < 2)
        {
            Scierror(999, _("%s: Wrong size for input argument #%d.\n"), fname, n + i);
            return 0;
        }
        x[i - 1] = stk(lx);
        dim[i - 1] = mx * nx;
        
        if ( !good_order(x[i - 1], mx * nx) )
        {
            Scierror(999, _("%s: Grid abscissae of dim %d not in strict increasing order.\n"), fname, n + i);
            return 0;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < n ; i++ )
            if ( U.dims[i] != dim[i] )
            {
                Scierror(999, _("%s: Size incompatibility between grid points and grid values in dimension %d.\n"), fname, i + 1);
                return 0;
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 1 ; i <= n ; i++) m = 2 * m;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i <= minrhs; i++)
    {
        SciErr sciErr;
        int *piAddressVar = NULL;
        sciErr = getVarAddressFromPosition(pvApiCtx, i, &piAddressVar);
        if(sciErr.iErr)
        {
            printError(&sciErr, 0);
            Scierror(999, _("%s: Can not read input argument #%d.\n"), fname, i);
            return 0;
        }

        if (isVarComplex(pvApiCtx, piAddressVar))
        {
            Scierror(202, _("%s: Wrong type for argument #%d: Real matrix expected.\n"), fname, i);
            return 0;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i <= minrhs - 1; i++)
    {
        SciErr sciErr;
        int *piAddressVar = NULL;
        sciErr = getVarAddressFromPosition(pvApiCtx, i, &piAddressVar);
        if (sciErr.iErr)
        {
            printError(&sciErr, 0);
            Scierror(999, _("%s: Can not read input argument #%d.\n"), fname, i);
            return 0;
        }

        if (isVarComplex(pvApiCtx, piAddressVar))
        {
            Scierror(202, _("%s: Wrong type for argument #%d: Real matrix expected.\n"), fname, i);
            return 0;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < np ; i++ )
                


                f[i] = C2F(cs2val)(&xp[i], &yp[i], &n, xyz, &xyz[n], &xyz[2 * n], &nr,



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < np ; i++ )
                


                C2F(cs2grd) (&xp[i], &yp[i], &n, xyz, &xyz[n], &xyz[2 * n], &nr,



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < np ; i++ )
            {
                


                C2F(cs2hes) (&xp[i], &yp[i], &n, xyz, &xyz[n], &xyz[2 * n], &nr,
                             cell, next, grid, &grid[1], &grid[2], &grid[3],
                             stk(lrmax), stk(lrw), stk(la), &f[i], &dfdx[i], &dfdy[i],
                             &dffdxx[i], &dffdxy[i], &dffdyy[i], &ier);
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i <= 3; i++)
    {
        SciErr sciErr;
        int *piAddressVar = NULL;
        sciErr = getVarAddressFromPosition(pvApiCtx, i, &piAddressVar);
        if (sciErr.iErr)
        {
            printError(&sciErr, 0);
            Scierror(999, _("%s: Can not read input argument #%d.\n"), fname, i);
            return 0;
        }

        if (isVarComplex(pvApiCtx, piAddressVar))
        {
            Scierror(202, _("%s: Wrong type for argument #%d: Real matrix expected.\n"), fname, i);
            return 0;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < np; i++)
    {
        fp[i] = C2F(db3val)(&(xp[i]), &(yp[i]), &(zp[i]), &ox, &oy, &oz,
            stk(ltx), stk(lty), stk(lty), &nx, &ny, &nz,
            &kx, &ky, &kz, stk(lbcoef), stk(lwork));
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(; i < size; i++)
        {
            str[i] = (char*)MALLOC(sizeof(char) * (lengths[i] + 1));
            if (str[i] == NULL)
            {
                freeArrayOfString(str, i);
                Scierror(999, _("%s: No more memory.\n"), fname);
                return 0;
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0;i < N; i++)
  {
    ptrStrs[i] = strdup("TEST BUG 8688.");
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0 ; i < iRows ; i++)
    {
        piNewRow[i] = iCols - piNbItemRow[i];
        for(j = 0 ; j < iCols ; j++)
        {
            int iFind = 0;
            for(k = 0 ; k < piNbItemRow[i] ; k++)
            {
                if (piColPos[iCol + k] == (j + 1))
                {
                    iFind = 1;
                    break;
                }
            }

            if (iFind == 0)
            {
                piNewCol[iNewCol++] = (j + 1);
            }
        }

        iCol += piNbItemRow[i];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0 ; i < iRows * iCols ; i++)
    {
        pdblReal[i] = (double*)malloc(sizeof(double) * piNbCoef[i]);
        pdblImg[i] = (double*)malloc(sizeof(double) * piNbCoef[i]);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0 ; i < (iRows * iCols) / 2 ; i++)
    {
        int iPos1			= iRows * iCols - 1 - i;
        double* pdblSave	= NULL;
        int iNbCoefSave		= 0;
        //switch array of coefficient
        pdblSave			= pdblReal[i];
        pdblReal[i]			= pdblReal[iPos1];
        pdblReal[iPos1]		= pdblSave;
        pdblSave			= pdblImg[i];
        pdblImg[i]			= pdblImg[iPos1];
        pdblImg[iPos1]		= pdblSave;
        //switch number of coefficient
        iNbCoefSave			= piNbCoef[i];
        piNbCoef[i]			= piNbCoef[iPos1];
        piNbCoef[iPos1]		= iNbCoefSave;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0 ; i < iRows * iCols ; i++)
    {
        for(j = 0 ; j < piNbCoef[i] / 2 ; j++)
        {
            int iPos2			= piNbCoef[i] - 1 - j;
            double dblVal		= pdblReal[i][j];
            pdblReal[i][j]		= pdblReal[i][iPos2];
            pdblReal[i][iPos2]	= dblVal;
            dblVal				= pdblImg[i][j];
            pdblImg[i][j]		= pdblImg[i][iPos2];
            pdblImg[i][iPos2]	= dblVal;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0 ; i < iRows * iCols ; i++)
    {
        free(pdblReal[i]);
        free(pdblImg[i]);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0 ; i < iRows * iCols ; i++)
    {
        piBool[i] = piBool[i] == 0 ? 1 : 0;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0 ; i < iRows * iCols ; i++)
        {
            pdblReal[i] = pdblReal[i] * -1;
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0 ; i < _iRows * _iCols ; i++)
    {
        int iVal = 0;
        memcpy(&iVal, (char*)_pvDataIn + i * _iSize, _iSize);
        iVal *= _iCoeff;
        memcpy((char*)pvDataOut + i * _iSize, &iVal, _iSize);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0 ; i < _iRows * _iCols ; i++)
    {
        int iVal = 0;
        memcpy(&iVal, (char*)_pvDataIn + i * _iSize, _iSize);
        iVal *= _iCoeff;
        memcpy((char*)pvDataOut + i * _iSize, &iVal, _iSize);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0 ; i < iRows ; i++)
    {
        for(j = 0 ; j < piNbItemRow[i] ; j++)
        {
            sciprint("(%d,%d) = %f", i + 1, piColPos[k], pdblReal[k]);
            if (isVarComplex(pvApiCtx, piAddr))
            {
                sciprint(" %+fi", pdblImg[k]);
            }

            sciprint("\n");
            k++;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0 ; i < iItem ; i++)
    {
        int iType           = 0;
        int* piAddrChild    = NULL;

        sciErr = getListItemAddress(_pvCtx, _piAddress, i + 1, &piAddrChild);
        if (sciErr.iErr)
        {
            printError(&sciErr, 0);
            return 0;
        }

        sciErr = getVarType(_pvCtx, piAddrChild, &iType);
        if (sciErr.iErr)
        {
            printError(&sciErr, 0);
            return 0;
        }

        if (iType == sci_list || iType == sci_tlist || iType == sci_mlist)
        {
            insert_indent();
            sciprint("Child %d -> ", i + 1);
            iLocalTab++;
            iRet = get_list_info(_pvCtx, piAddrChild);
            iLocalTab--;

            if (iRet)
            {
                return 1;
            }
        }
        else
        {
            insert_indent();
            sciprint("Child %d -> address : 0x%08X\n", i + 1, piAddrChild);
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0 ; i < iLocalTab ; i++)
    {
        sciprint("\t");
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0 ; i < iRows1 ; i++)
    {
        for(j = 0 ; j < iCols1 ; j++)
        {
            pdblReal1[i + iRows1 * j] = i * iCols1 + j;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0 ; i < iRows1 * iCols1; i++)
    //{



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0 ; i < iRows2 ; i++)
    {
        for(j = 0 ; j < iCols2 ; j++)
        {
            pdblReal2[i + iRows2 * j] = i * iCols2 + j;
            pdblImg2 [i + iRows2 * j]	= (iRows2 * iCols2 - 1) - (i * iCols2 + j);
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0 ; i < iRows2 * iCols2; i++)
    //{



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0 ; i < iRows * iCols ; i++)
    {
        pstData[i] = (char*)malloc(sizeof(char) * (piLen[i] + 1));//+ 1 for null termination
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0 ; i < iRows * iCols ; i++)
    {
        iLen += piLen[i];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0 ; i < iRows ; i++)
    {
        for(j = 0 ; j < iCols ; j++)
        {
            int iCurLen = strlen(pstOut);
            if (iCurLen)
            {
                strcat(pstOut, " ");
            }
            strcpy(pstOut + strlen(pstOut), pstData[j * iRows + i]);
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0 ; i < iRows * iCols ; i++)
    {
        free(pstData[i]);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0 ; i < iTab ; i++)
    {
        sciprint("\t");
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0 ; i < iItem ; i++)
    {
        sciErr = getListItemAddress(_pvCtx, _piAddr, i + 1, &piChild);
        if (sciErr.iErr)
        {
            printError(&sciErr, 0);
            return 0;
        }

        iTab++;
        iRet = get_info(_pvCtx, _iRhs, _piAddr, piChild, i + 1);
        iTab--;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0 ; i < iRows * iCols ; i++)
        {
            pdblReal[i] = (double*)malloc(sizeof(double) * piCoeff[i]);
            pdblImg[i]  = (double*)malloc(sizeof(double) * piCoeff[i]);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0 ; i < iRows * iCols ; i++)
        {
            pdblReal[i] = (double*)malloc(sizeof(double) * piCoeff[i]);
            pdblImg[i]  = (double*)malloc(sizeof(double) * piCoeff[i]);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0 ; i < iRows * iCols ; i++)
    {
        free(pdblReal[i]);
        free(pdblImg[i]);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0 ; i < iRows * iCols ; i++)
        {
            pstData[i] = (char*)malloc(sizeof(char) * (piLen[i] + 1));//+ 1 for null termination
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0 ; i < iRows * iCols ; i++)
        {
            pstData[i] = (char*)malloc(sizeof(char) * (piLen[i] + 1));//+ 1 for null termination
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0 ; i < nbInputArgument(pvApiCtx) ; i++)
    {
        sciErr = printf_info(pvApiCtx, i + 1);
        if (sciErr.iErr)
        {
            printError(&sciErr, 0);
            break;
        }
        sciprint("\n\n");
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < *n; ++j) \



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < *n; ++j) {\
	    t =  C2F(gensum)(typ,m, &A[j * (*na) ], &c__1);\
	    V[iv] = (Type)t;iv += *nv;\
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < *m; ++i) {\
	    t =  C2F(gensum)(typ,n, &A[i], m);\
	    V[iv] = (Type)t;iv += *nv;\
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < *n; ++j) \



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < *n; ++j) {\
	    t =  C2F(gensumasdouble)(typ,m, &A[j * (*na) ], &c__1);\
	    v[iv] = t;iv += *nv;\
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < *m; ++i) {\
	    t =  C2F(gensumasdouble)(typ,n, &A[i], m);\
	    v[iv] = t;iv += *nv;\
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 0; k < *n; ++k) {           \
      t *= (int)IN[kk];                  \
    OUT[kk] =(Type)t;kk += (*iw); \
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 0; k < *n; ++k) {           \
      t *= (double)IN[kk];               \
    out[kk] =t;kk += (*iw); \
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 1; j <= i1; ++j) {\
	ljj = (indxj[j] - 1) * (*mr);\
	jj = (j - 1) * (*m3);\
	i2 = *mi;\
	for(i = 1; i <= i2; ++i)\
	    TO[indxi[i] + ljj] = FROM[(i - 1 + jj) * (*inc3) + 1];\
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i <= i1; ++i) {\
	itemp += DX[ix] * DY[iy];\
	ix += *incx;\
	iy += *incy;\
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 1; k <= n; ++k) {\
	iw[k] = 0;\
	lp += *nx;\
	for(l = 1; l <= m; ++l) {\
	    aa = Abs((double)X[lp + l]);\
	    if (aa == 0) {\
		fl = 0;\
	    } else {\
	      fl = (int)(log(aa)/log(10.))  ;\
	    }\
	    iw[k] = Max(iw[k],fl + 2);\
	}\
	s += iw[k];\
	if (s > *ll - 2) {\
	    iw[lbloc + nbloc] = k - 1;\
	    ++nbloc;\
	    iw[lbloc + nbloc] = n;\
	    s = iw[k];\
	}\
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ib = 1; ib <= nbloc; ++ib) {\
	k2 = iw[lbloc + ib];\
	if (nbloc != 1) {\
	    C2F(blktit)(lunit, &k1, &k2, &io);\
	    if (io == -1) return 0;\
	}\
	for(l = 1; l <= m; ++l) {\
	  cw[0] = dl;l1 = 1;\
	    for(k = k1; k <= k2; ++k) {\
		a = X[l + (k - 1) * *nx];\
                sprintf((char *)&(cw[l1]),Fmt,iw[k],a);\
		l1 += iw[k]+1;\
	    }\
	    cw[l1] = dl;\
	    C2F(basout)(&io, lunit, cw, l1+1);\
	    if (io == -1) return 0;\
	}\
	k1 = k2 + 1;\
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i <= i1; ++i) DY[i] = (Ytype) DX[i];\



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i <= i1; ++i) {\
	DY[iy] = (Ytype) DX[ix];\
	ix += *incx;iy += *incy;\
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 1; j <= i1; ++j) {\
	i2 = *l;\
	for(i = 1; i <= i2; ++i) \
	    C[ic + i] = C2F(gendot)(typ,m, &A[i], na, &B[ib], &c1);\
	ic += *nc;ib += *nb;\
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i <= ii1; ++i) {\
	    if (A[i1] == B[i2]) {\
		r[i] = 1;\
	    } else {\
		r[i] = 0;\
	    }\
	    i1 += *ia;i2 += *ib;\
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i <= ii1; ++i) {\
	    if (A[i1] != B[i2]) {\
		r[i] = 1;\
	    } else {\
		r[i] = 0;\
	    }\
	    i1 += *ia; i2 += *ib;\
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i <= ii1; ++i) {\
	    if (A[i1] < B[i2]) {\
		r[i] = 1;\
	    } else {\
		r[i] = 0;\
	    }\
	    i1 += *ia;i2 += *ib;\
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i <= ii1; ++i) {\
	    if (A[i1] > B[i2]) {\
		r[i] = 1;\
	    } else {\
		r[i] = 0;\
	    }\
	    i1 += *ia;i2 += *ib;\
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i <= ii1; ++i) {\
	    if (A[i1] <= B[i2]) {\
		r[i] = 1;\
	    } else {\
		r[i] = 0;\
	    }\
	    i1 += *ia;i2 += *ib;\
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i <= ii1; ++i) {\
	    if (A[i1] >= B[i2]) {\
		r[i] = 1;\
	    } else {\
		r[i] = 0;\
	    }\
	    i1 += *ia;i2 += *ib;\
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 1; k <= i1; ++k) {\
	    if (B[jb] == 0) {*ierr = k;return 0;}\
	    R[jr] = A[ja] / B[jb];\
	    jr += *ir;jb += *ib;\
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 1; k <= i1; ++k) {\
	    R[jr] = A[ja] / B[jb];\
	    jr += *ir;ja += *ia;\
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 1; k <= i1; ++k) {\
	    if (B[jb] == 0) {*ierr = k;return 0;}\
	    R[jr] = A[ja] / B[jb];\
	    jr += *ir;jb += *ib;ja += *ia;\
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i <= *n; ++i) { \
	DY[iy] = *DX;iy += *incy;}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(l = 1; l <= *m; ++l){\
          DY[l] = DX[l];DK[l] = 1;\
	  for(k = 1; k < *n; ++k) {\
            if (DX[l+k*ix] > DY[l]) {\
              DY[l] = DX[l+k*ix];DK[l] = k+1;}}}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 0; k < *n; ++k){\
          kk = k*ix;\
          DY[1+k*iy] = DX[1+kk];DK[1+k*iy] = 1;\
	  for(l = 2; l <= *m; ++l) {\
            if (DX[l+kk] > DY[1+k*iy]) {\
              DY[1+k*iy] = DX[l+kk];DK[1+k*iy] = l;}}}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 0; k < *n; ++k){\
          kk = k*ix;\
	  for(l = 1; l <= *m; ++l) {\
            if (DX[l+kk] > DY[1]) {\
	      DY[1] = DX[l+kk];DK[1] = l + kk;}}}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i <= i1; ++i) DY[i] = (Type) dx[i];\



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i <= i1; ++i) {\
	DY[iy] = (Type) dx[ix];\
	ix += *incx;iy += *incy;\
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < *n; ++j) {\
        C2F(gencuprod)(typ,m, &IN[j * (*na) ], &OUT[j * (*na) ], &c__1);\
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < *m; ++i) {\
        C2F(gencuprod)(typ,n, &IN[i], &OUT[i], na);\
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < *n; ++j) {\
        C2F(gencuprodasdouble)(typ,m, &IN[j * (*na) ],&out[j * (*na) ], &c__1);\
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < *m; ++i) {\
        C2F(gencuprodasdouble)(typ,n, &IN[i], &out[i], na);\
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i <= *mi; ++i) \



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i <= nn*nn; ++i) {\
       DY[i] = 0;}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < *n; ++i) {\
       DY[iy+i*(nn+1)] = DX[i];}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 1; j <= *nj; ++j) \



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i <= *mi; ++i) {\
	    TO[l] = FROM[indxi[i]+(indxj[j]-1)*(*m)];\
	    l = l+1;}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 1; j <= nn; ++j) {\
      if (ll > *m) ll = *m;\
      for(i = 0; i < ll; ++i) \
        DX[ls+i] = 0;\
      ll++;\
      ls = ls + *m;\
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(jx = 1; jx <= *nx; ++jx) {\
      ky = 1;\
      kx1 = kx1 + ix;\
      kk1 = kk1 + *ny;\
      for(jy = 1; jy <= *ny; ++jy){\
        kx = kx1;\
        kk = 1 + (jy - 1 + kk1) * ir;\
        for(i = 1; i <= *mx; ++i){\
          for(l = 0; l < *my; ++l)\
   	       DR[kk + l] = DY[ky + l] * DX[kx];\
   	     kk = kk + *my;\
   	     kx = kx + 1;}\
   	   ky = ky + iy;}}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i <= (*m2)*(*n2); ++i) \



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i <= *n; ++i) {\
      if ((Ytype)DX[ix] > DY[i]) {\
        DY[i] = (Ytype)DX[ix];\
	ind[i-1] = *no;}\
	ix = ix + *incx;\
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < (*m)*kk; ++i) \



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 1; j <= nn; ++j) {\
      if (ll > 0) {\
        for(i = 0; i < ll; ++i) \
          DX[ls+i] = 0;\
        ll--;\
        ls = ls + *m +1;\
      }\
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < *n; ++j) {              \
        C2F(gencusum)(typ,m, &IN[j * (*na) ],&OUT[j * (*na) ], &c__1);\
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < *m; ++i) {              \
        C2F(gencusum)(typ,n, &IN[i], &OUT[i], na);\
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < *n; ++j) {\
        C2F(gencusumasdouble)(typ,m, &IN[j * (*na) ],&out[j * (*na) ], &c__1);\
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < *m; ++i) {\
        C2F(gencusumasdouble)(typ,n, &IN[i], &out[i], na);\
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i <= *n; ++i) dtemp *= (Typeout) DX[i];\



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i2 < 0 ? i >= i1 : i <= i1; i += i2) dtemp *= (Typeout) DX[i];\



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i <= i1; ++i)  DX[i] = DX[i] - DY[i];\



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i <= i1; ++i) {\
	DX[ix] = DX[ix] - DY[iy];\
	ix += *incx; iy += *incy;\
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i <= nv; ++i) \



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i <= nv; ++i) {\
	DY[iy] = DX[ix] + DY[iy];\
	ix += *incx; iy += *incy;\
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i <= *n; ++i) {\
      if ((Ytype)DX[ix] < DY[i]) {\
        DY[i] = (Ytype)DX[ix];\
	ind[i-1] = *no;}\
	ix = ix + *incx;\
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i <= mn; ++i) B[i] = A[i];\



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 1; j <= *n; ++j) {\
      ia += *na;ib += *nb;\
      for(i = 1; i <= *m; ++i) B[ib + i] = A[ia + i];\
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i2 < 0 ? i >= i1 : i <= i1; i += i2) {\
	DX[i] = Abs(DX[i]);\
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 1; j <= i1; ++j) {\
	ib = j;\
	for(i = 1; i <= i2; ++i) {\
	    B[ib] = A[ia + i];\
	    ib += *nb;\
	}\
	ia += *na;\
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 0; k < *n; ++k) {        \
      t += (int)IN[kk];               \
    OUT[kk] =(Type)t;kk += (*iw);     \
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 0; k < *n; ++k) {\
      t += (double)IN[kk];                      \
    out[kk] =t;kk += (*iw);\
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i <= *mi; ++i) \



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < mn; ++i) \



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i <= *n; ++i) if ((int) DX[i]!=0) {dtemp = 1;break;}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i2 < 0 ? i >= i1 : i <= i1; i += i2) if ((int) DX[i]!=0) {dtemp = 1;break;}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i <= *n; ++i) \



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i <= *n; ++i) {\
	DY[iy] = DX[ix];\
	ix += *incx;\
	iy += *incy;\
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i <= i1; ++i) DY[i] *= DX[i];\



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i <= i1; ++i) {\
	DY[iy] *= DX[ix];\
	ix += *incx;iy += *incy;\
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i2 < 0 ? i >= i1 : i <= i1; i += i2) {\
	DX[i] = (*DA) * DX[i];\
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < *n; ++j) \



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < *n; ++j) {\
        t =  C2F(genprod)(typ,m, &A[j * (*na) ], &c__1);\
        V[iv] = (Type)t;iv += *nv;\
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < *m; ++i) {\
        t =  C2F(genprod)(typ,n, &A[i], m);\
        V[iv] = (Type)t;iv += *nv;\
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < *n; ++j) \



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < *n; ++j) {\
        v[iv] =  C2F(genprodasdouble)(typ,m, &A[j * (*na) ], &c__1);\
        iv += *nv;\
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < *m; ++i) {\
        v[iv] =  C2F(genprodasdouble)(typ,n, &A[i], m);\
        iv += *nv;\
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=FIRST;j<=LAST;j++){\
      RES[i++]=j;\
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=FIRST;j>=LAST;j+=STEP){\
        RES[i++]=j;\
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=FIRST;j<=LAST;j+=STEP){\
        RES[i++]=j;\
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=FIRST;j>=LAST;j=j+STEP) {i++;}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=FIRST;j<=LAST;j=j+STEP) {i++;}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i <= nv; ++i) \



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i <= nv; ++i) {\
	DY[iy] = DX[ix] Op DY[iy];\
	ix += *incx; iy += *incy;\
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i <= nv; ++i) \



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i <= nv; ++i) {\
	DX[iy] = Op DX[ix];\
	ix += *incx;\
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m;i++) {\
          B[i]=A[i+(j-1)*m]; \
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i <= *n; ++i) dtemp += (Typeout) DX[i];\



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i2 < 0 ? i >= i1 : i <= i1; i += i2) dtemp += (Typeout) DX[i];\



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 1; j <= *n1; ++j) {\
      i1 += *m1; i2 += *m2; \
      ir1 += m; ir2 += m; \
      for(i = 1; i <= *m1; ++i) XR[ir1 + i] = X1[i1 + i]; \
      for(i = 1; i <= *m2; ++i) XR[ir2 + i] = X2[i2 + i]; \
     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(l = 1; l <= *m; ++l){\
          DY[l] = DX[l];DK[l] = 1;\
	  for(k = 1; k < *n; ++k) {\
            if (DX[l+k*ix] < DY[l]) {\
              DY[l] = DX[l+k*ix];DK[l] = k+1;}}}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 0; k < *n; ++k){\
          kk = k*ix;\
          DY[1+k*iy] = DX[1+kk];DK[1+k*iy] = 1;\
	  for(l = 2; l <= *m; ++l) {\
            if (DX[l+kk] < DY[1+k*iy]) {\
              DY[1+k*iy] = DX[l+kk];DK[1+k*iy] = l;}}}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 0; k < *n; ++k){\
          kk = k*ix;\
	  for(l = 1; l <= *m; ++l) {\
            if (DX[l+kk] < DY[1]) {\
	      DY[1] = DX[l+kk];DK[1] = l + kk;}}}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = kmin; k <= srhs; k++) {

        lk = *Lstk(topk);ilk=iadr(lk);
        nk = *Lstk(topk+1)-lk;
        if (*istk(ilk) < 0) {
            lk= *istk(ilk+1);
            nk = *istk(ilk+3);
        }

        res = IsEqualVar(stk(l1),n1,stk(lk),nk);
        if (res==-1) { 
            
            Ids[1 + Pt * nsiz] = k;
            Ids[2 + Pt * nsiz] = srhs;
            Ids[3 + Pt * nsiz] = topk;
            return 0;
        }
        else if (res == -2) {
            SciError(112);
            FreeRec();
            return 0;
        }
        

        if (res == 0) {
            
            Top = top1;
            C2F(crebmat)(fname, &top1, &one, &one, &l, (unsigned long)strlen(fname));
            *istk(l)=res;
            FreeRec();

            return 0;
        }
        topk++;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i<n; i++){
        if (d1[i] != d2[i]) return 0;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i<n; i++){
        if (l1[i] != l2[i]) return 0;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i<n; i++){
        if (d1[i] != d2[i]) return 0;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i <n; ++i) {\
    if (A[i] != B[i]) return 0;\
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( j= 0 ; j < p ; j++ ) 
	{
	  for( i = 0 ; i < n ; i++) 
	    ind[i+n*j]= i+1;
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( j= 0 ; j < p ; j++ ) 
    {
      sciqsort((char *) (a+n*j),(char *) (ind+n*j),flag, n, 
	       sizeof(char),sizeof(int), 
	       (dir == 'i' ) ? compareCchar : compareDchar,
	       swapcodechar,swapcodeind);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < n ; i++) 
	{
	  for( j= 0 ; j < p ; j++ ) 
	    {
	      ind[i+n*j]= j+1;
	    }
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < n ; i++) 
    {
      sciqsort((char *) (a+i),(char *) (ind+i),flag, p, 
	       n*sizeof(char),n*sizeof(int), 
	       (dir == 'i' ) ? compareCchar:compareDchar,
	       swapcodechar,swapcodeind);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < n*p ; i++) 
	ind[i]= i+1;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( j= 0 ; j < p ; j++ ) 
	{
	  for( i = 0 ; i < n ; i++) 
	    ind[i+n*j]= i+1;
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( j= 0 ; j < p ; j++ ) 
    {
      sciqsort((char *) (a+n*j),(char *) (ind+n*j),flag, n, 
	       sizeof(char),sizeof(int), 
	       (dir == 'i' ) ? compareCuchar : compareDuchar,
	       swapcodechar,swapcodeind);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < n ; i++) 
	{
	  for( j= 0 ; j < p ; j++ ) 
	    {
	      ind[i+n*j]= j+1;
	    }
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < n ; i++) 
    {
      sciqsort((char *) (a+i),(char *) (ind+i),flag, p, 
	       n*sizeof(char),n*sizeof(int), 
	       (dir == 'i' ) ? compareCuchar:compareDuchar,
	       swapcodechar,swapcodeind);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < n*p ; i++) 
	ind[i]= i+1;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( jc = 0 ; jc < lexicolschar ; jc++) 
    {
      if (*i > *j)
	return (1);
      if (*i < *j)
	return (-1);
      i += lexirowschar;
      j += lexirowschar;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( jc = 0 ; jc < lexicolschar ; jc++) 
    {
      if (*i < *j)
	return (1);
      if (*i > *j)
	return (-1);
      i += lexirowschar;
      j += lexirowschar;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( jc = 0 ; jc < lexicolschar ; jc++) 
    {
      if (*i > *j)
	return (1);
      if (*i < *j)
	return (-1);
      i += lexirowschar;
      j += lexirowschar;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( jc = 0 ; jc < lexicolschar ; jc++) 
    {
      if (*i < *j)
	return (1);
      if (*i > *j)
	return (-1);
      i += lexirowschar;
      j += lexirowschar;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( j = 0 ; j < lexicolschar ; j++) 
      {
	register char t = *(pi +lexirowschar*j);		
	*(pi + lexirowschar*j) = *(pj+lexirowschar*j);				
	*(pj + lexirowschar*j) = t;	
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < n ; i++) 
	ind[i]= i+1;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < n ; i++) 
	ind[i]= i+1;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( ic = 0 ; ic < lexirowschar ; ic++) 
    {
      if (*i > *j)
	return (1);
      if (*i < *j)
	return (-1);
      i++;
      j++;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( ic = 0 ; ic < lexirowschar ; ic++) 
    {
      if (*i < *j)
	return (1);
      if (*i > *j)
	return (-1);
      i++;
      j++;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( ic = 0 ; ic < lexirowschar ; ic++) 
    {
      if (*i > *j)
	return (1);
      if (*i < *j)
	return (-1);
      i++;
      j++;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( ic = 0 ; ic < lexirowschar ; ic++) 
    {
      if (*i < *j)
	return (1);
      if (*i > *j)
	return (-1);
      i++;
      j++;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( ir = 0 ; ir < lexirowschar ; ir++) 
      {
	register char t = *(pi +ir);		
	*(pi +ir) = *(pj+ir);				
	*(pj +ir) = t;	
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < p ; i++) 
	ind[i]= i+1;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < p ; i++) 
	ind[i]= i+1;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i <= i1; ++i) dy[i] = (double)dx[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i <= i1; ++i)
	{
		dy[iy] = (double)dx[ix];
		ix += *incx;
		iy += *incy;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<*n;i++) 
    {
        y[iy1] = ceil(x[ix1]);
        iy1 += *iy;
        ix1 += *ix;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(pm = a + es, tabm= tab + es1 ; pm < (char *) a + n * es; pm += es, tabm +=es1 )
      {
	for(pl = pm, tabl= tabm ; pl > (char *) a && cmp(pl - es, pl,tabl-es1,tabl,flag) > 0;  pl -= es, tabl -=es1)
	  {
	    swapind(tabl,tabl-es1);
	    swap(pl, pl - es);
	  }
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(;;) {
    
    while (pb <= pc && (r = cmp(pb, a,tabb,tab,flag)) <= 0) {
      if (r == 0) {
	
	swap_cnt = 1;
	swapind(taba,tabb);
	taba +=es1;
	swap(pa, pb);
	pa += es;
      }
      pb += es;
      tabb += es1;
    }

    
    
    while (pb <= pc && (r = cmp(pc, a,tabc,tab,flag)) >= 0) {
      if (r == 0) {
	
	swap_cnt = 1;
	swapind(tabc,tabd);
	tabd -= es1;
	swap(pc, pd);
	pd -= es;
      }
      pc -= es;
      tabc -= es1;
    }
    
    if (pb > pc){
      


   
      
      break;
    }    
    





    swapind(tabb,tabc);
    tabb += es1;
    tabc -= es1;
    swap(pb, pc);
    swap_cnt = 1;
    
    pb += es;
    pc -= es;
   


 
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(pm = a + es, tabm= tab + es1 ; pm < (char *) a + n * es; pm += es, tabm +=es1)
      {
	for(pl = pm, tabl= tabm ; pl > (char *) a && cmp(pl - es, pl,tabl-es1,tabl,flag) > 0;  pl -= es, tabl -=es1)
	  {
	    swapind(tabl,tabl-es1);
	    swap(pl, pl - es);
	  }
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( j= 0 ; j < p ; j++ ) 
	{
	  for( i = 0 ; i < n ; i++) 
	    ind[i+n*j]= i+1;
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( j= 0 ; j < p ; j++ ) 
    {
      sciqsort((char *) (a+n*j),(char *) (ind+n*j),flag, n, 
	       sizeof(double),sizeof(int), 
	       (dir == 'i' ) ? compareCdouble : compareDdouble,
	       swapcodedouble,swapcodeind);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < n ; i++) 
	{
	  for( j= 0 ; j < p ; j++ ) 
	    {
	      ind[i+n*j]= j+1;
	    }
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < n ; i++) 
    {
      sciqsort((char *) (a+i),(char *) (ind+i),flag, p, 
	       n*sizeof(double),n*sizeof(int), 
	       (dir == 'i' ) ? compareCdouble:compareDdouble,
	       swapcodedouble,swapcodeind);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < n*p ; i++) ind[i]= i+1;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( jc = 0 ; jc < lexicolsdouble ; jc++) 
    {
      if (*i > *j)
	return (1);
      if (*i < *j)
	return (-1);
      i += lexirowsdouble;
      j += lexirowsdouble;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( jc = 0 ; jc < lexicolsdouble ; jc++) 
    {
      if (*i < *j)
	return (1);
      if (*i > *j)
	return (-1);
      i += lexirowsdouble;
      j += lexirowsdouble;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( j = 0 ; j < lexicolsdouble ; j++) 
      {
	register double t = *(pi +lexirowsdouble*j);		
	*(pi + lexirowsdouble*j) = *(pj+lexirowsdouble*j);				
	*(pj + lexirowsdouble*j) = t;	
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < n ; i++) 
	ind[i]= i+1;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( ic = 0 ; ic < lexirowsdouble ; ic++) 
    {
      if (*i > *j)
	return (1);
      if (*i < *j)
	return (-1);
      i++;
      j++;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( ic = 0 ; ic < lexirowsdouble ; ic++) 
    {
      if (*i < *j)
	return (1);
      if (*i > *j)
	return (-1);
      i++;
      j++;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( ir = 0 ; ir < lexirowsdouble ; ir++) 
      {
	register double t = *(pi +ir);		
	*(pi +ir) = *(pj+ir);				
	*(pj +ir) = t;	
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < p ; i++) 
	ind[i]= i+1;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < *n; i++)
		{
			dy[iy] = dx[ix];
			ix += *incx;
			iy += *incy;
		}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i < *n; i++) 
    if (finite(v[i])==0) return 0;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i < *n; i++) 
    if (finiteComplex(v[i])==0) return 0;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( j= 0 ; j < p ; j++ ) 
	{
	  for( i = 0 ; i < n ; i++) 
	    ind[i+n*j]= i+1;
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( j= 0 ; j < p ; j++ ) 
    {
      sciqsort((char *) (a+n*j),(char *) (ind+n*j),flag, n, 
	       sizeof(int),sizeof(int), 
	       (dir == 'i' ) ? compareCint : compareDint,
	       swapcodeint,swapcodeind);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( j= 0 ; j < p ; j++ ) 
	{
	  for( i = 0 ; i < n ; i++) 
	    ind[i+n*j]= i+1;
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( j= 0 ; j < p ; j++ ) 
    {
      sciqsort((char *) (a+n*j),(char *) (ind+n*j),flag, n, 
	       sizeof(int),sizeof(int), 
	       (dir == 'i' ) ? compareCuint : compareDuint,
	       swapcodeint,swapcodeind);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < n ; i++) 
	{
	  for( j= 0 ; j < p ; j++ ) 
	    {
	      ind[i+n*j]= j+1;
	    }
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < n ; i++) 
    {
      sciqsort((char *) (a+i),(char *) (ind+i),flag, p, 
	       n*sizeof(int),n*sizeof(int), 
	       (dir == 'i' ) ? compareCint:compareDint,
	       swapcodeint,swapcodeind);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < n ; i++) 
	{
	  for( j= 0 ; j < p ; j++ ) 
	    {
	      ind[i+n*j]= j+1;
	    }
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < n ; i++) 
    {
      sciqsort((char *) (a+i),(char *) (ind+i),flag, p, 
	       n*sizeof(int),n*sizeof(int), 
	       (dir == 'i' ) ? compareCuint:compareDuint,
	       swapcodeint,swapcodeind);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < n*p ; i++) 
	ind[i]= i+1;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < n*p ; i++) 
	ind[i]= i+1;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( jc = 0 ; jc < lexicolsint ; jc++) 
    {
      if (*i > *j)
	return (1);
      if (*i < *j)
	return (-1);
      i += lexirowsint;
      j += lexirowsint;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( jc = 0 ; jc < lexicolsint ; jc++) 
    {
      if (*i > *j)
	return (1);
      if (*i < *j)
	return (-1);
      i += lexirowsint;
      j += lexirowsint;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( jc = 0 ; jc < lexicolsint ; jc++) 
    {
      if (*i < *j)
	return (1);
      if (*i > *j)
	return (-1);
      i += lexirowsint;
      j += lexirowsint;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( jc = 0 ; jc < lexicolsint ; jc++) 
    {
      if (*i < *j)
	return (1);
      if (*i > *j)
	return (-1);
      i += lexirowsint;
      j += lexirowsint;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( j = 0 ; j < lexicolsint ; j++) 
      {
	register int t = *(pi +lexirowsint*j);		
	*(pi + lexirowsint*j) = *(pj+lexirowsint*j);				
	*(pj + lexirowsint*j) = t;	
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < n ; i++) 
	ind[i]= i+1;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < n ; i++) 
	ind[i]= i+1;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( ic = 0 ; ic < lexirowsint ; ic++) 
    {
      if (*i > *j)
	return (1);
      if (*i < *j)
	return (-1);
      i++;
      j++;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( ic = 0 ; ic < lexirowsint ; ic++) 
    {
      if (*i > *j)
	return (1);
      if (*i < *j)
	return (-1);
      i++;
      j++;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( ic = 0 ; ic < lexirowsint ; ic++) 
    {
      if (*i < *j)
	return (1);
      if (*i > *j)
	return (-1);
      i++;
      j++;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( ic = 0 ; ic < lexirowsint ; ic++) 
    {
      if (*i < *j)
	return (1);
      if (*i > *j)
	return (-1);
      i++;
      j++;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( ir = 0 ; ir < lexirowsint ; ir++) 
      {
	register int t = *(pi +ir);		
	*(pi +ir) = *(pj+ir);				
	*(pj +ir) = t;	
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < p ; i++) 
	ind[i]= i+1;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < p ; i++) 
	ind[i]= i+1;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = j + 1; i <= i1; ++i) 
	{
		if (x[i * x_dim1 + 1] < xmin) 
		{
			



			xmin = x[i * x_dim1 + 1];
			ret_val = i;
		}
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<*n;i++) 
    {
        y[iy1] = floor(x[ix1]);
        iy1 += *iy;
        ix1 += *ix;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < len; i++)
        {
            if ((pStr[i] >= char_zero) && (pStr[i] <= char_nine))
            {
                result = (numberbase * result) + (int)pStr[i] - char_zero;
            }
            else if ((pStr[i] >= char_A) && (pStr[i] <= char_Z))
            {
                int vTmp = (int)pStr[i] - char_A + 10;
                if (vTmp > numberbase)
                {
                    *err = ERROR_CONVERTBASE_INVALID_REPRESENTATION;
                    return 0;
                }
                else
                {
                    result = (numberbase * result) + vTmp;
                }
            }
            else if ((pStr[i] >= char_a) && (pStr[i] <= char_z))
            {
                int vTmp = (int)pStr[i] - char_a + 10;
                if ( vTmp > numberbase)
                {
                    *err = ERROR_CONVERTBASE_INVALID_REPRESENTATION;
                    return 0;
                }
                else
                {
                    result = (numberbase * result) + vTmp;
                }
            }
            else
            {
                return 0;
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = i - 1; j > (i / 2 - t); j--)
            {
                char ch  = chResult[j];
                chResult[j] = chResult[k];
                chResult[k++] = ch;
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nbDigits - lenConvertedValue; i++)
                {
                    tmp[i] = '0';
                }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < mn; i++)
    {
        long long int iValue = (long long int) dValues[i];

        
        if (dValues[i] > maxVal)
        {
            maxVal = dValues[i];
        }

        
        if (dValues[i] != (double)iValue)
        {
            *err = ERROR_CONVERTBASE_NOT_INTEGER_VALUE;
            return NULL;
        }

        
        if ((dValues[i] < 0) || (dValues[i] > pow(2, 52)))
        {
            *err = ERROR_CONVERTBASE_NOT_IN_INTERVAL;
            return NULL;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < mn; i++)
        {
            convertedValues[i] = convertDec2Base(dValues[i], numberbase, nbDigits, err);
            if (*err)
            {
                freeArrayOfString(convertedValues, mn);
                return NULL;
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( j= 0 ; j < p ; j++ ) 
	{
	  for( i = 0 ; i < n ; i++) 
	    ind[i+n*j]= i+1;
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( j= 0 ; j < p ; j++ ) 
    {
      sciqsort((char *) (a+n*j),(char *) (ind+n*j),flag, n, 
	       sizeof(char *),sizeof(int), 
	       (dir == 'i' ) ? compareCstring : compareDstring,
	       swapcodestring,swapcodeind);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < n ; i++) 
	{
	  for( j= 0 ; j < p ; j++ ) 
	    {
	      ind[i+n*j]= j+1;
	    }
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < n ; i++) 
    {
      sciqsort((char *) (a+i),(char *) (ind+i),flag, p, 
	       n*sizeof(char *),n*sizeof(int), 
	       (dir == 'i' ) ? compareCstring:compareDstring,
	       swapcodestring,swapcodeind);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < n*p ; i++) 
	ind[i]= i+1;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( jc = 0 ; jc < lexicolsstring ; jc++) 
    {
      int k = strcmp(*i,*j);
      if ( k != 0) return(k);
      i += lexirowsstring;
      j += lexirowsstring;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( jc = 0 ; jc < lexicolsstring ; jc++) 
    {
      int k = strcmp(*i,*j);
      if ( k != 0) return(-k);
      i += lexirowsstring;
      j += lexirowsstring;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( j = 0 ; j < lexicolsstring ; j++) 
      {
	register char * t = *(pi +lexirowsstring*j);		
	*(pi + lexirowsstring*j) = *(pj+lexirowsstring*j);				
	*(pj + lexirowsstring*j) = t;	
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < n ; i++) 
	ind[i]= i+1;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( ic = 0 ; ic < lexirowsstring ; ic++) 
    {
      int k = strcmp(*i,*j);
      if ( k != 0) return(k);
      i++;
      j++;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( ic = 0 ; ic < lexirowsstring ; ic++) 
    {
      int k = strcmp(*i,*j);
      if ( k != 0) return(-k);
      i++;
      j++;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( ir = 0 ; ir < lexirowsstring ; ir++) 
      {
	register char * t = *(pi +ir);		
	*(pi +ir) = *(pj+ir);				
	*(pj +ir) = t;	
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < p ; i++) 
	ind[i]= i+1;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < *n; i++) 
    {
        y[iy1] = frexp(x[ix1],&j);
        z[iz1] = j;
        iy1 += *iy;
        ix1 += *ix;
        iz1 += *iz;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i < *n; i++) res[i]=0;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i < *n; i++) 
    {
#ifdef NAN_CHECK 
      if ( C2F(isanan)(&x[i])== 1 || C2F(isanan)(&y[i])== 1 ) 
	res[i]= 0; 
      else 
	res[i]= x[i]== y[i]; 
#else 
    res[i]= x[i]== y[i]; 
#endif 
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i < *n; i++) 
    {
#ifdef NAN_CHECK 
      if ( C2F(isanan)(&x[i])== 1 || C2F(isanan)(&y[i])== 1 ) 
	res[i]= 1; 
      else 
	res[i]= x[i] != y[i]; 
#else 
      res[i]= x[i] != y[i]; 
#endif 
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i < *n; i++) 
    {
#ifdef NAN_CHECK 
      if ( C2F(isanan)(&x[i])== 1 || C2F(isanan)(&y[i])== 1 ) 
	res[i]= 0; 
      else 
	res[i]= x[i] <  y[i]; 
#else 
      res[i]= x[i] <  y[i]; 
#endif 
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i < *n; i++) 
    {
#ifdef NAN_CHECK 
      if ( C2F(isanan)(&x[i])== 1 || C2F(isanan)(&y[i])== 1 ) 
	res[i]= 0; 
      else 
	res[i]= x[i] >  y[i]; 
#else 
      res[i]= x[i] >  y[i]; 
#endif 
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i < *n; i++) 
    {
#ifdef NAN_CHECK 
      if ( C2F(isanan)(&x[i])== 1 || C2F(isanan)(&y[i])== 1 ) 
	res[i]= 0; 
      else 
	res[i]= x[i] <=  y[i]; 
#else 
      res[i]= x[i] <=  y[i]; 
#endif 
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i < *n; i++) 
    {
#ifdef NAN_CHECK 
      if ( C2F(isanan)(&x[i])== 1 || C2F(isanan)(&y[i])== 1 ) 
	res[i]= 0; 
      else 
	res[i]= x[i] >=  y[i]; 
#else 
      res[i]= x[i] >=  y[i]; 
#endif 
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i <= i1; ++i) dy[i] = (double) dx[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i <= i1; ++i) 
	{
		dy[iy] = (double) dx[ix];
		ix += *incx;
		iy += *incy;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = j + 1; i <= i1; ++i) 
	{
		if (x[i * x_dim1 + 1] > xmax) 
		{
			



			xmax = x[i * x_dim1 + 1];
			ret_val = i;
		}
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < *n; i++)
		{
			dy[iy] = dx[ix];
			ix += *incx;
			iy += *incy;
		}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( j= 0 ; j < p ; j++ ) 
	{
	  for( i = 0 ; i < n ; i++) 
	    ind[i+n*j]= i+1;
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( j= 0 ; j < p ; j++ ) 
    {
      sciqsort((char *) (a+n*j),(char *) (ind+n*j),flag, n, 
	       sizeof(short),sizeof(int), 
	       (dir == 'i' ) ? compareCshort : compareDshort,
	       swapcodeshort,swapcodeind);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < n ; i++) 
	{
	  for( j= 0 ; j < p ; j++ ) 
	    {
	      ind[i+n*j]= j+1;
	    }
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < n ; i++) 
    {
      sciqsort((char *) (a+i),(char *) (ind+i),flag, p, 
	       n*sizeof(short),n*sizeof(int), 
	       (dir == 'i' ) ? compareCshort:compareDshort,
	       swapcodeshort,swapcodeind);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < n*p ; i++) 
	ind[i]= i+1;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( j= 0 ; j < p ; j++ ) 
	{
	  for( i = 0 ; i < n ; i++) 
	    ind[i+n*j]= i+1;
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( j= 0 ; j < p ; j++ ) 
    {
      sciqsort((char *) (a+n*j),(char *) (ind+n*j),flag, n, 
	       sizeof(short),sizeof(int), 
	       (dir == 'i' ) ? compareCushort : compareDushort,
	       swapcodeshort,swapcodeind);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < n ; i++) 
	{
	  for( j= 0 ; j < p ; j++ ) 
	    {
	      ind[i+n*j]= j+1;
	    }
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < n ; i++) 
    {
      sciqsort((char *) (a+i),(char *) (ind+i),flag, p, 
	       n*sizeof(short),n*sizeof(int), 
	       (dir == 'i' ) ? compareCushort:compareDushort,
	       swapcodeshort,swapcodeind);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < n*p ; i++) 
	ind[i]= i+1;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( jc = 0 ; jc < lexicolsshort ; jc++) 
    {
      if (*i > *j)
	return (1);
      if (*i < *j)
	return (-1);
      i += lexirowsshort;
      j += lexirowsshort;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( jc = 0 ; jc < lexicolsshort ; jc++) 
    {
      if (*i < *j)
	return (1);
      if (*i > *j)
	return (-1);
      i += lexirowsshort;
      j += lexirowsshort;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( jc = 0 ; jc < lexicolsshort ; jc++) 
    {
      if (*i > *j)
	return (1);
      if (*i < *j)
	return (-1);
      i += lexirowsshort;
      j += lexirowsshort;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( jc = 0 ; jc < lexicolsshort ; jc++) 
    {
      if (*i < *j)
	return (1);
      if (*i > *j)
	return (-1);
      i += lexirowsshort;
      j += lexirowsshort;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( j = 0 ; j < lexicolsshort ; j++) 
      {
	register short t = *(pi +lexirowsshort*j);		
	*(pi + lexirowsshort*j) = *(pj+lexirowsshort*j);				
	*(pj + lexirowsshort*j) = t;	
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < n ; i++) 
	ind[i]= i+1;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < n ; i++) 
	ind[i]= i+1;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( ic = 0 ; ic < lexirowsshort ; ic++) 
    {
      if (*i > *j)
	return (1);
      if (*i < *j)
	return (-1);
      i++;
      j++;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( ic = 0 ; ic < lexirowsshort ; ic++) 
    {
      if (*i < *j)
	return (1);
      if (*i > *j)
	return (-1);
      i++;
      j++;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( ic = 0 ; ic < lexirowsshort ; ic++) 
    {
      if (*i > *j)
	return (1);
      if (*i < *j)
	return (-1);
      i++;
      j++;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( ic = 0 ; ic < lexirowsshort ; ic++) 
    {
      if (*i < *j)
	return (1);
      if (*i > *j)
	return (-1);
      i++;
      j++;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( ir = 0 ; ir < lexirowsshort ; ir++) 
      {
	register short t = *(pi +ir);		
	*(pi +ir) = *(pj+ir);				
	*(pj +ir) = t;	
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < p ; i++) 
	ind[i]= i+1;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < p ; i++) 
	ind[i]= i+1;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < m1 * n1; i++)
                    tmp_matrix[i] = matrix[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < m1 * n1; i++)
                        tmp_matrix[i] = matrix[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < m1 * n1; i++)
                        tmp_matrix[i] = matrix[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < m1 * n1; i++)
                        tmp_matrix[i] = matrix[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < m1 * n1; i++)
                        tmp_matrix[i] = matrix[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < m1 * n1; i++)
                        tmp_matrix[i] = matrix[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < m1 * n1; i++)
                        tmp_matrix[i] = matrix[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < m * n; i++)
    {
        error_convertbase err = ERROR_CONVERTBASE_NOK;
        dResults[i] = convertBase2Dec(pStrs[i], iValue, &err);
        if (err != ERROR_CONVERTBASE_OK)
        {
            freeAllocatedMatrixOfString(m, n, pStrs);
            pStrs = NULL;

            FREE(dResults);
            dResults = NULL;

            Scierror(999, _("%s: Wrong value for input argument(s): Valid base %d representations expected.\n"), fname, iValue);
            return 0;

        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(; i < listLen - 1; i++)
        {
            switch (types[i])
            {
                case sci_matrix :
                {
                    int nbCol = 0;
                    int j = 0, k = 0;
                    double * real = 0;
                    double * imag = 0;
                    int nbRow = 0;

                    jobjectArray infos = (jobjectArray)(*jenv)->GetObjectArrayElement(jenv, list, i + 1);
                    int isReal = (*jenv)->GetArrayLength(jenv, infos) == 1;
                    jobjectArray data = (jobjectArray)(*jenv)->GetObjectArrayElement(jenv, infos, 0);

                    if (!data)
                    {
                        // empty matrix
                        sciErr = createMatrixOfDoubleInNamedList(pvApiCtx, varName, currentList, i + 1, 0, 0, 0);
                        (*jenv)->DeleteLocalRef(jenv, infos);
                        break;
                    }

                    nbRow = (*jenv)->GetArrayLength(jenv, data);

                    if (isReal)
                    {
                        // Get the matrix rowsw
                        for(; j < nbRow; j++)
                        {
                            jboolean isCopy1 = JNI_FALSE;
                            jdouble* element = NULL;
                            jdoubleArray oneDim = (jdoubleArray)(*jenv)->GetObjectArrayElement(jenv, data, j);
                            if (nbCol == 0)
                            {
                                nbCol = (*jenv)->GetArrayLength(jenv, oneDim);
                                real = (double*)MALLOC(sizeof(double) * nbRow * nbCol);
                            }

                            element = (jdouble*)(*jenv)->GetPrimitiveArrayCritical(jenv, oneDim, &isCopy1);

                            // Get the matrix element
                            for(k = 0; k < nbCol; k++)
                            {
                                real[k * nbRow + j] = element[k];
                            }
                            (*jenv)->ReleasePrimitiveArrayCritical(jenv, oneDim, element, JNI_ABORT);
                            (*jenv)->DeleteLocalRef(jenv, oneDim);
                        }
                        (*jenv)->DeleteLocalRef(jenv, data);

                        sciErr = createMatrixOfDoubleInNamedList(pvApiCtx, varName, currentList, i + 1, nbRow, nbCol, real);
                        FREE(real);
                    }
                    else
                    {
                        jobject imagData = (jobject)(*jenv)->GetObjectArrayElement(jenv, infos, 1);
                        // Get the matrix rows
                        for(; j < nbRow; j++)
                        {
                            jboolean isCopy1 = JNI_FALSE;
                            jdouble* elementR = NULL;
                            jdouble* elementI = NULL;
                            jdoubleArray oneDimR = (jdoubleArray)(*jenv)->GetObjectArrayElement(jenv, data, j);
                            jdoubleArray oneDimI = (jdoubleArray)(*jenv)->GetObjectArrayElement(jenv, imagData, j);
                            if (nbCol == 0)
                            {
                                nbCol = (*jenv)->GetArrayLength(jenv, oneDimR);
                                real = (double*)MALLOC(sizeof(double) * nbRow * nbCol);
                                imag = (double*)MALLOC(sizeof(double) * nbRow * nbCol);
                            }

                            elementR = (jdouble*)(*jenv)->GetPrimitiveArrayCritical(jenv, oneDimR, &isCopy1);
                            isCopy1 = JNI_FALSE;
                            elementI = (jdouble*)(*jenv)->GetPrimitiveArrayCritical(jenv, oneDimI, &isCopy1);

                            // Get the matrix element
                            for(k = 0; k < nbCol; k++)
                            {
                                real[k * nbRow + j] = elementR[k];
                                imag[k * nbRow + j] = elementI[k];
                            }
                            (*jenv)->ReleasePrimitiveArrayCritical(jenv, oneDimR, elementR, JNI_ABORT);
                            (*jenv)->ReleasePrimitiveArrayCritical(jenv, oneDimI, elementI, JNI_ABORT);
                            (*jenv)->DeleteLocalRef(jenv, oneDimR);
                            (*jenv)->DeleteLocalRef(jenv, oneDimI);
                        }
                        (*jenv)->DeleteLocalRef(jenv, data);
                        (*jenv)->DeleteLocalRef(jenv, imagData);

                        sciErr = createComplexMatrixOfDoubleInNamedList(pvApiCtx, varName, currentList, i + 1, nbRow, nbCol, real, imag);
                        FREE(real);
                        FREE(imag);
                    }
                    (*jenv)->DeleteLocalRef(jenv, infos);
                    break;
                }
                case sci_poly :
                {
                    jobjectArray infos = (jobjectArray)(*jenv)->GetObjectArrayElement(jenv, list, i + 1);
                    jobject data = (*jenv)->GetObjectArrayElement(jenv, infos, 1);
                    int nbRow = (*jenv)->GetArrayLength(jenv, data);
                    int isReal = 0;
                    jstring js;
                    char * polyVarName = NULL;
                    int nbCol = 0;
                    int j = 0, k = 0;
                    double ** real = NULL;
                    double ** imag = NULL;
                    int * nbCoef = NULL;

                    if (!data || nbRow == 0)
                    {
                        sciErr = createMatrixOfDoubleInNamedList(pvApiCtx, varName, currentList, i + 1, 0, 0, 0);
                        if (!data)
                        {
                            (*jenv)->DeleteLocalRef(jenv, data);
                        }
                        (*jenv)->DeleteLocalRef(jenv, infos);
                        break;
                    }

                    isReal = (*jenv)->GetArrayLength(jenv, infos) == 2;
                    js = (jstring)(*jenv)->GetObjectArrayElement(jenv, infos, 0);
                    polyVarName = (char*)(*jenv)->GetStringUTFChars(jenv, js, 0);
                 
                    if (isReal)
                    {
                        // Get the matrix rows
                        for(; j < nbRow; j++)
                        {
                            jobjectArray dblDim = (jobjectArray)(*jenv)->GetObjectArrayElement(jenv, data, j);
                            if (nbCol == 0)
                            {
                                nbCol = (*jenv)->GetArrayLength(jenv, dblDim);
                                real = (double**)MALLOC(sizeof(double*) * nbRow * nbCol);
                                nbCoef = (int*)MALLOC(sizeof(int) * nbRow * nbCol);
                            }

                            // Get the matrix element
                            for(k = 0; k < nbCol; k++)
                            {
                                jboolean isCopy1 = JNI_FALSE;
                                jdouble* element = NULL;
                                jdoubleArray oneDim = (jdoubleArray)(*jenv)->GetObjectArrayElement(jenv, dblDim, k);
                                int len = (*jenv)->GetArrayLength(jenv, oneDim);
                                nbCoef[k * nbRow + j] = len;
                                real[k * nbRow + j] = (double*)MALLOC(sizeof(double) * len);
                                element = (jdouble*)(*jenv)->GetPrimitiveArrayCritical(jenv, oneDim, &isCopy1);
                                memcpy(real[k * nbRow + j], element, sizeof(double) * len);
                                (*jenv)->ReleasePrimitiveArrayCritical(jenv, oneDim, element, 0);
                                (*jenv)->DeleteLocalRef(jenv, oneDim);
                            }
                            (*jenv)->DeleteLocalRef(jenv, dblDim);
                        }
                        (*jenv)->DeleteLocalRef(jenv, data);

                        sciErr = createMatrixOfPolyInNamedList(pvApiCtx, varName, currentList, i + 1, polyVarName, nbRow, nbCol, nbCoef, (const double * const*)real);
                        for(j = 0; j < nbRow * nbCol; j++)
                        {
                            FREE(real[j]);
                        }
                        FREE(real);
                        FREE(nbCoef);
                    }
                    else
                    {
                        jobject imagData = (*jenv)->GetObjectArrayElement(jenv, infos, 2);
                        // Get the matrix rows
                        for(; j < nbRow; j++)
                        {
                            jobjectArray dblDimR = (jobjectArray)(*jenv)->GetObjectArrayElement(jenv, data, j);
                            jobjectArray dblDimI = (jobjectArray)(*jenv)->GetObjectArrayElement(jenv, imagData, j);
                            if (nbCol == 0)
                            {
                                nbCol = (*jenv)->GetArrayLength(jenv, dblDimR);
                                real = (double**)MALLOC(sizeof(double*) * nbRow * nbCol);
                                imag = (double**)MALLOC(sizeof(double*) * nbRow * nbCol);
                                nbCoef = (int*)MALLOC(sizeof(int) * nbRow * nbCol);
                            }

                            // Get the matrix element
                            for(k = 0; k < nbCol; k++)
                            {
                                jboolean isCopy1 = JNI_FALSE;
                                jdouble* element = NULL;
                                jdoubleArray oneDimR = (jdoubleArray)(*jenv)->GetObjectArrayElement(jenv, dblDimR, k);
                                jdoubleArray oneDimI = (jdoubleArray)(*jenv)->GetObjectArrayElement(jenv, dblDimI, k);
                                int len = (*jenv)->GetArrayLength(jenv, oneDimR);
                                nbCoef[k * nbRow + j] = len;
                                real[k * nbRow + j] = (double*)MALLOC(sizeof(double) * len);
                                imag[k * nbRow + j] = (double*)MALLOC(sizeof(double) * len);
                                element = (jdouble*)(*jenv)->GetPrimitiveArrayCritical(jenv, oneDimR, &isCopy1);
                                memcpy(real[k * nbRow + j], element, sizeof(double) * len);
                                (*jenv)->ReleasePrimitiveArrayCritical(jenv, oneDimR, element, 0);
                                (*jenv)->DeleteLocalRef(jenv, oneDimR);
                                isCopy1 = JNI_FALSE;
                                element = (jdouble*)(*jenv)->GetPrimitiveArrayCritical(jenv, oneDimI, &isCopy1);
                                memcpy(imag[k * nbRow + j], element, sizeof(double) * len);
                                (*jenv)->ReleasePrimitiveArrayCritical(jenv, oneDimI, element, 0);
                                (*jenv)->DeleteLocalRef(jenv, oneDimI);
                            }
                            (*jenv)->DeleteLocalRef(jenv, dblDimR);
                            (*jenv)->DeleteLocalRef(jenv, dblDimI);
                        }
                        (*jenv)->DeleteLocalRef(jenv, data);
                        (*jenv)->DeleteLocalRef(jenv, imagData);

                        sciErr = createComplexMatrixOfPolyInNamedList(pvApiCtx, varName, currentList, i + 1, polyVarName, nbRow, nbCol, nbCoef, (const double * const*)real, (const double * const*)imag);
                        for(j = 0; j < nbRow * nbCol; j++)
                        {
                            FREE(real[j]);
                            FREE(imag[j]);
                        }
                        FREE(real);
                        FREE(imag);
                        FREE(nbCoef);
                    }

                    (*jenv)->ReleaseStringUTFChars(jenv, js, polyVarName);
                    (*jenv)->DeleteLocalRef(jenv, js);
                    (*jenv)->DeleteLocalRef(jenv, infos);
                    break;
                }
                case sci_boolean :
                {
                    jobject data = (*jenv)->GetObjectArrayElement(jenv, list, i + 1);
                    int nbRow = (*jenv)->GetArrayLength(jenv, data);
                    int nbCol = 0;
                    int j = 0, k;
                    int * b = 0;

                    if (!data || nbRow == 0)
                    {
                        sciErr = createMatrixOfDoubleInNamedList(pvApiCtx, varName, currentList, i + 1, 0, 0, 0);
                        if (!data)
                        {
                            (*jenv)->DeleteLocalRef(jenv, data);
                        }
                        break;
                    }

                    // Get the matrix rows
                    for(; j < nbRow; j++)
                    {
                        jboolean isCopy1 = JNI_FALSE;
                        jboolean* element = NULL;
                        jdoubleArray oneDim = (jdoubleArray)(*jenv)->GetObjectArrayElement(jenv, data, j);
                        if (nbCol == 0)
                        {
                            nbCol = (*jenv)->GetArrayLength(jenv, oneDim);
                            b = (int*)MALLOC(sizeof(int) * nbRow * nbCol);
                        }

                        element = (jboolean*)(*jenv)->GetPrimitiveArrayCritical(jenv, oneDim, &isCopy1);

                        // Get the matrix element
                        for(k = 0; k < nbCol; k++)
                        {
                            b[k * nbRow + j] = element[k];
                        }
                        (*jenv)->ReleasePrimitiveArrayCritical(jenv, oneDim, element, JNI_ABORT);
                        (*jenv)->DeleteLocalRef(jenv, oneDim);
                    }
                    (*jenv)->DeleteLocalRef(jenv, data);

                    sciErr = createMatrixOfBooleanInNamedList(pvApiCtx, varName, currentList, i + 1, nbRow, nbCol, (const int *)b);
                    FREE(b);
                    break;
                }
                case sci_sparse :
                {
                    jboolean isCopy1 = JNI_FALSE;
                    int* dims = NULL;
                    int* nbItemRow = NULL;
                    int* colPos = NULL;
                    double* data = NULL;
                    double * imagData = NULL;
                    jobjectArray infos = (jobjectArray)(*jenv)->GetObjectArrayElement(jenv, list, i + 1);
                    int isReal = (*jenv)->GetArrayLength(jenv, infos) == 4;
                    jintArray jdims = (jintArray)(*jenv)->GetObjectArrayElement(jenv, infos, 0);
                    jintArray jnbItemRow = (jintArray)(*jenv)->GetObjectArrayElement(jenv, infos, 1);
                    jintArray jcolPos = (jintArray)(*jenv)->GetObjectArrayElement(jenv, infos, 2);
                    jint nbNonNull = (*jenv)->GetArrayLength(jenv, jcolPos);
                    jdoubleArray jdata = (jdoubleArray)(*jenv)->GetObjectArrayElement(jenv, infos, 3);
                    jdoubleArray jimagData;

                    if (!isReal)
                    {
                        jimagData = (jdoubleArray)(*jenv)->GetObjectArrayElement(jenv, infos, 4);
                    }

                    dims = (jint*)(*jenv)->GetPrimitiveArrayCritical(jenv, jdims, &isCopy1);
                    isCopy1 = JNI_FALSE;
                    nbItemRow = (int*)(*jenv)->GetPrimitiveArrayCritical(jenv, jnbItemRow, &isCopy1);
                    isCopy1 = JNI_FALSE;
                    colPos = (int*)(*jenv)->GetPrimitiveArrayCritical(jenv, jcolPos, &isCopy1);
                    isCopy1 = JNI_FALSE;
                    data = (double*)(*jenv)->GetPrimitiveArrayCritical(jenv, jdata, &isCopy1);
                    isCopy1 = JNI_FALSE;

                    if (!isReal)
                    {
                        imagData = (double*)(*jenv)->GetPrimitiveArrayCritical(jenv, jimagData, &isCopy1);
                    }

                    if (isReal)
                    {
                        sciErr = createSparseMatrixInNamedList(pvApiCtx, varName, currentList, i + 1, dims[0], dims[1], nbNonNull, nbItemRow, colPos, data);
                        (*jenv)->ReleasePrimitiveArrayCritical(jenv, jdata, data, JNI_ABORT);
                    }
                    else
                    {
                        sciErr = createComplexSparseMatrixInNamedList(pvApiCtx, varName, currentList, i + 1, dims[0], dims[1], nbNonNull, nbItemRow, colPos, data, imagData);
                        (*jenv)->ReleasePrimitiveArrayCritical(jenv, jimagData, imagData, JNI_ABORT);
                        (*jenv)->ReleasePrimitiveArrayCritical(jenv, jdata, data, JNI_ABORT);
                    }

                    (*jenv)->ReleasePrimitiveArrayCritical(jenv, jcolPos, colPos, JNI_ABORT);
                    (*jenv)->ReleasePrimitiveArrayCritical(jenv, jnbItemRow, nbItemRow, JNI_ABORT);
                    (*jenv)->ReleasePrimitiveArrayCritical(jenv, jdims, dims, JNI_ABORT);

                    if (!isReal)
                    {
                        (*jenv)->DeleteLocalRef(jenv, jimagData);
                    }
                    (*jenv)->DeleteLocalRef(jenv, jdata);
                    (*jenv)->DeleteLocalRef(jenv, jcolPos);
                    (*jenv)->DeleteLocalRef(jenv, jnbItemRow);
                    (*jenv)->DeleteLocalRef(jenv, jdims);
                    (*jenv)->DeleteLocalRef(jenv, infos);

                    break;
                }
                case sci_boolean_sparse :
                {
                    jobjectArray infos = (jobjectArray)(*jenv)->GetObjectArrayElement(jenv, list, i + 1);
                    jintArray jdims = (jintArray)(*jenv)->GetObjectArrayElement(jenv, infos, 0);
                    jintArray jnbItemRow = (jintArray)(*jenv)->GetObjectArrayElement(jenv, infos, 1);
                    jintArray jcolPos = (jintArray)(*jenv)->GetObjectArrayElement(jenv, infos, 2);
                    jint nbNonNull = (*jenv)->GetArrayLength(jenv, jcolPos);
                    int* nbItemRow = NULL;
                    int* dims = NULL;
                    int* colPos = NULL;

                    jboolean isCopy1 = JNI_FALSE;

                    dims = (jint*)(*jenv)->GetPrimitiveArrayCritical(jenv, jdims, &isCopy1);
                    isCopy1 = JNI_FALSE;
                    nbItemRow = (int*)(*jenv)->GetPrimitiveArrayCritical(jenv, jnbItemRow, &isCopy1);
                    isCopy1 = JNI_FALSE;
                    colPos = (int*)(*jenv)->GetPrimitiveArrayCritical(jenv, jcolPos, &isCopy1);

                    sciErr = createBooleanSparseMatrixInNamedList(pvApiCtx, varName, currentList, i + 1, dims[0], dims[1], nbNonNull, nbItemRow, colPos);

                    (*jenv)->ReleasePrimitiveArrayCritical(jenv, jcolPos, colPos, JNI_ABORT);
                    (*jenv)->ReleasePrimitiveArrayCritical(jenv, jnbItemRow, nbItemRow, JNI_ABORT);
                    (*jenv)->ReleasePrimitiveArrayCritical(jenv, jdims, dims, JNI_ABORT);

                    (*jenv)->DeleteLocalRef(jenv, jcolPos);
                    (*jenv)->DeleteLocalRef(jenv, jnbItemRow);
                    (*jenv)->DeleteLocalRef(jenv, jdims);
                    (*jenv)->DeleteLocalRef(jenv, infos);

                    break;
                }
                case sci_ints :
                {
                    jobjectArray infos = (jobjectArray)(*jenv)->GetObjectArrayElement(jenv, list, i + 1);
                    jintArray jtype = (jintArray)(*jenv)->GetObjectArrayElement(jenv, infos, 0);
                    jint * typep = (*jenv)->GetIntArrayElements(jenv, jtype, 0);
                    int type = *typep;

                    (*jenv)->ReleaseIntArrayElements(jenv, jtype, typep, JNI_ABORT);
                    (*jenv)->DeleteLocalRef(jenv, jtype);

                    switch (type)
                    {
                        case sci_int8 :
                        {
                            jobject jdata = (*jenv)->GetObjectArrayElement(jenv, infos, 1);
                            int nbRow = (*jenv)->GetArrayLength(jenv, jdata);
                            int nbCol = 0;
                            int j = 0, k;
                            char * data = 0;

                            if (!jdata || nbRow == 0)
                            {
                                sciErr = createMatrixOfDoubleInNamedList(pvApiCtx, varName, currentList, i + 1, 0, 0, 0);
                                if (!jdata)
                                {
                                    (*jenv)->DeleteLocalRef(jenv, jdata);
                                }
                                break;
                            }

                            // Get the matrix rows
                            for(; j < nbRow; j++)
                            {
                                jboolean isCopy1 = JNI_FALSE;
                                jbyte* element = NULL;
                                jbyteArray oneDim = (jbyteArray)(*jenv)->GetObjectArrayElement(jenv, jdata, j);
                                if (nbCol == 0)
                                {
                                    nbCol = (*jenv)->GetArrayLength(jenv, oneDim);
                                    data = (char*)MALLOC(sizeof(char) * nbRow * nbCol);
                                }
                                isCopy1 = JNI_FALSE;
                                element = (jbyte*)(*jenv)->GetPrimitiveArrayCritical(jenv, oneDim, &isCopy1);

                                // Get the matrix element
                                for(k = 0; k < nbCol; k++)
                                {
                                    data[k * nbRow + j] = element[k];
                                }
                                (*jenv)->ReleasePrimitiveArrayCritical(jenv, oneDim, element, JNI_ABORT);
                                (*jenv)->DeleteLocalRef(jenv, oneDim);
                            }
                            (*jenv)->DeleteLocalRef(jenv, jdata);

                            sciErr = createMatrixOfInteger8InNamedList(pvApiCtx, varName, currentList, i + 1, nbRow, nbCol, data);
                            FREE(data);
                            break;
                        }
                        case sci_uint8 :
                        {
                            jobject jdata = (*jenv)->GetObjectArrayElement(jenv, infos, 1);
                            int nbRow = (*jenv)->GetArrayLength(jenv, jdata);
                            int nbCol = 0;
                            int j = 0, k;
                            unsigned char * data = 0;

                            if (!jdata || nbRow == 0)
                            {
                                sciErr = createMatrixOfDoubleInNamedList(pvApiCtx, varName, currentList, i + 1, 0, 0, 0);
                                if (!jdata)
                                {
                                    (*jenv)->DeleteLocalRef(jenv, jdata);
                                }
                                break;
                            }

                            // Get the matrix rows
                            for(; j < nbRow; j++)
                            {
                                jbyte* element = NULL;
                                jboolean isCopy1 = JNI_FALSE;
                                jbyteArray oneDim = (jbyteArray)(*jenv)->GetObjectArrayElement(jenv, jdata, j);
                                if (nbCol == 0)
                                {
                                    nbCol = (*jenv)->GetArrayLength(jenv, oneDim);
                                    data = (unsigned char*)MALLOC(sizeof(unsigned char) * nbRow * nbCol);
                                }

                                element = (jbyte*)(*jenv)->GetPrimitiveArrayCritical(jenv, oneDim, &isCopy1);

                                // Get the matrix element
                                for(k = 0; k < nbCol; k++)
                                {
                                    data[k * nbRow + j] = element[k];
                                }
                                (*jenv)->ReleasePrimitiveArrayCritical(jenv, oneDim, element, JNI_ABORT);
                                (*jenv)->DeleteLocalRef(jenv, oneDim);
                            }
                            (*jenv)->DeleteLocalRef(jenv, jdata);

                            sciErr = createMatrixOfUnsignedInteger8InNamedList(pvApiCtx, varName, currentList, i + 1, nbRow, nbCol, data);
                            FREE(data);

                            break;
                        }
                        case sci_int16 :
                        {
                            jobject jdata = (*jenv)->GetObjectArrayElement(jenv, infos, 1);
                            int nbRow = (*jenv)->GetArrayLength(jenv, jdata);
                            int nbCol = 0;
                            int j = 0, k;
                            short * data = 0;

                            if (!jdata || nbRow == 0)
                            {
                                sciErr = createMatrixOfDoubleInNamedList(pvApiCtx, varName, currentList, i + 1, 0, 0, 0);
                                if (!jdata)
                                {
                                    (*jenv)->DeleteLocalRef(jenv, jdata);
                                }
                                break;
                            }

                            // Get the matrix rows
                            for(; j < nbRow; j++)
                            {
                                jboolean isCopy1 = JNI_FALSE;
                                jshort* element = NULL;
                                jshortArray oneDim = (jshortArray)(*jenv)->GetObjectArrayElement(jenv, jdata, j);
                                if (nbCol == 0)
                                {
                                    nbCol = (*jenv)->GetArrayLength(jenv, oneDim);
                                    data = (short*)MALLOC(sizeof(short) * nbRow * nbCol);
                                }

                                element = (jshort*)(*jenv)->GetPrimitiveArrayCritical(jenv, oneDim, &isCopy1);

                                // Get the matrix element
                                for(k = 0; k < nbCol; k++)
                                {
                                    data[k * nbRow + j] = element[k];
                                }
                                (*jenv)->ReleasePrimitiveArrayCritical(jenv, oneDim, element, JNI_ABORT);
                                (*jenv)->DeleteLocalRef(jenv, oneDim);
                            }
                            (*jenv)->DeleteLocalRef(jenv, jdata);

                            sciErr = createMatrixOfInteger16InNamedList(pvApiCtx, varName, currentList, i + 1, nbRow, nbCol, data);
                            FREE(data);

                            break;
                        }
                        case sci_uint16 :
                        {
                            jobject jdata = (*jenv)->GetObjectArrayElement(jenv, infos, 1);
                            int nbRow = (*jenv)->GetArrayLength(jenv, jdata);
                            int nbCol = 0;
                            int j = 0, k;
                            unsigned short * data = 0;

                            if (!jdata || nbRow == 0)
                            {
                                sciErr = createMatrixOfDoubleInNamedList(pvApiCtx, varName, currentList, i + 1, 0, 0, 0);
                                if (!jdata)
                                {
                                    (*jenv)->DeleteLocalRef(jenv, jdata);
                                }
                                break;
                            }

                            // Get the matrix rows
                            for(; j < nbRow; j++)
                            {
                                jboolean isCopy1 = JNI_FALSE;
                                jshort* element = NULL;
                                jshortArray oneDim = (jshortArray)(*jenv)->GetObjectArrayElement(jenv, jdata, j);
                                if (nbCol == 0)
                                {
                                    nbCol = (*jenv)->GetArrayLength(jenv, oneDim);
                                    data = (unsigned short*)MALLOC(sizeof(unsigned short) * nbRow * nbCol);
                                }
                                isCopy1 = JNI_FALSE;
                                element = (jshort*)(*jenv)->GetPrimitiveArrayCritical(jenv, oneDim, &isCopy1);

                                // Get the matrix element
                                for(k = 0; k < nbCol; k++)
                                {
                                    data[k * nbRow + j] = element[k];
                                }
                                (*jenv)->ReleasePrimitiveArrayCritical(jenv, oneDim, element, JNI_ABORT);
                                (*jenv)->DeleteLocalRef(jenv, oneDim);
                            }
                            (*jenv)->DeleteLocalRef(jenv, jdata);

                            sciErr = createMatrixOfUnsignedInteger16InNamedList(pvApiCtx, varName, currentList, i + 1, nbRow, nbCol, data);
                            FREE(data);

                            break;
                        }
                        case sci_int32 :
                        {
                            jobject jdata = (*jenv)->GetObjectArrayElement(jenv, infos, 1);
                            int nbRow = (*jenv)->GetArrayLength(jenv, jdata);
                            int nbCol = 0;
                            int j = 0, k;
                            int * data = 0;

                            if (!jdata || nbRow == 0)
                            {
                                sciErr = createMatrixOfDoubleInNamedList(pvApiCtx, varName, currentList, i + 1, 0, 0, 0);
                                if (!jdata)
                                {
                                    (*jenv)->DeleteLocalRef(jenv, jdata);
                                }
                                break;
                            }

                            // Get the matrix rows
                            for(; j < nbRow; j++)
                            {
                                jboolean isCopy1 = JNI_FALSE;
                                jint* element = NULL;
                                jintArray oneDim = (jintArray)(*jenv)->GetObjectArrayElement(jenv, jdata, j);
                                if (nbCol == 0)
                                {
                                    nbCol = (*jenv)->GetArrayLength(jenv, oneDim);
                                    data = (int*)MALLOC(sizeof(int) * nbRow * nbCol);
                                }
                                isCopy1 = JNI_FALSE;
                                element = (jint*)(*jenv)->GetPrimitiveArrayCritical(jenv, oneDim, &isCopy1);

                                // Get the matrix element
                                for(k = 0; k < nbCol; k++)
                                {
                                    data[k * nbRow + j] = element[k];
                                }
                                (*jenv)->ReleasePrimitiveArrayCritical(jenv, oneDim, element, JNI_ABORT);
                                (*jenv)->DeleteLocalRef(jenv, oneDim);
                            }
                            (*jenv)->DeleteLocalRef(jenv, jdata);

                            sciErr = createMatrixOfInteger32InNamedList(pvApiCtx, varName, currentList, i + 1, nbRow, nbCol, data);
                            FREE(data);

                            break;
                        }
                        case sci_uint32 :
                        {
                            jobject jdata = (*jenv)->GetObjectArrayElement(jenv, infos, 1);
                            int nbRow = (*jenv)->GetArrayLength(jenv, jdata);
                            int nbCol = 0;
                            int j = 0, k;
                            unsigned int * data = 0;

                            if (!jdata || nbRow == 0)
                            {
                                sciErr = createMatrixOfDoubleInNamedList(pvApiCtx, varName, currentList, i + 1, 0, 0, 0);
                                if (!jdata)
                                {
                                    (*jenv)->DeleteLocalRef(jenv, jdata);
                                }
                                break;
                            }

                            // Get the matrix rows
                            for(; j < nbRow; j++)
                            {
                                jboolean isCopy1 = JNI_FALSE;
                                jint* element = NULL;
                                jintArray oneDim = (jintArray)(*jenv)->GetObjectArrayElement(jenv, jdata, j);
                                if (nbCol == 0)
                                {
                                    nbCol = (*jenv)->GetArrayLength(jenv, oneDim);
                                    data = (unsigned int*)MALLOC(sizeof(unsigned int) * nbRow * nbCol);
                                }
                                isCopy1 = JNI_FALSE;
                                element = (jint*)(*jenv)->GetPrimitiveArrayCritical(jenv, oneDim, &isCopy1);

                                // Get the matrix element
                                for(k = 0; k < nbCol; k++)
                                {
                                    data[k * nbRow + j] = element[k];
                                }
                                (*jenv)->ReleasePrimitiveArrayCritical(jenv, oneDim, element, JNI_ABORT);
                                (*jenv)->DeleteLocalRef(jenv, oneDim);
                            }
                            (*jenv)->DeleteLocalRef(jenv, jdata);

                            sciErr = createMatrixOfUnsignedInteger32InNamedList(pvApiCtx, varName, currentList, i + 1, nbRow, nbCol, data);
                            FREE(data);

                            break;
                        }
#ifdef __SCILAB_INT64__
                        case sci_int64 :
                        {
                            jobject jdata = (*jenv)->GetObjectArrayElement(jenv, infos, 1);
                            int nbRow = (*jenv)->GetArrayLength(jenv, jdata);
                            int nbCol = 0;
                            int j = 0, k;
                            long * data = 0;

                            if (!jdata || nbRow == 0)
                            {
                                sciErr = createMatrixOfDoubleInNamedList(pvApiCtx, varName, currentList, i + 1, 0, 0, 0);
                                if (!jdata)
                                {
                                    (*jenv)->DeleteLocalRef(jenv, jdata);
                                }
                                break;
                            }

                            // Get the matrix rows
                            for(; j < nbRow; j++)
                            {
                                jlongArray oneDim = (jlongArray)(*jenv)->GetObjectArrayElement(jenv, jdata, j);
                                if (nbCol == 0)
                                {
                                    nbCol = (*jenv)->GetArrayLength(jenv, oneDim);
                                    data = (long*)MALLOC(sizeof(long) * nbRow * nbCol);
                                }
                                jboolean isCopy1 = JNI_FALSE;
                                jlong* element = (jlong*)(*jenv)->GetPrimitiveArrayCritical(jenv, oneDim, &isCopy1);

                                // Get the matrix element
                                for(k = 0; k < nbCol; k++)
                                {
                                    data[k * nbRow + j] = element[k];
                                }
                                (*jenv)->ReleasePrimitiveArrayCritical(jenv, oneDim, element, JNI_ABORT);
                                (*jenv)->DeleteLocalRef(jenv, oneDim);
                            }
                            (*jenv)->DeleteLocalRef(jenv, jdata);

                            sciErr = createMatrixOfInteger64InNamedList(pvApiCtx, varName, currentList, i + 1, nbRow, nbCol, data);
                            FREE(data);

                            break;
                        }
                        case sci_uint64 :
                        {
                            jobject jdata = (*jenv)->GetObjectArrayElement(jenv, infos, 1);
                            int nbRow = (*jenv)->GetArrayLength(jenv, jdata);
                            int nbCol = 0;
                            int j = 0, k;
                            unsigned long * data = 0;

                            if (!jdata || nbRow == 0)
                            {
                                sciErr = createMatrixOfDoubleInNamedList(pvApiCtx, varName, currentList, i + 1, 0, 0, 0);
                                if (!jdata)
                                {
                                    (*jenv)->DeleteLocalRef(jenv, jdata);
                                }
                                break;
                            }

                            // Get the matrix rows
                            for(; j < nbRow; j++)
                            {
                                jlongArray oneDim = (jlongArray)(*jenv)->GetObjectArrayElement(jenv, jdata, j);
                                if (nbCol == 0)
                                {
                                    nbCol = (*jenv)->GetArrayLength(jenv, oneDim);
                                    data = (unsigned long*)MALLOC(sizeof(unsigned long) * nbRow * nbCol);
                                }
                                jboolean isCopy1 = JNI_FALSE;
                                jlong* element = (jlong*)(*jenv)->GetPrimitiveArrayCritical(jenv, oneDim, &isCopy1);

                                // Get the matrix element
                                for(k = 0; k < nbCol; k++)
                                {
                                    data[k * nbRow + j] = element[k];
                                }
                                (*jenv)->ReleasePrimitiveArrayCritical(jenv, oneDim, element, JNI_ABORT);
                                (*jenv)->DeleteLocalRef(jenv, oneDim);
                            }
                            (*jenv)->DeleteLocalRef(jenv, jdata);

                            sciErr = createMatrixOfUnsignedInteger64InNamedList(pvApiCtx, varName, currentList, i + 1, nbRow, nbCol, data);
                            FREE(data);
                            break;
                        }
#endif
                    }
                    (*jenv)->DeleteLocalRef(jenv, infos);
                    break;
                }
                case sci_strings :
                {
                    jobject data = (*jenv)->GetObjectArrayElement(jenv, list, i + 1);
                    int nbRow = (*jenv)->GetArrayLength(jenv, data);
                    int nbCol = 0;
                    int j = 0, k;
                    char ** strings = 0;

                    if (!data || nbRow == 0)
                    {
                        sciErr = createMatrixOfDoubleInNamedList(pvApiCtx, varName, currentList, i + 1, 0, 0, 0);
                        if (!data)
                        {
                            (*jenv)->DeleteLocalRef(jenv, data);
                        }
                        break;
                    }

                    // Get the matrix rows
                    for(; j < nbRow; j++)
                    {
                        jobjectArray oneDim = (jobjectArray)(*jenv)->GetObjectArrayElement(jenv, data, j);
                        if (nbCol == 0)
                        {
                            nbCol = (*jenv)->GetArrayLength(jenv, oneDim);
                            strings = (char**)MALLOC(sizeof(char*) * nbRow * nbCol);
                        }

                        // Get the matrix element
                        for(k = 0; k < nbCol; k++)
                        {
                            jstring j_string = (jstring)(*jenv)->GetObjectArrayElement(jenv, oneDim, k);
                            jboolean isCopy1 = JNI_FALSE;
                            char *str = (char *)(*jenv)->GetStringUTFChars(jenv, j_string, &isCopy1);
                            strings[k * nbRow + j] = (char*)MALLOC(sizeof(char) * (strlen(str) + 1));
                            strcpy(strings[k * nbRow + j], str);
                            if (isCopy1)
                            {
                                (*jenv)->ReleaseStringUTFChars(jenv, j_string, (const char *)str);
                            }
                            (*jenv)->DeleteLocalRef(jenv, j_string);
                        }
                        (*jenv)->DeleteLocalRef(jenv, oneDim);
                    }
                    (*jenv)->DeleteLocalRef(jenv, data);

                    sciErr = createMatrixOfStringInNamedList(pvApiCtx, varName, currentList, i + 1, nbRow, nbCol, (const char * const*)strings);
                    for(j = 0; j < nbRow * nbCol; j++)
                    {
                        FREE(strings[j]);
                    }
                    FREE(strings);
                    break;
                }
                case sci_list :
                {
                    jobject data = (*jenv)->GetObjectArrayElement(jenv, list, i + 1);
                    sciErr = sendList(jenv, data, currentList, i + 1, varName, 'l');
                    (*jenv)->DeleteLocalRef(jenv, data);
                    break;
                }
                case sci_tlist :
                {
                    jobject data = (*jenv)->GetObjectArrayElement(jenv, list, i + 1);
                    sciErr = sendList(jenv, data, currentList, i + 1, varName, 't');
                    (*jenv)->DeleteLocalRef(jenv, data);
                    break;
                }
                case sci_mlist :
                {
                    jobject data = (*jenv)->GetObjectArrayElement(jenv, list, i + 1);
                    sciErr = sendList(jenv, data, currentList, i + 1, varName, 'm');
                    (*jenv)->DeleteLocalRef(jenv, data);
                    break;
                }
            }

            if (sciErr.iErr)
            {
                break;
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i<size1; i++) {
      jstring j_string = (jstring)(*jenv)->GetObjectArrayElement(jenv, jarg1, i);
      const char * c_string = (*jenv)->GetStringUTFChars(jenv, j_string, 0);
      arg1[i] = MALLOC((strlen(c_string)+1)*sizeof(const char *));
      strcpy(arg1[i], c_string);
      (*jenv)->ReleaseStringUTFChars(jenv, j_string, c_string);
      (*jenv)->DeleteLocalRef(jenv, j_string);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<size1-1; i++) {
      FREE(arg1[i]);
      arg1[i] = NULL;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(; i < arg3; i++)
    {
      jobjectArray oneDim = (jobjectArray)(*jenv)->GetObjectArrayElement(jenv, jarg2, i);
      if (arg4 == 0)
      {
        
        arg4 = (*jenv)->GetArrayLength(jenv, oneDim);
        arg2 = (char**)malloc(sizeof(char*) * arg3 * arg4);
      }
      for(j = 0; j < arg4; j++)
      {
        jstring j_string = (jstring)(*jenv)->GetObjectArrayElement(jenv, oneDim, j);
        jboolean isCopy = JNI_FALSE;
        char *str = (char *)(*jenv)->GetStringUTFChars(jenv, j_string, &isCopy);
        arg2[j * arg3 + i] = (char*)MALLOC(sizeof(char)*(strlen(str) + 1));
        strcpy(arg2[j * arg3 + i], str);
        if (isCopy)
        {
          (*jenv)->ReleaseStringUTFChars(jenv, j_string, (const char *)str);
        }
        (*jenv)->DeleteLocalRef(jenv, j_string);
      }
      (*jenv)->DeleteLocalRef(jenv, oneDim);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(; i < arg3 * arg4; i++)
    {
      FREE(arg2[i]);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(; i < arg3; i++)
    {
      jboolean isCopy = JNI_FALSE;
      jdouble* element = NULL;
      jdoubleArray oneDim = (jdoubleArray)(*jenv)->GetObjectArrayElement(jenv, jarg2, i);
      if (arg4 == 0)
      {
        
        arg4 = (*jenv)->GetArrayLength(jenv, oneDim);
        arg2 = (double*)malloc(sizeof(double) * arg3 * arg4);
      }
      isCopy = JNI_FALSE;
      element = (jdouble*)(*jenv)->GetPrimitiveArrayCritical(jenv, oneDim, &isCopy);
      
      for(j = 0; j < arg4; j++)
      {
        arg2[j * arg3 + i] = element[j];
      }
      (*jenv)->ReleasePrimitiveArrayCritical(jenv, oneDim, element, JNI_ABORT);
      (*jenv)->DeleteLocalRef(jenv, oneDim);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(; i < arg6; i++)
    {
      jboolean isCopy = JNI_FALSE;
      jdouble* element = NULL;
      jdoubleArray oneDim = (jdoubleArray)(*jenv)->GetObjectArrayElement(jenv, jarg5, i);
      if (arg7 == 0)
      {
        
        arg7 = (*jenv)->GetArrayLength(jenv, oneDim);
        arg5 = (double*)malloc(sizeof(double) * arg6 * arg7);
      }
      isCopy = JNI_FALSE;
      element = (jdouble*)(*jenv)->GetPrimitiveArrayCritical(jenv, oneDim, &isCopy);
      
      for(j = 0; j < arg7; j++)
      {
        arg5[j * arg6 + i] = element[j];
      }
      (*jenv)->ReleasePrimitiveArrayCritical(jenv, oneDim, element, JNI_ABORT);
      (*jenv)->DeleteLocalRef(jenv, oneDim);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(; i < arg3; i++)
    {
      jboolean isCopy = JNI_FALSE;
      jdouble* element = NULL;
      jdoubleArray oneDim = (jdoubleArray)(*jenv)->GetObjectArrayElement(jenv, jarg2, i);
      if (arg4 == 0)
      {
        
        arg4 = (*jenv)->GetArrayLength(jenv, oneDim);
        arg2 = (double*)malloc(sizeof(double) * arg3 * arg4);
      }
      isCopy = JNI_FALSE;
      element = (jdouble*)(*jenv)->GetPrimitiveArrayCritical(jenv, oneDim, &isCopy);
      
      for(j = 0; j < arg4; j++)
      {
        arg2[j * arg3 + i] = element[j];
      }
      (*jenv)->ReleasePrimitiveArrayCritical(jenv, oneDim, element, JNI_ABORT);
      (*jenv)->DeleteLocalRef(jenv, oneDim);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(; i < arg3; i++)
    {
      jboolean isCopy = JNI_FALSE;
      jboolean* element = NULL;
      jbooleanArray oneDim = (jbooleanArray)(*jenv)->GetObjectArrayElement(jenv, jarg2, i);
      if (arg4 == 0)
      {
        
        arg4 = (*jenv)->GetArrayLength(jenv, oneDim);
        arg2 = (BOOL*)malloc(sizeof(BOOL) * arg3 * arg4);
      }
      isCopy = JNI_FALSE;
      element = (jboolean*)(*jenv)->GetPrimitiveArrayCritical(jenv, oneDim, &isCopy);
      
      for(j = 0; j < arg4; j++)
      {
        arg2[j * arg3 + i] = element[j];
      }
      (*jenv)->ReleasePrimitiveArrayCritical(jenv, oneDim, element, JNI_ABORT);
      (*jenv)->DeleteLocalRef(jenv, oneDim);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(; i < arg3; i++)
    {
      jboolean isCopy = JNI_FALSE;
      jbyte* element = NULL;
      jbyteArray oneDim = (jbyteArray)(*jenv)->GetObjectArrayElement(jenv, jarg2, i);
      if (arg4 == 0)
      {
        
        arg4 = (*jenv)->GetArrayLength(jenv, oneDim);
        arg2 = (byte*)malloc(sizeof(byte) * arg3 * arg4);
      }
      isCopy = JNI_FALSE;
      element = (jbyte*)(*jenv)->GetPrimitiveArrayCritical(jenv, oneDim, &isCopy);
      
      for(j = 0; j < arg4; j++)
      {
        arg2[j * arg3 + i] = element[j];
      }
      (*jenv)->ReleasePrimitiveArrayCritical(jenv, oneDim, element, JNI_ABORT);
      (*jenv)->DeleteLocalRef(jenv, oneDim);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(; i < arg3; i++)
    {
      jboolean isCopy = JNI_FALSE;
      jbyte* element = NULL;
      jbyteArray oneDim = (jbyteArray)(*jenv)->GetObjectArrayElement(jenv, jarg2, i);
      if (arg4 == 0)
      {
        
        arg4 = (*jenv)->GetArrayLength(jenv, oneDim);
        arg2 = (byte*)malloc(sizeof(byte) * arg3 * arg4);
      }
      isCopy = JNI_FALSE;
      element = (jbyte*)(*jenv)->GetPrimitiveArrayCritical(jenv, oneDim, &isCopy);
      
      for(j = 0; j < arg4; j++)
      {
        arg2[j * arg3 + i] = element[j];
      }
      (*jenv)->ReleasePrimitiveArrayCritical(jenv, oneDim, element, JNI_ABORT);
      (*jenv)->DeleteLocalRef(jenv, oneDim);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(; i < arg3; i++)
    {
      jboolean isCopy = JNI_FALSE;
      jshort* element = NULL;
      jshortArray oneDim = (jshortArray)(*jenv)->GetObjectArrayElement(jenv, jarg2, i);
      if (arg4 == 0)
      {
        
        arg4 = (*jenv)->GetArrayLength(jenv, oneDim);
        arg2 = (short*)malloc(sizeof(short) * arg3 * arg4);
      }
      isCopy = JNI_FALSE;
      element = (jshort*)(*jenv)->GetPrimitiveArrayCritical(jenv, oneDim, &isCopy);
      
      for(j = 0; j < arg4; j++)
      {
        arg2[j * arg3 + i] = element[j];
      }
      (*jenv)->ReleasePrimitiveArrayCritical(jenv, oneDim, element, JNI_ABORT);
      (*jenv)->DeleteLocalRef(jenv, oneDim);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(; i < arg3; i++)
    {
      jboolean isCopy = JNI_FALSE;
      jchar* element = NULL;
      jcharArray oneDim = (jcharArray)(*jenv)->GetObjectArrayElement(jenv, jarg2, i);
      if (arg4 == 0)
      {
        
        arg4 = (*jenv)->GetArrayLength(jenv, oneDim);
        arg2 = (unsigned short*)malloc(sizeof(unsigned short) * arg3 * arg4);
      }
      isCopy = JNI_FALSE;
      element = (jchar*)(*jenv)->GetPrimitiveArrayCritical(jenv, oneDim, &isCopy);
      
      for(j = 0; j < arg4; j++)
      {
        arg2[j * arg3 + i] = element[j];
      }
      (*jenv)->ReleasePrimitiveArrayCritical(jenv, oneDim, element, JNI_ABORT);
      (*jenv)->DeleteLocalRef(jenv, oneDim);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(; i < arg3; i++)
    {
      jboolean isCopy = JNI_FALSE;
      jint* element = NULL;
      jintArray oneDim = (jintArray)(*jenv)->GetObjectArrayElement(jenv, jarg2, i);
      if (arg4 == 0)
      {
        
        arg4 = (*jenv)->GetArrayLength(jenv, oneDim);
        arg2 = (int*)malloc(sizeof(int) * arg3 * arg4);
      }
      isCopy = JNI_FALSE;
      element = (jint*)(*jenv)->GetPrimitiveArrayCritical(jenv, oneDim, &isCopy);
      
      for(j = 0; j < arg4; j++)
      {
        arg2[j * arg3 + i] = element[j];
      }
      (*jenv)->ReleasePrimitiveArrayCritical(jenv, oneDim, element, JNI_ABORT);
      (*jenv)->DeleteLocalRef(jenv, oneDim);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(; i < arg3; i++)
    {
      jboolean isCopy = JNI_FALSE;
      jint* element = NULL;
      jintArray oneDim = (jintArray)(*jenv)->GetObjectArrayElement(jenv, jarg2, i);
      if (arg4 == 0)
      {
        
        arg4 = (*jenv)->GetArrayLength(jenv, oneDim);
        arg2 = (unsigned int*)malloc(sizeof(unsigned int) * arg3 * arg4);
      }
      isCopy = JNI_FALSE;
      element = (jint*)(*jenv)->GetPrimitiveArrayCritical(jenv, oneDim, &isCopy);
      
      for(j = 0; j < arg4; j++)
      {
        arg2[j * arg3 + i] = element[j];
      }
      (*jenv)->ReleasePrimitiveArrayCritical(jenv, oneDim, element, JNI_ABORT);
      (*jenv)->DeleteLocalRef(jenv, oneDim);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(; i < arg4; i++) {
      jobjectArray dblDim = (jobjectArray)(*jenv)->GetObjectArrayElement(jenv, jarg3, i);
      if (arg5 == 0) {
        
        arg5 = (*jenv)->GetArrayLength(jenv, dblDim);
        arg3 = (double**)malloc(sizeof(double*) * arg4 * arg5);
        arg6 = (int*)malloc(sizeof(int) * arg4 * arg5);
      }
      for(j = 0; j < arg5; j++)
      {
        jdoubleArray oneDim = (jdoubleArray)(*jenv)->GetObjectArrayElement(jenv, dblDim, j);
        jboolean isCopy = JNI_FALSE;
        jdouble* element = NULL;
        arg6[j * arg4 + i] = (*jenv)->GetArrayLength(jenv, oneDim);
        arg3[j * arg4 + i] = (double*)MALLOC(sizeof(jdouble) * arg6[j * arg4 + i]);
        isCopy = JNI_FALSE;
        element = (jdouble*)(*jenv)->GetPrimitiveArrayCritical(jenv, oneDim, &isCopy);
        memcpy(arg3[j * arg4 + i], element, sizeof(jdouble) * arg6[j * arg4 + i]);
        (*jenv)->ReleasePrimitiveArrayCritical(jenv, oneDim, element, 0);
        (*jenv)->DeleteLocalRef(jenv, oneDim);
      }
      (*jenv)->DeleteLocalRef(jenv, dblDim);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(; i < arg4 * arg5; i++)
    {
      FREE(arg3[i]);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(; i < arg4; i++) {
      jobjectArray dblDim = (jobjectArray)(*jenv)->GetObjectArrayElement(jenv, jarg3, i);
      if (arg5 == 0) {
        
        arg5 = (*jenv)->GetArrayLength(jenv, dblDim);
        arg3 = (double**)malloc(sizeof(double*) * arg4 * arg5);
        arg6 = (int*)malloc(sizeof(int) * arg4 * arg5);
      }
      for(j = 0; j < arg5; j++)
      {
        jdoubleArray oneDim = (jdoubleArray)(*jenv)->GetObjectArrayElement(jenv, dblDim, j);
        jboolean isCopy = JNI_FALSE;
        jdouble* element = NULL;
        arg6[j * arg4 + i] = (*jenv)->GetArrayLength(jenv, oneDim);
        arg3[j * arg4 + i] = (double*)MALLOC(sizeof(jdouble) * arg6[j * arg4 + i]);
        isCopy = JNI_FALSE;
        element = (jdouble*)(*jenv)->GetPrimitiveArrayCritical(jenv, oneDim, &isCopy);
        memcpy(arg3[j * arg4 + i], element, sizeof(jdouble) * arg6[j * arg4 + i]);
        (*jenv)->ReleasePrimitiveArrayCritical(jenv, oneDim, element, 0);
        (*jenv)->DeleteLocalRef(jenv, oneDim);
      }
      (*jenv)->DeleteLocalRef(jenv, dblDim);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(; i < arg8; i++) {
      jobjectArray dblDim = (jobjectArray)(*jenv)->GetObjectArrayElement(jenv, jarg7, i);
      if (arg9 == 0) {
        
        arg9 = (*jenv)->GetArrayLength(jenv, dblDim);
        arg7 = (double**)malloc(sizeof(double*) * arg8 * arg9);
        arg10 = (int*)malloc(sizeof(int) * arg8 * arg9);
      }
      for(j = 0; j < arg9; j++)
      {
        jdoubleArray oneDim = (jdoubleArray)(*jenv)->GetObjectArrayElement(jenv, dblDim, j);
        jboolean isCopy = JNI_FALSE;
        jdouble* element = NULL;
        arg10[j * arg8 + i] = (*jenv)->GetArrayLength(jenv, oneDim);
        arg7[j * arg8 + i] = (double*)MALLOC(sizeof(jdouble) * arg10[j * arg8 + i]);
        isCopy = JNI_FALSE;
        element = (jdouble*)(*jenv)->GetPrimitiveArrayCritical(jenv, oneDim, &isCopy);
        memcpy(arg7[j * arg8 + i], element, sizeof(jdouble) * arg10[j * arg8 + i]);
        (*jenv)->ReleasePrimitiveArrayCritical(jenv, oneDim, element, 0);
        (*jenv)->DeleteLocalRef(jenv, oneDim);
      }
      (*jenv)->DeleteLocalRef(jenv, dblDim);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(; i < arg4 * arg5; i++)
    {
      FREE(arg3[i]);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(; i < arg8 * arg9; i++)
    {
      FREE(arg7[i]);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < (*nbRow) * (*nbCol); i++)
    {
        pstData[i] = (char *)malloc(sizeof(char) * (piLen[i] + 1)); //+ 1 for null termination
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i<size2; i++) {
      jstring j_string = (jstring)(*jenv)->GetObjectArrayElement(jenv, jarg2, i);
      const char * c_string = (*jenv)->GetStringUTFChars(jenv, j_string, 0);
      arg2[i] = MALLOC((strlen(c_string)+1)*sizeof(const char *));
      strcpy(arg2[i], c_string);
      (*jenv)->ReleaseStringUTFChars(jenv, j_string, c_string);
      (*jenv)->DeleteLocalRef(jenv, j_string);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<size2-1; i++) {
      FREE(arg2[i]);
      arg2[i] = NULL;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n_label * m_label; i++)
        {
            label_list[i] = (char *)MALLOC((len_label[i]+1)*sizeof(char));
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nb_value_to_check; i++)
            {
                value_to_check = va_arg(vl, int);
                check_res = check_res || (value_to_check == *_piValue);
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nb_value_to_check; i++)
                    {
                        value_to_check = va_arg(vl,int);
                        sciprint(" %d", value_to_check);
                    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nb_value_to_check; i++)
            {
                value_to_check = va_arg(vl, double);
                check_res = check_res || (value_to_check == *_pdblValue);
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nb_value_to_check; i++)
                    {
                        value_to_check = va_arg(vl, double);
                        sciprint(" %f", value_to_check);
                    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n_label * m_label; i++)
        {
            label_list[i] = (char *)MALLOC((len_label[i] + 1) * sizeof(char));
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nb_value_to_check; i++)
            {
                value_to_check = va_arg(vl, char *);
                check_res = check_res || (strcmp(value_to_check, *_pstValue) == 0);
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nb_value_to_check; i++)
                    {
                        value_to_check = va_arg(vl, char *);
                        sciprint(" \"%s\"", value_to_check);
                    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < *_piSize; i++)
            {
                _piValue[i] = (int)tmp_dbl[i];
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nb_value_to_check; i++)
            {
                value_to_check = va_arg(vl, int);
                check_res = check_res || (value_to_check == *_piValue);
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nb_value_to_check; i++)
                    {
                        value_to_check = va_arg(vl, int);
                        sciprint(" %d", value_to_check);
                    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < _iDefaultSize; i++)
                {
                    _pdblValue[i] = _dblDefaultValue;
                }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < _iDefaultSize; i++)
                {
                    _pdblValue[i] = _dblDefaultValue;
                }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < _iDefaultSize; i++)
                {
                    _pdblValue[i] = _dblDefaultValue;
                }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < _iDefaultSize; i++)
                {
                    _pdblValue[i] = _dblDefaultValue;
                }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < _iDefaultSize; i++)
                {
                    _pdblValue[i] = _dblDefaultValue;
                }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nb_value_to_check; i++)
            {
                value_to_check = va_arg(vl, double);
                check_res = check_res || (value_to_check == *_pdblValue);
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nb_value_to_check; i++)
                    {
                        value_to_check = va_arg(vl,double);
                        sciprint(" %f", value_to_check);
                    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < _iDefaultSize; i++)
                {
                    _pdblValue[i] = _dblDefaultValue;
                }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i <= _iNbParams; i++)
    {
        label_list[i] = strdup(_pstLabelNames[i-1]);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < _iNbValues; i++)
    {
        tmp_val[i] = (double)_piValue[i];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0;  i < n_label * m_label; i++)
    {
        label_list[i] = (char *)MALLOC((len_label[i] + 1) * sizeof(char));
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < m_label * n_label; i++)
        {
            
            if (label_list[i] != NULL)
            {
                if (strncmp(label_list[i], _pstLabelToFind, strlen(_pstLabelToFind)) == 0)
                {
                    Pos = i;

                    if (len_label)
                    {
                        FREE(len_label);
                        len_label = NULL;
                    }
                    freeArrayOfString(label_list, m_label * n_label);

                    return Pos;
                }
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n_label * m_label; i++)
    {
        label_list[i] = (char *)MALLOC((len_label[i] + 1) * sizeof(char));
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < m_label * n_label; i++)
        {
            
            if (label_list[i] != NULL)
            {
                if (strcmp(label_list[i], (char *)_pstLabelToFind) == 0)
                {
                    Pos = i;

                    if (len_label)
                    {
                        FREE(len_label);
                        len_label = NULL;
                    }
                    freeArrayOfString(label_list, m_label * n_label);

                    return Pos;
                }
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(; n; --n, ++dst)
    {
        *dst= v;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(; n; --n, ++dst)
    {
        *dst= v;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<numb;i++)
       {n=(unsigned long)pow(2,*ipar+i);
        ref=ref+n;}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<mu1;j++)
	{for(i=0;i<nu;i++)
		{ij=i+j*nu;
	 	 ji=j+i*mu1;
		 *(ptr->LAT+ij)=*(u1+ji);}
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<mu2;j++)
	{for(i=0;i<nu;i++)
		{ij=i+j*l;
	 	 ji=j+i*mu2;
		 *(ptr->LBT+ij)=*(u2+ji);}
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<nu;j++)
		{for(i=0;i<mu2;i++)
			{ij=i+j*mu2;
			ji=j+i*nu;
			*(y+ij)=*(ptr->LBT+ji);}
		}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<mu1;i++)    *(ptr->jpvt+i)=0;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<mu1;j++)
	{for(i=0;i<mu2;i++)
		{ij=i+j*mu2;
		ji=j+i*l;
		*(y+ij)=*(ptr->LBT+ji);}
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<maxim/2;i++)
       {n=(short)pow(2,maxim/2+i);
        ref=ref+n;}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=r[2]-1;j<r[3];j++)
	{
		int i = 0;
		for(i=r[0]-1;i<r[1];i++)
		{
			int ij = i + j*mu;
			*(y+k)=*(u+ij);
			k++;
		}
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i< block->insz[0];i++){
    if (flag ==1 || flag ==6 || flag ==4)
      block->outptr[0][i]=block->z[i];
    else if (flag == 2)
      block->z[i]=block->inptr[0][i];
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(l=0;l<nu2;l++)
		{
			int j = 0;
			for(j=0;j<mu1;j++)
			{
				double D = 0.;
				int jl = j + l*mu1;
				int i = 0;
				for(i=0;i<nu1;i++)
				{
					int ji = j + i*mu1;
					int il = i + l*nu1;
					double C = (double)(u1[ji])*(double)(u2[il]);
					D = D + C;
				}
				y[jl]=(unsigned char)D;
			}
		}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<mu*nu;i++)
	     {v=(double)u1[i]*(double)u2[0];
	       if ((v<rpar[0])|(v>rpar[1])) 
		 {sciprint(_("overflow error"));
		   set_block_error(-4);
		   return;}
	       else y1[i]=(long)v;}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<mu*nu;i++)
	     {v=(double)u1[i]*(double)u2[0];
	       if ((v<rpar[0])|(v>rpar[1])) 
		 {sciprint(_("overflow error"));
		   set_block_error(-4);
		   return;}
	       else  y1[i]=(short)v;}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<mu*nu;i++)
	     {v=(double)u1[i]*(double)u2[0];
	       if ((v<rpar[0])|(v>rpar[1])) 
		 {sciprint(_("overflow error"));
		   set_block_error(-4);
		   return;}
	       else y1[i]=(char)v;}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<mu*nu;i++)
	     {v=(double)u1[i]*(double)u2[0];
	       if ((v<rpar[0])|(v>rpar[1])) 
		 {sciprint(_("overflow error"));
		   set_block_error(-4);
		   return;}
	       else y1[i]=(unsigned long)v;}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<mu*nu;i++)
	     {v=(double)u1[i]*(double)u2[0];
	       if ((v<rpar[0])|(v>rpar[1])) 
		 {sciprint(_("overflow error"));
		   set_block_error(-4);
		   return;}
	       else y1[i]=(unsigned short)v;}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<mu*nu;i++)
	     {v=(double)u1[i]*(double)u2[0];
	       if ((v<rpar[0])|(v>rpar[1])) 
		 {sciprint(_("overflow error"));
		   set_block_error(-4);
		   return;}
	       else y1[i]=(unsigned char)v;}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<block->insz[0];j++) {
      block->outptr[0][j]=acosh(block->inptr[0][j]);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<xu*vu;i++) 
	{
		*(yr+i)=*(u1r+i);
		*(yi+i)=*(u1i+i);
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<(nu*nu);i++)
		{
			ptr->LA[2*i]=ur[i];
			ptr->LA[2*i+1]=ui[i];
		}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<nu;j++)
		{
			for(i=j;i<nu;i++)
			{
				ij=i+j*nu;
				ji=j+i*nu;
				if (i!=j)
				{
					if ((*(ptr->LA+2*ij)==*(ptr->LA+2*ji))&&(*(ptr->LA+2*ij+1)==-(*(ptr->LA+2*ji+1)))) hermitien*= 1;
					else { hermitien*=0;break;
					}
				}
			}
		}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<nu;i++)
			{
				ii=i+i*nu;
				*(y1r+ii)=*(ptr->LX+i);
			}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<nu*nu;i++)
			{
				*(y2r+i)=*(ptr->LA+2*i);
				*(y2i+i)=*(ptr->LA+2*i+1);
			}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<nu;i++)
			{
				ii=i+i*nu;
				*(y1r+ii)=*(ptr->LX+2*i);
				*(y1i+ii)=*(ptr->LX+2*i+1);
			}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<nu*nu;i++)
		 {
			 *(y2r+i)=*(ptr->LVR+2*i);
			 *(y2i+i)=*(ptr->LVR+2*i+1);
			}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<*ipar;i++)
       {n=(char)pow(2,i);
        ref=ref+n;}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<mu*nu;i++)
	{
		long v=u[i];
		for(j=0;j<-ipar[0];j++)
		{
			y[i]=v&1;
			if (y[i]==0)  
			{
				y[i]=v>>1;
				y[i]=y[i]&(k-1);
			}
			else 
			{
				y[i]=v>>1;
				y[i]=(y[i])|(k);
			}
			v=y[i];
		}
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<(nu*nu);i++)
		{
			ptr->LA[2*i]=ur[i];
			ptr->LA[2*i+1]=ui[i];}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<nu;j++)
		{
			for(i=j;i<nu;i++)
			{ij=i+j*nu;
			ji=j+i*nu;
			if (i!=j)
			{
				if ((*(ptr->LA+2*ij)==*(ptr->LA+2*ji))&&(*(ptr->LA+2*ij+1)==-(*(ptr->LA+2*ji+1)))) hermitien*= 1;
				else {
					hermitien*=0;break;
			 }
			}
			}
		}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<nu;i++)
			{
				*(yr+i)=*(ptr->LX+2*i);
				*(yi+i)=*(ptr->LX+2*i+1);}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<my*ny;i++)
			{
				*(z+i+1)=C2F(urand)(&iy);
			}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<my*ny;i++)
			{
				do
				{
					sr=2.0*C2F(urand)(&iy)-1.0;
					si=2.0*C2F(urand)(&iy)-1.0;
					tl=sr*sr+si*si;
				} while(tl>1.0);
				z[i+1]= sr*(sqrt(-2.0*log(tl)/tl));}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<my*ny;i++) *(y+i)=*(rpar+i)+(*(rpar+i+my*ny))*(*(z+i+1));



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(l=0;l<nu2;l++)
		{
			int j = 0;
			for(j=0;j<mu1;j++)
			{
				double D = 0.;
				int jl = j + l*mu1;
				int i = 0;
				for(i=0;i<nu1;i++)
				{
					int ji = j+i*mu1;
					int il = i+l*nu1;
					double C=(double)(u1[ji])*(double)(u2[il]);
					D = D + C;
				}
				if (D>(k-1))
				{
					y[jl]=(unsigned char)(k-1);
				}
				else if (D<0)
				{
					y[jl]=0;
				}
				else 
				{
					y[jl]=(unsigned char)(D);
				}
			}
		}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<mu*nu;i++) 
	{
		*(yr+i)=*(u1r+i);
		*(yi+i)=-(*(u1i+i));
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<=(mz*nz)-2; i++){
      oz[i]=oz[i+1];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<nu*mu;j++) 
			{
				v=v+(double)u[j];
			}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<nu*mu;j++) 
			{
				v=0;
				for(k=0;k<nin;k++) 
				{
					u=Getuint16InPortPtrs(block,k+1);
					if(ipar[k]>0)
					{
						v=v+(double)u[j];
					}
					else
					{
						v=v-(double)u[j];}
				}
				if ((v>=l)|(v<0)) 
				{
					sciprint(_("overflow error"));
					set_block_error(-4);
					return;
				}
				else y[j]=(unsigned short)v;
			}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<nu*nu;i++) *(y+i)=*(ptr->LX+i);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<mu*nu;i++) y[i]=u[i]>>-ipar[0];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<block->insz[0];j++) {
			block->outptr[0][j]=tan(block->inptr[0][j]);
		}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++) *(y+i)=((*(u+i))|(*opar));



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < *nu ; i++)
  {
	  y[i] = cos(u[i]);
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<nu*mu;j++)
			{
				v=v+(double)u[j];
			}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<nu*mu;j++) 
			{
				v=0;
				for(k=0;k<nin;k++) 
				{
					u=Getuint16InPortPtrs(block,k+1);
					if(ipar[k]>0)
					{
						v=v+(double)u[j];
					}
					else
					{
						v=v-(double)u[j];}
				}
				if (v>=l)  v=l-1;
				else if (v<0) v=0;
				y[j]=(unsigned short)v;
			}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<mu*nu;j++) 
			{
				yr[0]=yr[0]+ur[j];
				yi[0]=yi[0]+ui[j];
			}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<mu*nu;j++)
			{
				yr[j]=0.0;
				yi[j]=0.0;
				for(k=1;k<GetNin(block)+1;k++) 
				{
					ur=GetRealInPortPtrs(block,k);
					ui=GetImagInPortPtrs(block,k);
					ipar=GetIparPtrs(block);
					if(ipar[k-1]>0)
					{
						yr[j]=yr[j]+ur[j];
						yi[j]=yi[j]+ui[j];
					}
					else
					{
						yr[j]=yr[j]-ur[j];
						yi[j]=yi[j]-ui[j];
					}
				}
			}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<block->insz[0];++i){
	if (get_phase_simulation()==1) {
	  if (block->inptr[0][i]<0){
	    j=2;
	  } else{
	    j=1;
	  }
	}else {
	  j=block->mode[i];
	}
	if (j==1){
	  block->outptr[0][i]=block->inptr[0][i];
	} else{
	  block->outptr[0][i]=-block->inptr[0][i];
	}
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<block->insz[0];++i){
	if (block->inptr[0][i]<0){
	  block->outptr[0][i]=-block->inptr[0][i];
	}else{
	  block->outptr[0][i]=block->inptr[0][i];
	}
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<block->insz[0];++i){
      block->g[i]=block->inptr[0][i];
      if (get_phase_simulation()==1) {
	if(block->g[i]<0){
	  block->mode[i]=2;
	}else{
	  block->mode[i]=1;
	}
      }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++) *(y+i)=block->mode[i]-1;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++) y[i]=0;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
				{
					if (u1[i]==u2[i]) y[i]=1;
				}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
				{
					if (u1[i]!=u2[i]) y[i]=1;
				}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
				{
					if (u1[i]<u2[i]) y[i]=1;
				}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
				{
					if (u1[i]<=u2[i]) y[i]=1;
				}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
				{
					if (u1[i]>u2[i]) y[i]=1;
				}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
				{
					if (u1[i]>=u2[i]) y[i]=1;
				}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++) block->g[i]=*(u1+i)-*(u2+i);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++) block->mode[i]=(int)1;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
				{
					if (u1[i]==u2[i]) block->mode[i]=(int)2;
				}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
				{
					if (u1[i]!=u2[i]) block->mode[i]=(int)2;
				}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
				{
					if (u1[i]<u2[i]) block->mode[i]=(int)2;
				}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
				{
					if (u1[i]<=u2[i]) block->mode[i]=(int)2;
				}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
				{
					if (u1[i]>u2[i]) block->mode[i]=(int)2;
				}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
				{
					if (u1[i]>=u2[i]) block->mode[i]=(int)2;
				}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<block->insz[0];j++) 
			{
				block->outptr[0][0]=block->outptr[0][0]*block->inptr[0][j];
			}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<block->insz[0];j++) 
			{
				block->outptr[0][j]=1.0;
				for(k=0;k<block->nin;k++) 
				{
					if(block->ipar[k]>0)
					{
						block->outptr[0][j]=block->outptr[0][j]*block->inptr[k][j];
					}
					else
					{
						if(block->inptr[k][j]==0)
						{
							set_block_error(-2);
							return;
						}
						else
						{
							block->outptr[0][j]=block->outptr[0][j]/block->inptr[k][j];
						}
					}
				}
			}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<xu*vu;i++) *(y+i)=*(u1+i);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<mu*nu;i++) y[i]=0;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<Min(mu,nu);i++)  
	 {if (*(ptr->LSV+i)!=0)
	      {*(ptr->LSW+i)=1/(*(ptr->LSV+i));}
	 else 
	      {*(ptr->LSW+i)=0;}}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<Min(mu,nu);i++)
	{ii=i+i*nu;
	 *(ptr->LS+ii)=*(ptr->LSW+i);}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<mu;j++)
	{for(i=j;i<mu;i++)
		{ij=i+j*mu;
	 	 ji=j+i*mu;
		 *(ptr->LUT+ij)=*(ptr->LU+ji);
		 *(ptr->LUT+ji)=*(ptr->LU+ij);}
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<nu;j++)
	{for(i=j;i<nu;i++)
		{ij=i+j*nu;
	 	 ji=j+i*nu;
		 *(ptr->LV+ij)=*(ptr->LVT+ji);
		 *(ptr->LV+ji)=*(ptr->LVT+ij);}
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<mu*nu;i++)  
		{
			double inpr = ur[i];
			double inpi = ui[i];
			C2F(wsqrt)(&inpr,&inpi,&yr[i],&yi[i]);
		}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<block->insz[0];j++) {
      block->outptr[0][j]=cos(block->inptr[0][j]);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
     		       	  {if (u[i]<=0)
		       	       {*y=0;
			        break;}
     		      	  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=1;i<m*n;i++)
			    {*y=(*y)&(u[i]);}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
			   {y[i]=1;
			    for(j=1;j<nin+1;j++)
				 {u=Getuint16InPortPtrs(block,j);
				  if (u[i]<=0) 
				      {y[i]=0;
				       break;}
				 } 
			   }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
			   {u=Getuint16InPortPtrs(block,1);
			    y[i]=u[i];
			    for(j=2;j<nin+1;j++)
				 {u=Getuint16InPortPtrs(block,j);
				  y[i]=(y[i])&(u[i]);
				 }
			   }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
     		       	  {if (u[i]>0)
		       	       {*y=1;
			        break;}
     		      	  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
			    {*y=(*y)|(u[i]);}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
			   {y[i]=0;
			    for(j=1;j<nin+1;j++)
				 {u=Getuint16InPortPtrs(block,j);
				  if (u[i]>0) 
				      {y[i]=1;
				       break;}
				 }
			   }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
			   {y[i]=0;
			    for(j=1;j<nin+1;j++)
				 {u=Getuint16InPortPtrs(block,j);
				  y[i]=(y[i])|(u[i]);
				 }
			   }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
     		       	  {if (u[i]<=0)
		       	       {*y=1;
			        break;}
     		      	  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=1;i<m*n;i++)
			    {*y=((*y)&(u[i]));}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
			   {y[i]=0;
			    for(j=1;j<nin+1;j++)
				 {u=Getuint16InPortPtrs(block,j);
				  if (u[i]<=0) 
				      {y[i]=1;
				       break;}
				 } 
			   }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
			   {u=Getuint16InPortPtrs(block,1);
			    y[i]=u[i];
			    for(j=2;j<nin+1;j++)
				 {u=Getuint16InPortPtrs(block,j);
				  y[i]=((y[i])&(u[i]));
				 }
			    y[i]=~y[i];
			   }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
     		       	  {if (u[i]>0)
		       	       {*y=0;
			        break;}
     		      	  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
			    {*y=((*y)|(u[i]));}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
			   {y[i]=1;
			    for(j=1;j<nin+1;j++)
				 {u=Getuint16InPortPtrs(block,j);
				  if (u[i]>0) 
				      {y[i]=0;
				       break;}
				 }
			   }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
			   {u=Getuint16InPortPtrs(block,1);
			    y[i]=u[i];
			    for(j=2;j<nin+1;j++)
				 {u=Getuint16InPortPtrs(block,j);
				  y[i]=((y[i])|(u[i]));
				 }
			    y[i]=~y[i];
			   }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
     		       	  {if (u[i]>0)
		       	       {l=(l+1)%2;
			       }
     		      	  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=1;i<m*n;i++)
			    {*y=((*y)^(u[i]));}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
			   {l=0;
			    for(j=1;j<nin+1;j++)
				 {u=Getuint16InPortPtrs(block,j);
				  if (u[i]>0) 
				      {l=(l+1)%2;}
				 }
			    y[i]=(unsigned short)l;
			   }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
		           {u=Getuint16InPortPtrs(block,1);
		           y[i]=u[i];
			   for(j=2;j<nin+1;j++)
				 {u=Getuint16InPortPtrs(block,j);
				  y[i]=((y[i])^(u[i]));
				 }
			   }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
		       {if (u[i]>0) y[i]=0;
			else y[i]=1;}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
		       {y[i]=~(u[i]);}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(l=0;l<nu2;l++)
	    {for(j=0;j<mu1;j++)
	        {D=0;
		     jl=j+l*mu1;
	        for(i=0;i<nu1;i++)
		   {ji=j+i*mu1;
		    
		    il=i+l*nu1;
		    C=(double)(u1[ji])*(double)(u2[il]);
		    D=D + C;}
		    t=D-(int)(D/(k))*((k));
		    y[jl]=(unsigned long)t;
		  }
	     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<*ipar;i++)
       {n=(unsigned long)pow(2,maxim-1-i);
        ref=ref+n;}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<(nu*nu);i++)   mdet->wrk[i]=u[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<nu;i++)
       {if((*(mdet->ipiv+i))!=i+1) D=-D;
        l=*(mdet->wrk+i*(nu+1));
        D=D*l;
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++) *(y+i)=((*(u+i))|(*opar));



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<nu;j++)
       {i=0;
	ij=i+j*mu;
	yr[ij]=ur[ij];
	yi[ij]=ui[ij];
	for(i=1;i<mu;i++)
	   {ij=i+j*mu;
	    yr[ij]=ur[ij]+yr[ij-1];
	    yi[ij]=ui[ij]+yi[ij-1];}}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<block->nout;++i)
		{
			for(j=0;j<block->outsz[i];++j)
			{
				block->outptr[i][j]=block->inptr[0][k];
				++k;
			}
		}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<block->nin;++i)
		{
			for(j=0;j<block->insz[i];++j)
			{
				block->outptr[0][k]=block->inptr[i][j];
				++k;
			}
		}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<*ipar;i++)
       {n=(unsigned char)pow(2,maxim-1-i);
        ref=ref+n;}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<maxim/2;i++)
       {n=(unsigned long)pow(2,maxim/2+i);
        ref=ref+n;}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<nu;j++)
	{
		double dr = 0.;
		double di = 0.;
		int i = 0;
		for(i=0;i<mu;i++)
		{
			int ij = i+j*mu;
			dr += *(ur+ij);
			di += *(ui+ij);
		}
		*(yr+j)=dr;
		*(yi+j)=di;
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<maxim/2;i++)
       {n=(char)pow(2,i);
        ref=ref+n;}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<mu;i++) 
	{yr[i]=ur[i];
	 yi[i]=ui[i];}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=1;j<nu;j++)
       {
	for(i=0;i<mu;i++)
	   {ij=i+j*mu;
	    yr[ij]=ur[ij]+yr[ij-mu];
	    yi[ij]=ui[ij]+yi[ij-mu];}}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<mu*nu;i++)
	     {v=(double)u1[i]*(double)u2[0];
	       if (v<rpar[0]) v=rpar[0];
	       else if (v>rpar[1]) v=rpar[1];
	       y1[i]=(long)v;}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<mu*nu;i++)
	     {v=(double)u1[i]*(double)u2[0];
	       if (v<rpar[0]) v=rpar[0];
	       else if (v>rpar[1]) v=rpar[1];
	       y1[i]=(short)v;}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<mu*nu;i++)
	     {v=(double)u1[i]*(double)u2[0];
	       if (v<rpar[0]) v=rpar[0];
	       else if (v>rpar[1]) v=rpar[1];
	       y1[i]=(char)v;}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<mu*nu;i++)
	     {v=(double)u1[i]*(double)u2[0];
	       if (v<rpar[0]) v=rpar[0];
	       else if (v>rpar[1]) v=rpar[1];
	       y1[i]=(unsigned long)v;}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<mu*nu;i++)
	     {v=(double)u1[i]*(double)u2[0];
	       if (v<rpar[0]) v=rpar[0];
	       else if (v>rpar[1]) v=rpar[1];
	       y1[i]=(unsigned short)v;}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<mu*nu;i++)
	     {v=(double)u1[i]*(double)u2[0];
	       if (v<rpar[0]) v=rpar[0];
	       else if (v>rpar[1]) v=rpar[1];
	       y1[i]=(unsigned char)v;}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<ny*mu;++i){
     D=(double)(opar[0])*(double)(u[i]);
     if (D>=k)  D=k-1;
     else if (D<0) D=0;
     y[i]=(unsigned char)D;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(l=0;l<ny;l++)
	 {for(j=0;j<my;j++)
	      {D=0;
		   jl=j+l*my;
	       for(i=0;i<mu;i++)
		   {ji=j+i*my;
		    
		    il=i+l*mu;
		    C=(double)(opar[ji])*(double)(u[il]);
		    D=D + C;}
		    if (D>=k)  D=k-1;
		    else if (D<0) D=0;
		    y[jl]=(unsigned char)D;
		  }
	     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<ny*mu;++i){
     D=(double)(opar[0])*(double)(u[i]);
     if ((D>=k)|( D<-k))
	{sciprint(_("overflow error"));
	 set_block_error(-4);
	 return;}
     else y[i]=(char)D;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(l=0;l<ny;l++)
	 {for(j=0;j<my;j++)
	      {D=0;
		   jl=j+l*my;
	       for(i=0;i<mu;i++)
		   {ji=j+i*my;
		    
		    il=i+l*mu;
		    C=(double)(opar[ji])*(double)(u[il]);
		    D=D + C;}
		    if ((D>=k)|( D<-k))
			{sciprint(_("overflow error"));
			 set_block_error(-4);
			 return;}
		    else y[jl]=(char)D;
		  }
	     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<block->insz[0];j++) 
		{
			block->outptr[0][j]=tanh(block->inptr[0][j]);
		}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < block->insz[0]; i++)
            {
                result = pushData(block, 0, i);
                if (result == FALSE)
                {
                    Coserror("%s: unable to push some data.", "cscope");
                    break;
                }
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < block->nin; i++)
        {
            sco->internal.bufferCoordinates[i] = (double **)CALLOC(block->insz[i], sizeof(double *));
            if (sco->internal.bufferCoordinates[i] == NULL)
            {
                goto error_handler_bufferCoordinates_i;
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < block->nin; i++)
        {
            for(j = 0; j < block->insz[i]; j++)
            {
                sco->internal.bufferCoordinates[i][j] = (double *)CALLOC(3 * block->ipar[2], sizeof(double));

                if (sco->internal.bufferCoordinates[i][j] == NULL)
                {
                    goto error_handler_bufferCoordinates_ij;
                }
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < block->nin; i++)
        {
            sco->internal.historyCoordinates[i] = (double **)CALLOC(block->insz[i], sizeof(double *));
            if (sco->internal.historyCoordinates[i] == NULL)
            {
                goto error_handler_historyCoordinates_i;
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < i; j++)
    {
        FREE(sco->internal.historyCoordinates[i]);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 0; k < i; k++)
    {
        for(l = 0; l < j; l++)
        {
            FREE(sco->internal.bufferCoordinates[k][l]);
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < i; j++)
    {
        FREE(sco->internal.bufferCoordinates[i]);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < block->nin; i++)
        {
            for(j = 0; j < block->insz[i]; j++)
            {
                if (sco->internal.historyCoordinates[i][j] != NULL)
                {
                    FREE(sco->internal.historyCoordinates[i][j]);
                }
                FREE(sco->internal.bufferCoordinates[i][j]);
            }
            FREE(sco->internal.historyCoordinates[i]);
            FREE(sco->internal.bufferCoordinates[i]);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < block->insz[0]; i++)
        {
            FREE(sco->scope.cachedHistoryPolylinesUIDs[i]);
            FREE(sco->scope.cachedBufferPolylinesUIDs[i]);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < block->insz[0]; i++)
    {
        ptr = (double *)MALLOC(3 * allocatedNumberOfPoints * sizeof(double));
        if (ptr == NULL)
        {
            goto error_handler;
        }

        // memcpy existing X-axis values from the history
        memcpy(ptr, sco->internal.historyCoordinates[0][i], previousNumberOfPoints * sizeof(double));
        // memcpy existing Y-axis values from the history
        memcpy(ptr + allocatedNumberOfPoints, sco->internal.historyCoordinates[0][i] + previousNumberOfPoints, previousNumberOfPoints * sizeof(double));
        // clear the last points, the Z-axis values
        memset(ptr + 2 * allocatedNumberOfPoints, 0, allocatedNumberOfPoints * sizeof(double));

        // then set the last points to the last values for X-axis and Y-axis values from the buffer points
        buffer = sco->internal.bufferCoordinates[0][i];
        memcpy(ptr + previousNumberOfPoints, buffer + bufferNewPointInc, (numberOfCopiedPoints - bufferNewPointInc) * sizeof(double));
        memcpy(ptr + allocatedNumberOfPoints + previousNumberOfPoints, buffer + bufferNumberOfPoints + bufferNewPointInc, (numberOfCopiedPoints - bufferNewPointInc) * sizeof(double));

        FREE(sco->internal.historyCoordinates[0][i]);
        sco->internal.historyCoordinates[0][i] = ptr;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(setLen = numberOfPoints; setLen < bufferPoints; setLen++)
    {
        coordinates[setLen] = t;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(setLen = numberOfPoints; setLen < bufferPoints; setLen++)
    {
        coordinates[bufferPoints + setLen] = value;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < block->insz[input]; i++)
        {
            sco->internal.bufferCoordinates[input][i][0] = sco->internal.bufferCoordinates[input][i][sco->internal.numberOfPoints - 1];
            sco->internal.bufferCoordinates[input][i][block->ipar[2]] = sco->internal.bufferCoordinates[input][i][block->ipar[2] + sco->internal.numberOfPoints - 1];
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < block->insz[input]; i++)
        {
            if (sco->internal.historyCoordinates[input][i] != NULL)
            {
                FREE(sco->internal.historyCoordinates[input][i]);
                sco->internal.historyCoordinates[input][i] = NULL;
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < block->insz[input]; i++)
        {
            sco->internal.bufferCoordinates[input][i][0] = sco->internal.bufferCoordinates[input][i][block->ipar[2] - 1];
            sco->internal.bufferCoordinates[input][i][block->ipar[2]] = sco->internal.bufferCoordinates[input][i][2 * block->ipar[2] - 1];
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < block->insz[input]; i++)
        {
            const double value = data[i];
            setBuffersCoordinates(block, sco->internal.bufferCoordinates[input][i], sco->internal.numberOfPoints, block->ipar[2], t, value);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < GetNin(block); i++)
        {
            pAxe = getAxe(pFigureUID, block, i);

            


            setLabel(pAxe, __GO_X_AXIS_LABEL__, "t");
            setLabel(pAxe, __GO_Y_AXIS_LABEL__, "y");

            setGraphicObjectProperty(pAxe, __GO_X_AXIS_VISIBLE__, &i__1, jni_bool, 1);
            setGraphicObjectProperty(pAxe, __GO_Y_AXIS_VISIBLE__, &i__1, jni_bool, 1);

            setPolylinesBounds(block, i, 0);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < block->insz[input]; i++)
        {
            getPolyline(pAxe, block, i, TRUE);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < block->insz[input]; i++)
        {
            getPolyline(pAxe, block, i, FALSE);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < block->nin; i++)
    {
        for(j = 0; j < block->insz[i]; j++)
        {
            pPolylineUID = sco->scope.cachedBufferPolylinesUIDs[j];
            deleteGraphicObject(pPolylineUID);
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < block->insz[input]; i++)
    {
        pPolylineUID = getPolyline(pAxeUID, block, i, TRUE);

        data = sco->internal.historyCoordinates[input][i];
        result &= setGraphicObjectProperty(pPolylineUID, __GO_DATA_MODEL_COORDINATES__, data, jni_double_vector, maxNumberOfPoints);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=1;i<block->insz[0];++i)
				{
					if(block->ipar[0]==1)
					{
						if(block->inptr[0][i]<maxmin)  maxmin=block->inptr[0][i];
					} 
					else 
					{
						if(block->inptr[0][i]>maxmin)  maxmin=block->inptr[0][i];
					}
				}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<block->insz[0];++i)
			{
				if((block->ng==0)||(phase==1))
				{
					if(block->ipar[0]==1)
					{
						block->outptr[0][i]=Min(block->inptr[0][i],block->inptr[1][i]);
					} 
					else 
					{
						block->outptr[0][i]=Max(block->inptr[0][i],block->inptr[1][i]);
					}
				}
				else
				{
					block->outptr[0][i]=block->inptr[block->mode[0]-1][i];
				}
			}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<block->insz[0];++i)
				{
					if(i!=block->mode[0]-1)
					{
						block->g[i]=block->inptr[0][i]-block->inptr[0][block->mode[0]-1];
					}
					else
					{
						block->g[i]=1.0;
					}
				}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=1;i<block->insz[0];++i)
				{
					if(block->ipar[0]==1)
					{
						if(block->inptr[0][i]<maxmin) 
						{
							maxmin=block->inptr[0][i];
							block->mode[0]=i+1;
						}
					}
					else 
					{
						if(block->inptr[0][i]>maxmin) 
						{
							maxmin=block->inptr[0][i];
							block->mode[0]=i+1;
						}
					}
				}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<block->insz[0];++i)
			{
				block->g[i]=block->inptr[0][i]-block->inptr[1][i];
				if(phase==1)
				{
					if(block->ipar[0]==1)
					{
						if(block->g[i]>0) 
						{
							block->mode[i]=2;
						}
						else
						{
							block->mode[i]=1;
						}
					}
					else
					{
						if(block->g[i]<0) 
						{
							block->mode[i]=2;
						}
						else
						{
							block->mode[i]=1;
						}
					}
				}
			}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<NX;i++) property[i]=-1; 



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<NX;i++)  block->x[i]=u[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<NX;i++) property[i]=-1; 



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<NX;i++) block->res[i]=u[i]-block->x[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<NX;i++)  y[i]=block->xd[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<nu*mu;j++) 
			{
				v=v+(double)u[j];
			}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<nu*mu;j++) 
			{
				v=0;
				for(k=0;k<nin;k++) 
				{
					u=Getint32InPortPtrs(block,k+1);
					if(ipar[k]>0)
					{
						v=v+(double)u[j];
					}
					else
					{
						v=v-(double)u[j];}
				}
				if (v>=l)  v=l-1;
				else if (v<-l) v=-l;
				y[j]=(long)v;
			}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<*ipar;i++)
       {n=(unsigned short)pow(2,maxim-1-i);
        ref=ref+n;}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<outsz[0];i++)
			*(outptr[0]+i)=record[mask[ievt+i]];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=2;i>=0;i--)
					if (type[i]!=' ') 
					{
						type[i+1]='\0';break;
					}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=2;i>=0;i--)
				if (type[i]!=' ') { type[i+1]='\0';break;}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=2;i>=0;i--)
			if (type[i]!=' ') 
			{
				type[i+1]='\0';break;
			}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<nu;j++)
       {i=0;
	ij=i+j*mu;
	y[ij]=u[ij];
	for(i=1;i<mu;i++)
	   {ij=i+j*mu;
	    y[ij]=u[ij]+y[ij-1];}}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<NX;i++) property[i]=0; 



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<NX;i++) x[i]=rparX0[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<NX;i++){
      y1[i]=x[i];
      y1[i+NX]=xd[i];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<NX;i++)
      res[i]= ui[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<NX;i++)
      property[i] = iparXp[(Mi-1)*NX+i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<ng;j++) g[j]=0;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<insz[Mi-1]-2*NX;j++) {
      g[j]=ui[j+2*NX];
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=1;i<Mi;i++)  
      indice+=insz[i-1]-2*NX; 



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k=0;k<insz[Mi-1]-2*NX;k++)
      if(jroot[k]==1){
	evout[0]=0.0;
	break;
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=1;i<Mi;i++)  
      indice+=insz[i-1]-2*NX; 



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k=0;k<insz[Mi-1]-2*NX;k++){
      if(jroot[k]==1){
	Mf=iparCx[indice+k]; 
	Mode[0]=Mf;
	Mode[1]=Mi;
	test=1;
	break;
      }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k=0;k<insz[Mi-1]-2*NX;k++) if(jroot[k]==-1) break;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<NX;i++)
      x[i]=ui[i+NX];     



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<block->insz[0];j++) {
      block->outptr[0][j]=cosh(block->inptr[0][j]);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<ny*mu;++i){
     D=(double)(opar[0])*(double)(u[i]);
     if (D>=k)  D=k-1;
     else if (D<-k) D=-k;
     y[i]=(char)D;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(l=0;l<ny;l++)
	 {for(j=0;j<my;j++)
	      {D=0;
		   jl=j+l*my;
	       for(i=0;i<mu;i++)
		   {ji=j+i*my;
		    
		    il=i+l*mu;
		    C=(double)(opar[ji])*(double)(u[il]);
		    D=D + C;}
		    if (D>=k)  D=k-1;
		    else if (D<-k) D=-k;
		    y[jl]=(char)D;
		  }
	     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<(block->nx)/2;++i) {
	if(block->mode[i]==3){
	  block->xd[i]=ur[i];
	  block->xd[i+(block->nx)/2]=ui[i];
	}else{
	  block->xd[i]=0.0;
	  block->xd[i+(block->nx)/2]=0.0;
	}
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<(block->nx)/2;++i) {
	block->xd[i]=ur[i];
	block->xd[i+(block->nx)/2]=ui[i];
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<(block->nx)/2;++i) {
      yr[i]=block->x[i];
      yi[i]=block->x[i+(block->nx)/2];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<(block->nx)/2;++i) {
      block->x[i]=ur[i];
      block->x[i+(block->nx)/2]=ui[i];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<(block->nx)/2;++i) {
      if (block->mode[i]==3){
	block->g[i]=(block->x[i]-(block->rpar[i]))*(block->x[i]-(block->rpar[(block->nx)/2+i]));
	block->g[i+(block->nx)/2]=(block->x[i+(block->nx)/2]-(block->rpar[i+(block->nx)]))*(block->x[i+(block->nx)/2]-(block->rpar[3*(block->nx)/2+i]));
      } else {
	block->g[i]=ur[i];
	block->g[i+(block->nx)/2]=ui[i];
      } 
      if (get_phase_simulation()==1) {
	if (ur[i]>=0&&block->x[i]>=block->rpar[i]&&ui[i>=0]&&block->x[i+(block->nx)/2]>=block->rpar[i+(block->nx)]){
	  block->mode[i]=1;
	}else if (ur[i]<=0&&block->x[i]<=block->rpar[(block->nx)/2+i]&&ui[i]<=0&&block->x[i+(block->nx)/2]<=block->rpar[3*(block->nx)/2+i]){
	  block->mode[i]=2;
	}else {
	  block->mode[i]=3;
	}
      }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(l=0;l<nu2;l++)
		{
			int j = 0;
			for(j=0;j<mu1;j++)
			{
				double D = 0.;
				double t = 0.;
				int jl = j + l * mu1;
				int i = 0;
				for(i=0;i<nu1;i++)
				{
					int ji = j+i*mu1;
					int il = i+l*nu1;
					double C = (double)(u1[ji])*(double)(u2[il]);
					D = D + C;
				}
				t = D - (double)((int)(D/(k)))*((k));
				if ((t>=k/2)|(-(t)>=k/2))
				{
					if (t>=0) (t)=(-((k/2))+fabs(t-((double)((int)((t)/((k/2)))))*((k/2))));
					else (t)=-(-((k/2))+fabs(t-((double)((int)((t)/((k/2)))))*((k/2))));
				}
				y[jl]=(short)t;
			}
		}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(l=0;l<nu2;l++)
	    {
			int j = 0;
			for(j=0;j<mu1;j++)
	        {
				double D = 0. ;
				int jl = j + l*mu1;
				int i = 0;
				for(i=0;i<nu1;i++)
				{
					int ji = j + i*mu1;
		    	    int il = i + l*nu1;
					double C = (double)(u1[ji])*(double)(u2[il]);
					D = D + C;
				}
				if ((D>(k-1)) |(D<0))
		        {
					sciprint(_("overflow error"));
					set_block_error(-4);
					return;
				}
				else 
				{
					y[jl]=(unsigned char)(D);
				}
			}
		}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<*ipar;i++)
       {n=(char)pow(2,maxim-1-i);
        ref=ref+n;}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<mu*nu;i++) y[i]=u[i]<<ipar[0];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++) *(y+i)=block->mode[i]-1;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++) y[i]=0;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
				{
					if (u1[i]==u2[i]) y[i]=1;
				}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
				{
					if (u1[i]!=u2[i]) y[i]=1;
				}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
				{
					if (u1[i]<u2[i]) y[i]=1;
				}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
				{
					if (u1[i]<=u2[i]) y[i]=1;
				}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
				{
					if (u1[i]>u2[i]) y[i]=1;
				}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
				{
					if (u1[i]>=u2[i]) y[i]=1;
				}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++) block->g[i]=*(u1+i)-*(u2+i);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++) block->mode[i]=(int)1;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
				{
					if (u1[i]==u2[i]) block->mode[i]=(int)2;
				}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
				{
					if (u1[i]!=u2[i]) block->mode[i]=(int)2;
				}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
				{
					if (u1[i]<u2[i]) block->mode[i]=(int)2;
				}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
				{
					if (u1[i]<=u2[i]) block->mode[i]=(int)2;
				}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
				{
					if (u1[i]>u2[i]) block->mode[i]=(int)2;
				}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
				{
					if (u1[i]>=u2[i]) block->mode[i]=(int)2;
				}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<ny*mu;++i){
     D=(double)(opar[0])*(double)(u[i]);
     if ((D>=k)|( D<-k))
	{sciprint(_("overflow error"));
	 set_block_error(-4);
	 return;}
     else y[i]=(long)D;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(l=0;l<ny;l++)
	 {for(j=0;j<my;j++)
	      {D=0;
	       jl=j+l*my;
	       for(i=0;i<mu;i++)
		   {ji=j+i*my;
		    
		    il=i+l*mu;
		    C=(double)(opar[ji])*(double)(u[il]);
		    D=D + C;}
		    if ((D>=k)|( D<-k))
			{sciprint(_("overflow error"));
			 set_block_error(-4);
			 return;}
		    else y[jl]=(long)D;
		  }
	     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(l=0;l<nu2;l++)
	    {
			int j = 0;
			for(j=0;j<mu1;j++)
	        {
				double D = 0;
				int jl=j+l*mu1;
				int i = 0;
				for(i=0;i<nu1;i++)
				{
					int ji=j+i*mu1;
		    	    int il=i+l*nu1;
					double C = (double)(u1[ji])*(double)(u2[il]);
					D = D + C;
				}

				if ((D>((k/2)-1)) |(D<-((k/2))))
		        {
					sciprint(_("overflow error"));
					set_block_error(-4);
					return;
				}
				else 
				{
					y[jl]=(short)(D);
				}
		    }
		}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<nc;j++)
	{for(i=0;i<nl;i++)
		{ij=r[i]-1+(r[nl+j]-1)*mu;
		 *(yr+k)=*(ur+ij);
		 *(yi+k)=*(ui+ij);
		 k++;}}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<numb;i++)
       {n=(char)pow(2,*ipar+i);
        ref=ref+n;}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<=(mz*nz)-2; i++){
      oz[i]=oz[i+1];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<block->insz[0];i++) 
			block->outptr[0][i]=block->inptr[0][i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<numb;i++)
       {n=(short)pow(2,*ipar+i);
        ref=ref+n;}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<ny*mu;++i){
     D=(double)(opar[0])*(double)(u[i]);
     if (D>=k)  D=k-1;
     else if (D<-k) D=-k;
     y[i]=(short)D;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(l=0;l<ny;l++)
	 {for(j=0;j<my;j++)
	      {D=0;
	       jl=j+l*my;
	       for(i=0;i<mu;i++)
		   {ji=j+i*my;
		    
		    il=i+l*mu;
		    C=(double)(opar[ji])*(double)(u[il]);
		    D=D + C;}
		    if (D>=k)  D=k-1;
		    else if (D<-k) D=-k;
		    y[jl]=(short)D;
		  }
	     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++) *(y+i)=((*(u+i))&(*opar));



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < links_count; i++)
            {
                result = pushData(block, 0, i);
                if (result == FALSE)
                {
                    Coserror("%s: unable to push some data.", "cfscope");
                    break;
                }
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++)
        {
            sco->internal.coordinates[i] = (double **)CALLOC(links_count, sizeof(double *));
            if (sco->internal.coordinates[i] == NULL)
            {
                goto error_handler_coordinates_i;
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++)
        {
            for(j = 0; j < links_count; j++)
            {
                sco->internal.coordinates[i][j] = (double *)CALLOC(3 * block->ipar[2], sizeof(double));

                if (sco->internal.coordinates[i][j] == NULL)
                {
                    goto error_handler_coordinates_ij;
                }
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 0; k < i; k++)
    {
        for(l = 0; l < j; l++)
        {
            FREE(sco->internal.coordinates[k][l]);
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < i; j++)
    {
        FREE(sco->internal.coordinates[i]);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++)
        {
            for(j = 0; j < links_count; j++)
            {
                FREE(sco->internal.coordinates[i][j]);
            }
            FREE(sco->internal.coordinates[i]);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < links_count; i++)
        {
            FREE(sco->scope.cachedPolylinesUIDs[i]);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++)
    {
        for(j = 0; j < links_count; j++)
        {
            ptr = (double *)REALLOC(sco->internal.coordinates[i][j], 3 * numberOfPoints * sizeof(double));
            if (ptr == NULL)
            {
                goto error_handler;
            }

            // clear the last points, the Z-axis values
            memset(ptr + 2 * numberOfPoints, 0, numberOfPoints * sizeof(double));

            // memcpy existing Y-axis values (use memmove to handle memory overlapping)
            memmove(ptr + numberOfPoints, ptr + previousNumberOfPoints, previousNumberOfPoints * sizeof(double));

            // then set the last points to the last values for Y-axis and X-axis values
            for(setLen = newPoints - 1; setLen >= 0; setLen--)
            {
                ptr[numberOfPoints + previousNumberOfPoints + setLen] = ptr[numberOfPoints + previousNumberOfPoints - 1];
            }
            for(setLen = newPoints - 1; setLen >= 0; setLen--)
            {
                ptr[previousNumberOfPoints + setLen] = ptr[previousNumberOfPoints - 1];
            }

            sco->internal.coordinates[i][j] = ptr;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < links_count; i++)
        {
            // X-axis values first
            for(setLen = maxNumberOfPoints - numberOfPoints - 1; setLen >= 0; setLen--)
            {
                sco->internal.coordinates[input][i][numberOfPoints + setLen] = t;
            }

            // then Y-axis values
            for(setLen = maxNumberOfPoints - numberOfPoints - 1; setLen >= 0; setLen--)
            {
                sco->internal.coordinates[input][i][maxNumberOfPoints + numberOfPoints + setLen] = data[i];
            }

            // do not update Z-axis values, always cleared
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < 1; i++)
        {
            pAxe = getAxe(pFigureUID, block, i);

            


            setLabel(pAxe, __GO_X_AXIS_LABEL__, "t");
            setLabel(pAxe, __GO_Y_AXIS_LABEL__, "y");

            setGraphicObjectProperty(pAxe, __GO_X_AXIS_VISIBLE__, &i__1, jni_bool, 1);
            setGraphicObjectProperty(pAxe, __GO_Y_AXIS_VISIBLE__, &i__1, jni_bool, 1);

            setPolylinesBounds(block, i, 0);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < links_count; i++)
        {
            getPolyline(pAxe, block, i);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<ny*mu;++i){
     D=(double)(opar[0])*(double)(u[i]);
     if (D>=k)  D=k-1;
     else if (D<-k) D=-k;
     y[i]=(long)D;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(l=0;l<ny;l++)
	 {for(j=0;j<my;j++)
	      {D=0;
	       jl=j+l*my;
	       for(i=0;i<mu;i++)
		   {ji=j+i*my;
		    
		    il=i+l*mu;
		    C=(double)(opar[ji])*(double)(u[il]);
		    D=D + C;}
		    if (D>=k)  D=k-1;
		    else if (D<-k) D=-k;
		    y[jl]=(long)D;
		  }
	     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++) y[i]=((u[i])&(*opar));



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<mu*nu;i++) y[i]=u[i]>>(-ipar[0]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k=0;k<outsz[0];k++)
			*(y++)=*(u++);  



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k=0;k<outsz[0];k++)
			*(y++)=*(u++);  



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<mu*nu;i++) 
	{
		*(y1+i)=*(u1r+i);
		*(y2+i)=*(u1i+i);
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<block->outsz[0];++i) 
		{
			block->outptr[0][i]=block->rpar[block->outsz[0]+i];
		}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<block->outsz[0];++i) 
		{
			block->outptr[0][i]=block->rpar[i];
		}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<(mu*nu);i++)
		{
			ptr->LA[2*i]=ur[i];
			ptr->LA[2*i+1]=ui[i];
		}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<maxim/2;i++)
       {n=(unsigned char)pow(2,maxim/2+i);
        ref=ref+n;}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<block->insz[0];j++) {
      block->outptr[0][j]=acos(block->inptr[0][j]);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<mu*nu;i++) y[i]=u[i]>>(-ipar[0]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<ny*mu;++i){
     D=(double)(opar[0])*(double)(u[i]);
     if ((D>=k)|( D<0))
	 {sciprint(_("overflow error"));
	  set_block_error(-4);
	  return;}
     else y[i]=(unsigned long)D;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(l=0;l<ny;l++)
	 {for(j=0;j<my;j++)
	      {D=0;
		   jl=j+l*my;
	       for(i=0;i<mu;i++)
		   {ji=j+i*my;
		    
		    il=i+l*mu;
		    C=(double)(opar[ji])*(double)(u[il]);
		    D=D + C;}
		    if ((D>=k)|( D<0))
			{sciprint(_("overflow error"));
			 set_block_error(-4);
			 return;}
		    else y[jl]=(unsigned long)D;
		  }
	     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(l=0;l<nu2;l++)
	    {for(j=0;j<mu1;j++)
	        {D=0;
		    jl=j+l*mu1;
	        for(i=0;i<nu1;i++)
		   {ji=j+i*mu1;
		    
		    il=i+l*nu1;
		    C=(double)(u1[ji])*(double)(u2[il]);
		    D=D + C;}
		    t=D-(int)(D/(k))*((k));
		    y[jl]=(unsigned short)t;
		  }
	     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < block->nin; i++)
            {
                u = (double *)block->inptr[i];

                appendData(block, i, t, u);
                for(j = 0; j < block->insz[i]; j++)
                {
                    result = pushData(block, i, j);
                    if (result == FALSE)
                    {
                        Coserror("%s: unable to push some data.", "cmscope");
                        break;
                    }
                }
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < block->nin; i++)
            {
                sco = reallocHistoryBuffer(block, i, sco->internal.maxNumberOfPoints[i] + sco->internal.numberOfPoints[i]);
                sco->scope.disableBufferUpdate[i] = FALSE;
                sco->scope.historyUpdateCounter[i] = 0;
                pushHistory(block, i, sco->internal.maxNumberOfPoints[i]);
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < block->nin; i++)
        {
            // 0 points out of a block->ipar[2] points buffer
            sco->internal.numberOfPoints[i] = 0;
            // 0 points out of a 0 points history
            sco->internal.maxNumberOfPoints[i] = 0;
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < block->nin; i++)
        {
            sco->internal.bufferCoordinates[i] = (double **)CALLOC(block->insz[i], sizeof(double *));
            if (sco->internal.bufferCoordinates[i] == NULL)
            {
                goto error_handler_bufferCoordinates_i;
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < block->nin; i++)
        {
            for(j = 0; j < block->insz[i]; j++)
            {
                sco->internal.bufferCoordinates[i][j] = (double *)CALLOC(3 * block->ipar[2], sizeof(double));

                if (sco->internal.bufferCoordinates[i][j] == NULL)
                {
                    goto error_handler_bufferCoordinates_ij;
                }
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < block->nin; i++)
        {
            sco->internal.historyCoordinates[i] = (double **)CALLOC(block->insz[i], sizeof(double *));
            if (sco->internal.historyCoordinates[i] == NULL)
            {
                goto error_handler_historyCoordinates_i;
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < block->nin; i++)
        {
            sco->scope.cachedBufferPolylinesUIDs[i] = (char **)CALLOC(block->insz[i], sizeof(char *));
            sco->scope.cachedHistoryPolylinesUIDs[i] = (char **)CALLOC(block->insz[i], sizeof(char *));
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < i; j++)
    {
        FREE(sco->internal.historyCoordinates[i]);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 0; k < i; k++)
    {
        for(l = 0; l < j; l++)
        {
            FREE(sco->internal.bufferCoordinates[k][l]);
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < i; j++)
    {
        FREE(sco->internal.bufferCoordinates[i]);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < block->nin; i++)
        {
            for(j = 0; j < block->insz[i]; j++)
            {
                if (sco->internal.historyCoordinates[i][j] != NULL)
                {
                    FREE(sco->internal.historyCoordinates[i][j]);
                }
                FREE(sco->internal.bufferCoordinates[i][j]);
            }
            FREE(sco->internal.historyCoordinates[i]);
            FREE(sco->internal.bufferCoordinates[i]);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < block->nin; i++)
        {
            FREE(sco->scope.cachedHistoryPolylinesUIDs[i]);
            FREE(sco->scope.cachedBufferPolylinesUIDs[i]);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < block->insz[input]; i++)
    {
        ptr = (double *)MALLOC(3 * allocatedNumberOfPoints * sizeof(double));
        if (ptr == NULL)
        {
            goto error_handler;
        }

        // memcpy existing X-axis values from the history
        memcpy(ptr, sco->internal.historyCoordinates[input][i], previousNumberOfPoints * sizeof(double));
        // memcpy existing Y-axis values from the history
        memcpy(ptr + allocatedNumberOfPoints, sco->internal.historyCoordinates[input][i] + previousNumberOfPoints, previousNumberOfPoints * sizeof(double));
        // clear the last points, the Z-axis values
        memset(ptr + 2 * allocatedNumberOfPoints, 0, allocatedNumberOfPoints * sizeof(double));

        // then set the last points to the last values for X-axis and Y-axis values from the buffer points
        buffer = sco->internal.bufferCoordinates[input][i];
        memcpy(ptr + previousNumberOfPoints, buffer + bufferNewPointInc, (numberOfCopiedPoints - bufferNewPointInc) * sizeof(double));
        memcpy(ptr + allocatedNumberOfPoints + previousNumberOfPoints, buffer + bufferNumberOfPoints + bufferNewPointInc, (numberOfCopiedPoints - bufferNewPointInc) * sizeof(double));

        FREE(sco->internal.historyCoordinates[input][i]);
        sco->internal.historyCoordinates[input][i] = ptr;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(setLen = numberOfPoints; setLen < bufferPoints; setLen++)
    {
        coordinates[setLen] = t;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(setLen = numberOfPoints; setLen < bufferPoints; setLen++)
    {
        coordinates[bufferPoints + setLen] = value;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < block->insz[input]; i++)
        {
            sco->internal.bufferCoordinates[input][i][0] = sco->internal.bufferCoordinates[input][i][sco->internal.numberOfPoints[input] - 1];
            sco->internal.bufferCoordinates[input][i][block->ipar[2]] = sco->internal.bufferCoordinates[input][i][block->ipar[2] + sco->internal.numberOfPoints[input] - 1];
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < block->insz[input]; i++)
        {
            if (sco->internal.historyCoordinates[input][i] != NULL)
            {
                FREE(sco->internal.historyCoordinates[input][i]);
                sco->internal.historyCoordinates[input][i] = NULL;
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < block->insz[input]; i++)
        {
            sco->internal.bufferCoordinates[input][i][0] = sco->internal.bufferCoordinates[input][i][block->ipar[2] - 1];
            sco->internal.bufferCoordinates[input][i][block->ipar[2]] = sco->internal.bufferCoordinates[input][i][2 * block->ipar[2] - 1];
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < block->insz[input]; i++)
        {
            const double value = data[i];
            setBuffersCoordinates(block, input, sco->internal.bufferCoordinates[input][i], sco->internal.numberOfPoints[input], block->ipar[2], t, value);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < GetNin(block); i++)
        {
            pAxe = getAxe(pFigureUID, block, i);

            


            setLabel(pAxe, __GO_X_AXIS_LABEL__, "t");
            setLabel(pAxe, __GO_Y_AXIS_LABEL__, "y");

            setGraphicObjectProperty(pAxe, __GO_X_AXIS_VISIBLE__, &i__1, jni_bool, 1);
            setGraphicObjectProperty(pAxe, __GO_Y_AXIS_VISIBLE__, &i__1, jni_bool, 1);

            setPolylinesBounds(block, i, 0);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < block->insz[input]; i++)
        {
            getPolyline(pAxe, block, input, i, TRUE);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < block->insz[input]; i++)
        {
            getPolyline(pAxe, block, input, i, FALSE);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < block->nin; i++)
    {
        for(j = 0; j < block->insz[i]; j++)
        {
            pPolylineUID = sco->scope.cachedBufferPolylinesUIDs[i][j];
            deleteGraphicObject(pPolylineUID);
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < block->insz[input]; i++)
    {
        pPolylineUID = getPolyline(pAxeUID, block, input, i, TRUE);

        data = sco->internal.historyCoordinates[input][i];

        PUSH_LOG("%s: %d\n", "pushHistory", maxNumberOfPoints);
        result &= setGraphicObjectProperty(pPolylineUID, __GO_DATA_MODEL_COORDINATES__, data, jni_double_vector, maxNumberOfPoints);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<ny*mu;++i){
     D=(double)(opar[0])*(double)(u[i]);
     if ((D>=k)|( D<-k))
	{sciprint(_("overflow error"));
	 set_block_error(-4);
	 return;}
    else y[i]=(short)D;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(l=0;l<ny;l++)
	 {for(j=0;j<my;j++)
	      {D=0;
	       jl=j+l*my;
	       for(i=0;i<mu;i++)
		   {ji=j+i*my;
		    
		    il=i+l*mu;
		    C=(double)(opar[ji])*(double)(u[il]);
		    D=D + C;}
		    if ((D>=k)|( D<-k))
			{sciprint(_("overflow error"));
			 set_block_error(-4);
			 return;}
		    else y[jl]=(short)D;
		  }
	     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<block->insz[0];j++) {
      block->outptr[0][j]=atanh(block->inptr[0][j]);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<mu*nu;i++)
	{ 
		char v = u[i];
		for(j=0;j<ipar[0];j++)
		{
			y[i]=v&k;
			if (y[i]==0)  y[i]=v<<1;
			else 
			{
				y[i]=v<<1;
				y[i]=(y[i])|(1);
			}
			v = y[i];
		}
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(l=0;l<nu2;l++)
	    {for(j=0;j<mu1;j++)
	        {D=0;
	         jl=j+l*mu1;
	        for(i=0;i<nu1;i++)
		   {ji=j+i*mu1;
		   
		    il=i+l*nu1;
		    C=(double)(u1[ji])*(double)(u2[il]);
		    D=D + C;}
		    if ((D)>((k/2)-1))
		        {y[jl]=(char)((k/2)-1);}
		    else if ((D)<-((k/2)))
			{y[jl]=-(char)((k/2));}
		    else {y[jl]=(char)(D);}
		    }
		 }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<block->nipar;++i){
      j=block->ipar[i]-1;
      if(j<0) j=0;
      if(j>=block->insz[0]) j=block->insz[0]-1;
      block->outptr[0][i]=block->inptr[0][j];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<(mu*nu);i++)   { ptr->dwork[i]=u[i];}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<l;j++)
	{for(i=0;i<mu;i++)
	     {ij=i+j*mu;
	      if (i==j)
		{*(y2+ij)=1;}
	      else if (i>j)
		{*(y2+ij)=*(ptr->dwork+ij);}
	      else 
		{*(y2+ij)=0;}
	      }
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<nu;j++)
	{for(i=0;i<l;i++)
	     {ij=i+j*l;
	      ik=i+j*mu;
	      if (i<=j)
		{*(y1+ij)=*(ptr->dwork+ik);}
	      else
		{*(y1+ij)=0;}
	      }
 	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<*ipar;i++)
       {n=(char)pow(2,maxim-1-i);
        ref=ref+n;}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<numb;i++)
       {n=(unsigned short)pow(2,*ipar+i);
        ref=ref+n;}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < nu; j++)
        {
            int bk = 0;

            for(bk = 1; bk < GetNin(block) + 1; bk++)
            {
                int i = 0;
                int k = 0;
                int mu = GetInPortRows(block, bk);
                double *ur = GetRealInPortPtrs(block, bk);
                double *ui = GetImagInPortPtrs(block, bk);

                for(i = 0; i < mu; i++)
                {
                    int ij = i + j * mu;

                    yr[k] = ur[ij];
                    yi[k] = ui[ij];
                    k++;
                }
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<nu*mu;j++) 
			{
				v=v+(double)u[j];
			}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<nu*mu;j++) 
			{
				v=0;
				for(k=0;k<nin;k++) 
				{
					u=Getuint8InPortPtrs(block,k+1);
					if(ipar[k]>0)
					{
						v=v+(double)u[j];
					}
					else
					{
						v=v-(double)u[j];}
				}
				if ((v>=l)|(v<0)) 
				{
					sciprint(_("overflow error"));
					set_block_error(-4);
					return;
				}
				else y[j]=(unsigned char)v;
			}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<nu*mu;j++) 
			{
				y[0]=y[0]+u[j];
			}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<nu*mu;j++) 
			{
				y[j]=0.0;
				for(k=0;k<GetNin(block);k++) 
				{
					double *u=GetRealInPortPtrs(block,k+1);
					if(ipar[k]>0)
					{
						y[j]=y[j]+u[j];
					}
					else
					{
						y[j]=y[j]-u[j];
					}
				}
			}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<maxim/2;i++)
       {n=(char)pow(2,maxim/2+i);
        ref=ref+n;}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<mu*nu;i++) 
	{*(yr+i)=0;
 	 *(yi+i)=0;}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<nu;j++)
	{for(i=j;i<mu;i++)
		{ij=i+j*mu;
		 *(yr+ij)=*(ur+ij);
		 *(yi+ij)=*(ui+ij);}}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<nu*mu;i++)
	{
		yr[0] += ur[i];
		yi[0] += ui[i];
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<*nin;i++)
		{
			y= *inptr[i];
			y=SCALE*y;
			if (y<0.0)
			{
				y=-y;
				sig=-1;
			}
			else
				sig=1;
			if(y>CLIP)
				y=CLIP;
			y=y+BIAS;
			f=frexp(y,&e);
			y=64*sig-16*e- (int) (32*f)+OFFSET;
			record[i] = y;
		}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<*ipar;i++)
       {n=(short)pow(2,maxim-1-i);
        ref=ref+n;}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<nu*mu; i++)
	{
		y[0]=u[i]+y[0];
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<(mu*nu);i++)
		{
			ptr->dwork[2*i]=ur[i];
			ptr->dwork[2*i+1]=ui[i];}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<l;j++)
		{
			for(i=0;i<mu;i++)
			{
				ij=i+j*mu;
				ij1=2*ij;
				if (i==j)
				{*(y2r+ij)=1;
				*(y2i+ij)=0;}
				else if (i>j)
				{*(y2r+ij)=*(ptr->dwork+ij1);
				*(y2i+ij)=*(ptr->dwork+ij1+1);
				}
				else 
				{*(y2r+ij)=0;
				*(y2i+ij)=0;}
			}
		}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<nu;j++)
		{
			for(i=0;i<l;i++)
			{ij=i+j*l;
			ik=2*(i+j*mu);
			if (i<=j)
			{
				*(y1r+ij)=*(ptr->dwork+ik);
				*(y1i+ij)=*(ptr->dwork+ik+1);
			}
			else
			{
				*(y1r+ij)=0;
				*(y1i+ij)=0;}
			}
		}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<mu*nu;i++) y[i]=u[i]>>-ipar[0];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<=(mz*nz)-2; i++){
      oz[i]=oz[i+1];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<mu*nu;i++) y[i]=u[i]>>-ipar[0];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k=0;k<outsz[0];k++)
				*(y++)=*(u++);  



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k=0;k<outsz[0];k++)
				*(y++)=*(u++);  



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<mu*nu;i++) *(yi+i)=-(*(yi+i));



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<*ntvec;i++)
		{
			surface_matched=1;
			exist_enabled_surface=0;

			for(j=0;j<*ng;j++){
				if (rpar[(*ng+1)*i+j]!=0)
				{
					exist_enabled_surface=1;
					if((rpar[(*ng+1)*i+j]*g[j])<=0)
					{
						surface_matched=0;
					}
				}
			}

			if(( surface_matched==1)&&(exist_enabled_surface ==1))
				tvec[i]=*t+rpar[(*ng+1)*i+*ng];
			else
				tvec[i]=-1;
		}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<*ng;i++)
				g[i]=u[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i< block->insz[0];i++){
      ww=block->inptr[0][i];
      if (ww != 0.0)
	block->outptr[0][i]=1.0/ww;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i< block->insz[0];i++){
      ww=block->inptr[0][i];
      if (ww != 0.0)
	block->outptr[0][i]=1.0/ww;
      else{
	set_block_error(-2);
	return;
      }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(l=0;l<nu2;l++)
	    {for(j=0;j<mu1;j++)
	        {D=0;
		     jl=j+l*mu1;
	        for(i=0;i<nu1;i++)
		   {ji=j+i*mu1;
		   
		    il=i+l*nu1;
		    C=(double)(u1[ji])*(double)(u2[il]);
		    D=D + C;}
		    y[jl]=(char)D;
		  }
	     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<mu*nu;i++) y[i]=u[i]<<ipar[0];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<maxim/2;i++)
       {n=(long)pow(2,i);
        ref=ref+n;}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<Min(mu,nu);i++)
	{ii=i+i*mu;
	 *(y2+ii)=*(ptr->LSV+i);}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<nu;j++)
	{for(i=j;i<nu;i++)
		{ij=i+j*nu;
	 	 ji=j+i*nu;
		 *(y3+ij)=*(ptr->LVT+ji);
		 *(y3+ji)=*(ptr->LVT+ij);}
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<mu*mu;i++) *(y+i)=0;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<mu;i++)     
	{
		ii = i+i*mu;
		*(y+ii)=*(u1+i);
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<block->nx;++i) {
	if(block->mode[i]==3){
	  block->xd[i]=block->inptr[0][i];
	}else{
	  block->xd[i]=0.0;
	}
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<block->nx;++i) {
	block->xd[i]=block->inptr[0][i];
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<block->nx;++i) {
      block->outptr[0][i]=block->x[i];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<block->nx;++i) {
      block->x[i]=block->inptr[1][i];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<block->nx;++i) {
      if (block->mode[i]==3){
	block->g[i]=(block->x[i]-(block->rpar[i]))*(block->x[i]-(block->rpar[block->nx+i]));
      } else {
	block->g[i]=block->inptr[0][i];
      } 
      if (get_phase_simulation()==1) {
	if (block->inptr[0][i]>=0&&block->x[i]>=block->rpar[i]){
	  block->mode[i]=1;
	}else if (block->inptr[0][i]<=0&&block->x[i]<=block->rpar[block->nx+i]){
	  block->mode[i]=2;
	}else {
	  block->mode[i]=3;
	}
      }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
     		       	  {if (u[i]<=0)
		       	       {*y=0;
			        break;}
     		      	  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=1;i<m*n;i++)
			    {*y=(*y)&(u[i]);}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
			   {y[i]=1;
			    for(j=1;j<nin+1;j++)
				 {u=Getint8InPortPtrs(block,j);
				  if (u[i]<=0) 
				      {y[i]=0;
				       break;}
				 } 
			   }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
			   {u=Getint8InPortPtrs(block,1);
			    y[i]=u[i];
			    for(j=2;j<nin+1;j++)
				 {u=Getint8InPortPtrs(block,j);
				  y[i]=(y[i])&(u[i]);
				 }
			   }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
     		       	  {if (u[i]>0)
		       	       {*y=1;
			        break;}
     		      	  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
			    {*y=(*y)|(u[i]);}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
			   {y[i]=0;
			    for(j=1;j<nin+1;j++)
				 {u=Getint8InPortPtrs(block,j);
				  if (u[i]>0) 
				      {y[i]=1;
				       break;}
				 }
			   }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
			   {y[i]=0;
			    for(j=1;j<nin+1;j++)
				 {u=Getint8InPortPtrs(block,j);
				  y[i]=(y[i])|(u[i]);
				 }
			   }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
     		       	  {if (u[i]<=0)
		       	       {*y=1;
			        break;}
     		      	  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=1;i<m*n;i++)
			    {*y=((*y)&(u[i]));}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
			   {y[i]=0;
			    for(j=1;j<nin+1;j++)
				 {u=Getint8InPortPtrs(block,j);
				  if (u[i]<=0) 
				      {y[i]=1;
				       break;}
				 } 
			   }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
			   {u=Getint8InPortPtrs(block,1);
			    y[i]=u[i];
			    for(j=2;j<nin+1;j++)
				 {u=Getint8InPortPtrs(block,j);
				  y[i]=((y[i])&(u[i]));
				 }
			    y[i]=~y[i];
			   }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
     		       	  {if (u[i]>0)
		       	       {*y=0;
			        break;}
     		      	  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
			    {*y=((*y)|(u[i]));}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
			   {y[i]=1;
			    for(j=1;j<nin+1;j++)
				 {u=Getint8InPortPtrs(block,j);
				  if (u[i]>0) 
				      {y[i]=0;
				       break;}
				 }
			   }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
			   {u=Getint8InPortPtrs(block,1);
			    y[i]=u[i];
			    for(j=2;j<nin+1;j++)
				 {u=Getint8InPortPtrs(block,j);
				  y[i]=((y[i])|(u[i]));
				 }
			    y[i]=~y[i];
			   }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
     		       	  {if (u[i]>0)
		       	       {l=(l+1)%2;
			       }
     		      	  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=1;i<m*n;i++)
			    {*y=((*y)^(u[i]));}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
			   {l=0;
			    for(j=1;j<nin+1;j++)
				 {u=Getint8InPortPtrs(block,j);
				  if (u[i]>0) 
				      {l=(l+1)%2;}
				 }
			    y[i]=(char)l;
			   }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
		           {u=Getint8InPortPtrs(block,1);
		           y[i]=u[i];
			   for(j=2;j<nin+1;j++)
				 {u=Getint8InPortPtrs(block,j);
				  y[i]=((y[i])^(u[i]));
				 }
			   }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
		       {if (u[i]>0) y[i]=0;
			else y[i]=1;}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
		       {y[i]=~(u[i]);}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<nu*mu;j++) 
			{
				v=v+(double)u[j];
			}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<nu*mu;j++) 
			{
				v=0;
				for(k=0;k<nin;k++) 
				{
					u=Getint8InPortPtrs(block,k+1);
					if(ipar[k]>0)
					{
						v=v+(double)u[j];
					}
					else
					{
						v=v-(double)u[j];
					}
				}
				if ((v>=l)|(v<-l)) 
				{
					sciprint(_("overflow error"));
					set_block_error(-4);
					return;
				}
				else y[j]=(char)v;
			}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < block->insz[0]; j++)
            {
                result = pushData(block, j);
                if (result == FALSE)
                {
                    Coserror("%s: unable to push some data.", "cscopxy3d");
                    break;
                }
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < block->insz[0]; i++)
        {
            sco->internal.coordinates[i] = (double *)CALLOC(3 * block->ipar[2], sizeof(double));

            if (sco->internal.coordinates[i] == NULL)
            {
                goto error_handler_coordinates_i;
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < i; j++)
    {
        FREE(sco->internal.coordinates[i]);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < block->insz[0]; i++)
        {
            FREE(sco->internal.coordinates[i]);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < block->insz[0]; i++)
        {
            FREE(sco->scope.cachedPolylinesUIDs[i]);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < block->insz[0]; i++)
    {
        ptr = (double *)REALLOC(sco->internal.coordinates[i], 3 * numberOfPoints * sizeof(double));
        if (ptr == NULL)
        {
            goto error_handler;
        }

        // memcpy existing Z-axis values (use memmove to handle memory overlapping)
        memmove(ptr + 2 * numberOfPoints, ptr + 2 * previousNumberOfPoints, previousNumberOfPoints * sizeof(double));

        // memcpy existing Y-axis values (use memmove to handle memory overlapping)
        memmove(ptr + numberOfPoints, ptr + previousNumberOfPoints, previousNumberOfPoints * sizeof(double));

        // then set the last points to the last values for Z-axis, Y-axis and X-axis values
        for(setLen = newPoints - 1; setLen >= 0; setLen--)
        {
            ptr[2 * numberOfPoints + previousNumberOfPoints + setLen] = ptr[2 * numberOfPoints + previousNumberOfPoints - 1];
        }
        for(setLen = newPoints - 1; setLen >= 0; setLen--)
        {
            ptr[numberOfPoints + previousNumberOfPoints + setLen] = ptr[numberOfPoints + previousNumberOfPoints - 1];
        }
        for(setLen = newPoints - 1; setLen >= 0; setLen--)
        {
            ptr[previousNumberOfPoints + setLen] = ptr[previousNumberOfPoints - 1];
        }

        sco->internal.coordinates[i] = ptr;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < block->insz[0]; i++)
        {

            for(setLen = maxNumberOfPoints - numberOfPoints - 1; setLen >= 0; setLen--)
            {
                sco->internal.coordinates[i][numberOfPoints + setLen] = x[i];
            }

            for(setLen = maxNumberOfPoints - numberOfPoints - 1; setLen >= 0; setLen--)
            {
                sco->internal.coordinates[i][maxNumberOfPoints + numberOfPoints + setLen] = y[i];
            }

            for(setLen = maxNumberOfPoints - numberOfPoints - 1; setLen >= 0; setLen--)
            {
                sco->internal.coordinates[i][2 * maxNumberOfPoints + numberOfPoints + setLen] = z[i];
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < block->insz[0]; i++)
        {
            getPolyline(pAxe, block, i);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<mu*nu;i++)
	{
		v=u[i];
		for(j=0;j<-ipar[0];j++)
		{
			y[i]=v&1;
			if (y[i]==0)  
			{
				y[i]=v>>1;
				y[i]=y[i]&(k-1);}
			else 
			{
				y[i]=v>>1;
				y[i]=(y[i])|(k);
			}
			v=y[i];
		}
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<(mu*nu);i++)
		{
			ptr->LA[2*i]=ur[i];
			ptr->LA[2*i+1]=ui[i];}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<Min(mu,nu);i++)
		{
			ii=i+i*mu;
			*(y2r+ii)=*(ptr->LSV+i);}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<nu;j++)
		{
			for(i=j;i<nu;i++)
			{
				ij=i+j*nu;
				ji=j+i*nu;
				*(y3r+ij)=*(ptr->LVT+2*ji);
				*(y3r+ji)=*(ptr->LVT+2*ij);
				*(y3i+ij)=-(*(ptr->LVT+2*ji+1));
				*(y3i+ji)=-(*(ptr->LVT+2*ij+1));
			}
		}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<mu*mu;i++)
		{
			*(y1r+i)=*(ptr->LU+2*i);
			*(y1i+i)=*(ptr->LU+2*i+1);
		}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<nu1;i++)    *(ptr->jpvt+i)=0;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<nu*mu;j++) 
			{
				y[0]=y[0]+u[j];
			}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<nu*mu;j++) 
			{
				y[j]=0;
				for(k=0;k<nin;k++) 
				{
					u=Getint32InPortPtrs(block,k+1);
					if(ipar[k]>0)
					{
						y[j]=y[j]+u[j];
					}
					else
					{
						y[j]=y[j]-u[j];}
				}
			}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<ny*mu;++i){
     D=(double)(opar[0])*(double)(u[i]);
     t=D-(double)((int)(D/(k)))*((k));
     if ((t>=k/2)|(-(t)>=k/2))
       {if (t>=0) (t)=(-((k/2))+fabs(t-(double)((int)((t)/((k/2))))*((k/2))));
	else (t)=-(-((k/2))+fabs(t-(double)((int)((t)/((k/2))))*((k/2))));}
     y[i]=(unsigned char)t;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(l=0;l<ny;l++)
	 {for(j=0;j<my;j++)
	      {D=0;
		   jl=j+l*my;
	       for(i=0;i<mu;i++)
		   {ji=j+i*my;
		    
		    il=i+l*mu;
		    C=(double)(opar[ji])*(double)(u[il]);
		    D=D + C;}
		    t=D-(double)((int)(D/(k)))*((k));
		    if ((t>=k/2)|(-(t)>=k/2))
		       {if (t>=0) (t)=(-((k/2))+fabs(t-(double)((int)((t)/((k/2))))*((k/2))));
			else (t)=-(-((k/2))+fabs(t-(double)((int)((t)/((k/2))))*((k/2))));}
		    y[jl]=(unsigned char)t;
		  }
	     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<nu*mu;j++) 
			{
				y[0]=y[0]+u[j];
			}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<nu*mu;j++) 
			{
				y[j]=0;
				for(k=0;k<nin;k++) 
				{
					u=Getuint16InPortPtrs(block,k+1);
					if(ipar[k]>0)
					{
						y[j]=y[j]+u[j];
					}
					else
					{
						y[j]=y[j]-u[j];
					}
				}
			}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<ny*mu;++i){
     D=(double)(opar[0])*(double)(u[i]);
     t=D-(double)((int)(D/(k)))*((k));
     if ((t>=k/2)|(-(t)>=k/2))
         {if (t>=0) (t)=(-((k/2))+fabs(t-(double)((int)((t)/((k/2))))*((k/2))));
	  else (t)=-(-((k/2))+fabs(t-(double)((int)((t)/((k/2))))*((k/2))));}
     y[i]=(long)t;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(l=0;l<ny;l++)
	 {for(j=0;j<my;j++)
	      {D=0;
	       jl=j+l*my;
	       for(i=0;i<mu;i++)
		   {ji=j+i*my;
		    
		    il=i+l*mu;
		    C=(double)(opar[ji])*(double)(u[il]);
		    D=D + C;}
		    t=D-(double)((int)(D/(k)))*((k));
		    if ((t>=k/2)|(-(t)>=k/2))
		       {if (t>=0) (t)=(-((k/2))+fabs(t-(double)((int)((t)/((k/2))))*((k/2))));
			else (t)=-(-((k/2))+fabs(t-(double)((int)((t)/((k/2))))*((k/2))));}
		    y[jl]=(long)t;
		  }
	     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
     		       	  {if (u[i]<=0)
		       	       {*y=0;
			        break;}
     		      	  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=1;i<m*n;i++)
			    {*y=(*y)&(u[i]);}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
			   {y[i]=1;
			    for(j=1;j<nin+1;j++)
				 {u=Getuint32InPortPtrs(block,j);
				  if (u[i]<=0) 
				      {y[i]=0;
				       break;}
				 } 
			   }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
			   {u=Getuint32InPortPtrs(block,1);
			    y[i]=u[i];
			    for(j=2;j<nin+1;j++)
				 {u=Getuint32InPortPtrs(block,j);
				  y[i]=(y[i])&(u[i]);
				 }
			   }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
     		       	  {if (u[i]>0)
		       	       {*y=1;
			        break;}
     		      	  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
			    {*y=(*y)|(u[i]);}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
			   {y[i]=0;
			    for(j=1;j<nin+1;j++)
				 {u=Getuint32InPortPtrs(block,j);
				  if (u[i]>0) 
				      {y[i]=1;
				       break;}
				 }
			   }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
			   {y[i]=0;
			    for(j=1;j<nin+1;j++)
				 {u=Getuint32InPortPtrs(block,j);
				  y[i]=(y[i])|(u[i]);
				 }
			   }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
     		       	  {if (u[i]<=0)
		       	       {*y=1;
			        break;}
     		      	  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=1;i<m*n;i++)
			    {*y=((*y)&(u[i]));}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
			   {y[i]=0;
			    for(j=1;j<nin+1;j++)
				 {u=Getuint32InPortPtrs(block,j);
				  if (u[i]<=0) 
				      {y[i]=1;
				       break;}
				 } 
			   }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
			   {u=Getuint32InPortPtrs(block,1);
			    y[i]=u[i];
			    for(j=2;j<nin+1;j++)
				 {u=Getuint32InPortPtrs(block,j);
				  y[i]=((y[i])&(u[i]));
				 }
			    y[i]=~y[i];
			   }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
     		       	  {if (u[i]>0)
		       	       {*y=0;
			        break;}
     		      	  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
			    {*y=((*y)|(u[i]));}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
			   {y[i]=1;
			    for(j=1;j<nin+1;j++)
				 {u=Getuint32InPortPtrs(block,j);
				  if (u[i]>0) 
				      {y[i]=0;
				       break;}
				 }
			   }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
			   {u=Getuint32InPortPtrs(block,1);
			    y[i]=u[i];
			    for(j=2;j<nin+1;j++)
				 {u=Getuint32InPortPtrs(block,j);
				  y[i]=((y[i])|(u[i]));
				 }
			    y[i]=~y[i];
			   }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
     		       	  {if (u[i]>0)
		       	       {l=(l+1)%2;
			       }
     		      	  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=1;i<m*n;i++)
			    {*y=((*y)^(u[i]));}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
			   {l=0;
			    for(j=1;j<nin+1;j++)
				 {u=Getuint32InPortPtrs(block,j);
				  if (u[i]>0) 
				      {l=(l+1)%2;}
				 }
			    y[i]=(unsigned long)l;
			   }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
		           {u=Getuint32InPortPtrs(block,1);
		           y[i]=u[i];
			   for(j=2;j<nin+1;j++)
				 {u=Getuint32InPortPtrs(block,j);
				  y[i]=((y[i])^(u[i]));
				 }
			   }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
		       {if (u[i]>0) y[i]=0;
			else y[i]=1;}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
		       {y[i]=~(u[i]);}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<insz[0];i++)
			record[i] = *(inptr[0]+i);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=2;i>=0;i--)
				if (type[i]!=' ') { type[i+1]='\0';break;}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=2;i>=0;i--)
				if (type[i]!=' ') { type[i+1]='\0';break;}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<nu;j++)
			{
				for(i=0;i<nin;i++)
				{
					u = GetInPortPtrs(block,i+1);
					mu = GetInPortRows(block,i+1);
					so = GetSizeOfIn(block,i+1);
					memcpy((char*)y+pointerposition,(char *)u+j*mu*so,mu*so);
					pointerposition = pointerposition + mu * so;
				}
			}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
     		       	  {if (u[i]<=0)
		       	       {*y=0;
			        break;}
     		      	  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=1;i<m*n;i++)
			    {*y=(*y)&(u[i]);}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
			   {y[i]=1;
			    for(j=1;j<nin+1;j++)
				 {u=Getuint8InPortPtrs(block,j);
				  if (u[i]<=0) 
				      {y[i]=0;
				       break;}
				 } 
			   }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
			   {u=Getuint8InPortPtrs(block,1);
			    y[i]=u[i];
			    for(j=2;j<nin+1;j++)
				 {u=Getuint8InPortPtrs(block,j);
				  y[i]=(y[i])&(u[i]);
				 }
			   }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
     		       	  {if (u[i]>0)
		       	       {*y=1;
			        break;}
     		      	  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
			    {*y=(*y)|(u[i]);}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
			   {y[i]=0;
			    for(j=1;j<nin+1;j++)
				 {u=Getuint8InPortPtrs(block,j);
				  if (u[i]>0) 
				      {y[i]=1;
				       break;}
				 }
			   }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
			   {y[i]=0;
			    for(j=1;j<nin+1;j++)
				 {u=Getuint8InPortPtrs(block,j);
				  y[i]=(y[i])|(u[i]);
				 }
			   }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
     		       	  {if (u[i]<=0)
		       	       {*y=1;
			        break;}
     		      	  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=1;i<m*n;i++)
			    {*y=((*y)&(u[i]));}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
			   {y[i]=0;
			    for(j=1;j<nin+1;j++)
				 {u=Getuint8InPortPtrs(block,j);
				  if (u[i]<=0) 
				      {y[i]=1;
				       break;}
				 } 
			   }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
			   {u=Getuint8InPortPtrs(block,1);
			    y[i]=u[i];
			    for(j=2;j<nin+1;j++)
				 {u=Getuint8InPortPtrs(block,j);
				  y[i]=((y[i])&(u[i]));
				 }
			    y[i]=~y[i];
			   }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
     		       	  {if (u[i]>0)
		       	       {*y=0;
			        break;}
     		      	  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
			    {*y=((*y)|(u[i]));}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
			   {y[i]=1;
			    for(j=1;j<nin+1;j++)
				 {u=Getuint8InPortPtrs(block,j);
				  if (u[i]>0) 
				      {y[i]=0;
				       break;}
				 }
			   }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
			   {u=Getuint8InPortPtrs(block,1);
			    y[i]=u[i];
			    for(j=2;j<nin+1;j++)
				 {u=Getuint8InPortPtrs(block,j);
				  y[i]=((y[i])|(u[i]));
				 }
			    y[i]=~y[i];
			   }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
     		       	  {if (u[i]>0)
		       	       {l=(l+1)%2;
			       }
     		      	  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=1;i<m*n;i++)
			    {*y=((*y)^(u[i]));}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
			   {l=0;
			    for(j=1;j<nin+1;j++)
				 {u=Getuint8InPortPtrs(block,j);
				  if (u[i]>0) 
				      {l=(l+1)%2;}
				 }
			    y[i]=(unsigned char)l;
			   }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
		           {u=Getuint8InPortPtrs(block,1);
		           y[i]=u[i];
			   for(j=2;j<nin+1;j++)
				 {u=Getuint8InPortPtrs(block,j);
				  y[i]=((y[i])^(u[i]));
				 }
			   }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
		       {if (u[i]>0) y[i]=0;
			else y[i]=1;}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
		       {y[i]=~(u[i]);}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<=(mz*nz)-2; i++){
      oz[i]=oz[i+1];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<block->insz[0];j++) 
		{
			block->outptr[0][j]=sin(block->inptr[0][j]);
		}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<nu*mu;j++) 
			{
				v=v+(double)u[j];
			}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<nu*mu;j++) 
			{
				v=0;
				for(k=0;k<nin;k++) 
				{
					u=Getint8InPortPtrs(block,k+1);
					if(ipar[k]>0)
					{
						v=v+(double)u[j];
					}
					else
					{
						v=v-(double)u[j];
					}
				}
				if (v>=l)  v=l-1;
				else if (v<-l) v=-l;
				y[j]=(char)v;
			}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < block->insz[0]; j++)
            {
                result = pushData(block, j);
                if (result == FALSE)
                {
                    Coserror("%s: unable to push some data.", "cscopxy");
                    break;
                }
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < block->insz[0]; i++)
        {
            sco->internal.coordinates[i] = (double *)CALLOC(3 * block->ipar[2], sizeof(double));

            if (sco->internal.coordinates[i] == NULL)
            {
                goto error_handler_coordinates_i;
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < i; j++)
    {
        FREE(sco->internal.coordinates[i]);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < block->insz[0]; i++)
        {
            FREE(sco->internal.coordinates[i]);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < block->insz[0]; i++)
        {
            FREE(sco->scope.cachedPolylinesUIDs[i]);
            sco->scope.cachedPolylinesUIDs[i] = NULL;
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < block->insz[0]; i++)
        {
            memmove(sco->internal.coordinates[i], sco->internal.coordinates[i] + 1, setLen * sizeof(double));
            sco->internal.coordinates[i][setLen] = x[i];

            memmove(sco->internal.coordinates[i] + maxNumberOfPoints, sco->internal.coordinates[i] + maxNumberOfPoints + 1, setLen * sizeof(double));
            sco->internal.coordinates[i][maxNumberOfPoints + setLen] = y[i];
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < block->insz[0]; i++)
        {
            for(setLen = maxNumberOfPoints - numberOfPoints - 1; setLen >= 0; setLen--)
            {
                sco->internal.coordinates[i][numberOfPoints + setLen] = x[i];
            }

            for(setLen = maxNumberOfPoints - numberOfPoints - 1; setLen >= 0; setLen--)
            {
                sco->internal.coordinates[i][maxNumberOfPoints + numberOfPoints + setLen] = y[i];
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < block->insz[0]; i++)
        {
            getPolyline(pAxe, block, i);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<nu;j++)
	{for(i=j;i<nu;i++)
		{ij=i+j*nu;
		 ji=j+i*nu;
		if (i!=j)
			{if (*(ptr->LA+ij)==*(ptr->LA+ji)) symmetric*= 1;
			 else { symmetric*=0;break;}}}}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<nu;i++)
	{ii=i+i*nu;
	 *(y1+ii)=*(ptr->LW+i);
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<nu;i++)
		{ii=i+i*nu;
		*(y1+ii)=*(ptr->LWR+i);
		*(y2+ii)=*(ptr->LWI+i);
		}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<nu;j++)
		{if (*(ptr->LWI+j)==0)
			for(i=0;i<nu;i++)
				{ij=i+(j)*nu;
				 *(y3+ij)=*(ptr->LVR +ij);
				 *(y4+ij)=0;}
		else{
			for(i=0;i<nu;i++)
					{ij=i+(j)*nu;
					 ij1=i+(j+1)*nu;
					 *(y3+ij)=*(ptr->LVR +ij);
					 *(y4+ij)=*(ptr->LVR +ij1);
					 *(y3+ij1)=*(ptr->LVR +ij);
					 *(y4+ij1)=-(*(ptr->LVR +ij1));}
			j++;}
		}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<nu*mu;j++) 
			{
				y[0]=y[0]+u[j];
			}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<nu*mu;j++) 
			{
				y[j]=0;
				for(k=0;k<nin;k++) 
				{
					u=Getuint32InPortPtrs(block,k+1);
					if(ipar[k]>0)
					{
						y[j]=y[j]+u[j];
					}
					else
					{
						y[j]=y[j]-u[j];}
				}
			}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<mu;j++)
		{
			int k=j;
			int bk = 0;
			for(bk=1;bk<GetNin(block)+1;bk++) 
			{
				double *ur=GetRealInPortPtrs(block,bk);
				double *ui=GetImagInPortPtrs(block,bk);
				int nu = GetInPortCols(block,bk);
				int i = 0;
				for(i=0;i<nu;i++)
				{
					int ij=j+i*mu;
					yr[k]=ur[ij];
					yi[k]=ui[ij];
					k+= mu;
				}
			}
		}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++) *(y+i)=(unsigned char)block->mode[i]-1;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++) y[i]=0;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
				{
					if (u1[i]==u2[i]) y[i]=1;
				}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
				{
					if (u1[i]!=u2[i]) y[i]=1;
				}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
				{
					if (u1[i]<u2[i]) y[i]=1;
				}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
				{
					if (u1[i]<=u2[i]) y[i]=1;
				}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
				{
					if (u1[i]>u2[i]) y[i]=1;
				}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
				{
					if (u1[i]>=u2[i]) y[i]=1;
				}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++) block->g[i]=*(u1+i)-*(u2+i);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++) block->mode[i]=(int)1;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
				{
					if (u1[i]==u2[i]) block->mode[i]=(int)2;
				}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
				{
					if (u1[i]!=u2[i]) block->mode[i]=(int)2;
				}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
				{
					if (u1[i]<u2[i]) block->mode[i]=(int)2;
				}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
				{
					if (u1[i]<=u2[i]) block->mode[i]=(int)2;
				}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
				{
					if (u1[i]>u2[i]) block->mode[i]=(int)2;
				}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
				{
					if (u1[i]>=u2[i]) block->mode[i]=(int)2;
				}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=1;j<mu*nu;j++)
  {
	  yr[j]=ur[j]+yr[j-1];
      yi[j]=ui[j]+yi[j-1];
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<nu*mu;j++) 
			{
				v=v+(double)u[j];
			}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<nu*mu;j++) 
			{
				v=0;
				for(k=0;k<nin;k++) 
				{
					u=Getint32InPortPtrs(block,k+1);
					if(ipar[k]>0)
					{
						v=v+(double)u[j];
					}
					else
					{
						v=v-(double)u[j];}
				}
				if ((v>=l)|(v<-l)) 
				{
					sciprint(_("overflow error"));
					set_block_error(-4);
					return;}
				else y[j]=(long)v;
			}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<nPoints;i++){
		if (rpar[i]>=0 ) {
		  ind[0]=i-1;
		  ind[1]=i;
		  break;
		}
	      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=ind[0];i<nPoints;i++){		
		if (i==-1) continue;
		if (t<rpar[i]) {
		  inow=i-1;
		  if (inow<ind[1]){
		    ind[1]=inow;
		  }else{
		    ind[0]=ind[1];
		    ind[1]=inow;
		  }
		  break;
		}
	      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<=(mz*nz)-2; i++){
      oz[i]=oz[i+1];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nclk; i++)
            {
                mask = 1 << i;
                if ((block->nevprt & mask) == mask)
                {
                    appendData(block, i, t);

                    result = pushData(block, i);
                    if (result == FALSE)
                    {
                        Coserror("%s: unable to push some data.", "cevscpe");
                        break;
                    }
                }
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nclk; i++)
        {
            sco->internal.maxNumberOfPoints[i] = DEFAULT_MAX_NUMBER_OF_POINTS;
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nclk; i++)
        {
            


            sco->internal.data[2 * i + 0] = (double *)CALLOC(3 * DEFAULT_MAX_NUMBER_OF_POINTS, sizeof(double));
            if (sco->internal.data[2 * i + 0] == NULL)
                goto error_handler_data_i;

            


            sco->internal.data[2 * i + 1] = (double *)CALLOC(3 * DEFAULT_MAX_NUMBER_OF_POINTS, sizeof(double));
            if (sco->internal.data[2 * i + 1] == NULL)
            {
                FREE(sco->internal.data[2 * i + 0]);
                goto error_handler_data_i;
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < i; j++)
    {
        FREE(sco->internal.data[2 * j + 0]);
        FREE(sco->internal.data[2 * j + 1]);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nclk; i++)
        {
            FREE(sco->internal.data[i]);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nclk; i++)
        {
            FREE(sco->scope.cachedSegsUIDs[i]);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(setLen = numberOfPoints - previousNumberOfPoints - 1; setLen >= 0; setLen--)
    {
        ptr[3 * (previousNumberOfPoints + setLen) + 0] = ptr[3 * (previousNumberOfPoints - 1) + 0];
        ptr[3 * (previousNumberOfPoints + setLen) + 1] = ptr[3 * (previousNumberOfPoints - 1) + 1];
        ptr[3 * (previousNumberOfPoints + setLen) + 2] = ptr[3 * (previousNumberOfPoints - 1) + 2];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(setLen = numberOfPoints - previousNumberOfPoints - 1; setLen >= 0; setLen--)
    {
        ptr[3 * (previousNumberOfPoints + setLen) + 0] = ptr[3 * (previousNumberOfPoints - 1) + 0];
        ptr[3 * (previousNumberOfPoints + setLen) + 1] = ptr[3 * (previousNumberOfPoints - 1) + 1];
        ptr[3 * (previousNumberOfPoints + setLen) + 2] = ptr[3 * (previousNumberOfPoints - 1) + 2];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nclk; i++)
        {
            sco->internal.numberOfPoints[i] = 0;
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(setLen = maxNumberOfPoints - numberOfPoints - 1; setLen >= 0; setLen--)
        {
            sco->internal.data[2 * input + 0][3 * (numberOfPoints + setLen) + 0] = t;   // x
            sco->internal.data[2 * input + 0][3 * (numberOfPoints + setLen) + 1] = 0;   // y
            sco->internal.data[2 * input + 0][3 * (numberOfPoints + setLen) + 2] = (double) input;   // z
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(setLen = maxNumberOfPoints - numberOfPoints - 1; setLen >= 0; setLen--)
        {
            sco->internal.data[2 * input + 1][3 * (numberOfPoints + setLen) + 0] = t;   // x
            sco->internal.data[2 * input + 1][3 * (numberOfPoints + setLen) + 1] = 0.8; // y
            sco->internal.data[2 * input + 1][3 * (numberOfPoints + setLen) + 2] = (double) input;   // z
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nclk; i++)
        {
            getSegs(pAxe, block, i);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nclk; i++)
    {
        pSegsUID = getSegs(pAxeUID, block, i);
        result &= setGraphicObjectProperty(pSegsUID, __GO_NUMBER_ARROWS__, &maxNumberOfPoints, jni_int, 1);

        



        color = block->ipar[2 + i];
        if (color > 0)
        {
            setGraphicObjectProperty(pSegsUID, __GO_SEGS_COLORS__, &color, jni_int_vector, 1);
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<nu*mu;j++) 
			{
				y[0]=y[0]+u[j];
			}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<nu*mu;j++) 
			{
				y[j]=0;
				for(k=0;k<nin;k++) 
				{
					short *u=Getint16InPortPtrs(block,k+1);
					if(ipar[k]>0)
					{
						y[j]=y[j]+u[j];
					}
					else
					{
						y[j]=y[j]-u[j];}
				}
			}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<ny*mu;++i){
     D=(double)(opar[0])*(double)(u[i]);
     if (D>=k)  D=k-1;
     else if (D<0) D=0;
     y[i]=(unsigned long)D;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(l=0;l<ny;l++)
	 {for(j=0;j<my;j++)
	      {D=0;
		   jl=j+l*my;
	       for(i=0;i<mu;i++)
		   {ji=j+i*my;
		    
		    il=i+l*mu;
		    C=(double)(opar[ji])*(double)(u[il]);
		    D=D + C;}
		    if (D>=k)  D=k-1;
		    else if (D<0) D=0;
		    y[jl]=(unsigned long)D;
		  }
	     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0 ; i <  *nu ; ++i ) 
  {
	  y[i] = Abs(u[i]);
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<nu*mu;j++) 
			{
				y[0]=y[0]+u[j];
			}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<nu*mu;j++) 
			{
				y[j]=0;
				for(k=0;k<nin;k++) 
				{
					u=Getint8InPortPtrs(block,k+1);
					if(ipar[k]>0)
					{
						y[j]=y[j]+u[j];
					}
					else
					{
						y[j]=y[j]-u[j];}
				}
			}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++) *(y+i)=block->mode[i]-1;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++) y[i]=0;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
				{
					if (u1[i]==u2[i]) y[i]=1;
				}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
				{
					if (u1[i]!=u2[i]) y[i]=1;
				}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
				{
					if (u1[i]<u2[i]) y[i]=1;
				}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
				{
					if (u1[i]<=u2[i]) y[i]=1;
				}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
				{
					if (u1[i]>u2[i]) y[i]=1;
				}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
				{
					if (u1[i]>=u2[i]) y[i]=1;
				}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++) block->g[i]=*(u1+i)-*(u2+i);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++) block->mode[i]=(int)1;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
				{
					if (u1[i]==u2[i]) block->mode[i]=(int)2;
				}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
				{
					if (u1[i]!=u2[i]) block->mode[i]=(int)2;
				}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
				{
					if (u1[i]<u2[i]) block->mode[i]=(int)2;
				}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
				{
					if (u1[i]<=u2[i]) block->mode[i]=(int)2;
				}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
				{
					if (u1[i]>u2[i]) block->mode[i]=(int)2;
				}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
				{
					if (u1[i]>=u2[i]) block->mode[i]=(int)2;
				}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(l=0;l<nu2;l++)
	    {
			int j = 0;
			for(j=0;j<mu1;j++)
	        {
				double D = 0.;
				int i = 0;
				int jl = j + l * mu1;

				for(i=0;i<nu1;i++)
				{
					int ji = j + i*mu1;
		    	    int il = i + l*nu1;
					double C = (double)(u1[ji])*(double)(u2[il]);
					D = D + C;
				}

				if ((D>((k/2)-1)) |(D<-((k/2))))
		        {
					sciprint(_("overflow error"));
					set_block_error(-4);
					return;
				}
				else 
				{
					y[jl]=(long)(D);
				}
		    }
		}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<block->insz[0];j++) {
      block->outptr[0][j]=atan(block->inptr[0][j]);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<maxim/2;i++)
       {n=(short)pow(2,maxim/2+i);
        ref=ref+n;}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<=nz-2; i++){
      z[i]=z[i+1];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
    {
        int k = 0;

        y[i] = 1.0;

        for(k = 0; k < *nin; k++)
        {
            double *u = (double *)inptr[k];
            y[i] = y[i] * u[i];
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<ny*mu;++i){
     D=(double)(opar[0])*(double)(u[i]);
     if (D>=k)  D=k-1;
     else if (D<0) D=0;
     y[i]=(unsigned short)D;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(l=0;l<ny;l++)
	 {for(j=0;j<my;j++)
	      {D=0;
		   jl=j+l*my;
	       for(i=0;i<mu;i++)
		   {ji=j+i*my;
		    
		    il=i+l*mu;
		    C=(double)(opar[ji])*(double)(u[il]);
		    D=D + C;}
		    if (D>=k)  D=k-1;
		    else if (D<0) D=0;
		    y[jl]=(unsigned short)D;
		  }
	     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<n;i++) 
	{
		int k = 0;
		y[i] = 0.0;
		for(k = 0;k < *nin; k++) 
		{
			double *u = (double *)inptr[k];
			y[i]=y[i]+u[i];
		}
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<ny*mu;++i){
     D=(double)(opar[0])*(double)(u[i]);
     t=D-(double)((int)(D/(k)))*((k));
     if ((t>=k/2)|(-(t)>=k/2))
       	 {if (t>=0) (t)=(-((k/2))+fabs(t-(double)((int)((t)/((k/2))))*((k/2))));
	  else (t)=-(-((k/2))+fabs(t-(double)((int)((t)/((k/2))))*((k/2))));}
     y[i]=(unsigned long)t;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(l=0;l<ny;l++)
	 {for(j=0;j<my;j++)
	      {D=0;
		   jl=j+l*my;
	       for(i=0;i<mu;i++)
		   {ji=j+i*my;
		    
		    il=i+l*mu;
		    C=(double)(opar[ji])*(double)(u[il]);
		    D=D + C;}
		    t=D-(double)((int)(D/(k)))*((k));
		    if ((t>=k/2)|(-(t)>=k/2))
		       {if (t>=0) (t)=(-((k/2))+fabs(t-(double)((int)((t)/((k/2))))*((k/2))));
			else (t)=-(-((k/2))+fabs(t-(double)((int)((t)/((k/2))))*((k/2))));}
		    y[jl]=(unsigned long)t;
		  }
	     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k=0;k<outsz[0];k++)
			*(y++)=*(u++);  



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k=0;k<outsz[0];k++)
			*(y++)=*(u++);  



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<nu*mu;j++) 
			{
				v=v+(double)u[j];
			}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<nu*mu;j++) 
			{
				v=0;
				for(k=0;k<nin;k++) 
				{
					u=Getuint32InPortPtrs(block,k+1);
					if(ipar[k]>0)
					{
						v=v+(double)u[j];
					}
					else
					{
						v=v-(double)u[j];}
				}
				if ((v>=l)|(v<0)) 
				{
					sciprint(_("overflow error"));
					set_block_error(-4);
					return;
				}
				else y[j]=(unsigned long)v;
			}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<maxim/2;i++)
       {n=(long)pow(2,maxim/2+i);
        ref=ref+n;}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<block->insz[0];++i){
      rw[2+2*i]=0;
      rw[3+2*i]=0;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<block->insz[0];++i)  {rw[2+2*i]=rw[3+2*i];}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<block->insz[0];++i) {
      rw[3+2*i]=block->inptr[0][i];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<block->insz[0];++i)
	block->outptr[0][i]=(rw[3+2*i]-rw[2+2*i])/dt;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
     		       	  {if (u[i]<=0)
		       	       {*y=0;
			        break;}
     		      	  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=1;i<m*n;i++)
			    {*y=(*y)&(u[i]);}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
			   {y[i]=1;
			    for(j=1;j<nin+1;j++)
				 {u=Getint32InPortPtrs(block,j);
				  if (u[i]<=0) 
				      {y[i]=0;
				       break;}
				 } 
			   }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
			   {u=Getint32InPortPtrs(block,1);
			    y[i]=u[i];
			    for(j=2;j<nin+1;j++)
				 {u=Getint32InPortPtrs(block,j);
				  y[i]=(y[i])&(u[i]);
				 }
			   }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
     		       	  {if (u[i]>0)
		       	       {*y=1;
			        break;}
     		      	  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
			    {*y=(*y)|(u[i]);}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
			   {y[i]=0;
			    for(j=1;j<nin+1;j++)
				 {u=Getint32InPortPtrs(block,j);
				  if (u[i]>0) 
				      {y[i]=1;
				       break;}
				 }
			   }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
			   {y[i]=0;
			    for(j=1;j<nin+1;j++)
				 {u=Getint32InPortPtrs(block,j);
				  y[i]=(y[i])|(u[i]);
				 }
			   }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
     		       	  {if (u[i]<=0)
		       	       {*y=1;
			        break;}
     		      	  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=1;i<m*n;i++)
			    {*y=((*y)&(u[i]));}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
			   {y[i]=0;
			    for(j=1;j<nin+1;j++)
				 {u=Getint32InPortPtrs(block,j);
				  if (u[i]<=0) 
				      {y[i]=1;
				       break;}
				 } 
			   }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
			   {u=Getint32InPortPtrs(block,1);
			    y[i]=u[i];
			    for(j=2;j<nin+1;j++)
				 {u=Getint32InPortPtrs(block,j);
				  y[i]=((y[i])&(u[i]));
				 }
			    y[i]=~y[i];
			   }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
     		       	  {if (u[i]>0)
		       	       {*y=0;
			        break;}
     		      	  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
			    {*y=((*y)|(u[i]));}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
			   {y[i]=1;
			    for(j=1;j<nin+1;j++)
				 {u=Getint32InPortPtrs(block,j);
				  if (u[i]>0) 
				      {y[i]=0;
				       break;}
				 }
			   }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
			   {u=Getint32InPortPtrs(block,1);
			    y[i]=u[i];
			    for(j=2;j<nin+1;j++)
				 {u=Getint32InPortPtrs(block,j);
				  y[i]=((y[i])|(u[i]));
				 }
			    y[i]=~y[i];
			   }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
     		       	  {if (u[i]>0)
		       	       {l=(l+1)%2;
			       }
     		      	  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=1;i<m*n;i++)
			    {*y=((*y)^(u[i]));}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
			   {l=0;
			    for(j=1;j<nin+1;j++)
				 {u=Getint32InPortPtrs(block,j);
				  if (u[i]>0) 
				      {l=(l+1)%2;}
				 }
			    y[i]=(long)l;
			   }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
		           {u=Getint32InPortPtrs(block,1);
		           y[i]=u[i];
			   for(j=2;j<nin+1;j++)
				 {u=Getint32InPortPtrs(block,j);
				  y[i]=((y[i])^(u[i]));
				 }
			   }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
		       {if (u[i]>0) y[i]=0;
			else y[i]=1;}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
		       {y[i]=~(u[i]);}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<mu*nu;i++)  y[i]=pow(u[i],0.5);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<block->insz[0];j++) {
			block->outptr[0][j]=sinh(block->inptr[0][j]);
		}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<mu*nu;i++)
	{
		int j = 0;
		short v = u[i];
		for(j=0;j<-ipar[0];j++)
		{
			y[i]=v&1;
			if (y[i]==0)  
			{
				y[i]=v>>1;
				y[i]=y[i]&(k-1);}
			else 
			{
				y[i]=v>>1;
				y[i]=(y[i])|(k);
			}
			v=y[i];
		}
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<(nu*nu);i++)
		{
			ptr->LX[2*i]=ur[i];
			ptr->LX[2*i+1]=ui[i];
		}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<(nu*nu);i++)
		{
			yr[i]=ptr->LX[2*i];
			yi[i]=ptr->LX[2*i+1];
		}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++) *(y+i)=(char)block->mode[i]-1;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++) y[i]=0;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
				{
					if (u1[i]==u2[i]) y[i]=1;
				}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
				{
					if (u1[i]!=u2[i]) y[i]=1;
				}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
				{
					if (u1[i]<u2[i]) y[i]=1;
				}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
				{
					if (u1[i]<=u2[i]) y[i]=1;
				}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
				{
					if (u1[i]>u2[i]) y[i]=1;
				}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
				{
					if (u1[i]>=u2[i]) y[i]=1;
				}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++) block->g[i]=*(u1+i)-*(u2+i);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++) block->mode[i]=(int)1;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
				{
					if (u1[i]==u2[i]) block->mode[i]=(int)2;
				}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
				{
					if (u1[i]!=u2[i]) block->mode[i]=(int)2;
				}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
				{
					if (u1[i]<u2[i]) block->mode[i]=(int)2;
				}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
				{
					if (u1[i]<=u2[i]) block->mode[i]=(int)2;
				}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
				{
					if (u1[i]>u2[i]) block->mode[i]=(int)2;
				}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
				{
					if (u1[i]>=u2[i]) block->mode[i]=(int)2;
				}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < n; i++)
    {
        int k = 0;
        y[i] = 0.0;

        for(k = 0; k < *nin; k++)
        {
            double *u = (double *)inptr[k];

            // if rpar exist at the index then use it, use 1 otherwise
            double gain;

            if (k < *nrpar)
                gain = rpar[k];
            else
                gain = 1.0;

            y[i] = y[i] + u[i] * gain;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < nin; j += 2)
    {
        assert(outsz[0] == insz[j]);
        assert(outsz[1] == insz[nin + j]);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i <= len; i++)
    {
        values[i] = (double) i;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<ny*mu;++i){
     D=(double)(opar[0])*(double)(u[i]);
     if ((D>=k)|( D<0))
	{sciprint(_("overflow error"));
	 set_block_error(-4);
	 return;}
     else y[i]=(unsigned short)D;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(l=0;l<ny;l++)
	 {for(j=0;j<my;j++)
	      {D=0;
			 jl=j+l*my;
	       for(i=0;i<mu;i++)
		   {ji=j+i*my;
		    
		    il=i+l*mu;
		    C=(double)(opar[ji])*(double)(u[il]);
		    D=D + C;}
		    if ((D>=k)|( D<0))
			{sciprint(_("overflow error"));
			 set_block_error(-4);
			 return;}
		    else y[jl]=(unsigned short)D;
		  }
	     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<numb;i++)
       {n=(long)pow(2,*ipar+i);
        ref=ref+n;}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<mu*nu;i++) y1[i]=u1[i]*u2[0];}



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<mu*nu;i++) 
	     {y1r[i]=(u1r[i]*u2r[0])-(u1i[i]*u2i[0]);
	       y1i[i]=(u1r[i]*u2i[0])+(u1i[i]*u2r[0]);}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(l=0;l<nu2;l++)
	    {for(j=0;j<mu1;j++)
	        {D=0;
	         jl=j+l*mu1;
	        for(i=0;i<nu1;i++)
		   {ji=j+i*mu1;
		    
		    il=i+l*nu1;
		    C=(double)(u1[ji])*(double)(u2[il]);
		    D=D + C;}
		    if (D>(k-1))
		        {y[jl]=(unsigned short)(k-1);}
		    else if (D<0)
			{y[jl]=0;}
		    else {y[jl]=(unsigned short)(D);}
		    }
		 }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<ny*mu;++i){
     D=(double)(opar[0])*(double)(u[i]);
     t=D-(double)((int)(D/(k)))*((k));
     if ((t>=k/2)|(-(t)>=k/2))
       {if (t>=0) (t)=(-((k/2))+fabs(t-(double)((int)((t)/((k/2))))*((k/2))));
	else (t)=-(-((k/2))+fabs(t-(double)((int)((t)/((k/2))))*((k/2))));}
     y[i]=(unsigned short)t;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(l=0;l<ny;l++)
	 {for(j=0;j<my;j++)
	      {D=0;
		    jl=j+l*my;
	       for(i=0;i<mu;i++)
		   {ji=j+i*my;
		    
		    il=i+l*mu;
		    C=(double)(opar[ji])*(double)(u[il]);
		    D=D + C;}
		    t=D-(double)((int)(D/(k)))*((k));
		    if ((t>=k/2)|(-(t)>=k/2))
		       {if (t>=0) (t)=(-((k/2))+fabs(t-(double)((int)((t)/((k/2))))*((k/2))));
			else (t)=-(-((k/2))+fabs(t-(double)((int)((t)/((k/2))))*((k/2))));}
		    y[jl]=(unsigned short)t;
		  }
	     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<=(mz*nz)-2; i++){
      oz[i]=oz[i+1];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++) *(y+i)=((*(u+i))|(*opar));



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(l=0;l<nu2;l++)
	    {
			int j = 0;
			for(j=0;j<mu1;j++)
	        {
				double D = 0.;
				double t = 0.;
				int jl = j + l*mu1;
				int i = 0;
				for(i=0;i<nu1;i++)
				{
					int ji = j + i*mu1;
		    	    int il = i + l*nu1;
					double C = (double)(u1[ji])*(double)(u2[il]);
					D = D + C;
				}
				t = D - (double)((int)(D/(k)))*((k));
				if ((t>=k/2)|(-(t)>=k/2))
				{
					if (t>=0) (t)=(-((k/2))+fabs(t-(double)((int)((t)/((k/2))))*((k/2))));
					else (t)=-(-((k/2))+fabs(t-(double)((int)((t)/((k/2))))*((k/2))));
				}
				y[jl]=(long)t;
			}
		}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=1;i< block->ipar[0];i++){
			pw[i]=pw[i-1]+block->rpar[0];
			for(j=1;j< block->insz[0]+1;j++){
				pw[i+block->ipar[0]*j]=block->rpar[1];
			}
		}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=1;j< block->insz[0]+1;j++){
				pw[*iw +block->ipar[0]*j]=block->inptr[0][j-1];
			}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=1;j< block->insz[0]+1;j++){
				pw[(block->ipar[0]+*iw-1)%block->ipar[0] +block->ipar[0]*j]=block->inptr[0][j-1];
			}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k=1;k<block->insz[0]+1;k++){
				block->outptr[0][k-1]=((pw[j]-td)*pw[i+block->ipar[0]*k] +
					(td-pw[i])*pw[j+block->ipar[0]*k])/del;
			}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k=1;k<block->insz[0]+1;k++){
				block->outptr[0][k-1]=pw[i+block->ipar[0]*k];
			}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<NX;i++) property[i]=-1; 



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<NX;i++){
	  property[i] = block->ipar[i];
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<NX;i++) block->res[i]=u[i];	



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<NX;i++)  y[i]=block->x[i];	



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<NX;i++)  y2[i]=block->xd[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<block->insz[0];j++) 
		{
			block->outptr[0][j]=block->inptr[i][j];
		}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++) *(y+i)= (unsigned short)block->mode[i]-1;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++) y[i]=0;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
				{
					if (u1[i]==u2[i]) y[i]=1;
				}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
				{
					if (u1[i]!=u2[i]) y[i]=1;
				}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
				{
					if (u1[i]<u2[i]) y[i]=1;
				}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
				{
					if (u1[i]<=u2[i]) y[i]=1;
				}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
				{
					if (u1[i]>u2[i]) y[i]=1;
				}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
				{
					if (u1[i]>=u2[i]) y[i]=1;
				}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++) block->g[i]=*(u1+i)-*(u2+i);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++) block->mode[i]=(int)1;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
				{
					if (u1[i]==u2[i]) block->mode[i]=(int)2;
				}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
				{
					if (u1[i]!=u2[i]) block->mode[i]=(int)2;
				}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
				{
					if (u1[i]<u2[i]) block->mode[i]=(int)2;
				}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
				{
					if (u1[i]<=u2[i]) block->mode[i]=(int)2;
				}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
				{
					if (u1[i]>u2[i]) block->mode[i]=(int)2;
				}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
				{
					if (u1[i]>=u2[i]) block->mode[i]=(int)2;
				}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<maxim/2;i++)
       {n=(short)pow(2,i);
        ref=ref+n;}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < (nu * nu); i++)
        {
            y[i] = u[i];
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<numb;i++)
       {n=(char)pow(2,*ipar+i);
        ref=ref+n;}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<*ipar;i++)
       {n=(long)pow(2,maxim-1-i);
        ref=ref+n;}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<block->insz[0];j++) {
      block->outptr[0][j]=asin(block->inptr[0][j]);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<maxim/2;i++)
       {n=(long)pow(2,maxim/2+i);
        ref=ref+n;}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<nin;i++) { 
				u=GetInPortPtrs(block,i+1);
				nu=GetInPortCols(block,i+1);
				so=GetSizeOfIn(block,i+1);
				memcpy((char*)y+pointerposition,u,mu*nu*so);
				pointerposition=pointerposition+mu*nu*so;
			}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<mu*nu;i++)
	     {v=(double)u1[i]*(double)u2[i];
	       if ((v<rpar[0])|(v>rpar[1])) 
		 {sciprint(_("overflow error"));
		   set_block_error(-4);
		   return;}
	       else y1[i]=(long)v;}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<mu*nu;i++)
	     {v=(double)u1[i]*(double)u2[i];
	       if ((v<rpar[0])|(v>rpar[1])) 
		 {sciprint(_("overflow error"));
		   set_block_error(-4);
		   return;}
	       else  y1[i]=(short)v;}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<mu*nu;i++)
	     {v=(double)u1[i]*(double)u2[i];
	       if ((v<rpar[0])|(v>rpar[1])) 
		 {sciprint(_("overflow error"));
		   set_block_error(-4);
		   return;}
	       else y1[i]=(char)v;}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<mu*nu;i++)
	     {v=(double)u1[i]*(double)u2[i];
	       if ((v<rpar[0])|(v>rpar[1])) 
		 {sciprint(_("overflow error"));
		   set_block_error(-4);
		   return;}
	       else y1[i]=(unsigned long)v;}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<mu*nu;i++)
	     {v=(double)u1[i]*(double)u2[i];
	       if ((v<rpar[0])|(v>rpar[1])) 
		 {sciprint(_("overflow error"));
		   set_block_error(-4);
		   return;}
	       else y1[i]=(unsigned short)v;}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<mu*nu;i++)
	     {v=(double)u1[i]*(double)u2[i];
	       if ((v<rpar[0])|(v>rpar[1])) 
		 {sciprint(_("overflow error"));
		   set_block_error(-4);
		   return;}
	       else y1[i]=(unsigned char)v;}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<(mu1*nu);i++)   
		{
			ptr->IN1[2*i]=ptr->urT1[i];
			ptr->IN1[2*i+1]=-ptr->uiT1[i];
		}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<(mu2*nu);i++)   
		{
			ptr->IN2[2*i]=ptr->urT2[i];
			ptr->IN2[2*i+1]=-ptr->uiT2[i];
		}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<(mu2*nu);i++)
					{
						*(ptr->yrT+i)=*(ptr->IN2+2*i);
						*(ptr->yiT+i)=-(*(ptr->IN2+(2*i)+1));}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<mu1;i++)    *(ptr->jpvt+i)=0;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<(l*mu2);i++)
		{
			*(ptr->yrT+i)=*(ptr->IN2X+2*i);
			*(ptr->yiT+i)=-(*(ptr->IN2X+(2*i)+1));
		}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<mu*nu;i++) 
	{
		*(y1r+i)=*(u1+i);
		*(y1i+i)=*(u2+i);
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(l=0;l<nu2;l++)
	    {for(j=0;j<mu1;j++)
	        {D=0;
	         jl=j+l*mu1;
	        for(i=0;i<nu1;i++)
		   {ji=j+i*mu1;
		    
		    il=i+l*nu1;
		    C=(double)(u1[ji])*(double)(u2[il]);
		    D=D + C;}
		    if ((D>(k-1)) |(D<0))
		        {sciprint(_("overflow error"));
			 set_block_error(-4);
			 return;}
		    else {y[jl]=(unsigned long)(D);}
		    }
		 }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<block->insz[0];j++) {
	    if(block->inptr[0][j]<=0)
	      {
		block->outptr[0][0]=0.0;
		break;
	      }
	  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<block->insz[0];j++) {
	  block->outptr[0][j]=1.0;
	  for(k=0;k<block->nin;k++) {
	    if(block->inptr[k][j]<=0) {
	      block->outptr[0][j]=0.0;
	      break;
	    }
	  }
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<block->insz[0];j++) {
	    if(block->inptr[0][j]>0) {
	      block->outptr[0][0]=1.0;
	      break;
	    }
	  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<block->insz[0];j++) {
	  block->outptr[0][j]=0.0;
	  for(k=0;k<block->nin;k++) {
	    if(block->inptr[k][j]>0) {
	      block->outptr[0][j]=1.0;
	      break;
	    }
	  }
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<block->insz[0];j++) {
	    if(block->inptr[0][j]<=0)
	      {
		block->outptr[0][0]=1.0;
		break;
	      }
	  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<block->insz[0];j++) {
	  block->outptr[0][j]=0.0;
	  for(k=0;k<block->nin;k++) {
	    if(block->inptr[k][j]<=0) {
	      block->outptr[0][j]=1.0;
	      break;
	    }
	  }
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<block->insz[0];j++) {
	    if(block->inptr[0][j]>0) {
	      block->outptr[0][0]=0.0;
	      break;
	    }
	  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<block->insz[0];j++) {
	  block->outptr[0][j]=1.0;
	  for(k=0;k<block->nin;k++) {
	    if(block->inptr[k][j]>0) {
	      block->outptr[0][j]=0.0;
	      break;
	    }
	  }
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<block->insz[0];j++) {
	    if(block->inptr[0][j]>0) {
	      l=(l+1)%2;
	    }
	  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<block->insz[0];j++) {
	  l=0;
	  for(k=0;k<block->nin;k++) {
	    if(block->inptr[k][j]>0) {
	      l=(l+1)%2;
	    }
	  }
	  block->outptr[0][j]=(double) l;
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<block->insz[0];j++) {
	if(block->inptr[0][j]>0) {
	  block->outptr[0][j]=0.0;
	}
	else{
	  block->outptr[0][j]=1.0;
	}
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<mu;i++) y[i]=u[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=1;j<nu;j++)
       {
	for(i=0;i<mu;i++)
	   {ij=i+j*mu;
	    y[ij]=u[ij]+y[ij-mu];}}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < block->insz[0]; j++)
            {
                result = pushData(block, j);
                if (result == FALSE)
                {
                    Coserror("%s: unable to push some data.", "bouncexy");
                    break;
                }
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < block->insz[0]; i++)
        {
            sco->internal.ballsSize[i] = block->z[6 * i + 2];
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < block->insz[0]; i++)
        {
            sco->internal.data[i] = (double *)CALLOC(3, sizeof(double));
            if (sco->internal.data[i] == NULL)
                goto error_handler_data_i;
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < i; j++)
    {
        FREE(sco->internal.data[i]);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < block->insz[0]; i++)
        {
            FREE(sco->internal.data[i]);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < block->insz[0]; i++)
        {
            FREE(sco->scope.cachedArcsUIDs[i]);
            sco->scope.cachedArcsUIDs[i] = NULL;
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < block->insz[0]; i++)
        {
            upperLeftPoint = sco->internal.data[i];
            ballSize = sco->internal.ballsSize[i];

            upperLeftPoint[0] = x[i] - (ballSize / 2);  // x
            upperLeftPoint[1] = y[i] + (ballSize / 2);  // y
            upperLeftPoint[2] = 0;  // z
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < block->insz[0]; i++)
        {
            getArc(pAxe, block, i);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<block->insz[0];j++) {
      block->outptr[0][j]=asinh(block->inptr[0][j]);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<numb;i++)
       {n=(long)pow(2,*ipar+i);
        ref=ref+n;}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<*ipar;i++)
       {n=(short)pow(2,maxim-1-i);
        ref=ref+n;}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<nu;j++)
	{for(i=j;i<nu;i++)
		{ij=i+j*nu;
		 ji=j+i*nu;
		if (i!=j)
			{if (*(ptr->LA+ij)==*(ptr->LA+ji)) symmetric*= 1;
			 else { symmetric*=0;break;}}}}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<nc;j++)
	{for(i=0;i<nl;i++)
		{ij=r[i]-1+(r[nl+j]-1)*mu;
		 *(y+k)=*(u+ij);
		 k++;}}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<mu*nu;i++) y[i]=u[i]<<ipar[0];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<(nu*nu);i++)
		{
			mdet->wrk[2*i]=ur[i];
			mdet->wrk[2*i+1]=ui[i];}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<nu;i++)
		{
			if((*(mdet->ipiv+i))!=i+1) {D.r=-D.r;D.i=-D.i;}
			l.r=*(mdet->wrk+i*2*(nu+1));
			l.i=*(mdet->wrk+1+i*2*(nu+1));
			A=D.r;
			D.r=D.r*l.r-D.i*l.i;
			D.i=D.i*l.r+A*l.i;
		}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(l=0;l<nu2;l++)
	    {for(j=0;j<mu1;j++)
	        {D=0;
	        jl=j+l*mu1;
	        for(i=0;i<nu1;i++)
		   {ji=j+i*mu1;
		    
		    il=i+l*nu1;
		    C=(double)(u1[ji])*(double)(u2[il]);
		    D=D + C;}
		    if ((D>(k-1)) |(D<0))
		        {sciprint(_("overflow error"));
			 set_block_error(-4);
			 return;}
		    else {y[jl]=(unsigned short)(D);}
		    }
		 }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<mu*nu;i++) y1[i]=u1[i]*u2[i];}



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<mu*nu;i++) 
			{y1r[i]=(u1r[i]*u2r[i])-(u1i[i]*u2i[i]);
			y1i[i]=(u1r[i]*u2i[i])+(u1i[i]*u2r[i]);}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<mu*nu;i++) *(y+i)=0;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<Min(mu,nu);i++)     
	{ii=i+i*mu;
	 *(y+ii)=*(u1+ii);}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<ny*mu;++i){
     D=(double)(opar[0])*(double)(u[i]);
     if ((D>=k)|( D<0))
	{sciprint(_("overflow error"));
	 set_block_error(-4);
	 return;}
     else y[i]=(unsigned char)D;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(l=0;l<ny;l++)
	 {for(j=0;j<my;j++)
	      {D=0;
		   jl=j+l*my;
	       for(i=0;i<mu;i++)
		   {ji=j+i*my;
		    
		    il=i+l*mu;
		    C=(double)(opar[ji])*(double)(u[il]);
		    D=D + C;}
		    if ((D>=k)|( D<0))
			{sciprint(_("overflow error"));
			 set_block_error(-4);
			 return;}
		    else y[jl]=(unsigned char)D;
		  }
	     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < nPoints-1; j++)
		{
			if(ptr_T[j] > ptr_T[j+1])
			{
				Coserror(_("The time vector should be an increasing vector.\n"));
				
				*(block->work)=NULL;
				scicos_free(ptr->workt);
				scicos_free(ptr->work);
				scicos_free(ptr);
				return;
			}
		}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<mY;j++)
			{ 
				for(i=0;i<=nPoints-2;i++)
				{
					A_sd[i] = 1.0 / (ptr_T[i+1] - ptr_T[i]);
					qdy[i]  = (ptr_d[i+1+j*nPoints] - ptr_d[i+j*nPoints]) * A_sd[i]*A_sd[i];
				}

				for(i=1;i<=nPoints-2;i++)
				{
					A_d[i] = 2.0*(A_sd[i-1] +A_sd[i]);
					ptr->D[i+j*nPoints] = 3.0*(qdy[i-1]+qdy[i]);
				}

				if (Method==2)
				{
					A_d[0] =  2.0*A_sd[0];
					ptr->D[0+j*nPoints] = 3.0 * qdy[0];
					A_d[nPoints-1] =  2.0*A_sd[nPoints-2];
					ptr->D[nPoints-1+j*nPoints] =  3.0 * qdy[nPoints-2];
					Mytridiagldltsolve(A_d, A_sd, &ptr->D[j*nPoints], nPoints);
				}

				if (Method==3)
				{
					
					r = A_sd[1]/A_sd[0];
					A_d[0]= A_sd[0]/(1.0 + r);
					ptr->D[j*nPoints]=((3.0*r+2.0)*qdy[0]+r*qdy[1])/((1.0+r)*(1.0+r));
					
					r = A_sd[nPoints-3]/A_sd[nPoints-2];
					A_d[nPoints-1] = A_sd[nPoints-2]/(1.0 + r);
					ptr->D[nPoints-1+j*nPoints] = \
						((3.0*r+2.0)*qdy[nPoints-2]+r*qdy[nPoints-3])/((1.0+r)*(1.0+r));
					Mytridiagldltsolve(A_d, A_sd, &ptr->D[j*nPoints], nPoints);
				}
			}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<mY;j++)
				{
					for(i=0;i<=nPoints-2;i++)
					{
						A_sd[i] = 1.0 / (ptr_T[i+1] - ptr_T[i]);
						qdy[i]  = (ptr_d[nPoints+i+1+j*nPoints] - ptr_d[nPoints+i+j*nPoints]) * A_sd[i]*A_sd[i];
					}

					for(i=1;i<=nPoints-2;i++)
					{
						A_d[i] = 2.0*(A_sd[i-1] +A_sd[i]);
						ptr->D[i+j*nPoints+nPoints] = 3.0*(qdy[i-1]+qdy[i]);
					}

					if (Method==2)
					{
						A_d[0] =  2.0*A_sd[0];
						ptr->D[nPoints+0+j*nPoints] = 3.0 * qdy[0];
						A_d[nPoints-1] =  2.0*A_sd[nPoints-2];
						ptr->D[nPoints+nPoints-1+j*nPoints] =  3.0 * qdy[nPoints-2];
						Mytridiagldltsolve(A_d, A_sd, &ptr->D[nPoints+j*nPoints], nPoints);
					}

					if (Method==3)
					{
						
						r = A_sd[1]/A_sd[0];
						A_d[0]= A_sd[0]/(1.0 + r);
						ptr->D[nPoints+j*nPoints]=((3.0*r+2.0)*qdy[0]+r*qdy[1])/((1.0+r)*(1.0+r));
						
						r = A_sd[nPoints-3]/A_sd[nPoints-2];
						A_d[nPoints-1] = A_sd[nPoints-2]/(1.0 + r);
						ptr->D[nPoints+nPoints-1+j*nPoints] = \
							((3.0*r+2.0)*qdy[nPoints-2]+r*qdy[nPoints-3])/((1.0+r)*(1.0+r));
						Mytridiagldltsolve(A_d, A_sd, &ptr->D[nPoints+j*nPoints], nPoints);
					}
				}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<nPoints;i++)
		{
			
			if (ptr->workt[i]>=0 )
			{
				cnt1=i-1;
				cnt2=i;
				break;
			}
		}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = cnt1 ; i < nPoints ; i++)
			{
				if (i==-1)
				{
					continue;
				}
				if (t <= ptr->workt[i])
				{
					 if (t < ptr->workt[i])
                    {
                        inow = i - 1;
                    }
                    else
                    {
                        inow = i;
                    }
					if (inow<cnt2)
					{
						cnt2=inow;
					}
					else
					{
						cnt1=cnt2;
						cnt2=inow;
					}
					break;
				}
			}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0 ; i < nPoints ; i++)
			{
				if (t <= ptr->workt[i])
				{
                    if (t < ptr->workt[i])
                    {
                        inow = i - 1;
                    }
                    else
                    {
                        inow = i;
                    }
					break;
				}
			}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<my*ny;j++)
			{
				if (ptr->Yt==1)
				{
					if (ptr->Yst==0)
					{
						
						y_d = GetRealOutPortPtrs(block,1);
						ptr_d=(double*) ptr->work;

						if (inow > nPoints)
						{
							if (OutEnd==0)
							{
								y_d[j]=0.0; 
							}
							else if (OutEnd==1)
							{
								y_d[j]=ptr_d[(nPoints-1)*ny*my+j]; 
							}
						}
						else
						{
							if (inow<0)
							{
								y_d[j]=0.0;
							}
							else
							{
								y_d[j]=ptr_d[inow*ny*my+j];
							}
						}
					}
					else
					{
						
						y_d = GetRealOutPortPtrs(block,1);
						y_cd = GetImagOutPortPtrs(block,1);
						ptr_d=(double*) ptr->work;

						if (inow > nPoints)
						{
							if (OutEnd==0)
							{
								y_d[j]=0.0;  
								y_cd[j]=0.0; 
							}
							else if (OutEnd==1)
							{
								y_d[j]=ptr_d[(nPoints-1)*ny*my+j]; 
								y_cd[j]=ptr_d[nPoints*my*ny+(nPoints-1)*ny*my+j];    
							}
						}
						else
						{
							if (inow<0)
							{
								y_d[j]=0.0;  
								y_cd[j]=0.0; 
							}
							else
							{
								y_d[j]=ptr_d[inow*ny*my+j];
								y_cd[j]=ptr_d[nPoints*my*ny+inow*ny*my+j];
							}
						}
					}
				}
				else if (ptr->Yt==8)
				{
					switch (ptr->Yst)
					{
					case 1:
						
						y_c = Getint8OutPortPtrs(block,1);
						ptr_c=(char*) ptr->work;
						if (inow > nPoints)
						{
							if (OutEnd==0)
							{
								y_c[j]=0; 
							}
							else if (OutEnd==1)
							{
								y_c[j]=ptr_c[(nPoints-1)*ny*my+j]; 
							}
						}
						else
						{
							if (inow<0)
							{
								y_c[j]=0;
							}
							else
							{
								y_c[j]=ptr_c[inow*ny*my+j];
							}
						}
						break;

					case 2:
						
						y_s = Getint16OutPortPtrs(block,1);
						ptr_s=(short*) ptr->work;
						if (inow > nPoints)
						{
							if (OutEnd==0)
							{
								y_s[j]=0; 
							}
							else if (OutEnd==1)
							{
								y_s[j]=ptr_s[(nPoints-1)*ny*my+j]; 
							}
						}
						else
						{
							if (inow<0)
							{
								y_s[j]=0;
							}
							else
							{
								y_s[j]=ptr_s[inow*ny*my+j];
							}
						}
						break;

					case 4:
						
						y_l = Getint32OutPortPtrs(block,1);
						ptr_l=(long*) ptr->work;
						if (inow > nPoints)
						{
							if (OutEnd==0)
							{
								y_l[j]=0;
							}
							else if (OutEnd==1)
							{
								y_l[j]=ptr_l[(nPoints-1)*ny*my+j]; 
							}
						}
						else
						{
							if (inow<0)
							{
								y_l[j]=0;
							}
							else
							{
								y_l[j]=ptr_l[inow*ny*my+j];
							}
						}
						break;

					case 11:
						
						y_uc = Getuint8OutPortPtrs(block,1);
						ptr_uc=(unsigned char*) ptr->work;
						if (inow > nPoints)
						{
							if (OutEnd==0)
							{
								y_uc[j]=0;
							}
							else if (OutEnd==1)
							{
								y_uc[j]=ptr_uc[(nPoints-1)*ny*my+j]; 
							}
						}
						else
						{
							if (inow<0)
							{
								y_uc[j]=0;
							}
							else
							{
								y_uc[j]=ptr_uc[inow*ny*my+j];
							}
						}
						break;

					case 12:
						
						y_us = Getuint16OutPortPtrs(block,1);
						ptr_us=(unsigned short*) ptr->work;
						if (inow > nPoints)
						{
							if (OutEnd==0)
							{
								y_us[j]=0;
							}
							else if (OutEnd==1)
							{
								y_us[j]=ptr_us[(nPoints-1)*ny*my+j]; 
							}
						}
						else
						{
							if (inow<0)
							{
								y_us[j]=0;
							}
							else
							{
								y_us[j]=ptr_us[inow*ny*my+j];
							}
						}
						break;

					case 14:
						
						y_ul = Getuint32OutPortPtrs(block,1);
						ptr_ul=(unsigned long*) ptr->work;
						if (inow > nPoints)
						{
							if (OutEnd==0)
							{
								y_ul[j]=0;
							}
							else if (OutEnd==1)
							{
								y_ul[j]=ptr_ul[(nPoints-1)*ny*my+j]; 
							}
						}
						else
						{
							if (inow<0)
							{
								y_ul[j]=0;
							}
							else
							{
								y_ul[j]=ptr_ul[inow*ny*my+j];
							}
						}
						break;
					}
				}
			}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<my;j++)
			{
				if (ptr->Yt==1)
				{
					if ((ptr->Yst==0)||(ptr->Yst==1))
					{
						
						y_d = GetRealOutPortPtrs(block,1);
						ptr_d=(double*) ptr->work;
						ptr_D=(double*) ptr->D;

						if (inow > nPoints)
						{
							if (OutEnd==0)
							{
								y_d[j]=0.0; 
							}
							else if (OutEnd==1)
							{
								y_d[j]=ptr_d[nPoints-1+(j)*nPoints]; 
							}
						}
						else if (Method==0)
						{
							if (inow<0)
							{
								y_d[j]=0.0;
							}
							else
							{
								y_d[j]=ptr_d[inow+(j)*nPoints];
							}
						}
						else if (Method==1)
						{
							if (inow<0)
							{
								inow=0;
							}
							t1=ptr->workt[inow];
							t2=ptr->workt[inow+1];
							y1=ptr_d[inow+j*nPoints];
							y2=ptr_d[inow+1+j*nPoints];
							y_d[j]=(y2-y1)*(t-t1)/(t2-t1)+y1;
						}
						else if (Method>=2)
						{
							t1=ptr->workt[inow];
							t2=ptr->workt[inow+1];
							y1=ptr_d[inow+j*nPoints];
							y2=ptr_d[inow+1+j*nPoints];
							d1=ptr_D[inow+j*nPoints];
							d2=ptr_D[inow+1+j*nPoints];
							scicos_evalhermite(&t, &t1,&t2, &y1,&y2, &d1,&d2, &h, &dh, &ddh, &dddh, &inow);
							y_d[j]=h;
						}
					}
					if (ptr->Yst==1)
					{
						
						y_cd = GetImagOutPortPtrs(block,1);
						if (inow > nPoints)
						{
							if (OutEnd==0)
							{
								y_cd[j]=0.0;
							}
							else if (OutEnd==1)
							{
								y_cd[j]=ptr_d[nPoints*my+nPoints-1+(j)*nPoints]; // hold outputs at the end
							}
						}
						else if (Method==0)
						{
							if (inow<0)
							{
								y_cd[j]=0.0; 
							}
							else
							{
								y_cd[j]=ptr_d[nPoints*my+inow+(j)*nPoints];
							}
						}
						else if (Method==1)
						{
							if (inow<0)
							{
								inow=0;
							} 
							t1=ptr->workt[inow];
							t2=ptr->workt[inow+1];
							y1=ptr_d[nPoints*my+inow+j*nPoints];
							y2=ptr_d[nPoints*my+inow+1+j*nPoints];
							y_cd[j]=(y2-y1)*(t-t1)/(t2-t1)+y1;
						}
						else if (Method>=2)
						{
							t1=ptr->workt[inow];
							t2=ptr->workt[inow+1];
							y1=ptr_d[inow+j*nPoints+nPoints];
							y2=ptr_d[inow+1+j*nPoints+nPoints];
							d1=ptr_D[inow+j*nPoints+nPoints];
							d2=ptr_D[inow+1+j*nPoints+nPoints];
							scicos_evalhermite(&t, &t1,&t2, &y1,&y2, &d1,&d2, &h, &dh, &ddh, &dddh, &inow);
							y_cd[j]=h;
						}
					}
				}
				else if (ptr->Yt==8)
				{
					switch (ptr->Yst)
					{
					case 1: 
						y_c = Getint8OutPortPtrs(block,1);
						ptr_c=(char*) ptr->work;
						
						if (inow > nPoints)
						{
							if (OutEnd==0)
							{
								y_c[j]=0; 
							}
							else if (OutEnd==1)
							{
								y_c[j]=ptr_c[nPoints-1+(j)*nPoints]; 
							}
						}
						else if (Method==0)
						{
							if (inow<0)
							{
								y_c[j]=0;
							}
							else
							{
								y_c[j]=ptr_c[inow+(j)*nPoints];
							}
						}
						else if (Method>=1)
						{
							if (inow<0)
							{
								inow=0;
							}
							t1=ptr->workt[inow];
							t2=ptr->workt[inow+1];
							y1=(double)ptr_c[inow+j*nPoints];
							y2=(double)ptr_c[inow+1+j*nPoints];
							y_c[j] =(char)((y2-y1)*(t-t1)/(t2-t1)+y1);
						}
						break;
					case 2:
						
						y_s = Getint16OutPortPtrs(block,1);
						ptr_s=(short*) ptr->work;
						
						if (inow > nPoints)
						{
							if (OutEnd==0)
							{
								y_s[j]=0; 
							}
							else if (OutEnd==1)
							{
								y_s[j]=ptr_s[nPoints-1+(j)*nPoints]; // hold outputs at the end
							}
						}
						else if (Method==0)
						{
							if (inow<0)
							{
								y_s[j]=0;
							}
							else
							{
								y_s[j]=ptr_s[inow+(j)*nPoints];
							}
						}
						else if (Method>=1)
						{
							if (inow<0)
							{
								inow=0;
							}
							t1=ptr->workt[inow];
							t2=ptr->workt[inow+1];
							y1=(double)ptr_s[inow+j*nPoints];
							y2=(double)ptr_s[inow+1+j*nPoints];
							y_s[j] =(short)((y2-y1)*(t-t1)/(t2-t1)+y1);
						}
						break;
					case 4:
						
						y_l = Getint32OutPortPtrs(block,1);
						ptr_l=(long*) ptr->work;
						
						if (inow > nPoints)
						{
							if (OutEnd==0)
							{
								y_l[j]=0;
							}
							else if (OutEnd==1)
							{
								y_l[j]=ptr_l[nPoints-1+(j)*nPoints]; 
							}
						}
						else if (Method==0)
						{
							if (inow<0)
							{
								y_l[j]=0;
							}
							else
							{
								y_l[j]=ptr_l[inow+(j)*nPoints];
							}
						}
						else if (Method>=1)
						{
							t1=ptr->workt[inow];
							t2=ptr->workt[inow+1];
							y1=(double)ptr_l[inow+j*nPoints];
							y2=(double)ptr_l[inow+1+j*nPoints];
							y_l[j] =(long)((y2-y1)*(t-t1)/(t2-t1)+y1);
						}
						break;
					case 11: 
						y_uc = Getuint8OutPortPtrs(block,1);
						ptr_uc=(unsigned char*) ptr->work;
						
						if (inow > nPoints)
						{
							if (OutEnd==0)
							{
								y_uc[j]=0;
							}
							else if (OutEnd==1)
							{
								y_uc[j]=ptr_uc[nPoints-1+(j)*nPoints]; 
							}
						}
						else if (Method==0)
						{
							if (inow<0)
							{
								y_uc[j]=0;
							}
							else
							{
								y_uc[j]=ptr_uc[inow+(j)*nPoints];
							}
						}
						else if (Method>=1)
						{
							t1=ptr->workt[inow];
							t2=ptr->workt[inow+1];
							y1=(double)ptr_uc[inow+j*nPoints];
							y2=(double)ptr_uc[inow+1+j*nPoints];
							y_uc[j] =(unsigned char)((y2-y1)*(t-t1)/(t2-t1)+y1);
						}
						break;
					case 12:
						
						y_us = Getuint16OutPortPtrs(block,1);
						ptr_us=(unsigned short*) ptr->work;
						
						if (inow > nPoints)
						{
							if (OutEnd==0)
							{
								y_us[j]=0;
							}
							else if (OutEnd==1)
							{
								y_us[j]=ptr_us[nPoints-1+(j)*nPoints]; 
							}
						}
						else if (Method==0)
						{
							if (inow<0)
							{
								y_us[j]=0;
							}
							else
							{
								y_us[j]=ptr_us[inow+(j)*nPoints];
							}
						}
						else if (Method>=1)
						{
							t1=ptr->workt[inow];
							t2=ptr->workt[inow+1];
							y1=(double)ptr_us[inow+j*nPoints];
							y2=(double)ptr_us[inow+1+j*nPoints];
							y_us[j] =(unsigned short)((y2-y1)*(t-t1)/(t2-t1)+y1);
						}
						break;
					case 14:
						
						y_ul = Getuint32OutPortPtrs(block,1);
						ptr_ul=(unsigned long*) ptr->work;
						
						if (inow > nPoints)
						{
							if (OutEnd==0)
							{
								y_ul[j]=0;
							}
							else if (OutEnd==1)
							{
								y_ul[j]=ptr_ul[nPoints-1+(j)*nPoints]; 
							}
						}
						else if (Method==0)
						{
							if (inow<0)
							{
								y_ul[j]=0;
							}
							else
							{
								y_ul[j]=ptr_ul[inow+(j)*nPoints];
							}
						}
						else if (Method>=1)
						{
							t1=ptr->workt[inow];
							t2=ptr->workt[inow+1];
							y1=(double)ptr_ul[inow+j*nPoints];
							y2=(double)ptr_ul[inow+1+j*nPoints];
							y_ul[j] =(unsigned long)((y2-y1)*(t-t1)/(t2-t1)+y1);
						}
						break;
					}
				}
			}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<nPoints;j++)
					{
						if (ptr->workt[j]>0)
						{
							jfirst=j;
							break;
						}
					}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<nPoints;j++)
						{
							if (ptr->workt[j]>=0)
							{
								jfirst=j;
								break;
							}
						}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 1; j <= N-1; ++j)
	{
		Temp = lA[j-1];
		lA[j-1] /= dA[j-1];
		B[j] -= lA[j-1] * B[j-1];
		dA[j] -= Temp * lA[j-1];
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = N - 2; j >= 0; --j)
	{
		B[j] = - lA[j] * B[j + 1] + B[j] / dA[j];
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<nu*mu;j++) 
			{
				v=v+(double)u[j];
			}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<nu*mu;j++) 
			{
				double v = 0.;
				for(k=0;k<nin;k++) 
				{
					short *u = Getint16InPortPtrs(block,k+1);
					if(ipar[k]>0)
					{
						v=v+(double)u[j];
					}
					else
					{
						v=v-(double)u[j];
					}
				}
				if ((v>=l)|(v<-l)) 
				{
					sciprint(_("overflow error"));
					set_block_error(-4);
					return;
				}
				else y[j]=(short)v;
			}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<mu*nu;i++)
	     {v=(double)u1[i]*(double)u2[i];
	       if (v<rpar[0]) v=rpar[0];
	       else if (v>rpar[1]) v=rpar[1];
	       y1[i]=(long)v;}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<mu*nu;i++)
	     {v=(double)u1[i]*(double)u2[i];
	       if (v<rpar[0]) v=rpar[0];
	       else if (v>rpar[1]) v=rpar[1];
	       y1[i]=(short)v;}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<mu*nu;i++)
	     {v=(double)u1[i]*(double)u2[i];
	       if (v<rpar[0]) v=rpar[0];
	       else if (v>rpar[1]) v=rpar[1];
	       y1[i]=(char)v;}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<mu*nu;i++)
	     {v=(double)u1[i]*(double)u2[i];
	       if (v<rpar[0]) v=rpar[0];
	       else if (v>rpar[1]) v=rpar[1];
	       y1[i]=(unsigned long)v;}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<mu*nu;i++)
	     {v=(double)u1[i]*(double)u2[i];
	       if (v<rpar[0]) v=rpar[0];
	       else if (v>rpar[1]) v=rpar[1];
	       y1[i]=(unsigned short)v;}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<mu*nu;i++)
	     {v=(double)u1[i]*(double)u2[i];
	       if (v<rpar[0]) v=rpar[0];
	       else if (v>rpar[1]) v=rpar[1];
	       y1[i]=(unsigned char)v;}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<my*ny;i++) 
			{
				*(z+i+2)=C2F(urand)(&iy_r);
				*(z+i+2+my*ny)=C2F(urand)(&iy_i);
			}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<my*ny;i++) 
			{
				do 
				{
					sr=2.0*C2F(urand)(&iy_r)-1.0;
					si=2.0*C2F(urand)(&iy_r)-1.0;
					tl=sr*sr+si*si;
				} while(tl>1.0);
				z[i+2]= sr*(sqrt(-2.0*log(tl)/tl));
				do {
					sr=2.0*C2F(urand)(&iy_i)-1.0;
					si=2.0*C2F(urand)(&iy_i)-1.0;
					tl=sr*sr+si*si;
				} while(tl>1.0);
				z[i+2+my*ny]= sr*(sqrt(-2.0*log(tl)/tl));
			}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<my*ny;i++) 
		{
			*(y_r+i)=*(rpar+i)+(*(rpar+i+2*my*ny))*(*(z+i+2));
			*(y_i+i)=*(rpar+i+my*ny)+(*(rpar+i+3*my*ny))*(*(z+i+2+my*ny));
		}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<*tempind1;i++)
	*(tempind1+1+i)=Max(Min((int)(*(indx1+i)),my-(1-(int)(*indxb)))-(int)(*indxb),0);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<my;i++)
	*(tempind1+1+i)=i;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<*tempind2;i++)
	  *(tempind2+1+i)=Max(Min((int)(*(indx2+i)),ny-(1-(int)(*indxb)))-(int)(*indxb),0);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<ny;i++)
	  *(tempind2+1+i)=i;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<tempind2[0];j++) 
	{
      for(i=0;i<tempind1[0];i++) 
	  {
		memcpy(((int*)y+((*(tempind2+1+j)*(my))+(*(tempind1+1+i)))*so),u,so);
      }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<mu*nu;i++)
	{
		yr[i]=u1r[i]*u2r[i]-u1i[i]*u2i[i];
		yi[i]=u1r[i]*u2i[i]+u1i[i]*u2r[i];
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=1;j<mu*nu;j++)
       {y[j]=u[j]+y[j-1];
       }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=r[2]-1;j<r[3];j++)
	{
		for(i=r[0]-1;i<r[1];i++)
		{
			int ij=i+j*mu;
			*(yr+k)=*(ur+ij);
			*(yi+k)=*(ui+ij);
			k++;
		}
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<mu*nu;i++) *(y+i)=*(u+i);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<nu;j++)
	{for(i=j+1;i<mu;i++)
		{ij=i+j*mu;
		 *(y+ij)=0;
		}}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<mu*nu;i++)
	{ 
		int j = 0;

		short v = u[i];
		for(j=0;j<ipar[0];j++)
		{
			y[i]=v&k;
			if (y[i]==0)  y[i]=v<<1;
			else 
			{
				y[i]=v<<1;
				y[i]=(y[i])|(1);
			}
			v=y[i];
		}
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < m * n; i++)
    {
        scaledData[i] = floor(alpha * data[i] + beta);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i <= len; i++)
    {
        values[i] = (double)i;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
     		       	  {if (u[i]<=0)
		       	       {*y=0;
			        break;}
     		      	  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=1;i<m*n;i++)
			    {*y=(*y)&(u[i]);}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
			   {y[i]=1;
			    for(j=1;j<nin+1;j++)
				 {u=Getint16InPortPtrs(block,j);
				  if (u[i]<=0) 
				      {y[i]=0;
				       break;}
				 } 
			   }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
			   {u=Getint16InPortPtrs(block,1);
			    y[i]=u[i];
			    for(j=1;j<nin+1;j++)
				 {u=Getint16InPortPtrs(block,j);
				  y[i]=(y[i])&(u[i]);
				 }
			   }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
     		       	  {if (u[i]>0)
		       	       {*y=1;
			        break;}
     		      	  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
			    {*y=(*y)|(u[i]);}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
			   {y[i]=0;
			    for(j=1;j<nin+1;j++)
				 {u=Getint16InPortPtrs(block,j);
				  if (u[i]>0) 
				      {y[i]=1;
				       break;}
				 }
			   }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
			   {y[i]=0;
			    for(j=1;j<nin+1;j++)
				 {u=Getint16InPortPtrs(block,j);
				  y[i]=(y[i])|(u[i]);
				 }
			   }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
     		       	  {if (u[i]<=0)
		       	       {*y=1;
			        break;}
     		      	  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=1;i<m*n;i++)
			    {*y=((*y)&(u[i]));}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
			   {y[i]=0;
			    for(j=1;j<nin+1;j++)
				 {u=Getint16InPortPtrs(block,j);
				  if (u[i]<=0) 
				      {y[i]=1;
				       break;}
				 } 
			   }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
			   {u=Getint16InPortPtrs(block,1);
			    y[i]=u[i];
			    for(j=2;j<nin+1;j++)
				 {u=Getint16InPortPtrs(block,j);
				  y[i]=((y[i])&(u[i]));
				 }
			    y[i]=~y[i];
			   }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
     		       	  {if (u[i]>0)
		       	       {*y=0;
			        break;}
     		      	  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
			    {*y=((*y)|(u[i]));}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
			   {y[i]=1;
			    for(j=1;j<nin+1;j++)
				 {u=Getint16InPortPtrs(block,j);
				  if (u[i]>0) 
				      {y[i]=0;
				       break;}
				 }
			   }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
			   {u=Getint16InPortPtrs(block,1);
			    y[i]=u[i];
			    for(j=2;j<nin+1;j++)
				 {u=Getint16InPortPtrs(block,j);
				  y[i]=((y[i])|(u[i]));
				 }
			    y[i]=~y[i];
			   }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
     		       	  {if (u[i]>0)
		       	       {l=(l+1)%2;
			       }
     		      	  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=1;i<m*n;i++)
			    {*y=((*y)^(u[i]));}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
			   {l=0;
			    for(j=1;j<nin+1;j++)
				 {u=Getint16InPortPtrs(block,j);
				  if (u[i]>0) 
				      {l=(l+1)%2;}
				 }
			    y[i]=(short)l;
			   }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
		           {u=Getint16InPortPtrs(block,1);
		           y[i]=u[i];
			   for(j=2;j<nin+1;j++)
				 {u=Getint16InPortPtrs(block,j);
				  y[i]=((y[i])^(u[i]));
				 }
			   }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
		       {if (u[i]>0) y[i]=0;
			else y[i]=1;}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
		       {y[i]=~(u[i]);}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<mu;j++)
	{
		double d=0.;
		int i = 0;
		for(i=0;i<nu;i++)
		{
			int ij = j+i*mu;
			d += *(u + ij);
		}
		*(y+j) = d;
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<ny*mu;++i){
     D=(double)(opar[0])*(double)(u[i]);
     t=D-(double)((int)(D/(k)))*((k));
     if ((t>=k/2)|(-(t)>=k/2))
       {if (t>=0) (t)=(-((k/2))+fabs(t-(double)((int)((t)/((k/2))))*((k/2))));
	else (t)=-(-((k/2))+fabs(t-(double)((int)((t)/((k/2))))*((k/2))));}
     y[i]=(char)t;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(l=0;l<ny;l++)
	 {for(j=0;j<my;j++)
	      {D=0;
		   jl=j+l*my;
	       for(i=0;i<mu;i++)
		   {ji=j+i*my;
		    
		    il=i+l*mu;
		    C=(double)(opar[ji])*(double)(u[il]);
		    D=D + C;}
		    t=D-(double)((int)(D/(k)))*((k));
		    if ((t>=k/2)|(-(t)>=k/2))
		       {if (t>=0) (t)=(-((k/2))+fabs(t-(double)((int)((t)/((k/2))))*((k/2))));
			else (t)=-(-((k/2))+fabs(t-(double)((int)((t)/((k/2))))*((k/2))));}
		    y[jl]=(char)t;
		  }
	     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<block->insz[0];++i)
		{
			if (get_phase_simulation()==1||block->ng==0) 
			{
				if (block->inptr[0][i]<0)
				{
					j=2;
				} else if (block->inptr[0][i]>0)
				{
					j=1;
				}
				else
				{
					j=0;
				}
			}
			else 
			{
				j=block->mode[i];
			}
			if (j==1){
				block->outptr[0][i]=1.0;
			}
			else if(j==2)
			{
				block->outptr[0][i]=-1.0;
			}
			else
			{
				block->outptr[0][i]=0.0;
			}
		}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<block->insz[0];++i)
		{
			block->g[i]=block->inptr[0][i];
			if (get_phase_simulation()==1) 
			{
				if(block->g[i]<0)
				{
					block->mode[i]=2;
				}
				else
				{
					block->mode[i]=1;
				}
			}
		}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < block->insz[0]; j++)
            {
                result = pushData(block, j);
                if (result == FALSE)
                {
                    Coserror("%s: unable to push some data.", "cscopxy3d");
                    break;
                }
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < block->insz[0]; i++)
        {
            sco->internal.coordinates[i] = (double *)CALLOC(3 * block->ipar[2], sizeof(double));

            if (sco->internal.coordinates[i] == NULL)
            {
                goto error_handler_coordinates_i;
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < i; j++)
    {
        FREE(sco->internal.coordinates[i]);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < block->insz[0]; i++)
        {
            FREE(sco->internal.coordinates[i]);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < block->insz[0]; i++)
        {
            FREE(sco->scope.cachedPolylinesUIDs[i]);
            sco->scope.cachedPolylinesUIDs[i] = NULL;
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < block->insz[0]; i++)
        {
            memmove(sco->internal.coordinates[i], sco->internal.coordinates[i] + 1, setLen * sizeof(double));
            sco->internal.coordinates[i][setLen] = x[i];

            memmove(sco->internal.coordinates[i] + maxNumberOfPoints, sco->internal.coordinates[i] + maxNumberOfPoints + 1, setLen * sizeof(double));
            sco->internal.coordinates[i][maxNumberOfPoints + setLen] = y[i];

            memmove(sco->internal.coordinates[i] + 2 * maxNumberOfPoints, sco->internal.coordinates[i] + 2 * maxNumberOfPoints + 1, setLen * sizeof(double));
            sco->internal.coordinates[i][2 * maxNumberOfPoints + setLen] = z[i];
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < block->insz[0]; i++)
        {
            for(setLen = maxNumberOfPoints - numberOfPoints - 1; setLen >= 0; setLen--)
            {
                sco->internal.coordinates[i][numberOfPoints + setLen] = x[i];
            }

            for(setLen = maxNumberOfPoints - numberOfPoints - 1; setLen >= 0; setLen--)
            {
                sco->internal.coordinates[i][maxNumberOfPoints + numberOfPoints + setLen] = y[i];
            }

            for(setLen = maxNumberOfPoints - numberOfPoints - 1; setLen >= 0; setLen--)
            {
                sco->internal.coordinates[i][2 * maxNumberOfPoints + numberOfPoints + setLen] = z[i];
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < block->insz[0]; i++)
        {
            getPolyline(pAxe, block, i);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<*ipar;i++)
       {n=(long)pow(2,maxim-1-i);
        ref=ref+n;}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < *nu ; i++ ) 
	{
		if ( u[i] < 0 ) 
		{
			y[i] = Min(0.00, u[i] + rpar[i] / 2.00);
		}
		else  
		{
			y[i] = Max(0.00, u[i] - rpar[i] / 2.00);
		}
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=1;j< block->insz[0]+1;j++)
		{
			pw[block->ipar[0]*j]=block->rpar[1];
		}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=1;i< block->ipar[0];i++)
		{
			pw[i]=pw[i-1]+block->rpar[0]-eps;
			for(j=1;j< block->insz[0]+1;j++)
			{
				pw[i+block->ipar[0]*j]=block->rpar[1];
			}
		}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k=0;k<block->insz[0];k++)
		{
			block->outptr[0][k]=block->rpar[1];
		}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=1;j< block->insz[0]+1;j++){
				pw[*iw +block->ipar[0]*j]=block->inptr[0][j-1];
			}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=1;j< block->insz[0]+1;j++)
			{
				pw[(block->ipar[0]+*iw-1)%block->ipar[0] +block->ipar[0]*j]=block->inptr[0][j-1];
			}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k=1;k<block->insz[0]+1;k++)
			{
				block->outptr[0][k-1]=((pw[j]-td)*pw[i+block->ipar[0]*k] +
					(td-pw[i])*pw[j+block->ipar[0]*k])/del;
			}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k=1;k<block->insz[0]+1;k++)
			{
				block->outptr[0][k-1]=pw[i+block->ipar[0]*k];
			}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<mu*nu;i++) 
	{*(yr+i)=*(ur+i);
	 *(yi+i)=*(ui+i);}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<nu;j++)
	{for(i=j+1;i<mu;i++)
		{ij=i+j*mu;
		 *(yr+ij)=0;
		 *(yi+ij)=0;}}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<ny*mu;++i){
     D=(double)(opar[0])*(double)(u[i]);
     t=D-(double)((int)(D/(k)))*((k));
     if ((t>=k/2)|(-(t)>=k/2))
	 {if (t>=0) (t)=(-((k/2))+fabs(t-(double)((int)((t)/((k/2))))*((k/2))));
	  else (t)=-(-((k/2))+fabs(t-(double)((int)((t)/((k/2))))*((k/2))));}
     y[i]=(short)t;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(l=0;l<ny;l++)
	 {for(j=0;j<my;j++)
	      {D=0;
	       jl=j+l*my;
	       for(i=0;i<mu;i++)
		   {ji=j+i*my;
		    
		    il=i+l*mu;
		    C=(double)(opar[ji])*(double)(u[il]);
		    D=D + C;}
		    t=D-(double)((int)(D/(k)))*((k));
		    if ((t>=k/2)|(-(t)>=k/2))
		       {if (t>=0) (t)=(-((k/2))+fabs(t-(double)((int)((t)/((k/2))))*((k/2))));
			else (t)=-(-((k/2))+fabs(t-(double)((int)((t)/((k/2))))*((k/2))));}
		    y[jl]=(short)t;
		  }
	     }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<*nout;i++)
		{
			mu=(int) record[i];

			mu=255-mu;
			if(mu>127)
				sig=1;
			else
				sig=0;
			




			quot=mu/16;rem=mu-16*quot;
			e=quot-8*sig+1;
			f=rem;

			y=ldexp((double)(f),(e+2));
			


			e=ETAB[e-1];

			y=SCALE*(1-2*sig)*(e+y);

			*outptr[i]=y;
		}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=2;i>=0;i--)
					if (type[i]!=' ') 
					{
						type[i+1]='\0';break;
					}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=2;i>=0;i--)
				if (type[i]!=' ') 
				{
					type[i+1]='\0';break;
				}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=2;i>=0;i--)
			if (type[i]!=' ') 
			{ 
				type[i+1]='\0';break;
			}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++) *(y+i)=((*(u+i))&(*opar));



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<*ipar;i++)
       {n=(long)pow(2,i);
        ref=ref+n;}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(l=0;l<nu2;l++)
	    {for(j=0;j<mu1;j++)
	        {D=0;
	        jl=j+l*mu1;
	        for(i=0;i<nu1;i++)
		   {ji=j+i*mu1;
		    
		    il=i+l*nu1;
		    C=(double)(u1[ji])*(double)(u2[il]);
		    D=D + C;}
		    if ((D>((k/2)-1)) |(D<-((k/2))))
		        {sciprint(_("overflow error"));
			 set_block_error(-4);
			 return;}
		    else {y[jl]=(char)(D);}
		    }
		 }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<block->outsz[0];++i)
		{
			block->outptr[0][i]=block->inptr[0][0];
		}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<nu*my;++i)
        {
            y[i]=rpar[0]*u[i];
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<nu*mu;j++) 
			{
				v=v+(double)u[j];
			}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<nu*mu;j++) 
			{
				v=0;
				for(k=0;k<nin;k++) 
				{
					u=Getuint32InPortPtrs(block,k+1);
					if(ipar[k]>0)
					{
						v=v+(double)u[j];
					}
					else
					{
						v=v-(double)u[j];}
				}
				if (v>=l)  v=l-1;
				else if (v<0) v=0;
				y[j]=(unsigned long)v;
			}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < block->insz[0]; j++)
            {
                result = pushData(block, j);
                if (result == FALSE)
                {
                    Coserror("%s: unable to push some data.", "cscopxy");
                    break;
                }
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < block->insz[0]; i++)
        {
            sco->internal.coordinates[i] = (double *)CALLOC(3 * block->ipar[2], sizeof(double));
            if (sco->internal.coordinates[i] == NULL)
            {
                goto error_handler_coordinates_i;
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < i; j++)
    {
        FREE(sco->internal.coordinates[i]);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < block->insz[0]; i++)
        {
            FREE(sco->internal.coordinates[i]);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < block->insz[0]; i++)
        {
            FREE(sco->scope.cachedPolylinesUIDs[i]);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < block->insz[0]; i++)
    {
        ptr = (double *)REALLOC(sco->internal.coordinates[i], 3 * numberOfPoints * sizeof(double));
        if (ptr == NULL)
        {
            goto error_handler;
        }

        // clear the last points, the Z-axis values
        memset(ptr + 2 * numberOfPoints, 0, numberOfPoints * sizeof(double));

        // memcpy existing Y-axis values (use memmove to handle memory overlapping)
        memmove(ptr + numberOfPoints, ptr + previousNumberOfPoints, previousNumberOfPoints * sizeof(double));

        // then set the last points to the last values for Y-axis and X-axis values
        for(setLen = newPoints - 1; setLen >= 0; setLen--)
        {
            ptr[numberOfPoints + previousNumberOfPoints + setLen] = ptr[numberOfPoints + previousNumberOfPoints - 1];
        }
        for(setLen = newPoints - 1; setLen >= 0; setLen--)
        {
            ptr[previousNumberOfPoints + setLen] = ptr[previousNumberOfPoints - 1];
        }

        sco->internal.coordinates[i] = ptr;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < block->insz[0]; i++)
        {
            for(setLen = maxNumberOfPoints - numberOfPoints - 1; setLen >= 0; setLen--)
            {
                sco->internal.coordinates[i][numberOfPoints + setLen] = x[i];
            }

            for(setLen = maxNumberOfPoints - numberOfPoints - 1; setLen >= 0; setLen--)
            {
                sco->internal.coordinates[i][maxNumberOfPoints + numberOfPoints + setLen] = y[i];
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < block->insz[0]; i++)
        {
            getPolyline(pAxe, block, i);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(l=0;l<nu2;l++)
	    {for(j=0;j<mu1;j++)
	        {D=0;
	         jl=j+l*mu1;
	        for(i=0;i<nu1;i++)
		   {ji=j+i*mu1;
		   
		    il=i+l*nu1;
		    C=(double)(u1[ji])*(double)(u2[il]);
		    D=D + C;}
		    if ((D)>((k/2)-1))
		        {y[jl]=(long)((k/2)-1);}
		    else if ((D)<-((k/2)))
			{y[jl]=-(long)((k/2));}
		    else {y[jl]=(long)(D);}
		    }
		 }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<nu*mu;j++) 
			{
				y[0]=y[0]+u[j];
			}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<nu*mu;j++) 
			{
				y[j]=0;
				for(k=0;k<nin;k++) 
				{
					u=Getuint8InPortPtrs(block,k+1);
					if(ipar[k]>0)
					{
						y[j]=y[j]+u[j];
					}
					else
					{
						y[j]=y[j]-u[j];}
				}
			}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<(mu*nu);i++)   
		{
			ptr->LA[2*i]=ur[i];
			ptr->LA[2*i+1]=ui[i];
		}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<Min(mu,nu);i++)  
		{
			if (*(ptr->LSV+i)!=0)
			{
				*(ptr->LSW+i)=1/(*(ptr->LSV+i));
			}
			else
			{
				*(ptr->LSW+i)=0;
			}
		}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<Min(mu,nu);i++)
		{
			ii=i+i*nu;
			*(ptr->LSr+ii)=*(ptr->LSW+i);}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<nu;j++)
		{
			for(i=j;i<nu;i++)
			{
				ij=i+j*nu;
				ji=j+i*nu;
				*(ptr->LVr+ij)=*(ptr->LVT+2*ji);
				*(ptr->LVr+ji)=*(ptr->LVT+2*ij);
				*(ptr->LVi+ij)=-(*(ptr->LVT+2*ji+1));
				*(ptr->LVi+ji)=-(*(ptr->LVT+2*ij+1));
			}
		}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<mu;j++)
		{
			for(i=j;i<mu;i++)
			{
				ij=i+j*mu;
				ji=j+i*mu;
				*(ptr->LUr+ij)=*(ptr->LU+2*ji);
				*(ptr->LUr+ji)=*(ptr->LU+2*ij);
				*(ptr->LUi+ij)=-(*(ptr->LU+2*ji+1));
				*(ptr->LUi+ji)=-(*(ptr->LU+2*ij+1));
			}
		}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<numb;i++)
       {n=(short)pow(2,*ipar+i);
        ref=ref+n;}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<mu*mu;i++) 
	{
		*(yr+i)=0;
		*(yi+i)=0;
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<mu;i++)     
	{
		int ii=i+i*mu;
		*(yr+ii)=*(u1r+i);
		*(yi+ii)=*(u1i+i);
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<nu*mu;j++) 
			{
				v=v+(double)u[j];
			}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<nu*mu;j++) 
			{
				v=0;
				for(k=0;k<nin;k++) 
				{
					u=Getuint8InPortPtrs(block,k+1);
					if(ipar[k]>0)
					{
						v=v+(double)u[j];
					}
					else
					{
						v=v-(double)u[j];}
				}
				if (v>=l)  v=l-1;
				else if (v<0) v=0;
				y[j]=(unsigned char)v;
			}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<nu*mu;j++) 
			{
				v=v+(double)u[j];
			}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<nu*mu;j++) 
			{
				v=0;
				for(k=0;k<nin;k++) 
				{
					u=Getint16InPortPtrs(block,k+1);
					if(ipar[k]>0)
					{
						v=v+(double)u[j];
					}
					else
					{
						v=v-(double)u[j];
					}
				}
				if (v>=l)  v=l-1;
				else if (v<-l) v=-l;
				y[j]=(short)v;
			}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<mu*nu;i++) *(y+i)=0;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<nu;j++)
	{for(i=j;i<mu;i++)
		{ij=i+j*mu;
		 *(y+ij)=*(u+ij);
		}}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<*ipar;i++)
       {n=(short)pow(2,i);
        ref=ref+n;}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<nz;i++) 
		{
			ptr_d[i]=-1;
		}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<nu*nu2*nz;i++) 
			{
				ptr_d[i] = 0.;
			}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<2*nu*nu2*nz;i++) 
			{
				ptr_d[i] = 0.;
			}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<nu*nu2*nz;i++) 
			{
				ptr_c[i] = 0;
			}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<nu*nu2*nz;i++) 
			{
				ptr_s[i] = 0;
			}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<nu*nu2*nz;i++) 
			{
				ptr_l[i] = 0;
			}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<nu*nu2*nz;i++) 
			{
				ptr_uc[i] = 0;
			}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<nu*nu2*nz;i++) 
			{
				ptr_us[i] = 0;
			}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<nu*nu2*nz;i++) 
			{
				ptr_ul[i] = 0;
			}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<ptr->cnt;j++) 
							{
								*((double *)(&ptr_i[10]) + (j+ptr->cnt)) = \
									*((double *)(&ptr_i[10]) + (j+nz*nu));
							}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<ptr_i[8]-1;i++) 
							{
								for(j=0;j<ptr->cnt;j++) 
								{
									*((double *)(&ptr_i[10]) + (((i+1)*nz)+j-(i+1)*k)) = \
										*((double *)(&ptr_i[10]) + (((i+1)*nz)+j));
								}
							}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<ptr_i[8]-1;i++) 
							{
								for(j=0;j<ptr->cnt;j++) 
								{
									*((double *)(&ptr_i[10]) + (((i+1)*nz)+j-(i+1)*k)) = \
										*((double *)(&ptr_i[10]) + (((i+1)*nz)+j));
									*((double *)(&ptr_i[10]) + (((i+1)*nz)+j-(i+1)*k)+nz*nu) = \
										*((double *)(&ptr_i[10]) + (((i+1)*nz)+j)+nz*nu);
								}
							}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<ptr_i[8]-1;i++) 
							{
								for(j=0;j<ptr->cnt;j++) 
								{
									*((char *)(&ptr_i[10]) + (((i+1)*nz)+j-(i+1)*k)) = \
										*((char *)(&ptr_i[10]) + (((i+1)*nz)+j));
								}
							}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<ptr_i[8]-1;i++) 
							{
								for(j=0;j<ptr->cnt;j++) 
								{
									*((short *)(&ptr_i[10]) + (((i+1)*nz)+j-(i+1)*k)) = \
										*((short *)(&ptr_i[10]) + (((i+1)*nz)+j));
								}
							}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<ptr_i[8]-1;i++) 
							{
								for(j=0;j<ptr->cnt;j++) 
								{
									*((long *)(&ptr_i[10]) + (((i+1)*nz)+j-(i+1)*k)) = \
										*((long *)(&ptr_i[10]) + (((i+1)*nz)+j));
								}
							}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<ptr_i[8]-1;i++) 
							{
								for(j=0;j<ptr->cnt;j++) 
								{
									*((unsigned char *)(&ptr_i[10]) + (((i+1)*nz)+j-(i+1)*k)) = \
										*((unsigned char *)(&ptr_i[10]) + (((i+1)*nz)+j));
								}
							}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<ptr_i[8]-1;i++) 
							{
								for(j=0;j<ptr->cnt;j++) 
								{
									*((unsigned short *)(&ptr_i[10]) + (((i+1)*nz)+j-(i+1)*k)) = \
										*((unsigned short *)(&ptr_i[10]) + (((i+1)*nz)+j));
								}
							}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<ptr_i[8]-1;i++) 
							{
								for(j=0;j<ptr->cnt;j++) 
								{
									*((unsigned long *)(&ptr_i[10]) + (((i+1)*nz)+j-(i+1)*k)) = \
										*((unsigned long *)(&ptr_i[10]) + (((i+1)*nz)+j));
								}
							}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<(nz-ptr->cnt);i++) 
				{
					ptr_i = (int*) ptr->workt;
					sav_t = *((double *)(&ptr_i[10])+(nz-1));
					for(j=(nz-1);j>=1;j--) 
					{
						*((double *)(&ptr_i[10])+j)=*((double *)(&ptr_i[10])+(j-1));
					}
					*((double *)(&ptr_i[10]))=sav_t;
				}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<(nz-ptr->cnt);i++) 
						{
							for(k=0;k<nu*nu2;k++) 
							{
								sav_d[k] = *((double *)(&ptr_i[44])+k+(nz-1)*nu*nu2);
							}
							for(j=(nz-1);j>=1;j--) 
							{
								for(k=0;k<nu*nu2;k++) 
								{
									*((double *)(&ptr_i[44])+k+j*(nu*nu2))=*((double *)(&ptr_i[44])+k+(j-1)*(nu*nu2));
								}
							}
							for(k=0;k<nu*nu2;k++) 
							{
								*((double *)(&ptr_i[44])+k)  = sav_d[k];
							}
						}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<(nz-ptr->cnt);i++) 
						{
							for(k=0;k<nu;k++) 
							{
								sav_d[k] = *((double *)(&ptr_i[10])+k*nz+(nz-1));
							}
							for(j=(nz-1);j>=1;j--) 
							{
								for(k=0;k<nu;k++) 
								{
									*((double *)(&ptr_i[10])+k*nz+j)=*((double *)(&ptr_i[10])+k*nz+j-1);
								}
							}
							for(k=0;k<nu;k++) 
							{
								*((double *)(&ptr_i[10])+k*nz)  = sav_d[k];
							}
						}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<(nz-ptr->cnt);i++) 
						{
							for(k=0;k<nu*nu2;k++) 
							{
								sav_d[k]        = *((double *)(&ptr_i[44])+k+(nz-1)*nu*nu2);
								sav_d[k+nu*nu2] = *((double *)(&ptr_i[44])+k+(nz-1)*nu*nu2+nz*nu*nu2);
							}
							for(j=(nz-1);j>=1;j--) 
							{
								for(k=0;k<nu*nu2;k++) 
								{
									*((double *)(&ptr_i[44])+k+j*(nu*nu2))= \
										*((double *)(&ptr_i[44])+k+(j-1)*(nu*nu2));
									*((double *)(&ptr_i[44])+k+j*(nu*nu2)+nz*nu*nu2)= \
										*((double *)(&ptr_i[44])+k+(j-1)*(nu*nu2)+nz*nu*nu2);
								}
							}
							for(k=0;k<nu*nu2;k++) 
							{
								*((double *)(&ptr_i[44])+k)           = sav_d[k];
								*((double *)(&ptr_i[44])+k+nz*nu*nu2) = sav_d[k+nu*nu2];
							}
						}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<(nz-ptr->cnt);i++) 
						{
							for(k=0;k<nu;k++) 
							{
								sav_d[k]    = *((double *)(&ptr_i[10])+k*nz+(nz-1));
								sav_d[k+nu] = *((double *)(&ptr_i[10])+k*nz+(nz-1)+nz*nu);
							}
							for(j=(nz-1);j>=1;j--) 
							{
								for(k=0;k<nu;k++) 
								{
									*((double *)(&ptr_i[10])+k*nz+j)= \
										*((double *)(&ptr_i[10])+k*nz+j-1);
									*((double *)(&ptr_i[10])+k*nz+j+nz*nu)= \
										*((double *)(&ptr_i[10])+k*nz+j-1+nz*nu);
								}
							}
							for(k=0;k<nu;k++) 
							{
								*((double *)(&ptr_i[10])+k*nz)        = sav_d[k];
								*((double *)(&ptr_i[10])+k*nz+nz*nu)  = sav_d[k+nu];
							}
						}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<(nz-ptr->cnt);i++) 
						{
							for(k=0;k<nu*nu2;k++) 
							{
								sav_c[k] = *((char *)(&ptr_i[44])+k+(nz-1)*nu*nu2);
							}
							for(j=(nz-1);j>=1;j--) 
							{
								for(k=0;k<nu*nu2;k++) 
								{
									*((char *)(&ptr_i[44])+k+j*(nu*nu2))=*((char *)(&ptr_i[44])+k+(j-1)*(nu*nu2));
								}
							}
							for(k=0;k<nu*nu2;k++) 
							{
								*((char *)(&ptr_i[44])+k)  = sav_c[k];
							}
						}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<(nz-ptr->cnt);i++) 
						{
							for(k=0;k<nu;k++) 
							{
								sav_c[k] = *((char *)(&ptr_i[10])+k*nz+(nz-1));
							}
							for(j=(nz-1);j>=1;j--) 
							{
								for(k=0;k<nu;k++) 
								{
									*((char *)(&ptr_i[10])+k*nz+j)=*((char *)(&ptr_i[10])+k*nz+j-1);
								}
							}
							for(k=0;k<nu;k++) 
							{
								*((char *)(&ptr_i[10])+k*nz)  = sav_c[k];
							}
						}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<(nz-ptr->cnt);i++) 
						{
							for(k=0;k<nu*nu2;k++) 
							{
								sav_s[k] = *((short *)(&ptr_i[44])+k+(nz-1)*nu*nu2);
							}
							for(j=(nz-1);j>=1;j--) 
							{
								for(k=0;k<nu*nu2;k++) 
								{
									*((short *)(&ptr_i[44])+k+j*(nu*nu2))=*((short *)(&ptr_i[44])+k+(j-1)*(nu*nu2));
								}
							}
							for(k=0;k<nu*nu2;k++) 
							{
								*((short *)(&ptr_i[44])+k)  = sav_s[k];
							}
						}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<(nz-ptr->cnt);i++) 
						{
							for(k=0;k<nu;k++) 
							{
								sav_s[k] = *((short *)(&ptr_i[10])+k*nz+(nz-1));
							}
							for(j=(nz-1);j>=1;j--) 
							{
								for(k=0;k<nu;k++) 
								{
									*((short *)(&ptr_i[10])+k*nz+j)=*((short *)(&ptr_i[10])+k*nz+j-1);
								}
							}
							for(k=0;k<nu;k++) 
							{
								*((short *)(&ptr_i[10])+k*nz)  = sav_s[k];
							}
						}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<(nz-ptr->cnt);i++) 
						{
							for(k=0;k<nu*nu2;k++) 
							{
								sav_l[k] = *((long *)(&ptr_i[44])+k+(nz-1)*nu*nu2);
							}
							for(j=(nz-1);j>=1;j--) 
							{
								for(k=0;k<nu*nu2;k++) 
								{
									*((long *)(&ptr_i[44])+k+j*(nu*nu2))=*((long *)(&ptr_i[44])+k+(j-1)*(nu*nu2));
								}
							}
							for(k=0;k<nu*nu2;k++) 
							{
								*((long *)(&ptr_i[44])+k)  = sav_l[k];
							}
						}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<(nz-ptr->cnt);i++) 
						{
							for(k=0;k<nu;k++) 
							{
								sav_l[k] = *((long *)(&ptr_i[10])+k*nz+(nz-1));
							}
							for(j=(nz-1);j>=1;j--) 
							{
								for(k=0;k<nu;k++) 
								{
									*((long *)(&ptr_i[10])+k*nz+j)=*((long *)(&ptr_i[10])+k*nz+j-1);
								}
							}
							for(k=0;k<nu;k++) 
							{
								*((long *)(&ptr_i[10])+k*nz)  = sav_l[k];
							}
						}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<(nz-ptr->cnt);i++) 
						{
							for(k=0;k<nu*nu2;k++) 
							{
								sav_uc[k] = *((unsigned char *)(&ptr_i[44])+k+(nz-1)*nu*nu2);
							}
							for(j=(nz-1);j>=1;j--) 
							{
								for(k=0;k<nu*nu2;k++) 
								{
									*((unsigned char *)(&ptr_i[44])+k+j*(nu*nu2))=*((unsigned char *)(&ptr_i[44])+k+(j-1)*(nu*nu2));
								}
							}
							for(k=0;k<nu*nu2;k++) 
							{
								*((unsigned char *)(&ptr_i[44])+k)  = sav_uc[k];
							}
						}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<(nz-ptr->cnt);i++) 
						{
							for(k=0;k<nu;k++) 
							{
								sav_uc[k] = *((unsigned char *)(&ptr_i[10])+k*nz+(nz-1));
							}
							for(j=(nz-1);j>=1;j--) 
							{
								for(k=0;k<nu;k++) 
								{
									*((unsigned char *)(&ptr_i[10])+k*nz+j)=*((unsigned char *)(&ptr_i[10])+k*nz+j-1);
								}
							}
							for(k=0;k<nu;k++) 
							{
								*((unsigned char *)(&ptr_i[10])+k*nz)  = sav_uc[k];
							}
						}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<(nz-ptr->cnt);i++) 
						{
							for(k=0;k<nu*nu2;k++) 
							{
								sav_us[k] = *((unsigned short *)(&ptr_i[44])+k+(nz-1)*nu*nu2);
							}
							for(j=(nz-1);j>=1;j--) 
							{
								for(k=0;k<nu*nu2;k++) 
								{
									*((unsigned short *)(&ptr_i[44])+k+j*(nu*nu2))=*((unsigned short *)(&ptr_i[44])+k+(j-1)*(nu*nu2));
								}
							}
							for(k=0;k<nu*nu2;k++) 
							{
								*((unsigned short *)(&ptr_i[44])+k)  = sav_us[k];
							}
						}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<(nz-ptr->cnt);i++) 
						{
							for(k=0;k<nu;k++) 
							{
								sav_us[k] = *((unsigned short *)(&ptr_i[10])+k*nz+(nz-1));
							}
							for(j=(nz-1);j>=1;j--) 
							{
								for(k=0;k<nu;k++) 
								{
									*((unsigned short *)(&ptr_i[10])+k*nz+j)=*((unsigned short *)(&ptr_i[10])+k*nz+j-1);
								}
							}
							for(k=0;k<nu;k++) 
							{
								*((unsigned short *)(&ptr_i[10])+k*nz)  = sav_us[k];
							}
						}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<(nz-ptr->cnt);i++) 
						{
							for(k=0;k<nu*nu2;k++) 
							{
								sav_ul[k] = *((unsigned long *)(&ptr_i[44])+k+(nz-1)*nu*nu2);
							}
							for(j=(nz-1);j>=1;j--) 
							{
								for(k=0;k<nu*nu2;k++) 
								{
									*((unsigned long *)(&ptr_i[44])+k+j*(nu*nu2))=*((unsigned long *)(&ptr_i[44])+k+(j-1)*(nu*nu2));
								}
							}
							for(k=0;k<nu*nu2;k++) 
							{
								*((unsigned long *)(&ptr_i[44])+k)  = sav_ul[k];
							}
						}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<(nz-ptr->cnt);i++) 
						{
							for(k=0;k<nu;k++) 
							{
								sav_ul[k] = *((unsigned long *)(&ptr_i[10])+k*nz+(nz-1));
							}
							for(j=(nz-1);j>=1;j--) 
							{
								for(k=0;k<nu;k++) 
								{
									*((unsigned long *)(&ptr_i[10])+k*nz+j)=*((unsigned long *)(&ptr_i[10])+k*nz+j-1);
								}
							}
							for(k=0;k<nu;k++) 
							{
								*((unsigned long *)(&ptr_i[10])+k*nz)  = sav_ul[k];
							}
						}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<nu*nu2;i++) 
				{
					ptr_d[ptr->cnt*(nu*nu2)+i] = u_d[i];
				}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<nu*nu2;i++) 
				{
					ptr_d[ptr->cnt+i*nz] = u_d[i];
				}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<nu*nu2;i++) 
				{
					ptr_d[ptr->cnt*(nu*nu2)+i] = u_d[i];
					ptr_d[nz*nu*nu2+ptr->cnt*(nu*nu2)+i] = u_cd[i];
				}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<nu;i++) 
				{
					ptr_d[ptr->cnt+i*nz]       = u_d[i];
					ptr_d[nz*nu+ptr->cnt+i*nz] = u_cd[i];
				}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<nu*nu2;i++) 
				{
					ptr_c[ptr->cnt*(nu*nu2)+i] = u_c[i];
				}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<nu;i++) 
				{
					ptr_c[ptr->cnt+i*nz] = u_c[i];
				}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<nu*nu2;i++) 
				{
					ptr_s[ptr->cnt*(nu*nu2)+i] = u_s[i];
				}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<nu;i++) 
				{
					ptr_s[ptr->cnt*nu+i*nz] = u_s[i];
				}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<nu*nu2;i++) 
				{
					ptr_l[ptr->cnt*(nu*nu2)+i] = u_l[i];
				}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<nu;i++) 
				{
					ptr_l[ptr->cnt+i*nz] = u_l[i];
				}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<nu*nu2;i++) 
				{
					ptr_uc[ptr->cnt*(nu*nu2)+i] = u_uc[i];
				}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<nu;i++) 
				{
					ptr_uc[ptr->cnt+i*nz] = u_uc[i];
				}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<nu*nu2;i++) 
				{
					ptr_us[ptr->cnt*(nu*nu2)+i] = u_us[i];
				}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<nu;i++) 
				{
					ptr_us[ptr->cnt+i*nz] = u_us[i];
				}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<nu*nu2;i++) 
				{
					ptr_ul[ptr->cnt*(nu*nu2)+i] = u_ul[i];
				}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<nu;i++) 
				{
					ptr_ul[ptr->cnt+i*nz]=u_ul[i];
				}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<maxim/2;i++)
       {n=(unsigned short)pow(2,maxim/2+i);
        ref=ref+n;}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<mu;j++)
	{
		double dr = 0.;
		double di = 0.;
		int i = 0;
		for(i=0;i<nu;i++)
		{
			int ij=j+i*mu;
			dr+=*(ur+ij);
			di+=*(ui+ij);
		}
		*(yr+j)=dr;
		*(yi+j)=di;
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<maxim/2;i++)
       {n=(char)pow(2,maxim/2+i);
        ref=ref+n;}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<mu*nu;i++) 
	{
		*(y1r+i)=(*(u1+i))*(cos(*(u2+i)));
		*(y1i+i)=(*(u1+i))*(sin(*(u2+i)));
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<mu*nu;i++) 
	{
		*(y1+i)=pow((pow(*(u1r+i),2)+pow(*(u1i+i),2)),0.5);
		*(y2+i)=atan2(*(u1i+i),*(u1r+i));
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++) *(y+i) = (short)block->mode[i]-1;}



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++) y[i]=0;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
				{
					if (u1[i]==u2[i]) y[i]=1;
				}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
				{
					if (u1[i]!=u2[i]) y[i]=1;
				}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
				{
					if (u1[i]<u2[i]) y[i]=1;
				}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
				{
					if (u1[i]<=u2[i]) y[i]=1;
				}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
				{
					if (u1[i]>u2[i]) y[i]=1;
				}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
				{
					if (u1[i]>=u2[i]) y[i]=1;
				}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++) block->g[i]=*(u1+i)-*(u2+i);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++) block->mode[i]=(int)1;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
				{
					if (u1[i]==u2[i]) block->mode[i]=(int)2;
				}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
				{
					if (u1[i]!=u2[i]) block->mode[i]=(int)2;
				}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
				{
					if (u1[i]<u2[i]) block->mode[i]=(int)2;
				}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
				{
					if (u1[i]<=u2[i]) block->mode[i]=(int)2;
				}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
				{
					if (u1[i]>u2[i]) block->mode[i]=(int)2;
				}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
				{
					if (u1[i]>=u2[i]) block->mode[i]=(int)2;
				}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<(mu*nu1);i++)   
		{
			ptr->IN1[2*i]=u1r[i];
			ptr->IN1[2*i+1]=u1i[i];
		}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<(mu*nu2);i++)   
		{
			ptr->IN2[2*i]=u2r[i];
			ptr->IN2[2*i+1]=u2i[i];
		}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<(mu*nu2);i++)
					{*(yr+i)=*(ptr->IN2+2*i);
					*(yi+i)=*(ptr->IN2+(2*i)+1);}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<nu1;i++)    *(ptr->jpvt+i)=0;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<wu;j++)
		{
			for(i=0;i<vu;i++)
			{
				ij=i+j*l;
				*(yr+k)=*(ptr->IN2X+2*ij);
				*(yi+k)=*(ptr->IN2X+(2*ij)+1);
				k++;
			}
		}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++) 
		        {v=(double)u[i];
		         w=v-(double)((int)(v/k))*k;
		         if (fabs(w)>k/2-1)
			     {if (w>=0) w=(-k/2+fabs(w-(double)((int)(w/(k/2)))*(k/2)));
			     else w=-(-(k/2)+fabs(w-(double)((int)(w/(k/2)))*(k/2)));
			     }
		         y[i]=(long)w;}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++) 
		        {v=(double)u[i];
		         w=v-(double)((int)(v/k))*k;
		         if (fabs(w)>k/2-1)
			     {if (w>=0) w=(-k/2+fabs(w-(double)((int)(w/(k/2)))*(k/2)));
			     else w=-(-(k/2)+fabs(w-(double)((int)(w/(k/2)))*(k/2)));
			     }
		         y[i]=(short)w;}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++) 
		        {v=(double)u[i];
		         w=v-(double)((int)(v/k))*k;
		         if (fabs(w)>k/2-1)
			     {if (w>=0) w=(-k/2+fabs(w-(double)((int)(w/(k/2)))*(k/2)));
			     else w=-(-(k/2)+fabs(w-(double)((int)(w/(k/2)))*(k/2)));
			     }
		         y[i]=(char)w;}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++) 
		        {v=(double)u[i];
		         w=v-(double)((int)(v/k))*k;
		         y[i]=(unsigned long)w;}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++) 
		        {v=(double)u[i];
		         w=v-(double)((int)(v/k))*k;
		         y[i]=(unsigned short)w;}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++) 
		        {v=(double)u[i];
		         w=v-(double)((int)(v/k))*k;
		         y[i]=(unsigned char)w;}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++) y[i]=(double) u[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++) 
		        {v=(double)u[i];
		         w=v-(double)((int)(v/k))*k;
		         if (fabs(w)>k/2-1)
			     {if (w>=0) w=(-k/2+fabs(w-(double)((int)(w/(k/2)))*(k/2)));
			     else w=-(-(k/2)+fabs(w-(double)((int)(w/(k/2)))*(k/2)));
			     }
		         y[i]=(short)w;}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++) 
		        {v=(double)u[i];
		         w=v-(double)((int)(v/k))*k;
		         if (fabs(w)>k/2-1)
			     {if (w>=0) w=(-k/2+fabs(w-(double)((int)(w/(k/2)))*(k/2)));
			     else w=-(-(k/2)+fabs(w-(double)((int)(w/(k/2)))*(k/2)));
			     }
		         y[i]=(char)w;}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++) 
		        {v=(double)u[i];
		         w=v-(double)((int)(v/k))*k;
		         y[i]=(unsigned short)w;}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++) 
		        {v=(double)u[i];
		         w=v-(double)((int)(v/k))*k;
		         y[i]=(unsigned char)w;}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++) y[i]=(double) u[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++) 
		        {y[i]=(long)u[i];}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++) 
		        {v=(double)u[i];
		         w=v-(double)((int)(v/k))*k;
		         if (fabs(w)>k/2-1)
			     {if (w>=0) w=(-k/2+fabs(w-(double)((int)(w/(k/2)))*(k/2)));
			     else w=-(-(k/2)+fabs(w-(double)((int)(w/(k/2)))*(k/2)));
			     }
		         y[i]=(char)w;}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++) 
		        {y[i]=(unsigned long)u[i];}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++) 
		        {v=(double)u[i];
		         w=v-(double)((int)(v/k))*k;
		         y[i]=(unsigned char)w;}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++) y[i]=(double) u[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++) 
		        {y[i]=(long)u[i];}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++) 
		        {y[i]=(short)u[i];}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++) 
		        {y[i]=(unsigned long)u[i];}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++) 
		        {y[i]=(unsigned short)u[i];}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++) y[i]=(double) u[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++) 
		        {v=(double)u[i];
		         w=v-(double)((int)(v/k))*k;
		         if ((w)>k/2-1)
			     { w=(-k/2+fabs(w-(double)((int)(w/(k/2)))*(k/2)));
			     }
		         y[i]=(short)w;}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++) 
		        {v=(double)u[i];
		         w=v-(double)((int)(v/k))*k;
		         if ((w)>k/2-1)
			     {w=(-k/2+fabs(w-(double)((int)(w/(k/2)))*(k/2)));
			     }
		         y[i]=(char)w;}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++) 
		        {v=(double)u[i];
		         w=v-(double)((int)(v/k))*k;
		         y[i]=(unsigned short)w;}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++) 
		        {v=(double)u[i];
		         w=v-(double)((int)(v/k))*k;
		         y[i]=(unsigned char)w;}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++) y[i]=(double) u[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++) 
		        {y[i]=(long)u[i];}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++) 
		        {v=(double)u[i];
		         w=v-(double)((int)(v/k))*k;
		         if (w>k/2-1)
			     {w=(-k/2+fabs(w-(double)((int)(w/(k/2)))*(k/2)));
			     }
		         y[i]=(char)w;}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++) 
		        {y[i]=(unsigned long)u[i];}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++) 
		        {v=(double)u[i];
		         w=v-(double)((int)(v/k))*k;
		         y[i]=(unsigned char)w;}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++) y[i]=(double) u[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++) 
		        {y[i]=(long)u[i];}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++) 
		        {y[i]=(short)u[i];}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++) 
		        {y[i]=(unsigned long)u[i];}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++) 
		        {y[i]=(unsigned short)u[i];}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
		       {if (u[i]>k/2-1)
		           {y[i]=(long)(k/2-1);}
		        else if (u[i]<-(k/2))
			   {y[i]=-(long)(k/2);}
		        else {y[i]=(long)(u[i]);}
		       }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++) 
		        {if (u[i]>k/2-1)
		           {y[i]=(short)(k/2-1);}
		        else if (u[i]<-(k/2))
			   {y[i]=-(short)(k/2);}
		        else {y[i]=(short)(u[i]);}
		       }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++) 
		        {if (u[i]>k/2-1)
		           {y[i]=(char)(k/2-1);}
		        else if (u[i]<-(k/2))
			   {y[i]=-(char)(k/2);}
		        else {y[i]=(char)(u[i]);}
		       }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++) 
		        {if (u[i]>=k)
		       	     {y[i]=(unsigned long)(k-1);}
		   	else if (u[i]<0)
			     {y[i]=0;}
		   	else {y[i]=(unsigned long)(u[i]);}
		   	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++) 
		        {if (u[i]>=k)
		       	     {y[i]=(unsigned short)(k-1);}
		   	else if (u[i]<0)
			     {y[i]=0;}
		   	else {y[i]=(unsigned short)(u[i]);}
		   	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++) 
		        {if (u[i]>=k)
		       	     {y[i]=(unsigned char)(k-1);}
		   	else if (u[i]<0)
			     {y[i]=0;}
		   	else {y[i]=(unsigned char)(u[i]);}
		   	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++) 
		        {if (u[i]>(long)(k/2-1))
		           {y[i]=(short)(k/2-1);}
		        else if (u[i]<-(long)(k/2))
			   {y[i]=-(short)(k/2);}
		        else {y[i]=(short)(u[i]);}
		       }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++) 
		        {if (u[i]>(long)(k/2-1))
		           {y[i]=(char)(k/2-1);}
		        else if (u[i]<-(long)(k/2))
			   {y[i]=-(char)(k/2);}
		        else {y[i]=(char)(u[i]);}
		       }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++) 
		   	{if (u[i]<0)
			     {y[i]=0;}
		   	else {y[i]=(unsigned long)(u[i]);}
		   	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++) 
		        {if (u[i]>=(long)(k))
		       	     {y[i]=(unsigned short)(k-1);}
		   	else if (u[i]<0)
			     {y[i]=0;}
		   	else {y[i]=(unsigned short)(u[i]);}
		   	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++) 
		        {if (u[i]>=(long)k)
		       	     {y[i]=(unsigned char)(k-1);}
		   	else if (u[i]<0)
			     {y[i]=0;}
		   	else {y[i]=(unsigned char)(u[i]);}
		   	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++) 
		        {if (u[i]>(short)(k/2-1))
		           {y[i]=(char)(k/2-1);}
		        else if (u[i]<-(short)(k/2))
			   {y[i]=-(char)(k/2);}
		        else {y[i]=(char)(u[i]);}
		       }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++) 
		        {if (u[i]<0)  y[i]=0;
			 else y[i]=(unsigned long)u[i];}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++) 
		   	{if (u[i]<0)
			     {y[i]=0;}
		   	else {y[i]=(unsigned short)(u[i]);}
		   	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++) 
		        {if (u[i]>=(short)k)
		       	     {y[i]=(unsigned char)(k-1);}
		   	else if (u[i]<0)
			     {y[i]=0;}
		   	else {y[i]=(unsigned char)(u[i]);}
		   	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++) 
			{if (u[i]<0)  y[i]=0;
			 else y[i]=(unsigned long)u[i];}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++) 
		        {if (u[i]<0)
			     {y[i]=0;}
		   	else {y[i]=(unsigned short)(u[i]);}
		   	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++) 
		   	{if (u[i]<0)
			     {y[i]=0;}
		   	else {y[i]=(unsigned char)(u[i]);}
		   	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++) 
		   	{if (u[i]>(unsigned long)(k/2-1))
			     {y[i]=(long)(k/2-1);}
		   	else {y[i]=(long)(u[i]);}
		   	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++) 
		        {if (u[i]>(unsigned long)(k/2-1))
			     {y[i]=(short)(k/2-1);}
		   	else {y[i]=(short)(u[i]);}
		   	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++) 
		        {if (u[i]>(unsigned long)(k/2-1))
			     {y[i]=(char)(k/2-1);}
		   	else {y[i]=(char)(u[i]);}
		   	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++) 
		        {if (u[i]>(unsigned long)(k/2-1))
			     {y[i]=(unsigned short)(k/2-1);}
		   	else {y[i]=(unsigned short)(u[i]);}
		   	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++) 
		        {if (u[i]>(unsigned long)(k/2-1))
			     {y[i]=(unsigned char)(k/2-1);}
		   	else {y[i]=(unsigned char)(u[i]);}
		   	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++) 
		        {if (u[i]>(unsigned short)(k/2-1))
			     {y[i]=(short)(k/2-1);}
		   	else {y[i]=(short)(u[i]);}
		   	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++) 
		        {if (u[i]>(unsigned short)(k/2-1))
			     {y[i]=(char)(k/2-1);}
		   	else {y[i]=(char)(u[i]);}
		   	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++) 
		        {if (u[i]>(unsigned short)(k/2-1))
			     {y[i]=(unsigned char)k/2-1;}
		   	else {y[i]=(unsigned char)(u[i]);}
		   	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++) 
		        {if (u[i]>(unsigned char)(k/2-1))
			     {y[i]=(char)(k/2-1);}
		   	else {y[i]=(char)(u[i]);}
		   	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
		   {if ((u[i]>k/2-1) | (u[i]<-(k/2)))
		           {if (flag==1)
                               {sciprint(_("overflow error"));
			        set_block_error(-4);
			        return;}}
		        else {y[i]=(long)(u[i]);}
		       }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++) 
		        {if ((u[i]>k/2-1) | (u[i]<-(k/2)))
		           {if (flag==1)
                               {sciprint(_("overflow error"));
			        set_block_error(-4);
			        return;}}
		        else {y[i]=(short)(u[i]);}
		       }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++) 
		        {if ((u[i]>k/2-1) | (u[i]<-(k/2)))
		           {if (flag==1)
                               {sciprint(_("overflow error"));
			        set_block_error(-4);
			        return;}}
		        else {y[i]=(char)(u[i]);}
		       }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++) 
		        {if ((u[i]>=k) | (u[i]<0))
		           {if (flag==1)
                               {sciprint(_("overflow error"));
			        set_block_error(-4);
			        return;}}
		   	else {y[i]=(unsigned long)(u[i]);}
		   	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++) 
		        {if ((u[i]>=k) | (u[i]<0))
		       	    {if (flag==1)
                               {sciprint(_("overflow error"));
			        set_block_error(-4);
			        return;}}
		   	else {y[i]=(unsigned short)(u[i]);}
		   	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++) 
		        {if ((u[i]>=k) | (u[i]<0))
		       	    {if (flag==1)
                               {sciprint(_("overflow error"));
			        set_block_error(-4);
			        return;}}
		   	else {y[i]=(unsigned char)(u[i]);}
		   	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++) 
		        {if ((u[i]>k/2-1) | (u[i]<-(k/2)))
		            {if (flag==1)
                               {sciprint(_("overflow error"));
			        set_block_error(-4);
			        return;}}
		        else {y[i]=(short)(u[i]);}
		       }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++) 
		        {if ((u[i]>k/2-1) | (u[i]<-(k/2)))
		            {if (flag==1)
                               {sciprint(_("overflow error"));
			        set_block_error(-4);
			        return;}}
		        else {y[i]=(char)(u[i]);}
		       }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++) 
		   	{if (u[i]<0)
			    {if (flag==1)
                               {sciprint(_("overflow error"));
			        set_block_error(-4);
			        return;}}
		   	else {y[i]=(unsigned long)(u[i]);}
		   	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++) 
		        {if ((u[i]>=k) | (u[i]<0))
		       	    {if (flag==1)
                               {sciprint(_("overflow error"));
			        set_block_error(-4);
			        return;}}
		   	else {y[i]=(unsigned short)(u[i]);}
		   	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++) 
		        {if ((u[i]>=k) | (u[i]<0))
		       	    {if (flag==1)
                               {sciprint(_("overflow error"));
			        set_block_error(-4);
			        return;}}
		   	else {y[i]=(unsigned char)(u[i]);}
		   	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++) 
		        {if ((u[i]>k/2-1) | (u[i]<-(k/2)))
		       	    {if (flag==1)
                               {sciprint(_("overflow error"));
			        set_block_error(-4);
			        return;}}
		        else {y[i]=(char)(u[i]);}
		       }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++) 
		        {if (u[i]<0)  
		       	    {if (flag==1)
                               {sciprint(_("overflow error"));
			        set_block_error(-4);
			        return;}}
			 else y[i]=(unsigned long)u[i];}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++) 
		   	{if (u[i]<0)
			    {if (flag==1) 
                                {sciprint(_("overflow error"));
			         set_block_error(-4);
			         return;}}
		   	else {y[i]=(unsigned short)(u[i]);}
		   	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++) 
		        {if (((u[i]>=k) | (u[i]<0))& (flag==1))
		       	    {if (flag==1) 
                                 {sciprint(_("overflow error"));
			          set_block_error(-4);
			          return;}}
		   	else {y[i]=(unsigned char)(u[i]);}
		   	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++) 
			{if (u[i]<0)
		       	    {if (flag==1)
                               {sciprint(_("overflow error"));
			        set_block_error(-4);
			        return;}}
			 else y[i]=(unsigned long)u[i];}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++) 
		        {if (u[i]<0)
		       	    {if (flag==1)
                               {sciprint(_("overflow error"));
			        set_block_error(-4);
			        return;}}
		   	else {y[i]=(unsigned short)(u[i]);}
		   	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++) 
		   	{if (u[i]<0)
		       	    {if (flag==1)
                               {sciprint(_("overflow error"));
			        set_block_error(-4);
			        return;}}
		   	else {y[i]=(unsigned char)(u[i]);}
		   	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++) 
		   	{if (u[i]>(k/2-1))
		       	    {if (flag==1)
                               {sciprint(_("overflow error"));
			        set_block_error(-4);
			        return;}}
		   	else {y[i]=(long)(u[i]);}
		   	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++) 
		        {if (u[i]>(k/2-1))
		       	    {if (flag==1)
                               {sciprint(_("overflow error"));
			        set_block_error(-4);
			        return;}}
		   	else {y[i]=(short)(u[i]);}
		   	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++) 
		        {if (u[i]>(k/2-1))
		       	    {if (flag==1)
                               {sciprint(_("overflow error"));
			        set_block_error(-4);
			        return;}}
		   	else {y[i]=(char)(u[i]);}
		   	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++) 
		        {if (u[i]>(k/2-1))
		       	    {if (flag==1)
                               {sciprint(_("overflow error"));
			        set_block_error(-4);
			        return;}}
		   	else {y[i]=(unsigned short)(u[i]);}
		   	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++) 
		        {if (u[i]>(k/2-1))
		       	    {if (flag==1)
                               {sciprint(_("overflow error"));
			        set_block_error(-4);
			        return;}}
		   	else {y[i]=(unsigned char)(u[i]);}
		   	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++) 
		        {if (u[i]>(k/2-1))
		       	    {if (flag==1)
                               {sciprint(_("overflow error"));
			        set_block_error(-4);
			        return;}}
		   	else {y[i]=(short)(u[i]);}
		   	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++) 
		        {if (u[i]>(k/2-1))
		       	    {if (flag==1)
                               {sciprint(_("overflow error"));
			        set_block_error(-4);
			        return;}}
		   	else {y[i]=(char)(u[i]);}
		   	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++) 
		        {if (u[i]>(k/2-1))
		       	    {if (flag==1)
                               {sciprint(_("overflow error"));
			        set_block_error(-4);
			        return;}}
		   	else {y[i]=(unsigned char)(u[i]);}
		   	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++) 
		        {if (u[i]>(k/2-1))
		       	    {if (flag==1)
                               {sciprint(_("overflow error"));
			        set_block_error(-4);
			        return;}}
		   	else {y[i]=(char)(u[i]);}
		   	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<numb;i++)
       {n=(unsigned char)pow(2,*ipar+i);
        ref=ref+n;}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<nin;i++)
	{
	    u=Getint8InPortPtrs(block,i+1);
	    inp=*u;
	    if (inp>0) inp=1;
	    else inp=0;
	    inp=inp<<i;
	    num=num+inp;
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<nout;i++)
	{
	    y=Getint8OutPortPtrs(block,i+1);
	    *y=*(opar+num+i*mo);
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<nout;i++)
	{
	    y=Getint8OutPortPtrs(block,i+1);
	    *y=*u;
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<mu*nu;i++) y[i]=u[i]>>-ipar[0];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0;j<nu;j++)
	{
		double d = 0.;
		int i = 0;
		for(i=0;i<mu;i++)
		{
			int ij = i + j*mu;
			d += *(u + ij);
		}
		*(y+j) = d;
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
     		      {if (u[i]<=0)
		       	   {*y=0;
			    break;}
     		      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
		       {y[i]=1;
			for(j=1;j<nin+1;j++)
			     {u=GetRealInPortPtrs(block,j);
			      if (u[i]<=0) 
				  {y[i]=0;
				   break;}
			     } 
		       }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
     		      {if (u[i]>0)
		       	   {*y=1;
			    break;}
     		      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
		       {y[i]=0;
			for(j=1;j<nin+1;j++)
			     {u=GetRealInPortPtrs(block,j);
			      if (u[i]>0) 
				  {y[i]=1;
				   break;}
			     }
		       }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
     		      {if (u[i]<=0)
		       	   {*y=1;
			    break;}
     		      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
		       {y[i]=0;
			for(j=1;j<nin+1;j++)
			     {u=GetRealInPortPtrs(block,j);
			      if (u[i]<=0) 
				  {y[i]=1;
				   break;}
			     } 
		       }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
     		      {if (u[i]>0)
		       	   {*y=0;
			    break;}
     		      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
		       {y[i]=1;
			for(j=1;j<nin+1;j++)
			     {u=GetRealInPortPtrs(block,j);
			      if (u[i]>0) 
				  {y[i]=0;
				   break;}
		   	     }
		       }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
     		      {if (u[i]>0)
		       	   {l=(l+1)%2;
			   }
     		      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
		       {l=0;
			for(j=1;j<nin+1;j++)
			     {u=GetRealInPortPtrs(block,j);
			      if (u[i]>0) 
				  {l=(l+1)%2;}
		  	     }
			y[i]=(double)l;
		       }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
		  {if (u[i]>0) y[i]=0;
		   else y[i]=1;}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<mu*nu;i++) 
	{*(yr+i)=0;
	 *(yi+i)=0;}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<Min(mu,nu);i++)     
	{ii=i+i*mu;
 	 *(yr+ii)=*(ur+ii);
	 *(yi+ii)=*(ui+ii);}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<mu*nu;i++) y[i]=exp(log(*rpar)*u[i]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(l=0;l<nu2;l++)
	    {
			int j = 0;
			for(j=0;j<mu1;j++)
	        {
				double D = 0.;
				int jl = j + l*mu1;

				int i = 0;
				for(i=0;i<nu1;i++)
				{
					int ji = j + i*mu1;
		    	    int il = i + l*nu1;
					double C = (double)(u1[ji])*(double)(u2[il]);
					D = D + C;
				}
				if (D>(k-1))
		        {
					y[jl]=(unsigned long)(k-1);
				}
				else if (D<0)
				{
					y[jl]=0;
				}
				else 
				{
					y[jl]=(unsigned long)(D);
				}
			}
		}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<mu*nu;i++)
	{ 
		int j = 0;
		long v=u[i];
		for(j=0;j<ipar[0];j++)
		{
			y[i]=v&k;
			if (y[i]==0)  y[i]=v<<1;
			else 
			{
				y[i]=v<<1;
				y[i]=(y[i])|(1);
			}
			v=y[i];
		}
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(l=0;l<nu2;l++)
	    {
			int j = 0;
			for(j=0;j<mu1;j++)
	        {
				double D = 0.;
				int jl=j+l*mu1;

				int i = 0;
				for(i=0;i<nu1;i++)
				{
					int ji = j + i*mu1;
		   		    int il = i+l*nu1;
					double C = (double)(u1[ji])*(double)(u2[il]);
					D = D + C;
				}

				if ((D)>((k/2)-1))
		        {
					y[jl]=(short)((k/2)-1);
				}
				else if ((D)<-((k/2)))
				{
					y[jl]=-(short)((k/2));
				}
				else 
				{
					y[jl]=(short)(D);
				}
			}
		}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i <= i1; ++i) {
      xd[((i - 1) << 2) + 1] = x[((i - 1) << 2) + 2];
      xd[((i - 1) << 2) + 3] = x[((i - 1) << 2) + 4];
      xd[((i - 1) << 2) + 2] = -c * x[((i - 1) << 2) + 2];
      xd[((i - 1) << 2) + 4] = -rpar[(n << 1) + 5] ;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i <= i1; ++i) {
      y1[i] = x[((i - 1) << 2) + 1];
      y2[i] = x[((i - 1) << 2) + 3];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 1; k <= i1; ++k) {
      i = ipar[((k - 1) << 1) + 1];
      j = ipar[((k - 1) << 1) + 2];
      d1 = x[((i - 1) << 2) + 1] - x[((j - 1) << 2) + 1];
      d2 = x[((i - 1) << 2) + 3] - x[((j - 1) << 2) + 3];
      d3 = rpar[i + n] + rpar[j + n];
      g[k] = d1 * d1 + d2 * d2 - d3 * d3;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i <= i1; ++i) {
      g[k] = x[((i - 1) << 2) + 3] - rpar[i + n] - rpar[(n << 1) + 3];
      ++k;
      g[k] = rpar[(n << 1) + 4] - x[((i - 1) << 2) + 3] - rpar[i + n];
      ++k;
      g[k] = x[((i - 1) << 2) + 1] - rpar[(n << 1) + 1] - rpar[i + n];
      ++k;
      g[k] = rpar[(n << 1) + 2] - rpar[i + n] - x[((i - 1) << 2) + 1];
      ++k;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 1; k <= i1; ++k) {
      if (jroot[k] < 0) {
	i = ipar[((k - 1) << 1) + 1];
	j = ipar[((k - 1) << 1) + 2];
	s1 = x[((j - 1) << 2) + 1] - x[((i - 1) << 2) + 1];
	s2 = -rpar[i] * s1 / rpar[j];
	s3 = x[((j - 1) << 2) + 3] - x[((i - 1) << 2) + 3];
	s4 = -rpar[i] * s3 / rpar[j];
	a = rpar[i] * (s1 * s1 + s3 * s3) + rpar[j] * (s2 * s2 + s4 
						       * s4);
	b = rpar[i] * (s1 * x[((i - 1) << 2) + 2] + s3 * x[((i - 1 )
							  << 2) + 4]) + rpar[j] * (s2 * x[((j - 1) << 2) + 2] + 
										   s4 * x[((j - 1) << 2) + 4]);
	xsi = -(b * 2. / a);
	x[((i - 1) << 2) + 2] += s1 * xsi;
	x[((j - 1) << 2) + 2] += s2 * xsi;
	x[((i - 1) << 2) + 4] += s3 * xsi;
	x[((j - 1) << 2) + 4] += s4 * xsi;
      }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i <= i1; ++i) {
      if (jroot[k] < 0) {
	x[((i - 1) << 2) + 4] = -x[((i - 1) << 2) + 4];
      }
      ++k;
      if (jroot[k] < 0) {
	x[((i - 1) << 2) + 4] = -x[((i - 1) << 2) + 4];
      }
      ++k;
      if (jroot[k] < 0) {
	x[((i - 1) << 2) + 2] = -x[((i - 1) << 2) + 2];
      }
      ++k;
      if (jroot[k] < 0) {
	x[((i - 1) << 2) + 2] = -x[((i - 1) << 2) + 2];
      }
      ++k;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(fieldIndex = 1; fieldIndex < nbFields - 1; fieldIndex++)
    {
      fieldMatVar = Mat_VarGetStructField(matVariable, &fieldIndex, BY_INDEX, 0);
      fieldNames[fieldIndex + 1] = strdup(fieldMatVar->name);
      if (fieldNames[fieldIndex + 1]==NULL)
        {
          Scierror(999, _("%s: No more memory.\n"), "CreateStructVariable");
          return FALSE;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(K=0; K<matVariable->rank; K++)
    {
      prodDims *= matVariable->dims[K];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(fieldIndex = 0; fieldIndex < nbFields - 2; fieldIndex++)
        {
          
          if (!CreateMatlabVariable(iVar, allData[fieldIndex], cell_addr, fieldIndex+3)) 
            {
              if (allData[fieldIndex]->class_type != 0) 
                {
                  sciprint("Do not know how to read a variable of class %d.\n", allData[fieldIndex]->class_type);
                }
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(fieldIndex = 0; fieldIndex < nbFields - 2; fieldIndex++)
        {
	  _SciErr = createListInList(pvApiCtx, iVar, cell_addr, fieldIndex+3, prodDims, &cell_entry_addr); MATIO_ERROR;
          
          for(valueIndex = 0; valueIndex < prodDims; valueIndex++)
            {
              
              if (!CreateMatlabVariable(iVar, allData[(fieldIndex) + (nbFields-2)*valueIndex], cell_entry_addr, valueIndex+1)) 
                {
                  if (allData[(fieldIndex) + (nbFields-2)*valueIndex]->class_type != 0) 
                    {
                      sciprint("Do not know how to read a variable of class %d.\n", allData[(fieldIndex) + (nbFields-2)*valueIndex]->class_type);
                    }
                }
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(K=0; K<sparseData->njc-1; K++)
        {
          colIndexes[K] = sparseData->jc[K+1] - sparseData->jc[K];
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(K=0; K<sparseData->nir; K++)
    {
      rowIndexes[K] = sparseData->ir[K] + 1;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(K=0; K<matVariable->rank; K++)
    {
      prodDims *= matVariable->dims[K];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(valueIndex = 0; valueIndex < prodDims; valueIndex++)
        {
          
          if (!CreateMatlabVariable(iVar, allData[valueIndex], cell_entry_addr, valueIndex+1)) 
            {
              sciprint("Do not know how to read a variable of class %d.\n", allData[valueIndex]->class_type);
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0 ; i < dims[0] * dims[1] ; i++)
            {
                pstData[i] = (char*)MALLOC(sizeof(char) * (piLen[i] + 1)); //+ 1 for null termination
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0 ; i < dims[0] * dims[1] ; i++)
            {
                pstData[i] = (char*)MALLOC(sizeof(char) * (piLen[i] + 1)); //+ 1 for null termination
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0 ; i < dims[0] ; i++)
                {
                    if (piLen[0] != piLen[i])
                    {
                        
                        Scierror(999, _("%s: Column array of strings with different lengths saving is not implemented.\n"), "GetCharVariable");
                        freeArrayOfString(pstData, dims[0]*dims[1]);
                        FREE(dims);
                        FREE(dataAdr);
                        FREE(piLen);
                        return NULL;
                    }
                }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0 ; i < dims[0] ; i++)
                {
                    for(j = 0 ; j < piLen[0] ; j++)
                    {
                        pstMatData[i+j*dims[0]] = pstData[i][j];
                    }
                }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(K=0; K<nbRow; K++)
	{
	  charData[K] =  (char*) MALLOC(sizeof(char*) * (matVariable->dims[1] + 1));
	  if (charData[K]==NULL)
	    {
	      Scierror(999, _("%s: No more memory.\n"), "CreateCharVariable");
	      return FALSE;
	    }
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(K=0; K<matVariable->dims[0]; K++) 
	{
	  for(L=0; L<matVariable->dims[1]; L++) 
	    {
	      if (matVariable->fp->version != MAT_FT_MAT4) 
		{
		  charData[K][L] = ((char *)matVariable->data)[L*matVariable->dims[0]+K];
		}
	      else 
		{
		  charData[K][L] = (char) ((double *)matVariable->data)[L*matVariable->dims[0]+K];
		}
	    }
	  charData[K][L] = '\0';
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(K=0;K<numberOfMatfiles;K++)
            {
              if(openedMatfiles[K]==NULL)
                {
                  openedMatfiles[K] = *matfile;
                  *fileIndex = K;
                  return;
                }
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(K=0;K<numberOfMatfiles;K++)
        {
          if(openedMatfiles[K]!=NULL)
            {
              sciprint("%d -> %s\n", K, openedMatfiles[K]->filename);
            }
          else
            {
              sciprint("%d -> Empty\n", K);
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<nbRow*nbCol; i++) tmp_int8[i] = ((char *)matVariable->data)[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<nbRow*nbCol; i++) tmp_int16[i] = ((short *)matVariable->data)[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<nbRow*nbCol; i++) tmp_int32[i] = ((int *)matVariable->data)[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<nbRow*nbCol; i++) tmp_int64[i] = ((long long *)matVariable->data)[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<nbRow*nbCol; i++) tmp_uint8[i] = ((unsigned char *)matVariable->data)[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<nbRow*nbCol; i++) tmp_uint16[i] = ((unsigned short *)matVariable->data)[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<nbRow*nbCol; i++) tmp_uint32[i] = ((unsigned int *)matVariable->data)[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<nbRow*nbCol; i++) tmp_uint64[i] = ((unsigned long long *)matVariable->data)[i];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(K = 0; K < nbRow*nbCol; K++)
            {
              intPtr[K] = ((unsigned char*)matVariable->data)[K];
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(K = 0; K < nbRow*nbCol; K++)
            {
              dblPtr[K] = ((unsigned char*)matVariable->data)[K];
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(K = 0; K < scilabSparse.m; K++)
        {
            colIndexes[K + 1] = colIndexes[K] + scilabSparse.mnel[K];
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(K = 0; K < scilabSparse.nel; K++)
        {
            rowIndexes[K] = scilabSparse.icol[K] - 1;
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(K = 0; K < scilabSparse.nel; K++)
            {
                data[K] = scilabSparse.R[K];
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(K = 0; K < scilabSparse.nel; K++)
            {
                data[K] = scilabSparse.R[K];
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(K = 0; K < scilabSparse.nel; K++)
            {
                data[K + scilabSparse.nel] = scilabSparse.I[K];
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<nbRow*nbFields;i++)
      	{
      	  fieldNames[i] = (char *)MALLOC((pilen[i]+1)*sizeof(char));
      	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(K=0; K<dimensionsVariable->rank; K++)
    {
        prodDims *= ((int *)dimensionsVariable->data)[K];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(K = 0; K < prodDims*(nbFields-2)+1; K++)
    {
        structEntries[K] = NULL;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(fieldIndex = 2; fieldIndex < nbFields; fieldIndex++)
        {
            structEntries[fieldIndex - 2] = GetMatlabVariable(iVar ,fieldNames[fieldIndex], matfile_version, var_addr, fieldIndex+1);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(fieldIndex = 2; fieldIndex < nbFields; fieldIndex++)
        {
            sciErr = getListInList(pvApiCtx, var_addr, fieldIndex+1, &list_addr);
            if(sciErr.iErr)
            {
                printError(&sciErr, 0);
                return NULL;
            }

            for(valueIndex = 0; valueIndex < prodDims; valueIndex++)
            {
                structEntries[(fieldIndex-1) + (nbFields-2)*valueIndex] = GetMatlabVariable(iVar ,fieldNames[fieldIndex], matfile_version, list_addr, valueIndex+1);
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(K=0; K<*rank; K++)
    {
        nbRow *= dims[K];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<nbRow*nbCol; i++)
                {
                    tmp_int8[i] = ((char *)realdata)[i];
                }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<nbRow*nbCol; i++)
                {
                    tmp_int16[i] = ((short *)realdata)[i];
                }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<nbRow*nbCol; i++)
                {
                    tmp_int32[i] = ((int *)realdata)[i];
                }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<nbRow*nbCol; i++)
                {    
                    tmp_int64[i] = ((long long *)realdata)[i];
                }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<nbRow*nbCol; i++)
                {
                    tmp_uint8[i] = ((unsigned char *)realdata)[i];
                }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<nbRow*nbCol; i++)
                {
                    tmp_uint16[i] = ((unsigned short *)realdata)[i];
                }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<nbRow*nbCol; i++)
                {
                    tmp_uint32[i] = ((unsigned int *)realdata)[i];
                }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<nbRow*nbCol; i++)
                {
                    tmp_uint64[i] = ((unsigned long long *)realdata)[i];
                }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(K=0; K<dimensionsVariable->rank; K++)
    {
      prodDims *= ((int *)dimensionsVariable->data)[K];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(K=0; K<prodDims; K++)
        {
          cellEntries[K] = GetMatlabVariable(iVar ,"data", matfile_version, var_addr, 3+K);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0 ; i < *_iDims ; i++)
        {
            //reverse dimensions to improve rendering in external tools
            _piDims[i] = (int)dims[*_iDims - 1 - i];
            iSize *= _piDims[i];
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < iCount; i++)
    {
        if (H5Gget_objtype_by_idx(_iFile, i) == H5G_DATASET)
        {
            if (pstNameList != NULL)
            {
                int iLen = 0;

                iLen = (int)H5Gget_objname_by_idx(_iFile, i, NULL, iLen);
                pstNameList[iNbItem] = (char *)MALLOC(sizeof(char) * (iLen + 1));   //null terminated
                H5Gget_objname_by_idx(_iFile, i, pstNameList[iNbItem], iLen + 1);
            }
            iNbItem++;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0 ; i < _iDims ; i++)
    {
        iSize *= _piDims[i];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < iSize; i++)
    {
        


        obj = H5Rdereference(_iDatasetId, H5R_OBJECT, &pData[i]);
        if (_iComplex)
        {
            status = readComplexPoly(obj, &_piNbCoef[i], &_pdblReal[i], &_pdblImg[i]);
        }
        else
        {
            status = readPoly(obj, &_piNbCoef[i], &_pdblReal[i]);
        }

        if (status < 0)
        {
            FREE(pData);
            return -1;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0 ; i < *_piRank ; i++)
    {
        //reverse dimensions to improve rendering in external tools
        piDims[i] = _piDims[*_piRank - 1 - i];
        iSize *= (int)piDims[i];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0 ; i < iSize ; i++)
    {
        pstPathName = createPathName(pstGroupName, i);

        // Write the string to ref
        if (_iComplex)
        {
            status = writeDoubleComplexMatrix(_iFile, pstPathName, 1, &_piNbCoef[i], _pdblReal[i], _pdblImg[i]);
        }
        else
        {
            status = writeDoubleMatrix(_iFile, pstPathName, 1, &_piNbCoef[i], _pdblReal[i]);
        }

        if (status < 0)
        {
            FREE(pstPathName);
            FREE(pstGroupName);
            FREE(pData);
            FREE(piDims);
            return -1;
        }

        // create the ref
        status = H5Rcreate(&pData[i], _iFile, pstPathName, H5R_OBJECT, -1);
        if (status < 0)
        {
            FREE(pstPathName);
            FREE(pstGroupName);
            FREE(pData);
            FREE(piDims);
            return -1;
        }

        FREE(pstPathName);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0 ; i < groupInfo.nlinks ; i++)
        {
            ssize_t size = 0;
            char* pstPathName = NULL;
            char* pstChildName = NULL;
            //build child path
            pstPathName = createPathName(pstGroupName, i);

            //try to delete child and his children
            deleteHDF5group(_iFile, pstPathName);

            //get child name
            size = H5Lget_name_by_idx(groupID, ".", H5_INDEX_NAME, H5_ITER_INC, 0, 0, 0, H5P_DEFAULT) + 1;
            pstChildName = (char*)MALLOC(sizeof(char) * size);
            H5Lget_name_by_idx(groupID, ".", H5_INDEX_NAME, H5_ITER_INC, 0, pstChildName, size, H5P_DEFAULT);

            //unlink child
            status = H5Ldelete(groupID, pstChildName, H5P_DEFAULT);

            FREE(pstChildName);
            FREE(pstPathName);

            if (status < 0)
            {
                return 1;
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < iCount; i++)
    {
        if (H5Gget_objtype_by_idx(_iFile, i) == H5G_DATASET)
        {
            if (pstNameList != NULL)
            {
                int iLen = 0;

                iLen = (int)H5Gget_objname_by_idx(_iFile, i, NULL, iLen);
                pstNameList[iNbItem] = (char *)MALLOC(sizeof(char) * (iLen + 1));   //null terminated
                H5Gget_objname_by_idx(_iFile, i, pstNameList[iNbItem], iLen + 1);
            }
            iNbItem++;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < _iRows * _iCols; i++)
    {
        _pstData[i] = (char *)MALLOC(iAllocSize);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < _iRows * _iCols; i++)
    {
        hsize_t start[1] = { i };
        hsize_t count[1] = { 1 };
#ifdef TIME_DEBUG
        QueryPerformanceCounter(&piStart[i + 1]);
#endif
        status = H5Sselect_hyperslab(space, H5S_SELECT_SET, start, NULL, count, NULL);
        if (status < 0)
        {
            return -1;
        }

        


        status = H5Dread(_iDatasetId, memtype, memspace, space, H5P_DEFAULT, _pstData[i]);
        if (status < 0)
        {
            return -1;
        }
#ifdef TIME_DEBUG
        QueryPerformanceCounter(&piEnd[i + 1]);
#endif
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < _iRows * _iCols; i++)
    {
        double dblTime = ((piEnd[i + 1].QuadPart - piStart[i + 1].QuadPart) * 1000.0) / iFreq.QuadPart;

        printf("SubTime %d : %0.3f ms\n", i, dblTime);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < _iRows * _iCols; i++)
    {
        


        obj = H5Rdereference(_iDatasetId, H5R_OBJECT, &pData[i]);
        if (_iComplex)
        {
            status = readComplexPoly_v1(obj, &_piNbCoef[i], &_pdblReal[i], &_pdblImg[i]);
        }
        else
        {
            status = readPoly_v1(obj, &_piNbCoef[i], &_pdblReal[i]);
        }

        if (status < 0)
        {
            FREE(pData);
            return -1;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<len; i++) {
        temp_string = (*jenv)->NewStringUTF(jenv, result[i]);
        (*jenv)->SetObjectArrayElement(jenv, jresult, i, temp_string);
        (*jenv)->DeleteLocalRef(jenv, temp_string);
        FREE(result[i]);
        result[i] = NULL;
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<len; i++) {
        temp_string = (*jenv)->NewStringUTF(jenv, result[i]);
        (*jenv)->SetObjectArrayElement(jenv, jresult, i, temp_string);
        (*jenv)->DeleteLocalRef(jenv, temp_string);
        FREE(result[i]);
        result[i] = NULL;
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<len; i++) {
        temp_string = (*jenv)->NewStringUTF(jenv, result[i]);
        (*jenv)->SetObjectArrayElement(jenv, jresult, i, temp_string);
        (*jenv)->DeleteLocalRef(jenv, temp_string);
        FREE(result[i]);
        result[i] = NULL;
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0, pos=0;  j<n;  pos+=n-j, j++)
   {

      
      F2C(dspmv)("L", &n, &dbl1, AP, B+j, &n, &dbl0, temp, &int1);

      
      lngth = n-j;
      F2C(dgemv)("N", &lngth, &n, &dbl1, B+j, &n, temp, &int1, &dbl0,
             CP+pos, &int1);

   }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0, pos=0;  j<n;  pos+=n-j, j++)
   {

      
      F2C(dspmv)("L", &n, &dbl1, AP, B+j*n, &int1, &dbl0, temp, &int1);

      
      lngth = n-j;
      F2C(dgemv)("T", &n, &lngth, &dbl1, B+j*n, &n, temp, &int1, &dbl0,
             CP+pos, &int1);

   }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0, sz=0;  i<L;  i++)  sz += (blck_szs[i]*(blck_szs[i]+1))/2;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=0, pos=0;  j<L;  j++)

    


    for(k=0, lngth=blck_szs[j];  k<blck_szs[j];  pos+=lngth,



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<L; i++) if (blck_szs[i] < 1){
    if ( getWarningMode() ) sciprint(_("blck_szs[%d] must be at least one.\n"), i);
    *info = -4;
    return 1;
 }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0, n=0, sz=0, up_sz=0, max_n=0;  i<L;  i++){
    n     += blck_szs[i];
    sz    += blck_szs[i]*(blck_szs[i]+1)/2;
    up_sz += blck_szs[i]*blck_szs[i];
    max_n  = Max(max_n, blck_szs[i]);
 }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<m; i++)
 if (fabs(inprd(F+(i+1)*sz, Z, L, blck_szs) - c[i]) > nrmc*TOLC){
     if ( getWarningMode() ) sciprint(_("Z0 does not satisfy equality conditions for dual feasibility.\n"));

    *info = -7;
    return 1;
 }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(*iters=0; *iters <= maxiters; (*iters)++){


    
    F2C(dcopy)(&sz, F, &int1, X, &int1);
    F2C(dgemv)("N", &sz, &m, &dbl1, F+sz, &sz, x, &int1, &dbl1, X, &int1);


    








    for(i=0, pos=0, pos2=0, pos3=0, gap=0.0;  i<L;
         pos += blck_szs[i]*(blck_szs[i]+1)/2,
         pos2 += blck_szs[i]*blck_szs[i],
         pos3 += blck_szs[i], i++){

       lngth = blck_szs[i]*(blck_szs[i]+1)/2;

       
       F2C(dcopy)(&lngth, Z+pos, &int1, temp, &int1);

       






       F2C(dspgv)(&int2, "V", "L", blck_szs+i, temp, X+pos, sigx+pos3,
              R+pos2, blck_szs+i, temp+lngth, &info2);
       if (info2){
          if ( getWarningMode() ) sciprint(_("Error in dspgv, info = %d.\n"), info2);
          if (*iters == 0 && info2 > blck_szs[i]){
             if ( getWarningMode() ) sciprint( _("x0 is not strictly primal feasible.\n"));
	         *info = -6;
          } else *info = -18;
          return 1;
       }

       


       for(k=0; k<blck_szs[i]; k++){
          scal = sigx[pos3+k];
          if (scal < 0.0){
             if (*iters == 0){
                if ( getWarningMode() ) sciprint(_("Z0 is not positive definite.\n"));
                *info = 7;
             } else {
                if ( getWarningMode() ) sciprint(_("F(x)*Z has a negative eigenvalue.\n"));
                *info = -18;
             }
             return 1;
          }
          gap += scal;    
          scal2 = sqrt(scal);
          scal = sqrt(scal2);
          sigx[pos3+k] = scal2;
          F2C(dscal)(blck_szs+i, &scal, R+pos2+k*blck_szs[i], &int1);
       }

    }


    



    ul[1] = -inprd(F,Z,L,blck_szs);         
    ul[0] = F2C(ddot)(&m, c, &int1, x, &int1);  
    if (*iters == 0){
	if ( getWarningMode() ) sciprint(_("\n    primal obj.  dual obj.  dual. gap \n"));

    }
    if ( getWarningMode() ) sciprint("% 13.2e % 12.2e %10.2e\n", ul[0], ul[1], gap);
    if (gap <= Max(abstol, MINABSTOL))  *info = 2;
    else if ( (ul[1] > 0.0 && gap <= reltol*ul[1]) ||
              (ul[0] < 0.0 && gap <= reltol*(-ul[0])) ) *info = 3;
    else if ( reltol < 0.0 && ul[0] <= tv ) *info = 4;
    else if ( reltol < 0.0 && ul[1] >= tv ) *info = 5;
    else if ( *iters == maxiters ) *info = 1;
    else *info = 0;
    if (*info) return 0;



    



    for(j=0, pos=0;  j<m;  j++) for(i=0, pos2=0;  i<L;
         pos += blck_szs[i]*(blck_szs[i]+1)/2,
         pos2 += blck_szs[i]*blck_szs[i], i++) {

       
       cngrncb(2, blck_szs[i], F+sz+pos, R+pos2, Fsc+pos, temp);

       
       for(k=0, pos4=pos;  k<blck_szs[i];  pos4 += blck_szs[i]-k, k++)
          Fsc[pos4] /= sqrt2;

    }


    



    F2C(dscal)(&sz, &dbl0, rhs, &int1);    
    rho = -q/gap;
    for(i=0, pos=0, pos3=0;  i<L;
         pos += blck_szs[i]*(blck_szs[i]+1)/2,
         pos3 += blck_szs[i], i++)
       for(k=0, pos4=pos;  k<blck_szs[i];  pos4+=blck_szs[i]-k, k++){
          scal = sigx[pos3+k];
          rhs[pos4] = (1.0/scal + rho*scal)/sqrt2;
    }


    





    F2C(dgels)("N", &sz, &m, &int1, Fsc, &sz, rhs, &sz, temp, &ltemp,
           &info2);
    if (info2)
	{
       if ( getWarningMode() ) sciprint(_("Error in dgels, info = %d.\n"), info2);
       *info = -18; return 1;
    }

    if (*iters == 0){

       


       F2C(dtrcon)("1", "U", "N", &m, Fsc, &sz, &rcond, temp, iwork,
                &info2);
       if (info2 < 0){
          if ( getWarningMode() ) sciprint(_("Error in dtrcon, info = %d.\n"), info2);
          *info = -18; return 1;
       }
       if (rcond < MINRCOND) {
          if ( getWarningMode() ) sciprint(_("The matrices F_i, i=1,...,m are linearly dependent (or the initial points are very badly conditioned).\n"));
          *info = -3; return 1;
       }

    }



    











    for(i=0, pos=0, pos2=0, pos3=0;  i<L;
         pos  += blck_szs[i]*(blck_szs[i]+1)/2,
         pos2 += blck_szs[i]*blck_szs[i],
         pos3 += blck_szs[i], i++){

       lngth = blck_szs[i]*(blck_szs[i]+1)/2;

       

       F2C(dgemv)("N", &lngth, &m, &dbl1, F+sz+pos, &sz, dx, &int1,
              &dbl0, temp, &int1);

       
       cngrncb(2, blck_szs[i], temp, R+pos2, temp+lngth, temp+2*lngth);

       
       for(k=0, pos4=lngth;  k<blck_szs[i];  pos4+=blck_szs[i]-k, k++)
          temp[pos4] -= rho*sigx[pos3+k] + 1.0/sigx[pos3+k];

       


       F2C(dspgst)(&int1, "L", blck_szs+i, temp, X+pos, &info2);
       if (info2){
		   if ( getWarningMode() ) sciprint(_("Error in dspst, info = %d.\n"), info2);

          *info = -18;  return 1;
       }
       
       F2C(dspev)("N", "L", blck_szs+i, temp, sigx+pos3, NULL, &int1,
              temp+2*lngth, &info2);
       if (info2){
	   if ( getWarningMode() ) sciprint(_("Error in dspev, info = %d.\n"), info2);
	   *info = -18;  return 1;
       }

       
       cngrncb(1, blck_szs[i], temp+lngth, R+pos2, dZ+pos,
               temp+2*lngth);

       
       F2C(dcopy)(&lngth, dZ+pos, &int1, temp, &int1);

       
       F2C(dcopy)(&lngth, Z+pos, &int1, temp+lngth, &int1);

       

       F2C(dspgv)(&int1, "N", "L", blck_szs+i, temp, temp+lngth, sigz+pos3,
              NULL, &int1, temp+2*lngth, &info2);
       if (info2){
	   if ( getWarningMode() ) sciprint(_("Error in dspgv, info = %d.\n"), info2);
          *info = -18;  return 1;
       }

    }


    



    maxpossigx = 0.0;  minnegsigx = 0.0;
    maxpossigz = 0.0;  minnegsigz = 0.0;
    for(i=0; i<n; i++) {
       if ( sigx[i] > maxpossigx )
          maxpossigx = sigx[i];  
       else if ( sigx[i] < minnegsigx )
          minnegsigx = sigx[i];  
       if ( sigz[i] > maxpossigz )
          maxpossigz = sigz[i];  
       else if ( sigz[i] < minnegsigz )
          minnegsigz = sigz[i];  
    }
    nrmx = F2C(dnrm2)(&n, sigx, &int1);        
    nrmz = F2C(dnrm2)(&n, sigz, &int1);        
    nrmmax = Max( nrmx, nrmz);

    XdZ = inprd(F,dZ,L,blck_szs);          
    ZdX = F2C(ddot)(&m, c, &int1, dx, &int1);  


    



   dbl_epsilon = F2C(dlamch)("e");
   if (nrmx > SIGTOL*nrmmax)
      if (ZdX < 0.0)
          alphax = (minnegsigx < -dbl_epsilon) ? -1.0/minnegsigx : 0.0;
      else
          alphax = (maxpossigx >  dbl_epsilon) ? -1.0/maxpossigx : 0.0;
    else alphax = 0.0;

    if (nrmz > SIGTOL*nrmmax)
       if (XdZ < 0.0)
          alphaz = (minnegsigz < -dbl_epsilon) ? -1.0/minnegsigz : 0.0;
       else
          alphaz = (maxpossigz >  dbl_epsilon) ? -1.0/maxpossigz : 0.0;
    else alphaz = 0.0;

    newgap = gap + alphax*ZdX + alphaz*XdZ;
    newu = ul[0] + alphax*ZdX;
    newl = ul[1] - alphaz*XdZ;

    if (newgap <= Max(abstol, MINABSTOL))  *info = 2;
    else if ( (newl > 0.0 && newgap <= reltol*newl) ||
              (newu < 0.0 && newgap <= -reltol*newu) ) *info = 3;
    else if ( reltol < 0.0 && newu <= tv ) *info = 4;
    else if ( reltol < 0.0 && newl >= tv ) *info = 5;
    else if ( *iters == maxiters ) *info = 1;
    else *info = 0;

    if (*info) {
       F2C(daxpy)(&m, &alphax, dx, &int1, x, &int1);
       F2C(daxpy)(&sz, &alphaz, dZ, &int1, Z, &int1);
       gap = newgap;  ul[0] = newu;   ul[1] = newl;
       if ( getWarningMode() ) sciprint("% 13.2e % 12.2e %10.2e\n", ul[0], ul[1], gap);
       (*iters)++;
       return 0;
    }


    






    alphax = 0.0;  alphaz = 0.0;  lambda_ls = 1.0;

    if (nrmx > SIGTOL*nrmmax)
       if (nrmz > SIGTOL*nrmmax)    
          while ( lambda_ls > 1e-4 ) {

             
             rho = q/(gap + alphax*ZdX + alphaz*XdZ);
             gradx = rho*ZdX;  hessx = 0.0;
             gradz = rho*XdZ;  hessz = 0.0;
             for(i=0; i<n; i++){
                gradx -= sigx[i] / (1.0+alphax*sigx[i]);
                hessx += SQR( sigx[i] / (1.0+alphax*sigx[i]) );
                gradz -= sigz[i] / (1.0+alphaz*sigz[i]);
                hessz += SQR( sigz[i] / (1.0+alphaz*sigz[i]) );
             }

             
             dalphax = -gradx/hessx;  dalphaz = -gradz/hessz;
             lambda_ls = sqrt( SQR(gradx)/hessx + SQR(gradz)/hessz );
             alphax += (lambda_ls > 0.25) ?
                       dalphax/(1.0+lambda_ls) : dalphax;
             alphaz += (lambda_ls > 0.25) ?
                       dalphaz/(1.0+lambda_ls) : dalphaz;

         }

       else while ( lambda_ls > 1e-4 ) {  

             
             rho = q/(gap + alphax*ZdX);
             gradx = rho*ZdX;  hessx = 0.0;
             for(i=0; i<n; i++){
                gradx -= sigx[i] / (1.0+alphax*sigx[i]);
                hessx += SQR( sigx[i] / (1.0+alphax*sigx[i]) );
             }

             
             dalphax = -gradx/hessx;
             lambda_ls = fabs(gradx)/sqrt(hessx);
             alphax += (lambda_ls > 0.25) ?
                       dalphax/(1.0+lambda_ls) : dalphax;

       }

       else if (nrmz > SIGTOL*nrmmax)        
          while ( lambda_ls > 1e-4 ) {

             
             rho = q/(gap + alphaz*XdZ);
             gradz = rho*XdZ;  hessz = 0.0;
             for(i=0; i<n; i++){
                gradz -= sigz[i] / (1.0+alphaz*sigz[i]);
                hessz += SQR( sigz[i] / (1.0+alphaz*sigz[i]) );
             }

             
             dalphaz = -gradz/hessz;
             lambda_ls = fabs(gradz)/sqrt(hessz);
             alphaz += (lambda_ls > 0.25) ?
                       dalphaz/(1.0+lambda_ls) : dalphaz;
        }



    
    F2C(daxpy)(&m, &alphax, dx, &int1, x, &int1);
    F2C(daxpy)(&sz, &alphaz, dZ, &int1, Z, &int1);

 }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k=0; k<n; k++) stk(lb)[k] = -C2F(dlamch)("o",1L);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k=0; k<n; k++) stk(ub)[k] = C2F(dlamch)("o",1L);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k=0; k<n; k++) 
	{
		for(l=0; l<m; l++) stk(C)[k*m+l] = -stk(C)[k*m+l];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = nact; k < m; k++) istk(iact)[k] = 0;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 0; k < Lhs; k++) LhsVar(1 + k) = Rhs + 1 + k;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i <= *nx; ++i) 
        {
            int ier = 0;
            zbeshg(&xr[i - 1], &xi[i - 1], &alpha[i - 1], kode, k, &iOne, &yr[i - 1],
                &yi[i - 1], &nz, &wr[1], &wi[0], &ier);
            *ierr = Max(*ierr,ier);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i <= *nx; ++i) 
        {
            int ier = 0;
            zbeshg(&xr[i - 1], &xi[i - 1], &alpha[0], kode, k, &iOne, &yr[i - 1], 
                &yi[i - 1], &nz, &wr[0], &wi[0], &ier);
            *ierr = Max(*ierr, ier);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i <= *nx; ++i) 
        {
            int ier = 0;
            zbeshg(&xr[i - 1], &xi[i - 1], &alpha[l - 1], kode, k, &n, &wr[0], &wi[0],
                &nz, &wr[*na], &wi[*na], &ier);

            *ierr = Max(*ierr,ier);

            C2F(dcopy)(&n, &wr[0], &iOne, &yr[(i + (l - 1) * *nx) - 1], nx);

            C2F(dcopy)(&n, &wi[0], &iOne, &yi[(i + (l - 1) * *nx) - 1], nx);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m2*n2;i++) 
        {
            if (*stk(l2+i) < 0.0) {ispos = 0;break;}
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < mnx ; i++ )
        if ( ! (fabs(x[i]) < 1.0) )
        {
            Scierror(999, _("%s: Wrong value for input argument #%d: Matrix with elements in (%d,%d) expected.\n"), fname, 3, -1, 1);
            return 0;
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < mnx ; i++ )
    {
        xx = fabs(x[i]); 
        F2C(dxlegf) (&dnu1, &nudiff, &m1, &m2, &xx, &id,
                     stk(lpqa + i * MNp1), istk(lipqa + i * MNp1), &ierror);
        if ( ierror != 0 )
        {
            if ( ierror == 207 ) 
            {
                Scierror(999, _("%s: overflow or underflow of an extended range number\n"), fname);
            }
            else
            {
                Scierror(999, _("%s: error number %d\n"), fname, ierror);
            }
            return 0;
        };
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < mnx * MNp1 ; i++ )
    {
        if ( ipqa[i] < 0 )
        {
            pqa[i] = 0.0;
        }
        if ( ipqa[i] > 0 )
        {
            pqa[i] = pqa[i] * return_an_inf(); 
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < mnx ; i++ )
    {
        if ( x[i] < 0.0 )
        {
            if ( (n1 + m1) % 2 == 1 )
            {
                for( j = 0 ; j < MNp1 ; j += 2 )
                {
                    pqa[i * MNp1 + j] = -pqa[i * MNp1 + j];
                }
            }
            else
            {
                for( j = 1 ; j < MNp1 ; j += 2 )
                {
                    pqa[i * MNp1 + j] = -pqa[i * MNp1 + j];
                }
            }
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 1 ; i < nb_elt ; i++ )
    {
        if ( x[i] != x[i - 1] + 1.0 )
        {
            return 0;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m1*n1;i++) 
        {
            t=(int)*stk(l1+i);
            if (t != *stk(l1+i)) 
            {
                isint = 0;
                break;
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m2*n2;i++) 
            {
                if (*stk(l2+i) < 0.0) {ispos=0;break;}
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m1*n1;i++) 
        {
            t=(int)*stk(l1+i);
            if (t != *stk(l1+i)) {isint=0;break;}
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m2*n2;i++) 
            {
                if (*stk(l2+i) < 0.0) {ispos=0;break;}
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < mx*nx ; i++ )
    {
        if ( (x[i] <= 0.0)  ||  (y[i] <= 0.0) )
        {
            Scierror(999,_("%s: Wrong value for input arguments: Must be > %d.\n"), fname,0);
            return 0;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < mx*nx ; i++ )
    {
        xpy = x[i] + y[i];

        if ( xpy <= switch_limit )
        {
            z[i] = F2C(dgammacody)(&x[i]) * F2C(dgammacody)(&y[i]) / F2C(dgammacody)(&xpy);
        }
        else
        {
            z[i] = exp(F2C(betaln)(&x[i], &y[i]));
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m2*n2;i++) 
        {
            if (*stk(l2+i) < 0.0) {ispos=0;break;}
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m2*n2;i++) *stk(l2i+i) = 0.0;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < dimMax; i++)
    {
        TCHAR achKey[MAX_KEY_LENGTH];
        DWORD cbName = MAX_KEY_LENGTH;
        DWORD Type = 0;
        DWORD retCode = 0;

        retCode = RegEnumValue(key, i,
                               achKey,
                               &cbName,
                               NULL,
                               &Type,
                               NULL,
                               NULL);

        if (retCode != ERROR_SUCCESS)
        {
            RegCloseKey(key);
            return FALSE;
        }
        else
        {
            ListKeys[i] = strdup(achKey);
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < dimMax; i++)
    {
        TCHAR achKey[MAX_KEY_LENGTH];
        DWORD cbName = MAX_KEY_LENGTH;

        LONG Err = RegEnumKey(key, i, achKey, cbName);
        if (Err != ERROR_SUCCESS)
        {
            RegCloseKey(key);
            return FALSE;
        }
        else
        {
            ListKeys[i] = strdup(achKey);
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(fin = *SizeStrings - 1; fin > 0; fin--)
    {
        int Sorted=FALSE;
        for(i=0;i<fin;i++)
        {
            if (Strings[i])
            {
                if(strcmp(Strings[i],Strings[i+1]) == 0)
                {
                    FREE(Strings[i+1]);
                    Strings[i+1] = NULL;
                    Sorted=TRUE;
                    newsize--;
                }
            }
            else
            {
                Strings[i] = Strings[i+1];
                Strings[i+1] = NULL;
                Sorted=TRUE;
            }
        }
        if(!Sorted)break;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<(int)wcslen(wcSciPathName);i++)
			{
				if (wcSciPathName[i] == L'\\') wcSciPathName[i] = L'/';
			}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<(int)strlen(path_out);i++)
		{
			if ( slashToAntislash )
			{
				if (path_in[i] == UNIX_SEPATATOR) 
				{
					path_out[i] = WINDOWS_SEPATATOR;
					bOK = TRUE;
				}
			}
			else
			{
				if (path_in[i] == WINDOWS_SEPATATOR) 
				{
					path_out[i] = UNIX_SEPATATOR;
					bOK = TRUE;
				}
			}
		}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = (int)strlen(command) - 1; i >= 0; i--)
        {
            if (command[i] == BLANK) command[i] = EMPTY_CHAR;
            else break;
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < len; j++)
        {
            
            if (_string[j] == NOTPRINTABLE)
            {
                _string[j] = BLANK;
                bRemove = TRUE;
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < argc; i++)
    {
        my_argv[i] = argv[i];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nArgs; i++)
        {
            my_argv[i] = wide_string_to_UTF8(szArglist[i]);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i < my_argc; i++)
    {
        if  ( (_stricmp (my_argv[i], "-NW") == 0) || (_stricmp (my_argv[i], "-NWI") == 0) || (_stricmp (my_argv[i], "-TEXMACS") == 0) || (_stricmp (my_argv[i], "-NOGUI") == 0) )
        {
            MessageBox(NULL, "Not with Windows Console", "Error", MB_ICONINFORMATION);
            exit(1);
        }

        if ( (_stricmp (my_argv[i], "-VERSION") == 0) ||
                (_stricmp (my_argv[i], "-VER") == 0) )
        {
            disp_scilab_version();
            exit(1);
        }

        if ( (_stricmp (my_argv[i], "-H") == 0) ||
                (_stricmp (my_argv[i], "-?") == 0) ||
                (_stricmp (my_argv[i], "-HELP") == 0) )
        {
            char Msg[2048];
            strcpy(Msg, "Wscilex <Options>: run Scilab.\n");
            strcat(Msg, "Arguments: passes Arguments to Scilab, This Arguments can be retreived\n  by the Scilab function sciargs.\n");
            strcat(Msg, "-e Instruction: execute the scilab instruction given in Instruction argument.\n");
            strcat(Msg, "-f File: execute the scilab script given in File argument.\n");
            strcat(Msg, "  '-e' and '-f' options are mutually exclusive.\n\n");
            strcat(Msg, "-l lang: it fixes the user language.\n\n" );
            strcat(Msg, "-mem N: set the initial stacksize.\n");
            strcat(Msg, "-ns: if this option is present the startup file scilab.start is not executed.\n");
            strcat(Msg, "-nb: if this option is present then Scilab loading message is not displayed.\n");
            strcat(Msg, "-nouserstartup: don't execute user startup files SCIHOME/.scilab or SCIHOME/scilab.ini.\n");
            strcat(Msg, "-nw: start Scilab without specialized Scilab Window.\n");
            strcat(Msg, "-nwni: start Scilab without user interaction (batch mode).\n");
            strcat(Msg, "-nogui: start Scilab without GUI,tcl/tk and user interaction (batch mode).\n");
            strcat(Msg, "-texmacs: reserved for WinTeXMacs.\n");
            strcat(Msg, "-version: print product version and exit.\n");

            MessageBox(NULL, Msg, "Help", MB_ICONINFORMATION);
            exit(1);
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < (int)strlen(pathin); i++)
    {
        if (pathin[i] == '\\')
        {
            pathout[i] = '/';
        }
        else
        {
            pathout[i] = pathin[i];
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < TextLength; i++)
                {
                    LignePrint[Index1] = lines[i];
                    if ( Index1 == NombredeCaracteresparLignes )
                    {
                        Index2 ++;
                        LignePrint[Index1] = '\0';
                        if (LignePrint[Index1 - 1] == '\r')
                        {
                            LignePrint[Index1 - 1] = '\0';
                        }
                        TextOut (PrintDC, (tm.tmMaxCharWidth + 10), Index2 * HauteurCaractere, LignePrint, (int)strlen(LignePrint));
                        Index1 = 0;
                        if (LignePrint)
                        {
                            FREE(LignePrint);
                            LignePrint = NULL;
                        }
                        LignePrint = (char*)MALLOC((NombredeCaracteresparLignes + 1) * sizeof(char));
                    }
                    else if ( (lines[i] == '\n') )
                    {
                        Index2 ++;
                        if (Index1 > 0)
                        {
                            LignePrint[Index1] = '\0';
                            if (LignePrint[Index1 - 1] == '\r')
                            {
                                LignePrint[Index1 - 1] = '\0';
                            }
                            TextOut (PrintDC, (tm.tmMaxCharWidth + 10), Index2 * HauteurCaractere, LignePrint, (int)strlen(LignePrint));
                            Index1 = 0;
                        }
                        if (LignePrint)
                        {
                            FREE(LignePrint);
                            LignePrint = NULL;
                        }
                        LignePrint = (char*)MALLOC((NombredeCaracteresparLignes + 1) * sizeof(char));
                    }
                    else
                    {
                        Index1 ++;
                    }
                    if (Index2 == NbLigneParPage - 4)
                    {
                        Footer(PrintDC, numero);
                        EndPage (PrintDC);
                        StartPage(PrintDC);
                        numero++;
                        PageHeader(PrintDC, Entete);
                        Index2 = 3;
                    }
                }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < subline; i++)
                        {
                            LignePrint = (char*)MALLOC( (NombredeCaracteresparLignes + 1) * sizeof(char));
                            for(j = 0; j < (NombredeCaracteresparLignes); j++)
                            {
                                if (line[(i * NombredeCaracteresparLignes) + j] == 9) 
                                {
                                    LignePrint[j] = ' ';
                                }
                                else
                                {
                                    LignePrint[j] = line[(i * NombredeCaracteresparLignes) + j];
                                }

                            }
                            LignePrint[j] = '\0';

                            TextOut (PrintDC, (tm.tmMaxCharWidth + 10), Index2 * HauteurCaractere, LignePrint, (int)strlen(LignePrint));
                            if (LignePrint)
                            {
                                FREE(LignePrint);
                                LignePrint = NULL;
                            }
                            Index2 ++;
                            if (Index2 == NbLigneParPage - 4)
                            {
                                Footer(PrintDC, numero);
                                EndPage (PrintDC);
                                StartPage(PrintDC);
                                numero++;
                                PageHeader(PrintDC, filename);
                                Index2 = 3;
                            }
                        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < (restsubline); j++)
                            {
                                if (line[(i * NombredeCaracteresparLignes) + j] == 9) 
                                {
                                    LignePrint[j] = ' ';
                                }
                                else
                                {
                                    LignePrint[j] = line[(i * NombredeCaracteresparLignes) + j];
                                }
                            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < NumberOfLines + 1; i++)
        {
            if ( i == 0)
            {
                lstrcpyn(Buffer, &Line[i * NumberOfCharByLine], NumberOfCharByLine);

            }
            else
            {
                char BufferCat[MAX_PATH];
                lstrcpyn(BufferCat, &Line[i * NumberOfCharByLine], NumberOfCharByLine);
                lstrcat(Buffer, BufferCat);

            }
            if (i != NumberOfLines)
            {
                lstrcat(Buffer, "\n");
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < argc; i++)
    {
        if (_stricmp(argv[i], ARG_NW) == 0)
        {
            FindNW = 1;
        }
        if (_stricmp(argv[i], ARG_NWNI) == 0 )
        {
            FindNW = 1;
        }
        if (_stricmp(argv[i], ARG_NOGUI) == 0 )
        {
            FindNW = 1;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 1; i < argc; i++)
        {
            argvbis[i + 1] = argv[i];
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < argc; i++)
        {
            argvbis[i] = argv[i];
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < numberOfGuids ; i++)
					{
						GUIDs[i] = createGUID();
					}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < NumbersElm; i++)
                {
                    ListKeysName[i] = NULL;
                }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0;i<nbrlines;i++) 
		{
			if (ouput[i])
			{
				sciprint("%s\n",ouput[i]);
			}
		}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(I = 1; I <= AllocatedSize; I++)
    {   Matrix->IntToExtRowMap[I] = I;
        Matrix->IntToExtColMap[I] = I;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(I = 1; I <= AllocatedSize; I++)
    {   Matrix->ExtToIntColMap[I] = -1;
        Matrix->ExtToIntRowMap[I] = -1;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(I = ELEMENTS_PER_ALLOCATION; I > 0; I--)
    {    ListPtr->NextRecord = ListPtr - 1;
         ListPtr--;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(I = Size; I > 0; I--)
        Intermediate[I] = RHS[*(pExtOrder--)];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(I = 1; I <= Size; I++)
    {   
      

        if ((Temp = Intermediate[I]) != 0.0)
        {   
	  pPivot = Matrix->Diag[I];
	  if ( pPivot != 0 && ELEMENT_MAG(pPivot) >  Matrix->AbsThreshold )
	    {
	      
	      Intermediate[I] = (Temp /= pPivot->Real);
	      
	      pElement = pPivot->NextInCol;
	      while (pElement != NULL)
		{   Intermediate[pElement->Row] -= Temp * pElement->Real;
		    pElement = pElement->NextInCol;
		  }
	    }
	  else
	    Intermediate[I]= 0.0;
        }
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(I = Size ; I > 0; I--)
    {   Temp = Intermediate[I];
	if ( Matrix->Diag[I] == 0) 
	  {
	    Intermediate[I]=0.0;
	  }
	else 
	  {
	    pElement = Matrix->Diag[I]->NextInRow;
	    while (pElement != NULL)
	      {   Temp -= pElement->Real * Intermediate[pElement->Col];
		  pElement = pElement->NextInRow;
		}
	    Intermediate[I] = Temp;
	  }
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(I = Size; I > 0; I--)
        Solution[*(pExtOrder--)] = Intermediate[I];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(I = Size; I > 0; I--)
    {   Intermediate[I].Real = RHS[*(pExtOrder)];
        Intermediate[I].Imag = iRHS[*(pExtOrder--)];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(I = Size; I > 0; I--)
        Intermediate[I] = ExtVector[*(pExtOrder--)];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(I = 1; I <= Size; I++)
    {   Temp = Intermediate[I];


        if ((Temp.Real != 0.0) OR (Temp.Imag != 0.0))
        {   pPivot = Matrix->Diag[I];

            CMPLX_MULT_ASSIGN(Temp, *pPivot);
            Intermediate[I] = Temp;
            pElement = pPivot->NextInCol;
            while (pElement != NULL)
            {

                CMPLX_MULT_SUBT_ASSIGN(Intermediate[pElement->Row],
                                       Temp, *pElement);
                pElement = pElement->NextInCol;
            }
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(I = Size; I > 0; I--)
    {   Temp = Intermediate[I];
        pElement = Matrix->Diag[I]->NextInRow;

        while (pElement != NULL)
        {

            CMPLX_MULT_SUBT_ASSIGN(Temp, *pElement,Intermediate[pElement->Col]);
            pElement = pElement->NextInRow;
        }
        Intermediate[I] = Temp;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(I = Size; I > 0; I--)
    {   Solution[*(pExtOrder)] = Intermediate[I].Real;
        iSolution[*(pExtOrder--)] = Intermediate[I].Imag;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(I = Size; I > 0; I--)
        ExtVector[*(pExtOrder--)] = Intermediate[I];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(I = Size; I > 0; I--)
        Intermediate[I] = RHS[*(pExtOrder--)];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(I = 1; I <= Size; I++)
    {   

        if ((Temp = Intermediate[I]) != 0.0)
        {   pElement = Matrix->Diag[I]->NextInRow;
            while (pElement != NULL)
            {   Intermediate[pElement->Col] -= Temp * pElement->Real;
                pElement = pElement->NextInRow;
            }

        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(I = Size; I > 0; I--)
    {   pPivot = Matrix->Diag[I];
        Temp = Intermediate[I];
        pElement = pPivot->NextInCol;
        while (pElement != NULL)
        {   Temp -= pElement->Real * Intermediate[pElement->Row];
            pElement = pElement->NextInCol;
        }
        Intermediate[I] = Temp * pPivot->Real;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(I = Size; I > 0; I--)
        Solution[*(pExtOrder--)] = Intermediate[I];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(I = Size; I > 0; I--)
    {   Intermediate[I].Real = RHS[*(pExtOrder)];
        Intermediate[I].Imag = iRHS[*(pExtOrder--)];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(I = Size; I > 0; I--)
        Intermediate[I] = ExtVector[*(pExtOrder--)];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(I = 1; I <= Size; I++)
    {   Temp = Intermediate[I];


        if ((Temp.Real != 0.0) OR (Temp.Imag != 0.0))
        {   pElement = Matrix->Diag[I]->NextInRow;
            while (pElement != NULL)
            {

                CMPLX_MULT_SUBT_ASSIGN( Intermediate[pElement->Col],
                                        Temp, *pElement);
                pElement = pElement->NextInRow;
            }
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(I = Size; I > 0; I--)
    {   pPivot = Matrix->Diag[I];
        Temp = Intermediate[I];
        pElement = pPivot->NextInCol;

        while (pElement != NULL)
        {

            CMPLX_MULT_SUBT_ASSIGN(Temp,Intermediate[pElement->Row],*pElement);

            pElement = pElement->NextInCol;
        }

        CMPLX_MULT(Intermediate[I], Temp, *pPivot);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(I = Size; I > 0; I--)
    {   Solution[*(pExtOrder)] = Intermediate[I].Real;
        iSolution[*(pExtOrder--)] = Intermediate[I].Imag;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(I = Size; I > 0; I--)
        ExtVector[*(pExtOrder--)] = Intermediate[I];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 0 ;k < *nel; k++) {
    i0=i0+1;
    while (i0-i1 > lln[i-1]) {
      i1=i0;
      i=i+1;
      i0=i0+1;
    }
    j=col[k];
   
    pelement = spGetElement(fmat,i,j);
 
    if (pelement == 0) {
      *ierr=2;
      return;
    }
    spADD_REAL_ELEMENT(pelement,(spREAL)(val[k]));

  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(I = 1; I <= Size; I++)
    {
      indsigd[I-1]=1;
      indsigd[Size+I-1]=  Matrix->IntToExtColMap[I];
      sigd[I-1]=1.0;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(I = 1; I <= Size; I++)
    if (Matrix->ExtToIntColMap[I]== -1) mc++;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(I = Size -(mc)+1  ; I <= Size; I++)
	{
	  for( J=last+1; J <=Size; J++)
	    {
	      if (Matrix->ExtToIntColMap[J]==-1)
		{
		  last=J;break;
		}
	    }
	  indsigd[I-1]=1;
	  indsigd[Size+I-1]= last;
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(I = 1; I <= Size; I++)
    if (Matrix->ExtToIntRowMap[I]== -1) mc++;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(I = 1; I <= Size-mc ; I++)
    {
      indsigg[I-1]= 1;
      indsigg[Size+Matrix->IntToExtRowMap[I]-1]=I;
      sigg[I-1]=1.0;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(I = Size -(mc)+1  ; I <= Size; I++)
	{
	  for( J=last+1; J <=Size; J++)
	    {
	      if (Matrix->ExtToIntRowMap[J]==-1)
		{

		  last=J;break;
		}
	    }
	  indsigg[I-1]= 1;
	  indsigg[Size+last-1]=I;
	  sigg[I-1]=1.0;
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(J = 1; J <= Size ; J++)
    {
      indl[J-1] = 0;
      indu[J-1] = 0;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(I = 1; I <= Size ; I++)
    {
      indu[I-1]=indu[I-1]+1;
      indu[Size+usize]=I;
      u[usize]=1.0;
      usize=usize+1;

      pElement = Matrix->FirstInRow[I];
      while ( pElement != NULL )
	{
	  J = pElement->Col;
	  if (I >= J) {
	    indl[I-1] = indl[I-1]+1;
	    indl[Size+lsize]=J;
	    l[lsize]=(double) pElement->Real ;
	    lsize=lsize+1;

	  }
	  else {
	    indu[I-1] = indu[I-1]+1;
	    indu[Size+usize]=J;
	    u[usize]=(double) pElement->Real ;
	    usize=usize+1;

	  }
	  pElement = pElement->NextInRow;
	};
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(J = 1; J <= Size ; J++)
    {
      pElement = Matrix->FirstInCol[J];
      while ( pElement != NULL )
	{
	  if (pElement->Row >= J)
	    *lsize=*lsize+1;
	  else
	    *usize=*usize+1;
	  pElement = pElement->NextInCol;
	};
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i<sci_luptr_index; i++) {
    if ( sci_luptr_table[i]==NULL) {
      sel = i;
      break;
    }
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(I = 1; I <= I1; ++I) {
	    *istk(ia + I) = *istk(ia + I - 1) + *istk(ilr + I - 1);
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(kkk=0; kkk<I1; ++kkk) *istk(ilr+kkk)=*istk(iat+kkk)-1;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(kkk=0; kkk<nel; ++kkk) *istk(ilr+n+1+kkk)=*istk(irc+n+kkk)-1;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k=0; k<n; ++k) header[jc+k+1]=0;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(kkk=0; kkk<I1; ++kkk) *istk(ilrs+kkk)=*istk(ilr+kkk)+1;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 1; j <= n; ++j) {
	nc = *istk(ilrs + j ) - *istk(ilrs + j - 1);
	j1_ = *istk(ilrs + j - 1) -1;
	tv = (double) j;
	C2F(dset)(&nc, &tv, stk(lij + nel + j1_ ), &c1);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(kkk=0; kkk<I1; ++kkk) *istk(ils+kkk)=*istk(ilr+kkk)+1;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 1; j <= I1; ++j) {
	nj = inda[j] - inda[j-1];
	if (nj > 0) {
	    I2 = nj;
	    for(ii = 1; ii <= I2; ++ii) {
		I = inda[*na  + k + ii];
		rr[I + (j - 1) * *ma -1 ] = a[k + ii -1];
	    }
	    k += nj;
	}
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 1; j <= I1; ++j) {
    nj = inda[j] - inda[j-1];
    if (nj > 0) {
      I2 = nj;
      for(ii = 1; ii <= I2; ++ii) {
	I = inda[*na + k + ii];
	rr[I + (j - 1) * *ma -1] = ar[k + ii -1];
	ri[I + (j - 1) * *ma -1] = ai[k + ii -1];
      }
      k += nj;
    }
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(J = StartAt; J <= Size; J++)
        {   if (Matrix->Diag[J] == NULL)
            {   Twins = CountTwins( Matrix, J, &pTwin1, &pTwin2 );
                if (Twins == 1)
                {   
                    SwapCols( Matrix, pTwin1, pTwin2 );
                    Swapped = YES;
                }
                else if ((Twins > 1) AND NOT AnotherPassNeeded)
                {   AnotherPassNeeded = YES;
                    StartAt = J;
                }
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(J = StartAt; NOT Swapped AND (J <= Size); J++)
            {   if (Matrix->Diag[J] == NULL)
                {   Twins = CountTwins( Matrix, J, &pTwin1, &pTwin2 );
                    SwapCols( Matrix, pTwin1, pTwin2 );
                    Swapped = YES;
                }
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(I = 1; I <= lSize; I++)
    {   if ((ScaleFactor = RHS_ScaleFactors[*(pExtOrder++)]) != 1.0)
        {   pElement = Matrix->FirstInRow[I];

            while (pElement != NULL)
            {   pElement->Real *= ScaleFactor;
                pElement = pElement->NextInRow;
            }
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(I = 1; I <= lSize; I++)
    {   if ((ScaleFactor = SolutionScaleFactors[*(pExtOrder++)]) != 1.0)
        {   pElement = Matrix->FirstInCol[I];

            while (pElement != NULL)
            {   pElement->Real *= ScaleFactor;
                pElement = pElement->NextInCol;
            }
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(I = 1; I <= lSize; I++)
    {   if ((ScaleFactor = RHS_ScaleFactors[*(pExtOrder++)]) != 1.0)
        {   pElement = Matrix->FirstInRow[I];

            while (pElement != NULL)
            {   pElement->Real *= ScaleFactor;
                pElement->Imag *= ScaleFactor;
                pElement = pElement->NextInRow;
            }
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(I = 1; I <= lSize; I++)
    {   if ((ScaleFactor = SolutionScaleFactors[*(pExtOrder++)]) != 1.0)
        {   pElement = Matrix->FirstInCol[I];

            while (pElement != NULL)
            {   pElement->Real *= ScaleFactor;
                pElement->Imag *= ScaleFactor;
                pElement = pElement->NextInCol;
            }
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(I = Matrix->Size; I > 0; I--)
        Vector[I] = Solution[*(pExtOrder--)];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(I = Matrix->Size; I > 0; I--)
    {   pElement = Matrix->FirstInRow[I];
        Sum = 0.0;

        while (pElement != NULL)
        {   Sum += pElement->Real * Vector[pElement->Col];
            pElement = pElement->NextInRow;
        }
        RHS[*pExtOrder--] = Sum;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(I = Matrix->Size; I > 0; I--)
    {   Vector[I].Real = Solution[*pExtOrder];
        Vector[I].Imag = iSolution[*(pExtOrder--)];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(I = Matrix->Size; I > 0; I--)
        Vector[I] = ((ComplexVector)Solution)[*(pExtOrder--)];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(I = Matrix->Size; I > 0; I--)
    {   pElement = Matrix->FirstInRow[I];
        Sum.Real = Sum.Imag = 0.0;

        while (pElement != NULL)
        {   
            CMPLX_MULT_ADD_ASSIGN( Sum, *pElement, Vector[pElement->Col] );
            pElement = pElement->NextInRow;
        }

#if spSEPARATED_COMPLEX_VECTORS
        RHS[*pExtOrder] = Sum.Real;
        iRHS[*pExtOrder--] = Sum.Imag;
#else
        ((ComplexVector)RHS)[*pExtOrder--] = Sum;
#endif
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(I = Matrix->Size; I > 0; I--)
        Vector[I] = Solution[*(pExtOrder--)];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(I = Matrix->Size; I > 0; I--)
    {   pElement = Matrix->FirstInCol[I];
        Sum = 0.0;

        while (pElement != NULL)
        {   Sum += pElement->Real * Vector[pElement->Row];
            pElement = pElement->NextInCol;
        }
        RHS[*pExtOrder--] = Sum;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(I = Matrix->Size; I > 0; I--)
    {   Vector[I].Real = Solution[*pExtOrder];
        Vector[I].Imag = iSolution[*(pExtOrder--)];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(I = Matrix->Size; I > 0; I--)
        Vector[I] = ((ComplexVector)Solution)[*(pExtOrder--)];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(I = Matrix->Size; I > 0; I--)
    {   pElement = Matrix->FirstInCol[I];
        Sum.Real = Sum.Imag = 0.0;

        while (pElement != NULL)
        {   
            CMPLX_MULT_ADD_ASSIGN( Sum, *pElement, Vector[pElement->Row] );
            pElement = pElement->NextInCol;
        }

#if spSEPARATED_COMPLEX_VECTORS
        RHS[*pExtOrder] = Sum.Real;
        iRHS[*pExtOrder--] = Sum.Imag;
#else
        ((ComplexVector)RHS)[*pExtOrder--] = Sum;
#endif
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(I = 1; I <= Size; I++)
        {   ppElement = &(Matrix->FirstInCol[I]);
            while ((pElement = *ppElement) != NULL)
            {   if (pElement->Row == 0)
                {   *ppElement = pElement->NextInCol;  
                    if (Matrix->Diag[pElement->Col] == pElement)
                        Matrix->Diag[pElement->Col] = NULL;
                }
                else
                    ppElement = &pElement->NextInCol;  
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(I = 1; I <= Size; I++)
        {   ppElement = &(Matrix->FirstInRow[I]);
            while ((pElement = *ppElement) != NULL)
            {   if (pElement->Row == 0)
                    *ppElement = pElement->NextInRow;  
                else
                    ppElement = &pElement->NextInRow;  
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(I = 2; I <= Matrix->Size; I++)
    {   Mag = ELEMENT_MAG( Diag[I] );
        if (Mag > MaxPivot)
            MaxPivot = Mag;
        else if (Mag < MinPivot)
            MinPivot = Mag;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(I = Size; I > 0; I--) T[I] = 0.0;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(I = 1; I <= Size; I++)
    {   pPivot = Matrix->Diag[I];
        if (T[I] < 0.0) Em = -E; else Em = E;
        Wm = (Em + T[I]) * pPivot->Real;
        if (Abs(Wm) > SLACK)
        {   ScaleFactor = 1.0 / Max( SQR( SLACK ), Abs(Wm) );
            for(K = Size; K > 0; K--) T[K] *= ScaleFactor;
            E *= ScaleFactor;
            Em *= ScaleFactor;
            Wm = (Em + T[I]) * pPivot->Real;
        }
        Wp = (T[I] - Em) * pPivot->Real;
        ASp = Abs(T[I] - Em);
        ASm = Abs(Em + T[I]);


        pElement = pPivot->NextInCol;
        while (pElement != NULL)
        {   Row = pElement->Row;
            Tm[Row] = T[Row] - (Wm * pElement->Real);
            T[Row] -= (Wp * pElement->Real);
            ASp += Abs(T[Row]);
            ASm += Abs(Tm[Row]);
            pElement = pElement->NextInCol;
        }


        if (ASm > ASp)
        {   T[I] = Wm;
            pElement = pPivot->NextInCol;
            while (pElement != NULL)
            {   T[pElement->Row] = Tm[pElement->Row];
                pElement = pElement->NextInCol;
            }
        }
        else T[I] = Wp;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ASw = 0.0, I = Size; I > 0; I--) ASw += Abs(T[I]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(I = Size; I > 0; I--) T[I] *= ScaleFactor;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(I = Size; I >= 1; I--)
    {   pElement = Matrix->Diag[I]->NextInRow;
        while (pElement != NULL)
        {   T[I] -= pElement->Real * T[pElement->Col];
            pElement = pElement->NextInRow;
        }
        if (Abs(T[I]) > SLACK)
        {   ScaleFactor = 1.0 / Max( SQR( SLACK ), Abs(T[I]) );
            for(K = Size; K > 0; K--) T[K] *= ScaleFactor;
            E *= ScaleFactor;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ASy = 0.0, I = Size; I > 0; I--) ASy += Abs(T[I]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(I = Size; I > 0; I--) T[I] *= ScaleFactor;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(MaxY = 0.0, I = Size; I > 0; I--)
        if (MaxY < Abs(T[I])) MaxY = Abs(T[I]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(I = 1; I <= Size; I++)
    {   pElement = Matrix->Diag[I]->NextInRow;
        while (pElement != NULL)
        {   T[pElement->Col] -= T[I] * pElement->Real;
            pElement = pElement->NextInRow;
        }
        if (Abs(T[I]) > SLACK)
        {   ScaleFactor = 1.0 / Max( SQR( SLACK ), Abs(T[I]) );
            for(K = Size; K > 0; K--) T[K] *= ScaleFactor;
            ASy *= ScaleFactor;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ASv = 0.0, I = Size; I > 0; I--) ASv += Abs(T[I]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(I = Size; I > 0; I--) T[I] *= ScaleFactor;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(I = Size; I >= 1; I--)
    {   pPivot = Matrix->Diag[I];
        pElement = pPivot->NextInCol;
        while (pElement != NULL)
        {   T[I] -= pElement->Real * T[pElement->Row];
            pElement = pElement->NextInCol;
        }
        T[I] *= pPivot->Real;
        if (Abs(T[I]) > SLACK)
        {   ScaleFactor = 1.0 / Max( SQR( SLACK ), Abs(T[I]) );
            for(K = Size; K > 0; K--) T[K] *= ScaleFactor;
            ASy *= ScaleFactor;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ASz = 0.0, I = Size; I > 0; I--) ASz += Abs(T[I]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(I = Size; I > 0; I--) T[I].Real = T[I].Imag = 0.0;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(I = 1; I <= Size; I++)
    {   pPivot = Matrix->Diag[I];
        if (T[I].Real < 0.0) Em = -E; else Em = E;
        Wm = T[I];
        Wm.Real += Em;
        ASm = CMPLX_1_NORM( Wm );
        CMPLX_MULT_ASSIGN( Wm, *pPivot );
        if (CMPLX_1_NORM(Wm) > SLACK)
        {   ScaleFactor = 1.0 / Max( SQR( SLACK ), CMPLX_1_NORM(Wm) );
            for(K = Size; K > 0; K--) SCLR_MULT_ASSIGN( T[K], ScaleFactor );
            E *= ScaleFactor;
            Em *= ScaleFactor;
            ASm *= ScaleFactor;
            SCLR_MULT_ASSIGN( Wm, ScaleFactor );
        }
        Wp = T[I];
        Wp.Real -= Em;
        ASp = CMPLX_1_NORM( Wp );
        CMPLX_MULT_ASSIGN( Wp, *pPivot );


        pElement = pPivot->NextInCol;
        while (pElement != NULL)
        {   Row = pElement->Row;
            
            CMPLX_MULT_SUBT( Tm[Row], Wm, *pElement, T[Row] );
            
            CMPLX_MULT_SUBT_ASSIGN( T[Row], Wm, *pElement );
            ASp += CMPLX_1_NORM(T[Row]);
            ASm += CMPLX_1_NORM(Tm[Row]);
            pElement = pElement->NextInCol;
        }


        if (ASm > ASp)
        {   T[I] = Wm;
            pElement = pPivot->NextInCol;
            while (pElement != NULL)
            {   T[pElement->Row] = Tm[pElement->Row];
                pElement = pElement->NextInCol;
            }
        }
        else T[I] = Wp;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ASw = 0.0, I = Size; I > 0; I--) ASw += CMPLX_1_NORM(T[I]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(I = Size; I > 0; I--) SCLR_MULT_ASSIGN( T[I], ScaleFactor );



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(I = Size; I >= 1; I--)
    {   pElement = Matrix->Diag[I]->NextInRow;
        while (pElement != NULL)
        {   
            CMPLX_MULT_SUBT_ASSIGN( T[I], T[pElement->Col], *pElement );
            pElement = pElement->NextInRow;
        }
        if (CMPLX_1_NORM(T[I]) > SLACK)
        {   ScaleFactor = 1.0 / Max( SQR( SLACK ), CMPLX_1_NORM(T[I]) );
            for(K = Size; K > 0; K--) SCLR_MULT_ASSIGN( T[K], ScaleFactor );
            E *= ScaleFactor;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ASy = 0.0, I = Size; I > 0; I--) ASy += CMPLX_1_NORM(T[I]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(I = Size; I > 0; I--) SCLR_MULT_ASSIGN( T[I], ScaleFactor );



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(MaxY = 0.0, I = Size; I > 0; I--)
        if (MaxY < CMPLX_1_NORM(T[I])) MaxY = CMPLX_1_NORM(T[I]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(I = 1; I <= Size; I++)
    {   pElement = Matrix->Diag[I]->NextInRow;
        while (pElement != NULL)
        {   
            CMPLX_MULT_SUBT_ASSIGN( T[pElement->Col], T[I], *pElement );
            pElement = pElement->NextInRow;
        }
        if (CMPLX_1_NORM(T[I]) > SLACK)
        {   ScaleFactor = 1.0 / Max( SQR( SLACK ), CMPLX_1_NORM(T[I]) );
            for(K = Size; K > 0; K--) SCLR_MULT_ASSIGN( T[K], ScaleFactor );
            ASy *= ScaleFactor;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ASv = 0.0, I = Size; I > 0; I--) ASv += CMPLX_1_NORM(T[I]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(I = Size; I > 0; I--) SCLR_MULT_ASSIGN( T[I], ScaleFactor );



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(I = Size; I >= 1; I--)
    {   pPivot = Matrix->Diag[I];
        pElement = pPivot->NextInCol;
        while (pElement != NULL)
        {   
            CMPLX_MULT_SUBT_ASSIGN( T[I], T[pElement->Row], *pElement );
            pElement = pElement->NextInCol;
        }
        CMPLX_MULT_ASSIGN( T[I], *pPivot );
        if (CMPLX_1_NORM(T[I]) > SLACK)
        {   ScaleFactor = 1.0 / Max( SQR( SLACK ), CMPLX_1_NORM(T[I]) );
            for(K = Size; K > 0; K--) SCLR_MULT_ASSIGN( T[K], ScaleFactor );
            ASy *= ScaleFactor;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ASz = 0.0, I = Size; I > 0; I--) ASz += CMPLX_1_NORM(T[I]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(I = Matrix->Size; I > 0; I--)
        {   pElement = Matrix->FirstInRow[I];
            AbsRowSum = 0.0;
            while (pElement != NULL)
            {   AbsRowSum += Abs( pElement->Real );
                pElement = pElement->NextInRow;
            }
            if (Max < AbsRowSum) Max = AbsRowSum;
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(I = Matrix->Size; I > 0; I--)
        {   pElement = Matrix->FirstInRow[I];
            AbsRowSum = 0.0;
            while (pElement != NULL)
            {   AbsRowSum += CMPLX_1_NORM( *pElement );
                pElement = pElement->NextInRow;
            }
            if (Max < AbsRowSum) Max = AbsRowSum;
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(I = 1; I <= Matrix->Size; I++)
        {   pDiag = Matrix->Diag[I];


            Pivot = 1.0 / pDiag->Real;
            Mag = Abs( Pivot );
            if (Mag > MaxRow) MaxRow = Mag;
            pElement = Matrix->FirstInRow[I];
            while (pElement != pDiag)
            {   Mag = Abs( pElement->Real );
                if (Mag > MaxRow) MaxRow = Mag;
                pElement = pElement->NextInRow;
            }


            pElement = Matrix->FirstInCol[I];
            AbsColSum = 1.0;  
            while (pElement != pDiag)
            {   AbsColSum += Abs( pElement->Real );
                pElement = pElement->NextInCol;
            }
            if (AbsColSum > MaxCol) MaxCol = AbsColSum;
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(I = 1; I <= Matrix->Size; I++)
        {   pElement = Matrix->FirstInCol[I];
            while (pElement != NULL)
            {   Mag = Abs( pElement->Real );
                if (Mag > Max) Max = Mag;
                pElement = pElement->NextInCol;
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(I = 1; I <= Matrix->Size; I++)
        {   pDiag = Matrix->Diag[I];


            CMPLX_RECIPROCAL( cPivot, *pDiag );
            Mag = CMPLX_1_NORM( cPivot );
            if (Mag > MaxRow) MaxRow = Mag;
            pElement = Matrix->FirstInRow[I];
            while (pElement != pDiag)
            {   Mag = CMPLX_1_NORM( *pElement );
                if (Mag > MaxRow) MaxRow = Mag;
                pElement = pElement->NextInRow;
            }


            pElement = Matrix->FirstInCol[I];
            AbsColSum = 1.0;  
            while (pElement != pDiag)
            {   AbsColSum += CMPLX_1_NORM( *pElement );
                pElement = pElement->NextInCol;
            }
            if (AbsColSum > MaxCol) MaxCol = AbsColSum;
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(I = 1; I <= Matrix->Size; I++)
        {   pElement = Matrix->FirstInCol[I];
            while (pElement != NULL)
            {   Mag = CMPLX_1_NORM( *pElement );
                if (Mag > Max) Max = Mag;
                pElement = pElement->NextInCol;
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(I = Matrix->Size; I > 0; I--)
        {   pElement = Matrix->FirstInRow[I];
            Count = 0;
            while (pElement->Col < I)
            {   Count++;
                pElement = pElement->NextInRow;
            }
            if (Count > MaxCount) MaxCount = Count;
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(Step = 1; Step <= Size; Step++)
        {   pPivot = Matrix->Diag[Step];
            LargestInCol = FindLargestInCol(pPivot->NextInCol);
            if ((LargestInCol * RelThreshold < ELEMENT_MAG(pPivot)))
            {   if (Matrix->Complex)
                    ComplexRowColElimination( Matrix, pPivot );
                else
                    RealRowColElimination( Matrix, pPivot );
            }
            else
            {   ReorderingRequired = YES;
                break; 
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(; Step <= Size; Step++)
    {   pPivot = SearchForPivot( Matrix, Step, DiagPivoting );
        if (pPivot != NULL && ELEMENT_MAG(pPivot) > Matrix->AbsThreshold)
                  
	  {
	    ExchangeRowsAndCols( Matrix, pPivot, Step );
	    
	    if (Matrix->Complex)
	      ComplexRowColElimination( Matrix, pPivot );
	    else
	      RealRowColElimination( Matrix, pPivot );
	    
	    if (Matrix->Error >= spFATAL) return Matrix->Error;
	    UpdateMarkowitzNumbers( Matrix, pPivot );
	    
#if ANNOTATE == FULL
	    WriteStatus( Matrix, Step );
#endif
	  }
	else 
	  {
	    Matrix->NumRank=Step-1;
#if ANNOTATE == FULL
	    if (pPivot==NULL) 
	      fprintf(stderr,"//Matrix is Singular Returning LU ");
	    else 
	      fprintf(stderr,"//Matrix is Singular at level prec [%f] I return LU\n",ELEMENT_MAG(pPivot));
#endif
	     break;

	    }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(Step = 2; Step <= Size; Step++)
    {   if (Matrix->DoRealDirect[Step])
        {   
            register RealNumber *Dest = (RealNumber *)Matrix->Intermediate;


            pElement = Matrix->FirstInCol[Step];
            while (pElement != NULL)
            {   Dest[pElement->Row] = pElement->Real;
                pElement = pElement->NextInCol;
            }


            pColumn = Matrix->FirstInCol[Step];
            while (pColumn->Row < Step)
            {   pElement = Matrix->Diag[pColumn->Row];
                pColumn->Real = Dest[pColumn->Row] * pElement->Real;
                while ((pElement = pElement->NextInCol) != NULL)
                    Dest[pElement->Row] -= pColumn->Real * pElement->Real;
                pColumn = pColumn->NextInCol;
            }


            pElement = Matrix->Diag[Step]->NextInCol;
            while (pElement != NULL)
            {   pElement->Real = Dest[pElement->Row];
                pElement = pElement->NextInCol;
            }


            if (Dest[Step] == 0.0) return ZeroPivot( Matrix, Step );

        }
        else
        {   
            register RealNumber **pDest = (RealNumber **)Matrix->Intermediate;


            pElement = Matrix->FirstInCol[Step];
            while (pElement != NULL)
            {   pDest[pElement->Row] = &pElement->Real;
                pElement = pElement->NextInCol;
            }


            pColumn = Matrix->FirstInCol[Step];
            while (pColumn->Row < Step)
            {   pElement = Matrix->Diag[pColumn->Row];
                Mult = (*pDest[pColumn->Row] *= pElement->Real);
                while ((pElement = pElement->NextInCol) != NULL)
                    *pDest[pElement->Row] -= Mult * pElement->Real;
                pColumn = pColumn->NextInCol;
            }


            if (Matrix->Diag[Step]->Real == 0.0)
                return ZeroPivot( Matrix, Step );

        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(Step = 2; Step <= Size; Step++)
    {   if (Matrix->DoCmplxDirect[Step])
        {   
            register  ComplexNumber  *Dest;
            Dest = (ComplexNumber *)Matrix->Intermediate;


            pElement = Matrix->FirstInCol[Step];
            while (pElement != NULL)
            {   Dest[pElement->Row] = *(ComplexNumber *)pElement;
                pElement = pElement->NextInCol;
            }


            pColumn = Matrix->FirstInCol[Step];
            while (pColumn->Row < Step)
            {   pElement = Matrix->Diag[pColumn->Row];
                
                CMPLX_MULT(Mult, Dest[pColumn->Row], *pElement);
                CMPLX_ASSIGN(*pColumn, Mult);
                while ((pElement = pElement->NextInCol) != NULL)
                {   
                    CMPLX_MULT_SUBT_ASSIGN(Dest[pElement->Row],Mult,*pElement);
                }
                pColumn = pColumn->NextInCol;
            }


            pElement = Matrix->Diag[Step]->NextInCol;
            while (pElement != NULL)
            {   *(ComplexNumber *)pElement = Dest[pElement->Row];
                pElement = pElement->NextInCol;
            }


            Pivot = Dest[Step];
            if (CMPLX_1_NORM(Pivot) == 0.0) return ZeroPivot( Matrix, Step );
            CMPLX_RECIPROCAL( *Matrix->Diag[Step], Pivot );  
        }
        else
        {   
            register  ComplexNumber  **pDest;
            pDest = (ComplexNumber **)Matrix->Intermediate;


            pElement = Matrix->FirstInCol[Step];
            while (pElement != NULL)
            {   pDest[pElement->Row] = (ComplexNumber *)pElement;
                pElement = pElement->NextInCol;
            }


            pColumn = Matrix->FirstInCol[Step];
            while (pColumn->Row < Step)
            {   pElement = Matrix->Diag[pColumn->Row];
                
                CMPLX_MULT(Mult, *pDest[pColumn->Row], *pElement);
                CMPLX_ASSIGN(*pDest[pColumn->Row], Mult);
                while ((pElement = pElement->NextInCol) != NULL)
                {  
                   CMPLX_MULT_SUBT_ASSIGN(*pDest[pElement->Row],Mult,*pElement);
                }
                pColumn = pColumn->NextInCol;
            }


            pElement = Matrix->Diag[Step];
            if (ELEMENT_MAG(pElement) == 0.0) return ZeroPivot( Matrix, Step );
            CMPLX_RECIPROCAL( *pElement, *pElement );  
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(Step = 1; Step <= Size; Step++)
#if REAL



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(Step = 1; Step <= Size; Step++)
#if REAL



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(Step = 1; Step <= Size; Step++)
    {   Nc[Step] = No[Step] = Nm[Step] = 0;

        pElement = Matrix->FirstInCol[Step];
        while (pElement != NULL)
        {   Nc[Step]++;
            pElement = pElement->NextInCol;
        }

        pColumn = Matrix->FirstInCol[Step];
        while (pColumn->Row < Step)
        {   pElement = Matrix->Diag[pColumn->Row];
            Nm[Step]++;
            while ((pElement = pElement->NextInCol) != NULL)
                No[Step]++;
            pColumn = pColumn->NextInCol;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(Step = 1; Step <= Size; Step++)
    {












#define generic
#ifdef hp9000s300
#if REAL
        DoRealDirect[Step] = (Nm[Step] + No[Step] > 3*Nc[Step] - 2*Nm[Step]);
#endif
#if spCOMPLEX
        
        DoCmplxDirect[Step] = NO;
#endif
#undef generic
#endif

#ifdef vax
#if REAL
        DoRealDirect[Step] = (Nm[Step] + No[Step] > 3*Nc[Step] - 2*Nm[Step]);
#endif
#if spCOMPLEX
        DoCmplxDirect[Step] = (Nm[Step] + No[Step] > 7*Nc[Step] - 4*Nm[Step]);
#endif
#undef generic
#endif

#ifdef generic
#if REAL
        DoRealDirect[Step] = (Nm[Step] + No[Step] > 3*Nc[Step] - 2*Nm[Step]);
#endif
#if spCOMPLEX
        DoCmplxDirect[Step] = (Nm[Step] + No[Step] > 7*Nc[Step] - 4*Nm[Step]);
#endif
#undef generic
#endif
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(Step = 1; Step <= Size; Step++)
            Ops += No[Step];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(I = Step; I <= Size; I++)
    {

        Count = -1;
        pElement = Matrix->FirstInRow[I];
        while (pElement != NULL AND pElement->Col < Step)
            pElement = pElement->NextInRow;
        while (pElement != NULL)
        {   Count++;
            pElement = pElement->NextInRow;
        }


        ExtRow = Matrix->IntToExtRowMap[I];

#if spSEPARATED_COMPLEX_VECTORS OR NOT spCOMPLEX
        if (RHS != NULL)
            if (RHS[ExtRow] != 0.0)  Count++;
#else
        if (RHS != NULL)
        {   if (Matrix->Complex)
            {   if ((RHS[2*ExtRow] != 0.0) OR (RHS[2*ExtRow+1] != 0.0))
                    Count++;
            }
            else if (RHS[I] != 0.0) Count++;
        }
#endif
        Matrix->MarkowitzRow[I] = Count;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(I = Step; I <= Size; I++)
    {

        Count = -1;
        pElement = Matrix->FirstInCol[I];
        while (pElement != NULL AND pElement->Row < Step)
            pElement = pElement->NextInCol;
        while (pElement != NULL)
        {   Count++;
            pElement = pElement->NextInCol;
        }
        Matrix->MarkowitzCol[I] = Count;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(I = Step; I <= Size; I++)
    {

        if ((*pMarkowitzRow > LARGEST_SHORT_INTEGER AND *pMarkowitzCol != 0) OR
            (*pMarkowitzCol > LARGEST_SHORT_INTEGER AND *pMarkowitzRow != 0))
        {   fProduct = (double)(*pMarkowitzRow++) * (double)(*pMarkowitzCol++);
            if (fProduct >= LARGEST_LONG_INTEGER)
                *pMarkowitzProduct++ = LARGEST_LONG_INTEGER;
            else
                *pMarkowitzProduct++ = (long) fProduct;
        }
        else
        {   Product = *pMarkowitzRow++ * *pMarkowitzCol++;
            if ((*pMarkowitzProduct++ = Product) == 0)
                Matrix->Singletons++;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(;;)  
    {   while (MinMarkowitzProduct < *(--pMarkowitzProduct))
        {   





        }

        I = pMarkowitzProduct - Matrix->MarkowitzProd;


        if (I < Step) break; 
        if (I > Matrix->Size) I = Step;

        if ((pDiag = Matrix->Diag[I]) == NULL)
            continue; 
        if ((Magnitude = ELEMENT_MAG(pDiag)) <= Matrix->AbsThreshold)
            continue; 

        if (*pMarkowitzProduct == 1)
        {



            pOtherInRow = pDiag->NextInRow;
            pOtherInCol = pDiag->NextInCol;
            if (pOtherInRow == NULL AND pOtherInCol == NULL)
            {    pOtherInRow = Matrix->FirstInRow[I];
                 while(pOtherInRow != NULL)
                 {   if (pOtherInRow->Col >= Step AND pOtherInRow->Col != I)
                         break;
                     pOtherInRow = pOtherInRow->NextInRow;
                 }
                 pOtherInCol = Matrix->FirstInCol[I];
                 while(pOtherInCol != NULL)
                 {   if (pOtherInCol->Row >= Step AND pOtherInCol->Row != I)
                         break;
                     pOtherInCol = pOtherInCol->NextInCol;
                 }
            }



            if (pOtherInRow != NULL  AND  pOtherInCol != NULL)
            {   if (pOtherInRow->Col == pOtherInCol->Row)
                {   LargestOffDiagonal = Max(ELEMENT_MAG(pOtherInRow),
                                                      ELEMENT_MAG(pOtherInCol));
                    if (Magnitude >= LargestOffDiagonal)
                    {

                        return pDiag;
                    }
                }
            }
        }

        if (*pMarkowitzProduct < MinMarkowitzProduct)
        {

            TiedElements[0] = pDiag;
            MinMarkowitzProduct = *pMarkowitzProduct;
            NumberOfTies = 0;
        }
        else
        {

            if (NumberOfTies < MAX_MARKOWITZ_TIES)
            {   TiedElements[++NumberOfTies] = pDiag;
                if (NumberOfTies >= MinMarkowitzProduct * TIES_MULTIPLIER)
                    break; 
            }
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(I = 0; I <= NumberOfTies; I++)
    {   pDiag = TiedElements[I];
        Magnitude = ELEMENT_MAG(pDiag);
        LargestInCol = FindBiggestInColExclude( Matrix, pDiag, Step );
        Ratio = LargestInCol / Magnitude;
        if (Ratio < MaxRatio)
        {   ChosenPivot = pDiag;
            MaxRatio = Ratio;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(;;)  
    {   while (*(--pMarkowitzProduct) >= MinMarkowitzProduct)
        {   
        }

        I = (int)(pMarkowitzProduct - Matrix->MarkowitzProd);


        if (I < Step) break; 
        if (I > Matrix->Size) I = Step;

        if ((pDiag = Matrix->Diag[I]) == NULL)
            continue; 
        if ((Magnitude = ELEMENT_MAG(pDiag)) <= Matrix->AbsThreshold)
            continue; 

        if (*pMarkowitzProduct == 1)
        {



            pOtherInRow = pDiag->NextInRow;
            pOtherInCol = pDiag->NextInCol;
            if (pOtherInRow == NULL AND pOtherInCol == NULL)
            {    pOtherInRow = Matrix->FirstInRow[I];
                 while(pOtherInRow != NULL)
                 {   if (pOtherInRow->Col >= Step AND pOtherInRow->Col != I)
                         break;
                     pOtherInRow = pOtherInRow->NextInRow;
                 }
                 pOtherInCol = Matrix->FirstInCol[I];
                 while(pOtherInCol != NULL)
                 {   if (pOtherInCol->Row >= Step AND pOtherInCol->Row != I)
                         break;
                     pOtherInCol = pOtherInCol->NextInCol;
                 }
            }



            if (pOtherInRow != NULL  AND  pOtherInCol != NULL)
            {   if (pOtherInRow->Col == pOtherInCol->Row)
                {   LargestOffDiagonal = Max(ELEMENT_MAG(pOtherInRow),
                                                      ELEMENT_MAG(pOtherInCol));
                    if (Magnitude >= LargestOffDiagonal)
                    {

                        return pDiag;
                    }
                }
            }
        }

        MinMarkowitzProduct = *pMarkowitzProduct;
        ChosenPivot = pDiag;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(J = Size+1; J > Step; J--)
    {
        if (*(--pMarkowitzProduct) > MinMarkowitzProduct)
            continue; 
        if (J > Matrix->Size)
            I = Step;
        else
            I = J;
        if ((pDiag = Matrix->Diag[I]) == NULL)
            continue; 
        if ((Magnitude = ELEMENT_MAG(pDiag)) <= Matrix->AbsThreshold)
            continue; 


        LargestInCol = FindBiggestInColExclude( Matrix, pDiag, Step );
        if (Magnitude <= Matrix->RelThreshold * LargestInCol)
            continue; 

        if (*pMarkowitzProduct < MinMarkowitzProduct)
        {

            ChosenPivot = pDiag;
            MinMarkowitzProduct = *pMarkowitzProduct;
            RatioOfAccepted = LargestInCol / Magnitude;
            NumberOfTies = 0;
        }
        else
        {

            NumberOfTies++;
            Ratio = LargestInCol / Magnitude;
            if (Ratio < RatioOfAccepted)
            {   ChosenPivot = pDiag;
                RatioOfAccepted = Ratio;
            }
            if (NumberOfTies >= MinMarkowitzProduct * TIES_MULTIPLIER)
                return ChosenPivot;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(I = Step; I <= Size; I++)
    {   pElement = Matrix->FirstInCol[I];

        while (pElement != NULL AND pElement->Row < Step)
            pElement = pElement->NextInCol;

        if((LargestInCol = FindLargestInCol(pElement)) == 0.0)
            continue; 

        while (pElement != NULL)
        {


            if ((Magnitude = ELEMENT_MAG(pElement)) > LargestElementMag)
            {   LargestElementMag = Magnitude;
                pLargestElement = pElement;
            }

            Product = Matrix->MarkowitzRow[pElement->Row] *
                      Matrix->MarkowitzCol[pElement->Col];


            if ((Product <= MinMarkowitzProduct) AND
                (Magnitude > Matrix->RelThreshold * LargestInCol) AND
                (Magnitude > Matrix->AbsThreshold))
            {


                if (Product < MinMarkowitzProduct)
                {

                    ChosenPivot = pElement;
                    MinMarkowitzProduct = Product;
                    RatioOfAccepted = LargestInCol / Magnitude;
                    NumberOfTies = 0;
                }
                else
                {

                    NumberOfTies++;
                    Ratio = LargestInCol / Magnitude;
                    if (Ratio < RatioOfAccepted)
                    {   ChosenPivot = pElement;
                        RatioOfAccepted = Ratio;
                    }
                    if (NumberOfTies >= MinMarkowitzProduct * TIES_MULTIPLIER)
                        return ChosenPivot;
                }
            }
            pElement = pElement->NextInCol;
        }  
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(ColPtr = pPivot->NextInCol; ColPtr != NULL; ColPtr = ColPtr->NextInCol)
    {   Row = ColPtr->Row;
        --MarkoRow[Row];


        if ((MarkoRow[Row] > LARGEST_SHORT_INTEGER AND MarkoCol[Row] != 0) OR
            (MarkoCol[Row] > LARGEST_SHORT_INTEGER AND MarkoRow[Row] != 0))
        {   Product = MarkoCol[Row] * MarkoRow[Row];
            if (Product >= LARGEST_LONG_INTEGER)
                Matrix->MarkowitzProd[Row] = LARGEST_LONG_INTEGER;
            else
                Matrix->MarkowitzProd[Row] = (long)Product;
        }
        else Matrix->MarkowitzProd[Row] = MarkoRow[Row] * MarkoCol[Row];
        if (MarkoRow[Row] == 0)
            Matrix->Singletons++;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(RowPtr = pPivot->NextInRow; RowPtr != NULL; RowPtr = RowPtr->NextInRow)
    {   Col = RowPtr->Col;
        --MarkoCol[Col];


        if ((MarkoRow[Col] > LARGEST_SHORT_INTEGER AND MarkoCol[Col] != 0) OR
            (MarkoCol[Col] > LARGEST_SHORT_INTEGER AND MarkoRow[Col] != 0))
        {   Product = MarkoCol[Col] * MarkoRow[Col];
            if (Product >= LARGEST_LONG_INTEGER)
                Matrix->MarkowitzProd[Col] = LARGEST_LONG_INTEGER;
            else
                Matrix->MarkowitzProd[Col] = (long)Product;
        }
        else Matrix->MarkowitzProd[Col] = MarkoRow[Col] * MarkoCol[Col];
        if ((MarkoCol[Col] == 0) AND (MarkoRow[Col] != 0))
            Matrix->Singletons++;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(I = 1; I <= Matrix->Size; I++)
        printf("%2d  ", Matrix->MarkowitzRow[I]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(I = 1; I <= Matrix->Size; I++)
        printf("%2d  ", Matrix->MarkowitzCol[I]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(I = 1; I <= Matrix->Size; I++)
        printf("%2d  ", Matrix->MarkowitzProd[I]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(I = 1; I <= Matrix->Size; I++)
        printf("%2d  ", Matrix->IntToExtRowMap[I]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(I = 1; I <= Matrix->Size; I++)
        printf("%2d  ", Matrix->IntToExtColMap[I]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(I = 1; I <= Matrix->ExtSize; I++)
        printf("%2d  ", Matrix->ExtToIntRowMap[I]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(I = 1; I <= Matrix->ExtSize; I++)
        printf("%2d  ", Matrix->ExtToIntColMap[I]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(I = Matrix->Size; I > 0; I--)
        {   pElement = Matrix->FirstInCol[I];
            while (pElement != NULL)
            {   pElement->Real = 0.0;
                pElement->Imag = 0.0;
                pElement = pElement->NextInCol;
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(I = Matrix->Size; I > 0; I--)
        {   pElement = Matrix->FirstInCol[I];
            while (pElement != NULL)
            {   pElement->Real = 0.0;
                pElement = pElement->NextInCol;
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(Col = Matrix->Size; Col >= 1; Col--)
    {

        pElement = Matrix->FirstInCol[Col];

        while (pElement != NULL)
        {   pElement->Col = Col;
            FirstInRowEntry = &FirstInRowArray[pElement->Row];
            pElement->NextInRow = *FirstInRowEntry;
            *FirstInRowEntry = pElement;
            pElement = pElement->NextInCol;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(I = OldAllocatedSize+1; I <= NewSize; I++)
    {   Matrix->IntToExtColMap[I] = I;
        Matrix->IntToExtRowMap[I] = I;
        Matrix->Diag[I] = NULL;
        Matrix->FirstInRow[I] = NULL;
        Matrix->FirstInCol[I] = NULL;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(I = OldAllocatedSize+1; I <= NewSize; I++)
    {   Matrix->ExtToIntRowMap[I] = -1;
        Matrix->ExtToIntColMap[I] = -1;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(J = Matrix->Size; J > 0; J--)
        {   pElement = Matrix->FirstInCol[J];
            while (pElement != NULL)
            {   pElement->Imag = 0.0;
                pElement = pElement->NextInCol;
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(J = Matrix->Size; J > 0; J--)
    {   pElement = Matrix->FirstInCol[J];
        Col = Matrix->IntToExtColMap[J];
        while (pElement != NULL)
        {   if (pElement->pInitInfo == NULL)
            {   pElement->Real = 0.0;
#               if spCOMPLEX
                    pElement->Imag = 0.0;
#               endif
            }
            else
            {   Error = (*pInit)((RealNumber *)pElement, pElement->pInitInfo,
                                 Matrix->IntToExtRowMap[pElement->Row], Col);
                if (Error)
                {   Matrix->Error = spFATAL;
                    return Error;
                }

            }
            pElement = pElement->NextInCol;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(I = 1; I <= Size; I++)
    {   PrintOrdToIntRowMap[ Matrix->IntToExtRowMap[I] ] = I;
        PrintOrdToIntColMap[ Matrix->IntToExtColMap[I] ] = I;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(J = 1, I = 1; I <= Top_; I++)
    {   if (PrintOrdToIntRowMap[I] != 0)
            PrintOrdToIntRowMap[ J++ ] = PrintOrdToIntRowMap[ I ];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(J = 1, I = 1; I <= Top_; I++)
    {   if (PrintOrdToIntColMap[I] != 0)
            PrintOrdToIntColMap[ J++ ] = PrintOrdToIntColMap[ I ];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(I = StartCol; I <= StopCol; I++)
                {   if (PrintReordered)
                        Col = I;
                    else
                        Col = PrintOrdToIntColMap[I];
                    printf(" %9d", Matrix->IntToExtColMap[ Col ]);
                }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(I = 1; I <= Size; I++)
        {   if (PrintReordered)
                Row = I;
            else
                Row = PrintOrdToIntRowMap[I];

            if (Header)
            {   if (PrintReordered AND NOT Data)
                    printf("%4d", I);
                else
                    printf("%4d", Matrix->IntToExtRowMap[ Row ]);
                if (NOT Data) putchar(' ');
            }


            for(J = StartCol; J <= StopCol; J++)
            {   if (PrintReordered)
                    Col = J;
                else
                    Col = PrintOrdToIntColMap[J];

                pElement = Matrix->FirstInCol[Col];
                while(pElement != NULL AND pElement->Row != Row)
                    pElement = pElement->NextInCol;

                if (Data)
                    pImagElements[J - StartCol] = pElement;

                if (pElement != NULL)


                {   if (Data)
                        printf(" %9.3lg", (double)pElement->Real);
                    else
                        putchar('x');


                    if ( (Magnitude = ELEMENT_MAG(pElement)) > LargestElement )
                        LargestElement = Magnitude;
                    if ((Magnitude < SmallestElement) AND (Magnitude != 0.0))
                        SmallestElement = Magnitude;
                    ElementCount++;
                }


                else
                {   if (Data)
                        printf("       ...");
                    else
                        putchar('.');
                }
            }
            putchar('\n');

#if spCOMPLEX
            if (Matrix->Complex AND Data)
            {   printf("    ");
                for(J = StartCol; J <= StopCol; J++)
                {   if (pImagElements[J - StartCol] != NULL)
                    {   printf(" %8.2lgj",
                               (double)pImagElements[J-StartCol]->Imag);
                    }
                    else printf("          ");
                }
                putchar('\n');
            }
#endif 
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(I = 1; I <= Size; I++)
        {   if (Matrix->Diag[I] != NULL)
            {   Magnitude = ELEMENT_MAG( Matrix->Diag[I] );
                if ( Magnitude > LargestDiag ) LargestDiag = Magnitude;
                if ( Magnitude < SmallestDiag ) SmallestDiag = Magnitude;
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(I = 1; I <= Size; I++)
        {   pElement = Matrix->FirstInCol[I];
            while (pElement != NULL)
            {   if (Reordered)
                {   Row = pElement->Row;
                    Col = I;
                }
                else
                {   Row = Matrix->IntToExtRowMap[pElement->Row];
                    Col = Matrix->IntToExtColMap[I];
                }
                pElement = pElement->NextInCol;
                if (fprintf(pMatrixFile, "%d\t%d\n", Row, Col) < 0) return 0;
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(I = 1; I <= Size; I++)
        {   pElement = Matrix->FirstInCol[I];
            while (pElement != NULL)
            {   if (Reordered)
                {   Row = pElement->Row;
                    Col = I;
                }
                else
                {   Row = Matrix->IntToExtRowMap[pElement->Row];
                    Col = Matrix->IntToExtColMap[I];
                }
                Err = fprintf
                (   pMatrixFile,"%d\t%d\t%-.15lg\t%-.15lg\n",
                    Row, Col, (double)pElement->Real, (double)pElement->Imag
                );
                if (Err < 0) return 0;
                pElement = pElement->NextInCol;
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(I = 1; I <= Size; I++)
        {   pElement = Matrix->FirstInCol[I];
            while (pElement != NULL)
            {   Row = Matrix->IntToExtRowMap[pElement->Row];
                Col = Matrix->IntToExtColMap[I];
                Err = fprintf
                (   pMatrixFile,"%d\t%d\t%-.15lg\n",
                    Row, Col, (double)pElement->Real
                );
                if (Err < 0) return 0;
                pElement = pElement->NextInCol;
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(I = 1; I <= Size; I++)
        {   Err = fprintf
            (   pMatrixFile, "%-.15lg\t%-.15lg\n",
                (double)RHS[I], (double)iRHS[I]
            );
            if (Err < 0) return 0;
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(I = 1; I <= Size; I++)
        {   Err = fprintf
            (   pMatrixFile, "%-.15lg\t%-.15lg\n",
                (double)RHS[2*I], (double)RHS[2*I+1]
            );
            if (Err < 0) return 0;
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(I = 1; I <= Size; I++)
        {   if (fprintf(pMatrixFile, "%-.15lg\n", (double)RHS[I]) < 0)
                return 0;
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(I = 1; I <= Size; I++)
    {   pElement = Matrix->FirstInCol[I];
        while (pElement != NULL)
        {   NumberOfElements++;
            Data = ELEMENT_MAG(pElement);
            if (Data > LargestElement)
                LargestElement = Data;
            if (Data < SmallestElement AND Data != 0.0)
                SmallestElement = Data;
            pElement = pElement->NextInCol;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < (*ma) * (*na) ; i++) ar[i] = 2 * ar[i] ;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < (*ma) * (*na) ; i++) ac[i] = 3 * ac[i] ;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 0; k < 3; k++) c[k] = a[k] + b[k] * 2.;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 0; k < i1; ++k) {
    cmntest.b[k] = a[k];
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 0; k < i1; ++k) {
    c[k] = cmntest.b[k];
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 0; k < *n; ++k) 
    {
      c[k] = a[k] + b[k];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 0; k < *n; ++k) 
	c[k] = sin(a[k]) + cos(b[k]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 0; k < *n; ++k) 
	c[k] = a[k] + b[k];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0; i < m*n ; i++ ) y[i] = (*stk(lp+i));



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 0; k < *n; ++k) 
    {
      c[k] = a[k] + b[k];
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 0; k < n; ++k) 
    c[k] = a[k] + b[k] * 2.;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 0; k < *n; ++k) 
	c[k] = sin(a[k]) + cos(b[k]);



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 0; k < *n; ++k) 
	c[k] = a[k] + b[k];



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 0; k < n; ++k) 
    c[k] = a[k] + b[k] * 2.;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 0; k < *n; ++k) {
	c[k] = sin(a[k]) + cos(b[k]);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i=0 ; i < n; i++)
  {
    for( j=0; j < l; j++)
    {
      s = 0.;
      for( k=0; k< m; k++)
      {
	      s += A(i,k)*B(k,j);
      }
      C(i,j) = s;
    }
  }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < LastInterf ; i++) 
	{
		if (strcmp(spname,DynInterf[i].name) == 0) 
		{
			unlinksharedlib(&DynInterf[i].Nshared);
			break;
		}
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < LastInterf ; i++) 
	{
		if ( DynInterf[i].ok == 0 ) 
		{
			inum= i;
		}
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0;i < sizefcts; i++)
	{
		int id[nsiz],zero=0,three=3,fptr = 0,fptr1 = 0,four=4;

		
		C2F(cvname)(id,fcts[i],&zero,(unsigned long)strlen(fcts[i]));
		fptr1 = fptr = (DynInterfStart+k1)*1000 +(i+1);
		
		C2F(funtab)(id,&fptr1,&four,"NULL_NAME",0); 
		
		C2F(funtab)(id,&fptr,&three,fcts[i],(unsigned long)strlen(fcts[i])); 
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i= 0 ; i < MaxInterfaces ; i++) 
				{
					strcpy(DynInterf[i].name,"");
					DynInterf[i].func = NULL;

					DynInterf[i].Nshared = -1;
					DynInterf[i].ok = FALSE;
				}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < LastInterf ; i++ ) 
	{
		if ( DynInterf[i].Nshared == id ) 
		{
			DynInterf[i].ok = FALSE;
			break;
		}
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i= MaxInterfaces ; i < newMaxInterfaces ; i++) 
			{
				strcpy(DynInterf[i].name,"");
				DynInterf[i].func = NULL;
				DynInterf[i].Nshared = -1;
				DynInterf[i].ok = FALSE;
			}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < sizesubnamesarray ; i++)
        {
            if (fflag)
            {
                errorcode = Sci_dlsym(subnamesarray[i], IdSharedLib, "f");
            }
            else
            {
                errorcode = Sci_dlsym(subnamesarray[i], IdSharedLib, "c");
            }

            if (errorcode < 0)
            {
                *ierr = errorcode;
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < Nshared ; i++)
    {
        if ( hd[i].ok == TRUE)
        {
            (*sizeList)++;
            if (ListId)
            {
                ListId = (int *)REALLOC(ListId, (*sizeList) * sizeof(int));
                ListId[(*sizeList) - 1] = i;
            }
            else
            {
                ListId = (int *)MALLOC((*sizeList) * sizeof(int));
                ListId[(*sizeList) - 1] = i;
            }
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = NEpoints - 1 ; i >= 0 ; i--)
            {
                if (EP[i].name)
                {
                    char *EntryName = (char *)MALLOC(((int)strlen(EP[i].name) + 1) * sizeof(char));

                    if (EntryName)
                    {
                        (*sizearray)++;
                        strcpy(EntryName , EP[i].name);
                        NamesOfFunctions[(*sizearray) - 1] = EntryName;
                    }
                }
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < ENTRYMAX ; i++)
        {
            hd[i].ok = FALSE;
            hd[i].shl = EP[i].Nshared = -1;
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = NEpoints - 1 ; i >= 0 ; i--)
    {
        if ( strcmp(op, EP[i].name) == 0)
        {
            *realop = EP[i].epoint;
            return(EP[i].Nshared );
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = NEpoints - 1 ; i >= 0 ; i--)
    {
        if ( strcmp(op, EP[i].name) == 0 && EP[i].Nshared == ilib)
        {
            return(i);
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < Nshared ; i++)
    {
        if ( hd[i].ok == TRUE)
        {
            if (getIlibVerboseLevel() != ILIB_VERBOSE_NO_OUTPUT)
            {
                sciprint("%d ", i);
                count++;
            }
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = NEpoints - 1 ; i >= 0 ; i--)
    {
        if (getIlibVerboseLevel() != ILIB_VERBOSE_NO_OUTPUT)
        {
            sciprint(_("Entry point %s in shared library %d.\n"), EP[i].name, EP[i].Nshared);
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < Nshared ; i++)
    {
        unlinksharedlib(&i);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = 0 ; i < Nshared ; i++ )
    {
        if ( hd[i].ok == FALSE)
        {
            hd[i].shl =  (unsigned long long)hd1;
            hd[i].ok = TRUE;
            return(i);
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i = NEpoints - 1 ; i >= 0 ; i--)
    {
        if ( EP[i].Nshared == ish )
        {
            int j;
            for( j = i ; j <= NEpoints - 2 ; j++ )
            {
                EP[j].epoint = EP[j + 1].epoint;
                EP[j].Nshared = EP[j + 1].Nshared;
                strcpy(EP[j].name, EP[j + 1].name);
            }
            NEpoints--;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < m1*n1; i++)
				{
					int ilib = (int) params[i];
					unlinksharedlib(&ilib);
				}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 2 ; i <= Rhs ; i++)
            {
                sciErr = getVarAddressFromPosition(pvApiCtx, i, &piAddrI);
                if (sciErr.iErr)
                {
                    printError(&sciErr, 0);
                    return 1;
                }

                sciErr = getVarType(pvApiCtx, piAddrI, &iTypeI);
                if (sciErr.iErr)
                {
                    printError(&sciErr, 0);
                    return 1;
                }

                if (iTypeI != sci_strings)
                {
                    iOldSave = TRUE;
                    break;
                }

                sciErr = getVarDimension(pvApiCtx, piAddrI, &iRowsI, &iColsI);
                if (sciErr.iErr)
                {
                    printError(&sciErr, 0);
                    return 1;
                }

                if (iRowsI != 1 || iColsI != 1)
                {
                    iOldSave = TRUE;
                    break;
                }

                if (getAllocatedSingleString(pvApiCtx, piAddrI, &pstVarI))
                {
                    return 1;
                }

                if(strcmp(pstVarI, "-append") != 0)
                {
                    //try to get variable by name
                    sciErr = getVarAddressFromName(pvApiCtx, pstVarI, &piAddrI2);
                    if (sciErr.iErr)
                    {
                        // Try old save because here the input variable can be of type "string" but not a variable name
                        // Ex: a=""; save(filename, a);
                        iOldSave = TRUE;
                        break;
                    }

                    if (piAddrI2 == 0)
                    {
                        iOldSave = TRUE;
                        break;
                    }
                }

                freeAllocatedSingleString(pstVarI);
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( ; ; ) {
        fflush(stdout);
        fflush(stderr);

        
        select_mask = Select_mask_ref;
        write_mask  = Write_mask_ref;

        select_timeout.tv_sec = 0;
        select_timeout.tv_usec = 10;
        i = select(inter_max_plus1, &select_mask, &write_mask, (fd_set *)NULL, &select_timeout);
        if (i < 0) {
            if (errno != EINTR) 
            {
                sciprint(_("Error. A signal has been caught.\n"));
                exit(0);
                continue;
            }
        }

        
        if ( FD_ISSET(fd_out,&write_mask)) {
            fflush(stdout);
        }
        if ( FD_ISSET(fd_err,&write_mask)) {
            fflush(stderr);
        }

        
        if (FD_ISSET(fd_in,&select_mask))
            state=1;

        if (state) {
            i=getchar();
            if (i==LF) state=0;
            return(i);
        }

        if (interrupt&&(ismenu()==1)) return(-1);

    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(K = 0; K < nbRowDefaultValues * nbColDefaultValues; K++)
        {
            defaultValuesInt[K] = (int)defaultValues[K];
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(K = 0; K < nbRowDefaultValues * nbColDefaultValues; K++)
        {
            userValueDouble[K] = userValue[K];
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(iMenuitemIndex = 0; iMenuitemIndex < iRows * iCols; iMenuitemIndex++)
        {
            // Create sub-menus
            pstMenuitemUID = createGraphicObject(__GO_UIMENU__);
            setGraphicObjectProperty(pstMenuitemUID, __GO_UI_LABEL__, pstAllMenuLabels[iMenuitemIndex], jni_string, 1);
            setGraphicObjectRelationship(pstUicontextmenuUID, pstMenuitemUID);
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(inputIndex = 0; inputIndex < NBPROPERTIES; inputIndex++)
        {
            propertiesValuesIndices[inputIndex] = NOT_FOUND;    
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(inputIndex = beginIndex; inputIndex < Rhs; inputIndex = inputIndex + 2)
        {
            
            if (VarType(inputIndex) != sci_strings)
            {
                Scierror(999, _("%s: Wrong type for input argument #%d: A string expected.\n"), fname, inputIndex);
                return FALSE;
            }
            else
            {
                GetRhsVar(inputIndex, STRING_DATATYPE, &nbRow, &nbCol, &stkAdr);
                propertyName = cstk(stkAdr);

                
                
                
                propertyPart = (char *)MALLOC(sizeof(char) * (MAXPROPERTYNAMELENGTH + 1));
                if (propertyPart == NULL)
                {
                    Scierror(999, _("%s: No more memory.\n"), fname);
                    return FALSE;
                }

                found = 0;
                for(k = 0; k < NBPROPERTIES; k++)
                {
                    if (strlen(propertyName) <= MAXPROPERTYNAMELENGTH)
                    {
                        strncpy(propertyPart, propertiesNames[k], strlen(propertyName));
                        propertyPart[strlen(propertyName)] = '\0';

                        if (stricmp(propertyName, propertyPart) == 0)
                        {
                            propertiesValuesIndices[k] = inputIndex + 1;    
                            found = 1;
                            break;
                        }
                    }
                }

                FREE(propertyPart);

                if (found == 0)
                {
                    Scierror(999, _("%s: Unknown property: %s for '%s' handles.\n"), fname, propertyName, "Uicontrol");
                    return FALSE;
                }
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(inputIndex = 1; inputIndex < NBPROPERTIES; inputIndex++)   
        {
            if (propertiesValuesIndices[inputIndex] != NOT_FOUND)
            {
                if (inputIndex == 21 || inputIndex == 23)   
                {
                    stkAdr = propertiesValuesIndices[inputIndex];   
                    nbRow = -1;
                    nbCol = -1;
                    setStatus =
                        callSetProperty(pvApiCtx, (char*)getObjectFromHandle(GraphicHandle), stkAdr, VarType(propertiesValuesIndices[inputIndex]), nbRow, nbCol,
                                        (char *)propertiesNames[inputIndex]);
                }
                else            
                {
                    
                    switch (VarType(propertiesValuesIndices[inputIndex]))
                    {
                        case sci_matrix:
                            GetRhsVar(propertiesValuesIndices[inputIndex], MATRIX_OF_DOUBLE_DATATYPE, &nbRow, &nbCol, &stkAdr);
                            setStatus =
                                callSetProperty(pvApiCtx, (char*)getObjectFromHandle(GraphicHandle), stkAdr, sci_matrix, nbRow, nbCol,
                                                (char *)propertiesNames[inputIndex]);
                            break;
                        case sci_strings:
                            
                            if ((inputIndex == 4) || (inputIndex == 27))
                            {
                                GetRhsVar(propertiesValuesIndices[inputIndex], MATRIX_OF_STRING_DATATYPE, &nbRow, &nbCol, &stkAdrForStrings);
                                setStatus =
                                    callSetProperty(pvApiCtx, (char*)getObjectFromHandle(GraphicHandle), (size_t) stkAdrForStrings, sci_strings, nbRow, nbCol,
                                                    (char *)propertiesNames[inputIndex]);
                                freeArrayOfString(stkAdrForStrings, nbRow * nbCol);
                            }
                            else
                            {
                                GetRhsVar(propertiesValuesIndices[inputIndex], STRING_DATATYPE, &nbRow, &nbCol, &stkAdr);
                                setStatus =
                                    callSetProperty(pvApiCtx, (char*)getObjectFromHandle(GraphicHandle), stkAdr, sci_strings, nbRow, nbCol,
                                                    (char *)propertiesNames[inputIndex]);
                            }
                            break;
                        case sci_handles:
                            GetRhsVar(propertiesValuesIndices[inputIndex], GRAPHICAL_HANDLE_DATATYPE, &nbRow, &nbCol, &stkAdr);
                            setStatus =
                                callSetProperty(pvApiCtx, (char*)getObjectFromHandle(GraphicHandle), stkAdr, sci_handles, nbRow, nbCol,
                                                (char *)propertiesNames[inputIndex]);
                            break;
                        default:
                            setStatus = SET_PROPERTY_ERROR;
                            break;
                    }
                }
                if (setStatus == SET_PROPERTY_ERROR)
                {
                    Scierror(999, _("%s: Could not set property '%s'.\n"), fname, (char *)propertiesNames[inputIndex]);
                    return FALSE;
                }
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(inputIndex = beginIndex; inputIndex < Rhs; inputIndex = inputIndex + 2)
    {
        int isUserDataProperty = 0;
        int iPropertyValuePositionIndex = inputIndex + 1;
        size_t posStackOrAdr = 0;

        
        if (VarType(inputIndex) != sci_strings)
        {
            Scierror(999, _("%s: Wrong type for input argument #%d: A string expected.\n"), fname, inputIndex);
            return FALSE;
        }
        else
        {
            GetRhsVar(inputIndex, STRING_DATATYPE, &nbRow, &nbCol, &stkAdr);
            propertyName = cstk(stkAdr);

            if (stricmp(propertyName, "parent") == 0)
            {
                parentDefined = TRUE;
            }

            isUserDataProperty = (stricmp(propertyName, "user_data") == 0) || (stricmp(propertyName, "userdata") == 0);
        }

        
        switch (VarType(iPropertyValuePositionIndex))
        {
            case sci_matrix:
                if (isUserDataProperty)
                {
                    nbRow = -1;
                    nbCol = -1;
                    posStackOrAdr = iPropertyValuePositionIndex;
                }
                else
                {
                    GetRhsVar(iPropertyValuePositionIndex, MATRIX_OF_DOUBLE_DATATYPE, &nbRow, &nbCol, &stkAdr);
                    posStackOrAdr = stkAdr;
                }
                setStatus = callSetProperty(pvApiCtx, (char*)getObjectFromHandle(GraphicHandle), posStackOrAdr, sci_matrix, nbRow, nbCol, propertyName);
                break;
            case sci_strings:
                if (isUserDataProperty)
                {
                    nbRow = -1;
                    nbCol = -1;
                    posStackOrAdr = iPropertyValuePositionIndex;
                }
                else
                {
                    GetRhsVar(iPropertyValuePositionIndex, STRING_DATATYPE, &nbRow, &nbCol, &stkAdr);
                    posStackOrAdr = stkAdr;
                }
                setStatus = callSetProperty(pvApiCtx, (char*)getObjectFromHandle(GraphicHandle), posStackOrAdr, sci_strings, nbRow, nbCol, propertyName);
                break;
            case sci_handles:
                if (isUserDataProperty)
                {
                    nbRow = -1;
                    nbCol = -1;
                    posStackOrAdr = iPropertyValuePositionIndex;
                }
                else
                {
                    GetRhsVar(iPropertyValuePositionIndex, GRAPHICAL_HANDLE_DATATYPE, &nbRow, &nbCol, &stkAdr);
                    posStackOrAdr = stkAdr;
                }
                setStatus = callSetProperty(pvApiCtx, (char*)getObjectFromHandle(GraphicHandle), posStackOrAdr, sci_handles, nbRow, nbCol, propertyName);
                break;
            case sci_list:
                if (isUserDataProperty)
                {
                    nbRow = -1;
                    nbCol = -1;
                    posStackOrAdr = iPropertyValuePositionIndex;
                }
                else
                {
                    GetRhsVar(iPropertyValuePositionIndex, LIST_DATATYPE, &nbRow, &nbCol, &stkAdr);
                    posStackOrAdr = iPropertyValuePositionIndex;
                }
                setStatus = callSetProperty(pvApiCtx, (char*)getObjectFromHandle(GraphicHandle), posStackOrAdr, sci_list, nbRow, nbCol, propertyName);
                break;
            default:
                setStatus = SET_PROPERTY_ERROR;
                break;
        }
        if (setStatus == SET_PROPERTY_ERROR)
        {
            Scierror(999, _("%s: Could not set property '%s'.\n"), fname, propertyName);
            return FALSE;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < m2; i++)
                            {
                                for(j = 0; j < n2; j++)
                                {
                                    SizeofTextToSendInClipboard = SizeofTextToSendInClipboard + (int)strlen(Str[j * m2 + i]) + (int)strlen("\n") + (int)strlen(" ");
                                    buffer[i * n2 + j] = strdup(Str[j * m2 + i]);
                                }
                            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < m2; i++)
                            {
                                for(j = 0; j < n2; j++)
                                {
                                    strcat(TextToSendInClipboard, buffer[l2++]);
                                    strcat(TextToSendInClipboard, " ");
                                }
                                if ( i != (m2 - 1) )
                                {
                                    strcat(TextToSendInClipboard, "\n");
                                }
                            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(lineIterator = 0 ; lineIterator < n ; ++lineIterator) {
      for(columnIterator = 0 ; columnIterator < lineIterator ; ++columnIterator) {
	elementAddress = l + columnIterator + lineIterator * n;
	symetricElementAddress = l + columnIterator * n + lineIterator;
	realRest = fabs(getElementByAddress(elementAddress) - getElementByAddress(symetricElementAddress));
	if (realRest > 0) {
	  return NOT_SYMMETRIC;
	}
      }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(lineIterator = 0 ; lineIterator < n ; ++lineIterator) {
      elementAddress = l + lineIterator + lineIterator * n;
      symetricElementAddress = elementAddress + size;
      if (fabs(getElementByAddress(symetricElementAddress)) > 0) {
	return NOT_SYMMETRIC;
      }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(lineIterator = 1 ; lineIterator < n ; ++lineIterator) {
      for(columnIterator = 1 ; columnIterator <= lineIterator ; ++columnIterator) {
	elementAddress = l + columnIterator - 1 + lineIterator * n;
	symetricElementAddress = l + (columnIterator - 1) * n + lineIterator;
	realRest = fabs(getElementByAddress(elementAddress) - getElementByAddress(symetricElementAddress));
	imagRest = fabs(getElementByAddress(elementAddress + size) + getElementByAddress(symetricElementAddress + size));
	if (realRest > 0 || imagRest > 0) {
	  return NOT_SYMMETRIC;
	}
      }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 1; j <= ix1; ++j) {
	    t = 0.;
	    ix2 = n;
	    for(ix = 1; ix <= ix2; ++ix) {
		t += (dx1 = *stk(lj + ix ), Abs(dx1));
	    }
	    if (t > rMax) {
		rMax = t;
	    }
	    lj += n;
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 1; k <= n; ++k)
	if (*istk(lib + k - 2 +1) >= 0)  ++nbloc;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 1; k <= n; ++k) {
	if (*istk(lib + k - 2 +1) >= 0) {
	  *stk(lbs + ix ) = (double) *istk(lib + k - 2 +1);
	  ++ix;
	}
      }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < iColsA; i++)
        {
            pdblFinalAlphaReal[i] = pdblFinalAlphaReal[i] / pdblFinalBeta[i];
            pdblFinalAlphaImg[i] = pdblFinalAlphaImg[i] / pdblFinalBeta[i];
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(index = 0; index < size; index++)
    {
        if (values[index] != 0)
        {
            result = 0;
            break;
        }
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < iColsA; i++)
        {
            pdblFinalAlphaReal[i] = pdblFinalAlphaReal[i] / pdblFinalBeta[i];
            pdblFinalAlphaImg[i] = pdblFinalAlphaImg[i] / pdblFinalBeta[i];
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0 ; i < iRows ; i++)
			{
				ij = i + j * iRows;
				EVRealTarget[ij] = EVRealSource[ij];
				EVImgTarget[ij] = ZERO;
			}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0 ; i < iRows ; i++)
			{
				ij = i + j * iRows;
				ij1 = i + (j + 1) * iRows;
				EVRealTarget[ij] = EVRealSource[ij];
				EVImgTarget[ij] = EVRealSource[ij1];
				EVRealTarget[ij1] = EVRealSource[ij];
				EVImgTarget[ij1] = -EVRealSource[ij1];
			}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0 ; i < iRows ; i++)
			{
				ij = i + j * iRows;
				ij1 = i + (j + 1) * iRows;
				EVImg[ij]   =   EVReal[ij1];
				EVImg[ij1]  = - EVReal[ij1];
				EVReal[ij1] =   EVReal[ij];
			}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0 ; i < iRows ; i++)
	{
		ii = i + i * iRows;
		EVRealTarget[ii] = EVRealSource[i];
		EVImgTarget[ii] = EVImgSource[i];
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(icol = 0 ; icol < iRows ; icol++)
	{
		ii = icol+icol * iRows;
		EVRealTarget[ii] = EVSource[icol].r;
		EVImgTarget[ii] = EVSource[icol].i;
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(icol = 0 ; icol < iRows ; icol++)
	{
		ii = icol+icol * iRows;
		EVTarget[ii] = EVSource[icol];
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < *nb_lines * *nb_columns ; ++j)
	    {
	      index_list[j] = NULL;
	    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0; j < i ; ++j)
	    {
	      sscanf(tmp_list[j], "%d,%d", &current_line, &current_column);
	      index_list[(current_column - 1) * *nb_lines + current_line - 1] = tmp_list[j];
	    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<m*n;i++)
	{
		MatrixDouble[i]=*stk(ptrValues++);
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=1;i<m+1;i++)
	{
		char VarValueWithIndice[2048];
		char VarNameWithIndice[2048];

		for(j=1;j<n+1;j++)
		{	
			int bOKsprintf1=0;
			int bOKsprintf2=0;

			bOKsprintf1=sprintf(VarNameWithIndice,"%s(%d,%d)",VarName,i,j);
			bOKsprintf2=sprintf(VarValueWithIndice,"%.10lf",MatrixDouble[(i-1)+m*(j-1)]);

			if ( (bOKsprintf1 == -1) || (bOKsprintf2 == -1) )
			{
				Scierror(999,_("Variable too long.\n"));
				return FALSE;
			}

			if (TCLinterpreter == NULL)
			{
				Scierror(999,_("%s: Error TCL interpreter not initialized.\n"),"TCL_SetVar");
				return FALSE;
			}

			if (!Tcl_SetVar(TCLinterpreter,VarNameWithIndice,VarValueWithIndice,0))
			{
				bOK = FALSE ;
			}
		}
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j=1;j<n+1;j++)
	{
		for(i=1;i<m+1;i++)
		{	
			char VarArrayName[1024];
			sprintf(VarArrayName,"%s(%d,%d)",VarName,i,j);
			if (Tcl_SetVar(TCLinterpreter, VarArrayName, Str[l++], TCL_GLOBAL_ONLY))
			{
				if (TestOnAllTcl_SetVar) TestOnAllTcl_SetVar=TRUE;
			}
			else
			{
				TestOnAllTcl_SetVar = FALSE;
			}
		}
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<(int)strlen(PathUnix);i++)
		{
			if (PathUnix[i]=='\\') PathUnix[i]='/';
		}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(nc = 0 ; nc <= ncomm ; nc++ )
            {
                // TODO : Scilab is supposed to be busy there. Add mutex lock...
                // C2F(tksynchro)(&c_n1);  // set sciprompt to -1 (scilab busy)
                if (C2F(iop).ddt == -1)
                {
                    if (seqf[nc] == 0)
                    {
                        char *msg = _("Flushed execution starts for %s - No option");
                        sciprint_full(msg, comm[nc]);
                        sciprint("\n");
                    }
                    else
                    {
                        char *msg = _("Flushed execution starts for %s - seq");
                        sciprint_full(msg, comm[nc]);
                        sciprint("\n");
                    }
                }
                




                StorePrioritaryCommandWithFlag(comm[nc], seqf[nc]);
                if (C2F(iop).ddt == -1)
                {
                    char *msg = _("Flushed execution ends for %s");
                    sciprint_full(msg, comm[nc]);
                    sciprint("\n");
                }
                FREE(comm[nc]);
                // TODO : Scilab is supposed to be busy there. Add mutex lock...
                // C2F(tksynchro)(&C2F(recu).paus);
                if (ierr != 0) return TCL_ERROR;
            }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(j = 0 ; j < nb_lines * nb_columns ; j++)
					{
						ReturnArrayString[j] = TCL_ArrayGetVar(TCLinterpreter, VarName, index_list[j]);
					}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i<m1*n1 ;i++)
	{

	  if (tclSlave != NULL) {
	    tclInterpReturnValue = sendTclCommandToSlave(Str[i], tclSlave);
	  }
	  else {
	    tclInterpReturnValue = sendTclCommand(Str[i]);
	  }

	  if (tclInterpReturnValue == TCL_ERROR)
	    {
	      const char *trace = NULL;

              
              if (tclSlave != NULL)
                {
                  trace = Tcl_GetVar(Tcl_GetSlave(getTclInterp(),tclSlave), "errorInfo", TCL_GLOBAL_ONLY);
                }
              else
                {
                  trace = Tcl_GetVar(getTclInterp(), "errorInfo", TCL_GLOBAL_ONLY);
                }
	      releaseTclInterp();
	      freeArrayOfString(Str,m1*n1);

              
              if(Err>0) 
		{
		  




		  Scierror(999,"%s, ScilabEval error at line %i\n	%s.\n",fname,i+1,(char *)trace);
		}
	      else 
		{
                  const char *result = NULL;

                  if (tclSlave != NULL) 
                    {
                      result = Tcl_GetStringResult(Tcl_GetSlave(getTclInterp(),tclSlave));
                    }
                  else 
                    {
                      result = Tcl_GetStringResult(getTclInterp());
                    }
                  Scierror(999,"%s, %s at line %i\n	%s\n", fname, (char *)result, i+1, (char *)trace);
		  releaseTclInterp();
		}
	      return 0;
            }
	  else
	    {
	      
	      
	      ReturnArrayString[k++] = getTclCommandResult();
            }
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 0; k < lenResults; k++) dResults[k] = 0;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(k = 0; k < nbElements; k++)
        {
            int iErr2 = 0;
            double *dConverted = getConvertedDateAsDoubleVector(dDates[k], &iErr2);
            if (iErr2 == 0)
            {
                int n = 0;
                for(n = 0; n < NB_ELEMNT_ARRAY_GETDATE; n++)
                {
                    dResults[j] = dConverted[n];
                    j++;
                }
                FREE(dConverted);
                dConverted = NULL;
            }
            else
            {
                FREE(dResults);
                FREE(dConverted);
                dResults = NULL;
                *iErr = iErr2;
                return NULL;
            }
        }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < nbElements; i++)
                {
                    if (dValues[i] < 0.)
                    {
                        Scierror(999,_("%s: Wrong value for input argument #%d: Must be > %d.\n"), fname, 1, 0);
                        return 0;
                    }
                }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i=0;i<NBRDAY*NBRWEEK;i++) CALMONTH[i]=0;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(day = 0; day < day_1; ++day) a++;



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(day = 1; day <= numdays; ++day, ++day_1, day_1 %= 7)
    {
        CALMONTH[a]= day;
		a++;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i=0; i < cSymbols; i++ ) 
	{
		fprintf(fout, "%04X ", i);
		if ( pSymbolTable->N.Name.Short != 0 ) fprintf(fout, "%-20.8s", pSymbolTable->N.ShortName);
		else fprintf(fout, "%-20s", stringTable + pSymbolTable->N.Name.Long);
		fprintf(fout, " %08X", (unsigned int)pSymbolTable->Value);

		GetSectionName(pSymbolTable->SectionNumber, sectionName,sizeof(sectionName));
		fprintf(fout, " sect:%s aux:%X type:%02X st:%s\n",
	       sectionName,
	       pSymbolTable->NumberOfAuxSymbols,
	       pSymbolTable->Type,
	       GetSZStorageClass(pSymbolTable->StorageClass) );
		


		i += pSymbolTable->NumberOfAuxSymbols;
		pSymbolTable += pSymbolTable->NumberOfAuxSymbols;
		pSymbolTable++;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for( i=0; i < cSymbols; i++ ) 
	{
		if (pSymbolTable->SectionNumber > 0 && pSymbolTable->Type == 0x20) 
		{
			if (pSymbolTable->StorageClass == IMAGE_SYM_CLASS_EXTERNAL) 
			{
				if (pSymbolTable->N.Name.Short != 0) 
				{
					strncpy(symbol, (const char*)pSymbolTable->N.ShortName, 8);
					symbol[8] = 0;
				}
				else 
				{
					s = stringTable + pSymbolTable->N.Name.Long;
					strcpy(symbol, s);
				}
				s = symbol;
				f = strchr(s, '@');
				if (f) 
				{
					*f = 0;
				}
#if defined(_MSC_VER) && ( defined(_X86_) )
				if (symbol[0] == '_') 
				{
					s = &symbol[1];
				}
#endif
				if (( stricmp(s, "DllEntryPoint") != 0) 
					&& (stricmp(s, "DllMain") != 0)) 
				{
					if ( s[0] != '?' ) fprintf(fout, "\t%s\n", s);
				}
			}
		}
		


		i += pSymbolTable->NumberOfAuxSymbols;
		pSymbolTable += pSymbolTable->NumberOfAuxSymbols;
		pSymbolTable++;
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(; arg < argc; arg++) 
	{
		if (argv[arg][0] == '@') 
		{
			FILE *fargs = fopen(&argv[arg][1], "r");
			if (fargs == NULL) 
			{
				fprintf(stderr, "Unable to open \'%s\' for reading:\n",
				argv[arg]);
				perror("");
				exit(1);
			}
			pos = 0;
			for(i = 0; i < arg; i++) 
			{
				strcpy(&cmdline[pos], argv[i]);
				pos += (int)strlen(&cmdline[pos]) + 1;
				fargv[i] = argv[i];
			}
			fgets(&cmdline[pos], sizeof(cmdline), fargs);
			fprintf(stderr, "%s\n", &cmdline[pos]);
			fclose(fargs);
			i += GetArgcArgv(&cmdline[pos], &fargv[i]);
			argc = i;
			argv = fargv;
		}
		DumpFile(argv[arg], fout, full);
    }


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < xpathObj->nodesetval->nodeNr; i++)
								{
									xmlAttrPtr attrib = xpathObj->nodesetval->nodeTab[i]->properties;
									CPUS_BLAS_SPEC[i] = (struct cpu_struct *) malloc(sizeof(struct cpu_struct));
									if (CPUS_BLAS_SPEC[i])
									{
										while(attrib != NULL)
										{
											if (xmlStrEqual (attrib->name, (const xmlChar*) "cpu_manufacturer"))
											{ 
												
												CPUS_BLAS_SPEC[i]->cpu_vendor = toWideString((char*)attrib->children->content);
											}

											if (xmlStrEqual (attrib->name, (const xmlChar*) "cpu_family"))
											{ 
												
												if (strcmp((char*)attrib->children->content, "*") == 0)
												{
													CPUS_BLAS_SPEC[i]->cpu_family = 0;
												}
												else
												{
													CPUS_BLAS_SPEC[i]->cpu_family = atoi((char*)attrib->children->content);
												}
											}

											if (xmlStrEqual (attrib->name, (const xmlChar*) "cpu_model"))
											{ 
												
												if (strcmp((char*)attrib->children->content, "*") == 0)
												{
													CPUS_BLAS_SPEC[i]->cpu_model = 0;
												}
												else
												{
													CPUS_BLAS_SPEC[i]->cpu_model = atoi((char*)attrib->children->content);
												}
											}

											if (xmlStrEqual (attrib->name, (const xmlChar*) "dll_filename"))
											{ 
												
												CPUS_BLAS_SPEC[i]->dll_filename = toWideString((char*)attrib->children->content);
											}

											if (xmlStrEqual (attrib->name, (const xmlChar*) "comments"))
											{ 
												
												CPUS_BLAS_SPEC[i]->comments = toWideString((char*)attrib->children->content);
											}
											attrib = attrib->next;
										}
									}
									*sizeArrayReturned = i;
								}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < sizeCPUS_SPEC; i++)
	{
		if (wcscmp(CPUS_SPEC[i]->cpu_vendor, CurrentCpuManufacturer) == 0)
		{
			if (CPUS_SPEC[i]->cpu_family == CurrentCpuFamily)
			{
				if (CPUS_SPEC[i]->cpu_model == CurrentCpuModel)
				{
					return _wcsdup(CPUS_SPEC[i]->dll_filename);
				}
				else
				{
					if (CPUS_SPEC[i]->cpu_model == 0)
					{
						return _wcsdup(CPUS_SPEC[i]->dll_filename);
					}
				}
			}
		}
	}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


for(i = 0; i < sizeCPUS_SPEC; i++)
		{
			if (CPUS_SPEC[i])
			{
				if (CPUS_SPEC[i]->comments)
				{
					free(CPUS_SPEC[i]->comments);
					CPUS_SPEC[i]->comments = NULL;
				}
				if (CPUS_SPEC[i]->cpu_vendor)
				{
					free(CPUS_SPEC[i]->cpu_vendor);
					CPUS_SPEC[i]->cpu_vendor = NULL;
				}
				if (CPUS_SPEC[i]->dll_filename)
				{
					free(CPUS_SPEC[i]->dll_filename);
					CPUS_SPEC[i]->dll_filename = NULL;
				}
				free(CPUS_SPEC[i]);
				CPUS_SPEC[i] = NULL;
			}
		}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^



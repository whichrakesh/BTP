filename: /home/rakesh/Dropbox/Study/Sem-7/BTP-I/for_loop_extracted/quantlib.txt
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLibAddin/Clients/CppInstrumentIn/instrument_in.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: int i = 4  i < argc  i += 1
induction variable: ['i']
{
L1: (argv[i],r) 
}
array table
-----------------------------------------------
argv -> [('[i]', 'r', 'normalized', ['i'], 1)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: unsigned int index = 0  index < vecMaketfiles.size()  ++index
induction variable: ['index']
{
L2: (vecMaketfiles[index],r) 
}
array table
-----------------------------------------------
vecMaketfiles -> [('[index]', 'r', 'normalized', ['index'], 2)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLibAddin/qlo/basketlossmodels.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLibAddin/qlo/swaptionvolstructure.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: QuantLib::Size i=0  i<sabrParameters.rows()  ++i
induction variable: ['i']
{
	loop info: QuantLib::Size j=0  j<sabrParameters.columns()-1  ++j
	induction variable: ['i', 'j']
	{
	L3: (par[j]=,w) (sabrParameters[i][j],r) 
	}
L4: (sabrParameters[i][numberOfColumn-1],r) 
L5: (par[numberOfColumn-1]=,w) 
}
array table
-----------------------------------------------
par -> [('[j]', 'w', 'normalized', ['i', 'j'], 3), ('[numberOfColumn-1]', 'w', 'not normalized', ['i', 'j'], 5)]
LDEs formed:3

sabrParameters -> [('[i][j]', 'r', 'normalized', ['i', 'j'], 3), ('[i][numberOfColumn-1]', 'r', 'not normalized', ['i', 'j'], 4)]
LDEs formed:0

distinct LDEs:
numberOfColumn-1=numberOfColumn-1
j1=j2
j1=numberOfColumn-1
#########################################################################################
loop info: QuantLib::Size i=0  i<volCube.rows()  ++i
induction variable: ['i']
{
	loop info: QuantLib::Size j=0  j<volCube.columns()  ++j
	induction variable: ['i', 'j']
	{
	L5: (vol[j]=,w) (volCube[i][j],r) 
	}
 }
array table
-----------------------------------------------
vol -> [('[j]', 'w', 'normalized', ['i', 'j'], 5)]
LDEs formed:1

volCube -> [('[i][j]', 'r', 'normalized', ['i', 'j'], 5)]
LDEs formed:0

distinct LDEs:
j1=j2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLibAddin/qlo/bonds.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<n  ++i
induction variable: ['i']
{
L6: (bonds[i]-,r) 
L7: (bonds[i]-,r) 
}
array table
-----------------------------------------------
bonds -> [('[i]', 'r', 'normalized', ['i'], 6), ('[i]', 'r', 'normalized', ['i'], 7)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<bonds.size()  ++i
induction variable: ['i']
{
L8: (bonds[i]-,r) 
L9: (bonds[i]-,r) 
}
array table
-----------------------------------------------
bonds -> [('[i]', 'r', 'normalized', ['i'], 8), ('[i]', 'r', 'normalized', ['i'], 9)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<n  ++i
induction variable: ['i']
{
L10: (bonds[i]-,r) 
L11: (bonds[i]-,r) 
L12: (bondItems[i]=,w) 
}
array table
-----------------------------------------------
bondItems -> [('[i]', 'w', 'normalized', ['i'], 12)]
LDEs formed:1

bonds -> [('[i]', 'r', 'normalized', ['i'], 10), ('[i]', 'r', 'normalized', ['i'], 11)]
LDEs formed:0

distinct LDEs:
i1=i2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLibAddin/qlo/smilesection.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLibAddin/qlo/couponvectors.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLibAddin/qlo/defaultbasket.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLibAddin/qlo/timeseries.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<values.size()  ++i
induction variable: ['i']
{
L12: (values[i],r) 
L13: (dates[i],r) 
L14: (values[i],r) 
}
array table
-----------------------------------------------
dates -> [('[i]', 'r', 'normalized', ['i'], 13)]
LDEs formed:0

values -> [('[i]', 'r', 'normalized', ['i'], 12), ('[i]', 'r', 'normalized', ['i'], 14)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLibAddin/qlo/leg.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: QuantLib::Size i=0  i<amounts.size()  ++i
induction variable: ['i']
{
L15: (dates[i],r) 
L16: (amounts[i],r) (dates[i],r) 
L17: (amounts[i]==,r) (amounts[i]==,r) 
L18: (amounts[i]<<,r) 
}
array table
-----------------------------------------------
amounts -> [('[i]', 'r', 'normalized', ['i'], 16), ('[i]', 'r', 'normalized', ['i'], 17), ('[i]', 'r', 'normalized', ['i'], 17), ('[i]', 'r', 'normalized', ['i'], 18)]
LDEs formed:0

dates -> [('[i]', 'r', 'normalized', ['i'], 15), ('[i]', 'r', 'normalized', ['i'], 16)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: QuantLib::Size i=0  i<legs.size()  ++i
induction variable: ['i']
{
L17: (legs[i]-,r) 
}
array table
-----------------------------------------------
legs -> [('[i]', 'r', 'normalized', ['i'], 17)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLibAddin/qlo/date.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLibAddin/qlo/sequencestatistics.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLibAddin/qlo/piecewiseyieldcurve.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLibAddin/qlo/quotes.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: QuantLib::Size i=0  i<q.size()  ++i
induction variable: ['i']
{
L18: (sq[i]=,w) (q[i].size,r) 
	loop info: QuantLib::Size j=0  j<q[i].size()  ++j
	induction variable: ['i', 'j']
	{
	L19: (q[i][j].currentLink,r) 
	L20: (sq[i][j]=,w) 
	}
 }
array table
-----------------------------------------------
q -> [('[i]', 'r', 'normalized', ['i', 'j'], 18), ('[i][j]', 'r', 'normalized', ['i', 'j'], 19)]
LDEs formed:0

sq -> [('[i]', 'w', 'normalized', ['i', 'j'], 18), ('[i][j]', 'w', 'normalized', ['i', 'j'], 20)]
LDEs formed:6

distinct LDEs:
i1=i2,j1=j2
i1=i2
#########################################################################################
loop info: QuantLib::Size i=0  i<n   ++i
induction variable: ['i']
{
L21: (quotes[i].currentLink,r) 
L22: (simpleQuotes[i]=,w) 
}
array table
-----------------------------------------------
quotes -> [('[i]', 'r', 'normalized', ['i'], 21)]
LDEs formed:0

simpleQuotes -> [('[i]', 'w', 'normalized', ['i'], 22)]
LDEs formed:1

distinct LDEs:
i1=i2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLibAddin/qlo/ratehelpers.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: QuantLib::Size i=0  i<nInstruments  ++i
induction variable: ['i']
{
L23: (qlarhs[i],r) 
L24: (priority[i],r) 
L25: (minDist[0],r) (minDist[i],r) 
}
array table
-----------------------------------------------
priority -> [('[i]', 'r', 'normalized', ['i'], 24)]
LDEs formed:0

qlarhs -> [('[i]', 'r', 'normalized', ['i'], 23)]
LDEs formed:0

minDist -> [('[0]', 'r', 'normalized', ['i'], 25), ('[i]', 'r', 'normalized', ['i'], 25)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: QuantLib::Size i=0  i<nInstruments  ++i
induction variable: ['i']
{
L26: (rhsAll[i].earliestDate,r) 
L27: (rhsAll[i].isDepo,r) 
L28: (rhsAll[i],r) 
L29: (rhsAll[i].latestDate,r) 
L30: (rhsAll[i],r) 
L31: (rhsAll[i].latestDate,r) 
L32: (rhsAll[i],r) 
L33: (rhsAll[i],r) 
L34: (rhsAll[i].latestDate,r) 
L35: (rhsAll[i],r) 
L36: (rhsAll[i].isSerialFutures,r) 
L37: (rhsAll[i].earliestDate-,r) 
L38: (rhsAll[i],r) 
L39: (rhsAll[i].isMainFutures,r) 
L40: (rhsAll[i].earliestDate-,r) 
L41: (rhsAll[i],r) 
L42: (rhsAll[i],r) 
}
array table
-----------------------------------------------
rhsAll -> [('[i]', 'r', 'normalized', ['i'], 26), ('[i]', 'r', 'normalized', ['i'], 27), ('[i]', 'r', 'normalized', ['i'], 28), ('[i]', 'r', 'normalized', ['i'], 29), ('[i]', 'r', 'normalized', ['i'], 30), ('[i]', 'r', 'normalized', ['i'], 31), ('[i]', 'r', 'normalized', ['i'], 32), ('[i]', 'r', 'normalized', ['i'], 33), ('[i]', 'r', 'normalized', ['i'], 34), ('[i]', 'r', 'normalized', ['i'], 35), ('[i]', 'r', 'normalized', ['i'], 36), ('[i]', 'r', 'normalized', ['i'], 37), ('[i]', 'r', 'normalized', ['i'], 38), ('[i]', 'r', 'normalized', ['i'], 39), ('[i]', 'r', 'normalized', ['i'], 40), ('[i]', 'r', 'normalized', ['i'], 41), ('[i]', 'r', 'normalized', ['i'], 42)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLibAddin/qlo/randomsequencegenerator.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLibAddin/qlo/interpolation.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLibAddin/qlo/cmsmarket.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLibAddin/qlo/flowanalysis.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: QuantLib::Size i=0  i<leg.size()  ++i
induction variable: ['i']
{
L43: (leg[i]-,r) 
L44: (leg[i]-,r) 
}
array table
-----------------------------------------------
leg -> [('[i]', 'r', 'normalized', ['i'], 43), ('[i]', 'r', 'normalized', ['i'], 44)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLibAddin/qlo/swap.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: QuantLib::Size i=0  i<legPtrs.size()  ++i
induction variable: ['i']
{
L45: (legPtrs[i]-,r) 
L46: (legs[i]=,w) 
}
array table
-----------------------------------------------
legPtrs -> [('[i]', 'r', 'normalized', ['i'], 45)]
LDEs formed:0

legs -> [('[i]', 'w', 'normalized', ['i'], 46)]
LDEs formed:1

distinct LDEs:
i1=i2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLibAddin/qlo/index.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: QuantLib::Size i=0  i<values.size()  ++i
induction variable: ['i']
{
L47: (values[i],r) 
L48: (dates[i],r) 
L49: (values[i],r) 
}
array table
-----------------------------------------------
dates -> [('[i]', 'r', 'normalized', ['i'], 48)]
LDEs formed:0

values -> [('[i]', 'r', 'normalized', ['i'], 47), ('[i]', 'r', 'normalized', ['i'], 49)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLibAddin/qlo/serialization/processor.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLibAddin/qlo/conversions/conversions.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: unsigned int r=0  r<m.rows()  ++r
induction variable: ['r']
{
	loop info: unsigned int c=0  c<m.columns()  ++c
	induction variable: ['r', 'c']
	{
	L50: (m[r][c],r) 
	}
 }
array table
-----------------------------------------------
m -> [('[r][c]', 'r', 'normalized', ['r', 'c'], 50)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLibAddin/Addins/Guile/guileutils.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: std::size_t i = properties.size()   --i != std::size_t(-1)   
induction variable: []
{
L51: (properties[i],r) 
}
array table
-----------------------------------------------
properties -> [('[i]', 'r', 'not normalized', [], 51)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLibAddin/Addins/Calc_old/conversions.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: int i=0  i<in.getLength()  ++i
induction variable: ['i']
{
	loop info: int j=0  j<in[i].getLength()  ++j
	induction variable: ['i', 'j']
	{
	L52: (in[i][j],r) 
	}
 }
array table
-----------------------------------------------
in -> [('[i][j]', 'r', 'normalized', ['i', 'j'], 52)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: int i=0  i<rows  ++i
induction variable: ['i']
{
L53: (in[i],r) 
	loop info: int j=0  j<cols  ++j
	induction variable: ['i', 'j']
	{
	L54: (m[i][j]=,w) (row[j],r) 
	}
 }
array table
-----------------------------------------------
row -> [('[j]', 'r', 'normalized', ['i', 'j'], 54)]
LDEs formed:0

m -> [('[i][j]', 'w', 'normalized', ['i', 'j'], 54)]
LDEs formed:2

in -> [('[i]', 'r', 'normalized', ['i', 'j'], 53)]
LDEs formed:0

distinct LDEs:
i1=i2,j1=j2
#########################################################################################
loop info: unsigned int i=0  i<v.size()  ++i
induction variable: ['i']
{
L54: (s[0]=,w) (v[i].serialNumber,r) 
L55: (ret[i]=,w) 
}
array table
-----------------------------------------------
s -> [('[0]', 'w', 'normalized', ['i'], 54)]
LDEs formed:1

ret -> [('[i]', 'w', 'normalized', ['i'], 55)]
LDEs formed:1

v -> [('[i]', 'r', 'normalized', ['i'], 54)]
LDEs formed:0

distinct LDEs:
0=0
i1=i2
#########################################################################################
loop info: unsigned int i=0  i<in.size()  ++i
induction variable: ['i']
{
L55: (s[0]=,w) (in[i],r) 
L56: (ret[i]=,w) 
}
array table
-----------------------------------------------
s -> [('[0]', 'w', 'normalized', ['i'], 55)]
LDEs formed:1

ret -> [('[i]', 'w', 'normalized', ['i'], 56)]
LDEs formed:1

in -> [('[i]', 'r', 'normalized', ['i'], 55)]
LDEs formed:0

distinct LDEs:
0=0
i1=i2
#########################################################################################
loop info: unsigned int i=0  i<in.rows()  ++i
induction variable: ['i']
{
	loop info: unsigned int j=0  j<in.columns()  ++j
	induction variable: ['i', 'j']
	{
	L56: (s[j]=,w) (in[i][j],r) 
	}
L57: (ret[i]=,w) 
}
array table
-----------------------------------------------
s -> [('[j]', 'w', 'normalized', ['i', 'j'], 56)]
LDEs formed:1

ret -> [('[i]', 'w', 'normalized', ['i', 'j'], 57)]
LDEs formed:1

in -> [('[i][j]', 'r', 'normalized', ['i', 'j'], 56)]
LDEs formed:0

distinct LDEs:
j1=j2
i1=i2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLibAddin/Addins/Calc_old/calcutils.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: unsigned int i=0  i<v.size()  ++i
induction variable: ['i']
{
L57: (s[0]=,w) (v[i],r) 
L58: (ss[i]=,w) 
}
array table
-----------------------------------------------
ss -> [('[i]', 'w', 'normalized', ['i'], 58)]
LDEs formed:1

s -> [('[0]', 'w', 'normalized', ['i'], 57)]
LDEs formed:1

v -> [('[i]', 'r', 'normalized', ['i'], 57)]
LDEs formed:0

distinct LDEs:
0=0
i1=i2
#########################################################################################
loop info: unsigned int i=0  i<v.size()  ++i
induction variable: ['i']
{
L58: (s[0]=,w) (v[i],r) 
L59: (ss[i]=,w) 
}
array table
-----------------------------------------------
ss -> [('[i]', 'w', 'normalized', ['i'], 59)]
LDEs formed:1

s -> [('[0]', 'w', 'normalized', ['i'], 58)]
LDEs formed:1

v -> [('[i]', 'r', 'normalized', ['i'], 58)]
LDEs formed:0

distinct LDEs:
0=0
i1=i2
#########################################################################################
loop info: unsigned int i=0  i<v.size()  ++i
induction variable: ['i']
{
L59: (v[i],r) 
L60: (s[0]=,w) 
L61: (ss[i]=,w) 
}
array table
-----------------------------------------------
ss -> [('[i]', 'w', 'normalized', ['i'], 61)]
LDEs formed:1

s -> [('[0]', 'w', 'normalized', ['i'], 60)]
LDEs formed:1

v -> [('[i]', 'r', 'normalized', ['i'], 59)]
LDEs formed:0

distinct LDEs:
0=0
i1=i2
#########################################################################################
loop info: unsigned int i=0  i<v.size()  ++i
induction variable: ['i']
{
L60: (s[0]=,w) (v[i].c_str,r) 
L61: (ss[i]=,w) 
}
array table
-----------------------------------------------
ss -> [('[i]', 'w', 'normalized', ['i'], 61)]
LDEs formed:1

s -> [('[0]', 'w', 'normalized', ['i'], 60)]
LDEs formed:1

v -> [('[i]', 'r', 'normalized', ['i'], 60)]
LDEs formed:0

distinct LDEs:
0=0
i1=i2
#########################################################################################
loop info: unsigned int i=0  i<v.size()  ++i
induction variable: ['i']
{
L61: (s[0],r) (v[i],r) 
L62: (ss[i]=,w) 
}
array table
-----------------------------------------------
ss -> [('[i]', 'w', 'normalized', ['i'], 62)]
LDEs formed:1

s -> [('[0]', 'r', 'normalized', ['i'], 61)]
LDEs formed:0

v -> [('[i]', 'r', 'normalized', ['i'], 61)]
LDEs formed:0

distinct LDEs:
i1=i2
#########################################################################################
loop info: unsigned int i=0  i<vv.size()  ++i
induction variable: ['i']
{
L62: (vv[i],r) 
	loop info: unsigned int j=0  j<v.size()  ++j
	induction variable: ['i', 'j']
	{
	}
L63: (ss[i]=,w) 
}
array table
-----------------------------------------------
ss -> [('[i]', 'w', 'normalized', ['i', 'j'], 63)]
LDEs formed:1

vv -> [('[i]', 'r', 'normalized', ['i', 'j'], 62)]
LDEs formed:0

distinct LDEs:
i1=i2
#########################################################################################
loop info: unsigned int i=0  i<vv.size()  ++i
induction variable: ['i']
{
L63: (vv[i],r) 
	loop info: unsigned int j=0  j<v.size()  ++j
	induction variable: ['i', 'j']
	{
	}
L64: (ss[i]=,w) 
}
array table
-----------------------------------------------
ss -> [('[i]', 'w', 'normalized', ['i', 'j'], 64)]
LDEs formed:1

vv -> [('[i]', 'r', 'normalized', ['i', 'j'], 63)]
LDEs formed:0

distinct LDEs:
i1=i2
#########################################################################################
loop info: unsigned int i=0  i<vv.size()  ++i
induction variable: ['i']
{
L64: (vv[i],r) 
	loop info: unsigned int j=0  j<v.size()  ++j
	induction variable: ['i', 'j']
	{
	L65: (v[j],r) 
	L66: (s[j]=,w) 
	}
L67: (ss[i]=,w) 
}
array table
-----------------------------------------------
ss -> [('[i]', 'w', 'normalized', ['i', 'j'], 67)]
LDEs formed:1

s -> [('[j]', 'w', 'normalized', ['i', 'j'], 66)]
LDEs formed:1

vv -> [('[i]', 'r', 'normalized', ['i', 'j'], 64)]
LDEs formed:0

v -> [('[j]', 'r', 'normalized', ['i', 'j'], 65)]
LDEs formed:0

distinct LDEs:
j1=j2
i1=i2
#########################################################################################
loop info: unsigned int i=0  i<vv.size()  ++i
induction variable: ['i']
{
L66: (vv[i],r) 
	loop info: unsigned int j=0  j<v.size()  ++j
	induction variable: ['i', 'j']
	{
	}
L67: (ss[i]=,w) 
}
array table
-----------------------------------------------
ss -> [('[i]', 'w', 'normalized', ['i', 'j'], 67)]
LDEs formed:1

vv -> [('[i]', 'r', 'normalized', ['i', 'j'], 66)]
LDEs formed:0

distinct LDEs:
i1=i2
#########################################################################################
loop info: unsigned int i=0  i<vv.size()  ++i
induction variable: ['i']
{
L67: (vv[i],r) 
	loop info: unsigned int j=0  j<v.size()  ++j
	induction variable: ['i', 'j']
	{
	}
L68: (ss[i]=,w) 
}
array table
-----------------------------------------------
ss -> [('[i]', 'w', 'normalized', ['i', 'j'], 68)]
LDEs formed:1

vv -> [('[i]', 'r', 'normalized', ['i', 'j'], 67)]
LDEs formed:0

distinct LDEs:
i1=i2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLibAddin/Addins/Calc/conversions.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: unsigned int i=0  i<v.size()  ++i
induction variable: ['i']
{
L68: (s[0]=,w) (v[i],r) 
L69: (ss[i]=,w) 
}
array table
-----------------------------------------------
ss -> [('[i]', 'w', 'normalized', ['i'], 69)]
LDEs formed:1

s -> [('[0]', 'w', 'normalized', ['i'], 68)]
LDEs formed:1

v -> [('[i]', 'r', 'normalized', ['i'], 68)]
LDEs formed:0

distinct LDEs:
0=0
i1=i2
#########################################################################################
loop info: unsigned int i=0  i<v.size()  ++i
induction variable: ['i']
{
L69: (s[0]=,w) (v[i],r) 
L70: (ss[i]=,w) 
}
array table
-----------------------------------------------
ss -> [('[i]', 'w', 'normalized', ['i'], 70)]
LDEs formed:1

s -> [('[0]', 'w', 'normalized', ['i'], 69)]
LDEs formed:1

v -> [('[i]', 'r', 'normalized', ['i'], 69)]
LDEs formed:0

distinct LDEs:
0=0
i1=i2
#########################################################################################
loop info: unsigned int i=0  i<v.size()  ++i
induction variable: ['i']
{
L70: (v[i],r) 
L71: (s[0]=,w) 
L72: (ss[i]=,w) 
}
array table
-----------------------------------------------
ss -> [('[i]', 'w', 'normalized', ['i'], 72)]
LDEs formed:1

s -> [('[0]', 'w', 'normalized', ['i'], 71)]
LDEs formed:1

v -> [('[i]', 'r', 'normalized', ['i'], 70)]
LDEs formed:0

distinct LDEs:
0=0
i1=i2
#########################################################################################
loop info: unsigned int i=0  i<v.size()  ++i
induction variable: ['i']
{
L71: (s[0]=,w) (v[i].c_str,r) 
L72: (ss[i]=,w) 
}
array table
-----------------------------------------------
ss -> [('[i]', 'w', 'normalized', ['i'], 72)]
LDEs formed:1

s -> [('[0]', 'w', 'normalized', ['i'], 71)]
LDEs formed:1

v -> [('[i]', 'r', 'normalized', ['i'], 71)]
LDEs formed:0

distinct LDEs:
0=0
i1=i2
#########################################################################################
loop info: unsigned int i=0  i<v.size()  ++i
induction variable: ['i']
{
L72: (s[0],r) (v[i],r) 
L73: (ss[i]=,w) 
}
array table
-----------------------------------------------
ss -> [('[i]', 'w', 'normalized', ['i'], 73)]
LDEs formed:1

s -> [('[0]', 'r', 'normalized', ['i'], 72)]
LDEs formed:0

v -> [('[i]', 'r', 'normalized', ['i'], 72)]
LDEs formed:0

distinct LDEs:
i1=i2
#########################################################################################
loop info: unsigned int i=0  i<vv.size()  ++i
induction variable: ['i']
{
L73: (vv[i],r) 
	loop info: unsigned int j=0  j<v.size()  ++j
	induction variable: ['i', 'j']
	{
	}
L74: (ss[i]=,w) 
}
array table
-----------------------------------------------
ss -> [('[i]', 'w', 'normalized', ['i', 'j'], 74)]
LDEs formed:1

vv -> [('[i]', 'r', 'normalized', ['i', 'j'], 73)]
LDEs formed:0

distinct LDEs:
i1=i2
#########################################################################################
loop info: unsigned int i=0  i<vv.size()  ++i
induction variable: ['i']
{
L74: (vv[i],r) 
	loop info: unsigned int j=0  j<v.size()  ++j
	induction variable: ['i', 'j']
	{
	}
L75: (ss[i]=,w) 
}
array table
-----------------------------------------------
ss -> [('[i]', 'w', 'normalized', ['i', 'j'], 75)]
LDEs formed:1

vv -> [('[i]', 'r', 'normalized', ['i', 'j'], 74)]
LDEs formed:0

distinct LDEs:
i1=i2
#########################################################################################
loop info: unsigned int i=0  i<vv.size()  ++i
induction variable: ['i']
{
L75: (vv[i],r) 
	loop info: unsigned int j=0  j<v.size()  ++j
	induction variable: ['i', 'j']
	{
	L76: (v[j],r) 
	L77: (s[j]=,w) 
	}
L78: (ss[i]=,w) 
}
array table
-----------------------------------------------
ss -> [('[i]', 'w', 'normalized', ['i', 'j'], 78)]
LDEs formed:1

s -> [('[j]', 'w', 'normalized', ['i', 'j'], 77)]
LDEs formed:1

vv -> [('[i]', 'r', 'normalized', ['i', 'j'], 75)]
LDEs formed:0

v -> [('[j]', 'r', 'normalized', ['i', 'j'], 76)]
LDEs formed:0

distinct LDEs:
j1=j2
i1=i2
#########################################################################################
loop info: unsigned int i=0  i<vv.size()  ++i
induction variable: ['i']
{
L77: (vv[i],r) 
	loop info: unsigned int j=0  j<v.size()  ++j
	induction variable: ['i', 'j']
	{
	}
L78: (ss[i]=,w) 
}
array table
-----------------------------------------------
ss -> [('[i]', 'w', 'normalized', ['i', 'j'], 78)]
LDEs formed:1

vv -> [('[i]', 'r', 'normalized', ['i', 'j'], 77)]
LDEs formed:0

distinct LDEs:
i1=i2
#########################################################################################
loop info: unsigned int i=0  i<vv.size()  ++i
induction variable: ['i']
{
L78: (vv[i],r) 
	loop info: unsigned int j=0  j<v.size()  ++j
	induction variable: ['i', 'j']
	{
	}
L79: (ss[i]=,w) 
}
array table
-----------------------------------------------
ss -> [('[i]', 'w', 'normalized', ['i', 'j'], 79)]
LDEs formed:1

vv -> [('[i]', 'r', 'normalized', ['i', 'j'], 78)]
LDEs formed:0

distinct LDEs:
i1=i2
#########################################################################################
loop info: int i=0  i<ss.getLength()  ++i
induction variable: ['i']
{
	loop info: int j=0  j<ss[i].getLength()  ++j
	induction variable: ['i', 'j']
	{
	L79: (ss[i][j],r) 
	}
 }
array table
-----------------------------------------------
ss -> [('[i][j]', 'r', 'normalized', ['i', 'j'], 79)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: int i=0  i<ss.getLength()  ++i
induction variable: ['i']
{
	loop info: int j=0  j<ss[i].getLength()  ++j
	induction variable: ['i', 'j']
	{
	L80: (ss[i][j],r) 
	}
 }
array table
-----------------------------------------------
ss -> [('[i][j]', 'r', 'normalized', ['i', 'j'], 80)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: int i=0  i<ss.getLength()  ++i
induction variable: ['i']
{
	loop info: int j=0  j<ss[i].getLength()  ++j
	induction variable: ['i', 'j']
	{
	L81: (ss[i][j],r) 
	}
 }
array table
-----------------------------------------------
ss -> [('[i][j]', 'r', 'normalized', ['i', 'j'], 81)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: int i=0  i<ss.getLength()  ++i
induction variable: ['i']
{
	loop info: int j=0  j<ss[i].getLength()  ++j
	induction variable: ['i', 'j']
	{
	L82: (ss[i][j],r) 
	}
 }
array table
-----------------------------------------------
ss -> [('[i][j]', 'r', 'normalized', ['i', 'j'], 82)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: int i=0  i<ss.getLength()  ++i
induction variable: ['i']
{
	loop info: int j=0  j<ss[i].getLength()  ++j
	induction variable: ['i', 'j']
	{
	L83: (ss[i][j],r) 
	}
 }
array table
-----------------------------------------------
ss -> [('[i][j]', 'r', 'normalized', ['i', 'j'], 83)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: unsigned int i=0  i<v.size()  ++i
induction variable: ['i']
{
L84: (s[0],r) (v[i],r) 
L85: (ret[i]=,w) 
}
array table
-----------------------------------------------
s -> [('[0]', 'r', 'normalized', ['i'], 84)]
LDEs formed:0

ret -> [('[i]', 'w', 'normalized', ['i'], 85)]
LDEs formed:1

v -> [('[i]', 'r', 'normalized', ['i'], 84)]
LDEs formed:0

distinct LDEs:
i1=i2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLibAddin/Addins/Calc/calcutils.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: unsigned int i=0  i<v.size()  ++i
induction variable: ['i']
{
L85: (s[0]=,w) (v[i],r) 
L86: (ss[i]=,w) 
}
array table
-----------------------------------------------
ss -> [('[i]', 'w', 'normalized', ['i'], 86)]
LDEs formed:1

s -> [('[0]', 'w', 'normalized', ['i'], 85)]
LDEs formed:1

v -> [('[i]', 'r', 'normalized', ['i'], 85)]
LDEs formed:0

distinct LDEs:
0=0
i1=i2
#########################################################################################
loop info: unsigned int i=0  i<v.size()  ++i
induction variable: ['i']
{
L86: (s[0]=,w) (v[i],r) 
L87: (ss[i]=,w) 
}
array table
-----------------------------------------------
ss -> [('[i]', 'w', 'normalized', ['i'], 87)]
LDEs formed:1

s -> [('[0]', 'w', 'normalized', ['i'], 86)]
LDEs formed:1

v -> [('[i]', 'r', 'normalized', ['i'], 86)]
LDEs formed:0

distinct LDEs:
0=0
i1=i2
#########################################################################################
loop info: unsigned int i=0  i<v.size()  ++i
induction variable: ['i']
{
L87: (v[i],r) 
L88: (s[0]=,w) 
L89: (ss[i]=,w) 
}
array table
-----------------------------------------------
ss -> [('[i]', 'w', 'normalized', ['i'], 89)]
LDEs formed:1

s -> [('[0]', 'w', 'normalized', ['i'], 88)]
LDEs formed:1

v -> [('[i]', 'r', 'normalized', ['i'], 87)]
LDEs formed:0

distinct LDEs:
0=0
i1=i2
#########################################################################################
loop info: unsigned int i=0  i<v.size()  ++i
induction variable: ['i']
{
L88: (s[0]=,w) (v[i].c_str,r) 
L89: (ss[i]=,w) 
}
array table
-----------------------------------------------
ss -> [('[i]', 'w', 'normalized', ['i'], 89)]
LDEs formed:1

s -> [('[0]', 'w', 'normalized', ['i'], 88)]
LDEs formed:1

v -> [('[i]', 'r', 'normalized', ['i'], 88)]
LDEs formed:0

distinct LDEs:
0=0
i1=i2
#########################################################################################
loop info: unsigned int i=0  i<v.size()  ++i
induction variable: ['i']
{
L89: (s[0],r) (v[i],r) 
L90: (ss[i]=,w) 
}
array table
-----------------------------------------------
ss -> [('[i]', 'w', 'normalized', ['i'], 90)]
LDEs formed:1

s -> [('[0]', 'r', 'normalized', ['i'], 89)]
LDEs formed:0

v -> [('[i]', 'r', 'normalized', ['i'], 89)]
LDEs formed:0

distinct LDEs:
i1=i2
#########################################################################################
loop info: unsigned int i=0  i<vv.size()  ++i
induction variable: ['i']
{
L90: (vv[i],r) 
	loop info: unsigned int j=0  j<v.size()  ++j
	induction variable: ['i', 'j']
	{
	}
L91: (ss[i]=,w) 
}
array table
-----------------------------------------------
ss -> [('[i]', 'w', 'normalized', ['i', 'j'], 91)]
LDEs formed:1

vv -> [('[i]', 'r', 'normalized', ['i', 'j'], 90)]
LDEs formed:0

distinct LDEs:
i1=i2
#########################################################################################
loop info: unsigned int i=0  i<vv.size()  ++i
induction variable: ['i']
{
L91: (vv[i],r) 
	loop info: unsigned int j=0  j<v.size()  ++j
	induction variable: ['i', 'j']
	{
	}
L92: (ss[i]=,w) 
}
array table
-----------------------------------------------
ss -> [('[i]', 'w', 'normalized', ['i', 'j'], 92)]
LDEs formed:1

vv -> [('[i]', 'r', 'normalized', ['i', 'j'], 91)]
LDEs formed:0

distinct LDEs:
i1=i2
#########################################################################################
loop info: unsigned int i=0  i<vv.size()  ++i
induction variable: ['i']
{
L92: (vv[i],r) 
	loop info: unsigned int j=0  j<v.size()  ++j
	induction variable: ['i', 'j']
	{
	L93: (v[j],r) 
	L94: (s[j]=,w) 
	}
L95: (ss[i]=,w) 
}
array table
-----------------------------------------------
ss -> [('[i]', 'w', 'normalized', ['i', 'j'], 95)]
LDEs formed:1

s -> [('[j]', 'w', 'normalized', ['i', 'j'], 94)]
LDEs formed:1

vv -> [('[i]', 'r', 'normalized', ['i', 'j'], 92)]
LDEs formed:0

v -> [('[j]', 'r', 'normalized', ['i', 'j'], 93)]
LDEs formed:0

distinct LDEs:
j1=j2
i1=i2
#########################################################################################
loop info: unsigned int i=0  i<vv.size()  ++i
induction variable: ['i']
{
L94: (vv[i],r) 
	loop info: unsigned int j=0  j<v.size()  ++j
	induction variable: ['i', 'j']
	{
	}
L95: (ss[i]=,w) 
}
array table
-----------------------------------------------
ss -> [('[i]', 'w', 'normalized', ['i', 'j'], 95)]
LDEs formed:1

vv -> [('[i]', 'r', 'normalized', ['i', 'j'], 94)]
LDEs formed:0

distinct LDEs:
i1=i2
#########################################################################################
loop info: unsigned int i=0  i<vv.size()  ++i
induction variable: ['i']
{
L95: (vv[i],r) 
	loop info: unsigned int j=0  j<v.size()  ++j
	induction variable: ['i', 'j']
	{
	}
L96: (ss[i]=,w) 
}
array table
-----------------------------------------------
ss -> [('[i]', 'w', 'normalized', ['i', 'j'], 96)]
LDEs formed:1

vv -> [('[i]', 'r', 'normalized', ['i', 'j'], 95)]
LDEs formed:0

distinct LDEs:
i1=i2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLibAddin/Addins/Calc/qladdin.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info:  n1 = 0   n1 < nE1   n1++ 
induction variable: ['n1']
{
L96: (temp[ n1 ],r) 
	loop info:  n2 = 0   n2 < nE2   n2++ 
	induction variable: ['n1', 'n2']
	{
	}
L97: (temp[n1]=,w) 
}
array table
-----------------------------------------------
temp -> [('[ n1 ]', 'r', 'normalized', ['n1', 'n2'], 96), ('[n1]', 'w', 'normalized', ['n1', 'n2'], 97)]
LDEs formed:2

distinct LDEs:
n11=n12
 n11 =n12
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLibAddin/Addins/Calc/calcaddins.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info:  n1 = 0   n1 < nE1   n1++ 
induction variable: ['n1']
{
L98: (temp[ n1 ],r) 
	loop info:  n2 = 0   n2 < nE2   n2++ 
	induction variable: ['n1', 'n2']
	{
	}
L99: (temp[n1]=,w) 
}
array table
-----------------------------------------------
temp -> [('[ n1 ]', 'r', 'normalized', ['n1', 'n2'], 98), ('[n1]', 'w', 'normalized', ['n1', 'n2'], 99)]
LDEs formed:2

distinct LDEs:
n11=n12
 n11 =n12
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/Docs/Examples/history_iterators.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/inflationcapfloor.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<N  i++
induction variable: ['i']
{
L100: (iiData[i].date,r) 
L101: (iiData[i].rate/,r) 
}
array table
-----------------------------------------------
iiData -> [('[i]', 'r', 'normalized', ['i'], 100), ('[i]', 'r', 'normalized', ['i'], 101)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<rpiSchedule.size() i++
induction variable: ['i']
{
L102: (rpiSchedule[i],r) (fixData[i],r) 
}
array table
-----------------------------------------------
rpiSchedule -> [('[i]', 'r', 'normalized', ['i'], 102)]
LDEs formed:0

fixData -> [('[i]', 'r', 'normalized', ['i'], 102)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size whichPricer = 0  whichPricer < 3  whichPricer++
induction variable: ['whichPricer']
{
	loop info: Size i=0  i<LENGTH(lengths)  i++
	induction variable: ['whichPricer', 'i']
	{
		loop info: Size j=0  j<LENGTH(cap_rates)  j++
		induction variable: ['whichPricer', 'i', 'j']
		{
			loop info: Size k=0  k<LENGTH(floor_rates)  k++
			induction variable: ['whichPricer', 'i', 'j', 'k']
			{
				loop info: Size l=0  l<LENGTH(vols)  l++
				induction variable: ['whichPricer', 'i', 'j', 'k', 'l']
				{
				L103: (lengths[i],r) 
				L104: (cap_rates[j],r) (vols[l],r) 
				L105: (floor_rates[k],r) (vols[l],r) 
				L106: (cap_rates[j],r) 
				L107: (floor_rates[k],r) 
				L108: (vols[l],r) 
				L109: (lengths[i]<<,r) 
				L110: (vols[l],r) 
				L111: (cap_rates[j],r) 
				L112: (floor_rates[k],r) 
					loop info: Integer m=0  m<lengths[i]*1  m++
					induction variable: ['whichPricer', 'i', 'j', 'k', 'l', 'm']
						{
						L113: (caplets[m]-,r) (vols[l],r) 
						L114: (caplets[m]-,r) 
						}
				L115: (lengths[i]<<,r) 
				L116: (vols[l],r) 
				L117: (cap_rates[j],r) 
				L118: (caplets[0]-,r) 
					loop info: Integer m=0  m<lengths[i]*1  m++
					induction variable: ['whichPricer', 'i', 'j', 'k', 'l', 'm']
						{
						L119: (floorlets[m]-,r) (vols[l],r) 
						L120: (floorlets[m]-,r) 
						}
				L121: (lengths[i]<<,r) 
				L122: (vols[l],r) 
				L123: (floor_rates[j],r) 
				L124: (floorlets[0]-,r) 
					loop info: Integer m=0  m<lengths[i]*1  m++
					induction variable: ['whichPricer', 'i', 'j', 'k', 'l', 'm']
						{
						L125: (collarlets[m]-,r) (vols[l],r) 
						L126: (collarlets[m]-,r) 
						}
				L127: (lengths[i]<<,r) 
				L128: (vols[l],r) 
				L129: (floor_rates[j],r) 
				L130: (cap_rates[j],r) 
				L131: (collarlets[0]-,r) 
				L132: (collarlets[0]-,r) 
				}
 			}
 		}
 	}
 }
array table
-----------------------------------------------
lengths -> [('[i]', 'r', 'normalized', ['whichPricer', 'i', 'j', 'k', 'l', 'm'], 103), ('[i]', 'r', 'normalized', ['whichPricer', 'i', 'j', 'k', 'l', 'm'], 109), ('[i]', 'r', 'normalized', ['whichPricer', 'i', 'j', 'k', 'l', 'm'], 115), ('[i]', 'r', 'normalized', ['whichPricer', 'i', 'j', 'k', 'l', 'm'], 121), ('[i]', 'r', 'normalized', ['whichPricer', 'i', 'j', 'k', 'l', 'm'], 127)]
LDEs formed:0

floor_rates -> [('[k]', 'r', 'normalized', ['whichPricer', 'i', 'j', 'k', 'l', 'm'], 105), ('[k]', 'r', 'normalized', ['whichPricer', 'i', 'j', 'k', 'l', 'm'], 107), ('[k]', 'r', 'normalized', ['whichPricer', 'i', 'j', 'k', 'l', 'm'], 112), ('[j]', 'r', 'normalized', ['whichPricer', 'i', 'j', 'k', 'l', 'm'], 123), ('[j]', 'r', 'normalized', ['whichPricer', 'i', 'j', 'k', 'l', 'm'], 129)]
LDEs formed:0

cap_rates -> [('[j]', 'r', 'normalized', ['whichPricer', 'i', 'j', 'k', 'l', 'm'], 104), ('[j]', 'r', 'normalized', ['whichPricer', 'i', 'j', 'k', 'l', 'm'], 106), ('[j]', 'r', 'normalized', ['whichPricer', 'i', 'j', 'k', 'l', 'm'], 111), ('[j]', 'r', 'normalized', ['whichPricer', 'i', 'j', 'k', 'l', 'm'], 117), ('[j]', 'r', 'normalized', ['whichPricer', 'i', 'j', 'k', 'l', 'm'], 130)]
LDEs formed:0

floorlets -> [('[m]', 'r', 'normalized', ['whichPricer', 'i', 'j', 'k', 'l', 'm'], 119), ('[m]', 'r', 'normalized', ['whichPricer', 'i', 'j', 'k', 'l', 'm'], 120), ('[0]', 'r', 'normalized', ['whichPricer', 'i', 'j', 'k', 'l', 'm'], 124)]
LDEs formed:0

vols -> [('[l]', 'r', 'normalized', ['whichPricer', 'i', 'j', 'k', 'l', 'm'], 104), ('[l]', 'r', 'normalized', ['whichPricer', 'i', 'j', 'k', 'l', 'm'], 105), ('[l]', 'r', 'normalized', ['whichPricer', 'i', 'j', 'k', 'l', 'm'], 108), ('[l]', 'r', 'normalized', ['whichPricer', 'i', 'j', 'k', 'l', 'm'], 110), ('[l]', 'r', 'normalized', ['whichPricer', 'i', 'j', 'k', 'l', 'm'], 113), ('[l]', 'r', 'normalized', ['whichPricer', 'i', 'j', 'k', 'l', 'm'], 116), ('[l]', 'r', 'normalized', ['whichPricer', 'i', 'j', 'k', 'l', 'm'], 119), ('[l]', 'r', 'normalized', ['whichPricer', 'i', 'j', 'k', 'l', 'm'], 122), ('[l]', 'r', 'normalized', ['whichPricer', 'i', 'j', 'k', 'l', 'm'], 125), ('[l]', 'r', 'normalized', ['whichPricer', 'i', 'j', 'k', 'l', 'm'], 128)]
LDEs formed:0

caplets -> [('[m]', 'r', 'normalized', ['whichPricer', 'i', 'j', 'k', 'l', 'm'], 113), ('[m]', 'r', 'normalized', ['whichPricer', 'i', 'j', 'k', 'l', 'm'], 114), ('[0]', 'r', 'normalized', ['whichPricer', 'i', 'j', 'k', 'l', 'm'], 118)]
LDEs formed:0

collarlets -> [('[m]', 'r', 'normalized', ['whichPricer', 'i', 'j', 'k', 'l', 'm'], 125), ('[m]', 'r', 'normalized', ['whichPricer', 'i', 'j', 'k', 'l', 'm'], 126), ('[0]', 'r', 'normalized', ['whichPricer', 'i', 'j', 'k', 'l', 'm'], 131), ('[0]', 'r', 'normalized', ['whichPricer', 'i', 'j', 'k', 'l', 'm'], 132)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size whichPricer = 0  whichPricer < 3  whichPricer++
induction variable: ['whichPricer']
{
	loop info: Size i=0  i<LENGTH(lengths)  i++
	induction variable: ['whichPricer', 'i']
	{
		loop info: Size j=0  j<LENGTH(strikes)  j++
		induction variable: ['whichPricer', 'i', 'j']
		{
			loop info: Size k=0  k<LENGTH(vols)  k++
			induction variable: ['whichPricer', 'i', 'j', 'k']
			{
			L133: (lengths[i],r) 
			L134: (strikes[j],r) (vols[k],r) 
			L135: (strikes[j],r) (vols[k],r) 
			L136: (lengths[i]*,r) 
			L137: (strikes[j],r) 
			L138: (lengths[i]<<,r) 
			L139: (vols[k],r) 
			L140: (strikes[j],r) 
			}
 		}
 	}
 }
array table
-----------------------------------------------
lengths -> [('[i]', 'r', 'normalized', ['whichPricer', 'i', 'j', 'k'], 133), ('[i]', 'r', 'normalized', ['whichPricer', 'i', 'j', 'k'], 136), ('[i]', 'r', 'normalized', ['whichPricer', 'i', 'j', 'k'], 138)]
LDEs formed:0

vols -> [('[k]', 'r', 'normalized', ['whichPricer', 'i', 'j', 'k'], 134), ('[k]', 'r', 'normalized', ['whichPricer', 'i', 'j', 'k'], 135), ('[k]', 'r', 'normalized', ['whichPricer', 'i', 'j', 'k'], 139)]
LDEs formed:0

strikes -> [('[j]', 'r', 'normalized', ['whichPricer', 'i', 'j', 'k'], 134), ('[j]', 'r', 'normalized', ['whichPricer', 'i', 'j', 'k'], 135), ('[j]', 'r', 'normalized', ['whichPricer', 'i', 'j', 'k'], 137), ('[j]', 'r', 'normalized', ['whichPricer', 'i', 'j', 'k'], 140)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/marketmodel_smmcapletcalibration.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<todaysForwards_.size()  ++i
induction variable: ['i']
{
L141: (todaysForwards_[i]=,w) 
L142: (todaysForwards_[i]=,w) 
}
array table
-----------------------------------------------
todaysForwards_ -> [('[i]', 'w', 'normalized', ['i'], 141), ('[i]', 'w', 'normalized', ['i'], 142)]
LDEs formed:3

distinct LDEs:
i1=i2
#########################################################################################
loop info: Size i=0  i<todaysSwaps_.size()  i++
induction variable: ['i']
{
L143: (swaptionDisplacedVols[i]=,w) (todaysSwaps[i]*,r) (mktSwaptionVols[i]/,r) 
L144: (todaysSwaps[i]+,r) 
L145: (swaptionVols[i]=,w) (mktSwaptionVols[i],r) 
L146: (capletDisplacedVols[i]=,w) (todaysForwards[i]*,r) (mktCapletVols[i]/,r) 
L147: (todaysForwards[i]+,r) 
L148: (capletVols_[i]=,w) (mktCapletVols[i],r) 
}
array table
-----------------------------------------------
todaysForwards -> [('[i]', 'r', 'normalized', ['i'], 146), ('[i]', 'r', 'normalized', ['i'], 147)]
LDEs formed:0

todaysSwaps -> [('[i]', 'r', 'normalized', ['i'], 143), ('[i]', 'r', 'normalized', ['i'], 144)]
LDEs formed:0

capletDisplacedVols -> [('[i]', 'w', 'normalized', ['i'], 146)]
LDEs formed:1

swaptionDisplacedVols -> [('[i]', 'w', 'normalized', ['i'], 143)]
LDEs formed:1

swaptionVols -> [('[i]', 'w', 'normalized', ['i'], 145)]
LDEs formed:1

capletVols_ -> [('[i]', 'w', 'normalized', ['i'], 148)]
LDEs formed:1

mktCapletVols -> [('[i]', 'r', 'normalized', ['i'], 146), ('[i]', 'r', 'normalized', ['i'], 148)]
LDEs formed:0

mktSwaptionVols -> [('[i]', 'r', 'normalized', ['i'], 143), ('[i]', 'r', 'normalized', ['i'], 145)]
LDEs formed:0

distinct LDEs:
i1=i2
#########################################################################################
loop info: Size i=0  i<numberOfRates  ++i
induction variable: ['i']
{
L146: (swapVariances[i]=,w) 
}
array table
-----------------------------------------------
swapVariances -> [('[i]', 'w', 'normalized', ['i'], 146)]
LDEs formed:1

distinct LDEs:
i1=i2
#########################################################################################
loop info: Size i=0  i<numberOfRates  ++i
induction variable: ['i']
{
L147: (capletVols[i]=,w) (capletTotCovariance[i][i]/,r) (rateTimes_[i],r) 
}
array table
-----------------------------------------------
capletVols -> [('[i]', 'w', 'normalized', ['i'], 147)]
LDEs formed:1

capletTotCovariance -> [('[i][i]', 'r', 'normalized', ['i'], 147)]
LDEs formed:0

rateTimes_ -> [('[i]', 'r', 'normalized', ['i'], 147)]
LDEs formed:0

distinct LDEs:
i1=i2
#########################################################################################
loop info: Size i=0  i<numberOfRates  ++i
induction variable: ['i']
{
L148: (swapVariances[i]-,r) 
L149: (swapPseudoRoots[i]*,r) (swapPseudoRoots[i],r) 
L150: (swapTerminalCovariance[i][i]/,r) (rateTimes_[i],r) 
}
array table
-----------------------------------------------
swapTerminalCovariance -> [('[i][i]', 'r', 'normalized', ['i'], 150)]
LDEs formed:0

swapPseudoRoots -> [('[i]', 'r', 'normalized', ['i'], 149), ('[i]', 'r', 'normalized', ['i'], 149)]
LDEs formed:0

swapVariances -> [('[i]', 'r', 'normalized', ['i'], 148)]
LDEs formed:0

rateTimes_ -> [('[i]', 'r', 'normalized', ['i'], 150)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<numberOfRates  ++i
induction variable: ['i']
{
L151: (capletVols[i]-,r) (capletVols_[i],r) 
L152: (capletVols_[i],r) 
L153: (capletVols[i],r) 
L154: (capletVols_[i]<<,r) 
}
array table
-----------------------------------------------
capletVols -> [('[i]', 'r', 'normalized', ['i'], 151), ('[i]', 'r', 'normalized', ['i'], 153)]
LDEs formed:0

capletVols_ -> [('[i]', 'r', 'normalized', ['i'], 151), ('[i]', 'r', 'normalized', ['i'], 152), ('[i]', 'r', 'normalized', ['i'], 154)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/inflationcapflooredcoupon.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<N  i++
induction variable: ['i']
{
L155: (iiData[i].date,r) 
L156: (iiData[i].rate/,r) 
}
array table
-----------------------------------------------
iiData -> [('[i]', 'r', 'normalized', ['i'], 155), ('[i]', 'r', 'normalized', ['i'], 156)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<rpiSchedule.size() i++
induction variable: ['i']
{
L157: (rpiSchedule[i],r) (fixData[i],r) 
}
array table
-----------------------------------------------
rpiSchedule -> [('[i]', 'r', 'normalized', ['i'], 157)]
LDEs formed:0

fixData -> [('[i]', 'r', 'normalized', ['i'], 157)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<yoyLeg.size()  i++
induction variable: ['i']
{
L158: (yoyLeg[i],r) 
}
array table
-----------------------------------------------
yoyLeg -> [('[i]', 'r', 'normalized', ['i'], 158)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size whichPricer = 0  whichPricer < 3  whichPricer++
induction variable: ['whichPricer']
{
	loop info: Size i=0  i<LENGTH(lengths)  i++
	induction variable: ['whichPricer', 'i']
	{
		loop info: Size j=0  j<LENGTH(strikes)  j++
		induction variable: ['whichPricer', 'i', 'j']
		{
			loop info: Size k=0  k<LENGTH(vols)  k++
			induction variable: ['whichPricer', 'i', 'j', 'k']
			{
			L159: (lengths[i],r) 
			L160: (strikes[j],r) (vols[k],r) 
			L161: (strikes[j],r) (vols[k],r) 
			L162: (lengths[i]*,r) 
			L163: (strikes[j],r) 
			L164: (lengths[i],r) 
			L165: (lengths[i],r) (strikes[j],r) 
			L166: (vols[k],r) 
			L167: (lengths[i],r) 
			L168: (lengths[i],r) (strikes[j],r) 
			L169: (vols[k],r) 
			L170: (lengths[i]<<,r) 
			L171: (vols[k],r) 
			L172: (strikes[j],r) 
			L173: (lengths[i]<<,r) 
			L174: (vols[k],r) 
			L175: (strikes[j],r) 
			}
 		}
 	}
 }
array table
-----------------------------------------------
lengths -> [('[i]', 'r', 'normalized', ['whichPricer', 'i', 'j', 'k'], 159), ('[i]', 'r', 'normalized', ['whichPricer', 'i', 'j', 'k'], 162), ('[i]', 'r', 'normalized', ['whichPricer', 'i', 'j', 'k'], 164), ('[i]', 'r', 'normalized', ['whichPricer', 'i', 'j', 'k'], 165), ('[i]', 'r', 'normalized', ['whichPricer', 'i', 'j', 'k'], 167), ('[i]', 'r', 'normalized', ['whichPricer', 'i', 'j', 'k'], 168), ('[i]', 'r', 'normalized', ['whichPricer', 'i', 'j', 'k'], 170), ('[i]', 'r', 'normalized', ['whichPricer', 'i', 'j', 'k'], 173)]
LDEs formed:0

vols -> [('[k]', 'r', 'normalized', ['whichPricer', 'i', 'j', 'k'], 160), ('[k]', 'r', 'normalized', ['whichPricer', 'i', 'j', 'k'], 161), ('[k]', 'r', 'normalized', ['whichPricer', 'i', 'j', 'k'], 166), ('[k]', 'r', 'normalized', ['whichPricer', 'i', 'j', 'k'], 169), ('[k]', 'r', 'normalized', ['whichPricer', 'i', 'j', 'k'], 171), ('[k]', 'r', 'normalized', ['whichPricer', 'i', 'j', 'k'], 174)]
LDEs formed:0

strikes -> [('[j]', 'r', 'normalized', ['whichPricer', 'i', 'j', 'k'], 160), ('[j]', 'r', 'normalized', ['whichPricer', 'i', 'j', 'k'], 161), ('[j]', 'r', 'normalized', ['whichPricer', 'i', 'j', 'k'], 163), ('[j]', 'r', 'normalized', ['whichPricer', 'i', 'j', 'k'], 165), ('[j]', 'r', 'normalized', ['whichPricer', 'i', 'j', 'k'], 168), ('[j]', 'r', 'normalized', ['whichPricer', 'i', 'j', 'k'], 172), ('[j]', 'r', 'normalized', ['whichPricer', 'i', 'j', 'k'], 175)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/libormarketmodel.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i < 9  ++i
induction variable: ['i']
{
L176: (vols[i]/,r) 
}
array table
-----------------------------------------------
vols -> [('[i]', 'r', 'normalized', ['i'], 176)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: i=0  i<size  ++i
induction variable: ['i']
{
	loop info: Size j=0  j<size  ++j
	induction variable: ['i', 'j']
	{
	L177: (recon[i][j],r) 
	L178: (recon[i][j],r) 
	}
 }
array table
-----------------------------------------------
recon -> [('[i][j]', 'r', 'normalized', ['i', 'j'], 177), ('[i][j]', 'r', 'normalized', ['i', 'j'], 178)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: i=0  i<size  ++i
induction variable: ['i']
{
L179: (fixingTimes[i]=,w) 
}
array table
-----------------------------------------------
fixingTimes -> [('[i]', 'w', 'normalized', ['i'], 179)]
LDEs formed:1

distinct LDEs:
i1=i2
#########################################################################################
loop info: Real t=0  t<4.6  t+=0.31
induction variable: ['t']
{
	loop info: Size i=0  i<size  ++i
	induction variable: ['t', 'i']
	{
		loop info: Size j=0  j<size  ++j
		induction variable: ['t', 'i', 'j']
		{
		L180: (recon[i][j],r) 
		L181: (recon[i][j],r) 
		}
 	}
	loop info: Size k=0  k<size  ++k
	induction variable: ['t', 'i', 'j', 'k']
	{
	L182: (fixingTimes[k],r) 
	L183: (volatility[k],r) 
	L184: (volatility[k],r) 
	}
 }
array table
-----------------------------------------------
recon -> [('[i][j]', 'r', 'normalized', ['t', 'i', 'j', 'k'], 180), ('[i][j]', 'r', 'normalized', ['t', 'i', 'j', 'k'], 181)]
LDEs formed:0

fixingTimes -> [('[k]', 'r', 'normalized', ['t', 'i', 'j', 'k'], 182)]
LDEs formed:0

volatility -> [('[k]', 'r', 'normalized', ['t', 'i', 'j', 'k'], 183), ('[k]', 'r', 'normalized', ['t', 'i', 'j', 'k'], 184)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: i=2  i < size  ++i
induction variable: ['i']
{
L185: (capVols[i-2],r) 
	loop info: Size j=1  j <= size/2  ++j
	induction variable: ['i', 'j']
		{
		L186: (swaptionVols[swapVolIndex++],r) 
		}
 }
array table
-----------------------------------------------
capVols -> [('[i-2]', 'r', 'normalized', ['i', 'j'], 185)]
LDEs formed:0

swaptionVols -> [('[swapVolIndex++]', 'r', 'not normalized', ['i', 'j'], 186)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: i=0  i<calibrationHelper.size()  ++i
induction variable: ['i']
{
L187: (calibrationHelper[i]-,r) 
}
array table
-----------------------------------------------
calibrationHelper -> [('[i]', 'r', 'normalized', ['i'], 187)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: i=0  i < tmp.size()  ++i
induction variable: ['i']
{
L188: (tmp[i],r) 
}
array table
-----------------------------------------------
tmp -> [('[i]', 'r', 'normalized', ['i'], 188)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: i=1  i < size  ++i
induction variable: ['i']
{
	loop info: Size j=1  j <= size-i  ++j
	induction variable: ['i', 'j']
	{
		loop info: Size n=0  n<nrTrails  ++n
		induction variable: ['i', 'j', 'n']
			{
				loop info: Size k=0  k<process->size()  ++k
				induction variable: ['i', 'j', 'n', 'k']
				{
				L189: (rates[k]=,w) (path.value[k],r) (location[i],r) 
				}
				loop info: Size m=i  m < i+j  ++m
				induction variable: ['i', 'j', 'n', 'k', 'm']
				{
				L190: (rates[m],r) 
				L191: (dis[m],r) 
				}
 			}
 	}
 }
array table
-----------------------------------------------
path.value -> [('[k]', 'r', 'normalized', ['i', 'j', 'n', 'k', 'm'], 189)]
LDEs formed:0

rates -> [('[k]', 'w', 'normalized', ['i', 'j', 'n', 'k', 'm'], 189), ('[m]', 'r', 'normalized', ['i', 'j', 'n', 'k', 'm'], 190)]
LDEs formed:2

location -> [('[i]', 'r', 'normalized', ['i', 'j', 'n', 'k', 'm'], 189)]
LDEs formed:0

dis -> [('[m]', 'r', 'normalized', ['i', 'j', 'n', 'k', 'm'], 191)]
LDEs formed:0

distinct LDEs:
k1=m2
k1=k2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/vpp.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size n=0  n < nrTrails  ++n
induction variable: ['n']
{
	loop info: Size i=1  i <= steps  ++i
	induction variable: ['n', 'i']
	{
	L192: (path.value[1][i],r) 
	L193: (path.value[0][i],r) 
	}
 }
array table
-----------------------------------------------
path.value -> [('[1][i]', 'r', 'normalized', ['n', 'i'], 192), ('[0][i]', 'r', 'normalized', ['n', 'i'], 193)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i < nTrails  ++i
induction variable: ['i']
{
L194: (p[0]=,w) (path.value[0].back,r) (path.value[1].back,r) 
L195: (p[1]=,w) (path.value[2].back,r) 
}
array table
-----------------------------------------------
p -> [('[0]', 'w', 'normalized', ['i'], 194), ('[1]', 'w', 'normalized', ['i'], 195)]
LDEs formed:3

path.value -> [('[0]', 'r', 'normalized', ['i'], 194), ('[1]', 'r', 'normalized', ['i'], 194), ('[2]', 'r', 'normalized', ['i'], 195)]
LDEs formed:0

distinct LDEs:
1=1
0=0
0=1
#########################################################################################
loop info: Size i=0  i < LENGTH(efficiency)  ++i
induction variable: ['i']
{
L196: (efficiency[i],r) 
L197: (expected[i]-,r) 
L198: (expected[i],r) 
}
array table
-----------------------------------------------
expected -> [('[i]', 'r', 'normalized', ['i'], 197), ('[i]', 'r', 'normalized', ['i'], 198)]
LDEs formed:0

efficiency -> [('[i]', 'r', 'normalized', ['i'], 196)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i < nHours  ++i
induction variable: ['i']
{
L197: (fuelPrices[i],r) 
L198: (powerPrices[i],r) 
}
array table
-----------------------------------------------
fuelPrices -> [('[i]', 'r', 'normalized', ['i'], 197)]
LDEs formed:0

powerPrices -> [('[i]', 'r', 'normalized', ['i'], 198)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=exercise->dates().size()  i > 0u  --i
induction variable: ['i']
{
	loop info: Size j=0  j < nCalibrationTrails  ++j
	induction variable: ['i', 'j']
	{
	L199: (x[j][0]=,w) (sparkSpreads[j]-,r) 
	}
	loop info: Size k=0  k < nStates  ++k
	induction variable: ['i', 'j', 'k']
	{
		loop info: Size j=0  j < nCalibrationTrails  ++j
		induction variable: ['i', 'j', 'k']
		{
		L200: (y[j]=,w) (prices[j][k],r) 
		}
	L201: (coeff[k][i-1]=,w) 
		loop info: Size j=0  j < nCalibrationTrails  ++j
		induction variable: ['i', 'j', 'k']
		{
		L202: (prices[j][k]=,w) 
			loop info: Size l=0  l < v.size()  ++l
			induction variable: ['i', 'j', 'k', 'l']
			{
			L203: (prices[j][k]+=,w) (coeff[k][i-1][l]*,r) (v[l],r) (x[j],r) 
			}
 		}
 	}
	loop info: Size j=0  j < nCalibrationTrails  ++j
	induction variable: ['i', 'j', 'k', 'l']
	{
	L204: (stepConditions[j]-,r) (prices[j],r) 
	}
 }
array table
-----------------------------------------------
sparkSpreads -> [('[j]', 'r', 'normalized', ['i', 'j', 'k', 'l'], 199)]
LDEs formed:0

coeff -> [('[k][i-1]', 'w', 'normalized', ['i', 'j', 'k', 'l'], 201), ('[k][i-1][l]', 'r', 'normalized', ['i', 'j', 'k', 'l'], 203)]
LDEs formed:6

prices -> [('[j][k]', 'r', 'normalized', ['i', 'j', 'k', 'l'], 200), ('[j][k]', 'w', 'normalized', ['i', 'j', 'k', 'l'], 202), ('[j][k]', 'w', 'normalized', ['i', 'j', 'k', 'l'], 203), ('[j]', 'r', 'normalized', ['i', 'j', 'k', 'l'], 204)]
LDEs formed:7

v -> [('[l]', 'r', 'normalized', ['i', 'j', 'k', 'l'], 203)]
LDEs formed:0

y -> [('[j]', 'w', 'normalized', ['i', 'j', 'k', 'l'], 200)]
LDEs formed:1

x -> [('[j][0]', 'w', 'normalized', ['i', 'j', 'k', 'l'], 199), ('[j]', 'r', 'normalized', ['i', 'j', 'k', 'l'], 203)]
LDEs formed:2

stepConditions -> [('[j]', 'r', 'normalized', ['i', 'j', 'k', 'l'], 204)]
LDEs formed:0

distinct LDEs:
j1=j2
k1=k2,i1-1=i2-1
j1=j2,k1=k2
j1=j2,0=0
#########################################################################################
loop info: Size i=0  i < nTrails  ++i
induction variable: ['i']
{
	loop info: Size j=exercise->dates().size()  j > 0u  --j
	induction variable: ['i', 'j']
	{
	L205: (x[0]=,w) 
		loop info: Size k=0  k < nStates  ++k
		induction variable: ['i', 'j', 'k']
		{
		L206: (contState[k]=,w) 
			loop info: Size l=0  l < v.size()  ++l
			induction variable: ['i', 'j', 'k', 'l']
			{
			L207: (contState[k]+=,w) (coeff[k][j-1][l]*,r) (v[l],r) 
			}
 		}
		loop info: Size i=0  i < 2*tMinUp  ++i
		induction variable: ['i', 'j', 'k', 'l']
		{
		L208: (state[i]+=,w) 
		L209: (contState[i]+=,w) 
		L210: (state[i]+=,w) 
		L211: (contState[i]+=,w) 
		}
		loop info: Size i=0  i < tMinUp-1  ++i
		induction variable: ['i', 'j', 'k', 'l']
		{
		L212: (retVal[i]=,w) (retVal[tMinUp + i],r) 
		L213: (contState[i+1],r) (contState[tMinUp + i+1],r) 
		L214: (state[i+1],r) (state[tMinUp + i+1],r) 
		}
	L215: (contState[2*tMinUp],r) 
	L216: (contState[tMinUp-1],r) (contState[2*tMinUp-1],r) 
	L217: (retVal[tMinUp-1]=,w) (retVal[2*tMinUp-1]=,w) (state[2*tMinUp],r) 
	L218: (contState[tMinUp-1],r) (contState[2*tMinUp-1],r) 
	L219: (retVal[tMinUp-1]=,w) (retVal[2*tMinUp-1]=,w) (state[tMinUp-1],r) 
	L220: (retVal[tMinUp-1]=,w) (retVal[2*tMinUp-1]=,w) (state[2*tMinUp-1],r) 
		loop info: Size i=0  i < tMinDown-1  ++i
		induction variable: ['i', 'j', 'k', 'l']
		{
		L221: (retVal[2*tMinUp + i]=,w) (state[2*tMinUp + i+1],r) 
		}
	L222: (contState[tMinUp],r) 
	L223: (contState[tMinUp],r) 
	L224: (state[tMinUp]-,r) 
	}
 }
array table
-----------------------------------------------
coeff -> [('[k][j-1][l]', 'r', 'normalized', ['i', 'j', 'k', 'l'], 207)]
LDEs formed:0

state -> [('[i]', 'w', 'normalized', ['i', 'j', 'k', 'l'], 208), ('[i]', 'w', 'normalized', ['i', 'j', 'k', 'l'], 210), ('[i+1]', 'r', 'normalized', ['i', 'j', 'k', 'l'], 214), ('[tMinUp + i+1]', 'r', 'not normalized', ['i', 'j', 'k', 'l'], 214), ('[2*tMinUp]', 'r', 'not normalized', ['i', 'j', 'k', 'l'], 217), ('[tMinUp-1]', 'r', 'not normalized', ['i', 'j', 'k', 'l'], 219), ('[2*tMinUp-1]', 'r', 'not normalized', ['i', 'j', 'k', 'l'], 220), ('[2*tMinUp + i+1]', 'r', 'not normalized', ['i', 'j', 'k', 'l'], 221), ('[tMinUp]', 'r', 'not normalized', ['i', 'j', 'k', 'l'], 224)]
LDEs formed:17

v -> [('[l]', 'r', 'normalized', ['i', 'j', 'k', 'l'], 207)]
LDEs formed:0

x -> [('[0]', 'w', 'normalized', ['i', 'j', 'k', 'l'], 205)]
LDEs formed:1

retVal -> [('[i]', 'w', 'normalized', ['i', 'j', 'k', 'l'], 212), ('[tMinUp + i]', 'r', 'not normalized', ['i', 'j', 'k', 'l'], 212), ('[tMinUp-1]', 'w', 'not normalized', ['i', 'j', 'k', 'l'], 217), ('[2*tMinUp-1]', 'w', 'not normalized', ['i', 'j', 'k', 'l'], 217), ('[tMinUp-1]', 'w', 'not normalized', ['i', 'j', 'k', 'l'], 219), ('[2*tMinUp-1]', 'w', 'not normalized', ['i', 'j', 'k', 'l'], 219), ('[tMinUp-1]', 'w', 'not normalized', ['i', 'j', 'k', 'l'], 220), ('[2*tMinUp-1]', 'w', 'not normalized', ['i', 'j', 'k', 'l'], 220), ('[2*tMinUp + i]', 'w', 'not normalized', ['i', 'j', 'k', 'l'], 221)]
LDEs formed:44

contState -> [('[k]', 'w', 'normalized', ['i', 'j', 'k', 'l'], 206), ('[k]', 'w', 'normalized', ['i', 'j', 'k', 'l'], 207), ('[i]', 'w', 'normalized', ['i', 'j', 'k', 'l'], 209), ('[i]', 'w', 'normalized', ['i', 'j', 'k', 'l'], 211), ('[i+1]', 'r', 'normalized', ['i', 'j', 'k', 'l'], 213), ('[tMinUp + i+1]', 'r', 'not normalized', ['i', 'j', 'k', 'l'], 213), ('[2*tMinUp]', 'r', 'not normalized', ['i', 'j', 'k', 'l'], 215), ('[tMinUp-1]', 'r', 'not normalized', ['i', 'j', 'k', 'l'], 216), ('[2*tMinUp-1]', 'r', 'not normalized', ['i', 'j', 'k', 'l'], 216), ('[tMinUp-1]', 'r', 'not normalized', ['i', 'j', 'k', 'l'], 218), ('[2*tMinUp-1]', 'r', 'not normalized', ['i', 'j', 'k', 'l'], 218), ('[tMinUp]', 'r', 'not normalized', ['i', 'j', 'k', 'l'], 222), ('[tMinUp]', 'r', 'not normalized', ['i', 'j', 'k', 'l'], 223)]
LDEs formed:46

distinct LDEs:
tMinUp-1=2*tMinUp-1
i1=2*tMinUp
k1=2*tMinUp
tMinUp + i1=tMinUp-1
i1=2*tMinUp-1
i1=2*tMinUp + i2+1
i1=tMinUp-1
k1=k2
i1=tMinUp
2*tMinUp-1=2*tMinUp-1
i1=i2
tMinUp-1=2*tMinUp + i2
k1=tMinUp-1
k1=i2
k1=tMinUp + i2+1
i1=tMinUp + i2+1
i1=i2+1
tMinUp + i1=2*tMinUp-1
k1=tMinUp
tMinUp + i1=2*tMinUp + i2
2*tMinUp-1=2*tMinUp + i2
k1=2*tMinUp-1
tMinUp-1=tMinUp-1
i1=2*tMinUp + i2
i1=tMinUp + i2
0=0
2*tMinUp + i1=2*tMinUp + i2
k1=i2+1
#########################################################################################
loop info: Size i=0  i < x.size()  ++i
induction variable: ['i']
{
L224: (x[i]=,w) 
}
array table
-----------------------------------------------
x -> [('[i]', 'w', 'normalized', ['i'], 224)]
LDEs formed:1

distinct LDEs:
i1=i2
#########################################################################################
loop info: Size i=0  i < x.size()  ++i
induction variable: ['i']
{
L225: (applyExpected[i]-,r) (applyCalculated[i],r) 
L226: (applyExpected[i],r) 
L227: (applyExpected[i]<<,r) 
L228: (applyCalculated[i]<<,r) 
L229: (applyExpectedMixed[i]-,r) (applyCalculatedMixed[i],r) 
L230: (applyExpected[i],r) 
L231: (applyExpectedMixed[i]<<,r) 
L232: (applyCalculatedMixed[i]<<,r) 
}
array table
-----------------------------------------------
applyExpected -> [('[i]', 'r', 'normalized', ['i'], 225), ('[i]', 'r', 'normalized', ['i'], 226), ('[i]', 'r', 'normalized', ['i'], 227), ('[i]', 'r', 'normalized', ['i'], 230)]
LDEs formed:0

applyCalculated -> [('[i]', 'r', 'normalized', ['i'], 225), ('[i]', 'r', 'normalized', ['i'], 228)]
LDEs formed:0

applyExpectedMixed -> [('[i]', 'r', 'normalized', ['i'], 229), ('[i]', 'r', 'normalized', ['i'], 231)]
LDEs formed:0

applyCalculatedMixed -> [('[i]', 'r', 'normalized', ['i'], 229), ('[i]', 'r', 'normalized', ['i'], 232)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i < 3  ++i
induction variable: ['i']
{
L233: (matrixDecomp[i],r) 
	loop info: Size j=0  j < x.size()  ++j
	induction variable: ['i', 'j']
	{
	L234: (applyExpectedDir[j]-,r) (applyCalculatedDir[j],r) 
	L235: (applyExpectedDir[j]*,r) 
	L236: (applyExpectedDir[i]<<,r) 
	L237: (applyCalculatedDir[i]<<,r) 
	}
 }
array table
-----------------------------------------------
applyExpectedDir -> [('[j]', 'r', 'normalized', ['i', 'j'], 234), ('[j]', 'r', 'normalized', ['i', 'j'], 235), ('[i]', 'r', 'normalized', ['i', 'j'], 236)]
LDEs formed:0

matrixDecomp -> [('[i]', 'r', 'normalized', ['i', 'j'], 233)]
LDEs formed:0

applyCalculatedDir -> [('[j]', 'r', 'normalized', ['i', 'j'], 234), ('[i]', 'r', 'normalized', ['i', 'j'], 237)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/linearleastsquaresregression.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size k=0  k<3  ++k
induction variable: ['k']
{
	loop info: i=0  i<nr  ++i
	induction variable: ['k', 'i']
	{
	L238: (x[i]=,w) 
	L239: (y[i]=,w) (a[0]*,r) (v[0],r) (x[i],r) (a[1]*,r) (v[1],r) (x[i],r) (a[2]*,r) (v[2],r) (x[i],r) 
	L240: (a[3]*,r) (v[3],r) (x[i],r) 
	}
	loop info: i=0  i<v.size()  ++i
	induction variable: ['k', 'i']
	{
	L241: (a[i],r) 
	L242: (a[i],r) 
	}
	loop info: i=0  i<v.size()  ++i
	induction variable: ['k', 'i']
	{
	L243: (ma[i]-,r) (a[i],r) (err[i],r) 
	L244: (ma[i],r) 
	L245: (err[i],r) 
	L246: (a[i],r) 
	}
 }
array table
-----------------------------------------------
a -> [('[0]', 'r', 'normalized', ['k', 'i'], 239), ('[1]', 'r', 'normalized', ['k', 'i'], 239), ('[2]', 'r', 'normalized', ['k', 'i'], 239), ('[3]', 'r', 'normalized', ['k', 'i'], 240), ('[i]', 'r', 'normalized', ['k', 'i'], 241), ('[i]', 'r', 'normalized', ['k', 'i'], 242), ('[i]', 'r', 'normalized', ['k', 'i'], 243), ('[i]', 'r', 'normalized', ['k', 'i'], 246)]
LDEs formed:0

ma -> [('[i]', 'r', 'normalized', ['k', 'i'], 243), ('[i]', 'r', 'normalized', ['k', 'i'], 244)]
LDEs formed:0

err -> [('[i]', 'r', 'normalized', ['k', 'i'], 243), ('[i]', 'r', 'normalized', ['k', 'i'], 245)]
LDEs formed:0

v -> [('[0]', 'r', 'normalized', ['k', 'i'], 239), ('[1]', 'r', 'normalized', ['k', 'i'], 239), ('[2]', 'r', 'normalized', ['k', 'i'], 239), ('[3]', 'r', 'normalized', ['k', 'i'], 240)]
LDEs formed:0

y -> [('[i]', 'w', 'normalized', ['k', 'i'], 239)]
LDEs formed:1

x -> [('[i]', 'w', 'normalized', ['k', 'i'], 238), ('[i]', 'r', 'normalized', ['k', 'i'], 239), ('[i]', 'r', 'normalized', ['k', 'i'], 239), ('[i]', 'r', 'normalized', ['k', 'i'], 239), ('[i]', 'r', 'normalized', ['k', 'i'], 240)]
LDEs formed:5

distinct LDEs:
i1=i2
#########################################################################################
loop info: Size i=0  i < v.size()  ++i
induction variable: ['i']
{
L241: (coeff[i]=,w) 
}
array table
-----------------------------------------------
coeff -> [('[i]', 'w', 'normalized', ['i'], 241)]
LDEs formed:1

distinct LDEs:
i1=i2
#########################################################################################
loop info: Size i=0  i < nr  ++i
induction variable: ['i']
{
	loop info: Size j=0  j < dims  ++j
	induction variable: ['i', 'j']
	{
	L242: (x[i][j]=,w) 
	}
	loop info: Size j=0  j < v.size()  ++j
	induction variable: ['i', 'j']
	{
	L243: (y[i]+=,w) (coeff[j]*,r) (v[j],r) (x[i],r) 
	}
L244: (y[i]+=,w) 
}
array table
-----------------------------------------------
y -> [('[i]', 'w', 'normalized', ['i', 'j'], 243), ('[i]', 'w', 'normalized', ['i', 'j'], 244)]
LDEs formed:3

x -> [('[i][j]', 'w', 'normalized', ['i', 'j'], 242), ('[i]', 'r', 'normalized', ['i', 'j'], 243)]
LDEs formed:2

coeff -> [('[j]', 'r', 'normalized', ['i', 'j'], 243)]
LDEs formed:0

v -> [('[j]', 'r', 'normalized', ['i', 'j'], 243)]
LDEs formed:0

distinct LDEs:
i1=i2,j1=j2
i1=i2
#########################################################################################
loop info: Size i=0  i < v.size()  ++i
induction variable: ['i']
{
L244: (coeff[i],r) 
L245: (coeff[i],r) 
}
array table
-----------------------------------------------
coeff -> [('[i]', 'r', 'normalized', ['i'], 244), ('[i]', 'r', 'normalized', ['i'], 245)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i < m1.dim()  ++i
induction variable: ['i']
{
L246: (coeff[i],r) 
L247: (coeff[i],r) 
}
array table
-----------------------------------------------
coeff -> [('[i]', 'r', 'normalized', ['i'], 246), ('[i]', 'r', 'normalized', ['i'], 247)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i < 2  ++i
induction variable: ['i']
{
L248: (errorsExpected[i],r) 
L249: (errorsExpected[i],r) 
L250: (coeffExpected[i],r) 
L251: (coeffExpected[i],r) 
}
array table
-----------------------------------------------
errorsExpected -> [('[i]', 'r', 'normalized', ['i'], 248), ('[i]', 'r', 'normalized', ['i'], 249)]
LDEs formed:0

coeffExpected -> [('[i]', 'r', 'normalized', ['i'], 250), ('[i]', 'r', 'normalized', ['i'], 251)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i < 2  ++i
induction variable: ['i']
{
L252: (errorsExpected[i],r) 
L253: (errorsExpected[i],r) 
L254: (coeffExpected[i],r) 
L255: (coeffExpected[i],r) 
}
array table
-----------------------------------------------
errorsExpected -> [('[i]', 'r', 'normalized', ['i'], 252), ('[i]', 'r', 'normalized', ['i'], 253)]
LDEs formed:0

coeffExpected -> [('[i]', 'r', 'normalized', ['i'], 254), ('[i]', 'r', 'normalized', ['i'], 255)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/covariance.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<n  i++
induction variable: ['i']
{
	loop info: Size j=0  j<n  j++
	induction variable: ['i', 'j']
	{
	L256: (goodCorr[i][j],r) 
	L257: (calcCorr[i][j],r) 
	L258: (cor[" << i << "][" << j << "],r) 
	}
 }
array table
-----------------------------------------------
cor -> [('[" << i << "][" << j << "]', 'r', 'normalized', ['i', 'j'], 258)]
LDEs formed:0

goodCorr -> [('[i][j]', 'r', 'normalized', ['i', 'j'], 256)]
LDEs formed:0

calcCorr -> [('[i][j]', 'r', 'normalized', ['i', 'j'], 257)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<n  i++
induction variable: ['i']
{
	loop info: Size j=0  j<n  j++
	induction variable: ['i', 'j']
	{
	L258: (goodCorr[i][j],r) 
	L259: (calcCorr[i][j],r) 
	L260: (cor[" << i << "][" << j << "],r) 
	}
 }
array table
-----------------------------------------------
cor -> [('[" << i << "][" << j << "]', 'r', 'normalized', ['i', 'j'], 260)]
LDEs formed:0

goodCorr -> [('[i][j]', 'r', 'normalized', ['i', 'j'], 258)]
LDEs formed:0

calcCorr -> [('[i][j]', 'r', 'normalized', ['i', 'j'], 259)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: i = 0  i<LENGTH(data)  i++
induction variable: ['i']
{
	loop info: j=0  j<n  j++
	induction variable: ['i', 'j']
	{
	L260: (temp[j]=,w) (data[i][j],r) 
	}
L261: (weights[i],r) 
}
array table
-----------------------------------------------
weights -> [('[i]', 'r', 'normalized', ['i', 'j'], 261)]
LDEs formed:0

data -> [('[i][j]', 'r', 'normalized', ['i', 'j'], 260)]
LDEs formed:0

temp -> [('[j]', 'w', 'normalized', ['i', 'j'], 260)]
LDEs formed:1

distinct LDEs:
j1=j2
#########################################################################################
loop info: i=0  i<n  i++
induction variable: ['i']
{
L261: (expCov[i][i]=,w) (std[i]*,r) (std[i],r) 
	loop info: j=0  j<i  j++
	induction variable: ['i', 'j']
	{
	L262: (expCov[i][j]=,w) (expCov[j][i]=,w) (expCor[i][j]*,r) (std[i]*,r) (std[j],r) 
	}
 }
array table
-----------------------------------------------
std -> [('[i]', 'r', 'normalized', ['i', 'j'], 261), ('[i]', 'r', 'normalized', ['i', 'j'], 261), ('[i]', 'r', 'normalized', ['i', 'j'], 262), ('[j]', 'r', 'normalized', ['i', 'j'], 262)]
LDEs formed:0

expCov -> [('[i][i]', 'w', 'normalized', ['i', 'j'], 261), ('[i][j]', 'w', 'normalized', ['i', 'j'], 262), ('[j][i]', 'w', 'normalized', ['i', 'j'], 262)]
LDEs formed:12

expCor -> [('[i][j]', 'r', 'normalized', ['i', 'j'], 262)]
LDEs formed:0

distinct LDEs:
j1=j2,i1=i2
i1=i2,j1=j2
i1=j2,i1=i2
i1=i2,i1=j2
i1=j2,j1=i2
i1=i2,i1=i2
#########################################################################################
loop info: i=0  i<n  i++
induction variable: ['i']
{
	loop info: j=0  j<n  j++
	induction variable: ['i', 'j']
	{
	L263: (expCor[i][j],r) 
	L264: (calcCor[i][j],r) 
	L265: (cor[" << i << "][" << j << "],r) 
	L266: (expCov[i][j],r) 
	L267: (calcCov[i][j],r) 
	L268: (cov[" << i << "][" << j << "],r) 
	}
 }
array table
-----------------------------------------------
expCov -> [('[i][j]', 'r', 'normalized', ['i', 'j'], 266)]
LDEs formed:0

cor -> [('[" << i << "][" << j << "]', 'r', 'normalized', ['i', 'j'], 265)]
LDEs formed:0

expCor -> [('[i][j]', 'r', 'normalized', ['i', 'j'], 263)]
LDEs formed:0

cov -> [('[" << i << "][" << j << "]', 'r', 'normalized', ['i', 'j'], 268)]
LDEs formed:0

calcCor -> [('[i][j]', 'r', 'normalized', ['i', 'j'], 264)]
LDEs formed:0

calcCov -> [('[i][j]', 'r', 'normalized', ['i', 'j'], 267)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: i=0  i<n  i++
induction variable: ['i']
{
	loop info: j=0  j<n  j++
	induction variable: ['i', 'j']
	{
	L268: (calcCov[i][j],r) 
	L269: (expCov[i][j],r) 
	L270: (cov[" << i << "][" << j << "],r) 
	}
 }
array table
-----------------------------------------------
expCov -> [('[i][j]', 'r', 'normalized', ['i', 'j'], 269)]
LDEs formed:0

calcCov -> [('[i][j]', 'r', 'normalized', ['i', 'j'], 268)]
LDEs formed:0

cov -> [('[" << i << "][" << j << "]', 'r', 'normalized', ['i', 'j'], 270)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: i=0  i<n  i++
induction variable: ['i']
{
L271: (calcStd[i],r) 
L272: (std[i],r) 
L273: (standardDev[" << i << "],r) 
	loop info: j=0  j<n  j++
	induction variable: ['i', 'j']
	{
	L274: (calcCor[i][j],r) 
	L275: (expCor[i][j],r) 
	L276: (corr[" << i << "][" << j << "],r) 
	}
 }
array table
-----------------------------------------------
std -> [('[i]', 'r', 'normalized', ['i', 'j'], 272)]
LDEs formed:0

expCor -> [('[i][j]', 'r', 'normalized', ['i', 'j'], 275)]
LDEs formed:0

calcCor -> [('[i][j]', 'r', 'normalized', ['i', 'j'], 274)]
LDEs formed:0

corr -> [('[" << i << "][" << j << "]', 'r', 'normalized', ['i', 'j'], 276)]
LDEs formed:0

calcStd -> [('[i]', 'r', 'normalized', ['i', 'j'], 271)]
LDEs formed:0

standardDev -> [('[" << i << "]', 'r', 'normalized', ['i', 'j'], 273)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/mclongstaffschwartzengine.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<path.assetNumber()  ++i
induction variable: ['i']
{
L274: (tmp[i]=,w) (path[i][t],r) 
}
array table
-----------------------------------------------
tmp -> [('[i]', 'w', 'normalized', ['i'], 274)]
LDEs formed:1

path -> [('[i][t]', 'r', 'not normalized', ['i'], 274)]
LDEs formed:0

distinct LDEs:
i1=i2
#########################################################################################
loop info: Integer i=0  i<2  ++i
induction variable: ['i']
{
	loop info: Integer j=0  j<3  ++j
	induction variable: ['i', 'j']
	{
	L275: (polynomTypes[0*(i*3+j)%LENGTH(polynomTypes)],r) 
	L276: (expectedExProb[i][j],r) 
	L277: (expectedExProb[i][j],r) 
	}
 }
array table
-----------------------------------------------
expectedExProb -> [('[i][j]', 'r', 'normalized', ['i', 'j'], 276), ('[i][j]', 'r', 'normalized', ['i', 'j'], 277)]
LDEs formed:0

polynomTypes -> [('[0*(i*3+j)%LENGTH(polynomTypes)]', 'r', 'not normalized', ['i', 'j'], 275)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<numberAssets  ++i
induction variable: ['i']
{
L276: (corr[i][i]=,w) 
}
array table
-----------------------------------------------
corr -> [('[i][i]', 'w', 'normalized', ['i'], 276)]
LDEs formed:2

distinct LDEs:
i1=i2,i1=i2
#########################################################################################
loop info: Size i = 0  i < 3  ++i
induction variable: ['i']
{
L277: (expected[i],r) 
L278: (expected[i],r) 
}
array table
-----------------------------------------------
expected -> [('[i]', 'r', 'normalized', ['i'], 277), ('[i]', 'r', 'normalized', ['i'], 278)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/bermudanswaption.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<leg.size()  i++
induction variable: ['i']
{
L279: (leg[i],r) 
}
array table
-----------------------------------------------
leg -> [('[i]', 'r', 'normalized', ['i'], 279)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/termstructures.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<deposits  i++
induction variable: ['i']
{
L280: (instruments[i]=,w) 
L281: (depositData[i].rate/,r) 
L282: (depositData[i].n*,r) (depositData[i].units,r) 
}
array table
-----------------------------------------------
instruments -> [('[i]', 'w', 'normalized', ['i'], 280)]
LDEs formed:1

depositData -> [('[i]', 'r', 'normalized', ['i'], 281), ('[i]', 'r', 'normalized', ['i'], 282), ('[i]', 'r', 'normalized', ['i'], 282)]
LDEs formed:0

distinct LDEs:
i1=i2
#########################################################################################
loop info: Size i=0  i<swaps  ++i
induction variable: ['i']
{
L283: (instruments[i+deposits]=,w) 
L284: (swapData[i].rate/,r) 
L285: (swapData[i].n*,r) (swapData[i].units,r) 
}
array table
-----------------------------------------------
instruments -> [('[i+deposits]', 'w', 'not normalized', ['i'], 283)]
LDEs formed:1

swapData -> [('[i]', 'r', 'normalized', ['i'], 284), ('[i]', 'r', 'normalized', ['i'], 285), ('[i]', 'r', 'normalized', ['i'], 285)]
LDEs formed:0

distinct LDEs:
i1+deposits=i2+deposits
#########################################################################################
loop info: i=0  i<LENGTH(days)  i++
induction variable: ['i']
{
L286: (expected[i],r) (calculated[i],r) 
L287: (days[i]<<,r) 
L288: (expected[i]<<,r) 
L289: (calculated[i],r) 
}
array table
-----------------------------------------------
expected -> [('[i]', 'r', 'normalized', ['i'], 286), ('[i]', 'r', 'normalized', ['i'], 288)]
LDEs formed:0

calculated -> [('[i]', 'r', 'normalized', ['i'], 286), ('[i]', 'r', 'normalized', ['i'], 289)]
LDEs formed:0

days -> [('[i]', 'r', 'normalized', ['i'], 287)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/capfloor.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<LENGTH(lengths)  i++
induction variable: ['i']
{
	loop info: Size j=0  j<LENGTH(vols)  j++
	induction variable: ['i', 'j']
	{
		loop info: Size k=0  k<LENGTH(strikes)  k++
		induction variable: ['i', 'j', 'k']
		{
			loop info: Size h=0  h<LENGTH(types)  h++
			induction variable: ['i', 'j', 'k', 'h']
			{
			L288: (lengths[i],r) 
			L289: (types[h],r) 
			L290: (strikes[k],r) (vols[j],r) 
			L291: (types[h],r) 
			L292: (strikes[k],r) (vols[j]+,r) 
			L293: (types[h],r) 
			L294: (strikes[k],r) (vols[j]-,r) 
			L295: (lengths[j]*,r) 
			L296: (strikes[k],r) 
			L297: (types[h]<<,r) 
			}
 		}
 	}
 }
array table
-----------------------------------------------
lengths -> [('[i]', 'r', 'normalized', ['i', 'j', 'k', 'h'], 288), ('[j]', 'r', 'normalized', ['i', 'j', 'k', 'h'], 295)]
LDEs formed:0

vols -> [('[j]', 'r', 'normalized', ['i', 'j', 'k', 'h'], 290), ('[j]', 'r', 'normalized', ['i', 'j', 'k', 'h'], 292), ('[j]', 'r', 'normalized', ['i', 'j', 'k', 'h'], 294)]
LDEs formed:0

strikes -> [('[k]', 'r', 'normalized', ['i', 'j', 'k', 'h'], 290), ('[k]', 'r', 'normalized', ['i', 'j', 'k', 'h'], 292), ('[k]', 'r', 'normalized', ['i', 'j', 'k', 'h'], 294), ('[k]', 'r', 'normalized', ['i', 'j', 'k', 'h'], 296)]
LDEs formed:0

types -> [('[h]', 'r', 'normalized', ['i', 'j', 'k', 'h'], 289), ('[h]', 'r', 'normalized', ['i', 'j', 'k', 'h'], 291), ('[h]', 'r', 'normalized', ['i', 'j', 'k', 'h'], 293), ('[h]', 'r', 'normalized', ['i', 'j', 'k', 'h'], 297)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<LENGTH(lengths)  i++
induction variable: ['i']
{
	loop info: Size j=0  j<LENGTH(vols)  j++
	induction variable: ['i', 'j']
	{
		loop info: Size k=0  k<LENGTH(strikes)  k++
		induction variable: ['i', 'j', 'k']
		{
		L298: (lengths[i],r) 
		L299: (strikes[k],r) (vols[j],r) 
		L300: (strikes[k],r) (vols[j],r) 
		}
	L301: (lengths[i]<<,r) 
	L302: (vols[j],r) 
	L303: (cap_values[n],r) 
	L304: (strikes[n],r) 
	L305: (cap_values[n+1],r) 
	L306: (strikes[n+1],r) 
	L307: (lengths[i]<<,r) 
	L308: (vols[j],r) 
	L309: (floor_values[n],r) 
	L310: (strikes[n],r) 
	L311: (floor_values[n+1],r) 
	L312: (strikes[n+1],r) 
	}
 }
array table
-----------------------------------------------
lengths -> [('[i]', 'r', 'normalized', ['i', 'j', 'k'], 298), ('[i]', 'r', 'normalized', ['i', 'j', 'k'], 301), ('[i]', 'r', 'normalized', ['i', 'j', 'k'], 307)]
LDEs formed:0

cap_values -> [('[n]', 'r', 'not normalized', ['i', 'j', 'k'], 303), ('[n+1]', 'r', 'not normalized', ['i', 'j', 'k'], 305)]
LDEs formed:0

vols -> [('[j]', 'r', 'normalized', ['i', 'j', 'k'], 299), ('[j]', 'r', 'normalized', ['i', 'j', 'k'], 300), ('[j]', 'r', 'normalized', ['i', 'j', 'k'], 302), ('[j]', 'r', 'normalized', ['i', 'j', 'k'], 308)]
LDEs formed:0

strikes -> [('[k]', 'r', 'normalized', ['i', 'j', 'k'], 299), ('[k]', 'r', 'normalized', ['i', 'j', 'k'], 300), ('[n]', 'r', 'not normalized', ['i', 'j', 'k'], 304), ('[n+1]', 'r', 'not normalized', ['i', 'j', 'k'], 306), ('[n]', 'r', 'not normalized', ['i', 'j', 'k'], 310), ('[n+1]', 'r', 'not normalized', ['i', 'j', 'k'], 312)]
LDEs formed:0

floor_values -> [('[n]', 'r', 'not normalized', ['i', 'j', 'k'], 309), ('[n+1]', 'r', 'not normalized', ['i', 'j', 'k'], 311)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<LENGTH(lengths)  i++
induction variable: ['i']
{
	loop info: Size j=0  j<LENGTH(cap_rates)  j++
	induction variable: ['i', 'j']
	{
		loop info: Size k=0  k<LENGTH(floor_rates)  k++
		induction variable: ['i', 'j', 'k']
		{
			loop info: Size l=0  l<LENGTH(vols)  l++
			induction variable: ['i', 'j', 'k', 'l']
			{
			L312: (lengths[i],r) 
			L313: (cap_rates[j],r) (vols[l],r) 
			L314: (floor_rates[k],r) (vols[l],r) 
			L315: (cap_rates[j],r) 
			L316: (floor_rates[k],r) 
			L317: (vols[l],r) 
			L318: (lengths[i]<<,r) 
			L319: (vols[l],r) 
			L320: (cap_rates[j],r) 
			L321: (floor_rates[k],r) 
				loop info: Integer m=0  m<lengths[i]*2  m++
				induction variable: ['i', 'j', 'k', 'l', 'm']
					{
					L322: (caplets[m]-,r) (vols[l],r) 
					L323: (caplets[m]-,r) 
					}
			L324: (lengths[i]<<,r) 
			L325: (vols[l],r) 
			L326: (cap_rates[j],r) 
			L327: (caplets[0]-,r) 
				loop info: Integer m=0  m<lengths[i]*2  m++
				induction variable: ['i', 'j', 'k', 'l', 'm']
					{
					L328: (floorlets[m]-,r) (vols[l],r) 
					L329: (floorlets[m]-,r) 
					}
			L330: (lengths[i]<<,r) 
			L331: (vols[l],r) 
			L332: (floor_rates[j],r) 
			L333: (floorlets[0]-,r) 
				loop info: Integer m=0  m<lengths[i]*2  m++
				induction variable: ['i', 'j', 'k', 'l', 'm']
					{
					L334: (collarlets[m]-,r) (vols[l],r) 
					L335: (collarlets[m]-,r) 
					}
			L336: (lengths[i]<<,r) 
			L337: (vols[l],r) 
			L338: (floor_rates[j],r) 
			L339: (cap_rates[j],r) 
			L340: (collarlets[0]-,r) 
			L341: (collarlets[0]-,r) 
			}
 		}
 	}
 }
array table
-----------------------------------------------
lengths -> [('[i]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'm'], 312), ('[i]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'm'], 318), ('[i]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'm'], 324), ('[i]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'm'], 330), ('[i]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'm'], 336)]
LDEs formed:0

floor_rates -> [('[k]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'm'], 314), ('[k]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'm'], 316), ('[k]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'm'], 321), ('[j]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'm'], 332), ('[j]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'm'], 338)]
LDEs formed:0

cap_rates -> [('[j]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'm'], 313), ('[j]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'm'], 315), ('[j]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'm'], 320), ('[j]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'm'], 326), ('[j]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'm'], 339)]
LDEs formed:0

floorlets -> [('[m]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'm'], 328), ('[m]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'm'], 329), ('[0]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'm'], 333)]
LDEs formed:0

vols -> [('[l]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'm'], 313), ('[l]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'm'], 314), ('[l]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'm'], 317), ('[l]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'm'], 319), ('[l]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'm'], 322), ('[l]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'm'], 325), ('[l]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'm'], 328), ('[l]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'm'], 331), ('[l]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'm'], 334), ('[l]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'm'], 337)]
LDEs formed:0

caplets -> [('[m]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'm'], 322), ('[m]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'm'], 323), ('[0]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'm'], 327)]
LDEs formed:0

collarlets -> [('[m]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'm'], 334), ('[m]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'm'], 335), ('[0]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'm'], 340), ('[0]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'm'], 341)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<LENGTH(lengths)  i++
induction variable: ['i']
{
	loop info: Size j=0  j<LENGTH(strikes)  j++
	induction variable: ['i', 'j']
	{
		loop info: Size k=0  k<LENGTH(vols)  k++
		induction variable: ['i', 'j', 'k']
		{
		L342: (lengths[i],r) 
		L343: (strikes[j],r) (vols[k],r) 
		L344: (strikes[j],r) (vols[k],r) 
		L345: (lengths[i],r) 
		L346: (vars.nominals[0],r) 
		L347: (strikes[j],r) 
		L348: (lengths[i]<<,r) 
		L349: (vols[k],r) 
		L350: (strikes[j],r) 
		}
 	}
 }
array table
-----------------------------------------------
lengths -> [('[i]', 'r', 'normalized', ['i', 'j', 'k'], 342), ('[i]', 'r', 'normalized', ['i', 'j', 'k'], 345), ('[i]', 'r', 'normalized', ['i', 'j', 'k'], 348)]
LDEs formed:0

vars.nominals -> [('[0]', 'r', 'normalized', ['i', 'j', 'k'], 346)]
LDEs formed:0

vols -> [('[k]', 'r', 'normalized', ['i', 'j', 'k'], 343), ('[k]', 'r', 'normalized', ['i', 'j', 'k'], 344), ('[k]', 'r', 'normalized', ['i', 'j', 'k'], 349)]
LDEs formed:0

strikes -> [('[j]', 'r', 'normalized', ['i', 'j', 'k'], 343), ('[j]', 'r', 'normalized', ['i', 'j', 'k'], 344), ('[j]', 'r', 'normalized', ['i', 'j', 'k'], 347), ('[j]', 'r', 'normalized', ['i', 'j', 'k'], 350)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<LENGTH(lengths)  i++
induction variable: ['i']
{
L351: (lengths[i],r) 
L352: (lengths[i],r) 
	loop info: Size j=0  j<LENGTH(strikes)  j++
	induction variable: ['i', 'j']
	{
		loop info: Size k=0  k<LENGTH(vols)  k++
		induction variable: ['i', 'j', 'k']
		{
		L353: (strikes[j],r) (vols[k],r) 
		L354: (strikes[j],r) (vols[k],r) 
		L355: (lengths[i]<<,r) 
		L356: (vols[k],r) 
		L357: (strikes[j],r) 
		L358: (vars.nominals[0],r) 
		L359: (lengths[i]<<,r) 
		L360: (vols[k],r) 
		}
 	}
 }
array table
-----------------------------------------------
lengths -> [('[i]', 'r', 'normalized', ['i', 'j', 'k'], 351), ('[i]', 'r', 'normalized', ['i', 'j', 'k'], 352), ('[i]', 'r', 'normalized', ['i', 'j', 'k'], 355), ('[i]', 'r', 'normalized', ['i', 'j', 'k'], 359)]
LDEs formed:0

vars.nominals -> [('[0]', 'r', 'normalized', ['i', 'j', 'k'], 358)]
LDEs formed:0

vols -> [('[k]', 'r', 'normalized', ['i', 'j', 'k'], 353), ('[k]', 'r', 'normalized', ['i', 'j', 'k'], 354), ('[k]', 'r', 'normalized', ['i', 'j', 'k'], 356), ('[k]', 'r', 'normalized', ['i', 'j', 'k'], 360)]
LDEs formed:0

strikes -> [('[j]', 'r', 'normalized', ['i', 'j', 'k'], 353), ('[j]', 'r', 'normalized', ['i', 'j', 'k'], 354), ('[j]', 'r', 'normalized', ['i', 'j', 'k'], 357)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size k=0  k<LENGTH(lengths)  k++
induction variable: ['k']
{
L358: (lengths[k],r) 
	loop info: Size i=0  i<LENGTH(types)  i++
	induction variable: ['k', 'i']
	{
		loop info: Size j=0  j<LENGTH(strikes)  j++
		induction variable: ['k', 'i', 'j']
		{
		L359: (types[i],r) (strikes[j],r) 
			loop info: Size n=0  n<LENGTH(rRates)  n++
			induction variable: ['k', 'i', 'j', 'n']
			{
				loop info: Size m=0  m<LENGTH(vols)  m++
				induction variable: ['k', 'i', 'j', 'n', 'm']
				{
				L360: (rRates[n],r) 
				L361: (vols[m],r) 
				L362: (types[i],r) 
				L363: (strikes[j],r) 
				L364: (lengths[k]<<,r) 
				L365: (types[i],r) 
				L366: (strikes[j],r) 
				L367: (lengths[k]<<,r) 
				}
 			}
 		}
 	}
 }
array table
-----------------------------------------------
lengths -> [('[k]', 'r', 'normalized', ['k', 'i', 'j', 'n', 'm'], 358), ('[k]', 'r', 'normalized', ['k', 'i', 'j', 'n', 'm'], 364), ('[k]', 'r', 'normalized', ['k', 'i', 'j', 'n', 'm'], 367)]
LDEs formed:0

rRates -> [('[n]', 'r', 'normalized', ['k', 'i', 'j', 'n', 'm'], 360)]
LDEs formed:0

vols -> [('[m]', 'r', 'normalized', ['k', 'i', 'j', 'n', 'm'], 361)]
LDEs formed:0

strikes -> [('[j]', 'r', 'normalized', ['k', 'i', 'j', 'n', 'm'], 359), ('[j]', 'r', 'normalized', ['k', 'i', 'j', 'n', 'm'], 363), ('[j]', 'r', 'normalized', ['k', 'i', 'j', 'n', 'm'], 366)]
LDEs formed:0

types -> [('[i]', 'r', 'normalized', ['k', 'i', 'j', 'n', 'm'], 359), ('[i]', 'r', 'normalized', ['k', 'i', 'j', 'n', 'm'], 362), ('[i]', 'r', 'normalized', ['k', 'i', 'j', 'n', 'm'], 365)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/rangeaccrual.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: i=0  i<nRowsAtmVols  i++
induction variable: ['i']
{
L366: (atmVolsHandle[i]=,w) 
	loop info: Size j=0  j<nColsAtmVols  j++
	induction variable: ['i', 'j']
	{
	L367: (atmVolsHandle[i][j]=,w) 
	L368: (atmVolMatrix[i][j],r) 
	}
 }
array table
-----------------------------------------------
atmVolMatrix -> [('[i][j]', 'r', 'normalized', ['i', 'j'], 368)]
LDEs formed:0

atmVolsHandle -> [('[i]', 'w', 'normalized', ['i', 'j'], 366), ('[i][j]', 'w', 'normalized', ['i', 'j'], 367)]
LDEs formed:6

distinct LDEs:
i1=i2,j1=j2
i1=i2
#########################################################################################
loop info: i=0  i<optionTenors.size()*swapTenors.size()  i++
induction variable: ['i']
{
L368: (parametersGuess[i]=,w) 
L369: (parametersGuess[i][0]=,w) 
L370: (parametersGuess[i][1]=,w) 
L371: (parametersGuess[i][2]=,w) 
L372: (parametersGuess[i][3]=,w) 
}
array table
-----------------------------------------------
parametersGuess -> [('[i]', 'w', 'normalized', ['i'], 368), ('[i][0]', 'w', 'normalized', ['i'], 369), ('[i][1]', 'w', 'normalized', ['i'], 370), ('[i][2]', 'w', 'normalized', ['i'], 371), ('[i][3]', 'w', 'normalized', ['i'], 372)]
LDEs formed:30

distinct LDEs:
i1=i2,2=2
i1=i2,2=3
i1=i2,3=3
i1=i2,0=0
i1=i2,0=1
i1=i2,0=2
i1=i2,0=3
i1=i2
i1=i2,1=1
i1=i2,1=3
i1=i2,1=2
#########################################################################################
loop info: i=0  i<optionTenors.size()*swapTenors.size()  i++
induction variable: ['i']
{
L373: (nullVolSpreads[i]=,w) 
	loop info: Size j=0  j<strikeSpreads.size()  j++
	induction variable: ['i', 'j']
	{
	L374: (nullVolSpreads[i][j]=,w) 
	}
 }
array table
-----------------------------------------------
nullVolSpreads -> [('[i]', 'w', 'normalized', ['i', 'j'], 373), ('[i][j]', 'w', 'normalized', ['i', 'j'], 374)]
LDEs formed:6

distinct LDEs:
i1=i2,j1=j2
i1=i2
#########################################################################################
loop info: i=0  i<optionTenors.size()*swapTenors.size()  i++
induction variable: ['i']
{
L375: (volSpreads[i]=,w) 
	loop info: Size j=0  j<strikeSpreads.size()  j++
	induction variable: ['i', 'j']
	{
	L376: (volSpreads[i][j]=,w) 
	L377: (volSpreadsMatrix[i][j],r) 
	}
 }
array table
-----------------------------------------------
volSpreadsMatrix -> [('[i][j]', 'r', 'normalized', ['i', 'j'], 377)]
LDEs formed:0

volSpreads -> [('[i]', 'w', 'normalized', ['i', 'j'], 375), ('[i][j]', 'w', 'normalized', ['i', 'j'], 376)]
LDEs formed:6

distinct LDEs:
i1=i2,j1=j2
i1=i2
#########################################################################################
loop info: Size z = 0  z < vars.smilesOnPayment.size()  z++
induction variable: ['z']
{
	loop info: Size i = 0  i < vars.byCallSpread.size()  i++
	induction variable: ['z', 'i']
	{
	L377: (vars.smilesOnExpiry[z],r) 
	L378: (vars.smilesOnPayment[z],r) 
	L379: (vars.byCallSpread[i],r) 
	}
 }
array table
-----------------------------------------------
vars.smilesOnExpiry -> [('[z]', 'r', 'normalized', ['z', 'i'], 377)]
LDEs formed:0

vars.smilesOnPayment -> [('[z]', 'r', 'normalized', ['z', 'i'], 378)]
LDEs formed:0

vars.byCallSpread -> [('[i]', 'r', 'normalized', ['z', 'i'], 379)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size z = 0  z < vars.smilesOnPayment.size()  z++
induction variable: ['z']
{
	loop info: Size i = 0  i < vars.byCallSpread.size()  i++
	induction variable: ['z', 'i']
	{
	L380: (vars.smilesOnExpiry[z],r) 
	L381: (vars.smilesOnPayment[z],r) 
	L382: (vars.byCallSpread[i],r) 
		loop info: Size k = 1  k < 100  k++
		induction variable: ['z', 'i', 'k']
		{
		}
 	}
 }
array table
-----------------------------------------------
vars.smilesOnExpiry -> [('[z]', 'r', 'normalized', ['z', 'i', 'k'], 380)]
LDEs formed:0

vars.smilesOnPayment -> [('[z]', 'r', 'normalized', ['z', 'i', 'k'], 381)]
LDEs formed:0

vars.byCallSpread -> [('[i]', 'r', 'normalized', ['z', 'i', 'k'], 382)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size z = 0  z < vars.smilesOnPayment.size()  z++
induction variable: ['z']
{
	loop info: Size i = 0  i < vars.byCallSpread.size()  i++
	induction variable: ['z', 'i']
	{
	L383: (vars.smilesOnExpiry[z],r) 
	L384: (vars.smilesOnPayment[z],r) 
	L385: (vars.byCallSpread[i],r) 
		loop info: Size k = 1  k < 95  k++
		induction variable: ['z', 'i', 'k']
		{
		}
 	}
 }
array table
-----------------------------------------------
vars.smilesOnExpiry -> [('[z]', 'r', 'normalized', ['z', 'i', 'k'], 383)]
LDEs formed:0

vars.smilesOnPayment -> [('[z]', 'r', 'normalized', ['z', 'i', 'k'], 384)]
LDEs formed:0

vars.byCallSpread -> [('[i]', 'r', 'normalized', ['z', 'i', 'k'], 385)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/marketmodel_cms.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<todaysCMSwapRates.size()  i++
induction variable: ['i']
{
L386: (volatilities[i]=,w) (todaysCMSwapRates[i]*,r) (mktVols[i]/,r) 
L387: (todaysCMSwapRates[i]+,r) 
L388: (blackVols[i]=,w) (mktVols[i],r) 
}
array table
-----------------------------------------------
volatilities -> [('[i]', 'w', 'normalized', ['i'], 386)]
LDEs formed:1

mktVols -> [('[i]', 'r', 'normalized', ['i'], 386), ('[i]', 'r', 'normalized', ['i'], 388)]
LDEs formed:0

blackVols -> [('[i]', 'w', 'normalized', ['i'], 388)]
LDEs formed:1

todaysCMSwapRates -> [('[i]', 'r', 'normalized', ['i'], 386), ('[i]', 'r', 'normalized', ['i'], 387)]
LDEs formed:0

distinct LDEs:
i1=i2
#########################################################################################
loop info: Size i=0  i<N  ++i
induction variable: ['i']
{
L388: (todaysCMSwapRates[i]-,r) (todaysDiscounts[i],r) 
L389: (expectedNPVs[i]=,w) 
L390: (discrepancies[i]=,w) (results[i]-,r) (expectedNPVs[i],r) (errors[i],r) 
L391: (discrepancies[i],r) 
}
array table
-----------------------------------------------
todaysCMSwapRates -> [('[i]', 'r', 'normalized', ['i'], 388)]
LDEs formed:0

errors -> [('[i]', 'r', 'normalized', ['i'], 390)]
LDEs formed:0

expectedNPVs -> [('[i]', 'w', 'normalized', ['i'], 389), ('[i]', 'r', 'normalized', ['i'], 390)]
LDEs formed:2

results -> [('[i]', 'r', 'normalized', ['i'], 390)]
LDEs formed:0

todaysDiscounts -> [('[i]', 'r', 'normalized', ['i'], 388)]
LDEs formed:0

discrepancies -> [('[i]', 'w', 'normalized', ['i'], 390), ('[i]', 'r', 'normalized', ['i'], 391)]
LDEs formed:2

distinct LDEs:
i1=i2
#########################################################################################
loop info: Size i=0  i<N  ++i
induction variable: ['i']
{
L392: (results[i],r) 
L393: (errors[i],r) 
L394: (expectedNPVs[i],r) 
L395: (discrepancies[N-1-i],r) 
}
array table
-----------------------------------------------
discrepancies -> [('[N-1-i]', 'r', 'not normalized', ['i'], 395)]
LDEs formed:0

errors -> [('[i]', 'r', 'normalized', ['i'], 393)]
LDEs formed:0

results -> [('[i]', 'r', 'normalized', ['i'], 392)]
LDEs formed:0

expectedNPVs -> [('[i]', 'r', 'normalized', ['i'], 394)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<N  ++i
induction variable: ['i']
{
L395: (displacedPayoff[i],r) 
L396: (todaysCMSwapRates[i]+,r) 
L397: (volatilities[i]*,r) (rateTimes[i],r) 
L398: (todaysDiscounts[i],r) 
L399: (expectedSwaptions[i]=,w) 
L400: (discrepancies[i]=,w) (results[N+i]-,r) (expectedSwaptions[i],r) (errors[N+i],r) 
L401: (discrepancies[i],r) 
}
array table
-----------------------------------------------
volatilities -> [('[i]', 'r', 'normalized', ['i'], 397)]
LDEs formed:0

errors -> [('[N+i]', 'r', 'not normalized', ['i'], 400)]
LDEs formed:0

todaysCMSwapRates -> [('[i]', 'r', 'normalized', ['i'], 396)]
LDEs formed:0

displacedPayoff -> [('[i]', 'r', 'normalized', ['i'], 395)]
LDEs formed:0

results -> [('[N+i]', 'r', 'not normalized', ['i'], 400)]
LDEs formed:0

todaysDiscounts -> [('[i]', 'r', 'normalized', ['i'], 398)]
LDEs formed:0

expectedSwaptions -> [('[i]', 'w', 'normalized', ['i'], 399), ('[i]', 'r', 'normalized', ['i'], 400)]
LDEs formed:2

discrepancies -> [('[i]', 'w', 'normalized', ['i'], 400), ('[i]', 'r', 'normalized', ['i'], 401)]
LDEs formed:2

rateTimes -> [('[i]', 'r', 'normalized', ['i'], 397)]
LDEs formed:0

distinct LDEs:
i1=i2
#########################################################################################
loop info: Size i=1  i<=N  ++i
induction variable: ['i']
{
L398: (results[2*N-i],r) 
L399: (errors[2*N-i],r) 
L400: (expectedSwaptions[N-i],r) 
L401: (discrepancies[N-i],r) 
}
array table
-----------------------------------------------
discrepancies -> [('[N-i]', 'r', 'not normalized', ['i'], 401)]
LDEs formed:0

errors -> [('[2*N-i]', 'r', 'not normalized', ['i'], 399)]
LDEs formed:0

results -> [('[2*N-i]', 'r', 'not normalized', ['i'], 398)]
LDEs formed:0

expectedSwaptions -> [('[N-i]', 'r', 'not normalized', ['i'], 400)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<undisplacedPayoff.size()  ++i
induction variable: ['i']
{
L401: (displacedPayoff[i]=,w) 
L402: (undisplacedPayoff[i]=,w) 
}
array table
-----------------------------------------------
undisplacedPayoff -> [('[i]', 'w', 'normalized', ['i'], 402)]
LDEs formed:1

displacedPayoff -> [('[i]', 'w', 'normalized', ['i'], 401)]
LDEs formed:1

distinct LDEs:
i1=i2
#########################################################################################
loop info: Size j=0  j<LENGTH(marketModels)  j++
induction variable: ['j']
{
	loop info: Size m=0  m<LENGTH(testedFactors)  ++m
	induction variable: ['j', 'm']
	{
	L402: (testedFactors[m],r) 
		loop info: Size k=0  k<LENGTH(measures)  k++
		induction variable: ['j', 'm', 'k']
		{
		L403: (measures[k],r) 
		L404: (marketModels[j],r) 
			loop info: Size i=0  i<LENGTH(evolvers)-stop  i++
			induction variable: ['j', 'm', 'k', 'i']
			{
				loop info: Size n=0  n<1  n++
				induction variable: ['j', 'm', 'k', 'i', 'n']
				{
				L405: (evolvers[i],r) 
				L406: (marketModels[j],r) 
				L407: (measures[k],r) 
				L408: (evolvers[i],r) 
				}
 			}
 		}
 	}
 }
array table
-----------------------------------------------
testedFactors -> [('[m]', 'r', 'normalized', ['j', 'm', 'k', 'i', 'n'], 402)]
LDEs formed:0

marketModels -> [('[j]', 'r', 'normalized', ['j', 'm', 'k', 'i', 'n'], 404), ('[j]', 'r', 'normalized', ['j', 'm', 'k', 'i', 'n'], 406)]
LDEs formed:0

measures -> [('[k]', 'r', 'normalized', ['j', 'm', 'k', 'i', 'n'], 403), ('[k]', 'r', 'normalized', ['j', 'm', 'k', 'i', 'n'], 407)]
LDEs formed:0

evolvers -> [('[i]', 'r', 'normalized', ['j', 'm', 'k', 'i', 'n'], 405), ('[i]', 'r', 'normalized', ['j', 'm', 'k', 'i', 'n'], 408)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/inflationvolatility.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i = 0  i < nTimesEUR  i++
induction variable: ['i']
{
L409: (ratesEUR[i],r) 
L410: (timesEUR[i],r) 
L411: (timesEUR[i]-,r) 
}
array table
-----------------------------------------------
timesEUR -> [('[i]', 'r', 'normalized', ['i'], 410), ('[i]', 'r', 'normalized', ['i'], 411)]
LDEs formed:0

ratesEUR -> [('[i]', 'r', 'normalized', ['i'], 409)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i = 0  i < nTimesGBP  i++
induction variable: ['i']
{
L410: (ratesGBP[i],r) 
L411: (timesGBP[i],r) 
L412: (timesGBP[i]-,r) 
}
array table
-----------------------------------------------
ratesGBP -> [('[i]', 'r', 'normalized', ['i'], 410)]
LDEs formed:0

timesGBP -> [('[i]', 'r', 'normalized', ['i'], 411), ('[i]', 'r', 'normalized', ['i'], 412)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i = 0  i < LENGTH(yoyEUrates)  i++
induction variable: ['i']
{
L413: (yoyEUrates[i],r) 
}
array table
-----------------------------------------------
yoyEUrates -> [('[i]', 'r', 'normalized', ['i'], 413)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i = 0  i < ncStrikesEU  i++
induction variable: ['i']
{
	loop info: Size j = 0  j < ncfMaturitiesEU  j++
	induction variable: ['i', 'j']
	{
	L414: (capPricesEU[i][j],r) 
	}
 }
array table
-----------------------------------------------
capPricesEU -> [('[i][j]', 'r', 'normalized', ['i', 'j'], 414)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i = 0  i < nfStrikesEU  i++
induction variable: ['i']
{
	loop info: Size j = 0  j < ncfMaturitiesEU  j++
	induction variable: ['i', 'j']
	{
	L415: (floorPricesEU[i][j],r) 
	}
 }
array table
-----------------------------------------------
floorPricesEU -> [('[i][j]', 'r', 'normalized', ['i', 'j'], 415)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i = 0  i < n  i++
induction variable: ['i']
{
L416: (someSlice.second[i]-,r) (volATyear1[i],r) 
L417: (someSlice.second[i],r) 
L418: (volATyear1[i],r) 
}
array table
-----------------------------------------------
someSlice.second -> [('[i]', 'r', 'normalized', ['i'], 416), ('[i]', 'r', 'normalized', ['i'], 417)]
LDEs formed:0

volATyear1 -> [('[i]', 'r', 'normalized', ['i'], 416), ('[i]', 'r', 'normalized', ['i'], 418)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i = 0  i < n  i++
induction variable: ['i']
{
L419: (someOtherSlice.second[i]-,r) (volATyear3[i],r) 
L420: (someOtherSlice.second[i]<<,r) (volATyear3[i],r) 
}
array table
-----------------------------------------------
volATyear3 -> [('[i]', 'r', 'normalized', ['i'], 419), ('[i]', 'r', 'normalized', ['i'], 420)]
LDEs formed:0

someOtherSlice.second -> [('[i]', 'r', 'normalized', ['i'], 419), ('[i]', 'r', 'normalized', ['i'], 420)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i = 0  i < yyATMt.first.size()  i++
induction variable: ['i']
{
L421: (yyATMt.second[i]-,r) (crv[i],r) 
L422: (yyATMt.second[i]<<,r) (crv[i],r) 
}
array table
-----------------------------------------------
crv -> [('[i]', 'r', 'normalized', ['i'], 421), ('[i]', 'r', 'normalized', ['i'], 422)]
LDEs formed:0

yyATMt.second -> [('[i]', 'r', 'normalized', ['i'], 421), ('[i]', 'r', 'normalized', ['i'], 422)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i = 0  i < yyATMd.first.size()  i++
induction variable: ['i']
{
L423: (yyATMd.first[i],r) (swaps[i],r) 
L424: (yyATMd.first[i],r) (swaps[i],r) 
}
array table
-----------------------------------------------
yyATMd.first -> [('[i]', 'r', 'normalized', ['i'], 423), ('[i]', 'r', 'normalized', ['i'], 424)]
LDEs formed:0

swaps -> [('[i]', 'r', 'normalized', ['i'], 423), ('[i]', 'r', 'normalized', ['i'], 424)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i = 0  i < yyATMd.first.size()  i++
induction variable: ['i']
{
L425: (yyATMd.first[i],r) (ayoy[i],r) 
L426: (yyATMd.first[i],r) (ayoy[i],r) 
L427: (yyATMd.first[i],r) 
}
array table
-----------------------------------------------
yyATMd.first -> [('[i]', 'r', 'normalized', ['i'], 425), ('[i]', 'r', 'normalized', ['i'], 426), ('[i]', 'r', 'normalized', ['i'], 427)]
LDEs formed:0

ayoy -> [('[i]', 'r', 'normalized', ['i'], 425), ('[i]', 'r', 'normalized', ['i'], 426)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/varianceswaps.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<LENGTH(values)  i++
induction variable: ['i']
{
L427: (values[i].t*,r) 
L428: (dates[0]=,w) 
L429: (values[i].s,r) 
L430: (values[i].q,r) 
L431: (values[i].r,r) 
	loop info: j=0  j<options  j++
	induction variable: ['i', 'j']
	{
	L432: (replicatingOptionData[j].type==,r) 
	L433: (replicatingOptionData[j].strike,r) 
	L434: (replicatingOptionData[j].v,r) 
	L435: (replicatingOptionData[j].type==,r) 
	L436: (replicatingOptionData[j].strike,r) 
	L437: (replicatingOptionData[j].v,r) 
	}
	loop info: j=0  j<putVols.size()  j++
	induction variable: ['i', 'j']
	{
	L438: (vols[j][0]=,w) (putVols[j],r) 
	L439: (putStrikes[j],r) 
	}
	loop info: Size k=1  k<callVols.size()  k++
	induction variable: ['i', 'j', 'k']
	{
	L440: (vols[j+k][0]=,w) (callVols[k],r) 
	L441: (callStrikes[k],r) 
	}
L442: (values[i].type,r) 
L443: (values[i].varStrike,r) 
L444: (values[i].nominal,r) 
L445: (values[i].result,r) 
L446: (values[i].tol,r) 
L447: (values[i].type,r) (values[i].varStrike,r) 
L448: (values[i].nominal,r) (values[i].s,r) (values[i].q,r) 
L449: (values[i].r,r) (values[i].v,r) 
L450: (values[i].tol,r) 
}
array table
-----------------------------------------------
dates -> [('[0]', 'w', 'normalized', ['i', 'j', 'k'], 428)]
LDEs formed:1

replicatingOptionData -> [('[j]', 'r', 'normalized', ['i', 'j', 'k'], 432), ('[j]', 'r', 'normalized', ['i', 'j', 'k'], 433), ('[j]', 'r', 'normalized', ['i', 'j', 'k'], 434), ('[j]', 'r', 'normalized', ['i', 'j', 'k'], 435), ('[j]', 'r', 'normalized', ['i', 'j', 'k'], 436), ('[j]', 'r', 'normalized', ['i', 'j', 'k'], 437)]
LDEs formed:0

callVols -> [('[k]', 'r', 'normalized', ['i', 'j', 'k'], 440)]
LDEs formed:0

putStrikes -> [('[j]', 'r', 'normalized', ['i', 'j', 'k'], 439)]
LDEs formed:0

putVols -> [('[j]', 'r', 'normalized', ['i', 'j', 'k'], 438)]
LDEs formed:0

values -> [('[i]', 'r', 'normalized', ['i', 'j', 'k'], 427), ('[i]', 'r', 'normalized', ['i', 'j', 'k'], 429), ('[i]', 'r', 'normalized', ['i', 'j', 'k'], 430), ('[i]', 'r', 'normalized', ['i', 'j', 'k'], 431), ('[i]', 'r', 'normalized', ['i', 'j', 'k'], 442), ('[i]', 'r', 'normalized', ['i', 'j', 'k'], 443), ('[i]', 'r', 'normalized', ['i', 'j', 'k'], 444), ('[i]', 'r', 'normalized', ['i', 'j', 'k'], 445), ('[i]', 'r', 'normalized', ['i', 'j', 'k'], 446), ('[i]', 'r', 'normalized', ['i', 'j', 'k'], 447), ('[i]', 'r', 'normalized', ['i', 'j', 'k'], 447), ('[i]', 'r', 'normalized', ['i', 'j', 'k'], 448), ('[i]', 'r', 'normalized', ['i', 'j', 'k'], 448), ('[i]', 'r', 'normalized', ['i', 'j', 'k'], 448), ('[i]', 'r', 'normalized', ['i', 'j', 'k'], 449), ('[i]', 'r', 'normalized', ['i', 'j', 'k'], 449), ('[i]', 'r', 'normalized', ['i', 'j', 'k'], 450)]
LDEs formed:0

callStrikes -> [('[k]', 'r', 'normalized', ['i', 'j', 'k'], 441)]
LDEs formed:0

vols -> [('[j][0]', 'w', 'normalized', ['i', 'j', 'k'], 438), ('[j+k][0]', 'w', 'normalized', ['i', 'j', 'k'], 440)]
LDEs formed:6

distinct LDEs:
0=0
j1+k1=j2+k2,0=0
j1=j2,0=0
j1=j2+k2,0=0
#########################################################################################
loop info: Size i=0  i<LENGTH(values)  i++
induction variable: ['i']
{
L441: (values[i].t*,r) 
L442: (values[i].t1*,r) 
L443: (dates[0]=,w) 
L444: (dates[1]=,w) 
L445: (values[i].s,r) 
L446: (values[i].q,r) 
L447: (values[i].r,r) 
L448: (vols[0]=,w) (values[i].v1,r) 
L449: (vols[1]=,w) (values[i].v,r) 
L450: (values[i].type,r) 
L451: (values[i].varStrike,r) 
L452: (values[i].nominal,r) 
L453: (values[i].result,r) 
L454: (values[i].tol,r) 
L455: (values[i].type,r) (values[i].varStrike,r) 
L456: (values[i].nominal,r) (values[i].s,r) (values[i].q,r) 
L457: (values[i].r,r) (values[i].v,r) 
L458: (values[i].tol,r) 
}
array table
-----------------------------------------------
dates -> [('[0]', 'w', 'normalized', ['i'], 443), ('[1]', 'w', 'normalized', ['i'], 444)]
LDEs formed:3

values -> [('[i]', 'r', 'normalized', ['i'], 441), ('[i]', 'r', 'normalized', ['i'], 442), ('[i]', 'r', 'normalized', ['i'], 445), ('[i]', 'r', 'normalized', ['i'], 446), ('[i]', 'r', 'normalized', ['i'], 447), ('[i]', 'r', 'normalized', ['i'], 448), ('[i]', 'r', 'normalized', ['i'], 449), ('[i]', 'r', 'normalized', ['i'], 450), ('[i]', 'r', 'normalized', ['i'], 451), ('[i]', 'r', 'normalized', ['i'], 452), ('[i]', 'r', 'normalized', ['i'], 453), ('[i]', 'r', 'normalized', ['i'], 454), ('[i]', 'r', 'normalized', ['i'], 455), ('[i]', 'r', 'normalized', ['i'], 455), ('[i]', 'r', 'normalized', ['i'], 456), ('[i]', 'r', 'normalized', ['i'], 456), ('[i]', 'r', 'normalized', ['i'], 456), ('[i]', 'r', 'normalized', ['i'], 457), ('[i]', 'r', 'normalized', ['i'], 457), ('[i]', 'r', 'normalized', ['i'], 458)]
LDEs formed:0

vols -> [('[0]', 'w', 'normalized', ['i'], 448), ('[1]', 'w', 'normalized', ['i'], 449)]
LDEs formed:3

distinct LDEs:
1=1
0=0
0=1
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/blackdeltacalculator.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<LENGTH(values)  i++
induction variable: ['i']
{
L450: (values[i].ot,r) 
L451: (values[i].dt,r) 
L452: (values[i].spot,r) 
L453: (values[i].dDf,r) 
L454: (values[i].fDf,r) 
L455: (values[i].stdDev,r) 
L456: (values[i].strike,r) 
L457: (values[i].value,r) 
}
array table
-----------------------------------------------
values -> [('[i]', 'r', 'normalized', ['i'], 450), ('[i]', 'r', 'normalized', ['i'], 451), ('[i]', 'r', 'normalized', ['i'], 452), ('[i]', 'r', 'normalized', ['i'], 453), ('[i]', 'r', 'normalized', ['i'], 454), ('[i]', 'r', 'normalized', ['i'], 455), ('[i]', 'r', 'normalized', ['i'], 456), ('[i]', 'r', 'normalized', ['i'], 457)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<LENGTH(values) ++i
induction variable: ['i']
{
L458: (values[i].type,r) (values[i].strike,r) 
L459: (values[i].t,r) 
L460: (values[i].s,r) 
L461: (values[i].v,r) 
L462: (values[i].r,r) 
L463: (values[i].q,r) 
L464: (values[i].type,r) 
L465: (values[i].strike,r) 
L466: (values[i].strike,r) 
L467: (values[i].strike,r) 
}
array table
-----------------------------------------------
values -> [('[i]', 'r', 'normalized', ['i'], 458), ('[i]', 'r', 'normalized', ['i'], 458), ('[i]', 'r', 'normalized', ['i'], 459), ('[i]', 'r', 'normalized', ['i'], 460), ('[i]', 'r', 'normalized', ['i'], 461), ('[i]', 'r', 'normalized', ['i'], 462), ('[i]', 'r', 'normalized', ['i'], 463), ('[i]', 'r', 'normalized', ['i'], 464), ('[i]', 'r', 'normalized', ['i'], 465), ('[i]', 'r', 'normalized', ['i'], 466), ('[i]', 'r', 'normalized', ['i'], 467)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<LENGTH(values) ++i
induction variable: ['i']
{
L468: (values[i].strike,r) 
L469: (values[i].t,r) 
L470: (values[i].s,r) 
L471: (values[i].v,r) 
L472: (values[i].r,r) 
L473: (values[i].q,r) 
L474: (values[i].strike,r) 
L475: (values[i].strike,r) 
L476: (values[i].strike,r) 
L477: (values[i].strike,r) 
L478: (values[i].strike,r) 
L479: (values[i].strike,r) 
L480: (values[i].strike/,r) 
L481: (values[i].strike,r) 
L482: (values[i].strike,r) 
L483: (values[i].strike/,r) 
}
array table
-----------------------------------------------
values -> [('[i]', 'r', 'normalized', ['i'], 468), ('[i]', 'r', 'normalized', ['i'], 469), ('[i]', 'r', 'normalized', ['i'], 470), ('[i]', 'r', 'normalized', ['i'], 471), ('[i]', 'r', 'normalized', ['i'], 472), ('[i]', 'r', 'normalized', ['i'], 473), ('[i]', 'r', 'normalized', ['i'], 474), ('[i]', 'r', 'normalized', ['i'], 475), ('[i]', 'r', 'normalized', ['i'], 476), ('[i]', 'r', 'normalized', ['i'], 477), ('[i]', 'r', 'normalized', ['i'], 478), ('[i]', 'r', 'normalized', ['i'], 479), ('[i]', 'r', 'normalized', ['i'], 480), ('[i]', 'r', 'normalized', ['i'], 481), ('[i]', 'r', 'normalized', ['i'], 482), ('[i]', 'r', 'normalized', ['i'], 483)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<LENGTH(values)  i++
induction variable: ['i']
{
L484: (values[i].dt,r) 
L485: (values[i].spot,r) 
L486: (values[i].dDf,r) 
L487: (values[i].fDf,r) 
L488: (values[i].stdDev,r) 
}
array table
-----------------------------------------------
values -> [('[i]', 'r', 'normalized', ['i'], 484), ('[i]', 'r', 'normalized', ['i'], 485), ('[i]', 'r', 'normalized', ['i'], 486), ('[i]', 'r', 'normalized', ['i'], 487), ('[i]', 'r', 'normalized', ['i'], 488)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/distributions.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<LENGTH(values)  i++
induction variable: ['i']
{
L489: (values[i].rho,r) 
L490: (values[i].a,r) (values[i].b,r) 
L491: (values[i].result,r) 
L492: (values[i].a<<,r) 
L493: (values[i].b<<,r) 
L494: (values[i].rho<<,r) 
L495: (values[i].result<<,r) 
}
array table
-----------------------------------------------
values -> [('[i]', 'r', 'normalized', ['i'], 489), ('[i]', 'r', 'normalized', ['i'], 490), ('[i]', 'r', 'normalized', ['i'], 490), ('[i]', 'r', 'normalized', ['i'], 491), ('[i]', 'r', 'normalized', ['i'], 492), ('[i]', 'r', 'normalized', ['i'], 493), ('[i]', 'r', 'normalized', ['i'], 494), ('[i]', 'r', 'normalized', ['i'], 495)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0 i<LENGTH(rho) i++
induction variable: ['i']
{
	loop info: Integer sgn=-1  sgn < 2  sgn+=2
	induction variable: ['i', 'sgn']
	{
	L496: (rho[i],r) 
	L497: (rho[i],r) 
	L498: (rho[i]<<,r) 
	}
 }
array table
-----------------------------------------------
rho -> [('[i]', 'r', 'normalized', ['i', 'sgn'], 496), ('[i]', 'r', 'normalized', ['i', 'sgn'], 497), ('[i]', 'r', 'normalized', ['i', 'sgn'], 498)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<LENGTH(data)  i++
induction variable: ['i']
{
L499: (data[i],r) 
L500: (data[i]<<,r) 
L501: (data[i],r) 
}
array table
-----------------------------------------------
data -> [('[i]', 'r', 'normalized', ['i'], 499), ('[i]', 'r', 'normalized', ['i'], 500), ('[i]', 'r', 'normalized', ['i'], 501)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i < LENGTH(ns)  ++i
induction variable: ['i']
{
L502: (ns[i],r) 
L503: (ns[i],r) 
	loop info: Size j=0  j < LENGTH(xs)  ++j
	induction variable: ['i', 'j']
	{
	L504: (xs[j],r) (xs[j],r) 
	L505: (expected1[i*LENGTH(xs)+j],r) 
	L506: (xs[j],r) (xs[j],r) 
	L507: (expected2[i*LENGTH(xs)+j],r) 
	L508: (xs[j]<<,r) 
	L509: (xs[j]<<,r) 
	}
 }
array table
-----------------------------------------------
expected1 -> [('[i*LENGTH(xs)+j]', 'r', 'not normalized', ['i', 'j'], 505)]
LDEs formed:0

xs -> [('[j]', 'r', 'normalized', ['i', 'j'], 504), ('[j]', 'r', 'normalized', ['i', 'j'], 504), ('[j]', 'r', 'normalized', ['i', 'j'], 506), ('[j]', 'r', 'normalized', ['i', 'j'], 506), ('[j]', 'r', 'normalized', ['i', 'j'], 508), ('[j]', 'r', 'normalized', ['i', 'j'], 509)]
LDEs formed:0

ns -> [('[i]', 'r', 'normalized', ['i', 'j'], 502), ('[i]', 'r', 'normalized', ['i', 'j'], 503)]
LDEs formed:0

expected2 -> [('[i*LENGTH(xs)+j]', 'r', 'not normalized', ['i', 'j'], 507)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i < LENGTH(cases)  ++i
induction variable: ['i']
{
L508: (cases[i].n,r) (cases[i].rho,r) 
L509: (cases[i].x,r) (cases[i].y,r) 
L510: (cases[i].result,r) 
L511: (cases[i].n<<,r) 
L512: (cases[i].rho<<,r) 
L513: (cases[i].x<<,r) 
L514: (cases[i].y<<,r) 
}
array table
-----------------------------------------------
cases -> [('[i]', 'r', 'normalized', ['i'], 508), ('[i]', 'r', 'normalized', ['i'], 508), ('[i]', 'r', 'normalized', ['i'], 509), ('[i]', 'r', 'normalized', ['i'], 509), ('[i]', 'r', 'normalized', ['i'], 510), ('[i]', 'r', 'normalized', ['i'], 511), ('[i]', 'r', 'normalized', ['i'], 512), ('[i]', 'r', 'normalized', ['i'], 513), ('[i]', 'r', 'normalized', ['i'], 514)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/tqreigendecomposition.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i < diag.size()  ++i
induction variable: ['i']
{
L515: (ev[i],r) 
}
array table
-----------------------------------------------
ev -> [('[i]', 'r', 'normalized', ['i'], 515)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/marketmodel.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<todaysForwards.size()  ++i
induction variable: ['i']
{
L516: (todaysForwards[i]=,w) 
L517: (todaysForwards[i],r) 
}
array table
-----------------------------------------------
todaysForwards -> [('[i]', 'w', 'normalized', ['i'], 516), ('[i]', 'r', 'normalized', ['i'], 517)]
LDEs formed:2

distinct LDEs:
i1=i2
#########################################################################################
loop info: Size i=1  i<=N  ++i
induction variable: ['i']
{
L518: (coterminalAnnuity[N-1]=,w) (accruals[N-1]*,r) (todaysDiscounts[N],r) 
L519: (coterminalAnnuity[N-i]=,w) (coterminalAnnuity[N-i+1]+,r) 
L520: (accruals[N-i]*,r) (todaysDiscounts[N-i+1],r) 
L521: (todaysDiscounts[N-i]-,r) (todaysDiscounts[N],r) 
L522: (todaysCoterminalSwapRates[N-i]=,w) (coterminalAnnuity[N-i],r) 
}
array table
-----------------------------------------------
coterminalAnnuity -> [('[N-1]', 'w', 'not normalized', ['i'], 518), ('[N-i]', 'w', 'not normalized', ['i'], 519), ('[N-i+1]', 'r', 'not normalized', ['i'], 519), ('[N-i]', 'r', 'not normalized', ['i'], 522)]
LDEs formed:7

accruals -> [('[N-1]', 'r', 'not normalized', ['i'], 518), ('[N-i]', 'r', 'not normalized', ['i'], 520)]
LDEs formed:0

todaysCoterminalSwapRates -> [('[N-i]', 'w', 'not normalized', ['i'], 522)]
LDEs formed:1

todaysDiscounts -> [('[N]', 'r', 'not normalized', ['i'], 518), ('[N-i+1]', 'r', 'not normalized', ['i'], 520), ('[N-i]', 'r', 'not normalized', ['i'], 521), ('[N]', 'r', 'not normalized', ['i'], 521)]
LDEs formed:0

distinct LDEs:
N-1=N-1
N-1=N-i2+1
N-i1=N-i2
N-i1=N-i2+1
N-1=N-i2
#########################################################################################
loop info: Size i=0  i<std::min(LENGTH(mktVols),todaysForwards.size())  i++
induction variable: ['i']
{
L522: (volatilities[i]=,w) (todaysForwards[i]*,r) (mktVols[i]/,r) 
L523: (todaysForwards[i]+,r) 
L524: (blackVols[i]=,w) (mktVols[i],r) 
L525: (normalVols[i]=,w) (mktVols[i]*,r) (todaysForwards[i],r) 
}
array table
-----------------------------------------------
blackVols -> [('[i]', 'w', 'normalized', ['i'], 524)]
LDEs formed:1

volatilities -> [('[i]', 'w', 'normalized', ['i'], 522)]
LDEs formed:1

mktVols -> [('[i]', 'r', 'normalized', ['i'], 522), ('[i]', 'r', 'normalized', ['i'], 524), ('[i]', 'r', 'normalized', ['i'], 525)]
LDEs formed:0

todaysForwards -> [('[i]', 'r', 'normalized', ['i'], 522), ('[i]', 'r', 'normalized', ['i'], 523), ('[i]', 'r', 'normalized', ['i'], 525)]
LDEs formed:0

normalVols -> [('[i]', 'w', 'normalized', ['i'], 525)]
LDEs formed:1

distinct LDEs:
i1=i2
#########################################################################################
loop info: Size j=0  j<subProductExpectedValue->values.size()  ++j
induction variable: ['j']
{
L526: (results[currentResultIndex]-,r) (values[j],r) 
L527: (errors[currentResultIndex],r) 
}
array table
-----------------------------------------------
errors -> [('[currentResultIndex]', 'r', 'not normalized', ['j'], 527)]
LDEs formed:0

values -> [('[j]', 'r', 'normalized', ['j'], 526)]
LDEs formed:0

results -> [('[currentResultIndex]', 'r', 'not normalized', ['j'], 526)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size j=0  j<subProductExpectedValue->values.size()  ++j
induction variable: ['j']
{
L527: (results[currentResultIndex],r) 
L528: (values[j],r) 
L529: (errors[currentResultIndex],r) 
L530: (stdDevs[currentResultIndex],r) 
}
array table
-----------------------------------------------
stdDevs -> [('[currentResultIndex]', 'r', 'not normalized', ['j'], 530)]
LDEs formed:0

errors -> [('[currentResultIndex]', 'r', 'not normalized', ['j'], 529)]
LDEs formed:0

values -> [('[j]', 'r', 'normalized', ['j'], 528)]
LDEs formed:0

results -> [('[currentResultIndex]', 'r', 'not normalized', ['j'], 527)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<N  ++i
induction variable: ['i']
{
L528: (expectedForwards[i]=,w) (todaysForwards[i]-,r) (forwardStrikes[i],r) 
L529: (accruals[i]*,r) (todaysDiscounts[i+1],r) 
L530: (forwardStdDevs[i]=,w) (results[i]-,r) (expectedForwards[i],r) (errors[i],r) 
L531: (forwardStdDevs[i],r) 
L532: (forwardStdDevs[i],r) 
L533: (forwardStdDevs[i],r) 
L534: (forwardStdDevs[i],r) 
L535: (rateTimes[i],r) 
L536: (expectedCaplets[i]=,w) 
L537: (displacedPayoffs[i],r) 
L538: (todaysForwards[i]+,r) 
L539: (volatilities[i]*,r) 
L540: (todaysDiscounts[i+1]*,r) (accruals[i],r) 
L541: (capletStdDev[i]=,w) (results[i+N]-,r) (expectedCaplets[i],r) (errors[i+N],r) 
L542: (capletStdDev[i],r) 
L543: (capletStdDev[i],r) 
L544: (capletStdDev[i],r) 
L545: (capletStdDev[i],r) 
}
array table
-----------------------------------------------
volatilities -> [('[i]', 'r', 'normalized', ['i'], 539)]
LDEs formed:0

errors -> [('[i]', 'r', 'normalized', ['i'], 530), ('[i+N]', 'r', 'not normalized', ['i'], 541)]
LDEs formed:0

todaysForwards -> [('[i]', 'r', 'normalized', ['i'], 528), ('[i]', 'r', 'normalized', ['i'], 538)]
LDEs formed:0

displacedPayoffs -> [('[i]', 'r', 'normalized', ['i'], 537)]
LDEs formed:0

capletStdDev -> [('[i]', 'w', 'normalized', ['i'], 541), ('[i]', 'r', 'normalized', ['i'], 542), ('[i]', 'r', 'normalized', ['i'], 543), ('[i]', 'r', 'normalized', ['i'], 544), ('[i]', 'r', 'normalized', ['i'], 545)]
LDEs formed:5

todaysDiscounts -> [('[i+1]', 'r', 'normalized', ['i'], 529), ('[i+1]', 'r', 'normalized', ['i'], 540)]
LDEs formed:0

expectedForwards -> [('[i]', 'w', 'normalized', ['i'], 528), ('[i]', 'r', 'normalized', ['i'], 530)]
LDEs formed:2

results -> [('[i]', 'r', 'normalized', ['i'], 530), ('[i+N]', 'r', 'not normalized', ['i'], 541)]
LDEs formed:0

expectedCaplets -> [('[i]', 'w', 'normalized', ['i'], 536), ('[i]', 'r', 'normalized', ['i'], 541)]
LDEs formed:2

rateTimes -> [('[i]', 'r', 'normalized', ['i'], 535)]
LDEs formed:0

accruals -> [('[i]', 'r', 'normalized', ['i'], 529), ('[i]', 'r', 'normalized', ['i'], 540)]
LDEs formed:0

forwardStdDevs -> [('[i]', 'w', 'normalized', ['i'], 530), ('[i]', 'r', 'normalized', ['i'], 531), ('[i]', 'r', 'normalized', ['i'], 532), ('[i]', 'r', 'normalized', ['i'], 533), ('[i]', 'r', 'normalized', ['i'], 534)]
LDEs formed:5

forwardStrikes -> [('[i]', 'r', 'normalized', ['i'], 528)]
LDEs formed:0

distinct LDEs:
i1=i2
#########################################################################################
loop info: i=0  i<N  ++i
induction variable: ['i']
{
L529: (results[i],r) 
L530: (expectedForwards[i],r) 
L531: (errors[i],r) 
L532: (forwardStdDevs[i],r) 
}
array table
-----------------------------------------------
errors -> [('[i]', 'r', 'normalized', ['i'], 531)]
LDEs formed:0

forwardStdDevs -> [('[i]', 'r', 'normalized', ['i'], 532)]
LDEs formed:0

results -> [('[i]', 'r', 'normalized', ['i'], 529)]
LDEs formed:0

expectedForwards -> [('[i]', 'r', 'normalized', ['i'], 530)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: i=0  i<N  ++i
induction variable: ['i']
{
L531: (results[i+N],r) 
L532: (errors[i+N],r) 
L533: (expectedCaplets[i],r) 
L534: (errors[i+N],r) 
L535: (results[i+N]-,r) (expectedCaplets[i],r) (errors[i+N]==,r) 
L536: (errors[i+N],r) 
}
array table
-----------------------------------------------
expectedCaplets -> [('[i]', 'r', 'normalized', ['i'], 533), ('[i]', 'r', 'normalized', ['i'], 535)]
LDEs formed:0

errors -> [('[i+N]', 'r', 'not normalized', ['i'], 532), ('[i+N]', 'r', 'not normalized', ['i'], 534), ('[i+N]', 'r', 'not normalized', ['i'], 535), ('[i+N]', 'r', 'not normalized', ['i'], 536)]
LDEs formed:0

results -> [('[i+N]', 'r', 'not normalized', ['i'], 531), ('[i+N]', 'r', 'not normalized', ['i'], 535)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<N  ++i
induction variable: ['i']
{
L536: (expectedForwards[i]=,w) (todaysForwards[i]-,r) (forwardStrikes[i],r) 
L537: (accruals[i]*,r) (todaysDiscounts[i+1],r) 
L538: (forwardStdDevs[i]=,w) (results[i]-,r) (expectedForwards[i],r) (errors[i],r) 
L539: (forwardStdDevs[i],r) 
L540: (forwardStdDevs[i],r) 
L541: (forwardStdDevs[i],r) 
L542: (forwardStdDevs[i],r) 
L543: (rateTimes[i],r) 
L544: (expectedCaplets[i]=,w) 
L545: (displacedPayoffs[i],r) 
L546: (todaysForwards[i]+,r) 
L547: (normalVols[i]*,r) 
L548: (todaysDiscounts[i+1]*,r) (accruals[i],r) 
L549: (capletStdDev[i]=,w) (results[i+N]-,r) (expectedCaplets[i],r) (errors[i+N],r) 
L550: (capletStdDev[i],r) 
L551: (capletStdDev[i],r) 
L552: (capletStdDev[i],r) 
L553: (capletStdDev[i],r) 
}
array table
-----------------------------------------------
errors -> [('[i]', 'r', 'normalized', ['i'], 538), ('[i+N]', 'r', 'not normalized', ['i'], 549)]
LDEs formed:0

todaysForwards -> [('[i]', 'r', 'normalized', ['i'], 536), ('[i]', 'r', 'normalized', ['i'], 546)]
LDEs formed:0

displacedPayoffs -> [('[i]', 'r', 'normalized', ['i'], 545)]
LDEs formed:0

capletStdDev -> [('[i]', 'w', 'normalized', ['i'], 549), ('[i]', 'r', 'normalized', ['i'], 550), ('[i]', 'r', 'normalized', ['i'], 551), ('[i]', 'r', 'normalized', ['i'], 552), ('[i]', 'r', 'normalized', ['i'], 553)]
LDEs formed:5

todaysDiscounts -> [('[i+1]', 'r', 'normalized', ['i'], 537), ('[i+1]', 'r', 'normalized', ['i'], 548)]
LDEs formed:0

expectedForwards -> [('[i]', 'w', 'normalized', ['i'], 536), ('[i]', 'r', 'normalized', ['i'], 538)]
LDEs formed:2

results -> [('[i]', 'r', 'normalized', ['i'], 538), ('[i+N]', 'r', 'not normalized', ['i'], 549)]
LDEs formed:0

expectedCaplets -> [('[i]', 'w', 'normalized', ['i'], 544), ('[i]', 'r', 'normalized', ['i'], 549)]
LDEs formed:2

normalVols -> [('[i]', 'r', 'normalized', ['i'], 547)]
LDEs formed:0

rateTimes -> [('[i]', 'r', 'normalized', ['i'], 543)]
LDEs formed:0

accruals -> [('[i]', 'r', 'normalized', ['i'], 537), ('[i]', 'r', 'normalized', ['i'], 548)]
LDEs formed:0

forwardStdDevs -> [('[i]', 'w', 'normalized', ['i'], 538), ('[i]', 'r', 'normalized', ['i'], 539), ('[i]', 'r', 'normalized', ['i'], 540), ('[i]', 'r', 'normalized', ['i'], 541), ('[i]', 'r', 'normalized', ['i'], 542)]
LDEs formed:5

forwardStrikes -> [('[i]', 'r', 'normalized', ['i'], 536)]
LDEs formed:0

distinct LDEs:
i1=i2
#########################################################################################
loop info: i=0  i<N  ++i
induction variable: ['i']
{
L537: (results[i],r) 
L538: (errors[i],r) 
L539: (expectedForwards[i],r) 
L540: (forwardStdDevs[i],r) 
}
array table
-----------------------------------------------
errors -> [('[i]', 'r', 'normalized', ['i'], 538)]
LDEs formed:0

forwardStdDevs -> [('[i]', 'r', 'normalized', ['i'], 540)]
LDEs formed:0

results -> [('[i]', 'r', 'normalized', ['i'], 537)]
LDEs formed:0

expectedForwards -> [('[i]', 'r', 'normalized', ['i'], 539)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: i=0  i<N  ++i
induction variable: ['i']
{
L540: (results[i+N],r) 
L541: (errors[i+N],r) 
L542: (expectedCaplets[i],r) 
L543: (results[i+N]-,r) (expectedCaplets[i],r) (errors[i+N]==,r) 
L544: (errors[i+N],r) 
}
array table
-----------------------------------------------
expectedCaplets -> [('[i]', 'r', 'normalized', ['i'], 542), ('[i]', 'r', 'normalized', ['i'], 543)]
LDEs formed:0

errors -> [('[i+N]', 'r', 'not normalized', ['i'], 541), ('[i+N]', 'r', 'not normalized', ['i'], 543), ('[i+N]', 'r', 'not normalized', ['i'], 544)]
LDEs formed:0

results -> [('[i+N]', 'r', 'not normalized', ['i'], 540), ('[i+N]', 'r', 'not normalized', ['i'], 543)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<todaysForwards.size()  ++i
induction variable: ['i']
{
L544: (forwardStrikes[i]=,w) (todaysForwards[i]+,r) 
L545: (optionletPayoffs[i]=,w) 
L546: (todaysForwards[i],r) 
L547: (displacedPayoffs[i]=,w) 
L548: (todaysForwards[i]+,r) 
}
array table
-----------------------------------------------
displacedPayoffs -> [('[i]', 'w', 'normalized', ['i'], 547)]
LDEs formed:1

forwardStrikes -> [('[i]', 'w', 'normalized', ['i'], 544)]
LDEs formed:1

optionletPayoffs -> [('[i]', 'w', 'normalized', ['i'], 545)]
LDEs formed:1

todaysForwards -> [('[i]', 'r', 'normalized', ['i'], 544), ('[i]', 'r', 'normalized', ['i'], 546), ('[i]', 'r', 'normalized', ['i'], 548)]
LDEs formed:0

distinct LDEs:
i1=i2
#########################################################################################
loop info: Size j=0  j<LENGTH(marketModels)  j++
induction variable: ['j']
{
	loop info: Size m=0  m<LENGTH(testedFactors)  ++m
	induction variable: ['j', 'm']
	{
	L549: (testedFactors[m],r) 
		loop info: Size k=0  k<LENGTH(measures)  k++
		induction variable: ['j', 'm', 'k']
		{
		L550: (measures[k],r) 
		L551: (marketModels[j],r) 
			loop info: Size i=0  i<LENGTH(evolvers)-stop  i++
			induction variable: ['j', 'm', 'k', 'i']
			{
				loop info: Size n=0  n<1  n++
				induction variable: ['j', 'm', 'k', 'i', 'n']
				{
				L552: (evolvers[i],r) 
				L553: (marketModels[j],r) 
				L554: (measures[k],r) 
				L555: (evolvers[i],r) 
				}
 			}
 		}
 	}
 }
array table
-----------------------------------------------
testedFactors -> [('[m]', 'r', 'normalized', ['j', 'm', 'k', 'i', 'n'], 549)]
LDEs formed:0

marketModels -> [('[j]', 'r', 'normalized', ['j', 'm', 'k', 'i', 'n'], 551), ('[j]', 'r', 'normalized', ['j', 'm', 'k', 'i', 'n'], 553)]
LDEs formed:0

measures -> [('[k]', 'r', 'normalized', ['j', 'm', 'k', 'i', 'n'], 550), ('[k]', 'r', 'normalized', ['j', 'm', 'k', 'i', 'n'], 554)]
LDEs formed:0

evolvers -> [('[i]', 'r', 'normalized', ['j', 'm', 'k', 'i', 'n'], 552), ('[i]', 'r', 'normalized', ['j', 'm', 'k', 'i', 'n'], 555)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<todaysForwards.size()  ++i
induction variable: ['i']
{
L556: (forwardStrikes[i]=,w) (todaysForwards[i]+,r) 
L557: (optionletPayoffs[i]=,w) 
L558: (todaysForwards[i],r) 
L559: (displacedPayoffs[i]=,w) 
L560: (todaysForwards[i]+,r) 
}
array table
-----------------------------------------------
displacedPayoffs -> [('[i]', 'w', 'normalized', ['i'], 559)]
LDEs formed:1

forwardStrikes -> [('[i]', 'w', 'normalized', ['i'], 556)]
LDEs formed:1

optionletPayoffs -> [('[i]', 'w', 'normalized', ['i'], 557)]
LDEs formed:1

todaysForwards -> [('[i]', 'r', 'normalized', ['i'], 556), ('[i]', 'r', 'normalized', ['i'], 558), ('[i]', 'r', 'normalized', ['i'], 560)]
LDEs formed:0

distinct LDEs:
i1=i2
#########################################################################################
loop info: Size j=0  j<LENGTH(marketModels)  j++
induction variable: ['j']
{
	loop info: Size m=0  m<LENGTH(testedFactors)  ++m
	induction variable: ['j', 'm']
	{
	L561: (testedFactors[m],r) 
		loop info: Size k=0  k<LENGTH(measures)  k++
		induction variable: ['j', 'm', 'k']
		{
		L562: (measures[k],r) 
		L563: (marketModels[j],r) 
			loop info: Size i=0  i<LENGTH(evolvers)-stop  i++
			induction variable: ['j', 'm', 'k', 'i']
			{
				loop info: Size n=0  n<1  n++
				induction variable: ['j', 'm', 'k', 'i', 'n']
				{
				L564: (evolvers[i],r) 
				L565: (marketModels[j],r) 
				L566: (measures[k],r) 
				L567: (evolvers[i],r) 
				}
 			}
 		}
 	}
 }
array table
-----------------------------------------------
testedFactors -> [('[m]', 'r', 'normalized', ['j', 'm', 'k', 'i', 'n'], 561)]
LDEs formed:0

marketModels -> [('[j]', 'r', 'normalized', ['j', 'm', 'k', 'i', 'n'], 563), ('[j]', 'r', 'normalized', ['j', 'm', 'k', 'i', 'n'], 565)]
LDEs formed:0

measures -> [('[k]', 'r', 'normalized', ['j', 'm', 'k', 'i', 'n'], 562), ('[k]', 'r', 'normalized', ['j', 'm', 'k', 'i', 'n'], 566)]
LDEs formed:0

evolvers -> [('[i]', 'r', 'normalized', ['j', 'm', 'k', 'i', 'n'], 564), ('[i]', 'r', 'normalized', ['j', 'm', 'k', 'i', 'n'], 567)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size j=0  j<LENGTH(marketModels)  j++
induction variable: ['j']
{
	loop info: Size m=0  m<LENGTH(testedFactors)  ++m
	induction variable: ['j', 'm']
	{
	L568: (testedFactors[m],r) 
		loop info: Size k=0  k<LENGTH(measures)  k++
		induction variable: ['j', 'm', 'k']
		{
		L569: (measures[k],r) 
		L570: (marketModels[j],r) 
			loop info: Size i=0  i<LENGTH(evolvers)  i++
			induction variable: ['j', 'm', 'k', 'i']
			{
			L571: (evolvers[i],r) 
			L572: (marketModels[j],r) 
			L573: (measures[k],r) 
			L574: (evolvers[i],r) 
				loop info: Size i=0  i <  accruals.size()  ++i
				induction variable: ['j', 'm', 'k', 'i']
				{
				}
				loop info: Size i=0  i < accruals.size()  ++i
				induction variable: ['j', 'm', 'k', 'i']
				{
				L575: (floatingAccruals[i]*,r) (todaysForwards[i]+,r) (floatingSpreads[i],r) (todaysDiscounts[i+1],r) 
				L576: (fixedAccruals[i]*,r) (todaysDiscounts[i+1]*,r) 
				L577: (fixedStrikes[i]/,r) 
				L578: (todaysForwards[i],r) 
				L579: (modelVolatilities[i],r) 
				}
 			}
 		}
 	}
 }
array table
-----------------------------------------------
fixedAccruals -> [('[i]', 'r', 'normalized', ['j', 'm', 'k', 'i'], 576)]
LDEs formed:0

todaysForwards -> [('[i]', 'r', 'normalized', ['j', 'm', 'k', 'i'], 575), ('[i]', 'r', 'normalized', ['j', 'm', 'k', 'i'], 578)]
LDEs formed:0

modelVolatilities -> [('[i]', 'r', 'normalized', ['j', 'm', 'k', 'i'], 579)]
LDEs formed:0

testedFactors -> [('[m]', 'r', 'normalized', ['j', 'm', 'k', 'i'], 568)]
LDEs formed:0

measures -> [('[k]', 'r', 'normalized', ['j', 'm', 'k', 'i'], 569), ('[k]', 'r', 'normalized', ['j', 'm', 'k', 'i'], 573)]
LDEs formed:0

floatingAccruals -> [('[i]', 'r', 'normalized', ['j', 'm', 'k', 'i'], 575)]
LDEs formed:0

todaysDiscounts -> [('[i+1]', 'r', 'normalized', ['j', 'm', 'k', 'i'], 575), ('[i+1]', 'r', 'normalized', ['j', 'm', 'k', 'i'], 576)]
LDEs formed:0

evolvers -> [('[i]', 'r', 'normalized', ['j', 'm', 'k', 'i'], 571), ('[i]', 'r', 'normalized', ['j', 'm', 'k', 'i'], 574)]
LDEs formed:0

floatingSpreads -> [('[i]', 'r', 'normalized', ['j', 'm', 'k', 'i'], 575)]
LDEs formed:0

marketModels -> [('[j]', 'r', 'normalized', ['j', 'm', 'k', 'i'], 570), ('[j]', 'r', 'normalized', ['j', 'm', 'k', 'i'], 572)]
LDEs formed:0

fixedStrikes -> [('[i]', 'r', 'normalized', ['j', 'm', 'k', 'i'], 577)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size j=0  j<LENGTH(marketModels)  j++
induction variable: ['j']
{
	loop info: Size m=0  m<LENGTH(testedFactors)  ++m
	induction variable: ['j', 'm']
	{
	L578: (testedFactors[m],r) 
		loop info: Size k=0  k<LENGTH(measures)  k++
		induction variable: ['j', 'm', 'k']
		{
		L579: (measures[k],r) 
		L580: (marketModels[j],r) 
			loop info: Size i=0  i<LENGTH(evolvers)-stop  i++
			induction variable: ['j', 'm', 'k', 'i']
			{
				loop info: Size n=0  n<1  n++
				induction variable: ['j', 'm', 'k', 'i', 'n']
				{
				L581: (evolvers[i],r) 
				L582: (marketModels[j],r) 
				L583: (measures[k],r) 
				L584: (evolvers[i],r) 
				}
 			}
 		}
 	}
 }
array table
-----------------------------------------------
testedFactors -> [('[m]', 'r', 'normalized', ['j', 'm', 'k', 'i', 'n'], 578)]
LDEs formed:0

marketModels -> [('[j]', 'r', 'normalized', ['j', 'm', 'k', 'i', 'n'], 580), ('[j]', 'r', 'normalized', ['j', 'm', 'k', 'i', 'n'], 582)]
LDEs formed:0

measures -> [('[k]', 'r', 'normalized', ['j', 'm', 'k', 'i', 'n'], 579), ('[k]', 'r', 'normalized', ['j', 'm', 'k', 'i', 'n'], 583)]
LDEs formed:0

evolvers -> [('[i]', 'r', 'normalized', ['j', 'm', 'k', 'i', 'n'], 581), ('[i]', 'r', 'normalized', ['j', 'm', 'k', 'i', 'n'], 584)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<todaysForwards.size()  ++i
induction variable: ['i']
{
L585: (todaysForwards[i]-,r) (forwardStrikes[i],r) 
L586: (accruals[i]*,r) (todaysDiscounts[i+1],r) 
}
array table
-----------------------------------------------
forwardStrikes -> [('[i]', 'r', 'normalized', ['i'], 585)]
LDEs formed:0

accruals -> [('[i]', 'r', 'normalized', ['i'], 586)]
LDEs formed:0

todaysForwards -> [('[i]', 'r', 'normalized', ['i'], 585)]
LDEs formed:0

todaysDiscounts -> [('[i+1]', 'r', 'normalized', ['i'], 586)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<todaysForwards.size()  ++i
induction variable: ['i']
{
L587: (optionletPayoffs[i]=,w) 
L588: (todaysForwards[i],r) 
L589: (todaysForwards[i],r) 
L590: (displacedPayoffs[i]=,w) 
L591: (todaysForwards[i]+,r) 
L592: (todaysForwards[i]+,r) 
}
array table
-----------------------------------------------
displacedPayoffs -> [('[i]', 'w', 'normalized', ['i'], 590)]
LDEs formed:1

todaysForwards -> [('[i]', 'r', 'normalized', ['i'], 588), ('[i]', 'r', 'normalized', ['i'], 589), ('[i]', 'r', 'normalized', ['i'], 591), ('[i]', 'r', 'normalized', ['i'], 592)]
LDEs formed:0

optionletPayoffs -> [('[i]', 'w', 'normalized', ['i'], 587)]
LDEs formed:1

distinct LDEs:
i1=i2
#########################################################################################
loop info: Size i=0  i<todaysForwards.size()  ++i
induction variable: ['i']
{
L588: (displacedPayoffs[i],r) 
L589: (todaysForwards[i]+,r) 
L590: (volatilities[i]*,r) (rateTimes[i],r) 
L591: (todaysDiscounts[i+1]*,r) (accruals[i],r) 
}
array table
-----------------------------------------------
volatilities -> [('[i]', 'r', 'normalized', ['i'], 590)]
LDEs formed:0

todaysForwards -> [('[i]', 'r', 'normalized', ['i'], 589)]
LDEs formed:0

todaysDiscounts -> [('[i+1]', 'r', 'normalized', ['i'], 591)]
LDEs formed:0

displacedPayoffs -> [('[i]', 'r', 'normalized', ['i'], 588)]
LDEs formed:0

rateTimes -> [('[i]', 'r', 'normalized', ['i'], 590)]
LDEs formed:0

accruals -> [('[i]', 'r', 'normalized', ['i'], 591)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<todaysForwards.size()  ++i
induction variable: ['i']
{
L592: (todaysForwards[i]-,r) 
L593: (accruals[i]*,r) (todaysDiscounts[i+1],r) 
}
array table
-----------------------------------------------
accruals -> [('[i]', 'r', 'normalized', ['i'], 593)]
LDEs formed:0

todaysDiscounts -> [('[i+1]', 'r', 'normalized', ['i'], 593)]
LDEs formed:0

todaysForwards -> [('[i]', 'r', 'normalized', ['i'], 592)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<todaysForwards.size()  ++i
induction variable: ['i']
{
L593: (atmRates[i]-,r) 
}
array table
-----------------------------------------------
atmRates -> [('[i]', 'r', 'normalized', ['i'], 593)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<todaysForwards.size()  ++i
induction variable: ['i']
{
L594: (todaysForwards[i]+,r) 
L595: (todaysCoterminalSwapRates[i]+,r) 
L596: (cotSwapsCovariance[i][i],r) 
L597: (todaysDiscounts[0],r) 
}
array table
-----------------------------------------------
todaysCoterminalSwapRates -> [('[i]', 'r', 'normalized', ['i'], 595)]
LDEs formed:0

todaysDiscounts -> [('[0]', 'r', 'normalized', ['i'], 597)]
LDEs formed:0

todaysForwards -> [('[i]', 'r', 'normalized', ['i'], 594)]
LDEs formed:0

cotSwapsCovariance -> [('[i][i]', 'r', 'normalized', ['i'], 596)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<numberBigRates  ++i
induction variable: ['i']
{
L597: (optionletPayoffs[i]=,w) 
L598: (swaptionPayoffs[i]=,w) 
L599: (displacedOptionletPayoffs[i]=,w) 
L600: (displacedSwaptionPayoffs[i]=,w) 
}
array table
-----------------------------------------------
displacedSwaptionPayoffs -> [('[i]', 'w', 'normalized', ['i'], 600)]
LDEs formed:1

swaptionPayoffs -> [('[i]', 'w', 'normalized', ['i'], 598)]
LDEs formed:1

displacedOptionletPayoffs -> [('[i]', 'w', 'normalized', ['i'], 599)]
LDEs formed:1

optionletPayoffs -> [('[i]', 'w', 'normalized', ['i'], 597)]
LDEs formed:1

distinct LDEs:
i1=i2
#########################################################################################
loop info: Size j=0  j < adaptedSwapModel->numberOfRates()  ++j
induction variable: ['j']
{
L598: (adaptedForwardSds[j]=,w) (finalForwardCovariances[j][j],r) 
L599: (adaptedSwapSds[j]=,w) (finalSwapCovariances[j][j],r) 
L600: (todaysDiscounts[0]*,r) 
L601: (approxCapletPrices[j]=,w) (displacedOptionletPayoffs[j],r) 
L602: (adaptedForwardSds[j],r) 
L603: (todaysDiscounts[0],r) 
L604: (approxSwaptionPrices[j]=,w) (displacedSwaptionPayoffs[j],r) 
L605: (adaptedSwapSds[j],r) 
}
array table
-----------------------------------------------
displacedOptionletPayoffs -> [('[j]', 'r', 'normalized', ['j'], 601)]
LDEs formed:0

adaptedSwapSds -> [('[j]', 'w', 'normalized', ['j'], 599), ('[j]', 'r', 'normalized', ['j'], 605)]
LDEs formed:2

approxSwaptionPrices -> [('[j]', 'w', 'normalized', ['j'], 604)]
LDEs formed:1

adaptedForwardSds -> [('[j]', 'w', 'normalized', ['j'], 598), ('[j]', 'r', 'normalized', ['j'], 602)]
LDEs formed:2

finalForwardCovariances -> [('[j][j]', 'r', 'normalized', ['j'], 598)]
LDEs formed:0

todaysDiscounts -> [('[0]', 'r', 'normalized', ['j'], 600), ('[0]', 'r', 'normalized', ['j'], 603)]
LDEs formed:0

displacedSwaptionPayoffs -> [('[j]', 'r', 'normalized', ['j'], 604)]
LDEs formed:0

approxCapletPrices -> [('[j]', 'w', 'normalized', ['j'], 601)]
LDEs formed:1

finalSwapCovariances -> [('[j][j]', 'r', 'normalized', ['j'], 599)]
LDEs formed:0

distinct LDEs:
j1=j2
#########################################################################################
loop info: Size i=0  i < numberBigRates  ++i
induction variable: ['i']
{
L600: (capletErrorsInSds[i]=,w) (results[i]-,r) (approxCapletPrices[i],r) (errors[i],r) 
L601: (swaptionErrorsInSds[i]=,w) (results[i+numberBigRates]-,r) (approxSwaptionPrices[i],r) (errors[i+numberBigRates],r) 
}
array table
-----------------------------------------------
errors -> [('[i]', 'r', 'normalized', ['i'], 600), ('[i+numberBigRates]', 'r', 'not normalized', ['i'], 601)]
LDEs formed:0

capletErrorsInSds -> [('[i]', 'w', 'normalized', ['i'], 600)]
LDEs formed:1

swaptionErrorsInSds -> [('[i]', 'w', 'normalized', ['i'], 601)]
LDEs formed:1

approxSwaptionPrices -> [('[i]', 'r', 'normalized', ['i'], 601)]
LDEs formed:0

results -> [('[i]', 'r', 'normalized', ['i'], 600), ('[i+numberBigRates]', 'r', 'not normalized', ['i'], 601)]
LDEs formed:0

approxCapletPrices -> [('[i]', 'r', 'normalized', ['i'], 600)]
LDEs formed:0

distinct LDEs:
i1=i2
#########################################################################################
loop info: Size i=0  i < numberBigRates  ++i
induction variable: ['i']
{
L601: (capletErrorsInSds[i],r) 
L602: (approxCapletPrices[i]<<,r) 
L603: (results[i]<<,r) 
L604: (capletErrorsInSds[i],r) 
}
array table
-----------------------------------------------
capletErrorsInSds -> [('[i]', 'r', 'normalized', ['i'], 601), ('[i]', 'r', 'normalized', ['i'], 604)]
LDEs formed:0

results -> [('[i]', 'r', 'normalized', ['i'], 603)]
LDEs formed:0

approxCapletPrices -> [('[i]', 'r', 'normalized', ['i'], 602)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i < numberBigRates  ++i
induction variable: ['i']
{
L603: (swaptionErrorsInSds[i],r) 
L604: (approxSwaptionPrices[i]<<,r) 
L605: (results[i+numberBigRates]<<,r) 
L606: (swaptionErrorsInSds[i],r) 
}
array table
-----------------------------------------------
approxSwaptionPrices -> [('[i]', 'r', 'normalized', ['i'], 604)]
LDEs formed:0

results -> [('[i+numberBigRates]', 'r', 'not normalized', ['i'], 605)]
LDEs formed:0

swaptionErrorsInSds -> [('[i]', 'r', 'normalized', ['i'], 603), ('[i]', 'r', 'normalized', ['i'], 606)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size j=0  j<LENGTH(marketModels)  j++
induction variable: ['j']
{
	loop info: Size m=0  m<LENGTH(testedFactors)  ++m
	induction variable: ['j', 'm']
	{
	L607: (testedFactors[m],r) 
		loop info: Size k=0  k<LENGTH(measures)  k++
		induction variable: ['j', 'm', 'k']
		{
		L608: (measures[k],r) 
		L609: (marketModels[j],r) 
			loop info: Size i=0  i<LENGTH(evolvers)-stop  i++
			induction variable: ['j', 'm', 'k', 'i']
			{
				loop info: Size n=0  n<1  n++
				induction variable: ['j', 'm', 'k', 'i', 'n']
				{
				L610: (evolvers[i],r) 
				L611: (marketModels[j],r) 
				L612: (measures[k],r) 
				L613: (evolvers[i],r) 
				L614: (evolvers[i],r) 
					loop info: Size s=0  s < isExerciseTime.size()  ++s
					induction variable: ['j', 'm', 'k', 'i', 'n', 's']
					{
					L615: (isExerciseTime[s],r) 
					L616: (evolvers[i],r) 
					}
				L617: (todaysDiscounts[initialNumeraire],r) 
				}
 			}
 		}
 	}
 }
array table
-----------------------------------------------
isExerciseTime -> [('[s]', 'r', 'normalized', ['j', 'm', 'k', 'i', 'n', 's'], 615)]
LDEs formed:0

testedFactors -> [('[m]', 'r', 'normalized', ['j', 'm', 'k', 'i', 'n', 's'], 607)]
LDEs formed:0

measures -> [('[k]', 'r', 'normalized', ['j', 'm', 'k', 'i', 'n', 's'], 608), ('[k]', 'r', 'normalized', ['j', 'm', 'k', 'i', 'n', 's'], 612)]
LDEs formed:0

todaysDiscounts -> [('[initialNumeraire]', 'r', 'not normalized', ['j', 'm', 'k', 'i', 'n', 's'], 617)]
LDEs formed:0

evolvers -> [('[i]', 'r', 'normalized', ['j', 'm', 'k', 'i', 'n', 's'], 610), ('[i]', 'r', 'normalized', ['j', 'm', 'k', 'i', 'n', 's'], 613), ('[i]', 'r', 'normalized', ['j', 'm', 'k', 'i', 'n', 's'], 614), ('[i]', 'r', 'normalized', ['j', 'm', 'k', 'i', 'n', 's'], 616)]
LDEs formed:0

marketModels -> [('[j]', 'r', 'normalized', ['j', 'm', 'k', 'i', 'n', 's'], 609), ('[j]', 'r', 'normalized', ['j', 'm', 'k', 'i', 'n', 's'], 611)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size j=0  j<LENGTH(marketModels)  j++
induction variable: ['j']
{
	loop info: Size m=0  m<LENGTH(testedFactors)  ++m
	induction variable: ['j', 'm']
	{
	L612: (testedFactors[m],r) 
		loop info: Size k=0  k<LENGTH(measures)  k++
		induction variable: ['j', 'm', 'k']
		{
		L613: (measures[k],r) 
		L614: (marketModels[j],r) 
			loop info: Size i=0  i<LENGTH(evolvers)-stop  i++
			induction variable: ['j', 'm', 'k', 'i']
			{
				loop info: Size n=0  n<1  n++
				induction variable: ['j', 'm', 'k', 'i', 'n']
				{
				L615: (evolvers[i],r) 
				L616: (marketModels[j],r) 
				L617: (measures[k],r) 
				L618: (evolvers[i],r) 
				L619: (evolvers[i],r) 
					loop info: Size s=0  s < isExerciseTime.size()  ++s
					induction variable: ['j', 'm', 'k', 'i', 'n', 's']
					{
					L620: (isExerciseTime[s],r) 
					L621: (evolvers[i],r) 
					}
				L622: (todaysDiscounts[initialNumeraire],r) 
				}
 			}
 		}
 	}
 }
array table
-----------------------------------------------
isExerciseTime -> [('[s]', 'r', 'normalized', ['j', 'm', 'k', 'i', 'n', 's'], 620)]
LDEs formed:0

testedFactors -> [('[m]', 'r', 'normalized', ['j', 'm', 'k', 'i', 'n', 's'], 612)]
LDEs formed:0

measures -> [('[k]', 'r', 'normalized', ['j', 'm', 'k', 'i', 'n', 's'], 613), ('[k]', 'r', 'normalized', ['j', 'm', 'k', 'i', 'n', 's'], 617)]
LDEs formed:0

todaysDiscounts -> [('[initialNumeraire]', 'r', 'not normalized', ['j', 'm', 'k', 'i', 'n', 's'], 622)]
LDEs formed:0

evolvers -> [('[i]', 'r', 'normalized', ['j', 'm', 'k', 'i', 'n', 's'], 615), ('[i]', 'r', 'normalized', ['j', 'm', 'k', 'i', 'n', 's'], 618), ('[i]', 'r', 'normalized', ['j', 'm', 'k', 'i', 'n', 's'], 619), ('[i]', 'r', 'normalized', ['j', 'm', 'k', 'i', 'n', 's'], 621)]
LDEs formed:0

marketModels -> [('[j]', 'r', 'normalized', ['j', 'm', 'k', 'i', 'n', 's'], 614), ('[j]', 'r', 'normalized', ['j', 'm', 'k', 'i', 'n', 's'], 616)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size j=0  j<LENGTH(marketModels)  j++
induction variable: ['j']
{
	loop info: Size m=0  m<LENGTH(testedFactors)  ++m
	induction variable: ['j', 'm']
	{
	L617: (testedFactors[m],r) 
		loop info: Size k=0  k<LENGTH(measures)  k++
		induction variable: ['j', 'm', 'k']
		{
		L618: (measures[k],r) 
		L619: (marketModels[j],r) 
			loop info: Size i=0  i<LENGTH(evolvers)-stop  i++
			induction variable: ['j', 'm', 'k', 'i']
			{
				loop info: Size n=0  n<1  n++
				induction variable: ['j', 'm', 'k', 'i', 'n']
				{
				L620: (evolvers[i],r) 
				L621: (marketModels[j],r) 
				L622: (measures[k],r) 
				L623: (evolvers[i],r) 
				L624: (todaysDiscounts[initialNumeraire],r) 
				L625: (evolvers[i],r) 
					loop info: Size s=0  s < isExerciseTime.size()  ++s
					induction variable: ['j', 'm', 'k', 'i', 'n', 's']
					{
					L626: (isExerciseTime[s],r) 
					L627: (evolvers[i],r) 
					}
 				}
 			}
 		}
 	}
 }
array table
-----------------------------------------------
isExerciseTime -> [('[s]', 'r', 'normalized', ['j', 'm', 'k', 'i', 'n', 's'], 626)]
LDEs formed:0

testedFactors -> [('[m]', 'r', 'normalized', ['j', 'm', 'k', 'i', 'n', 's'], 617)]
LDEs formed:0

measures -> [('[k]', 'r', 'normalized', ['j', 'm', 'k', 'i', 'n', 's'], 618), ('[k]', 'r', 'normalized', ['j', 'm', 'k', 'i', 'n', 's'], 622)]
LDEs formed:0

todaysDiscounts -> [('[initialNumeraire]', 'r', 'not normalized', ['j', 'm', 'k', 'i', 'n', 's'], 624)]
LDEs formed:0

evolvers -> [('[i]', 'r', 'normalized', ['j', 'm', 'k', 'i', 'n', 's'], 620), ('[i]', 'r', 'normalized', ['j', 'm', 'k', 'i', 'n', 's'], 623), ('[i]', 'r', 'normalized', ['j', 'm', 'k', 'i', 'n', 's'], 625), ('[i]', 'r', 'normalized', ['j', 'm', 'k', 'i', 'n', 's'], 627)]
LDEs formed:0

marketModels -> [('[j]', 'r', 'normalized', ['j', 'm', 'k', 'i', 'n', 's'], 619), ('[j]', 'r', 'normalized', ['j', 'm', 'k', 'i', 'n', 's'], 621)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<todaysForwards.size()  ++i
induction variable: ['i']
{
L622: (payoffs[i]=,w) 
L623: (todaysForwards[i],r) 
L624: (todaysForwards[i],r) 
L625: (displacedPayoffs[i]=,w) 
L626: (todaysForwards[i]+,r) 
L627: (todaysForwards[i]+,r) 
}
array table
-----------------------------------------------
displacedPayoffs -> [('[i]', 'w', 'normalized', ['i'], 625)]
LDEs formed:1

todaysForwards -> [('[i]', 'r', 'normalized', ['i'], 623), ('[i]', 'r', 'normalized', ['i'], 624), ('[i]', 'r', 'normalized', ['i'], 626), ('[i]', 'r', 'normalized', ['i'], 627)]
LDEs formed:0

payoffs -> [('[i]', 'w', 'normalized', ['i'], 622)]
LDEs formed:1

distinct LDEs:
i1=i2
#########################################################################################
loop info: Size j=0  j<LENGTH(marketModels)  j++
induction variable: ['j']
{
	loop info: Size m=0  m<LENGTH(testedFactors)  ++m
	induction variable: ['j', 'm']
	{
	L623: (testedFactors[m],r) 
		loop info: Size k=0  k<LENGTH(measures)  k++
		induction variable: ['j', 'm', 'k']
		{
		L624: (measures[k],r) 
			loop info: Size n=0  n<1  n++
			induction variable: ['j', 'm', 'k', 'n']
			{
			L625: (marketModels[j],r) 
				loop info: Size i=0  i<evolution.evolutionTimes().size()  ++i
				induction variable: ['j', 'm', 'k', 'n', 'i']
				{
				}
			L626: (marketModels[j],r) 
			L627: (marketModels[j],r) 
			L628: (deltaGammaWeights[0][0]=,w) 
			L629: (deltaGammaWeights[0][1]=,w) 
			L630: (deltaGammaWeights[0][2]=,w) 
			L631: (deltaGammaWeights[1][0]=,w) 
			L632: (deltaGammaWeights[1][1]=,w) 
			L633: (deltaGammaWeights[1][2]=,w) 
			L634: (marketModels[j],r) 
			L635: (marketModels[j],r) 
			L636: (vegaWeights[0][0]=,w) 
			L637: (vegaWeights[0][1]=,w) 
			L638: (vegaWeights[0][2]=,w) 
			L639: (marketModels[j],r) 
			L640: (measures[k],r) 
			L641: (todaysDiscounts[initialNumeraire],r) 
			L642: (greekStats[0][0].mean,r) 
			L643: (greekStats[0][0].errorEstimate,r) 
			L644: (greekStats[0][1].mean,r) 
			L645: (greekStats[0][1].errorEstimate,r) 
			L646: (greekStats[1][0].mean,r) 
			L647: (greekStats[1][0].errorEstimate,r) 
			L648: (todaysDiscounts[0],r) 
			L649: (todaysDiscounts[0],r) 
				loop info: Size i=0  i<todaysForwards.size()  ++i
				induction variable: ['j', 'm', 'k', 'n', 'i']
				{
				L650: (rateTimes[i+1]-,r) (rateTimes[i],r) 
				L651: (fwdPlus[i]=,w) (todaysForwards[i]+,r) 
				L652: (fwdMinus[i]=,w) (todaysForwards[i]-,r) 
				L653: (discPlus[i+1]=,w) (discPlus[i]/,r) (fwdPlus[i]*,r) 
				L654: (discMinus[i+1]=,w) (discMinus[i]/,r) (fwdMinus[i]*,r) 
				L655: (pricePlus[i]=,w) (displacedPayoffs[i],r) (fwdPlus[i],r) 
				L656: (volatilities[i]*,r) (rateTimes[i],r) 
				L657: (discPlus[i+1]*,r) 
				L658: (price0[i]=,w) (displacedPayoffs[i],r) (todaysForwards[i],r) 
				L659: (volatilities[i]*,r) (rateTimes[i],r) 
				L660: (todaysDiscounts[i+1]*,r) 
				L661: (priceMinus[i]=,w) (displacedPayoffs[i],r) (fwdMinus[i],r) 
				L662: (volatilities[i]*,r) (rateTimes[i],r) 
				L663: (discMinus[i+1]*,r) 
				}
				loop info: Size i=0  i<product.numberOfProducts()  ++i
				induction variable: ['j', 'm', 'k', 'n', 'i']
				{
				L664: (pricePlus[i]-,r) (priceMinus[i],r) 
				L665: (pricePlus[i]-,r) (price0[i]+,r) (priceMinus[i],r) 
				L666: (price0[i]<<,r) 
				L667: (values[i],r) 
				L668: (errors[i],r) 
				L669: (values[i]-,r) (price0[i],r) (errors[i]<<,r) 
				L670: (deltas[i],r) 
				L671: (deltaErrors[i],r) 
				L672: (deltas[i]-,r) (deltaErrors[i]<<,r) 
				L673: (gammas[i],r) 
				L674: (gammaErrors[i],r) 
				L675: (gammas[i]-,r) (gammaErrors[i]<<,r) 
				L676: (vegas[i],r) 
				L677: (vegaErrors[i],r) 
				}
 			}
 		}
 	}
 }
array table
-----------------------------------------------
deltas -> [('[i]', 'r', 'normalized', ['j', 'm', 'k', 'n', 'i'], 670), ('[i]', 'r', 'normalized', ['j', 'm', 'k', 'n', 'i'], 672)]
LDEs formed:0

volatilities -> [('[i]', 'r', 'normalized', ['j', 'm', 'k', 'n', 'i'], 656), ('[i]', 'r', 'normalized', ['j', 'm', 'k', 'n', 'i'], 659), ('[i]', 'r', 'normalized', ['j', 'm', 'k', 'n', 'i'], 662)]
LDEs formed:0

deltaErrors -> [('[i]', 'r', 'normalized', ['j', 'm', 'k', 'n', 'i'], 671), ('[i]', 'r', 'normalized', ['j', 'm', 'k', 'n', 'i'], 672)]
LDEs formed:0

fwdPlus -> [('[i]', 'w', 'normalized', ['j', 'm', 'k', 'n', 'i'], 651), ('[i]', 'r', 'normalized', ['j', 'm', 'k', 'n', 'i'], 653), ('[i]', 'r', 'normalized', ['j', 'm', 'k', 'n', 'i'], 655)]
LDEs formed:3

pricePlus -> [('[i]', 'w', 'normalized', ['j', 'm', 'k', 'n', 'i'], 655), ('[i]', 'r', 'normalized', ['j', 'm', 'k', 'n', 'i'], 664), ('[i]', 'r', 'normalized', ['j', 'm', 'k', 'n', 'i'], 665)]
LDEs formed:3

deltaGammaWeights -> [('[0][0]', 'w', 'normalized', ['j', 'm', 'k', 'n', 'i'], 628), ('[0][1]', 'w', 'normalized', ['j', 'm', 'k', 'n', 'i'], 629), ('[0][2]', 'w', 'normalized', ['j', 'm', 'k', 'n', 'i'], 630), ('[1][0]', 'w', 'normalized', ['j', 'm', 'k', 'n', 'i'], 631), ('[1][1]', 'w', 'normalized', ['j', 'm', 'k', 'n', 'i'], 632), ('[1][2]', 'w', 'normalized', ['j', 'm', 'k', 'n', 'i'], 633)]
LDEs formed:42

rateTimes -> [('[i+1]', 'r', 'normalized', ['j', 'm', 'k', 'n', 'i'], 650), ('[i]', 'r', 'normalized', ['j', 'm', 'k', 'n', 'i'], 650), ('[i]', 'r', 'normalized', ['j', 'm', 'k', 'n', 'i'], 656), ('[i]', 'r', 'normalized', ['j', 'm', 'k', 'n', 'i'], 659), ('[i]', 'r', 'normalized', ['j', 'm', 'k', 'n', 'i'], 662)]
LDEs formed:0

price0 -> [('[i]', 'w', 'normalized', ['j', 'm', 'k', 'n', 'i'], 658), ('[i]', 'r', 'normalized', ['j', 'm', 'k', 'n', 'i'], 665), ('[i]', 'r', 'normalized', ['j', 'm', 'k', 'n', 'i'], 666), ('[i]', 'r', 'normalized', ['j', 'm', 'k', 'n', 'i'], 669)]
LDEs formed:4

discPlus -> [('[i+1]', 'w', 'normalized', ['j', 'm', 'k', 'n', 'i'], 653), ('[i]', 'r', 'normalized', ['j', 'm', 'k', 'n', 'i'], 653), ('[i+1]', 'r', 'normalized', ['j', 'm', 'k', 'n', 'i'], 657)]
LDEs formed:3

errors -> [('[i]', 'r', 'normalized', ['j', 'm', 'k', 'n', 'i'], 668), ('[i]', 'r', 'normalized', ['j', 'm', 'k', 'n', 'i'], 669)]
LDEs formed:0

greekStats -> [('[0][0]', 'r', 'normalized', ['j', 'm', 'k', 'n', 'i'], 642), ('[0][0]', 'r', 'normalized', ['j', 'm', 'k', 'n', 'i'], 643), ('[0][1]', 'r', 'normalized', ['j', 'm', 'k', 'n', 'i'], 644), ('[0][1]', 'r', 'normalized', ['j', 'm', 'k', 'n', 'i'], 645), ('[1][0]', 'r', 'normalized', ['j', 'm', 'k', 'n', 'i'], 646), ('[1][0]', 'r', 'normalized', ['j', 'm', 'k', 'n', 'i'], 647)]
LDEs formed:0

testedFactors -> [('[m]', 'r', 'normalized', ['j', 'm', 'k', 'n', 'i'], 623)]
LDEs formed:0

displacedPayoffs -> [('[i]', 'r', 'normalized', ['j', 'm', 'k', 'n', 'i'], 655), ('[i]', 'r', 'normalized', ['j', 'm', 'k', 'n', 'i'], 658), ('[i]', 'r', 'normalized', ['j', 'm', 'k', 'n', 'i'], 661)]
LDEs formed:0

vegaWeights -> [('[0][0]', 'w', 'normalized', ['j', 'm', 'k', 'n', 'i'], 636), ('[0][1]', 'w', 'normalized', ['j', 'm', 'k', 'n', 'i'], 637), ('[0][2]', 'w', 'normalized', ['j', 'm', 'k', 'n', 'i'], 638)]
LDEs formed:12

gammas -> [('[i]', 'r', 'normalized', ['j', 'm', 'k', 'n', 'i'], 673), ('[i]', 'r', 'normalized', ['j', 'm', 'k', 'n', 'i'], 675)]
LDEs formed:0

priceMinus -> [('[i]', 'w', 'normalized', ['j', 'm', 'k', 'n', 'i'], 661), ('[i]', 'r', 'normalized', ['j', 'm', 'k', 'n', 'i'], 664), ('[i]', 'r', 'normalized', ['j', 'm', 'k', 'n', 'i'], 665)]
LDEs formed:3

measures -> [('[k]', 'r', 'normalized', ['j', 'm', 'k', 'n', 'i'], 624), ('[k]', 'r', 'normalized', ['j', 'm', 'k', 'n', 'i'], 640)]
LDEs formed:0

gammaErrors -> [('[i]', 'r', 'normalized', ['j', 'm', 'k', 'n', 'i'], 674), ('[i]', 'r', 'normalized', ['j', 'm', 'k', 'n', 'i'], 675)]
LDEs formed:0

vegas -> [('[i]', 'r', 'normalized', ['j', 'm', 'k', 'n', 'i'], 676)]
LDEs formed:0

todaysForwards -> [('[i]', 'r', 'normalized', ['j', 'm', 'k', 'n', 'i'], 651), ('[i]', 'r', 'normalized', ['j', 'm', 'k', 'n', 'i'], 652), ('[i]', 'r', 'normalized', ['j', 'm', 'k', 'n', 'i'], 658)]
LDEs formed:0

vegaErrors -> [('[i]', 'r', 'normalized', ['j', 'm', 'k', 'n', 'i'], 677)]
LDEs formed:0

todaysDiscounts -> [('[initialNumeraire]', 'r', 'not normalized', ['j', 'm', 'k', 'n', 'i'], 641), ('[0]', 'r', 'normalized', ['j', 'm', 'k', 'n', 'i'], 648), ('[0]', 'r', 'normalized', ['j', 'm', 'k', 'n', 'i'], 649), ('[i+1]', 'r', 'normalized', ['j', 'm', 'k', 'n', 'i'], 660)]
LDEs formed:0

fwdMinus -> [('[i]', 'w', 'normalized', ['j', 'm', 'k', 'n', 'i'], 652), ('[i]', 'r', 'normalized', ['j', 'm', 'k', 'n', 'i'], 654), ('[i]', 'r', 'normalized', ['j', 'm', 'k', 'n', 'i'], 661)]
LDEs formed:3

values -> [('[i]', 'r', 'normalized', ['j', 'm', 'k', 'n', 'i'], 667), ('[i]', 'r', 'normalized', ['j', 'm', 'k', 'n', 'i'], 669)]
LDEs formed:0

marketModels -> [('[j]', 'r', 'normalized', ['j', 'm', 'k', 'n', 'i'], 625), ('[j]', 'r', 'normalized', ['j', 'm', 'k', 'n', 'i'], 626), ('[j]', 'r', 'normalized', ['j', 'm', 'k', 'n', 'i'], 627), ('[j]', 'r', 'normalized', ['j', 'm', 'k', 'n', 'i'], 634), ('[j]', 'r', 'normalized', ['j', 'm', 'k', 'n', 'i'], 635), ('[j]', 'r', 'normalized', ['j', 'm', 'k', 'n', 'i'], 639)]
LDEs formed:0

discMinus -> [('[i+1]', 'w', 'normalized', ['j', 'm', 'k', 'n', 'i'], 654), ('[i]', 'r', 'normalized', ['j', 'm', 'k', 'n', 'i'], 654), ('[i+1]', 'r', 'normalized', ['j', 'm', 'k', 'n', 'i'], 663)]
LDEs formed:3

distinct LDEs:
0=0,0=2
0=0,0=1
1=1,2=2
i1+1=i2
0=0,0=0
1=1,1=2
1=1,1=1
1=1,0=2
1=1,0=1
1=1,0=0
i1=i2
i1+1=i2+1
0=0,2=2
0=1,2=0
0=1,2=1
0=1,2=2
0=1,0=2
0=1,0=0
0=1,0=1
0=1,1=2
0=1,1=1
0=1,1=0
0=0,1=2
0=0,1=1
#########################################################################################
loop info: Size i=0  i<todaysForwards.size()  ++i
induction variable: ['i']
{
L664: (payoffs[i]=,w) 
L665: (todaysForwards[i],r) 
L666: (todaysForwards[i],r) 
L667: (displacedPayoffs[i]=,w) 
L668: (todaysForwards[i]+,r) 
L669: (todaysForwards[i]+,r) 
}
array table
-----------------------------------------------
displacedPayoffs -> [('[i]', 'w', 'normalized', ['i'], 667)]
LDEs formed:1

todaysForwards -> [('[i]', 'r', 'normalized', ['i'], 665), ('[i]', 'r', 'normalized', ['i'], 666), ('[i]', 'r', 'normalized', ['i'], 668), ('[i]', 'r', 'normalized', ['i'], 669)]
LDEs formed:0

payoffs -> [('[i]', 'w', 'normalized', ['i'], 664)]
LDEs formed:1

distinct LDEs:
i1=i2
#########################################################################################
loop info: Size whichProduct=0  whichProduct<2  ++whichProduct
induction variable: ['whichProduct']
{
	loop info: Size j=0  j<LENGTH(marketModels)  j++
	induction variable: ['whichProduct', 'j']
	{
		loop info: Size m=0  m<LENGTH(testedFactors)  ++m
		induction variable: ['whichProduct', 'j', 'm']
		{
		L665: (testedFactors[m],r) 
			loop info: Size k=0  k<LENGTH(measures)  k++
			induction variable: ['whichProduct', 'j', 'm', 'k']
			{
			L666: (measures[k],r) 
				loop info: Size n=0  n<1  n++
				induction variable: ['whichProduct', 'j', 'm', 'k', 'n']
				{
				L667: (marketModels[j],r) 
				L668: (marketModels[j],r) 
				L669: (measures[k],r) 
				L670: (todaysDiscounts[initialNumeraire],r) 
					loop info: Size i=0  i < product->numberOfProducts()  ++i
					induction variable: ['whichProduct', 'j', 'm', 'k', 'n', 'i']
					{
					L671: (prices[i]=,w) (valuesAndDeltas[i],r) 
					L672: (priceErrors[i]=,w) (errors[i],r) 
					L673: (modelPrices[i]=,w) (displacedPayoffs[i],r) (todaysForwards[i],r) 
					L674: (volatilities[i]*,r) (rateTimes[i],r) 
					L675: (todaysDiscounts[i+1]*,r) (rateTimes[i+1]-,r) (rateTimes[i],r) 
						loop info: Size j=0  j <  todaysForwards.size()  ++j
						induction variable: ['whichProduct', 'j', 'm', 'k', 'n', 'i']
						{
						L676: (deltas[i][j]=,w) (valuesAndDeltas[(i+1)*product->numberOfProducts()+j],r) 
						L677: (deltasErrors[i][j]=,w) (errors[(i+1)* product->numberOfProducts()+j],r) 
						}
 					}
				L678: (todaysDiscounts[0],r) 
				L679: (todaysDiscounts[0],r) 
					loop info: Size i=0  i < todaysForwards.size()  ++i
					induction variable: ['whichProduct', 'j', 'm', 'k', 'n', 'i']
					{
						loop info: Size j=0  j < todaysForwards.size()  ++j
						induction variable: ['whichProduct', 'j', 'm', 'k', 'n', 'i']
						{
						L680: (fwdPlus[j]=,w) (todaysForwards[j],r) 
						L681: (fwdMinus[j]=,w) (todaysForwards[j],r) 
						L682: (fwdPlus[j]=,w) (todaysForwards[j]+,r) 
						L683: (fwdMinus[j]=,w) (todaysForwards[j]-,r) 
						L684: (rateTimes[j+1]-,r) (rateTimes[j],r) 
						L685: (discPlus[j+1]=,w) (discPlus[j]/,r) (fwdPlus[j]*,r) 
						L686: (discMinus[j+1]=,w) (discMinus[j]/,r) (fwdMinus[j]*,r) 
						}
						loop info: Size k=0  k  < product->numberOfProducts()  ++k
						induction variable: ['whichProduct', 'j', 'm', 'k', 'n', 'i']
						{
						L687: (rateTimes[k+1]-,r) (rateTimes[k],r) 
						L688: (displacedPayoffs[k],r) (fwdPlus[k],r) 
						L689: (volatilities[k]*,r) (rateTimes[k],r) 
						L690: (discPlus[k+1]*,r) 
						L691: (displacedPayoffs[k],r) (fwdMinus[k],r) 
						L692: (volatilities[k]*,r) (rateTimes[k],r) 
						L693: (discMinus[k+1]*,r) 
						L694: (modelDeltas[k][i]=,w) 
						}
 					}
					loop info: Size i=0  i<product->numberOfProducts()  ++i
					induction variable: ['whichProduct', 'j', 'm', 'k', 'n', 'i']
					{
					L695: (prices[i],r) 
					L696: (modelPrices[i],r) 
					L697: (priceErrors[i],r) 
					L698: (prices[i]<<,r) (modelPrices[i],r) 
					L699: (priceErrors[i]<<,r) 
						loop info: Size j =0  j < todaysForwards.size()  ++j
						induction variable: ['whichProduct', 'j', 'm', 'k', 'n', 'i']
						{
						L700: (deltas[i][j],r) 
						L701: (modelDeltas[i][j],r) 
						L702: (deltasErrors[i][j],r) 
						L703: (deltasErrors[i][j],r) 
						L704: (deltas[i][j]<<,r) (modelDeltas[i][j],r) 
						L705: (deltasErrors[i][j]<<,r) 
						}
 					}
 				}
 			}
 		}
 	}
 }
array table
-----------------------------------------------
deltasErrors -> [('[i][j]', 'w', 'normalized', ['whichProduct', 'j', 'm', 'k', 'n', 'i'], 677), ('[i][j]', 'r', 'normalized', ['whichProduct', 'j', 'm', 'k', 'n', 'i'], 702), ('[i][j]', 'r', 'normalized', ['whichProduct', 'j', 'm', 'k', 'n', 'i'], 703), ('[i][j]', 'r', 'normalized', ['whichProduct', 'j', 'm', 'k', 'n', 'i'], 705)]
LDEs formed:8

priceErrors -> [('[i]', 'w', 'normalized', ['whichProduct', 'j', 'm', 'k', 'n', 'i'], 672), ('[i]', 'r', 'normalized', ['whichProduct', 'j', 'm', 'k', 'n', 'i'], 697), ('[i]', 'r', 'normalized', ['whichProduct', 'j', 'm', 'k', 'n', 'i'], 699)]
LDEs formed:3

valuesAndDeltas -> [('[i]', 'r', 'normalized', ['whichProduct', 'j', 'm', 'k', 'n', 'i'], 671), ('[(i+1)*product->numberOfProducts()+j]', 'r', 'not normalized', ['whichProduct', 'j', 'm', 'k', 'n', 'i'], 676)]
LDEs formed:0

todaysForwards -> [('[i]', 'r', 'normalized', ['whichProduct', 'j', 'm', 'k', 'n', 'i'], 673), ('[j]', 'r', 'normalized', ['whichProduct', 'j', 'm', 'k', 'n', 'i'], 680), ('[j]', 'r', 'normalized', ['whichProduct', 'j', 'm', 'k', 'n', 'i'], 681), ('[j]', 'r', 'normalized', ['whichProduct', 'j', 'm', 'k', 'n', 'i'], 682), ('[j]', 'r', 'normalized', ['whichProduct', 'j', 'm', 'k', 'n', 'i'], 683)]
LDEs formed:0

volatilities -> [('[i]', 'r', 'normalized', ['whichProduct', 'j', 'm', 'k', 'n', 'i'], 674), ('[k]', 'r', 'normalized', ['whichProduct', 'j', 'm', 'k', 'n', 'i'], 689), ('[k]', 'r', 'normalized', ['whichProduct', 'j', 'm', 'k', 'n', 'i'], 692)]
LDEs formed:0

testedFactors -> [('[m]', 'r', 'normalized', ['whichProduct', 'j', 'm', 'k', 'n', 'i'], 665)]
LDEs formed:0

modelPrices -> [('[i]', 'w', 'normalized', ['whichProduct', 'j', 'm', 'k', 'n', 'i'], 673), ('[i]', 'r', 'normalized', ['whichProduct', 'j', 'm', 'k', 'n', 'i'], 696), ('[i]', 'r', 'normalized', ['whichProduct', 'j', 'm', 'k', 'n', 'i'], 698)]
LDEs formed:3

measures -> [('[k]', 'r', 'normalized', ['whichProduct', 'j', 'm', 'k', 'n', 'i'], 666), ('[k]', 'r', 'normalized', ['whichProduct', 'j', 'm', 'k', 'n', 'i'], 669)]
LDEs formed:0

fwdPlus -> [('[j]', 'w', 'normalized', ['whichProduct', 'j', 'm', 'k', 'n', 'i'], 680), ('[j]', 'w', 'normalized', ['whichProduct', 'j', 'm', 'k', 'n', 'i'], 682), ('[j]', 'r', 'normalized', ['whichProduct', 'j', 'm', 'k', 'n', 'i'], 685), ('[k]', 'r', 'normalized', ['whichProduct', 'j', 'm', 'k', 'n', 'i'], 688)]
LDEs formed:7

todaysDiscounts -> [('[initialNumeraire]', 'r', 'not normalized', ['whichProduct', 'j', 'm', 'k', 'n', 'i'], 670), ('[i+1]', 'r', 'normalized', ['whichProduct', 'j', 'm', 'k', 'n', 'i'], 675), ('[0]', 'r', 'normalized', ['whichProduct', 'j', 'm', 'k', 'n', 'i'], 678), ('[0]', 'r', 'normalized', ['whichProduct', 'j', 'm', 'k', 'n', 'i'], 679)]
LDEs formed:0

deltas -> [('[i][j]', 'w', 'normalized', ['whichProduct', 'j', 'm', 'k', 'n', 'i'], 676), ('[i][j]', 'r', 'normalized', ['whichProduct', 'j', 'm', 'k', 'n', 'i'], 700), ('[i][j]', 'r', 'normalized', ['whichProduct', 'j', 'm', 'k', 'n', 'i'], 704)]
LDEs formed:6

displacedPayoffs -> [('[i]', 'r', 'normalized', ['whichProduct', 'j', 'm', 'k', 'n', 'i'], 673), ('[k]', 'r', 'normalized', ['whichProduct', 'j', 'm', 'k', 'n', 'i'], 688), ('[k]', 'r', 'normalized', ['whichProduct', 'j', 'm', 'k', 'n', 'i'], 691)]
LDEs formed:0

errors -> [('[i]', 'r', 'normalized', ['whichProduct', 'j', 'm', 'k', 'n', 'i'], 672), ('[(i+1)* product->numberOfProducts()+j]', 'r', 'not normalized', ['whichProduct', 'j', 'm', 'k', 'n', 'i'], 677)]
LDEs formed:0

modelDeltas -> [('[k][i]', 'w', 'normalized', ['whichProduct', 'j', 'm', 'k', 'n', 'i'], 694), ('[i][j]', 'r', 'normalized', ['whichProduct', 'j', 'm', 'k', 'n', 'i'], 701), ('[i][j]', 'r', 'normalized', ['whichProduct', 'j', 'm', 'k', 'n', 'i'], 704)]
LDEs formed:6

prices -> [('[i]', 'w', 'normalized', ['whichProduct', 'j', 'm', 'k', 'n', 'i'], 671), ('[i]', 'r', 'normalized', ['whichProduct', 'j', 'm', 'k', 'n', 'i'], 695), ('[i]', 'r', 'normalized', ['whichProduct', 'j', 'm', 'k', 'n', 'i'], 698)]
LDEs formed:3

rateTimes -> [('[i]', 'r', 'normalized', ['whichProduct', 'j', 'm', 'k', 'n', 'i'], 674), ('[i+1]', 'r', 'normalized', ['whichProduct', 'j', 'm', 'k', 'n', 'i'], 675), ('[i]', 'r', 'normalized', ['whichProduct', 'j', 'm', 'k', 'n', 'i'], 675), ('[j+1]', 'r', 'normalized', ['whichProduct', 'j', 'm', 'k', 'n', 'i'], 684), ('[j]', 'r', 'normalized', ['whichProduct', 'j', 'm', 'k', 'n', 'i'], 684), ('[k+1]', 'r', 'normalized', ['whichProduct', 'j', 'm', 'k', 'n', 'i'], 687), ('[k]', 'r', 'normalized', ['whichProduct', 'j', 'm', 'k', 'n', 'i'], 687), ('[k]', 'r', 'normalized', ['whichProduct', 'j', 'm', 'k', 'n', 'i'], 689), ('[k]', 'r', 'normalized', ['whichProduct', 'j', 'm', 'k', 'n', 'i'], 692)]
LDEs formed:0

marketModels -> [('[j]', 'r', 'normalized', ['whichProduct', 'j', 'm', 'k', 'n', 'i'], 667), ('[j]', 'r', 'normalized', ['whichProduct', 'j', 'm', 'k', 'n', 'i'], 668)]
LDEs formed:0

discPlus -> [('[j+1]', 'w', 'normalized', ['whichProduct', 'j', 'm', 'k', 'n', 'i'], 685), ('[j]', 'r', 'normalized', ['whichProduct', 'j', 'm', 'k', 'n', 'i'], 685), ('[k+1]', 'r', 'normalized', ['whichProduct', 'j', 'm', 'k', 'n', 'i'], 690)]
LDEs formed:3

discMinus -> [('[j+1]', 'w', 'normalized', ['whichProduct', 'j', 'm', 'k', 'n', 'i'], 686), ('[j]', 'r', 'normalized', ['whichProduct', 'j', 'm', 'k', 'n', 'i'], 686), ('[k+1]', 'r', 'normalized', ['whichProduct', 'j', 'm', 'k', 'n', 'i'], 693)]
LDEs formed:3

fwdMinus -> [('[j]', 'w', 'normalized', ['whichProduct', 'j', 'm', 'k', 'n', 'i'], 681), ('[j]', 'w', 'normalized', ['whichProduct', 'j', 'm', 'k', 'n', 'i'], 683), ('[j]', 'r', 'normalized', ['whichProduct', 'j', 'm', 'k', 'n', 'i'], 686), ('[k]', 'r', 'normalized', ['whichProduct', 'j', 'm', 'k', 'n', 'i'], 691)]
LDEs formed:7

distinct LDEs:
k1=i2,i1=j2
i1=i2,j1=j2
j1=k2
j1+1=j2+1
j1+1=j2
j1+1=k2+1
i1=i2
j1=j2
k1=k2,i1=i2
#########################################################################################
loop info: Size i=0  i<todaysForwards.size()  ++i
induction variable: ['i']
{
L692: (payoffs[i]=,w) 
L693: (todaysForwards[i],r) 
L694: (todaysForwards[i],r) 
L695: (displacedPayoffs[i]=,w) 
L696: (todaysForwards[i]+,r) 
L697: (todaysForwards[i]+,r) 
}
array table
-----------------------------------------------
displacedPayoffs -> [('[i]', 'w', 'normalized', ['i'], 695)]
LDEs formed:1

todaysForwards -> [('[i]', 'r', 'normalized', ['i'], 693), ('[i]', 'r', 'normalized', ['i'], 694), ('[i]', 'r', 'normalized', ['i'], 696), ('[i]', 'r', 'normalized', ['i'], 697)]
LDEs formed:0

payoffs -> [('[i]', 'w', 'normalized', ['i'], 692)]
LDEs formed:1

distinct LDEs:
i1=i2
#########################################################################################
loop info: Size j=0  j<LENGTH(marketModels)  j++
induction variable: ['j']
{
	loop info: Size m=0  m<LENGTH(testedFactors)  ++m
	induction variable: ['j', 'm']
	{
	L693: (testedFactors[m],r) 
	L694: (marketModels[j],r) 
		loop info: Size k=0  k < marketModel->numberOfSteps()  ++k
		induction variable: ['j', 'm', 'k']
		{
		}
		loop info: Size step=0  step < evolution.numberOfSteps()  ++ step
		induction variable: ['j', 'm', 'k', 'step']
		{
			loop info: Size l=0  l < evolution.numberOfRates()  ++l
			induction variable: ['j', 'm', 'k', 'step', 'l']
			{
			L695: (pseudoRoots[step][l][f]+=,w) 
			L696: (pseudoRoots[step][l][f]-=,w) 
			L697: (pseudoRoots[step][l][f]-=,w) 
			L698: (pseudoRoots[step][l][f]+=,w) 
			}
 		}
 	}
 }
array table
-----------------------------------------------
testedFactors -> [('[m]', 'r', 'normalized', ['j', 'm', 'k', 'step', 'l'], 693)]
LDEs formed:0

marketModels -> [('[j]', 'r', 'normalized', ['j', 'm', 'k', 'step', 'l'], 694)]
LDEs formed:0

pseudoRoots -> [('[step][l][f]', 'w', 'not normalized', ['j', 'm', 'k', 'step', 'l'], 695), ('[step][l][f]', 'w', 'not normalized', ['j', 'm', 'k', 'step', 'l'], 696), ('[step][l][f]', 'w', 'not normalized', ['j', 'm', 'k', 'step', 'l'], 697), ('[step][l][f]', 'w', 'not normalized', ['j', 'm', 'k', 'step', 'l'], 698)]
LDEs formed:30

distinct LDEs:
step1=step2,l1=l2,f=f
#########################################################################################
loop info: Size j=0  j<LENGTH(marketModels)  j++
induction variable: ['j']
{
	loop info: Size m=0  m<LENGTH(testedFactors)  ++m
	induction variable: ['j', 'm']
	{
	L699: (testedFactors[m],r) 
	L700: (marketModels[j],r) 
		loop info: Size startIndex = 1  startIndex < evolution.numberOfRates()-1  ++startIndex
		induction variable: ['j', 'm', 'startIndex']
		{
			loop info: Size k=0  k < marketModel->numberOfSteps()  ++k
			induction variable: ['j', 'm', 'startIndex', 'k']
			{
			}
			loop info: Size step=0  step < evolution.numberOfSteps()  ++ step
			induction variable: ['j', 'm', 'startIndex', 'k', 'step']
			{
				loop info: Size l=0  l < evolution.numberOfRates()  ++l
				induction variable: ['j', 'm', 'startIndex', 'k', 'step', 'l']
				{
				L701: (pseudoRoots[step][l][f]+=,w) 
				L702: (pseudoRoots[step][l][f]-=,w) 
				L703: (pseudoRoots[step][l][f]-=,w) 
				L704: (pseudoRoots[step][l][f]+=,w) 
					loop info: Size k=startIndex  k < endIndex  ++k
					induction variable: ['j', 'm', 'startIndex', 'k', 'step', 'l']
					{
					L705: (totalCovUp[k][k],r) 
					L706: (totalCovDown[k][k],r) 
					L707: (todaysDiscounts[k+1]*,r) 
					L708: (todaysForwards[k],r) 
					}
 				}
 			}
			loop info: Size m= startIndex  m < endIndex  ++m
			induction variable: ['j', 'm', 'startIndex', 'k', 'step', 'l']
			{
			L709: (todaysDiscounts[m+1]*,r) 
			L710: (rateTimes[m],r) 
			L711: (todaysForwards[m],r) 
			L712: (totalCov[m][m],r) 
			}
 		}
 	}
	loop info: Size m=0  m<LENGTH(testedFactors)  ++m
	induction variable: ['j', 'm', 'startIndex', 'k', 'step', 'l']
	{
	L713: (testedFactors[m],r) 
	L714: (marketModels[j],r) 
		loop info: Size startIndex = 1  startIndex < evolution.numberOfRates()-1  ++startIndex
		induction variable: ['j', 'm', 'startIndex', 'k', 'step', 'l']
		{
			loop info: Size k=0  k < marketModel->numberOfSteps()  ++k
			induction variable: ['j', 'm', 'startIndex', 'k', 'step', 'l']
			{
			}
			loop info: Size step=0  step < evolution.numberOfSteps()  ++ step
			induction variable: ['j', 'm', 'startIndex', 'k', 'step', 'l']
			{
				loop info: Size l=0  l < evolution.numberOfRates()  ++l
				induction variable: ['j', 'm', 'startIndex', 'k', 'step', 'l']
				{
				L715: (pseudoRoots[step][l][f]+=,w) 
				L716: (pseudoRoots[step][l][f]-=,w) 
				L717: (pseudoRoots[step][l][f]-=,w) 
				L718: (pseudoRoots[step][l][f]+=,w) 
				}
 			}
 		}
 	}
 }
array table
-----------------------------------------------
pseudoRoots -> [('[step][l][f]', 'w', 'not normalized', ['j', 'm', 'startIndex', 'k', 'step', 'l'], 701), ('[step][l][f]', 'w', 'not normalized', ['j', 'm', 'startIndex', 'k', 'step', 'l'], 702), ('[step][l][f]', 'w', 'not normalized', ['j', 'm', 'startIndex', 'k', 'step', 'l'], 703), ('[step][l][f]', 'w', 'not normalized', ['j', 'm', 'startIndex', 'k', 'step', 'l'], 704), ('[step][l][f]', 'w', 'not normalized', ['j', 'm', 'startIndex', 'k', 'step', 'l'], 715), ('[step][l][f]', 'w', 'not normalized', ['j', 'm', 'startIndex', 'k', 'step', 'l'], 716), ('[step][l][f]', 'w', 'not normalized', ['j', 'm', 'startIndex', 'k', 'step', 'l'], 717), ('[step][l][f]', 'w', 'not normalized', ['j', 'm', 'startIndex', 'k', 'step', 'l'], 718)]
LDEs formed:108

todaysForwards -> [('[k]', 'r', 'normalized', ['j', 'm', 'startIndex', 'k', 'step', 'l'], 708), ('[m]', 'r', 'normalized', ['j', 'm', 'startIndex', 'k', 'step', 'l'], 711)]
LDEs formed:0

testedFactors -> [('[m]', 'r', 'normalized', ['j', 'm', 'startIndex', 'k', 'step', 'l'], 699), ('[m]', 'r', 'normalized', ['j', 'm', 'startIndex', 'k', 'step', 'l'], 713)]
LDEs formed:0

totalCovUp -> [('[k][k]', 'r', 'normalized', ['j', 'm', 'startIndex', 'k', 'step', 'l'], 705)]
LDEs formed:0

todaysDiscounts -> [('[k+1]', 'r', 'normalized', ['j', 'm', 'startIndex', 'k', 'step', 'l'], 707), ('[m+1]', 'r', 'normalized', ['j', 'm', 'startIndex', 'k', 'step', 'l'], 709)]
LDEs formed:0

totalCovDown -> [('[k][k]', 'r', 'normalized', ['j', 'm', 'startIndex', 'k', 'step', 'l'], 706)]
LDEs formed:0

totalCov -> [('[m][m]', 'r', 'normalized', ['j', 'm', 'startIndex', 'k', 'step', 'l'], 712)]
LDEs formed:0

rateTimes -> [('[m]', 'r', 'normalized', ['j', 'm', 'startIndex', 'k', 'step', 'l'], 710)]
LDEs formed:0

marketModels -> [('[j]', 'r', 'normalized', ['j', 'm', 'startIndex', 'k', 'step', 'l'], 700), ('[j]', 'r', 'normalized', ['j', 'm', 'startIndex', 'k', 'step', 'l'], 714)]
LDEs formed:0

distinct LDEs:
step1=step2,l1=l2,f=f
#########################################################################################
loop info: Size j=0  j<LENGTH(marketModels)  j++
induction variable: ['j']
{
	loop info: Size m=0  m<LENGTH(testedFactors)  ++m
	induction variable: ['j', 'm']
	{
	L715: (testedFactors[m],r) 
		loop info: Size k=0  k < evolution.numberOfRates()  ++k
		induction variable: ['j', 'm', 'k']
		{
			loop info: Size f=0  f < factors  ++f
			induction variable: ['j', 'm', 'k', 'f']
			{
			L716: (modelBump[k][f]=,w) 
			L717: (modelBump[k][f]=,w) 
			}
 		}
		loop info: Size l = 0  l < evolution.numberOfSteps()  ++l
		induction variable: ['j', 'm', 'k', 'f', 'l']
		{
			loop info: Size k=0  k < evolution.numberOfRates()  k=k+bumpIncrement
			induction variable: ['j', 'm', 'k', 'f', 'l']
			{
				loop info: Size f=0  f < factorsToTest  ++f
				induction variable: ['j', 'm', 'k', 'f', 'l']
				{
					loop info: Size m=0  m < evolution.numberOfSteps()  ++m
					induction variable: ['j', 'm', 'k', 'f', 'l']
					{
					L718: (modelBump[k][f]=,w) 
					L719: (vegaBumps[l].push_back,r) 
					L720: (modelBump[k][f]=,w) 
					}
 				}
 			}
 		}
		loop info: Size k=0  k<LENGTH(measures)  k++
		induction variable: ['j', 'm', 'k', 'f', 'l']
		{
		L721: (measures[k],r) 
		L722: (marketModels[j],r) 
			loop info: Size l=0  l < evolution.numberOfSteps()  ++l
			induction variable: ['j', 'm', 'k', 'f', 'l']
			{
			L723: (numeraires[l],r) 
			L724: (numeraires[l],r) 
			L725: (numeraires[l],r) 
			L726: (numeraires[l],r) 
			}
			loop info: Size i=0  i < product.numberOfProducts()  ++i
			induction variable: ['j', 'm', 'k', 'f', 'l', 'i']
			{
			}
			loop info: Size i=0  i < steps  ++i
			induction variable: ['j', 'm', 'k', 'f', 'l', 'i']
				{
				}
		L727: (oneStepDFs[0]=,w) 
			loop info: Size l=0  l < pathsToDo  ++l
			induction variable: ['j', 'm', 'k', 'f', 'l', 'i']
			{
				loop info: Size i=1  i <= evolution.numberOfRates()  ++i
				induction variable: ['j', 'm', 'k', 'f', 'l', 'i']
					{
					}
			L728: (testees[currentStep].getBumps,r) 
			L729: (testees2[currentStep].getBumps,r) 
			L730: (testers[currentStep].getBumps,r) 
			L731: (testersDown[currentStep].getBumps,r) 
				loop info: Size i1 =0  i1 < pseudoBumps.size()  ++i1
				induction variable: ['j', 'm', 'k', 'f', 'l', 'i', 'i1']
					{
						loop info:   j1 < evolution.firstAliveRate()[i1]  ++j1
						induction variable: ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1']
						{
						L732: (B4[i1][j1]=,w) 
						}
						loop info: Size k1=evolution.firstAliveRate()[i1]  k1 < numberRates  ++k1
						induction variable: ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1']
							{
							}
					L733: (B4[i1][j1]=,w) 
					}
				loop info: Size j=0  j < B.rows()  ++j
				induction variable: ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1']
					{
					L734: (B[j][k]/,r) 
					L735: (B4[j][k]/,r) 
					L736: (B2[j][k]-,r) (B3[j][k],r) 
					L737: (B[j][k]<<,r) (B2[j][k],r) 
					L738: (B4[j][k]<<,r) (B2[j][k],r) 
					}
 			}
 		}
		loop info: Size deflate =0  deflate <2  ++deflate
		induction variable: ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1', 'deflate']
		{
			loop info: Size k=0  k<LENGTH(measures)  k++
			induction variable: ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1', 'deflate']
			{
			L739: (measures[k],r) 
			L740: (marketModels[j],r) 
			L741: (vegaBumps[0].size,r) 
			L742: (marketModels[j],r) 
			L743: (measures[k],r) 
			L744: (todaysDiscounts[initialNumeraire],r) 
			L745: (vegaBumps[0].size,r) 
			L746: (vegaBumps[0].size,r) 
				loop info: Size i=0  i < caplets.numberOfProducts()  ++i
				induction variable: ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1', 'deflate']
				{
				L747: (prices[i]=,w) (values[i*entriesPerProduct],r) 
				L748: (priceErrors[i]=,w) (errors[i*entriesPerProduct],r) 
					loop info: Size j=0  j < vegaBumps[0].size()  ++j
					induction variable: ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1', 'deflate']
					{
					L749: (vegasMatrix[i][j]=,w) (values[i*entriesPerProduct + numberRates+1 + j],r) 
					L750: (standardErrors[i][j]=,w) (errors[i*entriesPerProduct + numberRates+1 + j],r) 
					}
				L751: (deltasMatrix[i][j]=,w) (values[i*entriesPerProduct +1 + j],r) 
				L752: (deltasErrors[i][j]=,w) (errors[i*entriesPerProduct +1 + j],r) 
				}
				loop info: Size r =0  r < truePrices.size()  ++r
				induction variable: ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1', 'deflate', 'r']
				{
				L753: (truePrices[r]=,w) (displacedPayoffs[r],r) (todaysForwards[r],r) (totalCovariance[r][r],r) 
				L754: (todaysDiscounts[r+1]*,r) (rateTimes[r+1]-,r) (rateTimes[r],r) 
				}
				loop info: Size b =0  b < vegaBumps[0].size()  ++b
				induction variable: ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1', 'deflate', 'r', 'b']
				{
					loop info: Size step = 0  step < marketModel->numberOfSteps()  ++step
					induction variable: ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1', 'deflate', 'r', 'b', 'step']
					{
					L755: (vegaBumps[step][b],r) 
						loop info: Size rate=step  rate<marketModel->numberOfRates()  ++rate
						induction variable: ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1', 'deflate', 'r', 'b', 'step', 'rate']
						{
							loop info: Size f=0  f < marketModel->numberOfFactors()  ++f
							induction variable: ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1', 'deflate', 'r', 'b', 'step', 'rate']
							{
							}
						L756: (variances[rate]+=,w) 
						}
 					}
					loop info: Size r =0  r < truePrices.size()  ++r
					induction variable: ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1', 'deflate', 'r', 'b', 'step', 'rate']
					{
					L757: (bumpedPrices[r]=,w) (displacedPayoffs[r],r) (todaysForwards[r],r) (variances[r],r) 
					L758: (todaysDiscounts[r+1]*,r) (rateTimes[r+1]-,r) (rateTimes[r],r) 
					L759: (vegas[r]=,w) (bumpedPrices[r]-,r) (truePrices[r],r) 
					}
					loop info: Size s=0  s  < truePrices.size()  ++s
					induction variable: ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1', 'deflate', 'r', 'b', 'step', 'rate', 's']
					{
					L760: (vegasMatrix[s][b],r) 
					L761: (vegas[s],r) 
					L762: (standardErrors[s][b],r) 
					}
 				}
				loop info: Size i=0  i < productToUse2->numberOfProducts()  ++i
				induction variable: ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1', 'deflate', 'r', 'b', 'step', 'rate', 's']
				{
				L763: (prices2[i]=,w) (valuesAndDeltas2[i],r) 
				L764: (priceErrors2[i]=,w) (errors2[i],r) 
					loop info: Size j=0  j <  todaysForwards.size()  ++j
					induction variable: ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1', 'deflate', 'r', 'b', 'step', 'rate', 's']
					{
					L765: (deltas2[i][j]=,w) (valuesAndDeltas2[(i+1)*productToUse2->numberOfProducts()+j],r) 
					L766: (deltasErrors2[i][j]=,w) (errors2[(i+1)* productToUse2->numberOfProducts()+j],r) 
					}
 				}
				loop info: Size i=0  i < productToUse2->numberOfProducts()  ++i
				induction variable: ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1', 'deflate', 'r', 'b', 'step', 'rate', 's']
				{
				L767: (prices2[i]-,r) (prices[i],r) 
				L768: (priceErrors2[i],r) 
				L769: (prices[j]<<,r) (prices2[j]<<,r) 
					loop info: Size j=0  j <  todaysForwards.size()  ++j
					induction variable: ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1', 'deflate', 'r', 'b', 'step', 'rate', 's']
					{
					L770: (deltas2[i][j]-,r) (deltasMatrix[i][j],r) 
					L771: (deltasErrors2[i][j],r) 
					L772: (deltasMatrix[i][j]<<,r) (deltas2[i][j]<<,r) 
					}
 				}
 			}
 		}
	L773: (todaysForwards[0],r) 
		loop info: Size i=0  i +2 < numberRates  i=i+3
		induction variable: ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1', 'deflate', 'r', 'b', 'step', 'rate', 's']
			{
			}
		loop info: Size r=0  r < caps.size()  ++r
		induction variable: ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1', 'deflate', 'r', 'b', 'step', 'rate', 's']
			{
			L774: (startsAndEnds[r].first=,w) (caps[r].startIndex_,r) 
			L775: (startsAndEnds[r].second=,w) (caps[r].endIndex_,r) 
			}
		loop info: Size k=0  k<LENGTH(measures)  k++
		induction variable: ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1', 'deflate', 'r', 'b', 'step', 'rate', 's']
			{
			L776: (measures[k],r) 
			L777: (marketModels[j],r) 
			L778: (vegaBumps[0].size,r) 
			L779: (marketModels[j],r) 
			L780: (measures[k],r) 
			L781: (todaysDiscounts[initialNumeraire],r) 
				loop info: Size i=0  i <values.size()  ++i
				induction variable: ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1', 'deflate', 'r', 'b', 'step', 'rate', 's']
					{
					}
			L782: (vegaBumps[0].size,r) 
			L783: (vegaBumps[0].size,r) 
				loop info: Size i=0  i < capsDeflated.numberOfProducts()  ++i
				induction variable: ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1', 'deflate', 'r', 'b', 'step', 'rate', 's']
				{
				L784: (vegasMatrix[i][j]=,w) (values[i*entriesPerProduct + numberRates+1 + j],r) 
				L785: (standardErrors[i][j]=,w) (errors[i*entriesPerProduct + numberRates+1 + j],r) 
				}
				loop info: Size r =0  r < trueCapletPrices.size()  ++r
				induction variable: ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1', 'deflate', 'r', 'b', 'step', 'rate', 's']
				{
				}
				loop info: Size s=0  s < capsDeflated.numberOfProducts()  ++s
				induction variable: ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1', 'deflate', 'r', 'b', 'step', 'rate', 's']
				{
				L786: (trueCapPrices[s]=,w) 
					loop info: Size t= caps[s].startIndex_  t <  caps[s].endIndex_  ++t
					induction variable: ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1', 'deflate', 'r', 'b', 'step', 'rate', 's', 't']
					{
					}
 				}
				loop info: Size b =0  b < vegaBumps[0].size()  ++b
				induction variable: ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1', 'deflate', 'r', 'b', 'step', 'rate', 's', 't']
				{
					loop info: Size step = 0  step < marketModel->numberOfSteps()  ++step
					induction variable: ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1', 'deflate', 'r', 'b', 'step', 'rate', 's', 't']
					{
					L787: (vegaBumps[step][b],r) 
						loop info: Size rate=step  rate<marketModel->numberOfRates()  ++rate
						induction variable: ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1', 'deflate', 'r', 'b', 'step', 'rate', 's', 't']
						{
							loop info: Size f=0  f < marketModel->numberOfFactors()  ++f
							induction variable: ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1', 'deflate', 'r', 'b', 'step', 'rate', 's', 't']
							{
							}
						L788: (variances[rate]+=,w) 
						}
 					}
					loop info: Size r =0  r < trueCapletPrices.size()  ++r
					induction variable: ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1', 'deflate', 'r', 'b', 'step', 'rate', 's', 't']
					{
					L789: (bumpedCapletPrices[r]=,w) (todaysForwards[r],r) (variances[r],r) 
					L790: (todaysDiscounts[r+1]*,r) (rateTimes[r+1]-,r) (rateTimes[r],r) 
					L791: (vegasCaplets[r]=,w) (bumpedCapletPrices[r]-,r) (trueCapletPrices[r],r) 
					}
					loop info: Size s=0  s < capsDeflated.numberOfProducts()  ++s
					induction variable: ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1', 'deflate', 'r', 'b', 'step', 'rate', 's', 't']
					{
					L792: (vegaCaps[s]=,w) 
						loop info: Size t= caps[s].startIndex_  t <  caps[s].endIndex_  ++t
						induction variable: ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1', 'deflate', 'r', 'b', 'step', 'rate', 's', 't']
						{
						}
 					}
					loop info: Size s=0  s  < capsDeflated.numberOfProducts()  ++s
					induction variable: ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1', 'deflate', 'r', 'b', 'step', 'rate', 's', 't']
					{
					L793: (vegasMatrix[s][b],r) 
					L794: (vegaCaps[s],r) 
					L795: (standardErrors[s][b],r) 
					}
 				}
 			}
 	}
 }
array table
-----------------------------------------------
priceErrors2 -> [('[i]', 'w', 'normalized', ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1', 'deflate', 'r', 'b', 'step', 'rate', 's', 't'], 764), ('[i]', 'r', 'normalized', ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1', 'deflate', 'r', 'b', 'step', 'rate', 's', 't'], 768)]
LDEs formed:2

testersDown -> [('[currentStep]', 'r', 'not normalized', ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1', 'deflate', 'r', 'b', 'step', 'rate', 's', 't'], 731)]
LDEs formed:0

bumpedCapletPrices -> [('[r]', 'w', 'normalized', ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1', 'deflate', 'r', 'b', 'step', 'rate', 's', 't'], 789), ('[r]', 'r', 'normalized', ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1', 'deflate', 'r', 'b', 'step', 'rate', 's', 't'], 791)]
LDEs formed:2

trueCapPrices -> [('[s]', 'w', 'normalized', ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1', 'deflate', 'r', 'b', 'step', 'rate', 's', 't'], 786)]
LDEs formed:1

vegasCaplets -> [('[r]', 'w', 'normalized', ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1', 'deflate', 'r', 'b', 'step', 'rate', 's', 't'], 791)]
LDEs formed:1

rateTimes -> [('[r+1]', 'r', 'normalized', ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1', 'deflate', 'r', 'b', 'step', 'rate', 's', 't'], 754), ('[r]', 'r', 'normalized', ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1', 'deflate', 'r', 'b', 'step', 'rate', 's', 't'], 754), ('[r+1]', 'r', 'normalized', ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1', 'deflate', 'r', 'b', 'step', 'rate', 's', 't'], 758), ('[r]', 'r', 'normalized', ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1', 'deflate', 'r', 'b', 'step', 'rate', 's', 't'], 758), ('[r+1]', 'r', 'normalized', ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1', 'deflate', 'r', 'b', 'step', 'rate', 's', 't'], 790), ('[r]', 'r', 'normalized', ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1', 'deflate', 'r', 'b', 'step', 'rate', 's', 't'], 790)]
LDEs formed:0

errors2 -> [('[i]', 'r', 'normalized', ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1', 'deflate', 'r', 'b', 'step', 'rate', 's', 't'], 764), ('[(i+1)* productToUse2->numberOfProducts()+j]', 'r', 'not normalized', ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1', 'deflate', 'r', 'b', 'step', 'rate', 's', 't'], 766)]
LDEs formed:0

startsAndEnds -> [('[r]', 'w', 'normalized', ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1', 'deflate', 'r', 'b', 'step', 'rate', 's', 't'], 774), ('[r]', 'w', 'normalized', ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1', 'deflate', 'r', 'b', 'step', 'rate', 's', 't'], 775)]
LDEs formed:3

errors -> [('[i*entriesPerProduct]', 'r', 'not normalized', ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1', 'deflate', 'r', 'b', 'step', 'rate', 's', 't'], 748), ('[i*entriesPerProduct + numberRates+1 + j]', 'r', 'not normalized', ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1', 'deflate', 'r', 'b', 'step', 'rate', 's', 't'], 750), ('[i*entriesPerProduct +1 + j]', 'r', 'not normalized', ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1', 'deflate', 'r', 'b', 'step', 'rate', 's', 't'], 752), ('[i*entriesPerProduct + numberRates+1 + j]', 'r', 'not normalized', ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1', 'deflate', 'r', 'b', 'step', 'rate', 's', 't'], 785)]
LDEs formed:0

modelBump -> [('[k][f]', 'w', 'normalized', ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1', 'deflate', 'r', 'b', 'step', 'rate', 's', 't'], 716), ('[k][f]', 'w', 'normalized', ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1', 'deflate', 'r', 'b', 'step', 'rate', 's', 't'], 717), ('[k][f]', 'w', 'normalized', ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1', 'deflate', 'r', 'b', 'step', 'rate', 's', 't'], 718), ('[k][f]', 'w', 'normalized', ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1', 'deflate', 'r', 'b', 'step', 'rate', 's', 't'], 720)]
LDEs formed:20

testedFactors -> [('[m]', 'r', 'normalized', ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1', 'deflate', 'r', 'b', 'step', 'rate', 's', 't'], 715)]
LDEs formed:0

oneStepDFs -> [('[0]', 'w', 'normalized', ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1', 'deflate', 'r', 'b', 'step', 'rate', 's', 't'], 727)]
LDEs formed:1

testers -> [('[currentStep]', 'r', 'not normalized', ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1', 'deflate', 'r', 'b', 'step', 'rate', 's', 't'], 730)]
LDEs formed:0

valuesAndDeltas2 -> [('[i]', 'r', 'normalized', ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1', 'deflate', 'r', 'b', 'step', 'rate', 's', 't'], 763), ('[(i+1)*productToUse2->numberOfProducts()+j]', 'r', 'not normalized', ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1', 'deflate', 'r', 'b', 'step', 'rate', 's', 't'], 765)]
LDEs formed:0

prices2 -> [('[i]', 'w', 'normalized', ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1', 'deflate', 'r', 'b', 'step', 'rate', 's', 't'], 763), ('[i]', 'r', 'normalized', ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1', 'deflate', 'r', 'b', 'step', 'rate', 's', 't'], 767), ('[j]', 'r', 'normalized', ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1', 'deflate', 'r', 'b', 'step', 'rate', 's', 't'], 769)]
LDEs formed:3

displacedPayoffs -> [('[r]', 'r', 'normalized', ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1', 'deflate', 'r', 'b', 'step', 'rate', 's', 't'], 753), ('[r]', 'r', 'normalized', ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1', 'deflate', 'r', 'b', 'step', 'rate', 's', 't'], 757)]
LDEs formed:0

totalCovariance -> [('[r][r]', 'r', 'normalized', ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1', 'deflate', 'r', 'b', 'step', 'rate', 's', 't'], 753)]
LDEs formed:0

standardErrors -> [('[i][j]', 'w', 'normalized', ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1', 'deflate', 'r', 'b', 'step', 'rate', 's', 't'], 750), ('[s][b]', 'r', 'normalized', ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1', 'deflate', 'r', 'b', 'step', 'rate', 's', 't'], 762), ('[i][j]', 'w', 'normalized', ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1', 'deflate', 'r', 'b', 'step', 'rate', 's', 't'], 785), ('[s][b]', 'r', 'normalized', ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1', 'deflate', 'r', 'b', 'step', 'rate', 's', 't'], 795)]
LDEs formed:14

vegasMatrix -> [('[i][j]', 'w', 'normalized', ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1', 'deflate', 'r', 'b', 'step', 'rate', 's', 't'], 749), ('[s][b]', 'r', 'normalized', ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1', 'deflate', 'r', 'b', 'step', 'rate', 's', 't'], 760), ('[i][j]', 'w', 'normalized', ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1', 'deflate', 'r', 'b', 'step', 'rate', 's', 't'], 784), ('[s][b]', 'r', 'normalized', ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1', 'deflate', 'r', 'b', 'step', 'rate', 's', 't'], 793)]
LDEs formed:14

deltasErrors -> [('[i][j]', 'w', 'normalized', ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1', 'deflate', 'r', 'b', 'step', 'rate', 's', 't'], 752)]
LDEs formed:2

B -> [('[j][k]', 'r', 'normalized', ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1', 'deflate', 'r', 'b', 'step', 'rate', 's', 't'], 734), ('[j][k]', 'r', 'normalized', ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1', 'deflate', 'r', 'b', 'step', 'rate', 's', 't'], 737)]
LDEs formed:0

testees -> [('[currentStep]', 'r', 'not normalized', ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1', 'deflate', 'r', 'b', 'step', 'rate', 's', 't'], 728)]
LDEs formed:0

trueCapletPrices -> [('[r]', 'r', 'normalized', ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1', 'deflate', 'r', 'b', 'step', 'rate', 's', 't'], 791)]
LDEs formed:0

measures -> [('[k]', 'r', 'normalized', ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1', 'deflate', 'r', 'b', 'step', 'rate', 's', 't'], 721), ('[k]', 'r', 'normalized', ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1', 'deflate', 'r', 'b', 'step', 'rate', 's', 't'], 739), ('[k]', 'r', 'normalized', ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1', 'deflate', 'r', 'b', 'step', 'rate', 's', 't'], 743), ('[k]', 'r', 'normalized', ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1', 'deflate', 'r', 'b', 'step', 'rate', 's', 't'], 776), ('[k]', 'r', 'normalized', ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1', 'deflate', 'r', 'b', 'step', 'rate', 's', 't'], 780)]
LDEs formed:0

caps -> [('[r]', 'r', 'normalized', ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1', 'deflate', 'r', 'b', 'step', 'rate', 's', 't'], 774), ('[r]', 'r', 'normalized', ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1', 'deflate', 'r', 'b', 'step', 'rate', 's', 't'], 775)]
LDEs formed:0

vegas -> [('[r]', 'w', 'normalized', ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1', 'deflate', 'r', 'b', 'step', 'rate', 's', 't'], 759), ('[s]', 'r', 'normalized', ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1', 'deflate', 'r', 'b', 'step', 'rate', 's', 't'], 761)]
LDEs formed:2

testees2 -> [('[currentStep]', 'r', 'not normalized', ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1', 'deflate', 'r', 'b', 'step', 'rate', 's', 't'], 729)]
LDEs formed:0

prices -> [('[i]', 'w', 'normalized', ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1', 'deflate', 'r', 'b', 'step', 'rate', 's', 't'], 747), ('[i]', 'r', 'normalized', ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1', 'deflate', 'r', 'b', 'step', 'rate', 's', 't'], 767), ('[j]', 'r', 'normalized', ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1', 'deflate', 'r', 'b', 'step', 'rate', 's', 't'], 769)]
LDEs formed:3

deltasMatrix -> [('[i][j]', 'w', 'normalized', ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1', 'deflate', 'r', 'b', 'step', 'rate', 's', 't'], 751), ('[i][j]', 'r', 'normalized', ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1', 'deflate', 'r', 'b', 'step', 'rate', 's', 't'], 770), ('[i][j]', 'r', 'normalized', ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1', 'deflate', 'r', 'b', 'step', 'rate', 's', 't'], 772)]
LDEs formed:6

deltasErrors2 -> [('[i][j]', 'w', 'normalized', ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1', 'deflate', 'r', 'b', 'step', 'rate', 's', 't'], 766), ('[i][j]', 'r', 'normalized', ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1', 'deflate', 'r', 'b', 'step', 'rate', 's', 't'], 771)]
LDEs formed:4

deltas2 -> [('[i][j]', 'w', 'normalized', ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1', 'deflate', 'r', 'b', 'step', 'rate', 's', 't'], 765), ('[i][j]', 'r', 'normalized', ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1', 'deflate', 'r', 'b', 'step', 'rate', 's', 't'], 770), ('[i][j]', 'r', 'normalized', ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1', 'deflate', 'r', 'b', 'step', 'rate', 's', 't'], 772)]
LDEs formed:6

vegaBumps -> [('[l]', 'r', 'normalized', ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1', 'deflate', 'r', 'b', 'step', 'rate', 's', 't'], 719), ('[0]', 'r', 'normalized', ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1', 'deflate', 'r', 'b', 'step', 'rate', 's', 't'], 741), ('[0]', 'r', 'normalized', ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1', 'deflate', 'r', 'b', 'step', 'rate', 's', 't'], 745), ('[0]', 'r', 'normalized', ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1', 'deflate', 'r', 'b', 'step', 'rate', 's', 't'], 746), ('[step][b]', 'r', 'normalized', ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1', 'deflate', 'r', 'b', 'step', 'rate', 's', 't'], 755), ('[0]', 'r', 'normalized', ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1', 'deflate', 'r', 'b', 'step', 'rate', 's', 't'], 778), ('[0]', 'r', 'normalized', ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1', 'deflate', 'r', 'b', 'step', 'rate', 's', 't'], 782), ('[0]', 'r', 'normalized', ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1', 'deflate', 'r', 'b', 'step', 'rate', 's', 't'], 783), ('[step][b]', 'r', 'normalized', ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1', 'deflate', 'r', 'b', 'step', 'rate', 's', 't'], 787)]
LDEs formed:0

vegaCaps -> [('[s]', 'w', 'normalized', ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1', 'deflate', 'r', 'b', 'step', 'rate', 's', 't'], 792), ('[s]', 'r', 'normalized', ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1', 'deflate', 'r', 'b', 'step', 'rate', 's', 't'], 794)]
LDEs formed:2

priceErrors -> [('[i]', 'w', 'normalized', ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1', 'deflate', 'r', 'b', 'step', 'rate', 's', 't'], 748)]
LDEs formed:1

todaysForwards -> [('[r]', 'r', 'normalized', ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1', 'deflate', 'r', 'b', 'step', 'rate', 's', 't'], 753), ('[r]', 'r', 'normalized', ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1', 'deflate', 'r', 'b', 'step', 'rate', 's', 't'], 757), ('[0]', 'r', 'normalized', ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1', 'deflate', 'r', 'b', 'step', 'rate', 's', 't'], 773), ('[r]', 'r', 'normalized', ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1', 'deflate', 'r', 'b', 'step', 'rate', 's', 't'], 789)]
LDEs formed:0

variances -> [('[rate]', 'w', 'normalized', ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1', 'deflate', 'r', 'b', 'step', 'rate', 's', 't'], 756), ('[r]', 'r', 'normalized', ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1', 'deflate', 'r', 'b', 'step', 'rate', 's', 't'], 757), ('[rate]', 'w', 'normalized', ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1', 'deflate', 'r', 'b', 'step', 'rate', 's', 't'], 788), ('[r]', 'r', 'normalized', ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1', 'deflate', 'r', 'b', 'step', 'rate', 's', 't'], 789)]
LDEs formed:7

truePrices -> [('[r]', 'w', 'normalized', ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1', 'deflate', 'r', 'b', 'step', 'rate', 's', 't'], 753), ('[r]', 'r', 'normalized', ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1', 'deflate', 'r', 'b', 'step', 'rate', 's', 't'], 759)]
LDEs formed:2

todaysDiscounts -> [('[initialNumeraire]', 'r', 'not normalized', ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1', 'deflate', 'r', 'b', 'step', 'rate', 's', 't'], 744), ('[r+1]', 'r', 'normalized', ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1', 'deflate', 'r', 'b', 'step', 'rate', 's', 't'], 754), ('[r+1]', 'r', 'normalized', ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1', 'deflate', 'r', 'b', 'step', 'rate', 's', 't'], 758), ('[initialNumeraire]', 'r', 'not normalized', ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1', 'deflate', 'r', 'b', 'step', 'rate', 's', 't'], 781), ('[r+1]', 'r', 'normalized', ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1', 'deflate', 'r', 'b', 'step', 'rate', 's', 't'], 790)]
LDEs formed:0

B4 -> [('[i1][j1]', 'w', 'normalized', ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1', 'deflate', 'r', 'b', 'step', 'rate', 's', 't'], 732), ('[i1][j1]', 'w', 'normalized', ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1', 'deflate', 'r', 'b', 'step', 'rate', 's', 't'], 733), ('[j][k]', 'r', 'normalized', ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1', 'deflate', 'r', 'b', 'step', 'rate', 's', 't'], 735), ('[j][k]', 'r', 'normalized', ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1', 'deflate', 'r', 'b', 'step', 'rate', 's', 't'], 738)]
LDEs formed:14

values -> [('[i*entriesPerProduct]', 'r', 'not normalized', ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1', 'deflate', 'r', 'b', 'step', 'rate', 's', 't'], 747), ('[i*entriesPerProduct + numberRates+1 + j]', 'r', 'not normalized', ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1', 'deflate', 'r', 'b', 'step', 'rate', 's', 't'], 749), ('[i*entriesPerProduct +1 + j]', 'r', 'not normalized', ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1', 'deflate', 'r', 'b', 'step', 'rate', 's', 't'], 751), ('[i*entriesPerProduct + numberRates+1 + j]', 'r', 'not normalized', ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1', 'deflate', 'r', 'b', 'step', 'rate', 's', 't'], 784)]
LDEs formed:0

bumpedPrices -> [('[r]', 'w', 'normalized', ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1', 'deflate', 'r', 'b', 'step', 'rate', 's', 't'], 757), ('[r]', 'r', 'normalized', ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1', 'deflate', 'r', 'b', 'step', 'rate', 's', 't'], 759)]
LDEs formed:2

B2 -> [('[j][k]', 'r', 'normalized', ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1', 'deflate', 'r', 'b', 'step', 'rate', 's', 't'], 736), ('[j][k]', 'r', 'normalized', ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1', 'deflate', 'r', 'b', 'step', 'rate', 's', 't'], 737), ('[j][k]', 'r', 'normalized', ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1', 'deflate', 'r', 'b', 'step', 'rate', 's', 't'], 738)]
LDEs formed:0

B3 -> [('[j][k]', 'r', 'normalized', ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1', 'deflate', 'r', 'b', 'step', 'rate', 's', 't'], 736)]
LDEs formed:0

marketModels -> [('[j]', 'r', 'normalized', ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1', 'deflate', 'r', 'b', 'step', 'rate', 's', 't'], 722), ('[j]', 'r', 'normalized', ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1', 'deflate', 'r', 'b', 'step', 'rate', 's', 't'], 740), ('[j]', 'r', 'normalized', ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1', 'deflate', 'r', 'b', 'step', 'rate', 's', 't'], 742), ('[j]', 'r', 'normalized', ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1', 'deflate', 'r', 'b', 'step', 'rate', 's', 't'], 777), ('[j]', 'r', 'normalized', ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1', 'deflate', 'r', 'b', 'step', 'rate', 's', 't'], 779)]
LDEs formed:0

numeraires -> [('[l]', 'r', 'normalized', ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1', 'deflate', 'r', 'b', 'step', 'rate', 's', 't'], 723), ('[l]', 'r', 'normalized', ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1', 'deflate', 'r', 'b', 'step', 'rate', 's', 't'], 724), ('[l]', 'r', 'normalized', ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1', 'deflate', 'r', 'b', 'step', 'rate', 's', 't'], 725), ('[l]', 'r', 'normalized', ['j', 'm', 'k', 'f', 'l', 'i', 'i1', 'j1', 'k1', 'deflate', 'r', 'b', 'step', 'rate', 's', 't'], 726)]
LDEs formed:0

distinct LDEs:
rate1=r2
s1=s2
i1=i2,j1=j2
i1=s2,j1=b2
r1=r2
rate1=rate2
i11=i12,j11=j12
0=0
r1=s2
i1=i2
k1=k2,f1=f2
i11=j2,j11=k2
i1=j2
#########################################################################################
loop info: Size i=0  i<todaysForwards.size()  ++i
induction variable: ['i']
{
L727: (payoffs[i]=,w) 
L728: (displacedPayoffs[i]=,w) 
}
array table
-----------------------------------------------
displacedPayoffs -> [('[i]', 'w', 'normalized', ['i'], 728)]
LDEs formed:1

payoffs -> [('[i]', 'w', 'normalized', ['i'], 727)]
LDEs formed:1

distinct LDEs:
i1=i2
#########################################################################################
loop info: Size j=0  j < caps.size()  ++j
induction variable: ['j']
{
L728: (startsAndEnds[j].first=,w) (caps[j].startIndex_,r) 
L729: (startsAndEnds[j].second=,w) (caps[j].endIndex_,r) 
}
array table
-----------------------------------------------
startsAndEnds -> [('[j]', 'w', 'normalized', ['j'], 728), ('[j]', 'w', 'normalized', ['j'], 729)]
LDEs formed:3

caps -> [('[j]', 'r', 'normalized', ['j'], 728), ('[j]', 'r', 'normalized', ['j'], 729)]
LDEs formed:0

distinct LDEs:
j1=j2
#########################################################################################
loop info: Size i=0  i < numberRates  ++i
induction variable: ['i']
{
L730: (swaptions[i].startIndex_=,w) 
L731: (swaptions[i].endIndex_=,w) 
}
array table
-----------------------------------------------
swaptions -> [('[i]', 'w', 'normalized', ['i'], 730), ('[i]', 'w', 'normalized', ['i'], 731)]
LDEs formed:3

distinct LDEs:
i1=i2
#########################################################################################
loop info: Size j=0  j<LENGTH(marketModels)  j++
induction variable: ['j']
{
	loop info: Size m=0  m<LENGTH(testedFactors)  ++m
	induction variable: ['j', 'm']
	{
	L732: (testedFactors[m],r) 
	L733: (marketModels[j],r) 
	L734: (theBumps[0].size,r) 
		loop info: Size i=0  i < swaptionsDeflated.numberOfProducts()  ++i
		induction variable: ['j', 'm', 'i']
			{
			L735: (swaptions[i].startIndex_,r) 
			L736: (swaptions[i].endIndex_,r) 
				loop info: Size j=0  j <  theBumps[0].size()  ++j
				induction variable: ['j', 'm', 'i']
				{
				L737: (swaptionVegasMatrix[i][j]=,w) 
					loop info: Size k=0  k < steps  ++k
					induction variable: ['j', 'm', 'i', 'k']
					{
					}
 				}
 			}
		loop info: Size i=0  i < swaptions.size()  ++i
		induction variable: ['j', 'm', 'i', 'k']
			{
				loop info: Size j=0  j <  theBumps[0].size()  ++j
				induction variable: ['j', 'm', 'i', 'k']
				{
				L738: (swaptionVegasMatrix[i][i]-,r) 
				L739: (swaptionVegasMatrix[i][j],r) 
				}
 			}
	L740: (theBumps[0].size,r) 
		loop info: Size i=0  i < caps.size()  ++i
		induction variable: ['j', 'm', 'i', 'k']
		{
		L741: (caps[i].strike_,r) 
		L742: (caps[i].startIndex_,r) 
		L743: (caps[i].endIndex_,r) 
			loop info: Size j=0  j <  theBumps[0].size()  ++j
			induction variable: ['j', 'm', 'i', 'k']
			{
			L744: (capsVegasMatrix[i][j]=,w) 
				loop info: Size k=0  k < steps  ++k
				induction variable: ['j', 'm', 'i', 'k']
				{
				}
 			}
 		}
		loop info: Size i=0  i < caps.size()  ++i
		induction variable: ['j', 'm', 'i', 'k']
		{
			loop info: Size j=0  j <  theBumps[0].size()  ++j
			induction variable: ['j', 'm', 'i', 'k']
			{
			L745: (capsVegasMatrix[i][j]-,r) 
			L746: (capsVegasMatrix[i][j],r) 
			}
 		}
 	}
 }
array table
-----------------------------------------------
swaptionVegasMatrix -> [('[i][j]', 'w', 'normalized', ['j', 'm', 'i', 'k'], 737), ('[i][i]', 'r', 'normalized', ['j', 'm', 'i', 'k'], 738), ('[i][j]', 'r', 'normalized', ['j', 'm', 'i', 'k'], 739)]
LDEs formed:6

swaptions -> [('[i]', 'r', 'normalized', ['j', 'm', 'i', 'k'], 735), ('[i]', 'r', 'normalized', ['j', 'm', 'i', 'k'], 736)]
LDEs formed:0

testedFactors -> [('[m]', 'r', 'normalized', ['j', 'm', 'i', 'k'], 732)]
LDEs formed:0

caps -> [('[i]', 'r', 'normalized', ['j', 'm', 'i', 'k'], 741), ('[i]', 'r', 'normalized', ['j', 'm', 'i', 'k'], 742), ('[i]', 'r', 'normalized', ['j', 'm', 'i', 'k'], 743)]
LDEs formed:0

capsVegasMatrix -> [('[i][j]', 'w', 'normalized', ['j', 'm', 'i', 'k'], 744), ('[i][j]', 'r', 'normalized', ['j', 'm', 'i', 'k'], 745), ('[i][j]', 'r', 'normalized', ['j', 'm', 'i', 'k'], 746)]
LDEs formed:6

theBumps -> [('[0]', 'r', 'normalized', ['j', 'm', 'i', 'k'], 734), ('[0]', 'r', 'normalized', ['j', 'm', 'i', 'k'], 740)]
LDEs formed:0

marketModels -> [('[j]', 'r', 'normalized', ['j', 'm', 'i', 'k'], 733)]
LDEs formed:0

distinct LDEs:
i1=i2,j1=i2
i1=i2,j1=j2
#########################################################################################
loop info: Size i=0  i < swaptionsDeflated.numberOfProducts()  ++i
induction variable: ['i']
{
L734: (cashFlowsGenerated1[i].resize,r) 
	loop info: Size j=0  j < swaptionsDeflated.maxNumberOfCashFlowsPerProductPerStep()  ++j
	induction variable: ['i', 'j']
	{
	}
 }
array table
-----------------------------------------------
cashFlowsGenerated1 -> [('[i]', 'r', 'normalized', ['i', 'j'], 734)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size j=0  j<LENGTH(marketModels)  j++
induction variable: ['j']
{
	loop info: Size m=0  m<LENGTH(testedFactors)  ++m
	induction variable: ['j', 'm']
	{
	L735: (testedFactors[m],r) 
	L736: (marketModels[j],r) 
		loop info: Size p=0  p < pathsToDo  ++p
		induction variable: ['j', 'm', 'p']
		{
			loop info: Size prod = 0  prod <  swaptionsDeflated.numberOfProducts()  ++prod
			induction variable: ['j', 'm', 'p', 'prod']
				{
				L737: (numberCashFlowsThisStep1[prod],r) (numberCashFlowsThisStep2[prod],r) 
					loop info: Size cf =0  cf < numberCashFlowsThisStep1[prod]  ++cf
					induction variable: ['j', 'm', 'p', 'prod', 'cf']
					{
					}
 				}
 		}
 	}
 }
array table
-----------------------------------------------
testedFactors -> [('[m]', 'r', 'normalized', ['j', 'm', 'p', 'prod', 'cf'], 735)]
LDEs formed:0

numberCashFlowsThisStep1 -> [('[prod]', 'r', 'normalized', ['j', 'm', 'p', 'prod', 'cf'], 737)]
LDEs formed:0

marketModels -> [('[j]', 'r', 'normalized', ['j', 'm', 'p', 'prod', 'cf'], 736)]
LDEs formed:0

numberCashFlowsThisStep2 -> [('[prod]', 'r', 'normalized', ['j', 'm', 'p', 'prod', 'cf'], 737)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size j=0  j<LENGTH(marketModels)  j++
induction variable: ['j']
{
	loop info: Size m=0  m<LENGTH(testedFactors)  ++m
	induction variable: ['j', 'm']
	{
	L738: (testedFactors[m],r) 
	L739: (marketModels[j],r) 
	L740: (todaysDiscounts[initialNumeraire],r) 
	L741: (theBumps[0].size,r) 
	L742: (theBumps[0].size,r) 
		loop info: Size i=0  i < swaptionsDeflated.numberOfProducts()  ++i
		induction variable: ['j', 'm', 'i']
		{
		L743: (vegasMatrix[i][j]=,w) (values[i*entriesPerProduct + numberRates+1+j],r) 
		L744: (standardErrors[i][j]=,w) (errors[i*entriesPerProduct + numberRates+1 +j],r) 
		}
		loop info: Size i=0  i < swaptions.size()  ++i
		induction variable: ['j', 'm', 'i']
		{
		}
		loop info: Size i=0  i < swaptions.size()  ++i
		induction variable: ['j', 'm', 'i']
		{
		L745: (rateTimes[i],r) 
		L746: (impliedVols_[i]*,r) 
		L747: (analyticVegas[i]=,w) 
		}
		loop info: Size i=0  i < swaptions.size()  ++i
		induction variable: ['j', 'm', 'i']
		{
		L748: (vegasMatrix[i][i]-,r) (analyticVegas[i],r) 
		L749: (standardErrors[i][i]+,r) 
		}
		loop info: Size i=0  i < swaptions.size()  ++i
		induction variable: ['j', 'm', 'i']
		{
		L750: (vegasMatrix[i][j],r) 
		L751: (standardErrors[i][j]+,r) 
		}
 	}
 }
array table
-----------------------------------------------
errors -> [('[i*entriesPerProduct + numberRates+1 +j]', 'r', 'not normalized', ['j', 'm', 'i'], 744)]
LDEs formed:0

impliedVols_ -> [('[i]', 'r', 'normalized', ['j', 'm', 'i'], 746)]
LDEs formed:0

testedFactors -> [('[m]', 'r', 'normalized', ['j', 'm', 'i'], 738)]
LDEs formed:0

todaysDiscounts -> [('[initialNumeraire]', 'r', 'not normalized', ['j', 'm', 'i'], 740)]
LDEs formed:0

analyticVegas -> [('[i]', 'w', 'normalized', ['j', 'm', 'i'], 747), ('[i]', 'r', 'normalized', ['j', 'm', 'i'], 748)]
LDEs formed:2

values -> [('[i*entriesPerProduct + numberRates+1+j]', 'r', 'not normalized', ['j', 'm', 'i'], 743)]
LDEs formed:0

rateTimes -> [('[i]', 'r', 'normalized', ['j', 'm', 'i'], 745)]
LDEs formed:0

theBumps -> [('[0]', 'r', 'normalized', ['j', 'm', 'i'], 741), ('[0]', 'r', 'normalized', ['j', 'm', 'i'], 742)]
LDEs formed:0

marketModels -> [('[j]', 'r', 'normalized', ['j', 'm', 'i'], 739)]
LDEs formed:0

standardErrors -> [('[i][j]', 'w', 'normalized', ['j', 'm', 'i'], 744), ('[i][i]', 'r', 'normalized', ['j', 'm', 'i'], 749), ('[i][j]', 'r', 'normalized', ['j', 'm', 'i'], 751)]
LDEs formed:6

vegasMatrix -> [('[i][j]', 'w', 'normalized', ['j', 'm', 'i'], 743), ('[i][i]', 'r', 'normalized', ['j', 'm', 'i'], 748), ('[i][j]', 'r', 'normalized', ['j', 'm', 'i'], 750)]
LDEs formed:6

distinct LDEs:
i1=i2,j1=i2
i1=i2,j1=j2
i1=i2
#########################################################################################
loop info: Size j=0  j<LENGTH(marketModels)  j++
induction variable: ['j']
{
	loop info: Size m=0  m<LENGTH(testedFactors)  ++m
	induction variable: ['j', 'm']
	{
	L751: (testedFactors[m],r) 
	L752: (marketModels[j],r) 
	L753: (todaysDiscounts[initialNumeraire],r) 
	L754: (theBumps[0].size,r) 
	L755: (theBumps[0].size,r) 
		loop info: Size i=0  i < capsDeflated.numberOfProducts()  ++i
		induction variable: ['j', 'm', 'i']
		{
		L756: (vegasMatrix[i][j]=,w) (values[i*entriesPerProduct +numberRates+j+1],r) 
		L757: (standardErrors[i][j]=,w) (errors[i*entriesPerProduct +numberRates+j+1],r) 
		}
		loop info: Size i=0  i < caps.size()  ++i
		induction variable: ['j', 'm', 'i']
		{
		L758: (caps[i].strike_,r) 
		L759: (caps[i].startIndex_,r) 
		L760: (caps[i].endIndex_,r) 
		L761: (impliedVols_[i]=,w) 
			loop info: Size j= caps[i].startIndex_  j< caps[i].endIndex_  ++j
			induction variable: ['j', 'm', 'i']
			{
			L762: (accruals[j],r) 
			L763: (rateTimes[j],r) 
			L764: (impliedVols_[i]*,r) 
			L765: (caps[i].strike_,r) 
			}
		L766: (analyticVegas[i]=,w) 
		}
		loop info: Size i=0  i < caps.size()  ++i
		induction variable: ['j', 'm', 'i']
		{
		L767: (vegasMatrix[i][i+swaptions.size()]-,r) (analyticVegas[i],r) 
		L768: (standardErrors[i][i+swaptions.size()]+,r) 
		L769: (vegasMatrix[i][i+swaptions.size()]<<,r) (analyticVegas[i]<<,r) 
		}
		loop info: Size i=0  i < caps.size()  ++i
		induction variable: ['j', 'm', 'i']
		{
		L770: (vegasMatrix[i][j],r) 
		L771: (standardErrors[i][j]+,r) 
		}
 	}
 }
array table
-----------------------------------------------
errors -> [('[i*entriesPerProduct +numberRates+j+1]', 'r', 'not normalized', ['j', 'm', 'i'], 757)]
LDEs formed:0

rateTimes -> [('[j]', 'r', 'normalized', ['j', 'm', 'i'], 763)]
LDEs formed:0

testedFactors -> [('[m]', 'r', 'normalized', ['j', 'm', 'i'], 751)]
LDEs formed:0

todaysDiscounts -> [('[initialNumeraire]', 'r', 'not normalized', ['j', 'm', 'i'], 753)]
LDEs formed:0

caps -> [('[i]', 'r', 'normalized', ['j', 'm', 'i'], 758), ('[i]', 'r', 'normalized', ['j', 'm', 'i'], 759), ('[i]', 'r', 'normalized', ['j', 'm', 'i'], 760), ('[i]', 'r', 'normalized', ['j', 'm', 'i'], 765)]
LDEs formed:0

analyticVegas -> [('[i]', 'w', 'normalized', ['j', 'm', 'i'], 766), ('[i]', 'r', 'normalized', ['j', 'm', 'i'], 767), ('[i]', 'r', 'normalized', ['j', 'm', 'i'], 769)]
LDEs formed:3

values -> [('[i*entriesPerProduct +numberRates+j+1]', 'r', 'not normalized', ['j', 'm', 'i'], 756)]
LDEs formed:0

impliedVols_ -> [('[i]', 'w', 'normalized', ['j', 'm', 'i'], 761), ('[i]', 'r', 'normalized', ['j', 'm', 'i'], 764)]
LDEs formed:2

theBumps -> [('[0]', 'r', 'normalized', ['j', 'm', 'i'], 754), ('[0]', 'r', 'normalized', ['j', 'm', 'i'], 755)]
LDEs formed:0

marketModels -> [('[j]', 'r', 'normalized', ['j', 'm', 'i'], 752)]
LDEs formed:0

standardErrors -> [('[i][j]', 'w', 'normalized', ['j', 'm', 'i'], 757), ('[i][i+swaptions.size()]', 'r', 'not normalized', ['j', 'm', 'i'], 768), ('[i][j]', 'r', 'normalized', ['j', 'm', 'i'], 771)]
LDEs formed:6

accruals -> [('[j]', 'r', 'normalized', ['j', 'm', 'i'], 762)]
LDEs formed:0

vegasMatrix -> [('[i][j]', 'w', 'normalized', ['j', 'm', 'i'], 756), ('[i][i+swaptions.size()]', 'r', 'not normalized', ['j', 'm', 'i'], 767), ('[i][i+swaptions.size()]', 'r', 'not normalized', ['j', 'm', 'i'], 769), ('[i][j]', 'r', 'normalized', ['j', 'm', 'i'], 770)]
LDEs formed:8

distinct LDEs:
i1=i2,j1=i2+swaptions.size()
i1=i2,j1=j2
i1=i2
#########################################################################################
loop info: i1=0  i1<rateTimes.size()  i1++ 
induction variable: ['i1']
{
	loop info: i2=0  i2<rateTimes.size()  i2++ 
	induction variable: ['i1', 'i2']
	{
	L771: (rateTimes[i1],r) (rateTimes[i2],r) 
	L772: (rateTimes[i1]<<,r) 
	L773: (rateTimes[i2]<<,r) 
	L774: (rateTimes[i1],r) (rateTimes[i2],r) 
	}
 }
array table
-----------------------------------------------
rateTimes -> [('[i1]', 'r', 'normalized', ['i1', 'i2'], 771), ('[i2]', 'r', 'normalized', ['i1', 'i2'], 771), ('[i1]', 'r', 'normalized', ['i1', 'i2'], 772), ('[i2]', 'r', 'normalized', ['i1', 'i2'], 773), ('[i1]', 'r', 'normalized', ['i1', 'i2'], 774), ('[i2]', 'r', 'normalized', ['i1', 'i2'], 774)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<blackVols.size()  i++
induction variable: ['i']
{
L775: (k[i]-,r) 
L776: (rateTimes[i],r) (rateTimes[i],r) 
L777: (rateTimes[i]<<,r) 
L778: (blackVols[i],r) 
L779: (k[i]<<,r) 
L780: (k[i]-,r) 
}
array table
-----------------------------------------------
rateTimes -> [('[i]', 'r', 'normalized', ['i'], 776), ('[i]', 'r', 'normalized', ['i'], 776), ('[i]', 'r', 'normalized', ['i'], 777)]
LDEs formed:0

k -> [('[i]', 'r', 'normalized', ['i'], 775), ('[i]', 'r', 'normalized', ['i'], 779), ('[i]', 'r', 'normalized', ['i'], 780)]
LDEs formed:0

blackVols -> [('[i]', 'r', 'normalized', ['i'], 778)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<todaysForwards.size()  ++i
induction variable: ['i']
{
L779: (forwardStrikes[i]=,w) (todaysForwards[i]+,r) 
L780: (optionletPayoffs[i]=,w) 
L781: (todaysForwards[i],r) 
L782: (displacedPayoffs[i]=,w) 
L783: (todaysForwards[i]+,r) 
}
array table
-----------------------------------------------
displacedPayoffs -> [('[i]', 'w', 'normalized', ['i'], 782)]
LDEs formed:1

forwardStrikes -> [('[i]', 'w', 'normalized', ['i'], 779)]
LDEs formed:1

optionletPayoffs -> [('[i]', 'w', 'normalized', ['i'], 780)]
LDEs formed:1

todaysForwards -> [('[i]', 'r', 'normalized', ['i'], 779), ('[i]', 'r', 'normalized', ['i'], 781), ('[i]', 'r', 'normalized', ['i'], 783)]
LDEs formed:0

distinct LDEs:
i1=i2
#########################################################################################
loop info: Size j=0  j<LENGTH(marketModels)  j++
induction variable: ['j']
{
	loop info: Size m=0  m<LENGTH(testedFactors)  ++m
	induction variable: ['j', 'm']
	{
	L784: (testedFactors[m],r) 
		loop info: Size k=0  k<LENGTH(measures)  k++
		induction variable: ['j', 'm', 'k']
		{
		L785: (measures[k],r) 
		L786: (marketModels[j],r) 
			loop info: Size n=0  n<1  n++
			induction variable: ['j', 'm', 'k', 'n']
			{
			L787: (marketModels[j],r) 
			L788: (measures[k],r) 
				loop info: Size i=0  i < accruals.size()  ++i
				induction variable: ['j', 'm', 'k', 'n', 'i']
				{
				L789: (todaysDiscounts[i]-,r) (todaysDiscounts[i+1]*,r) (forwardStrikes[i]*,r) (accruals[i],r) 
				L790: (results[i]-,r) 
				L791: (errors[i],r) 
				L792: (results[i]<<,r) (errors[i],r) 
				}
				loop info: Size i=0  i < accruals.size()  ++i
				induction variable: ['j', 'm', 'k', 'n', 'i']
				{
				L793: (volatilities[i],r) 
				L794: (forwardStrikes[i],r) 
				L795: (todaysForwards[i]+,r) 
				L796: (todaysForwards[i]+,r) 
				L797: (rateTimes[i],r) 
				L798: (accruals[i]*,r) (todaysDiscounts[i+1],r) 
				L799: (displacedPayoffs[i],r) 
				L800: (todaysForwards[i]+,r) 
				L801: (volatilities[i]*,r) (rateTimes[i],r) 
				L802: (todaysDiscounts[i+1]*,r) (accruals[i],r) 
				L803: (results[i+ accruals.size()]-,r) 
				L804: (errors[i],r) 
				L805: (results[i+ accruals.size()]<<,r) (errors[i],r) 
				}
 			}
 		}
 	}
 }
array table
-----------------------------------------------
volatilities -> [('[i]', 'r', 'normalized', ['j', 'm', 'k', 'n', 'i'], 793), ('[i]', 'r', 'normalized', ['j', 'm', 'k', 'n', 'i'], 801)]
LDEs formed:0

errors -> [('[i]', 'r', 'normalized', ['j', 'm', 'k', 'n', 'i'], 791), ('[i]', 'r', 'normalized', ['j', 'm', 'k', 'n', 'i'], 792), ('[i]', 'r', 'normalized', ['j', 'm', 'k', 'n', 'i'], 804), ('[i]', 'r', 'normalized', ['j', 'm', 'k', 'n', 'i'], 805)]
LDEs formed:0

todaysForwards -> [('[i]', 'r', 'normalized', ['j', 'm', 'k', 'n', 'i'], 795), ('[i]', 'r', 'normalized', ['j', 'm', 'k', 'n', 'i'], 796), ('[i]', 'r', 'normalized', ['j', 'm', 'k', 'n', 'i'], 800)]
LDEs formed:0

testedFactors -> [('[m]', 'r', 'normalized', ['j', 'm', 'k', 'n', 'i'], 784)]
LDEs formed:0

forwardStrikes -> [('[i]', 'r', 'normalized', ['j', 'm', 'k', 'n', 'i'], 789), ('[i]', 'r', 'normalized', ['j', 'm', 'k', 'n', 'i'], 794)]
LDEs formed:0

measures -> [('[k]', 'r', 'normalized', ['j', 'm', 'k', 'n', 'i'], 785), ('[k]', 'r', 'normalized', ['j', 'm', 'k', 'n', 'i'], 788)]
LDEs formed:0

todaysDiscounts -> [('[i]', 'r', 'normalized', ['j', 'm', 'k', 'n', 'i'], 789), ('[i+1]', 'r', 'normalized', ['j', 'm', 'k', 'n', 'i'], 789), ('[i+1]', 'r', 'normalized', ['j', 'm', 'k', 'n', 'i'], 798), ('[i+1]', 'r', 'normalized', ['j', 'm', 'k', 'n', 'i'], 802)]
LDEs formed:0

results -> [('[i]', 'r', 'normalized', ['j', 'm', 'k', 'n', 'i'], 790), ('[i]', 'r', 'normalized', ['j', 'm', 'k', 'n', 'i'], 792), ('[i+ accruals.size()]', 'r', 'not normalized', ['j', 'm', 'k', 'n', 'i'], 803), ('[i+ accruals.size()]', 'r', 'not normalized', ['j', 'm', 'k', 'n', 'i'], 805)]
LDEs formed:0

displacedPayoffs -> [('[i]', 'r', 'normalized', ['j', 'm', 'k', 'n', 'i'], 799)]
LDEs formed:0

rateTimes -> [('[i]', 'r', 'normalized', ['j', 'm', 'k', 'n', 'i'], 797), ('[i]', 'r', 'normalized', ['j', 'm', 'k', 'n', 'i'], 801)]
LDEs formed:0

marketModels -> [('[j]', 'r', 'normalized', ['j', 'm', 'k', 'n', 'i'], 786), ('[j]', 'r', 'normalized', ['j', 'm', 'k', 'n', 'i'], 787)]
LDEs formed:0

accruals -> [('[i]', 'r', 'normalized', ['j', 'm', 'k', 'n', 'i'], 789), ('[i]', 'r', 'normalized', ['j', 'm', 'k', 'n', 'i'], 798), ('[i]', 'r', 'normalized', ['j', 'm', 'k', 'n', 'i'], 802)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size k=0  k<LENGTH(marketModels)  ++k
induction variable: ['k']
{
L803: (marketModels[k],r) 
	loop info: Size j=0  j<numberOfSteps  ++j
	induction variable: ['k', 'j']
	{
	L804: (alive[j],r) 
		loop info: Size h=inf  h<numeraires.size()  ++h
		induction variable: ['k', 'j', 'h']
		{
		L805: (numeraires[h],r) (alive[j],r) 
			loop info: Size i=0  i<drifts.size()  ++i
			induction variable: ['k', 'j', 'h', 'i']
			{
			L806: (driftsReduced[i]-,r) (drifts[i],r) 
			L807: (marketModels[k],r) 
			L808: (drifts[i]<<,r) 
			L809: (driftsReduced[i]<<,r) 
			}
 		}
 	}
 }
array table
-----------------------------------------------
drifts -> [('[i]', 'r', 'normalized', ['k', 'j', 'h', 'i'], 806), ('[i]', 'r', 'normalized', ['k', 'j', 'h', 'i'], 808)]
LDEs formed:0

marketModels -> [('[k]', 'r', 'normalized', ['k', 'j', 'h', 'i'], 803), ('[k]', 'r', 'normalized', ['k', 'j', 'h', 'i'], 807)]
LDEs formed:0

numeraires -> [('[h]', 'r', 'normalized', ['k', 'j', 'h', 'i'], 805)]
LDEs formed:0

alive -> [('[j]', 'r', 'normalized', ['k', 'j', 'h', 'i'], 804), ('[j]', 'r', 'normalized', ['k', 'j', 'h', 'i'], 805)]
LDEs formed:0

driftsReduced -> [('[i]', 'r', 'normalized', ['k', 'j', 'h', 'i'], 806), ('[i]', 'r', 'normalized', ['k', 'j', 'h', 'i'], 809)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<dim  i++
induction variable: ['i']
{
L810: (set[" << i << "]=,w) (set[i]<<,r) 
L811: (subset[" << i << "]=,w) (subset[i]<<,r) 
L812: (result[" << i << "]=,w) (result[i],r) 
}
array table
-----------------------------------------------
subset -> [('[" << i << "]', 'w', 'normalized', ['i'], 811), ('[i]', 'r', 'normalized', ['i'], 811)]
LDEs formed:2

set -> [('[" << i << "]', 'w', 'normalized', ['i'], 810), ('[i]', 'r', 'normalized', ['i'], 810)]
LDEs formed:2

result -> [('[" << i << "]', 'w', 'normalized', ['i'], 812), ('[i]', 'r', 'normalized', ['i'], 812)]
LDEs formed:2

distinct LDEs:
" << i1 << "=" << i2 << "
" << i1 << "=i2
#########################################################################################
loop info: Size k=0 k<modelNames.size() k++
induction variable: ['k']
{
	loop info: Size l=0 l<evolNames.size() l++
	induction variable: ['k', 'l']
	{
	L813: (evolTimes[l],r) 
	L814: (modelNames[k],r) 
		loop info: Size i=0 i<evolTimes[l].size() i++
		induction variable: ['k', 'l', 'i']
			{
			L815: (evolTimes[l][i]-,r) (evolTimes[l][i-1],r) 
				loop info: Size x=0 x<n-1 x++
				induction variable: ['k', 'l', 'i', 'x']
				{
					loop info: Size y=0 y<n-1 y++
					induction variable: ['k', 'l', 'i', 'x', 'y']
					{
					L816: (rateTimes[x],r) (rateTimes[y],r) (evolTimes[l][i],r) 
					L817: (cov[x][y]-,r) (c[x][y]*,r) 
					L818: (modelNames[k],r) 
					L819: (evolNames[l],r) 
					L820: (c[x][y]*,r) 
					L821: (cov[x][y],r) 
					}
 				}
 			}
 	}
 }
array table
-----------------------------------------------
c -> [('[x][y]', 'r', 'normalized', ['k', 'l', 'i', 'x', 'y'], 817), ('[x][y]', 'r', 'normalized', ['k', 'l', 'i', 'x', 'y'], 820)]
LDEs formed:0

evolTimes -> [('[l]', 'r', 'normalized', ['k', 'l', 'i', 'x', 'y'], 813), ('[l][i]', 'r', 'normalized', ['k', 'l', 'i', 'x', 'y'], 815), ('[l][i-1]', 'r', 'normalized', ['k', 'l', 'i', 'x', 'y'], 815), ('[l][i]', 'r', 'normalized', ['k', 'l', 'i', 'x', 'y'], 816)]
LDEs formed:0

cov -> [('[x][y]', 'r', 'normalized', ['k', 'l', 'i', 'x', 'y'], 817), ('[x][y]', 'r', 'normalized', ['k', 'l', 'i', 'x', 'y'], 821)]
LDEs formed:0

modelNames -> [('[k]', 'r', 'normalized', ['k', 'l', 'i', 'x', 'y'], 814), ('[k]', 'r', 'normalized', ['k', 'l', 'i', 'x', 'y'], 818)]
LDEs formed:0

rateTimes -> [('[x]', 'r', 'normalized', ['k', 'l', 'i', 'x', 'y'], 816), ('[y]', 'r', 'normalized', ['k', 'l', 'i', 'x', 'y'], 816)]
LDEs formed:0

evolNames -> [('[l]', 'r', 'normalized', ['k', 'l', 'i', 'x', 'y'], 819)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/marketmodel_smmcapletalphacalibration.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<todaysForwards_.size()  ++i
induction variable: ['i']
{
L820: (todaysForwards_[i]=,w) 
L821: (todaysForwards_[i]=,w) 
}
array table
-----------------------------------------------
todaysForwards_ -> [('[i]', 'w', 'normalized', ['i'], 820), ('[i]', 'w', 'normalized', ['i'], 821)]
LDEs formed:3

distinct LDEs:
i1=i2
#########################################################################################
loop info: Size i=0  i<todaysSwaps_.size()  i++
induction variable: ['i']
{
L822: (swaptionDisplacedVols[i]=,w) (todaysSwaps[i]*,r) (mktSwaptionVols[i]/,r) 
L823: (todaysSwaps[i]+,r) 
L824: (swaptionVols[i]=,w) (mktSwaptionVols[i],r) 
L825: (capletDisplacedVols[i]=,w) (todaysForwards[i]*,r) (mktCapletVols[i]/,r) 
L826: (todaysForwards[i]+,r) 
L827: (capletVols_[i]=,w) (mktCapletVols[i],r) 
}
array table
-----------------------------------------------
todaysForwards -> [('[i]', 'r', 'normalized', ['i'], 825), ('[i]', 'r', 'normalized', ['i'], 826)]
LDEs formed:0

todaysSwaps -> [('[i]', 'r', 'normalized', ['i'], 822), ('[i]', 'r', 'normalized', ['i'], 823)]
LDEs formed:0

capletDisplacedVols -> [('[i]', 'w', 'normalized', ['i'], 825)]
LDEs formed:1

swaptionDisplacedVols -> [('[i]', 'w', 'normalized', ['i'], 822)]
LDEs formed:1

swaptionVols -> [('[i]', 'w', 'normalized', ['i'], 824)]
LDEs formed:1

capletVols_ -> [('[i]', 'w', 'normalized', ['i'], 827)]
LDEs formed:1

mktCapletVols -> [('[i]', 'r', 'normalized', ['i'], 825), ('[i]', 'r', 'normalized', ['i'], 827)]
LDEs formed:0

mktSwaptionVols -> [('[i]', 'r', 'normalized', ['i'], 822), ('[i]', 'r', 'normalized', ['i'], 824)]
LDEs formed:0

distinct LDEs:
i1=i2
#########################################################################################
loop info: Size i=0  i<numberOfRates  ++i
induction variable: ['i']
{
L825: (swapVariances[i]=,w) 
}
array table
-----------------------------------------------
swapVariances -> [('[i]', 'w', 'normalized', ['i'], 825)]
LDEs formed:1

distinct LDEs:
i1=i2
#########################################################################################
loop info: Size i=0  i<numberOfRates  ++i
induction variable: ['i']
{
L826: (capletVols[i]=,w) (capletTotCovariance[i][i]/,r) (rateTimes_[i],r) 
}
array table
-----------------------------------------------
capletVols -> [('[i]', 'w', 'normalized', ['i'], 826)]
LDEs formed:1

capletTotCovariance -> [('[i][i]', 'r', 'normalized', ['i'], 826)]
LDEs formed:0

rateTimes_ -> [('[i]', 'r', 'normalized', ['i'], 826)]
LDEs formed:0

distinct LDEs:
i1=i2
#########################################################################################
loop info: Size i=0  i<numberOfRates  ++i
induction variable: ['i']
{
L827: (swapVariances[i]-,r) 
L828: (swapPseudoRoots[i]*,r) (swapPseudoRoots[i],r) 
L829: (swapTerminalCovariance[i][i]/,r) (rateTimes_[i],r) 
}
array table
-----------------------------------------------
swapTerminalCovariance -> [('[i][i]', 'r', 'normalized', ['i'], 829)]
LDEs formed:0

swapPseudoRoots -> [('[i]', 'r', 'normalized', ['i'], 828), ('[i]', 'r', 'normalized', ['i'], 828)]
LDEs formed:0

swapVariances -> [('[i]', 'r', 'normalized', ['i'], 827)]
LDEs formed:0

rateTimes_ -> [('[i]', 'r', 'normalized', ['i'], 829)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<numberOfRates  ++i
induction variable: ['i']
{
L830: (capletVols[i]-,r) (capletVols_[i],r) 
L831: (capletVols_[i],r) 
L832: (capletVols[i],r) 
L833: (capletVols_[i]<<,r) 
}
array table
-----------------------------------------------
capletVols -> [('[i]', 'r', 'normalized', ['i'], 830), ('[i]', 'r', 'normalized', ['i'], 832)]
LDEs formed:0

capletVols_ -> [('[i]', 'r', 'normalized', ['i'], 830), ('[i]', 'r', 'normalized', ['i'], 831), ('[i]', 'r', 'normalized', ['i'], 833)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/blackformula.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0 i<LENGTH(d) ++i
induction variable: ['i']
{
L834: (d[i]*,r) 
}
array table
-----------------------------------------------
d -> [('[i]', 'r', 'normalized', ['i'], 834)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i1 = 0  i1 < LENGTH(types)  ++i1
induction variable: ['i1']
{
	loop info: Size i2 = 0  i2 < LENGTH(displacements)  ++i2
	induction variable: ['i1', 'i2']
	{
		loop info: Size i3 = 0  i3 < LENGTH(forwards)  ++i3
		induction variable: ['i1', 'i2', 'i3']
		{
			loop info: Size i4 = 0  i4 < LENGTH(strikes)  ++i4
			induction variable: ['i1', 'i2', 'i3', 'i4']
			{
				loop info: Size i5 = 0  i5 < LENGTH(stdDevs)  ++i5
				induction variable: ['i1', 'i2', 'i3', 'i4', 'i5']
				{
					loop info: Size i6 = 0  i6 < LENGTH(discounts)  ++i6
					induction variable: ['i1', 'i2', 'i3', 'i4', 'i5', 'i6']
					{
					L835: (forwards[i3]+,r) (displacements[i2],r) 
					L836: (strikes[i4]+,r) (displacements[i2],r) 
					L837: (types[i1],r) (strikes[i4],r) (forwards[i3],r) 
					L838: (stdDevs[i5],r) (discounts[i6],r) 
					L839: (displacements[i2],r) 
					L840: (types[i1],r) (forwards[i3],r) (forwards[i3],r) 
					L841: (stdDevs[i5],r) (discounts[i6],r) 
					L842: (displacements[i2],r) 
					L843: (types[i1],r) (strikes[i4],r) (forwards[i3],r) 
					L844: (discounts[i6],r) 
					L845: (displacements[i2],r) 
					L846: (strikes[i4]+,r) (displacements[i2],r) 
					L847: (forwards[i3]+,r) (displacements[i2],r) 
					L848: (stdDevs[i5],r) (stdDevs[i5]*,r) 
					L849: (types[i1],r) 
					L850: (displacements[i2],r) 
					L851: (forwards[i3],r) 
					L852: (strikes[i4],r) 
					L853: (discounts[i6],r) 
					L854: (stdDevs[i5],r) 
					}
 				}
 			}
 		}
 	}
 }
array table
-----------------------------------------------
stdDevs -> [('[i5]', 'r', 'normalized', ['i1', 'i2', 'i3', 'i4', 'i5', 'i6'], 838), ('[i5]', 'r', 'normalized', ['i1', 'i2', 'i3', 'i4', 'i5', 'i6'], 841), ('[i5]', 'r', 'normalized', ['i1', 'i2', 'i3', 'i4', 'i5', 'i6'], 848), ('[i5]', 'r', 'normalized', ['i1', 'i2', 'i3', 'i4', 'i5', 'i6'], 848), ('[i5]', 'r', 'normalized', ['i1', 'i2', 'i3', 'i4', 'i5', 'i6'], 854)]
LDEs formed:0

forwards -> [('[i3]', 'r', 'normalized', ['i1', 'i2', 'i3', 'i4', 'i5', 'i6'], 835), ('[i3]', 'r', 'normalized', ['i1', 'i2', 'i3', 'i4', 'i5', 'i6'], 837), ('[i3]', 'r', 'normalized', ['i1', 'i2', 'i3', 'i4', 'i5', 'i6'], 840), ('[i3]', 'r', 'normalized', ['i1', 'i2', 'i3', 'i4', 'i5', 'i6'], 840), ('[i3]', 'r', 'normalized', ['i1', 'i2', 'i3', 'i4', 'i5', 'i6'], 843), ('[i3]', 'r', 'normalized', ['i1', 'i2', 'i3', 'i4', 'i5', 'i6'], 847), ('[i3]', 'r', 'normalized', ['i1', 'i2', 'i3', 'i4', 'i5', 'i6'], 851)]
LDEs formed:0

strikes -> [('[i4]', 'r', 'normalized', ['i1', 'i2', 'i3', 'i4', 'i5', 'i6'], 836), ('[i4]', 'r', 'normalized', ['i1', 'i2', 'i3', 'i4', 'i5', 'i6'], 837), ('[i4]', 'r', 'normalized', ['i1', 'i2', 'i3', 'i4', 'i5', 'i6'], 843), ('[i4]', 'r', 'normalized', ['i1', 'i2', 'i3', 'i4', 'i5', 'i6'], 846), ('[i4]', 'r', 'normalized', ['i1', 'i2', 'i3', 'i4', 'i5', 'i6'], 852)]
LDEs formed:0

discounts -> [('[i6]', 'r', 'normalized', ['i1', 'i2', 'i3', 'i4', 'i5', 'i6'], 838), ('[i6]', 'r', 'normalized', ['i1', 'i2', 'i3', 'i4', 'i5', 'i6'], 841), ('[i6]', 'r', 'normalized', ['i1', 'i2', 'i3', 'i4', 'i5', 'i6'], 844), ('[i6]', 'r', 'normalized', ['i1', 'i2', 'i3', 'i4', 'i5', 'i6'], 853)]
LDEs formed:0

displacements -> [('[i2]', 'r', 'normalized', ['i1', 'i2', 'i3', 'i4', 'i5', 'i6'], 835), ('[i2]', 'r', 'normalized', ['i1', 'i2', 'i3', 'i4', 'i5', 'i6'], 836), ('[i2]', 'r', 'normalized', ['i1', 'i2', 'i3', 'i4', 'i5', 'i6'], 839), ('[i2]', 'r', 'normalized', ['i1', 'i2', 'i3', 'i4', 'i5', 'i6'], 842), ('[i2]', 'r', 'normalized', ['i1', 'i2', 'i3', 'i4', 'i5', 'i6'], 845), ('[i2]', 'r', 'normalized', ['i1', 'i2', 'i3', 'i4', 'i5', 'i6'], 846), ('[i2]', 'r', 'normalized', ['i1', 'i2', 'i3', 'i4', 'i5', 'i6'], 847), ('[i2]', 'r', 'normalized', ['i1', 'i2', 'i3', 'i4', 'i5', 'i6'], 850)]
LDEs formed:0

types -> [('[i1]', 'r', 'normalized', ['i1', 'i2', 'i3', 'i4', 'i5', 'i6'], 837), ('[i1]', 'r', 'normalized', ['i1', 'i2', 'i3', 'i4', 'i5', 'i6'], 840), ('[i1]', 'r', 'normalized', ['i1', 'i2', 'i3', 'i4', 'i5', 'i6'], 843), ('[i1]', 'r', 'normalized', ['i1', 'i2', 'i3', 'i4', 'i5', 'i6'], 849)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/functions.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i < LENGTH(tasks)  ++i
induction variable: ['i']
{
L850: (tasks[i][0],r) 
L851: (tasks[i][1],r) 
L852: (tasks[i][2]*,r) 
}
array table
-----------------------------------------------
tasks -> [('[i][0]', 'r', 'normalized', ['i'], 850), ('[i][1]', 'r', 'normalized', ['i'], 851), ('[i][2]', 'r', 'normalized', ['i'], 852)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i < LENGTH(r)  ++i
induction variable: ['i']
{
L853: (r[i][0],r) 
L854: (r[i][1],r) 
L855: (r[i][2],r) 
L856: (r[i][3],r) 
}
array table
-----------------------------------------------
r -> [('[i][0]', 'r', 'normalized', ['i'], 853), ('[i][1]', 'r', 'normalized', ['i'], 854), ('[i][2]', 'r', 'normalized', ['i'], 855), ('[i][3]', 'r', 'normalized', ['i'], 856)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i < LENGTH(c)  ++i
induction variable: ['i']
{
L857: (c[i][0],r) 
L858: (c[i][1],r) (c[i][2],r) 
L859: (c[i][3],r) (c[i][4],r) 
L860: (c[i][5],r) (c[i][6],r) 
}
array table
-----------------------------------------------
c -> [('[i][0]', 'r', 'normalized', ['i'], 857), ('[i][1]', 'r', 'normalized', ['i'], 858), ('[i][2]', 'r', 'normalized', ['i'], 858), ('[i][3]', 'r', 'normalized', ['i'], 859), ('[i][4]', 'r', 'normalized', ['i'], 859), ('[i][5]', 'r', 'normalized', ['i'], 860), ('[i][6]', 'r', 'normalized', ['i'], 860)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/forwardoption.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<LENGTH(values)  i++
induction variable: ['i']
{
L861: (values[i].type,r) 
L862: (values[i].t*,r) 
L863: (values[i].start*,r) 
L864: (values[i].s,r) 
L865: (values[i].q,r) 
L866: (values[i].r,r) 
L867: (values[i].v,r) 
L868: (values[i].moneyness,r) 
L869: (values[i].result,r) 
L870: (values[i].s,r) 
L871: (values[i].q,r) (values[i].r,r) 
L872: (values[i].v,r) (values[i].moneyness,r) 
L873: (values[i].result,r) 
}
array table
-----------------------------------------------
values -> [('[i]', 'r', 'normalized', ['i'], 861), ('[i]', 'r', 'normalized', ['i'], 862), ('[i]', 'r', 'normalized', ['i'], 863), ('[i]', 'r', 'normalized', ['i'], 864), ('[i]', 'r', 'normalized', ['i'], 865), ('[i]', 'r', 'normalized', ['i'], 866), ('[i]', 'r', 'normalized', ['i'], 867), ('[i]', 'r', 'normalized', ['i'], 868), ('[i]', 'r', 'normalized', ['i'], 869), ('[i]', 'r', 'normalized', ['i'], 870), ('[i]', 'r', 'normalized', ['i'], 871), ('[i]', 'r', 'normalized', ['i'], 871), ('[i]', 'r', 'normalized', ['i'], 872), ('[i]', 'r', 'normalized', ['i'], 872), ('[i]', 'r', 'normalized', ['i'], 873)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<LENGTH(values)  i++
induction variable: ['i']
{
L874: (values[i].type,r) 
L875: (values[i].t*,r) 
L876: (values[i].start*,r) 
L877: (values[i].s,r) 
L878: (values[i].q,r) 
L879: (values[i].r,r) 
L880: (values[i].v,r) 
L881: (values[i].moneyness,r) 
L882: (values[i].result,r) 
L883: (values[i].s,r) 
L884: (values[i].q,r) (values[i].r,r) 
L885: (values[i].v,r) (values[i].moneyness,r) 
L886: (values[i].result,r) 
}
array table
-----------------------------------------------
values -> [('[i]', 'r', 'normalized', ['i'], 874), ('[i]', 'r', 'normalized', ['i'], 875), ('[i]', 'r', 'normalized', ['i'], 876), ('[i]', 'r', 'normalized', ['i'], 877), ('[i]', 'r', 'normalized', ['i'], 878), ('[i]', 'r', 'normalized', ['i'], 879), ('[i]', 'r', 'normalized', ['i'], 880), ('[i]', 'r', 'normalized', ['i'], 881), ('[i]', 'r', 'normalized', ['i'], 882), ('[i]', 'r', 'normalized', ['i'], 883), ('[i]', 'r', 'normalized', ['i'], 884), ('[i]', 'r', 'normalized', ['i'], 884), ('[i]', 'r', 'normalized', ['i'], 885), ('[i]', 'r', 'normalized', ['i'], 885), ('[i]', 'r', 'normalized', ['i'], 886)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<LENGTH(types)  i++
induction variable: ['i']
{
	loop info: Size j=0  j<LENGTH(moneyness)  j++
	induction variable: ['i', 'j']
	{
		loop info: Size k=0  k<LENGTH(lengths)  k++
		induction variable: ['i', 'j', 'k']
		{
			loop info: Size h=0  h<LENGTH(startMonths)  h++
			induction variable: ['i', 'j', 'k', 'h']
			{
			L887: (lengths[k]*,r) 
			L888: (startMonths[h]*,r) 
			L889: (types[i],r) 
			L890: (moneyness[j],r) 
				loop info: Size l=0  l<LENGTH(underlyings)  l++
				induction variable: ['i', 'j', 'k', 'h', 'l']
				{
					loop info: Size m=0  m<LENGTH(qRates)  m++
					induction variable: ['i', 'j', 'k', 'h', 'l', 'm']
					{
						loop info: Size n=0  n<LENGTH(rRates)  n++
						induction variable: ['i', 'j', 'k', 'h', 'l', 'm', 'n']
						{
							loop info: Size p=0  p<LENGTH(vols)  p++
							induction variable: ['i', 'j', 'k', 'h', 'l', 'm', 'n', 'p']
							{
							L891: (underlyings[l],r) 
							L892: (qRates[m],r) 
							L893: (rRates[n],r) 
							L894: (vols[p],r) 
							L895: (calculated["delta"]=,w) 
							L896: (calculated["gamma"]=,w) 
							L897: (calculated["theta"]=,w) 
							L898: (calculated["rho"]=,w) 
							L899: (calculated["divRho"]=,w) 
							L900: (calculated["vega"]=,w) 
							L901: (expected["delta"]=,w) 
							L902: (expected["gamma"]=,w) 
							L903: (expected["rho"]=,w) 
							L904: (expected["divRho"]=,w) 
							L905: (expected["vega"]=,w) 
							L906: (expected["theta"]=,w) 
							L907: (calculated[greek],r) 
							L908: (moneyness[j],r) 
							}
 						}
 					}
 				}
 			}
 		}
 	}
 }
array table
-----------------------------------------------
rRates -> [('[n]', 'r', 'normalized', ['i', 'j', 'k', 'h', 'l', 'm', 'n', 'p'], 893)]
LDEs formed:0

lengths -> [('[k]', 'r', 'normalized', ['i', 'j', 'k', 'h', 'l', 'm', 'n', 'p'], 887)]
LDEs formed:0

startMonths -> [('[h]', 'r', 'normalized', ['i', 'j', 'k', 'h', 'l', 'm', 'n', 'p'], 888)]
LDEs formed:0

qRates -> [('[m]', 'r', 'normalized', ['i', 'j', 'k', 'h', 'l', 'm', 'n', 'p'], 892)]
LDEs formed:0

underlyings -> [('[l]', 'r', 'normalized', ['i', 'j', 'k', 'h', 'l', 'm', 'n', 'p'], 891)]
LDEs formed:0

vols -> [('[p]', 'r', 'normalized', ['i', 'j', 'k', 'h', 'l', 'm', 'n', 'p'], 894)]
LDEs formed:0

expected -> [('["delta"]', 'w', 'not normalized', ['i', 'j', 'k', 'h', 'l', 'm', 'n', 'p'], 901), ('["gamma"]', 'w', 'not normalized', ['i', 'j', 'k', 'h', 'l', 'm', 'n', 'p'], 902), ('["rho"]', 'w', 'not normalized', ['i', 'j', 'k', 'h', 'l', 'm', 'n', 'p'], 903), ('["divRho"]', 'w', 'not normalized', ['i', 'j', 'k', 'h', 'l', 'm', 'n', 'p'], 904), ('["vega"]', 'w', 'not normalized', ['i', 'j', 'k', 'h', 'l', 'm', 'n', 'p'], 905), ('["theta"]', 'w', 'not normalized', ['i', 'j', 'k', 'h', 'l', 'm', 'n', 'p'], 906)]
LDEs formed:21

moneyness -> [('[j]', 'r', 'normalized', ['i', 'j', 'k', 'h', 'l', 'm', 'n', 'p'], 890), ('[j]', 'r', 'normalized', ['i', 'j', 'k', 'h', 'l', 'm', 'n', 'p'], 908)]
LDEs formed:0

calculated -> [('["delta"]', 'w', 'not normalized', ['i', 'j', 'k', 'h', 'l', 'm', 'n', 'p'], 895), ('["gamma"]', 'w', 'not normalized', ['i', 'j', 'k', 'h', 'l', 'm', 'n', 'p'], 896), ('["theta"]', 'w', 'not normalized', ['i', 'j', 'k', 'h', 'l', 'm', 'n', 'p'], 897), ('["rho"]', 'w', 'not normalized', ['i', 'j', 'k', 'h', 'l', 'm', 'n', 'p'], 898), ('["divRho"]', 'w', 'not normalized', ['i', 'j', 'k', 'h', 'l', 'm', 'n', 'p'], 899), ('["vega"]', 'w', 'not normalized', ['i', 'j', 'k', 'h', 'l', 'm', 'n', 'p'], 900), ('[greek]', 'r', 'not normalized', ['i', 'j', 'k', 'h', 'l', 'm', 'n', 'p'], 907)]
LDEs formed:27

types -> [('[i]', 'r', 'normalized', ['i', 'j', 'k', 'h', 'l', 'm', 'n', 'p'], 889)]
LDEs formed:0

distinct LDEs:
"gamma"="divRho"
"divRho"="divRho"
"theta"="theta"
"vega"="theta"
"divRho"="vega"
"rho"="rho"
"gamma"="vega"
"delta"="delta"
"rho"="vega"
"delta"="theta"
"rho"="theta"
"divRho"="theta"
"delta"="rho"
"gamma"="theta"
"vega"="vega"
"rho"=greek
"delta"="divRho"
"delta"=greek
"gamma"=greek
"gamma"="rho"
"vega"=greek
"delta"="gamma"
"gamma"="gamma"
"delta"="vega"
"rho"="divRho"
"theta"=greek
"divRho"=greek
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/asianoptions.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<fixingDates.size()  i++
induction variable: ['i']
{
L890: (fixingDates[i]=,w) 
}
array table
-----------------------------------------------
fixingDates -> [('[i]', 'w', 'normalized', ['i'], 890)]
LDEs formed:1

distinct LDEs:
i1=i2
#########################################################################################
loop info: Size i=0  i<LENGTH(types)  i++
induction variable: ['i']
{
	loop info: Size j=0  j<LENGTH(strikes)  j++
	induction variable: ['i', 'j']
	{
		loop info: Size k=0  k<LENGTH(lengths)  k++
		induction variable: ['i', 'j', 'k']
		{
		L891: (lengths[k]*,r) 
		L892: (types[i],r) (strikes[j],r) 
			loop info: Size l=0  l<LENGTH(underlyings)  l++
			induction variable: ['i', 'j', 'k', 'l']
			{
				loop info: Size m=0  m<LENGTH(qRates)  m++
				induction variable: ['i', 'j', 'k', 'l', 'm']
				{
					loop info: Size n=0  n<LENGTH(rRates)  n++
					induction variable: ['i', 'j', 'k', 'l', 'm', 'n']
					{
						loop info: Size p=0  p<LENGTH(vols)  p++
						induction variable: ['i', 'j', 'k', 'l', 'm', 'n', 'p']
						{
						L893: (underlyings[l],r) 
						L894: (qRates[m],r) 
						L895: (rRates[n],r) 
						L896: (vols[p],r) 
						L897: (calculated["delta"]=,w) 
						L898: (calculated["gamma"]=,w) 
						L899: (calculated["theta"]=,w) 
						L900: (calculated["rho"]=,w) 
						L901: (calculated["divRho"]=,w) 
						L902: (calculated["vega"]=,w) 
						L903: (expected["delta"]=,w) 
						L904: (expected["gamma"]=,w) 
						L905: (expected["rho"]=,w) 
						L906: (expected["divRho"]=,w) 
						L907: (expected["vega"]=,w) 
						L908: (expected["theta"]=,w) 
						L909: (calculated[greek],r) 
						}
 					}
 				}
 			}
 		}
 	}
 }
array table
-----------------------------------------------
rRates -> [('[n]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p'], 895)]
LDEs formed:0

lengths -> [('[k]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p'], 891)]
LDEs formed:0

calculated -> [('["delta"]', 'w', 'not normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p'], 897), ('["gamma"]', 'w', 'not normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p'], 898), ('["theta"]', 'w', 'not normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p'], 899), ('["rho"]', 'w', 'not normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p'], 900), ('["divRho"]', 'w', 'not normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p'], 901), ('["vega"]', 'w', 'not normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p'], 902), ('[greek]', 'r', 'not normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p'], 909)]
LDEs formed:27

qRates -> [('[m]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p'], 894)]
LDEs formed:0

strikes -> [('[j]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p'], 892)]
LDEs formed:0

underlyings -> [('[l]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p'], 893)]
LDEs formed:0

vols -> [('[p]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p'], 896)]
LDEs formed:0

expected -> [('["delta"]', 'w', 'not normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p'], 903), ('["gamma"]', 'w', 'not normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p'], 904), ('["rho"]', 'w', 'not normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p'], 905), ('["divRho"]', 'w', 'not normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p'], 906), ('["vega"]', 'w', 'not normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p'], 907), ('["theta"]', 'w', 'not normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p'], 908)]
LDEs formed:21

types -> [('[i]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p'], 892)]
LDEs formed:0

distinct LDEs:
"gamma"="divRho"
"divRho"="divRho"
"theta"="rho"
"theta"="theta"
"gamma"="vega"
"theta"="vega"
"rho"="rho"
"divRho"="vega"
"delta"="delta"
"rho"="vega"
"delta"="theta"
"delta"="rho"
"gamma"="theta"
"vega"="vega"
"rho"=greek
"delta"="divRho"
"delta"=greek
"gamma"=greek
"gamma"="rho"
"vega"=greek
"delta"="gamma"
"gamma"="gamma"
"delta"="vega"
"theta"="divRho"
"rho"="divRho"
"theta"=greek
"divRho"=greek
#########################################################################################
loop info: Size l=0  l<LENGTH(cases4)  l++
induction variable: ['l']
{
L893: (cases4[l].type,r) (cases4[l].strike,r) 
L894: (cases4[l].length/,r) (cases4[l].fixings-,r) 
L895: (cases4[l].fixings,r) 
L896: (cases4[l].fixings,r) 
L897: (timeIncrements[0]=,w) (cases4[l].first,r) 
L898: (fixingDates[0]=,w) (timeIncrements[0]*,r) 
	loop info: Size i=1  i<cases4[l].fixings  i++
	induction variable: ['l', 'i']
	{
	L899: (timeIncrements[i]=,w) (cases4[l].first,r) 
	L900: (fixingDates[i]=,w) (timeIncrements[i]*,r) 
	}
L901: (cases4[l].fixings-,r) 
L902: (cases4[l].underlying,r) 
L903: (cases4[l].dividendYield,r) 
L904: (cases4[l].riskFreeRate,r) 
L905: (cases4[l].volatility,r) 
L906: (cases4[l].result,r) 
L907: (cases4[l].fixings,r) 
}
array table
-----------------------------------------------
fixingDates -> [('[0]', 'w', 'normalized', ['l', 'i'], 898), ('[i]', 'w', 'normalized', ['l', 'i'], 900)]
LDEs formed:3

timeIncrements -> [('[0]', 'w', 'normalized', ['l', 'i'], 897), ('[0]', 'r', 'normalized', ['l', 'i'], 898), ('[i]', 'w', 'normalized', ['l', 'i'], 899), ('[i]', 'r', 'normalized', ['l', 'i'], 900)]
LDEs formed:7

cases4 -> [('[l]', 'r', 'normalized', ['l', 'i'], 893), ('[l]', 'r', 'normalized', ['l', 'i'], 893), ('[l]', 'r', 'normalized', ['l', 'i'], 894), ('[l]', 'r', 'normalized', ['l', 'i'], 894), ('[l]', 'r', 'normalized', ['l', 'i'], 895), ('[l]', 'r', 'normalized', ['l', 'i'], 896), ('[l]', 'r', 'normalized', ['l', 'i'], 897), ('[l]', 'r', 'normalized', ['l', 'i'], 899), ('[l]', 'r', 'normalized', ['l', 'i'], 901), ('[l]', 'r', 'normalized', ['l', 'i'], 902), ('[l]', 'r', 'normalized', ['l', 'i'], 903), ('[l]', 'r', 'normalized', ['l', 'i'], 904), ('[l]', 'r', 'normalized', ['l', 'i'], 905), ('[l]', 'r', 'normalized', ['l', 'i'], 906), ('[l]', 'r', 'normalized', ['l', 'i'], 907)]
LDEs formed:0

distinct LDEs:
0=i2
0=0
i1=i2
#########################################################################################
loop info: Size l=0  l<LENGTH(cases5)  l++
induction variable: ['l']
{
L908: (cases5[l].type,r) (cases5[l].strike,r) 
L909: (cases5[l].length/,r) (cases5[l].fixings-,r) 
L910: (cases5[l].fixings,r) 
L911: (cases5[l].fixings,r) 
L912: (timeIncrements[0]=,w) (cases5[l].first,r) 
L913: (fixingDates[0]=,w) (timeIncrements[0]*,r) 
	loop info: Size i=1  i<cases5[l].fixings  i++
	induction variable: ['l', 'i']
	{
	L914: (timeIncrements[i]=,w) (cases5[l].first,r) 
	L915: (fixingDates[i]=,w) (timeIncrements[i]*,r) 
	}
L916: (cases5[l].fixings-,r) 
L917: (cases5[l].underlying,r) 
L918: (cases5[l].dividendYield,r) 
L919: (cases5[l].riskFreeRate,r) 
L920: (cases5[l].volatility,r) 
L921: (cases5[l].result,r) 
}
array table
-----------------------------------------------
fixingDates -> [('[0]', 'w', 'normalized', ['l', 'i'], 913), ('[i]', 'w', 'normalized', ['l', 'i'], 915)]
LDEs formed:3

cases5 -> [('[l]', 'r', 'normalized', ['l', 'i'], 908), ('[l]', 'r', 'normalized', ['l', 'i'], 908), ('[l]', 'r', 'normalized', ['l', 'i'], 909), ('[l]', 'r', 'normalized', ['l', 'i'], 909), ('[l]', 'r', 'normalized', ['l', 'i'], 910), ('[l]', 'r', 'normalized', ['l', 'i'], 911), ('[l]', 'r', 'normalized', ['l', 'i'], 912), ('[l]', 'r', 'normalized', ['l', 'i'], 914), ('[l]', 'r', 'normalized', ['l', 'i'], 916), ('[l]', 'r', 'normalized', ['l', 'i'], 917), ('[l]', 'r', 'normalized', ['l', 'i'], 918), ('[l]', 'r', 'normalized', ['l', 'i'], 919), ('[l]', 'r', 'normalized', ['l', 'i'], 920), ('[l]', 'r', 'normalized', ['l', 'i'], 921)]
LDEs formed:0

timeIncrements -> [('[0]', 'w', 'normalized', ['l', 'i'], 912), ('[0]', 'r', 'normalized', ['l', 'i'], 913), ('[i]', 'w', 'normalized', ['l', 'i'], 914), ('[i]', 'r', 'normalized', ['l', 'i'], 915)]
LDEs formed:7

distinct LDEs:
0=i2
0=0
i1=i2
#########################################################################################
loop info: Size i=0  i<LENGTH(types)  i++
induction variable: ['i']
{
	loop info: Size j=0  j<LENGTH(strikes)  j++
	induction variable: ['i', 'j']
	{
		loop info: Size k=0  k<LENGTH(lengths)  k++
		induction variable: ['i', 'j', 'k']
		{
		L916: (lengths[k]*,r) 
		L917: (types[i],r) (strikes[j],r) 
			loop info: Size l=0  l<LENGTH(underlyings)  l++
			induction variable: ['i', 'j', 'k', 'l']
			{
				loop info: Size m=0  m<LENGTH(qRates)  m++
				induction variable: ['i', 'j', 'k', 'l', 'm']
				{
					loop info: Size n=0  n<LENGTH(rRates)  n++
					induction variable: ['i', 'j', 'k', 'l', 'm', 'n']
					{
						loop info: Size p=0  p<LENGTH(vols)  p++
						induction variable: ['i', 'j', 'k', 'l', 'm', 'n', 'p']
						{
						L918: (underlyings[l],r) 
						L919: (qRates[m],r) 
						L920: (rRates[n],r) 
						L921: (vols[p],r) 
						L922: (calculated["delta"]=,w) 
						L923: (calculated["gamma"]=,w) 
						L924: (calculated["theta"]=,w) 
						L925: (calculated["rho"]=,w) 
						L926: (calculated["divRho"]=,w) 
						L927: (calculated["vega"]=,w) 
						L928: (expected["delta"]=,w) 
						L929: (expected["gamma"]=,w) 
						L930: (expected["rho"]=,w) 
						L931: (expected["divRho"]=,w) 
						L932: (expected["vega"]=,w) 
						L933: (expected["theta"]=,w) 
						L934: (calculated[greek],r) 
						}
 					}
 				}
 			}
 		}
 	}
 }
array table
-----------------------------------------------
rRates -> [('[n]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p'], 920)]
LDEs formed:0

lengths -> [('[k]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p'], 916)]
LDEs formed:0

calculated -> [('["delta"]', 'w', 'not normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p'], 922), ('["gamma"]', 'w', 'not normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p'], 923), ('["theta"]', 'w', 'not normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p'], 924), ('["rho"]', 'w', 'not normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p'], 925), ('["divRho"]', 'w', 'not normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p'], 926), ('["vega"]', 'w', 'not normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p'], 927), ('[greek]', 'r', 'not normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p'], 934)]
LDEs formed:27

qRates -> [('[m]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p'], 919)]
LDEs formed:0

strikes -> [('[j]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p'], 917)]
LDEs formed:0

underlyings -> [('[l]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p'], 918)]
LDEs formed:0

vols -> [('[p]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p'], 921)]
LDEs formed:0

expected -> [('["delta"]', 'w', 'not normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p'], 928), ('["gamma"]', 'w', 'not normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p'], 929), ('["rho"]', 'w', 'not normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p'], 930), ('["divRho"]', 'w', 'not normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p'], 931), ('["vega"]', 'w', 'not normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p'], 932), ('["theta"]', 'w', 'not normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p'], 933)]
LDEs formed:21

types -> [('[i]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p'], 917)]
LDEs formed:0

distinct LDEs:
"gamma"="divRho"
"divRho"="divRho"
"theta"="rho"
"theta"="theta"
"gamma"="vega"
"theta"="vega"
"rho"="rho"
"divRho"="vega"
"delta"="delta"
"rho"="vega"
"delta"="theta"
"delta"="rho"
"gamma"="theta"
"vega"="vega"
"rho"=greek
"delta"="divRho"
"delta"=greek
"gamma"=greek
"gamma"="rho"
"vega"=greek
"delta"="gamma"
"gamma"="gamma"
"delta"="vega"
"theta"="divRho"
"rho"="divRho"
"theta"=greek
"divRho"=greek
#########################################################################################
loop info: Size l=0  l<LENGTH(cases)  l++
induction variable: ['l']
{
L918: (cases[l].spot,r) 
L919: (cases[l].dividendYield,r) 
L920: (cases[l].riskFreeRate,r) 
L921: (cases[l].volatility,r) 
L922: (cases[l].currentAverage,r) 
L923: (cases[l].type,r) (cases[l].strike,r) 
L924: (cases[l].elapsed,r) 
L925: (cases[l].length,r) 
L926: (cases[l].result,r) 
L927: (cases[l].spot,r) 
L928: (cases[l].currentAverage,r) 
L929: (cases[l].strike,r) 
L930: (cases[l].dividendYield,r) 
L931: (cases[l].riskFreeRate,r) 
L932: (cases[l].volatility,r) 
L933: (cases[l].length,r) 
L934: (cases[l].elapsed,r) 
}
array table
-----------------------------------------------
cases -> [('[l]', 'r', 'normalized', ['l'], 918), ('[l]', 'r', 'normalized', ['l'], 919), ('[l]', 'r', 'normalized', ['l'], 920), ('[l]', 'r', 'normalized', ['l'], 921), ('[l]', 'r', 'normalized', ['l'], 922), ('[l]', 'r', 'normalized', ['l'], 923), ('[l]', 'r', 'normalized', ['l'], 923), ('[l]', 'r', 'normalized', ['l'], 924), ('[l]', 'r', 'normalized', ['l'], 925), ('[l]', 'r', 'normalized', ['l'], 926), ('[l]', 'r', 'normalized', ['l'], 927), ('[l]', 'r', 'normalized', ['l'], 928), ('[l]', 'r', 'normalized', ['l'], 929), ('[l]', 'r', 'normalized', ['l'], 930), ('[l]', 'r', 'normalized', ['l'], 931), ('[l]', 'r', 'normalized', ['l'], 932), ('[l]', 'r', 'normalized', ['l'], 933), ('[l]', 'r', 'normalized', ['l'], 934)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<LENGTH(cases)  ++i
induction variable: ['i']
{
L935: (cases[i].spot,r) 
L936: (cases[i].riskFreeRate,r) 
L937: (cases[i].volatility,r) 
L938: (cases[i].length*,r) 
L939: (cases[i].strike,r) 
L940: (cases[i].result,r) 
L941: (cases[i].tolerance,r) 
L942: (cases[i].result,r) 
L943: (cases[i].result,r) 
L944: (cases[i].tolerance,r) 
}
array table
-----------------------------------------------
cases -> [('[i]', 'r', 'normalized', ['i'], 935), ('[i]', 'r', 'normalized', ['i'], 936), ('[i]', 'r', 'normalized', ['i'], 937), ('[i]', 'r', 'normalized', ['i'], 938), ('[i]', 'r', 'normalized', ['i'], 939), ('[i]', 'r', 'normalized', ['i'], 940), ('[i]', 'r', 'normalized', ['i'], 941), ('[i]', 'r', 'normalized', ['i'], 942), ('[i]', 'r', 'normalized', ['i'], 943), ('[i]', 'r', 'normalized', ['i'], 944)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/defaultprobabilitycurves.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<n.size()  i++
induction variable: ['i']
{
L945: (n[i]*,r) 
L946: (quote[i],r) 
L947: (quote[i],r) 
L948: (n[i]<<,r) 
}
array table
-----------------------------------------------
quote -> [('[i]', 'r', 'normalized', ['i'], 946), ('[i]', 'r', 'normalized', ['i'], 947)]
LDEs formed:0

n -> [('[i]', 'r', 'normalized', ['i'], 945), ('[i]', 'r', 'normalized', ['i'], 948)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<n.size()  i++
induction variable: ['i']
{
L949: (n[i]*,r) 
L950: (quote[i],r) 
L951: (quote[i],r) 
L952: (n[i]<<,r) 
}
array table
-----------------------------------------------
quote -> [('[i]', 'r', 'normalized', ['i'], 950), ('[i]', 'r', 'normalized', ['i'], 951)]
LDEs formed:0

n -> [('[i]', 'r', 'normalized', ['i'], 949), ('[i]', 'r', 'normalized', ['i'], 952)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/schedule.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<expected.size()  ++i
induction variable: ['i']
{
L953: (s[i],r) (expected[i],r) 
L954: (expected[i],r) 
L955: (s[i],r) 
}
array table
-----------------------------------------------
expected -> [('[i]', 'r', 'normalized', ['i'], 953), ('[i]', 'r', 'normalized', ['i'], 954)]
LDEs formed:0

s -> [('[i]', 'r', 'normalized', ['i'], 953), ('[i]', 'r', 'normalized', ['i'], 955)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/rounding.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<LENGTH(testData)  i++
induction variable: ['i']
{
L956: (testData[i].precision,r) 
L957: (testData[i].x,r) 
L958: (testData[i].closest,r) 
L959: (testData[i].x<<,r) 
}
array table
-----------------------------------------------
testData -> [('[i]', 'r', 'normalized', ['i'], 956), ('[i]', 'r', 'normalized', ['i'], 957), ('[i]', 'r', 'normalized', ['i'], 958), ('[i]', 'r', 'normalized', ['i'], 959)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<LENGTH(testData)  i++
induction variable: ['i']
{
L960: (testData[i].precision,r) 
L961: (testData[i].x,r) 
L962: (testData[i].up,r) 
L963: (testData[i].x<<,r) 
}
array table
-----------------------------------------------
testData -> [('[i]', 'r', 'normalized', ['i'], 960), ('[i]', 'r', 'normalized', ['i'], 961), ('[i]', 'r', 'normalized', ['i'], 962), ('[i]', 'r', 'normalized', ['i'], 963)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<LENGTH(testData)  i++
induction variable: ['i']
{
L964: (testData[i].precision,r) 
L965: (testData[i].x,r) 
L966: (testData[i].down,r) 
L967: (testData[i].x<<,r) 
}
array table
-----------------------------------------------
testData -> [('[i]', 'r', 'normalized', ['i'], 964), ('[i]', 'r', 'normalized', ['i'], 965), ('[i]', 'r', 'normalized', ['i'], 966), ('[i]', 'r', 'normalized', ['i'], 967)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<LENGTH(testData)  i++
induction variable: ['i']
{
L968: (testData[i].precision,r) 
L969: (testData[i].x,r) 
L970: (testData[i].floor,r) 
L971: (testData[i].x<<,r) 
}
array table
-----------------------------------------------
testData -> [('[i]', 'r', 'normalized', ['i'], 968), ('[i]', 'r', 'normalized', ['i'], 969), ('[i]', 'r', 'normalized', ['i'], 970), ('[i]', 'r', 'normalized', ['i'], 971)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<LENGTH(testData)  i++
induction variable: ['i']
{
L972: (testData[i].precision,r) 
L973: (testData[i].x,r) 
L974: (testData[i].ceiling,r) 
L975: (testData[i].x<<,r) 
}
array table
-----------------------------------------------
testData -> [('[i]', 'r', 'normalized', ['i'], 972), ('[i]', 'r', 'normalized', ['i'], 973), ('[i]', 'r', 'normalized', ['i'], 974), ('[i]', 'r', 'normalized', ['i'], 975)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/bonds.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<LENGTH(issueMonths)  i++
induction variable: ['i']
{
	loop info: Size j=0  j<LENGTH(lengths)  j++
	induction variable: ['i', 'j']
	{
		loop info: Size k=0  k<LENGTH(coupons)  k++
		induction variable: ['i', 'j', 'k']
		{
			loop info: Size l=0  l<LENGTH(frequencies)  l++
			induction variable: ['i', 'j', 'k', 'l']
			{
				loop info: Size n=0  n<LENGTH(compounding)  n++
				induction variable: ['i', 'j', 'k', 'l', 'n']
				{
				L976: (issueMonths[i],r) 
				L977: (lengths[j],r) 
				L978: (frequencies[l],r) 
				L979: (coupons[k],r) 
					loop info: Size m=0  m<LENGTH(yields)  m++
					induction variable: ['i', 'j', 'k', 'l', 'n', 'm']
					{
					L980: (yields[m],r) 
					L981: (compounding[n],r) 
					L982: (frequencies[l],r) 
					L983: (compounding[n],r) 
					L984: (frequencies[l],r) 
					L985: (yields[m]-,r) 
					L986: (compounding[n],r) 
					L987: (frequencies[l],r) 
					L988: (coupons[k],r) 
					L989: (frequencies[l]<<,r) 
					L990: (yields[m],r) 
					L991: (compounding[n]==,r) 
					}
 				}
 			}
 		}
 	}
 }
array table
-----------------------------------------------
issueMonths -> [('[i]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'n', 'm'], 976)]
LDEs formed:0

lengths -> [('[j]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'n', 'm'], 977)]
LDEs formed:0

frequencies -> [('[l]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'n', 'm'], 978), ('[l]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'n', 'm'], 982), ('[l]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'n', 'm'], 984), ('[l]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'n', 'm'], 987), ('[l]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'n', 'm'], 989)]
LDEs formed:0

yields -> [('[m]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'n', 'm'], 980), ('[m]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'n', 'm'], 985), ('[m]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'n', 'm'], 990)]
LDEs formed:0

compounding -> [('[n]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'n', 'm'], 981), ('[n]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'n', 'm'], 983), ('[n]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'n', 'm'], 986), ('[n]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'n', 'm'], 991)]
LDEs formed:0

coupons -> [('[k]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'n', 'm'], 979), ('[k]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'n', 'm'], 988)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<LENGTH(issueMonths)  i++
induction variable: ['i']
{
	loop info: Size j=0  j<LENGTH(lengths)  j++
	induction variable: ['i', 'j']
	{
		loop info: Size k=0  k<LENGTH(coupons)  k++
		induction variable: ['i', 'j', 'k']
		{
			loop info: Size l=0  l<LENGTH(frequencies)  l++
			induction variable: ['i', 'j', 'k', 'l']
			{
			L989: (issueMonths[i],r) 
			L990: (lengths[j],r) 
			L991: (frequencies[l],r) 
			L992: (coupons[k],r) 
			L993: (coupons[k]-,r) 
			L994: (coupons[k],r) 
			L995: (frequencies[l]<<,r) 
			}
 		}
 	}
 }
array table
-----------------------------------------------
lengths -> [('[j]', 'r', 'normalized', ['i', 'j', 'k', 'l'], 990)]
LDEs formed:0

frequencies -> [('[l]', 'r', 'normalized', ['i', 'j', 'k', 'l'], 991), ('[l]', 'r', 'normalized', ['i', 'j', 'k', 'l'], 995)]
LDEs formed:0

coupons -> [('[k]', 'r', 'normalized', ['i', 'j', 'k', 'l'], 992), ('[k]', 'r', 'normalized', ['i', 'j', 'k', 'l'], 993), ('[k]', 'r', 'normalized', ['i', 'j', 'k', 'l'], 994)]
LDEs formed:0

issueMonths -> [('[i]', 'r', 'normalized', ['i', 'j', 'k', 'l'], 989)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<LENGTH(issueMonths)  i++
induction variable: ['i']
{
	loop info: Size j=0  j<LENGTH(lengths)  j++
	induction variable: ['i', 'j']
	{
		loop info: Size k=0  k<LENGTH(coupons)  k++
		induction variable: ['i', 'j', 'k']
		{
			loop info: Size l=0  l<LENGTH(frequencies)  l++
			induction variable: ['i', 'j', 'k', 'l']
			{
				loop info: Size n=0  n<LENGTH(compounding)  n++
				induction variable: ['i', 'j', 'k', 'l', 'n']
				{
				L990: (issueMonths[i],r) 
				L991: (lengths[j],r) 
				L992: (frequencies[l],r) 
				L993: (coupons[k],r) 
					loop info: Size m=0  m<LENGTH(spreads)  m++
					induction variable: ['i', 'j', 'k', 'l', 'n', 'm']
					{
					L994: (spreads[m],r) 
					L995: (compounding[n],r) 
					L996: (frequencies[l],r) 
					L997: (compounding[n],r) 
					L998: (frequencies[l],r) 
					L999: (spreads[m]-,r) 
					L1000: (compounding[n],r) 
					L1001: (frequencies[l],r) 
					L1002: (coupons[k],r) 
					L1003: (frequencies[l]<<,r) 
					L1004: (spreads[m],r) 
					L1005: (compounding[n]==,r) 
					}
 				}
 			}
 		}
 	}
 }
array table
-----------------------------------------------
issueMonths -> [('[i]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'n', 'm'], 990)]
LDEs formed:0

lengths -> [('[j]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'n', 'm'], 991)]
LDEs formed:0

frequencies -> [('[l]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'n', 'm'], 992), ('[l]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'n', 'm'], 996), ('[l]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'n', 'm'], 998), ('[l]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'n', 'm'], 1001), ('[l]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'n', 'm'], 1003)]
LDEs formed:0

spreads -> [('[m]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'n', 'm'], 994), ('[m]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'n', 'm'], 999), ('[m]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'n', 'm'], 1004)]
LDEs formed:0

compounding -> [('[n]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'n', 'm'], 995), ('[n]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'n', 'm'], 997), ('[n]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'n', 'm'], 1000), ('[n]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'n', 'm'], 1005)]
LDEs formed:0

coupons -> [('[k]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'n', 'm'], 993), ('[k]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'n', 'm'], 1002)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size j=0  j<LENGTH(lengths)  j++
induction variable: ['j']
{
	loop info: Size k=0  k<LENGTH(coupons)  k++
	induction variable: ['j', 'k']
	{
		loop info: Size l=0  l<LENGTH(frequencies)  l++
		induction variable: ['j', 'k', 'l']
		{
		L1003: (lengths[j],r) 
		L1004: (frequencies[l],r) 
		L1005: (coupons[k],r) 
			loop info: Size m=0  m<LENGTH(yields)  m++
			induction variable: ['j', 'k', 'l', 'm']
			{
			L1006: (yields[m],r) 
			L1007: (yields[m],r) 
			L1008: (frequencies[l],r) 
			L1009: (coupons[k],r) 
			L1010: (frequencies[l]<<,r) 
			L1011: (yields[m],r) 
			L1012: (frequencies[l],r) 
			L1013: (yields[m]-,r) 
			L1014: (coupons[k],r) 
			L1015: (frequencies[l]<<,r) 
			L1016: (yields[m],r) 
			}
 		}
 	}
 }
array table
-----------------------------------------------
lengths -> [('[j]', 'r', 'normalized', ['j', 'k', 'l', 'm'], 1003)]
LDEs formed:0

frequencies -> [('[l]', 'r', 'normalized', ['j', 'k', 'l', 'm'], 1004), ('[l]', 'r', 'normalized', ['j', 'k', 'l', 'm'], 1008), ('[l]', 'r', 'normalized', ['j', 'k', 'l', 'm'], 1010), ('[l]', 'r', 'normalized', ['j', 'k', 'l', 'm'], 1012), ('[l]', 'r', 'normalized', ['j', 'k', 'l', 'm'], 1015)]
LDEs formed:0

yields -> [('[m]', 'r', 'normalized', ['j', 'k', 'l', 'm'], 1006), ('[m]', 'r', 'normalized', ['j', 'k', 'l', 'm'], 1007), ('[m]', 'r', 'normalized', ['j', 'k', 'l', 'm'], 1011), ('[m]', 'r', 'normalized', ['j', 'k', 'l', 'm'], 1013), ('[m]', 'r', 'normalized', ['j', 'k', 'l', 'm'], 1016)]
LDEs formed:0

coupons -> [('[k]', 'r', 'normalized', ['j', 'k', 'l', 'm'], 1005), ('[k]', 'r', 'normalized', ['j', 'k', 'l', 'm'], 1009), ('[k]', 'r', 'normalized', ['j', 'k', 'l', 'm'], 1014)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size bondIndex = 0  bondIndex < maturityDates.size()  bondIndex++
induction variable: ['bondIndex']
{
L1015: (yields[bondIndex],r) 
L1016: (maturityDates[bondIndex],r) 
L1017: (prices[bondIndex],r) 
}
array table
-----------------------------------------------
prices -> [('[bondIndex]', 'r', 'normalized', ['bondIndex'], 1017)]
LDEs formed:0

maturityDates -> [('[bondIndex]', 'r', 'normalized', ['bondIndex'], 1016)]
LDEs formed:0

yields -> [('[bondIndex]', 'r', 'normalized', ['bondIndex'], 1015)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<LENGTH(cases)  ++i
induction variable: ['i']
{
L1016: (cases[i].settlementDate,r) 
L1017: (cases[i].settlementDate,r) 
L1018: (cases[i].accruedAmount,r) 
L1019: (cases[i].testPrice+,r) 
L1020: (cases[i].settlementDate,r) 
L1021: (cases[i].NPV,r) 
L1022: (cases[i].settlementDate,r) 
L1023: (cases[i].settlementDate,r) 
L1024: (cases[i].yield,r) 
L1025: (cases[i].settlementDate,r) 
L1026: (cases[i].settlementDate,r) 
L1027: (cases[i].duration,r) 
L1028: (cases[i].settlementDate,r) 
L1029: (cases[i].settlementDate,r) 
L1030: (cases[i].convexity,r) 
L1031: (cases[i].settlementDate,r) 
L1032: (cases[i].settlementDate,r) 
L1033: (cases[i].NPV,r) 
L1034: (cases[i].settlementDate,r) 
L1035: (cases[i].testPrice,r) 
}
array table
-----------------------------------------------
cases -> [('[i]', 'r', 'normalized', ['i'], 1016), ('[i]', 'r', 'normalized', ['i'], 1017), ('[i]', 'r', 'normalized', ['i'], 1018), ('[i]', 'r', 'normalized', ['i'], 1019), ('[i]', 'r', 'normalized', ['i'], 1020), ('[i]', 'r', 'normalized', ['i'], 1021), ('[i]', 'r', 'normalized', ['i'], 1022), ('[i]', 'r', 'normalized', ['i'], 1023), ('[i]', 'r', 'normalized', ['i'], 1024), ('[i]', 'r', 'normalized', ['i'], 1025), ('[i]', 'r', 'normalized', ['i'], 1026), ('[i]', 'r', 'normalized', ['i'], 1027), ('[i]', 'r', 'normalized', ['i'], 1028), ('[i]', 'r', 'normalized', ['i'], 1029), ('[i]', 'r', 'normalized', ['i'], 1030), ('[i]', 'r', 'normalized', ['i'], 1031), ('[i]', 'r', 'normalized', ['i'], 1032), ('[i]', 'r', 'normalized', ['i'], 1033), ('[i]', 'r', 'normalized', ['i'], 1034), ('[i]', 'r', 'normalized', ['i'], 1035)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<LENGTH(cases)  ++i
induction variable: ['i']
{
L1036: (cases[i].settlementDate,r) 
L1037: (cases[i].settlementDate,r) 
L1038: (cases[i].accruedAmount,r) 
L1039: (cases[i].testPrice+,r) 
L1040: (cases[i].settlementDate,r) 
L1041: (cases[i].NPV,r) 
L1042: (cases[i].settlementDate,r) 
L1043: (cases[i].settlementDate,r) 
L1044: (cases[i].yield,r) 
L1045: (cases[i].settlementDate,r) 
L1046: (cases[i].settlementDate,r) 
L1047: (cases[i].duration,r) 
L1048: (cases[i].settlementDate,r) 
L1049: (cases[i].settlementDate,r) 
L1050: (cases[i].convexity,r) 
L1051: (cases[i].settlementDate,r) 
L1052: (cases[i].settlementDate,r) 
L1053: (cases[i].NPV,r) 
L1054: (cases[i].settlementDate,r) 
L1055: (cases[i].testPrice,r) 
}
array table
-----------------------------------------------
cases -> [('[i]', 'r', 'normalized', ['i'], 1036), ('[i]', 'r', 'normalized', ['i'], 1037), ('[i]', 'r', 'normalized', ['i'], 1038), ('[i]', 'r', 'normalized', ['i'], 1039), ('[i]', 'r', 'normalized', ['i'], 1040), ('[i]', 'r', 'normalized', ['i'], 1041), ('[i]', 'r', 'normalized', ['i'], 1042), ('[i]', 'r', 'normalized', ['i'], 1043), ('[i]', 'r', 'normalized', ['i'], 1044), ('[i]', 'r', 'normalized', ['i'], 1045), ('[i]', 'r', 'normalized', ['i'], 1046), ('[i]', 'r', 'normalized', ['i'], 1047), ('[i]', 'r', 'normalized', ['i'], 1048), ('[i]', 'r', 'normalized', ['i'], 1049), ('[i]', 'r', 'normalized', ['i'], 1050), ('[i]', 'r', 'normalized', ['i'], 1051), ('[i]', 'r', 'normalized', ['i'], 1052), ('[i]', 'r', 'normalized', ['i'], 1053), ('[i]', 'r', 'normalized', ['i'], 1054), ('[i]', 'r', 'normalized', ['i'], 1055)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/gjrgarchmodel.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size k = 0  k < 3  ++k
induction variable: ['k']
{
L1056: (Lambda[k],r) 
	loop info: Size i = 0  i < 2  ++i
	induction variable: ['k', 'i']
	{
		loop info: Size j = 0  j < 6  ++j
		induction variable: ['k', 'i', 'j']
		{
		L1057: (strike[j],r) 
		L1058: (maturity[i],r) 
		L1059: (analytic[k][i][j],r) 
		L1060: (analytic[k][i][j],r) 
		L1061: (mcValues[k][i][j],r) 
		L1062: (mcValues[k][i][j],r) 
		}
 	}
 }
array table
-----------------------------------------------
strike -> [('[j]', 'r', 'normalized', ['k', 'i', 'j'], 1057)]
LDEs formed:0

maturity -> [('[i]', 'r', 'normalized', ['k', 'i', 'j'], 1058)]
LDEs formed:0

analytic -> [('[k][i][j]', 'r', 'normalized', ['k', 'i', 'j'], 1059), ('[k][i][j]', 'r', 'normalized', ['k', 'i', 'j'], 1060)]
LDEs formed:0

mcValues -> [('[k][i][j]', 'r', 'normalized', ['k', 'i', 'j'], 1061), ('[k][i][j]', 'r', 'normalized', ['k', 'i', 'j'], 1062)]
LDEs formed:0

Lambda -> [('[k]', 'r', 'normalized', ['k', 'i', 'j'], 1056)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: i = 0  i < 8  ++i
induction variable: ['i']
{
L1057: (t[i],r) 
L1058: (r[i],r) 
}
array table
-----------------------------------------------
r -> [('[i]', 'r', 'normalized', ['i'], 1058)]
LDEs formed:0

t -> [('[i]', 'r', 'normalized', ['i'], 1057)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size s = 3  s < 10  ++s
induction variable: ['s']
{
	loop info: Size m = 0  m < 3  ++m
	induction variable: ['s', 'm']
	{
	L1058: (v[s*8+m],r) 
	L1059: (t[m]+,r) 
	L1060: (strike[s],r) 
	}
 }
array table
-----------------------------------------------
strike -> [('[s]', 'r', 'normalized', ['s', 'm'], 1060)]
LDEs formed:0

t -> [('[m]', 'r', 'normalized', ['s', 'm'], 1059)]
LDEs formed:0

v -> [('[s*8+m]', 'r', 'normalized', ['s', 'm'], 1058)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: i = 0  i < options.size()  ++i
induction variable: ['i']
{
L1059: (options[i]-,r) 
}
array table
-----------------------------------------------
options -> [('[i]', 'r', 'normalized', ['i'], 1059)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/doublebarrieroption.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<LENGTH(values)  i++
induction variable: ['i']
{
L1060: (values[i].t*,r) 
L1061: (values[i].s,r) 
L1062: (values[i].q,r) 
L1063: (values[i].r,r) 
L1064: (values[i].v,r) 
L1065: (values[i].type,r) (values[i].strike,r) 
L1066: (values[i].barrierType,r) 
L1067: (values[i].barrierlo,r) 
L1068: (values[i].barrierhi,r) 
L1069: (values[i].result,r) 
L1070: (values[i].tol,r) 
L1071: (values[i].barrierType,r) (values[i].barrierlo,r) 
L1072: (values[i].barrierhi,r) (values[i].s,r) 
L1073: (values[i].q,r) (values[i].r,r) (values[i].v,r) 
L1074: (values[i].tol,r) 
L1075: (values[i].result,r) 
L1076: (values[i].tol,r) 
L1077: (values[i].barrierType,r) (values[i].barrierlo,r) 
L1078: (values[i].barrierhi,r) (values[i].s,r) 
L1079: (values[i].q,r) (values[i].r,r) (values[i].v,r) 
L1080: (values[i].tol,r) 
L1081: (values[i].result,r) 
L1082: (values[i].barrierType,r) 
L1083: (values[i].barrierlo,r) (values[i].barrierhi,r) 
L1084: (values[i].s,r) (values[i].q,r) (values[i].r,r) 
L1085: (values[i].v,r) 
L1086: (values[i].result,r) 
L1087: (values[i].barrierType,r) 
L1088: (values[i].barrierlo,r) (values[i].barrierhi,r) 
L1089: (values[i].s,r) (values[i].q,r) (values[i].r,r) 
L1090: (values[i].v,r) 
}
array table
-----------------------------------------------
values -> [('[i]', 'r', 'normalized', ['i'], 1060), ('[i]', 'r', 'normalized', ['i'], 1061), ('[i]', 'r', 'normalized', ['i'], 1062), ('[i]', 'r', 'normalized', ['i'], 1063), ('[i]', 'r', 'normalized', ['i'], 1064), ('[i]', 'r', 'normalized', ['i'], 1065), ('[i]', 'r', 'normalized', ['i'], 1065), ('[i]', 'r', 'normalized', ['i'], 1066), ('[i]', 'r', 'normalized', ['i'], 1067), ('[i]', 'r', 'normalized', ['i'], 1068), ('[i]', 'r', 'normalized', ['i'], 1069), ('[i]', 'r', 'normalized', ['i'], 1070), ('[i]', 'r', 'normalized', ['i'], 1071), ('[i]', 'r', 'normalized', ['i'], 1071), ('[i]', 'r', 'normalized', ['i'], 1072), ('[i]', 'r', 'normalized', ['i'], 1072), ('[i]', 'r', 'normalized', ['i'], 1073), ('[i]', 'r', 'normalized', ['i'], 1073), ('[i]', 'r', 'normalized', ['i'], 1073), ('[i]', 'r', 'normalized', ['i'], 1074), ('[i]', 'r', 'normalized', ['i'], 1075), ('[i]', 'r', 'normalized', ['i'], 1076), ('[i]', 'r', 'normalized', ['i'], 1077), ('[i]', 'r', 'normalized', ['i'], 1077), ('[i]', 'r', 'normalized', ['i'], 1078), ('[i]', 'r', 'normalized', ['i'], 1078), ('[i]', 'r', 'normalized', ['i'], 1079), ('[i]', 'r', 'normalized', ['i'], 1079), ('[i]', 'r', 'normalized', ['i'], 1079), ('[i]', 'r', 'normalized', ['i'], 1080), ('[i]', 'r', 'normalized', ['i'], 1081), ('[i]', 'r', 'normalized', ['i'], 1082), ('[i]', 'r', 'normalized', ['i'], 1083), ('[i]', 'r', 'normalized', ['i'], 1083), ('[i]', 'r', 'normalized', ['i'], 1084), ('[i]', 'r', 'normalized', ['i'], 1084), ('[i]', 'r', 'normalized', ['i'], 1084), ('[i]', 'r', 'normalized', ['i'], 1085), ('[i]', 'r', 'normalized', ['i'], 1086), ('[i]', 'r', 'normalized', ['i'], 1087), ('[i]', 'r', 'normalized', ['i'], 1088), ('[i]', 'r', 'normalized', ['i'], 1088), ('[i]', 'r', 'normalized', ['i'], 1089), ('[i]', 'r', 'normalized', ['i'], 1089), ('[i]', 'r', 'normalized', ['i'], 1089), ('[i]', 'r', 'normalized', ['i'], 1090)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<LENGTH(values)  i++
induction variable: ['i']
{
L1091: (values[i].s,r) 
L1092: (values[i].q,r) 
L1093: (values[i].r,r) 
L1094: (values[i].vol25Put,r) 
L1095: (values[i].volAtm,r) 
L1096: (values[i].vol25Call,r) 
L1097: (values[i].type,r) 
L1098: (values[i].strike,r) 
L1099: (values[i].t*,r) 
L1100: (values[i].t,r) 
L1101: (values[i].t,r) 
L1102: (values[i].t,r) 
L1103: (values[i].barrierType,r) 
L1104: (values[i].barrier1,r) 
L1105: (values[i].barrier2,r) 
L1106: (values[i].rebate,r) 
L1107: (values[i].type,r) (values[i].strike,r) 
L1108: (values[i].t,r) (values[i].t,r) 
L1109: (values[i].v*,r) (values[i].t,r) (values[i].t,r) 
L1110: (values[i].result,r) 
L1111: (values[i].tol,r) 
L1112: (values[i].barrierType,r) 
L1113: (values[i].barrier1,r) (values[i].barrier2,r) 
L1114: (values[i].rebate,r) (values[i].s,r) 
L1115: (values[i].q,r) (values[i].r,r) (values[i].vol25Put,r) 
L1116: (values[i].volAtm,r) (values[i].vol25Call,r) (values[i].v,r) 
L1117: (values[i].tol,r) 
L1118: (values[i].result,r) 
L1119: (values[i].barrierType,r) 
L1120: (values[i].barrier1,r) (values[i].barrier2,r) 
L1121: (values[i].rebate,r) (values[i].s,r) 
L1122: (values[i].q,r) (values[i].r,r) (values[i].vol25Put,r) 
L1123: (values[i].volAtm,r) (values[i].vol25Call,r) (values[i].v,r) 
L1124: (values[i].tol,r) 
}
array table
-----------------------------------------------
values -> [('[i]', 'r', 'normalized', ['i'], 1091), ('[i]', 'r', 'normalized', ['i'], 1092), ('[i]', 'r', 'normalized', ['i'], 1093), ('[i]', 'r', 'normalized', ['i'], 1094), ('[i]', 'r', 'normalized', ['i'], 1095), ('[i]', 'r', 'normalized', ['i'], 1096), ('[i]', 'r', 'normalized', ['i'], 1097), ('[i]', 'r', 'normalized', ['i'], 1098), ('[i]', 'r', 'normalized', ['i'], 1099), ('[i]', 'r', 'normalized', ['i'], 1100), ('[i]', 'r', 'normalized', ['i'], 1101), ('[i]', 'r', 'normalized', ['i'], 1102), ('[i]', 'r', 'normalized', ['i'], 1103), ('[i]', 'r', 'normalized', ['i'], 1104), ('[i]', 'r', 'normalized', ['i'], 1105), ('[i]', 'r', 'normalized', ['i'], 1106), ('[i]', 'r', 'normalized', ['i'], 1107), ('[i]', 'r', 'normalized', ['i'], 1107), ('[i]', 'r', 'normalized', ['i'], 1108), ('[i]', 'r', 'normalized', ['i'], 1108), ('[i]', 'r', 'normalized', ['i'], 1109), ('[i]', 'r', 'normalized', ['i'], 1109), ('[i]', 'r', 'normalized', ['i'], 1109), ('[i]', 'r', 'normalized', ['i'], 1110), ('[i]', 'r', 'normalized', ['i'], 1111), ('[i]', 'r', 'normalized', ['i'], 1112), ('[i]', 'r', 'normalized', ['i'], 1113), ('[i]', 'r', 'normalized', ['i'], 1113), ('[i]', 'r', 'normalized', ['i'], 1114), ('[i]', 'r', 'normalized', ['i'], 1114), ('[i]', 'r', 'normalized', ['i'], 1115), ('[i]', 'r', 'normalized', ['i'], 1115), ('[i]', 'r', 'normalized', ['i'], 1115), ('[i]', 'r', 'normalized', ['i'], 1116), ('[i]', 'r', 'normalized', ['i'], 1116), ('[i]', 'r', 'normalized', ['i'], 1116), ('[i]', 'r', 'normalized', ['i'], 1117), ('[i]', 'r', 'normalized', ['i'], 1118), ('[i]', 'r', 'normalized', ['i'], 1119), ('[i]', 'r', 'normalized', ['i'], 1120), ('[i]', 'r', 'normalized', ['i'], 1120), ('[i]', 'r', 'normalized', ['i'], 1121), ('[i]', 'r', 'normalized', ['i'], 1121), ('[i]', 'r', 'normalized', ['i'], 1122), ('[i]', 'r', 'normalized', ['i'], 1122), ('[i]', 'r', 'normalized', ['i'], 1122), ('[i]', 'r', 'normalized', ['i'], 1123), ('[i]', 'r', 'normalized', ['i'], 1123), ('[i]', 'r', 'normalized', ['i'], 1123), ('[i]', 'r', 'normalized', ['i'], 1124)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/rngtraits.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/inflationcpiswap.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<N  i++
induction variable: ['i']
{
L1125: (iiData[i].date,r) 
L1126: (iiData[i].rate/,r) 
}
array table
-----------------------------------------------
iiData -> [('[i]', 'r', 'normalized', ['i'], 1125), ('[i]', 'r', 'normalized', ['i'], 1126)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<rpiSchedule.size() i++
induction variable: ['i']
{
L1127: (rpiSchedule[i],r) (fixData[i],r) 
}
array table
-----------------------------------------------
rpiSchedule -> [('[i]', 'r', 'normalized', ['i'], 1127)]
LDEs formed:0

fixData -> [('[i]', 'r', 'normalized', ['i'], 1127)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i = 0  i < nominalDataLength  i++
induction variable: ['i']
{
L1128: (nominalData[i].date,r) 
L1129: (nominalData[i].rate/,r) 
}
array table
-----------------------------------------------
nominalData -> [('[i]', 'r', 'normalized', ['i'], 1128), ('[i]', 'r', 'normalized', ['i'], 1129)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i = 0  i < zciisDataLength  i++
induction variable: ['i']
{
L1130: (zciisData[i].date,r) 
L1131: (zciisData[i].rate,r) 
}
array table
-----------------------------------------------
zciisData -> [('[i]', 'r', 'normalized', ['i'], 1130), ('[i]', 'r', 'normalized', ['i'], 1131)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0 i<floatSchedule.size()  i++
induction variable: ['i']
{
L1132: (floatSchedule[i],r) 
L1133: (floatSchedule[i],r) (floatFix[i],r) 
L1134: (cpiFix[i],r) 
}
array table
-----------------------------------------------
floatSchedule -> [('[i]', 'r', 'normalized', ['i'], 1132), ('[i]', 'r', 'normalized', ['i'], 1133)]
LDEs formed:0

cpiFix -> [('[i]', 'r', 'normalized', ['i'], 1134)]
LDEs formed:0

floatFix -> [('[i]', 'r', 'normalized', ['i'], 1133)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0 i<floatSchedule.size()  i++
induction variable: ['i']
{
L1134: (floatSchedule[i],r) 
L1135: (floatSchedule[i],r) (floatFix[i],r) 
L1136: (cpiFix[i],r) 
}
array table
-----------------------------------------------
floatSchedule -> [('[i]', 'r', 'normalized', ['i'], 1134), ('[i]', 'r', 'normalized', ['i'], 1135)]
LDEs formed:0

cpiFix -> [('[i]', 'r', 'normalized', ['i'], 1136)]
LDEs formed:0

floatFix -> [('[i]', 'r', 'normalized', ['i'], 1135)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/mersennetwister.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: i=0  i<1000  i++
induction variable: ['i']
{
L1136: (referenceLongValues[i],r) 
}
array table
-----------------------------------------------
referenceLongValues -> [('[i]', 'r', 'normalized', ['i'], 1136)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: i=0  i<1000  i++
induction variable: ['i']
{
L1137: (referenceValues[i]-,r) 
}
array table
-----------------------------------------------
referenceValues -> [('[i]', 'r', 'normalized', ['i'], 1137)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/inflationcpibond.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<N  i++
induction variable: ['i']
{
L1138: (iiData[i].date,r) 
L1139: (iiData[i].rate/,r) 
}
array table
-----------------------------------------------
iiData -> [('[i]', 'r', 'normalized', ['i'], 1138), ('[i]', 'r', 'normalized', ['i'], 1139)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<LENGTH(fixData)  ++i
induction variable: ['i']
{
L1140: (rpiSchedule[i],r) (fixData[i],r) 
}
array table
-----------------------------------------------
rpiSchedule -> [('[i]', 'r', 'normalized', ['i'], 1140)]
LDEs formed:0

fixData -> [('[i]', 'r', 'normalized', ['i'], 1140)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/extendedtrees.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<LENGTH(types)  i++
induction variable: ['i']
{
	loop info: Size j=0  j<LENGTH(strikes)  j++
	induction variable: ['i', 'j']
	{
		loop info: Size k=0  k<LENGTH(lengths)  k++
		induction variable: ['i', 'j', 'k']
		{
		L1141: (lengths[k]*,r) 
		L1142: (types[i],r) (strikes[j],r) 
			loop info: Size l=0  l<LENGTH(underlyings)  l++
			induction variable: ['i', 'j', 'k', 'l']
			{
				loop info: Size m=0  m<LENGTH(qRates)  m++
				induction variable: ['i', 'j', 'k', 'l', 'm']
				{
					loop info: Size n=0  n<LENGTH(rRates)  n++
					induction variable: ['i', 'j', 'k', 'l', 'm', 'n']
					{
						loop info: Size p=0  p<LENGTH(vols)  p++
						induction variable: ['i', 'j', 'k', 'l', 'm', 'n', 'p']
						{
						L1143: (underlyings[l],r) 
						L1144: (qRates[m],r) 
						L1145: (rRates[n],r) 
						L1146: (vols[p],r) 
						L1147: (expected["value"]=,w) 
						L1148: (calculated["value"]=,w) 
						L1149: (expected["delta"]=,w) 
						L1150: (expected["gamma"]=,w) 
						L1151: (expected["theta"]=,w) 
						L1152: (calculated["delta"]=,w) 
						L1153: (calculated["gamma"]=,w) 
						L1154: (calculated["theta"]=,w) 
						L1155: (calculated[greek],r) 
						}
 					}
 				}
 			}
 		}
 	}
 }
array table
-----------------------------------------------
rRates -> [('[n]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p'], 1145)]
LDEs formed:0

lengths -> [('[k]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p'], 1141)]
LDEs formed:0

calculated -> [('["value"]', 'w', 'not normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p'], 1148), ('["delta"]', 'w', 'not normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p'], 1152), ('["gamma"]', 'w', 'not normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p'], 1153), ('["theta"]', 'w', 'not normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p'], 1154), ('[greek]', 'r', 'not normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p'], 1155)]
LDEs formed:14

qRates -> [('[m]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p'], 1144)]
LDEs formed:0

strikes -> [('[j]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p'], 1142)]
LDEs formed:0

underlyings -> [('[l]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p'], 1143)]
LDEs formed:0

vols -> [('[p]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p'], 1146)]
LDEs formed:0

expected -> [('["value"]', 'w', 'not normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p'], 1147), ('["delta"]', 'w', 'not normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p'], 1149), ('["gamma"]', 'w', 'not normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p'], 1150), ('["theta"]', 'w', 'not normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p'], 1151)]
LDEs formed:10

types -> [('[i]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p'], 1142)]
LDEs formed:0

distinct LDEs:
"delta"="delta"
"delta"="gamma"
"gamma"="theta"
"value"="delta"
"gamma"="gamma"
"value"="gamma"
"delta"=greek
"delta"="theta"
"value"=greek
"theta"="theta"
"value"="value"
"theta"=greek
"gamma"=greek
"value"="theta"
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/timeseries.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: int i = 0  d < d1  ++i, d = calendar.advance(d, 1, Days
induction variable: ['i', 'd']
{
L1143: (ts1[d]=,w) 
}
array table
-----------------------------------------------
ts1 -> [('[d]', 'w', 'normalized', ['i', 'd'], 1143)]
LDEs formed:1

distinct LDEs:
d1=d2
#########################################################################################
loop info: int i = 0  d < d1  ++i, d = calendar.advance(d, 1, Days
induction variable: ['i', 'd']
{
L1144: (ts1[d],r) 
}
array table
-----------------------------------------------
ts1 -> [('[d]', 'r', 'normalized', ['i', 'd'], 1144)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/riskstats.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: i=0  i<LENGTH(averages)  i++
induction variable: ['i']
{
	loop info: j=0  j<LENGTH(sigmas)  j++
	induction variable: ['i', 'j']
	{
	L1145: (averages[i],r) (sigmas[j],r) 
	L1146: (averages[i],r) (sigmas[j],r) 
	L1147: (averages[i],r) (sigmas[j],r) 
		loop info: k=0  k<N  k++
		induction variable: ['i', 'j', 'k']
		{
		L1148: (data[k]=,w) (value[0],r) 
		L1149: (data[k],r) 
		L1150: (data[k],r) 
		L1151: (weights[k]=,w) 
		}
	L1152: (averages[i],r) 
	L1153: (averages[i]<<,r) 
	L1154: (sigmas[j]<<,r) 
	L1155: (averages[i]<<,r) 
	L1156: (sigmas[j]<<,r) 
	L1157: (sigmas[j]*,r) (sigmas[j],r) 
	L1158: (averages[i]<<,r) 
	L1159: (sigmas[j]<<,r) 
	L1160: (averages[i]<<,r) 
	L1161: (sigmas[j]<<,r) 
	L1162: (sigmas[j],r) 
	L1163: (averages[i]<<,r) 
	L1164: (sigmas[j]<<,r) 
	L1165: (averages[i]<<,r) 
	L1166: (sigmas[j]<<,r) 
	L1167: (averages[i]<<,r) 
	L1168: (sigmas[j]<<,r) 
	L1169: (averages[i]<<,r) 
	L1170: (sigmas[j]<<,r) 
	L1171: (averages[i]<<,r) 
	L1172: (sigmas[j]<<,r) 
	L1173: (averages[i]<<,r) 
	L1174: (sigmas[j]<<,r) 
	L1175: (averages[i],r) 
	L1176: (averages[i]<<,r) 
	L1177: (sigmas[j]<<,r) 
	L1178: (averages[i]<<,r) 
	L1179: (sigmas[j]<<,r) 
	L1180: (averages[i]<<,r) 
	L1181: (sigmas[j]<<,r) 
	L1182: (averages[i]+,r) (sigmas[j],r) 
	L1183: (averages[i]-,r) (sigmas[j],r) 
	L1184: (averages[i]<<,r) 
	L1185: (sigmas[j]<<,r) 
	L1186: (averages[i]<<,r) 
	L1187: (sigmas[j]<<,r) 
	L1188: (averages[i]<<,r) 
	L1189: (sigmas[j]<<,r) 
	L1190: (averages[i]<<,r) 
	L1191: (sigmas[j]<<,r) 
	L1192: (averages[i]<<,r) 
	L1193: (sigmas[j]<<,r) 
	L1194: (averages[i]<<,r) 
	L1195: (sigmas[j]<<,r) 
	L1196: (averages[i],r) (sigmas[j],r) (averages[i],r) 
	L1197: (averages[i],r) 
	L1198: (sigmas[j]*,r) (sigmas[j],r) 
	L1199: (averages[i]<<,r) 
	L1200: (sigmas[j]<<,r) 
	L1201: (averages[i]<<,r) 
	L1202: (sigmas[j]<<,r) 
	L1203: (averages[i]<<,r) 
	L1204: (sigmas[j]<<,r) 
	L1205: (averages[i],r) 
	L1206: (averages[i]<<,r) 
	L1207: (sigmas[j]<<,r) 
	L1208: (averages[i],r) 
	L1209: (averages[i]<<,r) 
	L1210: (sigmas[j]<<,r) 
	L1211: (averages[i],r) 
	L1212: (averages[i]<<,r) 
	L1213: (sigmas[j]<<,r) 
	L1214: (sigmas[j]/,r) 
	L1215: (averages[i],r) 
	L1216: (averages[i]<<,r) 
	L1217: (sigmas[j]<<,r) 
	L1218: (averages[i],r) 
	L1219: (averages[i]<<,r) 
	L1220: (sigmas[j]<<,r) 
	L1221: (averages[i],r) 
	L1222: (averages[i]<<,r) 
	L1223: (sigmas[j]<<,r) 
	L1224: (sigmas[j]*,r) (sigmas[j],r) 
	L1225: (averages[i],r) 
	L1226: (averages[i]<<,r) 
	L1227: (averages[i]<<,r) 
	L1228: (sigmas[j]<<,r) 
	L1229: (averages[i],r) 
	L1230: (averages[i]<<,r) 
	L1231: (averages[i]<<,r) 
	L1232: (sigmas[j]<<,r) 
	L1233: (averages[i],r) 
	L1234: (averages[i]<<,r) 
	L1235: (averages[i]<<,r) 
	L1236: (sigmas[j]<<,r) 
	L1237: (averages[i]<<,r) 
	L1238: (sigmas[j]<<,r) 
	L1239: (averages[i]<<,r) 
	L1240: (sigmas[j]<<,r) 
	L1241: (averages[i]==,r) 
	L1242: (sigmas[j]*,r) (sigmas[j],r) 
	L1243: (averages[i]<<,r) 
	L1244: (sigmas[j]<<,r) 
	L1245: (averages[i]<<,r) 
	L1246: (sigmas[j]<<,r) 
	L1247: (averages[i]<<,r) 
	L1248: (sigmas[j]<<,r) 
	L1249: (averages[i]<<,r) 
	L1250: (sigmas[j]<<,r) 
	}
 }
array table
-----------------------------------------------
data -> [('[k]', 'w', 'normalized', ['i', 'j', 'k'], 1148), ('[k]', 'r', 'normalized', ['i', 'j', 'k'], 1149), ('[k]', 'r', 'normalized', ['i', 'j', 'k'], 1150)]
LDEs formed:3

averages -> [('[i]', 'r', 'normalized', ['i', 'j', 'k'], 1145), ('[i]', 'r', 'normalized', ['i', 'j', 'k'], 1146), ('[i]', 'r', 'normalized', ['i', 'j', 'k'], 1147), ('[i]', 'r', 'normalized', ['i', 'j', 'k'], 1152), ('[i]', 'r', 'normalized', ['i', 'j', 'k'], 1153), ('[i]', 'r', 'normalized', ['i', 'j', 'k'], 1155), ('[i]', 'r', 'normalized', ['i', 'j', 'k'], 1158), ('[i]', 'r', 'normalized', ['i', 'j', 'k'], 1160), ('[i]', 'r', 'normalized', ['i', 'j', 'k'], 1163), ('[i]', 'r', 'normalized', ['i', 'j', 'k'], 1165), ('[i]', 'r', 'normalized', ['i', 'j', 'k'], 1167), ('[i]', 'r', 'normalized', ['i', 'j', 'k'], 1169), ('[i]', 'r', 'normalized', ['i', 'j', 'k'], 1171), ('[i]', 'r', 'normalized', ['i', 'j', 'k'], 1173), ('[i]', 'r', 'normalized', ['i', 'j', 'k'], 1175), ('[i]', 'r', 'normalized', ['i', 'j', 'k'], 1176), ('[i]', 'r', 'normalized', ['i', 'j', 'k'], 1178), ('[i]', 'r', 'normalized', ['i', 'j', 'k'], 1180), ('[i]', 'r', 'normalized', ['i', 'j', 'k'], 1182), ('[i]', 'r', 'normalized', ['i', 'j', 'k'], 1183), ('[i]', 'r', 'normalized', ['i', 'j', 'k'], 1184), ('[i]', 'r', 'normalized', ['i', 'j', 'k'], 1186), ('[i]', 'r', 'normalized', ['i', 'j', 'k'], 1188), ('[i]', 'r', 'normalized', ['i', 'j', 'k'], 1190), ('[i]', 'r', 'normalized', ['i', 'j', 'k'], 1192), ('[i]', 'r', 'normalized', ['i', 'j', 'k'], 1194), ('[i]', 'r', 'normalized', ['i', 'j', 'k'], 1196), ('[i]', 'r', 'normalized', ['i', 'j', 'k'], 1196), ('[i]', 'r', 'normalized', ['i', 'j', 'k'], 1197), ('[i]', 'r', 'normalized', ['i', 'j', 'k'], 1199), ('[i]', 'r', 'normalized', ['i', 'j', 'k'], 1201), ('[i]', 'r', 'normalized', ['i', 'j', 'k'], 1203), ('[i]', 'r', 'normalized', ['i', 'j', 'k'], 1205), ('[i]', 'r', 'normalized', ['i', 'j', 'k'], 1206), ('[i]', 'r', 'normalized', ['i', 'j', 'k'], 1208), ('[i]', 'r', 'normalized', ['i', 'j', 'k'], 1209), ('[i]', 'r', 'normalized', ['i', 'j', 'k'], 1211), ('[i]', 'r', 'normalized', ['i', 'j', 'k'], 1212), ('[i]', 'r', 'normalized', ['i', 'j', 'k'], 1215), ('[i]', 'r', 'normalized', ['i', 'j', 'k'], 1216), ('[i]', 'r', 'normalized', ['i', 'j', 'k'], 1218), ('[i]', 'r', 'normalized', ['i', 'j', 'k'], 1219), ('[i]', 'r', 'normalized', ['i', 'j', 'k'], 1221), ('[i]', 'r', 'normalized', ['i', 'j', 'k'], 1222), ('[i]', 'r', 'normalized', ['i', 'j', 'k'], 1225), ('[i]', 'r', 'normalized', ['i', 'j', 'k'], 1226), ('[i]', 'r', 'normalized', ['i', 'j', 'k'], 1227), ('[i]', 'r', 'normalized', ['i', 'j', 'k'], 1229), ('[i]', 'r', 'normalized', ['i', 'j', 'k'], 1230), ('[i]', 'r', 'normalized', ['i', 'j', 'k'], 1231), ('[i]', 'r', 'normalized', ['i', 'j', 'k'], 1233), ('[i]', 'r', 'normalized', ['i', 'j', 'k'], 1234), ('[i]', 'r', 'normalized', ['i', 'j', 'k'], 1235), ('[i]', 'r', 'normalized', ['i', 'j', 'k'], 1237), ('[i]', 'r', 'normalized', ['i', 'j', 'k'], 1239), ('[i]', 'r', 'normalized', ['i', 'j', 'k'], 1241), ('[i]', 'r', 'normalized', ['i', 'j', 'k'], 1243), ('[i]', 'r', 'normalized', ['i', 'j', 'k'], 1245), ('[i]', 'r', 'normalized', ['i', 'j', 'k'], 1247), ('[i]', 'r', 'normalized', ['i', 'j', 'k'], 1249)]
LDEs formed:0

value -> [('[0]', 'r', 'normalized', ['i', 'j', 'k'], 1148)]
LDEs formed:0

sigmas -> [('[j]', 'r', 'normalized', ['i', 'j', 'k'], 1145), ('[j]', 'r', 'normalized', ['i', 'j', 'k'], 1146), ('[j]', 'r', 'normalized', ['i', 'j', 'k'], 1147), ('[j]', 'r', 'normalized', ['i', 'j', 'k'], 1154), ('[j]', 'r', 'normalized', ['i', 'j', 'k'], 1156), ('[j]', 'r', 'normalized', ['i', 'j', 'k'], 1157), ('[j]', 'r', 'normalized', ['i', 'j', 'k'], 1157), ('[j]', 'r', 'normalized', ['i', 'j', 'k'], 1159), ('[j]', 'r', 'normalized', ['i', 'j', 'k'], 1161), ('[j]', 'r', 'normalized', ['i', 'j', 'k'], 1162), ('[j]', 'r', 'normalized', ['i', 'j', 'k'], 1164), ('[j]', 'r', 'normalized', ['i', 'j', 'k'], 1166), ('[j]', 'r', 'normalized', ['i', 'j', 'k'], 1168), ('[j]', 'r', 'normalized', ['i', 'j', 'k'], 1170), ('[j]', 'r', 'normalized', ['i', 'j', 'k'], 1172), ('[j]', 'r', 'normalized', ['i', 'j', 'k'], 1174), ('[j]', 'r', 'normalized', ['i', 'j', 'k'], 1177), ('[j]', 'r', 'normalized', ['i', 'j', 'k'], 1179), ('[j]', 'r', 'normalized', ['i', 'j', 'k'], 1181), ('[j]', 'r', 'normalized', ['i', 'j', 'k'], 1182), ('[j]', 'r', 'normalized', ['i', 'j', 'k'], 1183), ('[j]', 'r', 'normalized', ['i', 'j', 'k'], 1185), ('[j]', 'r', 'normalized', ['i', 'j', 'k'], 1187), ('[j]', 'r', 'normalized', ['i', 'j', 'k'], 1189), ('[j]', 'r', 'normalized', ['i', 'j', 'k'], 1191), ('[j]', 'r', 'normalized', ['i', 'j', 'k'], 1193), ('[j]', 'r', 'normalized', ['i', 'j', 'k'], 1195), ('[j]', 'r', 'normalized', ['i', 'j', 'k'], 1196), ('[j]', 'r', 'normalized', ['i', 'j', 'k'], 1198), ('[j]', 'r', 'normalized', ['i', 'j', 'k'], 1198), ('[j]', 'r', 'normalized', ['i', 'j', 'k'], 1200), ('[j]', 'r', 'normalized', ['i', 'j', 'k'], 1202), ('[j]', 'r', 'normalized', ['i', 'j', 'k'], 1204), ('[j]', 'r', 'normalized', ['i', 'j', 'k'], 1207), ('[j]', 'r', 'normalized', ['i', 'j', 'k'], 1210), ('[j]', 'r', 'normalized', ['i', 'j', 'k'], 1213), ('[j]', 'r', 'normalized', ['i', 'j', 'k'], 1214), ('[j]', 'r', 'normalized', ['i', 'j', 'k'], 1217), ('[j]', 'r', 'normalized', ['i', 'j', 'k'], 1220), ('[j]', 'r', 'normalized', ['i', 'j', 'k'], 1223), ('[j]', 'r', 'normalized', ['i', 'j', 'k'], 1224), ('[j]', 'r', 'normalized', ['i', 'j', 'k'], 1224), ('[j]', 'r', 'normalized', ['i', 'j', 'k'], 1228), ('[j]', 'r', 'normalized', ['i', 'j', 'k'], 1232), ('[j]', 'r', 'normalized', ['i', 'j', 'k'], 1236), ('[j]', 'r', 'normalized', ['i', 'j', 'k'], 1238), ('[j]', 'r', 'normalized', ['i', 'j', 'k'], 1240), ('[j]', 'r', 'normalized', ['i', 'j', 'k'], 1242), ('[j]', 'r', 'normalized', ['i', 'j', 'k'], 1242), ('[j]', 'r', 'normalized', ['i', 'j', 'k'], 1244), ('[j]', 'r', 'normalized', ['i', 'j', 'k'], 1246), ('[j]', 'r', 'normalized', ['i', 'j', 'k'], 1248), ('[j]', 'r', 'normalized', ['i', 'j', 'k'], 1250)]
LDEs formed:0

weights -> [('[k]', 'w', 'normalized', ['i', 'j', 'k'], 1151)]
LDEs formed:1

distinct LDEs:
k1=k2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/inflationcpicapfloor.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<N  i++
induction variable: ['i']
{
L1152: (iiData[i].date,r) 
L1153: (iiData[i].rate/,r) 
}
array table
-----------------------------------------------
iiData -> [('[i]', 'r', 'normalized', ['i'], 1152), ('[i]', 'r', 'normalized', ['i'], 1153)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<rpiSchedule.size() i++
induction variable: ['i']
{
L1154: (rpiSchedule[i],r) (fixData[i],r) 
}
array table
-----------------------------------------------
rpiSchedule -> [('[i]', 'r', 'normalized', ['i'], 1154)]
LDEs formed:0

fixData -> [('[i]', 'r', 'normalized', ['i'], 1154)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i = 0  i < nominalDataLength  i++
induction variable: ['i']
{
L1155: (nominalData[i].date,r) 
L1156: (nominalData[i].rate/,r) 
}
array table
-----------------------------------------------
nominalData -> [('[i]', 'r', 'normalized', ['i'], 1155), ('[i]', 'r', 'normalized', ['i'], 1156)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i = 0  i < zciisDataLength  i++
induction variable: ['i']
{
L1157: (zciisData[i].date,r) 
L1158: (zciisData[i].rate,r) 
}
array table
-----------------------------------------------
zciisData -> [('[i]', 'r', 'normalized', ['i'], 1157), ('[i]', 'r', 'normalized', ['i'], 1158)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i = 0  i < ncStrikes  i++
induction variable: ['i']
{
	loop info: Size j = 0  j < ncfMaturities  j++
	induction variable: ['i', 'j']
	{
	L1159: (cPrice[j][i]/,r) 
	}
 }
array table
-----------------------------------------------
cPrice -> [('[j][i]', 'r', 'normalized', ['i', 'j'], 1159)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i = 0  i < nfStrikes  i++
induction variable: ['i']
{
	loop info: Size j = 0  j < ncfMaturities  j++
	induction variable: ['i', 'j']
	{
	L1160: (fPrice[j][i]/,r) 
	}
 }
array table
-----------------------------------------------
fPrice -> [('[j][i]', 'r', 'normalized', ['i', 'j'], 1160)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i =0  i<common.fStrikesUK.size()  i++
induction variable: ['i']
{
L1161: (common.fStrikesUK[i],r) 
	loop info: Size j=0  j<nMat  j++
	induction variable: ['i', 'j']
	{
	L1162: (common.cfMaturitiesUK[j],r) 
	}
 }
array table
-----------------------------------------------
common.cfMaturitiesUK -> [('[j]', 'r', 'normalized', ['i', 'j'], 1162)]
LDEs formed:0

common.fStrikesUK -> [('[i]', 'r', 'normalized', ['i', 'j'], 1161)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i =0  i<common.cStrikesUK.size()  i++
induction variable: ['i']
{
L1162: (common.cStrikesUK[i],r) 
	loop info: Size j=0  j<nMat  j++
	induction variable: ['i', 'j']
	{
	L1163: (common.cfMaturitiesUK[j],r) 
	}
 }
array table
-----------------------------------------------
common.cfMaturitiesUK -> [('[j]', 'r', 'normalized', ['i', 'j'], 1163)]
LDEs formed:0

common.cStrikesUK -> [('[i]', 'r', 'normalized', ['i', 'j'], 1162)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/marketmodel_smmcaplethomocalibration.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<todaysForwards_.size()  ++i
induction variable: ['i']
{
L1163: (todaysForwards_[i]=,w) 
L1164: (todaysForwards_[i]=,w) 
}
array table
-----------------------------------------------
todaysForwards_ -> [('[i]', 'w', 'normalized', ['i'], 1163), ('[i]', 'w', 'normalized', ['i'], 1164)]
LDEs formed:3

distinct LDEs:
i1=i2
#########################################################################################
loop info: Size i=0  i<todaysSwaps_.size()  i++
induction variable: ['i']
{
L1165: (swaptionDisplacedVols[i]=,w) (todaysSwaps[i]*,r) (mktSwaptionVols[i]/,r) 
L1166: (todaysSwaps[i]+,r) 
L1167: (swaptionVols[i]=,w) (mktSwaptionVols[i],r) 
L1168: (capletDisplacedVols[i]=,w) (todaysForwards[i]*,r) (mktCapletVols[i]/,r) 
L1169: (todaysForwards[i]+,r) 
L1170: (capletVols_[i]=,w) (mktCapletVols[i],r) 
}
array table
-----------------------------------------------
todaysForwards -> [('[i]', 'r', 'normalized', ['i'], 1168), ('[i]', 'r', 'normalized', ['i'], 1169)]
LDEs formed:0

todaysSwaps -> [('[i]', 'r', 'normalized', ['i'], 1165), ('[i]', 'r', 'normalized', ['i'], 1166)]
LDEs formed:0

capletDisplacedVols -> [('[i]', 'w', 'normalized', ['i'], 1168)]
LDEs formed:1

swaptionDisplacedVols -> [('[i]', 'w', 'normalized', ['i'], 1165)]
LDEs formed:1

swaptionVols -> [('[i]', 'w', 'normalized', ['i'], 1167)]
LDEs formed:1

capletVols_ -> [('[i]', 'w', 'normalized', ['i'], 1170)]
LDEs formed:1

mktCapletVols -> [('[i]', 'r', 'normalized', ['i'], 1168), ('[i]', 'r', 'normalized', ['i'], 1170)]
LDEs formed:0

mktSwaptionVols -> [('[i]', 'r', 'normalized', ['i'], 1165), ('[i]', 'r', 'normalized', ['i'], 1167)]
LDEs formed:0

distinct LDEs:
i1=i2
#########################################################################################
loop info: Size i=0  i<numberOfRates  ++i
induction variable: ['i']
{
L1168: (swapVariances[i]=,w) 
}
array table
-----------------------------------------------
swapVariances -> [('[i]', 'w', 'normalized', ['i'], 1168)]
LDEs formed:1

distinct LDEs:
i1=i2
#########################################################################################
loop info: Size i=0  i<numberOfRates  ++i
induction variable: ['i']
{
L1169: (capletVols[i]=,w) (capletTotCovariance[i][i]/,r) (rateTimes_[i],r) 
}
array table
-----------------------------------------------
capletVols -> [('[i]', 'w', 'normalized', ['i'], 1169)]
LDEs formed:1

capletTotCovariance -> [('[i][i]', 'r', 'normalized', ['i'], 1169)]
LDEs formed:0

rateTimes_ -> [('[i]', 'r', 'normalized', ['i'], 1169)]
LDEs formed:0

distinct LDEs:
i1=i2
#########################################################################################
loop info: Size i=0  i<numberOfRates  ++i
induction variable: ['i']
{
L1170: (swapVariances[i]-,r) 
L1171: (swapPseudoRoots[i]*,r) (swapPseudoRoots[i],r) 
L1172: (swapTerminalCovariance[i][i]/,r) (rateTimes_[i],r) 
}
array table
-----------------------------------------------
swapTerminalCovariance -> [('[i][i]', 'r', 'normalized', ['i'], 1172)]
LDEs formed:0

swapPseudoRoots -> [('[i]', 'r', 'normalized', ['i'], 1171), ('[i]', 'r', 'normalized', ['i'], 1171)]
LDEs formed:0

swapVariances -> [('[i]', 'r', 'normalized', ['i'], 1170)]
LDEs formed:0

rateTimes_ -> [('[i]', 'r', 'normalized', ['i'], 1172)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<numberOfRates  ++i
induction variable: ['i']
{
L1173: (capletVols[i]-,r) (capletVols_[i],r) 
L1174: (capletVols_[i],r) 
L1175: (capletVols[i],r) 
L1176: (capletVols_[i]<<,r) 
}
array table
-----------------------------------------------
capletVols -> [('[i]', 'r', 'normalized', ['i'], 1173), ('[i]', 'r', 'normalized', ['i'], 1175)]
LDEs formed:0

capletVols_ -> [('[i]', 'r', 'normalized', ['i'], 1173), ('[i]', 'r', 'normalized', ['i'], 1174), ('[i]', 'r', 'normalized', ['i'], 1176)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<numberOfRates  ++i
induction variable: ['i']
{
L1177: (capletVols[i]=,w) (capletTotCovariance[i][i]/,r) (rateTimes_[i],r) 
}
array table
-----------------------------------------------
capletVols -> [('[i]', 'w', 'normalized', ['i'], 1177)]
LDEs formed:1

capletTotCovariance -> [('[i][i]', 'r', 'normalized', ['i'], 1177)]
LDEs formed:0

rateTimes_ -> [('[i]', 'r', 'normalized', ['i'], 1177)]
LDEs formed:0

distinct LDEs:
i1=i2
#########################################################################################
loop info: Size i=0  i<numberOfRates  ++i
induction variable: ['i']
{
L1178: (capletVols[i]-,r) (capletVols_[i],r) 
L1179: (capletVols_[i],r) 
L1180: (capletVols[i],r) 
L1181: (capletVols_[i]<<,r) 
}
array table
-----------------------------------------------
capletVols -> [('[i]', 'r', 'normalized', ['i'], 1178), ('[i]', 'r', 'normalized', ['i'], 1180)]
LDEs formed:0

capletVols_ -> [('[i]', 'r', 'normalized', ['i'], 1178), ('[i]', 'r', 'normalized', ['i'], 1179), ('[i]', 'r', 'normalized', ['i'], 1181)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<numberBigRates  ++i
induction variable: ['i']
{
L1182: (swapVariances[i].totalVolatility,r) 
L1183: (swapTerminalCovariance[i][i],r) 
L1184: (swapTerminalCovariance[i][i]/,r) 
}
array table
-----------------------------------------------
swapTerminalCovariance -> [('[i][i]', 'r', 'normalized', ['i'], 1183), ('[i][i]', 'r', 'normalized', ['i'], 1184)]
LDEs formed:0

swapVariances -> [('[i]', 'r', 'normalized', ['i'], 1182)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/interestrates.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<LENGTH(cases)  i++
induction variable: ['i']
{
L1183: (cases[i].r,r) 
L1184: (cases[i].comp,r) (cases[i].freq,r) 
L1185: (cases[i].t+,r) 
L1186: (cases[i].precision,r) 
L1187: (cases[i].comp2,r) (cases[i].freq2,r) 
L1188: (cases[i].expected,r) 
L1189: (cases[i].comp2,r) (cases[i].freq2,r) 
L1190: (cases[i].precision+,r) 
L1191: (cases[i].comp2,r) (cases[i].freq2,r) 
L1192: (cases[i].expected,r) 
L1193: (cases[i].precision-,r) 
L1194: (cases[i].expected,r) 
}
array table
-----------------------------------------------
cases -> [('[i]', 'r', 'normalized', ['i'], 1183), ('[i]', 'r', 'normalized', ['i'], 1184), ('[i]', 'r', 'normalized', ['i'], 1184), ('[i]', 'r', 'normalized', ['i'], 1185), ('[i]', 'r', 'normalized', ['i'], 1186), ('[i]', 'r', 'normalized', ['i'], 1187), ('[i]', 'r', 'normalized', ['i'], 1187), ('[i]', 'r', 'normalized', ['i'], 1188), ('[i]', 'r', 'normalized', ['i'], 1189), ('[i]', 'r', 'normalized', ['i'], 1189), ('[i]', 'r', 'normalized', ['i'], 1190), ('[i]', 'r', 'normalized', ['i'], 1191), ('[i]', 'r', 'normalized', ['i'], 1191), ('[i]', 'r', 'normalized', ['i'], 1192), ('[i]', 'r', 'normalized', ['i'], 1193), ('[i]', 'r', 'normalized', ['i'], 1194)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/operators.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<n  ++i
induction variable: ['i']
{
L1195: (final[i],r) (original[i],r) 
}
array table
-----------------------------------------------
final -> [('[i]', 'r', 'normalized', ['i'], 1195)]
LDEs formed:0

original -> [('[i]', 'r', 'normalized', ['i'], 1195)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<n  ++i
induction variable: ['i']
{
L1196: (temp[i],r) (intermediate[i],r) 
}
array table
-----------------------------------------------
intermediate -> [('[i]', 'r', 'normalized', ['i'], 1196)]
LDEs formed:0

temp -> [('[i]', 'r', 'normalized', ['i'], 1196)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<n  ++i
induction variable: ['i']
{
L1197: (final[i],r) (original[i],r) 
}
array table
-----------------------------------------------
final -> [('[i]', 'r', 'normalized', ['i'], 1197)]
LDEs formed:0

original -> [('[i]', 'r', 'normalized', ['i'], 1197)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<n  ++i
induction variable: ['i']
{
L1198: (temp[i],r) (intermediate[i],r) 
}
array table
-----------------------------------------------
intermediate -> [('[i]', 'r', 'normalized', ['i'], 1198)]
LDEs formed:0

temp -> [('[i]', 'r', 'normalized', ['i'], 1198)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<n  ++i
induction variable: ['i']
{
L1199: (final[i],r) (original[i],r) 
}
array table
-----------------------------------------------
final -> [('[i]', 'r', 'normalized', ['i'], 1199)]
LDEs formed:0

original -> [('[i]', 'r', 'normalized', ['i'], 1199)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<n  ++i
induction variable: ['i']
{
L1200: (final[i]-,r) (original[i],r) 
L1201: (temp[i],r) (intermediate[i],r) 
}
array table
-----------------------------------------------
intermediate -> [('[i]', 'r', 'normalized', ['i'], 1201)]
LDEs formed:0

final -> [('[i]', 'r', 'normalized', ['i'], 1200)]
LDEs formed:0

temp -> [('[i]', 'r', 'normalized', ['i'], 1201)]
LDEs formed:0

original -> [('[i]', 'r', 'normalized', ['i'], 1200)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: i = 0  i < grid.size()  i++
induction variable: ['i']
{
L1201: (grid[i]=,w) 
}
array table
-----------------------------------------------
grid -> [('[i]', 'w', 'normalized', ['i'], 1201)]
LDEs formed:1

distinct LDEs:
i1=i2
#########################################################################################
loop info: i=2  i<grid.size()-2  i++
induction variable: ['i']
{
L1202: (lderror[i],r) 
L1203: (derror[i],r) 
L1204: (uderror[i],r) 
}
array table
-----------------------------------------------
derror -> [('[i]', 'r', 'normalized', ['i'], 1203)]
LDEs formed:0

uderror -> [('[i]', 'r', 'normalized', ['i'], 1204)]
LDEs formed:0

lderror -> [('[i]', 'r', 'normalized', ['i'], 1202)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: i=2  i<grid.size()-2  i++
induction variable: ['i']
{
L1203: (lderror[i],r) 
L1204: (derror[i],r) 
L1205: (uderror[i],r) 
}
array table
-----------------------------------------------
derror -> [('[i]', 'r', 'normalized', ['i'], 1204)]
LDEs formed:0

uderror -> [('[i]', 'r', 'normalized', ['i'], 1205)]
LDEs formed:0

lderror -> [('[i]', 'r', 'normalized', ['i'], 1203)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/basketoption.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<LENGTH(values)  i++
induction variable: ['i']
{
L1204: (values[i].type,r) (values[i].strike,r) 
L1205: (values[i].t*,r) 
L1206: (values[i].s1,r) 
L1207: (values[i].s2,r) 
L1208: (values[i].q1,r) 
L1209: (values[i].q2,r) 
L1210: (values[i].r,r) 
L1211: (values[i].v1,r) 
L1212: (values[i].v2,r) 
L1213: (values[i].basketType,r) 
L1214: (values[i].rho,r) 
L1215: (values[i].rho,r) 
L1216: (values[i].rho,r) 
	loop info: Integer j=0  j < 2  j++
	induction variable: ['i', 'j']
	{
	L1217: (correlationMatrix[j][j]=,w) 
	}
L1218: (values[i].rho,r) 
L1219: (values[i].basketType,r) 
L1220: (values[i].result,r) 
L1221: (values[i].tol,r) 
L1222: (values[i].basketType,r) 
L1223: (values[i].s1,r) (values[i].s2,r) (values[i].q1,r) 
L1224: (values[i].q2,r) (values[i].r,r) (values[i].v1,r) 
L1225: (values[i].v2,r) (values[i].rho,r) (values[i].result,r) 
L1226: (values[i].tol,r) 
L1227: (values[i].basketType,r) 
L1228: (values[i].s1,r) (values[i].s2,r) 
L1229: (values[i].q1,r) (values[i].q2,r) (values[i].r,r) 
L1230: (values[i].v1,r) (values[i].v2,r) (values[i].rho,r) 
L1231: (values[i].result,r) 
L1232: (values[i].s1,r) 
L1233: (values[i].basketType,r) 
L1234: (values[i].s1,r) (values[i].s2,r) 
L1235: (values[i].q1,r) (values[i].q2,r) (values[i].r,r) 
L1236: (values[i].v1,r) (values[i].v2,r) (values[i].rho,r) 
L1237: (values[i].result,r) 
}
array table
-----------------------------------------------
values -> [('[i]', 'r', 'normalized', ['i', 'j'], 1204), ('[i]', 'r', 'normalized', ['i', 'j'], 1204), ('[i]', 'r', 'normalized', ['i', 'j'], 1205), ('[i]', 'r', 'normalized', ['i', 'j'], 1206), ('[i]', 'r', 'normalized', ['i', 'j'], 1207), ('[i]', 'r', 'normalized', ['i', 'j'], 1208), ('[i]', 'r', 'normalized', ['i', 'j'], 1209), ('[i]', 'r', 'normalized', ['i', 'j'], 1210), ('[i]', 'r', 'normalized', ['i', 'j'], 1211), ('[i]', 'r', 'normalized', ['i', 'j'], 1212), ('[i]', 'r', 'normalized', ['i', 'j'], 1213), ('[i]', 'r', 'normalized', ['i', 'j'], 1214), ('[i]', 'r', 'normalized', ['i', 'j'], 1215), ('[i]', 'r', 'normalized', ['i', 'j'], 1216), ('[i]', 'r', 'normalized', ['i', 'j'], 1218), ('[i]', 'r', 'normalized', ['i', 'j'], 1219), ('[i]', 'r', 'normalized', ['i', 'j'], 1220), ('[i]', 'r', 'normalized', ['i', 'j'], 1221), ('[i]', 'r', 'normalized', ['i', 'j'], 1222), ('[i]', 'r', 'normalized', ['i', 'j'], 1223), ('[i]', 'r', 'normalized', ['i', 'j'], 1223), ('[i]', 'r', 'normalized', ['i', 'j'], 1223), ('[i]', 'r', 'normalized', ['i', 'j'], 1224), ('[i]', 'r', 'normalized', ['i', 'j'], 1224), ('[i]', 'r', 'normalized', ['i', 'j'], 1224), ('[i]', 'r', 'normalized', ['i', 'j'], 1225), ('[i]', 'r', 'normalized', ['i', 'j'], 1225), ('[i]', 'r', 'normalized', ['i', 'j'], 1225), ('[i]', 'r', 'normalized', ['i', 'j'], 1226), ('[i]', 'r', 'normalized', ['i', 'j'], 1227), ('[i]', 'r', 'normalized', ['i', 'j'], 1228), ('[i]', 'r', 'normalized', ['i', 'j'], 1228), ('[i]', 'r', 'normalized', ['i', 'j'], 1229), ('[i]', 'r', 'normalized', ['i', 'j'], 1229), ('[i]', 'r', 'normalized', ['i', 'j'], 1229), ('[i]', 'r', 'normalized', ['i', 'j'], 1230), ('[i]', 'r', 'normalized', ['i', 'j'], 1230), ('[i]', 'r', 'normalized', ['i', 'j'], 1230), ('[i]', 'r', 'normalized', ['i', 'j'], 1231), ('[i]', 'r', 'normalized', ['i', 'j'], 1232), ('[i]', 'r', 'normalized', ['i', 'j'], 1233), ('[i]', 'r', 'normalized', ['i', 'j'], 1234), ('[i]', 'r', 'normalized', ['i', 'j'], 1234), ('[i]', 'r', 'normalized', ['i', 'j'], 1235), ('[i]', 'r', 'normalized', ['i', 'j'], 1235), ('[i]', 'r', 'normalized', ['i', 'j'], 1235), ('[i]', 'r', 'normalized', ['i', 'j'], 1236), ('[i]', 'r', 'normalized', ['i', 'j'], 1236), ('[i]', 'r', 'normalized', ['i', 'j'], 1236), ('[i]', 'r', 'normalized', ['i', 'j'], 1237)]
LDEs formed:0

correlationMatrix -> [('[j][j]', 'w', 'normalized', ['i', 'j'], 1217)]
LDEs formed:2

distinct LDEs:
j1=j2,j1=j2
#########################################################################################
loop info: Size i=0  i<LENGTH(values)  i++
induction variable: ['i']
{
L1218: (values[i].type,r) (values[i].strike,r) 
L1219: (values[i].t,r) 
L1220: (values[i].s1,r) 
L1221: (values[i].s2,r) 
L1222: (values[i].s3,r) 
L1223: (values[i].r,r) 
L1224: (values[i].v1,r) 
L1225: (values[i].v2,r) 
L1226: (values[i].v3,r) 
L1227: (values[i].rho,r) 
	loop info: Integer j=0  j < 3  j++
	induction variable: ['i', 'j']
	{
	L1228: (correlation[j][j]=,w) 
	}
L1229: (values[i].basketType,r) 
L1230: (values[i].euroValue,r) 
L1231: (values[i].s1,r) 
L1232: (values[i].basketType,r) 
L1233: (values[i].s1,r) (values[i].s2,r) 
L1234: (values[i].s3,r) (values[i].r,r) (values[i].v1,r) 
L1235: (values[i].v2,r) (values[i].v3,r) (values[i].rho,r) 
L1236: (values[i].euroValue,r) 
L1237: (values[i].basketType,r) 
L1238: (values[i].amValue,r) 
L1239: (values[i].s1,r) 
L1240: (values[i].basketType,r) 
L1241: (values[i].s1,r) (values[i].s2,r) 
L1242: (values[i].s3,r) (values[i].r,r) (values[i].v1,r) 
L1243: (values[i].v2,r) (values[i].v3,r) (values[i].rho,r) 
L1244: (values[i].amValue,r) 
}
array table
-----------------------------------------------
values -> [('[i]', 'r', 'normalized', ['i', 'j'], 1218), ('[i]', 'r', 'normalized', ['i', 'j'], 1218), ('[i]', 'r', 'normalized', ['i', 'j'], 1219), ('[i]', 'r', 'normalized', ['i', 'j'], 1220), ('[i]', 'r', 'normalized', ['i', 'j'], 1221), ('[i]', 'r', 'normalized', ['i', 'j'], 1222), ('[i]', 'r', 'normalized', ['i', 'j'], 1223), ('[i]', 'r', 'normalized', ['i', 'j'], 1224), ('[i]', 'r', 'normalized', ['i', 'j'], 1225), ('[i]', 'r', 'normalized', ['i', 'j'], 1226), ('[i]', 'r', 'normalized', ['i', 'j'], 1227), ('[i]', 'r', 'normalized', ['i', 'j'], 1229), ('[i]', 'r', 'normalized', ['i', 'j'], 1230), ('[i]', 'r', 'normalized', ['i', 'j'], 1231), ('[i]', 'r', 'normalized', ['i', 'j'], 1232), ('[i]', 'r', 'normalized', ['i', 'j'], 1233), ('[i]', 'r', 'normalized', ['i', 'j'], 1233), ('[i]', 'r', 'normalized', ['i', 'j'], 1234), ('[i]', 'r', 'normalized', ['i', 'j'], 1234), ('[i]', 'r', 'normalized', ['i', 'j'], 1234), ('[i]', 'r', 'normalized', ['i', 'j'], 1235), ('[i]', 'r', 'normalized', ['i', 'j'], 1235), ('[i]', 'r', 'normalized', ['i', 'j'], 1235), ('[i]', 'r', 'normalized', ['i', 'j'], 1236), ('[i]', 'r', 'normalized', ['i', 'j'], 1237), ('[i]', 'r', 'normalized', ['i', 'j'], 1238), ('[i]', 'r', 'normalized', ['i', 'j'], 1239), ('[i]', 'r', 'normalized', ['i', 'j'], 1240), ('[i]', 'r', 'normalized', ['i', 'j'], 1241), ('[i]', 'r', 'normalized', ['i', 'j'], 1241), ('[i]', 'r', 'normalized', ['i', 'j'], 1242), ('[i]', 'r', 'normalized', ['i', 'j'], 1242), ('[i]', 'r', 'normalized', ['i', 'j'], 1242), ('[i]', 'r', 'normalized', ['i', 'j'], 1243), ('[i]', 'r', 'normalized', ['i', 'j'], 1243), ('[i]', 'r', 'normalized', ['i', 'j'], 1243), ('[i]', 'r', 'normalized', ['i', 'j'], 1244)]
LDEs formed:0

correlation -> [('[j][j]', 'w', 'normalized', ['i', 'j'], 1228)]
LDEs formed:2

distinct LDEs:
j1=j2,j1=j2
#########################################################################################
loop info: Integer j=0  j < 3  j++
induction variable: ['j']
{
L1229: (correlation[j][j]=,w) 
}
array table
-----------------------------------------------
correlation -> [('[j][j]', 'w', 'normalized', ['j'], 1229)]
LDEs formed:2

distinct LDEs:
j1=j2,j1=j2
#########################################################################################
loop info: Size i=0  i<LENGTH(values)  i++
induction variable: ['i']
{
L1230: (values[i].type,r) (values[i].strike,r) 
L1231: (values[i].t*,r) 
L1232: (values[i].s,r) 
L1233: (values[i].v,r) 
L1234: (values[i].r,r) 
L1235: (values[i].q,r) 
L1236: (values[i].result,r) 
L1237: (values[i].s,r) 
L1238: (values[i].tol,r) 
L1239: (values[i].result<<,r) 
}
array table
-----------------------------------------------
values -> [('[i]', 'r', 'normalized', ['i'], 1230), ('[i]', 'r', 'normalized', ['i'], 1230), ('[i]', 'r', 'normalized', ['i'], 1231), ('[i]', 'r', 'normalized', ['i'], 1232), ('[i]', 'r', 'normalized', ['i'], 1233), ('[i]', 'r', 'normalized', ['i'], 1234), ('[i]', 'r', 'normalized', ['i'], 1235), ('[i]', 'r', 'normalized', ['i'], 1236), ('[i]', 'r', 'normalized', ['i'], 1237), ('[i]', 'r', 'normalized', ['i'], 1238), ('[i]', 'r', 'normalized', ['i'], 1239)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<LENGTH(values)  i++
induction variable: ['i']
{
L1240: (values[i].type,r) (values[i].strike,r) 
L1241: (values[i].t*,r) 
L1242: (values[i].s,r) 
L1243: (values[i].v,r) 
L1244: (values[i].r,r) 
L1245: (values[i].q,r) 
L1246: (values[i].result,r) 
L1247: (values[i].s,r) 
L1248: (values[i].tol,r) 
L1249: (values[i].result<<,r) 
}
array table
-----------------------------------------------
values -> [('[i]', 'r', 'normalized', ['i'], 1240), ('[i]', 'r', 'normalized', ['i'], 1240), ('[i]', 'r', 'normalized', ['i'], 1241), ('[i]', 'r', 'normalized', ['i'], 1242), ('[i]', 'r', 'normalized', ['i'], 1243), ('[i]', 'r', 'normalized', ['i'], 1244), ('[i]', 'r', 'normalized', ['i'], 1245), ('[i]', 'r', 'normalized', ['i'], 1246), ('[i]', 'r', 'normalized', ['i'], 1247), ('[i]', 'r', 'normalized', ['i'], 1248), ('[i]', 'r', 'normalized', ['i'], 1249)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/ode.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Real t=0.01  t < 11  t+=t
induction variable: ['t']
{
L1250: (expected[0][0]=,w) 
L1251: (expected[0][1]=,w) 
L1252: (expected[0][2]=,w) 
L1253: (expected[1][0]=,w) 
L1254: (expected[1][1]=,w) 
L1255: (expected[1][2]=,w) 
L1256: (expected[2][0]=,w) 
L1257: (expected[2][1]=,w) 
L1258: (expected[2][2]=,w) 
}
array table
-----------------------------------------------
expected -> [('[0][0]', 'w', 'normalized', ['t'], 1250), ('[0][1]', 'w', 'normalized', ['t'], 1251), ('[0][2]', 'w', 'normalized', ['t'], 1252), ('[1][0]', 'w', 'normalized', ['t'], 1253), ('[1][1]', 'w', 'normalized', ['t'], 1254), ('[1][2]', 'w', 'normalized', ['t'], 1255), ('[2][0]', 'w', 'normalized', ['t'], 1256), ('[2][1]', 'w', 'normalized', ['t'], 1257), ('[2][2]', 'w', 'normalized', ['t'], 1258)]
LDEs formed:90

distinct LDEs:
1=1,2=2
0=0,0=2
0=0,0=1
0=0,0=0
0=2,2=2
0=2,2=1
1=2,0=1
2=2,1=2
0=2,2=0
1=2,0=2
1=1,1=2
1=1,1=1
1=2,2=2
1=2,2=0
1=2,2=1
2=2,0=2
2=2,0=1
2=2,0=0
1=2,1=1
1=2,1=0
1=2,1=2
1=2,0=0
1=1,0=2
1=1,0=1
1=1,0=0
2=2,1=1
2=2,2=2
0=2,0=1
0=2,0=0
0=2,0=2
0=1,2=0
0=1,2=1
0=1,2=2
0=0,2=2
0=1,0=2
0=1,0=0
0=1,0=1
0=1,1=2
0=1,1=1
0=1,1=0
0=2,1=0
0=2,1=1
0=2,1=2
0=0,1=2
0=0,1=1
#########################################################################################
loop info: Size i=0  i < calculated.rows()  ++i
induction variable: ['i']
{
	loop info: Size j=0  j < calculated.columns()  ++j
	induction variable: ['i', 'j']
	{
	L1259: (calculated[i][j]-,r) 
	}
 }
array table
-----------------------------------------------
calculated -> [('[i][j]', 'r', 'normalized', ['i', 'j'], 1259)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/marketmodel_smm.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<todaysForwards.size()  ++i
induction variable: ['i']
{
L1260: (todaysForwards[i]=,w) 
L1261: (todaysForwards[i]=,w) 
}
array table
-----------------------------------------------
todaysForwards -> [('[i]', 'w', 'normalized', ['i'], 1260), ('[i]', 'w', 'normalized', ['i'], 1261)]
LDEs formed:3

distinct LDEs:
i1=i2
#########################################################################################
loop info: Size i=0  i<todaysSwaps.size()  i++
induction variable: ['i']
{
L1262: (volatilities[i]=,w) (todaysSwaps[i]*,r) (mktVols[i]/,r) 
L1263: (todaysSwaps[i]+,r) 
L1264: (blackVols[i]=,w) (mktVols[i],r) 
}
array table
-----------------------------------------------
volatilities -> [('[i]', 'w', 'normalized', ['i'], 1262)]
LDEs formed:1

mktVols -> [('[i]', 'r', 'normalized', ['i'], 1262), ('[i]', 'r', 'normalized', ['i'], 1264)]
LDEs formed:0

blackVols -> [('[i]', 'w', 'normalized', ['i'], 1264)]
LDEs formed:1

todaysSwaps -> [('[i]', 'r', 'normalized', ['i'], 1262), ('[i]', 'r', 'normalized', ['i'], 1263)]
LDEs formed:0

distinct LDEs:
i1=i2
#########################################################################################
loop info: Size i=0  i<N  ++i
induction variable: ['i']
{
L1264: (todaysSwaps[i]-,r) (todaysDiscounts[i],r) 
L1265: (expectedNPVs[i]=,w) 
L1266: (discrepancies[i]=,w) (results[i]-,r) (expectedNPVs[i],r) (errors[i],r) 
L1267: (discrepancies[i],r) 
}
array table
-----------------------------------------------
errors -> [('[i]', 'r', 'normalized', ['i'], 1266)]
LDEs formed:0

expectedNPVs -> [('[i]', 'w', 'normalized', ['i'], 1265), ('[i]', 'r', 'normalized', ['i'], 1266)]
LDEs formed:2

todaysSwaps -> [('[i]', 'r', 'normalized', ['i'], 1264)]
LDEs formed:0

results -> [('[i]', 'r', 'normalized', ['i'], 1266)]
LDEs formed:0

todaysDiscounts -> [('[i]', 'r', 'normalized', ['i'], 1264)]
LDEs formed:0

discrepancies -> [('[i]', 'w', 'normalized', ['i'], 1266), ('[i]', 'r', 'normalized', ['i'], 1267)]
LDEs formed:2

distinct LDEs:
i1=i2
#########################################################################################
loop info: Size i=0  i<N  ++i
induction variable: ['i']
{
L1268: (results[i],r) 
L1269: (errors[i],r) 
L1270: (expectedNPVs[i],r) 
L1271: (discrepancies[N-1-i],r) 
}
array table
-----------------------------------------------
discrepancies -> [('[N-1-i]', 'r', 'not normalized', ['i'], 1271)]
LDEs formed:0

errors -> [('[i]', 'r', 'normalized', ['i'], 1269)]
LDEs formed:0

results -> [('[i]', 'r', 'normalized', ['i'], 1268)]
LDEs formed:0

expectedNPVs -> [('[i]', 'r', 'normalized', ['i'], 1270)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<N  ++i
induction variable: ['i']
{
L1271: (displacedPayoff[i],r) 
L1272: (todaysSwaps[i]+,r) 
L1273: (volatilities[i]*,r) (rateTimes[i],r) 
L1274: (todaysDiscounts[i],r) 
L1275: (expectedSwaptions[i]=,w) 
L1276: (discrepancies[i]=,w) (results[N+i]-,r) (expectedSwaptions[i],r) (errors[N+i],r) 
L1277: (discrepancies[i],r) 
}
array table
-----------------------------------------------
volatilities -> [('[i]', 'r', 'normalized', ['i'], 1273)]
LDEs formed:0

errors -> [('[N+i]', 'r', 'not normalized', ['i'], 1276)]
LDEs formed:0

displacedPayoff -> [('[i]', 'r', 'normalized', ['i'], 1271)]
LDEs formed:0

results -> [('[N+i]', 'r', 'not normalized', ['i'], 1276)]
LDEs formed:0

todaysDiscounts -> [('[i]', 'r', 'normalized', ['i'], 1274)]
LDEs formed:0

expectedSwaptions -> [('[i]', 'w', 'normalized', ['i'], 1275), ('[i]', 'r', 'normalized', ['i'], 1276)]
LDEs formed:2

discrepancies -> [('[i]', 'w', 'normalized', ['i'], 1276), ('[i]', 'r', 'normalized', ['i'], 1277)]
LDEs formed:2

todaysSwaps -> [('[i]', 'r', 'normalized', ['i'], 1272)]
LDEs formed:0

rateTimes -> [('[i]', 'r', 'normalized', ['i'], 1273)]
LDEs formed:0

distinct LDEs:
i1=i2
#########################################################################################
loop info: Size i=1  i<=N  ++i
induction variable: ['i']
{
L1274: (results[2*N-i],r) 
L1275: (errors[2*N-i],r) 
L1276: (expectedSwaptions[N-i],r) 
L1277: (discrepancies[N-i],r) 
}
array table
-----------------------------------------------
discrepancies -> [('[N-i]', 'r', 'not normalized', ['i'], 1277)]
LDEs formed:0

errors -> [('[2*N-i]', 'r', 'not normalized', ['i'], 1275)]
LDEs formed:0

results -> [('[2*N-i]', 'r', 'not normalized', ['i'], 1274)]
LDEs formed:0

expectedSwaptions -> [('[N-i]', 'r', 'not normalized', ['i'], 1276)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<undisplacedPayoff.size()  ++i
induction variable: ['i']
{
L1277: (displacedPayoff[i]=,w) 
L1278: (undisplacedPayoff[i]=,w) 
}
array table
-----------------------------------------------
undisplacedPayoff -> [('[i]', 'w', 'normalized', ['i'], 1278)]
LDEs formed:1

displacedPayoff -> [('[i]', 'w', 'normalized', ['i'], 1277)]
LDEs formed:1

distinct LDEs:
i1=i2
#########################################################################################
loop info: Size j=0  j<LENGTH(marketModels)  j++
induction variable: ['j']
{
	loop info: Size m=0  m<LENGTH(testedFactors)  ++m
	induction variable: ['j', 'm']
	{
	L1278: (testedFactors[m],r) 
		loop info: Size k=0  k<LENGTH(measures)  k++
		induction variable: ['j', 'm', 'k']
		{
		L1279: (measures[k],r) 
		L1280: (marketModels[j],r) 
			loop info: Size i=0  i<LENGTH(evolvers)-stop  i++
			induction variable: ['j', 'm', 'k', 'i']
			{
				loop info: Size n=0  n<1  n++
				induction variable: ['j', 'm', 'k', 'i', 'n']
				{
				L1281: (evolvers[i],r) 
				L1282: (marketModels[j],r) 
				L1283: (measures[k],r) 
				L1284: (evolvers[i],r) 
				}
 			}
 		}
 	}
 }
array table
-----------------------------------------------
testedFactors -> [('[m]', 'r', 'normalized', ['j', 'm', 'k', 'i', 'n'], 1278)]
LDEs formed:0

marketModels -> [('[j]', 'r', 'normalized', ['j', 'm', 'k', 'i', 'n'], 1280), ('[j]', 'r', 'normalized', ['j', 'm', 'k', 'i', 'n'], 1282)]
LDEs formed:0

measures -> [('[k]', 'r', 'normalized', ['j', 'm', 'k', 'i', 'n'], 1279), ('[k]', 'r', 'normalized', ['j', 'm', 'k', 'i', 'n'], 1283)]
LDEs formed:0

evolvers -> [('[i]', 'r', 'normalized', ['j', 'm', 'k', 'i', 'n'], 1281), ('[i]', 'r', 'normalized', ['j', 'm', 'k', 'i', 'n'], 1284)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/inflation.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<N  i++
induction variable: ['i']
{
L1285: (iiData[i].date,r) 
L1286: (iiData[i].rate/,r) 
}
array table
-----------------------------------------------
iiData -> [('[i]', 'r', 'normalized', ['i'], 1285), ('[i]', 'r', 'normalized', ['i'], 1286)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<LENGTH(fixData)  i++
induction variable: ['i']
{
L1287: (rpiSchedule[i],r) (fixData[i],r) 
}
array table
-----------------------------------------------
rpiSchedule -> [('[i]', 'r', 'normalized', ['i'], 1287)]
LDEs formed:0

fixData -> [('[i]', 'r', 'normalized', ['i'], 1287)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<rpiSchedule.size()-1 i++
induction variable: ['i']
{
L1288: (rpiSchedule[i],r) 
	loop info: Date d=lim.first  d<=lim.second  d++
	induction variable: ['i', 'd']
	{
	L1289: (fixData[i],r) 
	L1290: (fixData[i],r) 
	}
 }
array table
-----------------------------------------------
rpiSchedule -> [('[i]', 'r', 'normalized', ['i', 'd'], 1288)]
LDEs formed:0

fixData -> [('[i]', 'r', 'normalized', ['i', 'd'], 1289), ('[i]', 'r', 'normalized', ['i', 'd'], 1290)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<LENGTH(fixData)  i++
induction variable: ['i']
{
L1291: (rpiSchedule[i],r) (fixData[i],r) 
}
array table
-----------------------------------------------
rpiSchedule -> [('[i]', 'r', 'normalized', ['i'], 1291)]
LDEs formed:0

fixData -> [('[i]', 'r', 'normalized', ['i'], 1291)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<LENGTH(zcData)  i++
induction variable: ['i']
{
L1292: (zcData[i].rate/,r) 
L1293: (zcData[i].date,r) 
L1294: (zcData[i].date,r) 
L1295: (zcData[i].rate/,r) 
L1296: (helpers[i]-,r) 
L1297: (zcData[i].rate/,r) 
L1298: (helpers[i]-,r) 
L1299: (zcData[i].rate/,r) 
}
array table
-----------------------------------------------
zcData -> [('[i]', 'r', 'normalized', ['i'], 1292), ('[i]', 'r', 'normalized', ['i'], 1293), ('[i]', 'r', 'normalized', ['i'], 1294), ('[i]', 'r', 'normalized', ['i'], 1295), ('[i]', 'r', 'normalized', ['i'], 1297), ('[i]', 'r', 'normalized', ['i'], 1299)]
LDEs formed:0

helpers -> [('[i]', 'r', 'normalized', ['i'], 1296), ('[i]', 'r', 'normalized', ['i'], 1298)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<testIndex.size() i++
induction variable: ['i']
{
L1299: (testIndex[i],r) 
}
array table
-----------------------------------------------
testIndex -> [('[i]', 'r', 'normalized', ['i'], 1299)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: int i=0 i<12 i++
induction variable: ['i']
{
L1300: (fixing[i]-,r) (seasonalityFixing_1[i],r) 
}
array table
-----------------------------------------------
seasonalityFixing_1 -> [('[i]', 'r', 'normalized', ['i'], 1300)]
LDEs formed:0

fixing -> [('[i]', 'r', 'normalized', ['i'], 1300)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: int i=0 i<12 i++
induction variable: ['i']
{
L1301: (expectedFixing[i]-,r) (seasonalityFixing_real[i],r) 
L1302: (expectedFixing[i]<<,r) (seasonalityFixing_real[i],r) 
}
array table
-----------------------------------------------
seasonalityFixing_real -> [('[i]', 'r', 'normalized', ['i'], 1301), ('[i]', 'r', 'normalized', ['i'], 1302)]
LDEs formed:0

expectedFixing -> [('[i]', 'r', 'normalized', ['i'], 1301), ('[i]', 'r', 'normalized', ['i'], 1302)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: int i=0 i<12 i++
induction variable: ['i']
{
L1303: (seasonalityFixing_unset[i]-,r) (seasonalityFixing_1[i],r) 
L1304: (seasonalityFixing_unset[i]<<,r) (seasonalityFixing_1[i],r) 
}
array table
-----------------------------------------------
seasonalityFixing_1 -> [('[i]', 'r', 'normalized', ['i'], 1303), ('[i]', 'r', 'normalized', ['i'], 1304)]
LDEs formed:0

seasonalityFixing_unset -> [('[i]', 'r', 'normalized', ['i'], 1303), ('[i]', 'r', 'normalized', ['i'], 1304)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<LENGTH(fixData) i++
induction variable: ['i']
{
L1305: (rpiSchedule[i],r) (fixData[i],r) 
}
array table
-----------------------------------------------
rpiSchedule -> [('[i]', 'r', 'normalized', ['i'], 1305)]
LDEs formed:0

fixData -> [('[i]', 'r', 'normalized', ['i'], 1305)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<LENGTH(zcData)  i++
induction variable: ['i']
{
L1306: (zcData[i].rate/,r) 
L1307: (zcData[i].date,r) 
L1308: (zcData[i].date,r) 
L1309: (zcData[i].date<<,r) 
L1310: (zcData[i].rate/,r) 
L1311: (helpersyes[i]-,r) 
L1312: (zcData[i].rate/,r) 
L1313: (helpersyes[i]-,r) 
L1314: (zcData[i].rate/,r) 
}
array table
-----------------------------------------------
zcData -> [('[i]', 'r', 'normalized', ['i'], 1306), ('[i]', 'r', 'normalized', ['i'], 1307), ('[i]', 'r', 'normalized', ['i'], 1308), ('[i]', 'r', 'normalized', ['i'], 1309), ('[i]', 'r', 'normalized', ['i'], 1310), ('[i]', 'r', 'normalized', ['i'], 1312), ('[i]', 'r', 'normalized', ['i'], 1314)]
LDEs formed:0

helpersyes -> [('[i]', 'r', 'normalized', ['i'], 1311), ('[i]', 'r', 'normalized', ['i'], 1313)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<testIndex.size() i++
induction variable: ['i']
{
L1314: (testIndex[i],r) 
}
array table
-----------------------------------------------
testIndex -> [('[i]', 'r', 'normalized', ['i'], 1314)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<LENGTH(fixData) i++
induction variable: ['i']
{
L1315: (rpiSchedule[i],r) (fixData[i],r) 
L1316: (rpiSchedule[i],r) (fixData[i],r) 
}
array table
-----------------------------------------------
rpiSchedule -> [('[i]', 'r', 'normalized', ['i'], 1315), ('[i]', 'r', 'normalized', ['i'], 1316)]
LDEs formed:0

fixData -> [('[i]', 'r', 'normalized', ['i'], 1315), ('[i]', 'r', 'normalized', ['i'], 1316)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=13  i<rpiSchedule.size() i++
induction variable: ['i']
{
L1317: (rpiSchedule[i],r) 
L1318: (rpiSchedule[i-12],r) 
	loop info: Date d=lim.first  d<=lim.second  d++
	induction variable: ['i', 'd']
	{
	L1319: (fixData[i]/,r) (fixData[i-12]-,r) 
	L1320: (fixData[i]+,r) (fixData[i+1]-,r) (fixData[i],r) 
	L1321: (fixData[i-12]+,r) (fixData[i+1-12]-,r) (fixData[i-12],r) 
	L1322: (fixData[i-12]<<,r) (fixData[i+1-12],r) 
	L1323: (fixData[i]<<,r) (fixData[i+1],r) 
	}
 }
array table
-----------------------------------------------
rpiSchedule -> [('[i]', 'r', 'normalized', ['i', 'd'], 1317), ('[i-12]', 'r', 'normalized', ['i', 'd'], 1318)]
LDEs formed:0

fixData -> [('[i]', 'r', 'normalized', ['i', 'd'], 1319), ('[i-12]', 'r', 'normalized', ['i', 'd'], 1319), ('[i]', 'r', 'normalized', ['i', 'd'], 1320), ('[i+1]', 'r', 'normalized', ['i', 'd'], 1320), ('[i]', 'r', 'normalized', ['i', 'd'], 1320), ('[i-12]', 'r', 'normalized', ['i', 'd'], 1321), ('[i+1-12]', 'r', 'normalized', ['i', 'd'], 1321), ('[i-12]', 'r', 'normalized', ['i', 'd'], 1321), ('[i-12]', 'r', 'normalized', ['i', 'd'], 1322), ('[i+1-12]', 'r', 'normalized', ['i', 'd'], 1322), ('[i]', 'r', 'normalized', ['i', 'd'], 1323), ('[i+1]', 'r', 'normalized', ['i', 'd'], 1323)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<LENGTH(fixData)  i++
induction variable: ['i']
{
L1324: (rpiSchedule[i],r) (fixData[i],r) 
}
array table
-----------------------------------------------
rpiSchedule -> [('[i]', 'r', 'normalized', ['i'], 1324)]
LDEs formed:0

fixData -> [('[i]', 'r', 'normalized', ['i'], 1324)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size j = 1  j < LENGTH(yyData)  j++
induction variable: ['j']
{
L1325: (yyData[j].date,r) 
L1326: (yyData[j].rate/,r) 
L1327: (yyData[j].rate/,r) 
L1328: (yyData[j].date-,r) 
L1329: (yyData[j].date-,r) 
}
array table
-----------------------------------------------
yyData -> [('[j]', 'r', 'normalized', ['j'], 1325), ('[j]', 'r', 'normalized', ['j'], 1326), ('[j]', 'r', 'normalized', ['j'], 1327), ('[j]', 'r', 'normalized', ['j'], 1328), ('[j]', 'r', 'normalized', ['j'], 1329)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size k = 0  k < 14  k++
induction variable: ['k']
{
L1330: (yyData[jj].date-,r) 
L1331: (yyData[jj].rate/,r) 
}
array table
-----------------------------------------------
yyData -> [('[jj]', 'r', 'not normalized', ['k'], 1330), ('[jj]', 'r', 'not normalized', ['k'], 1331)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/gsr.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/cms.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<nRows  ++i
induction variable: ['i']
{
L1332: (volSpreads[i]=,w) 
	loop info: Size j=0  j<nCols  ++j
	induction variable: ['i', 'j']
	{
	L1333: (volSpreads[i][j]=,w) 
	L1334: (volSpreadsMatrix[i][j],r) 
	}
 }
array table
-----------------------------------------------
volSpreadsMatrix -> [('[i][j]', 'r', 'normalized', ['i', 'j'], 1334)]
LDEs formed:0

volSpreads -> [('[i]', 'w', 'normalized', ['i', 'j'], 1332), ('[i][j]', 'w', 'normalized', ['i', 'j'], 1333)]
LDEs formed:6

distinct LDEs:
i1=i2,j1=j2
i1=i2
#########################################################################################
loop info: Size i=0  i<nRows  ++i
induction variable: ['i']
{
L1334: (guess[i]=,w) 
L1335: (guess[i][0]=,w) 
L1336: (guess[i][1]=,w) 
L1337: (guess[i][2]=,w) 
L1338: (guess[i][3]=,w) 
}
array table
-----------------------------------------------
guess -> [('[i]', 'w', 'normalized', ['i'], 1334), ('[i][0]', 'w', 'normalized', ['i'], 1335), ('[i][1]', 'w', 'normalized', ['i'], 1336), ('[i][2]', 'w', 'normalized', ['i'], 1337), ('[i][3]', 'w', 'normalized', ['i'], 1338)]
LDEs formed:30

distinct LDEs:
i1=i2,2=2
i1=i2,2=3
i1=i2,3=3
i1=i2,0=0
i1=i2,0=1
i1=i2,0=2
i1=i2,0=3
i1=i2
i1=i2,1=1
i1=i2,1=3
i1=i2,1=2
#########################################################################################
loop info: Size j = 0  j < yieldCurveModels.size()  ++j
induction variable: ['j']
{
L1339: (yieldCurveModels[j],r) 
L1340: (yieldCurveModels[j],r) 
}
array table
-----------------------------------------------
yieldCurveModels -> [('[j]', 'r', 'normalized', ['j'], 1339), ('[j]', 'r', 'normalized', ['j'], 1340)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size j=0  j<vars.yieldCurveModels.size()  ++j
induction variable: ['j']
{
L1341: (vars.numericalPricers[j]-,r) 
L1342: (vars.numericalPricers[j],r) 
L1343: (vars.analyticPricers[j]-,r) 
L1344: (vars.analyticPricers[j],r) 
L1345: (vars.yieldCurveModels[j]<<,r) 
}
array table
-----------------------------------------------
vars.numericalPricers -> [('[j]', 'r', 'normalized', ['j'], 1341), ('[j]', 'r', 'normalized', ['j'], 1342)]
LDEs formed:0

vars.yieldCurveModels -> [('[j]', 'r', 'normalized', ['j'], 1345)]
LDEs formed:0

vars.analyticPricers -> [('[j]', 'r', 'normalized', ['j'], 1343), ('[j]', 'r', 'normalized', ['j'], 1344)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size j=0  j<vars.yieldCurveModels.size()  ++j
induction variable: ['j']
{
L1345: (vars.numericalPricers[j]-,r) 
L1346: (vars.analyticPricers[j]-,r) 
	loop info: Size sl=0  sl<n  ++sl
	induction variable: ['j', 'sl']
	{
	L1347: (cms[sl]-,r) (vars.numericalPricers[j],r) 
	L1348: (cms[sl]-,r) 
	L1349: (cms[sl]-,r) (vars.analyticPricers[j],r) 
	L1350: (cms[sl]-,r) 
	L1351: (swapLengths[sl]<<,r) 
	L1352: (vars.yieldCurveModels[j]<<,r) 
	}
 }
array table
-----------------------------------------------
vars.yieldCurveModels -> [('[j]', 'r', 'normalized', ['j', 'sl'], 1352)]
LDEs formed:0

vars.numericalPricers -> [('[j]', 'r', 'normalized', ['j', 'sl'], 1345), ('[j]', 'r', 'normalized', ['j', 'sl'], 1347)]
LDEs formed:0

swapLengths -> [('[sl]', 'r', 'normalized', ['j', 'sl'], 1351)]
LDEs formed:0

cms -> [('[sl]', 'r', 'normalized', ['j', 'sl'], 1347), ('[sl]', 'r', 'normalized', ['j', 'sl'], 1348), ('[sl]', 'r', 'normalized', ['j', 'sl'], 1349), ('[sl]', 'r', 'normalized', ['j', 'sl'], 1350)]
LDEs formed:0

vars.analyticPricers -> [('[j]', 'r', 'normalized', ['j', 'sl'], 1346), ('[j]', 'r', 'normalized', ['j', 'sl'], 1349)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Rate strike = .02  strike<.12  strike+=0.05
induction variable: ['strike']
{
	loop info: Size i=0  i<swaptionVols.size()  ++i
	induction variable: ['strike', 'i']
	{
		loop info: Size j=0  j<vars.yieldCurveModels.size()  ++j
		induction variable: ['strike', 'i', 'j']
		{
		L1350: (vars.numericalPricers[j]-,r) (swaptionVols[i],r) 
		L1351: (vars.analyticPricers[j]-,r) (swaptionVols[i],r) 
		L1352: (pricers[0]=,w) (vars.numericalPricers[j],r) 
		L1353: (pricers[1]=,w) (vars.analyticPricers[j],r) 
			loop info: Size k=0  k<pricers.size()  ++k
			induction variable: ['strike', 'i', 'j', 'k']
			{
			L1354: (pricers[k],r) 
			L1355: (pricers[k],r) 
			L1356: (pricers[k],r) 
			L1357: (vars.yieldCurveModels[j]<<,r) 
			}
 		}
 	}
 }
array table
-----------------------------------------------
vars.yieldCurveModels -> [('[j]', 'r', 'normalized', ['strike', 'i', 'j', 'k'], 1357)]
LDEs formed:0

vars.numericalPricers -> [('[j]', 'r', 'normalized', ['strike', 'i', 'j', 'k'], 1350), ('[j]', 'r', 'normalized', ['strike', 'i', 'j', 'k'], 1352)]
LDEs formed:0

pricers -> [('[0]', 'w', 'normalized', ['strike', 'i', 'j', 'k'], 1352), ('[1]', 'w', 'normalized', ['strike', 'i', 'j', 'k'], 1353), ('[k]', 'r', 'normalized', ['strike', 'i', 'j', 'k'], 1354), ('[k]', 'r', 'normalized', ['strike', 'i', 'j', 'k'], 1355), ('[k]', 'r', 'normalized', ['strike', 'i', 'j', 'k'], 1356)]
LDEs formed:9

swaptionVols -> [('[i]', 'r', 'normalized', ['strike', 'i', 'j', 'k'], 1350), ('[i]', 'r', 'normalized', ['strike', 'i', 'j', 'k'], 1351)]
LDEs formed:0

vars.analyticPricers -> [('[j]', 'r', 'normalized', ['strike', 'i', 'j', 'k'], 1351), ('[j]', 'r', 'normalized', ['strike', 'i', 'j', 'k'], 1353)]
LDEs formed:0

distinct LDEs:
1=1
0=k2
0=0
0=1
1=k2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/piecewisezerospreadedtermstructure.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i = 0  i < 8  ++i
induction variable: ['i']
{
L1354: (ts[i],r) 
L1355: (r[i],r) 
}
array table
-----------------------------------------------
r -> [('[i]', 'r', 'normalized', ['i'], 1355)]
LDEs formed:0

ts -> [('[i]', 'r', 'normalized', ['i'], 1354)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/pagodaoption.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/cliquetoption.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<LENGTH(types)  i++
induction variable: ['i']
{
	loop info: Size j=0  j<LENGTH(moneyness)  j++
	induction variable: ['i', 'j']
	{
		loop info: Size k=0  k<LENGTH(lengths)  k++
		induction variable: ['i', 'j', 'k']
		{
			loop info: Size kk=0  kk<LENGTH(frequencies)  kk++
			induction variable: ['i', 'j', 'k', 'kk']
			{
			L1355: (lengths[k]*,r) 
			L1356: (types[i],r) (moneyness[j],r) 
			L1357: (frequencies[kk],r) 
			L1358: (frequencies[kk],r) 
				loop info: Size l=0  l<LENGTH(underlyings)  l++
				induction variable: ['i', 'j', 'k', 'kk', 'l']
				{
					loop info: Size m=0  m<LENGTH(qRates)  m++
					induction variable: ['i', 'j', 'k', 'kk', 'l', 'm']
					{
						loop info: Size n=0  n<LENGTH(rRates)  n++
						induction variable: ['i', 'j', 'k', 'kk', 'l', 'm', 'n']
						{
							loop info: Size p=0  p<LENGTH(vols)  p++
							induction variable: ['i', 'j', 'k', 'kk', 'l', 'm', 'n', 'p']
							{
							L1359: (underlyings[l],r) 
							L1360: (qRates[m],r) 
							L1361: (rRates[n],r) 
							L1362: (vols[p],r) 
							L1363: (calculated["delta"]=,w) 
							L1364: (calculated["gamma"]=,w) 
							L1365: (calculated["theta"]=,w) 
							L1366: (calculated["rho"]=,w) 
							L1367: (calculated["divRho"]=,w) 
							L1368: (calculated["vega"]=,w) 
							L1369: (expected["delta"]=,w) 
							L1370: (expected["gamma"]=,w) 
							L1371: (expected["rho"]=,w) 
							L1372: (expected["divRho"]=,w) 
							L1373: (expected["vega"]=,w) 
							L1374: (expected["theta"]=,w) 
							L1375: (calculated[greek],r) 
							}
 						}
 					}
 				}
 			}
 		}
 	}
 }
array table
-----------------------------------------------
rRates -> [('[n]', 'r', 'normalized', ['i', 'j', 'k', 'kk', 'l', 'm', 'n', 'p'], 1361)]
LDEs formed:0

lengths -> [('[k]', 'r', 'normalized', ['i', 'j', 'k', 'kk', 'l', 'm', 'n', 'p'], 1355)]
LDEs formed:0

frequencies -> [('[kk]', 'r', 'normalized', ['i', 'j', 'k', 'kk', 'l', 'm', 'n', 'p'], 1357), ('[kk]', 'r', 'normalized', ['i', 'j', 'k', 'kk', 'l', 'm', 'n', 'p'], 1358)]
LDEs formed:0

calculated -> [('["delta"]', 'w', 'not normalized', ['i', 'j', 'k', 'kk', 'l', 'm', 'n', 'p'], 1363), ('["gamma"]', 'w', 'not normalized', ['i', 'j', 'k', 'kk', 'l', 'm', 'n', 'p'], 1364), ('["theta"]', 'w', 'not normalized', ['i', 'j', 'k', 'kk', 'l', 'm', 'n', 'p'], 1365), ('["rho"]', 'w', 'not normalized', ['i', 'j', 'k', 'kk', 'l', 'm', 'n', 'p'], 1366), ('["divRho"]', 'w', 'not normalized', ['i', 'j', 'k', 'kk', 'l', 'm', 'n', 'p'], 1367), ('["vega"]', 'w', 'not normalized', ['i', 'j', 'k', 'kk', 'l', 'm', 'n', 'p'], 1368), ('[greek]', 'r', 'not normalized', ['i', 'j', 'k', 'kk', 'l', 'm', 'n', 'p'], 1375)]
LDEs formed:27

qRates -> [('[m]', 'r', 'normalized', ['i', 'j', 'k', 'kk', 'l', 'm', 'n', 'p'], 1360)]
LDEs formed:0

underlyings -> [('[l]', 'r', 'normalized', ['i', 'j', 'k', 'kk', 'l', 'm', 'n', 'p'], 1359)]
LDEs formed:0

vols -> [('[p]', 'r', 'normalized', ['i', 'j', 'k', 'kk', 'l', 'm', 'n', 'p'], 1362)]
LDEs formed:0

expected -> [('["delta"]', 'w', 'not normalized', ['i', 'j', 'k', 'kk', 'l', 'm', 'n', 'p'], 1369), ('["gamma"]', 'w', 'not normalized', ['i', 'j', 'k', 'kk', 'l', 'm', 'n', 'p'], 1370), ('["rho"]', 'w', 'not normalized', ['i', 'j', 'k', 'kk', 'l', 'm', 'n', 'p'], 1371), ('["divRho"]', 'w', 'not normalized', ['i', 'j', 'k', 'kk', 'l', 'm', 'n', 'p'], 1372), ('["vega"]', 'w', 'not normalized', ['i', 'j', 'k', 'kk', 'l', 'm', 'n', 'p'], 1373), ('["theta"]', 'w', 'not normalized', ['i', 'j', 'k', 'kk', 'l', 'm', 'n', 'p'], 1374)]
LDEs formed:21

moneyness -> [('[j]', 'r', 'normalized', ['i', 'j', 'k', 'kk', 'l', 'm', 'n', 'p'], 1356)]
LDEs formed:0

types -> [('[i]', 'r', 'normalized', ['i', 'j', 'k', 'kk', 'l', 'm', 'n', 'p'], 1356)]
LDEs formed:0

distinct LDEs:
"gamma"="divRho"
"divRho"="divRho"
"theta"="rho"
"theta"="theta"
"gamma"="vega"
"theta"="vega"
"rho"="rho"
"divRho"="vega"
"delta"="delta"
"rho"="vega"
"delta"="theta"
"delta"="rho"
"gamma"="theta"
"vega"="vega"
"rho"=greek
"delta"="divRho"
"delta"=greek
"gamma"=greek
"gamma"="rho"
"vega"=greek
"delta"="gamma"
"gamma"="gamma"
"delta"="vega"
"theta"="divRho"
"rho"="divRho"
"theta"=greek
"divRho"=greek
#########################################################################################
loop info: Size i=0  i<LENGTH(types)  i++
induction variable: ['i']
{
	loop info: Size j=0  j<LENGTH(moneyness)  j++
	induction variable: ['i', 'j']
	{
		loop info: Size k=0  k<LENGTH(lengths)  k++
		induction variable: ['i', 'j', 'k']
		{
			loop info: Size kk=0  kk<LENGTH(frequencies)  kk++
			induction variable: ['i', 'j', 'k', 'kk']
			{
			L1357: (frequencies[kk],r) 
			L1358: (lengths[k]*,r) 
			L1359: (types[i],r) (moneyness[j],r) 
				loop info: Date d = today + tenor  d < maturity->lastDate()  d += tenor
				induction variable: ['i', 'j', 'k', 'kk', 'd']
				{
				}
				loop info: Size l=0  l<LENGTH(underlyings)  l++
				induction variable: ['i', 'j', 'k', 'kk', 'd', 'l']
				{
					loop info: Size m=0  m<LENGTH(qRates)  m++
					induction variable: ['i', 'j', 'k', 'kk', 'd', 'l', 'm']
					{
						loop info: Size n=0  n<LENGTH(rRates)  n++
						induction variable: ['i', 'j', 'k', 'kk', 'd', 'l', 'm', 'n']
						{
							loop info: Size p=0  p<LENGTH(vols)  p++
							induction variable: ['i', 'j', 'k', 'kk', 'd', 'l', 'm', 'n', 'p']
							{
							L1360: (underlyings[l],r) 
							L1361: (qRates[m],r) 
							L1362: (rRates[n],r) 
							L1363: (vols[p],r) 
							}
 						}
 					}
 				}
 			}
 		}
 	}
 }
array table
-----------------------------------------------
rRates -> [('[n]', 'r', 'normalized', ['i', 'j', 'k', 'kk', 'd', 'l', 'm', 'n', 'p'], 1362)]
LDEs formed:0

lengths -> [('[k]', 'r', 'normalized', ['i', 'j', 'k', 'kk', 'd', 'l', 'm', 'n', 'p'], 1358)]
LDEs formed:0

frequencies -> [('[kk]', 'r', 'normalized', ['i', 'j', 'k', 'kk', 'd', 'l', 'm', 'n', 'p'], 1357)]
LDEs formed:0

qRates -> [('[m]', 'r', 'normalized', ['i', 'j', 'k', 'kk', 'd', 'l', 'm', 'n', 'p'], 1361)]
LDEs formed:0

underlyings -> [('[l]', 'r', 'normalized', ['i', 'j', 'k', 'kk', 'd', 'l', 'm', 'n', 'p'], 1360)]
LDEs formed:0

vols -> [('[p]', 'r', 'normalized', ['i', 'j', 'k', 'kk', 'd', 'l', 'm', 'n', 'p'], 1363)]
LDEs formed:0

moneyness -> [('[j]', 'r', 'normalized', ['i', 'j', 'k', 'kk', 'd', 'l', 'm', 'n', 'p'], 1359)]
LDEs formed:0

types -> [('[i]', 'r', 'normalized', ['i', 'j', 'k', 'kk', 'd', 'l', 'm', 'n', 'p'], 1359)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/partialtimebarrieroption.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<LENGTH(cases)  ++i
induction variable: ['i']
{
L1360: (cases[i].days,r) 
L1361: (cases[i].strike,r) 
L1362: (cases[i].underlying,r) 
L1363: (cases[i].result,r) 
}
array table
-----------------------------------------------
cases -> [('[i]', 'r', 'normalized', ['i'], 1360), ('[i]', 'r', 'normalized', ['i'], 1361), ('[i]', 'r', 'normalized', ['i'], 1362), ('[i]', 'r', 'normalized', ['i'], 1363)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/doublebinaryoption.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<LENGTH(values)  i++
induction variable: ['i']
{
L1364: (values[i].cash,r) 
L1365: (values[i].t*,r) 
L1366: (values[i].barrierType==,r) 
L1367: (values[i].barrierType==,r) 
L1368: (values[i].s,r) 
L1369: (values[i].q,r) 
L1370: (values[i].r,r) 
L1371: (values[i].v,r) 
L1372: (values[i].barrierType,r) 
L1373: (values[i].barrier_lo,r) 
L1374: (values[i].barrier_hi,r) 
L1375: (values[i].result,r) 
L1376: (values[i].tol,r) 
L1377: (values[i].barrierType,r) 
L1378: (values[i].barrier_lo,r) (values[i].barrier_hi,r) (values[i].s,r) 
L1379: (values[i].q,r) (values[i].r,r) (values[i].v,r) 
L1380: (values[i].result,r) (values[i].tol,r) 
L1381: (values[i].result,r) 
L1382: (values[i].barrierType,r) 
L1383: (values[i].barrier_lo,r) (values[i].barrier_hi,r) (values[i].s,r) 
L1384: (values[i].q,r) (values[i].r,r) (values[i].v,r) 
L1385: (values[i].result,r) 
}
array table
-----------------------------------------------
values -> [('[i]', 'r', 'normalized', ['i'], 1364), ('[i]', 'r', 'normalized', ['i'], 1365), ('[i]', 'r', 'normalized', ['i'], 1366), ('[i]', 'r', 'normalized', ['i'], 1367), ('[i]', 'r', 'normalized', ['i'], 1368), ('[i]', 'r', 'normalized', ['i'], 1369), ('[i]', 'r', 'normalized', ['i'], 1370), ('[i]', 'r', 'normalized', ['i'], 1371), ('[i]', 'r', 'normalized', ['i'], 1372), ('[i]', 'r', 'normalized', ['i'], 1373), ('[i]', 'r', 'normalized', ['i'], 1374), ('[i]', 'r', 'normalized', ['i'], 1375), ('[i]', 'r', 'normalized', ['i'], 1376), ('[i]', 'r', 'normalized', ['i'], 1377), ('[i]', 'r', 'normalized', ['i'], 1378), ('[i]', 'r', 'normalized', ['i'], 1378), ('[i]', 'r', 'normalized', ['i'], 1378), ('[i]', 'r', 'normalized', ['i'], 1379), ('[i]', 'r', 'normalized', ['i'], 1379), ('[i]', 'r', 'normalized', ['i'], 1379), ('[i]', 'r', 'normalized', ['i'], 1380), ('[i]', 'r', 'normalized', ['i'], 1380), ('[i]', 'r', 'normalized', ['i'], 1381), ('[i]', 'r', 'normalized', ['i'], 1382), ('[i]', 'r', 'normalized', ['i'], 1383), ('[i]', 'r', 'normalized', ['i'], 1383), ('[i]', 'r', 'normalized', ['i'], 1383), ('[i]', 'r', 'normalized', ['i'], 1384), ('[i]', 'r', 'normalized', ['i'], 1384), ('[i]', 'r', 'normalized', ['i'], 1384), ('[i]', 'r', 'normalized', ['i'], 1385)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/swaptionvolatilitycube.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<atm.tenors.options.size()  i++
induction variable: ['i']
{
	loop info: Size j=0  j<atm.tenors.swaps.size()  j++
	induction variable: ['i', 'j']
	{
	L1386: (atm.tenors.options[i],r) 
	L1387: (atm.tenors.swaps[j],r) 
	L1388: (atm.tenors.options[i],r) 
	L1389: (atm.tenors.swaps[j],r) 
	L1390: (atm.tenors.options[i],r) 
	L1391: (atm.tenors.swaps[j],r) 
	L1392: (atm.tenors.options[i]<<,r) 
	L1393: (atm.tenors.swaps[j]<<,r) 
	}
 }
array table
-----------------------------------------------
atm.tenors.options -> [('[i]', 'r', 'normalized', ['i', 'j'], 1386), ('[i]', 'r', 'normalized', ['i', 'j'], 1388), ('[i]', 'r', 'normalized', ['i', 'j'], 1390), ('[i]', 'r', 'normalized', ['i', 'j'], 1392)]
LDEs formed:0

atm.tenors.swaps -> [('[j]', 'r', 'normalized', ['i', 'j'], 1387), ('[j]', 'r', 'normalized', ['i', 'j'], 1389), ('[j]', 'r', 'normalized', ['i', 'j'], 1391), ('[j]', 'r', 'normalized', ['i', 'j'], 1393)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<cube.tenors.options.size()  i++
induction variable: ['i']
{
	loop info: Size j=0  j<cube.tenors.swaps.size()  j++
	induction variable: ['i', 'j']
	{
		loop info: Size k=0  k<cube.strikeSpreads.size()  k++
		induction variable: ['i', 'j', 'k']
		{
		L1394: (cube.tenors.options[i],r) 
		L1395: (cube.tenors.swaps[j],r) 
		L1396: (cube.tenors.options[i],r) 
		L1397: (cube.tenors.swaps[j],r) 
		L1398: (cube.tenors.options[i],r) 
		L1399: (cube.tenors.swaps[j],r) 
		L1400: (cube.strikeSpreads[k],r) 
		L1401: (cube.volSpreads[i*cube.tenors.swaps.size()+j][k],r) 
		L1402: (cube.tenors.options[i]<<,r) 
		L1403: (cube.tenors.swaps[j]<<,r) 
		L1404: (cube.strikeSpreads[k],r) 
		}
 	}
 }
array table
-----------------------------------------------
cube.volSpreads -> [('[i*cube.tenors.swaps.size()+j][k]', 'r', 'not normalized', ['i', 'j', 'k'], 1401)]
LDEs formed:0

cube.strikeSpreads -> [('[k]', 'r', 'normalized', ['i', 'j', 'k'], 1400), ('[k]', 'r', 'normalized', ['i', 'j', 'k'], 1404)]
LDEs formed:0

cube.tenors.options -> [('[i]', 'r', 'normalized', ['i', 'j', 'k'], 1394), ('[i]', 'r', 'normalized', ['i', 'j', 'k'], 1396), ('[i]', 'r', 'normalized', ['i', 'j', 'k'], 1398), ('[i]', 'r', 'normalized', ['i', 'j', 'k'], 1402)]
LDEs formed:0

cube.tenors.swaps -> [('[j]', 'r', 'normalized', ['i', 'j', 'k'], 1395), ('[j]', 'r', 'normalized', ['i', 'j', 'k'], 1397), ('[j]', 'r', 'normalized', ['i', 'j', 'k'], 1399), ('[j]', 'r', 'normalized', ['i', 'j', 'k'], 1403)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<vars.cube.tenors.options.size()*vars.cube.tenors.swaps.size()  i++
induction variable: ['i']
{
L1404: (parametersGuess[i]=,w) 
L1405: (parametersGuess[i][0]=,w) 
L1406: (parametersGuess[i][1]=,w) 
L1407: (parametersGuess[i][2]=,w) 
L1408: (parametersGuess[i][3]=,w) 
}
array table
-----------------------------------------------
parametersGuess -> [('[i]', 'w', 'normalized', ['i'], 1404), ('[i][0]', 'w', 'normalized', ['i'], 1405), ('[i][1]', 'w', 'normalized', ['i'], 1406), ('[i][2]', 'w', 'normalized', ['i'], 1407), ('[i][3]', 'w', 'normalized', ['i'], 1408)]
LDEs formed:30

distinct LDEs:
i1=i2,2=2
i1=i2,2=3
i1=i2,3=3
i1=i2,0=0
i1=i2,0=1
i1=i2,0=2
i1=i2,0=3
i1=i2
i1=i2,1=1
i1=i2,1=3
i1=i2,1=2
#########################################################################################
loop info: Size i=0  i<vars.cube.tenors.options.size()*vars.cube.tenors.swaps.size()  i++
induction variable: ['i']
{
L1409: (parametersGuess[i]=,w) 
L1410: (parametersGuess[i][0]=,w) 
L1411: (parametersGuess[i][1]=,w) 
L1412: (parametersGuess[i][2]=,w) 
L1413: (parametersGuess[i][3]=,w) 
}
array table
-----------------------------------------------
parametersGuess -> [('[i]', 'w', 'normalized', ['i'], 1409), ('[i][0]', 'w', 'normalized', ['i'], 1410), ('[i][1]', 'w', 'normalized', ['i'], 1411), ('[i][2]', 'w', 'normalized', ['i'], 1412), ('[i][3]', 'w', 'normalized', ['i'], 1413)]
LDEs formed:30

distinct LDEs:
i1=i2,2=2
i1=i2,2=3
i1=i2,3=3
i1=i2,0=0
i1=i2,0=1
i1=i2,0=2
i1=i2,0=3
i1=i2
i1=i2,1=1
i1=i2,1=3
i1=i2,1=2
#########################################################################################
loop info: Size i=0  i<vars.cube.tenors.options.size()  i++
induction variable: ['i']
{
	loop info: Size j=0  j<vars.cube.tenors.swaps.size()  j++
	induction variable: ['i', 'j']
	{
	L1414: (vars.cube.tenors.options[i],r) (vars.cube.tenors.swaps[j],r) 
	L1415: (vars.cube.tenors.options[i],r) (vars.cube.tenors.swaps[j],r) 
		loop info: Size k=0  k<strikes.size()  k++
		induction variable: ['i', 'j', 'k']
		{
		L1416: (strikes[k],r) 
		L1417: (vars.cube.tenors.options[i],r) (vars.cube.tenors.swaps[j],r) 
		L1418: (vars.cube.tenors.options[i],r) (vars.cube.tenors.swaps[j],r) 
		L1419: (vars.cube.tenors.options[i]<<,r) 
		L1420: (vars.cube.tenors.swaps[j]<<,r) 
		L1421: (vars.cube.tenors.options[i]<<,r) 
		L1422: (vars.cube.tenors.swaps[j]<<,r) 
		}
 	}
 }
array table
-----------------------------------------------
vars.cube.tenors.swaps -> [('[j]', 'r', 'normalized', ['i', 'j', 'k'], 1414), ('[j]', 'r', 'normalized', ['i', 'j', 'k'], 1415), ('[j]', 'r', 'normalized', ['i', 'j', 'k'], 1417), ('[j]', 'r', 'normalized', ['i', 'j', 'k'], 1418), ('[j]', 'r', 'normalized', ['i', 'j', 'k'], 1420), ('[j]', 'r', 'normalized', ['i', 'j', 'k'], 1422)]
LDEs formed:0

strikes -> [('[k]', 'r', 'normalized', ['i', 'j', 'k'], 1416)]
LDEs formed:0

vars.cube.tenors.options -> [('[i]', 'r', 'normalized', ['i', 'j', 'k'], 1414), ('[i]', 'r', 'normalized', ['i', 'j', 'k'], 1415), ('[i]', 'r', 'normalized', ['i', 'j', 'k'], 1417), ('[i]', 'r', 'normalized', ['i', 'j', 'k'], 1418), ('[i]', 'r', 'normalized', ['i', 'j', 'k'], 1419), ('[i]', 'r', 'normalized', ['i', 'j', 'k'], 1421)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<vars.cube.tenors.options.size()*vars.cube.tenors.swaps.size()  i++
induction variable: ['i']
{
L1422: (parametersGuess[i]=,w) 
L1423: (parametersGuess[i][0]=,w) 
L1424: (parametersGuess[i][1]=,w) 
L1425: (parametersGuess[i][2]=,w) 
L1426: (parametersGuess[i][3]=,w) 
}
array table
-----------------------------------------------
parametersGuess -> [('[i]', 'w', 'normalized', ['i'], 1422), ('[i][0]', 'w', 'normalized', ['i'], 1423), ('[i][1]', 'w', 'normalized', ['i'], 1424), ('[i][2]', 'w', 'normalized', ['i'], 1425), ('[i][3]', 'w', 'normalized', ['i'], 1426)]
LDEs formed:30

distinct LDEs:
i1=i2,2=2
i1=i2,2=3
i1=i2,3=3
i1=i2,0=0
i1=i2,0=1
i1=i2,0=2
i1=i2,0=3
i1=i2
i1=i2,1=1
i1=i2,1=3
i1=i2,1=2
#########################################################################################
loop info: Size i=0 i<vars.cube.tenors.options.size()  i++ 
induction variable: ['i']
{
	loop info: Size j=0  j<vars.cube.tenors.swaps.size()  j++
	induction variable: ['i', 'j']
	{
		loop info: Size k=0  k<vars.cube.strikeSpreads.size()  k++
		induction variable: ['i', 'j', 'k']
		{
		L1427: (vars.cube.tenors.options[i],r) 
		L1428: (vars.cube.tenors.swaps[j],r) 
		L1429: (vars.cube.strikeSpreads[k],r) 
		L1430: (vars.cube.tenors.options[i],r) 
		L1431: (vars.cube.tenors.swaps[j],r) 
		L1432: (vars.cube.strikeSpreads[k],r) 
		L1433: (vars.cube.tenors.options[i]<<,r) 
		L1434: (vars.cube.tenors.swaps[j]<<,r) 
		L1435: (vars.cube.strikeSpreads[k],r) 
		}
 	}
 }
array table
-----------------------------------------------
vars.cube.strikeSpreads -> [('[k]', 'r', 'normalized', ['i', 'j', 'k'], 1429), ('[k]', 'r', 'normalized', ['i', 'j', 'k'], 1432), ('[k]', 'r', 'normalized', ['i', 'j', 'k'], 1435)]
LDEs formed:0

vars.cube.tenors.swaps -> [('[j]', 'r', 'normalized', ['i', 'j', 'k'], 1428), ('[j]', 'r', 'normalized', ['i', 'j', 'k'], 1431), ('[j]', 'r', 'normalized', ['i', 'j', 'k'], 1434)]
LDEs formed:0

vars.cube.tenors.options -> [('[i]', 'r', 'normalized', ['i', 'j', 'k'], 1427), ('[i]', 'r', 'normalized', ['i', 'j', 'k'], 1430), ('[i]', 'r', 'normalized', ['i', 'j', 'k'], 1433)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0 i<vars.cube.tenors.options.size()  i++ 
induction variable: ['i']
{
	loop info: Size j=0  j<vars.cube.tenors.swaps.size()  j++
	induction variable: ['i', 'j']
	{
		loop info: Size k=0  k<vars.cube.strikeSpreads.size()  k++
		induction variable: ['i', 'j', 'k']
		{
		L1434: (vars.cube.tenors.options[i],r) 
		L1435: (vars.cube.tenors.swaps[j],r) 
		L1436: (vars.cube.strikeSpreads[k],r) 
		L1437: (vars.cube.tenors.options[i],r) 
		L1438: (vars.cube.tenors.swaps[j],r) 
		L1439: (vars.cube.strikeSpreads[k],r) 
		L1440: (vars.cube.tenors.options[i]<<,r) 
		L1441: (vars.cube.tenors.swaps[j]<<,r) 
		L1442: (vars.cube.strikeSpreads[k],r) 
		}
 	}
 }
array table
-----------------------------------------------
vars.cube.strikeSpreads -> [('[k]', 'r', 'normalized', ['i', 'j', 'k'], 1436), ('[k]', 'r', 'normalized', ['i', 'j', 'k'], 1439), ('[k]', 'r', 'normalized', ['i', 'j', 'k'], 1442)]
LDEs formed:0

vars.cube.tenors.swaps -> [('[j]', 'r', 'normalized', ['i', 'j', 'k'], 1435), ('[j]', 'r', 'normalized', ['i', 'j', 'k'], 1438), ('[j]', 'r', 'normalized', ['i', 'j', 'k'], 1441)]
LDEs formed:0

vars.cube.tenors.options -> [('[i]', 'r', 'normalized', ['i', 'j', 'k'], 1434), ('[i]', 'r', 'normalized', ['i', 'j', 'k'], 1437), ('[i]', 'r', 'normalized', ['i', 'j', 'k'], 1440)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/swaption.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<LENGTH(exercises)  i++
induction variable: ['i']
{
	loop info: Size j=0  j<LENGTH(lengths)  j++
	induction variable: ['i', 'j']
	{
		loop info: Size k=0  k<LENGTH(type)  k++
		induction variable: ['i', 'j', 'k']
		{
		L1441: (exercises[i],r) 
			loop info: Size l=0  l<LENGTH(strikes)  l++
			induction variable: ['i', 'j', 'k', 'l']
			{
			L1442: (lengths[j],r) (strikes[l],r) 
			L1443: (type[k],r) 
			}
		L1444: (type[k]==,r) 
		L1445: (exercises[i]<<,r) 
		L1446: (lengths[j]<<,r) 
		L1447: (values[n  ]<<,r) (strikes[n  ],r) 
		L1448: (values[n+1]<<,r) (strikes[n+1],r) 
		L1449: (exercises[i]<<,r) 
		L1450: (lengths[j]<<,r) 
		L1451: (values_cash[n  ]<<,r) (strikes[n  ],r) 
		L1452: (values_cash[n+1]<<,r) (strikes[n+1],r) 
		L1453: (exercises[i]<<,r) 
		L1454: (lengths[j]<<,r) 
		L1455: (values[n  ]<<,r) (strikes[n  ],r) 
		L1456: (values[n+1]<<,r) (strikes[n+1],r) 
		L1457: (exercises[i]<<,r) 
		L1458: (lengths[j]<<,r) 
		L1459: (values_cash[n  ]<<,r) (strikes[n  ],r) 
		L1460: (values_cash[n+1]<<,r) (strikes[n+1],r) 
		}
 	}
 }
array table
-----------------------------------------------
lengths -> [('[j]', 'r', 'normalized', ['i', 'j', 'k', 'l'], 1442), ('[j]', 'r', 'normalized', ['i', 'j', 'k', 'l'], 1446), ('[j]', 'r', 'normalized', ['i', 'j', 'k', 'l'], 1450), ('[j]', 'r', 'normalized', ['i', 'j', 'k', 'l'], 1454), ('[j]', 'r', 'normalized', ['i', 'j', 'k', 'l'], 1458)]
LDEs formed:0

strikes -> [('[l]', 'r', 'normalized', ['i', 'j', 'k', 'l'], 1442), ('[n  ]', 'r', 'not normalized', ['i', 'j', 'k', 'l'], 1447), ('[n+1]', 'r', 'not normalized', ['i', 'j', 'k', 'l'], 1448), ('[n  ]', 'r', 'not normalized', ['i', 'j', 'k', 'l'], 1451), ('[n+1]', 'r', 'not normalized', ['i', 'j', 'k', 'l'], 1452), ('[n  ]', 'r', 'not normalized', ['i', 'j', 'k', 'l'], 1455), ('[n+1]', 'r', 'not normalized', ['i', 'j', 'k', 'l'], 1456), ('[n  ]', 'r', 'not normalized', ['i', 'j', 'k', 'l'], 1459), ('[n+1]', 'r', 'not normalized', ['i', 'j', 'k', 'l'], 1460)]
LDEs formed:0

values -> [('[n  ]', 'r', 'not normalized', ['i', 'j', 'k', 'l'], 1447), ('[n+1]', 'r', 'not normalized', ['i', 'j', 'k', 'l'], 1448), ('[n  ]', 'r', 'not normalized', ['i', 'j', 'k', 'l'], 1455), ('[n+1]', 'r', 'not normalized', ['i', 'j', 'k', 'l'], 1456)]
LDEs formed:0

exercises -> [('[i]', 'r', 'normalized', ['i', 'j', 'k', 'l'], 1441), ('[i]', 'r', 'normalized', ['i', 'j', 'k', 'l'], 1445), ('[i]', 'r', 'normalized', ['i', 'j', 'k', 'l'], 1449), ('[i]', 'r', 'normalized', ['i', 'j', 'k', 'l'], 1453), ('[i]', 'r', 'normalized', ['i', 'j', 'k', 'l'], 1457)]
LDEs formed:0

values_cash -> [('[n  ]', 'r', 'not normalized', ['i', 'j', 'k', 'l'], 1451), ('[n+1]', 'r', 'not normalized', ['i', 'j', 'k', 'l'], 1452), ('[n  ]', 'r', 'not normalized', ['i', 'j', 'k', 'l'], 1459), ('[n+1]', 'r', 'not normalized', ['i', 'j', 'k', 'l'], 1460)]
LDEs formed:0

type -> [('[k]', 'r', 'normalized', ['i', 'j', 'k', 'l'], 1443), ('[k]', 'r', 'normalized', ['i', 'j', 'k', 'l'], 1444)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<LENGTH(exercises)  i++
induction variable: ['i']
{
	loop info: Size j=0  j<LENGTH(lengths)  j++
	induction variable: ['i', 'j']
	{
		loop info: Size k=0  k<LENGTH(type)  k++
		induction variable: ['i', 'j', 'k']
		{
		L1445: (exercises[i],r) 
			loop info: Size l=0  l<LENGTH(spreads)  l++
			induction variable: ['i', 'j', 'k', 'l']
			{
			L1446: (lengths[j],r) 
			L1447: (spreads[l],r) 
			L1448: (type[k],r) 
			}
		L1449: (type[k]==,r) 
		L1450: (lengths[j]<<,r) 
		L1451: (values[n  ]<<,r) (spreads[n],r) 
		L1452: (values[n+1]<<,r) (spreads[n+1],r) 
		L1453: (lengths[j]<<,r) 
		L1454: (values_cash[n  ]<<,r) (spreads[n],r) 
		L1455: (values_cash[n+1]<<,r) (spreads[n+1],r) 
		L1456: (lengths[j]<<,r) 
		L1457: (values[n  ]<<,r) (spreads[n],r) 
		L1458: (values[n+1]<<,r) (spreads[n+1],r) 
		L1459: (lengths[j]<<,r) 
		L1460: (values_cash[n  ]<<,r) (spreads[n],r) 
		L1461: (values_cash[n+1]<<,r) (spreads[n+1],r) 
		}
 	}
 }
array table
-----------------------------------------------
lengths -> [('[j]', 'r', 'normalized', ['i', 'j', 'k', 'l'], 1446), ('[j]', 'r', 'normalized', ['i', 'j', 'k', 'l'], 1450), ('[j]', 'r', 'normalized', ['i', 'j', 'k', 'l'], 1453), ('[j]', 'r', 'normalized', ['i', 'j', 'k', 'l'], 1456), ('[j]', 'r', 'normalized', ['i', 'j', 'k', 'l'], 1459)]
LDEs formed:0

spreads -> [('[l]', 'r', 'normalized', ['i', 'j', 'k', 'l'], 1447), ('[n]', 'r', 'not normalized', ['i', 'j', 'k', 'l'], 1451), ('[n+1]', 'r', 'not normalized', ['i', 'j', 'k', 'l'], 1452), ('[n]', 'r', 'not normalized', ['i', 'j', 'k', 'l'], 1454), ('[n+1]', 'r', 'not normalized', ['i', 'j', 'k', 'l'], 1455), ('[n]', 'r', 'not normalized', ['i', 'j', 'k', 'l'], 1457), ('[n+1]', 'r', 'not normalized', ['i', 'j', 'k', 'l'], 1458), ('[n]', 'r', 'not normalized', ['i', 'j', 'k', 'l'], 1460), ('[n+1]', 'r', 'not normalized', ['i', 'j', 'k', 'l'], 1461)]
LDEs formed:0

values -> [('[n  ]', 'r', 'not normalized', ['i', 'j', 'k', 'l'], 1451), ('[n+1]', 'r', 'not normalized', ['i', 'j', 'k', 'l'], 1452), ('[n  ]', 'r', 'not normalized', ['i', 'j', 'k', 'l'], 1457), ('[n+1]', 'r', 'not normalized', ['i', 'j', 'k', 'l'], 1458)]
LDEs formed:0

exercises -> [('[i]', 'r', 'normalized', ['i', 'j', 'k', 'l'], 1445)]
LDEs formed:0

values_cash -> [('[n  ]', 'r', 'not normalized', ['i', 'j', 'k', 'l'], 1454), ('[n+1]', 'r', 'not normalized', ['i', 'j', 'k', 'l'], 1455), ('[n  ]', 'r', 'not normalized', ['i', 'j', 'k', 'l'], 1460), ('[n+1]', 'r', 'not normalized', ['i', 'j', 'k', 'l'], 1461)]
LDEs formed:0

type -> [('[k]', 'r', 'normalized', ['i', 'j', 'k', 'l'], 1448), ('[k]', 'r', 'normalized', ['i', 'j', 'k', 'l'], 1449)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<LENGTH(exercises)  i++
induction variable: ['i']
{
	loop info: Size j=0  j<LENGTH(lengths)  j++
	induction variable: ['i', 'j']
	{
		loop info: Size k=0  k<LENGTH(type)  k++
		induction variable: ['i', 'j', 'k']
		{
		L1450: (exercises[i],r) 
			loop info: Size l=0  l<LENGTH(spreads)  l++
			induction variable: ['i', 'j', 'k', 'l']
			{
			L1451: (lengths[j],r) 
			L1452: (spreads[l],r) 
			L1453: (type[k],r) 
			L1454: (spreads[l]*,r) 
			L1455: (lengths[j],r) 
			L1456: (type[k],r) 
			L1457: (lengths[j]<<,r) 
			L1458: (type[k]<<,r) 
			L1459: (spreads[l],r) 
			L1460: (lengths[j]<<,r) 
			L1461: (type[k],r) 
			L1462: (spreads[l],r) 
			}
 		}
 	}
 }
array table
-----------------------------------------------
exercises -> [('[i]', 'r', 'normalized', ['i', 'j', 'k', 'l'], 1450)]
LDEs formed:0

lengths -> [('[j]', 'r', 'normalized', ['i', 'j', 'k', 'l'], 1451), ('[j]', 'r', 'normalized', ['i', 'j', 'k', 'l'], 1455), ('[j]', 'r', 'normalized', ['i', 'j', 'k', 'l'], 1457), ('[j]', 'r', 'normalized', ['i', 'j', 'k', 'l'], 1460)]
LDEs formed:0

spreads -> [('[l]', 'r', 'normalized', ['i', 'j', 'k', 'l'], 1452), ('[l]', 'r', 'normalized', ['i', 'j', 'k', 'l'], 1454), ('[l]', 'r', 'normalized', ['i', 'j', 'k', 'l'], 1459), ('[l]', 'r', 'normalized', ['i', 'j', 'k', 'l'], 1462)]
LDEs formed:0

type -> [('[k]', 'r', 'normalized', ['i', 'j', 'k', 'l'], 1453), ('[k]', 'r', 'normalized', ['i', 'j', 'k', 'l'], 1456), ('[k]', 'r', 'normalized', ['i', 'j', 'k', 'l'], 1458), ('[k]', 'r', 'normalized', ['i', 'j', 'k', 'l'], 1461)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<LENGTH(exercises)  i++
induction variable: ['i']
{
L1462: (exercises[i],r) 
	loop info: Size j=0  j<LENGTH(lengths)  j++
	induction variable: ['i', 'j']
	{
		loop info: Size t=0  t<LENGTH(strikes)  t++
		induction variable: ['i', 'j', 't']
		{
			loop info: Size h=0  h<LENGTH(type)  h++
			induction variable: ['i', 'j', 't', 'h']
			{
			L1463: (lengths[j],r) (strikes[t],r) 
			L1464: (type[h],r) 
				loop info: Size u=0  u<LENGTH(vols)  u++
				induction variable: ['i', 'j', 't', 'h', 'u']
				{
				L1465: (vols[u],r) (types[h],r) 
				L1466: (vols[u]-,r) (types[h],r) 
				L1467: (vols[u]+,r) (types[h],r) 
				L1468: (exercises[i]<<,r) 
				L1469: (vols[u],r) 
				L1470: (lengths[j]<<,r) 
				L1471: (strikes[t],r) 
				L1472: (types[h]<<,r) 
				}
 			}
 		}
 	}
 }
array table
-----------------------------------------------
lengths -> [('[j]', 'r', 'normalized', ['i', 'j', 't', 'h', 'u'], 1463), ('[j]', 'r', 'normalized', ['i', 'j', 't', 'h', 'u'], 1470)]
LDEs formed:0

strikes -> [('[t]', 'r', 'normalized', ['i', 'j', 't', 'h', 'u'], 1463), ('[t]', 'r', 'normalized', ['i', 'j', 't', 'h', 'u'], 1471)]
LDEs formed:0

vols -> [('[u]', 'r', 'normalized', ['i', 'j', 't', 'h', 'u'], 1465), ('[u]', 'r', 'normalized', ['i', 'j', 't', 'h', 'u'], 1466), ('[u]', 'r', 'normalized', ['i', 'j', 't', 'h', 'u'], 1467), ('[u]', 'r', 'normalized', ['i', 'j', 't', 'h', 'u'], 1469)]
LDEs formed:0

exercises -> [('[i]', 'r', 'normalized', ['i', 'j', 't', 'h', 'u'], 1462), ('[i]', 'r', 'normalized', ['i', 'j', 't', 'h', 'u'], 1468)]
LDEs formed:0

type -> [('[h]', 'r', 'normalized', ['i', 'j', 't', 'h', 'u'], 1464)]
LDEs formed:0

types -> [('[h]', 'r', 'normalized', ['i', 'j', 't', 'h', 'u'], 1465), ('[h]', 'r', 'normalized', ['i', 'j', 't', 'h', 'u'], 1466), ('[h]', 'r', 'normalized', ['i', 'j', 't', 'h', 'u'], 1467), ('[h]', 'r', 'normalized', ['i', 'j', 't', 'h', 'u'], 1472)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<LENGTH(exercises)  i++
induction variable: ['i']
{
	loop info: Size j=0  j<LENGTH(lengths)  j++
	induction variable: ['i', 'j']
	{
	L1473: (exercises[i],r) 
	L1474: (lengths[j],r) 
	L1475: (type[0],r) 
	L1476: (type[0],r) 
	L1477: (type[0],r) 
	L1478: (type[0],r) 
		loop info: i=0  i<swapFixedLeg_u360.size()  i++
		induction variable: ['i', 'j']
		{
		L1479: (swapFixedLeg_u360[i]-,r) 
		L1480: (swapFixedLeg_u360[i]-,r) 
		}
		loop info: i=0  i<swapFixedLeg_u365.size()  i++
		induction variable: ['i', 'j']
		{
		L1481: (swapFixedLeg_u365[i]-,r) 
		L1482: (swapFixedLeg_u365[i]-,r) 
		}
		loop info: i=0  i<swapFixedLeg_a360.size()  i++
		induction variable: ['i', 'j']
		{
		L1483: (swapFixedLeg_a360[i]-,r) 
		L1484: (swapFixedLeg_a360[i]-,r) 
		}
		loop info: i=0  i<swapFixedLeg_a365.size()  i++
		induction variable: ['i', 'j']
		{
		L1485: (swapFixedLeg_a365[i]-,r) 
		L1486: (swapFixedLeg_a365[i]-,r) 
		}
	L1487: (exercises[i].units,r) (lengths[j].units,r) 
	L1488: (exercises[i].units,r) (lengths[j].units,r) 
	L1489: (exercises[i].units,r) (lengths[j].units,r) 
	L1490: (exercises[i].units,r) (lengths[j].units,r) 
	}
 }
array table
-----------------------------------------------
lengths -> [('[j]', 'r', 'normalized', ['i', 'j'], 1474), ('[j]', 'r', 'normalized', ['i', 'j'], 1487), ('[j]', 'r', 'normalized', ['i', 'j'], 1488), ('[j]', 'r', 'normalized', ['i', 'j'], 1489), ('[j]', 'r', 'normalized', ['i', 'j'], 1490)]
LDEs formed:0

swapFixedLeg_a360 -> [('[i]', 'r', 'normalized', ['i', 'j'], 1483), ('[i]', 'r', 'normalized', ['i', 'j'], 1484)]
LDEs formed:0

swapFixedLeg_a365 -> [('[i]', 'r', 'normalized', ['i', 'j'], 1485), ('[i]', 'r', 'normalized', ['i', 'j'], 1486)]
LDEs formed:0

swapFixedLeg_u365 -> [('[i]', 'r', 'normalized', ['i', 'j'], 1481), ('[i]', 'r', 'normalized', ['i', 'j'], 1482)]
LDEs formed:0

exercises -> [('[i]', 'r', 'normalized', ['i', 'j'], 1473), ('[i]', 'r', 'normalized', ['i', 'j'], 1487), ('[i]', 'r', 'normalized', ['i', 'j'], 1488), ('[i]', 'r', 'normalized', ['i', 'j'], 1489), ('[i]', 'r', 'normalized', ['i', 'j'], 1490)]
LDEs formed:0

type -> [('[0]', 'r', 'normalized', ['i', 'j'], 1475), ('[0]', 'r', 'normalized', ['i', 'j'], 1476), ('[0]', 'r', 'normalized', ['i', 'j'], 1477), ('[0]', 'r', 'normalized', ['i', 'j'], 1478)]
LDEs formed:0

swapFixedLeg_u360 -> [('[i]', 'r', 'normalized', ['i', 'j'], 1479), ('[i]', 'r', 'normalized', ['i', 'j'], 1480)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<LENGTH(exercises)  i++
induction variable: ['i']
{
	loop info: Size j=0  j<LENGTH(lengths)  j++
	induction variable: ['i', 'j']
	{
	L1481: (exercises[i],r) 
		loop info: Size t=0  t<LENGTH(strikes)  t++
		induction variable: ['i', 'j', 't']
		{
			loop info: Size k=0  k<LENGTH(type)  k++
			induction variable: ['i', 'j', 't', 'k']
			{
			L1482: (lengths[j],r) (strikes[t],r) 
			L1483: (type[k],r) 
				loop info: Size h=0  h<LENGTH(types)  h++
				induction variable: ['i', 'j', 't', 'k', 'h']
				{
					loop info: Size u=0  u<LENGTH(vols)  u++
					induction variable: ['i', 'j', 't', 'k', 'h', 'u']
					{
					L1484: (vols[u],r) (types[h],r) 
					L1485: (exercises[i]<<,r) (lengths[j]<<,r) (type[k]<<,r) 
					L1486: (types[h]<<,r) 
					L1487: (strikes[t]<<,r) 
					L1488: (vols[u],r) 
					L1489: (vols[u],r) 
					L1490: (exercises[i]<<,r) (lengths[j]<<,r) (type[k]<<,r) 
					L1491: (types[h]<<,r) 
					L1492: (strikes[t]<<,r) 
					L1493: (vols[u],r) 
					}
 				}
 			}
 		}
 	}
 }
array table
-----------------------------------------------
lengths -> [('[j]', 'r', 'normalized', ['i', 'j', 't', 'k', 'h', 'u'], 1482), ('[j]', 'r', 'normalized', ['i', 'j', 't', 'k', 'h', 'u'], 1485), ('[j]', 'r', 'normalized', ['i', 'j', 't', 'k', 'h', 'u'], 1490)]
LDEs formed:0

strikes -> [('[t]', 'r', 'normalized', ['i', 'j', 't', 'k', 'h', 'u'], 1482), ('[t]', 'r', 'normalized', ['i', 'j', 't', 'k', 'h', 'u'], 1487), ('[t]', 'r', 'normalized', ['i', 'j', 't', 'k', 'h', 'u'], 1492)]
LDEs formed:0

vols -> [('[u]', 'r', 'normalized', ['i', 'j', 't', 'k', 'h', 'u'], 1484), ('[u]', 'r', 'normalized', ['i', 'j', 't', 'k', 'h', 'u'], 1488), ('[u]', 'r', 'normalized', ['i', 'j', 't', 'k', 'h', 'u'], 1489), ('[u]', 'r', 'normalized', ['i', 'j', 't', 'k', 'h', 'u'], 1493)]
LDEs formed:0

exercises -> [('[i]', 'r', 'normalized', ['i', 'j', 't', 'k', 'h', 'u'], 1481), ('[i]', 'r', 'normalized', ['i', 'j', 't', 'k', 'h', 'u'], 1485), ('[i]', 'r', 'normalized', ['i', 'j', 't', 'k', 'h', 'u'], 1490)]
LDEs formed:0

type -> [('[k]', 'r', 'normalized', ['i', 'j', 't', 'k', 'h', 'u'], 1483), ('[k]', 'r', 'normalized', ['i', 'j', 't', 'k', 'h', 'u'], 1485), ('[k]', 'r', 'normalized', ['i', 'j', 't', 'k', 'h', 'u'], 1490)]
LDEs formed:0

types -> [('[h]', 'r', 'normalized', ['i', 'j', 't', 'k', 'h', 'u'], 1484), ('[h]', 'r', 'normalized', ['i', 'j', 't', 'k', 'h', 'u'], 1486), ('[h]', 'r', 'normalized', ['i', 'j', 't', 'k', 'h', 'u'], 1491)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/compoundoption.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<LENGTH(values)  i++
induction variable: ['i']
{
L1492: (values[i].strikeMother,r) 
L1493: (values[i].strikeMother,r) 
L1494: (values[i].typeDaughter,r) 
L1495: (values[i].strikeDaughter,r) 
L1496: (values[i].tMother,r) 
L1497: (values[i].tDaughter,r) 
L1498: (values[i].s,r) 
L1499: (values[i].q,r) 
L1500: (values[i].r,r) 
L1501: (values[i].v,r) 
L1502: (values[i].strikeMother*,r) 
L1503: (values[i].s,r) 
L1504: (values[i].q,r) (values[i].r,r) 
L1505: (values[i].v,r) (values[i].delta,r) 
}
array table
-----------------------------------------------
values -> [('[i]', 'r', 'normalized', ['i'], 1492), ('[i]', 'r', 'normalized', ['i'], 1493), ('[i]', 'r', 'normalized', ['i'], 1494), ('[i]', 'r', 'normalized', ['i'], 1495), ('[i]', 'r', 'normalized', ['i'], 1496), ('[i]', 'r', 'normalized', ['i'], 1497), ('[i]', 'r', 'normalized', ['i'], 1498), ('[i]', 'r', 'normalized', ['i'], 1499), ('[i]', 'r', 'normalized', ['i'], 1500), ('[i]', 'r', 'normalized', ['i'], 1501), ('[i]', 'r', 'normalized', ['i'], 1502), ('[i]', 'r', 'normalized', ['i'], 1503), ('[i]', 'r', 'normalized', ['i'], 1504), ('[i]', 'r', 'normalized', ['i'], 1504), ('[i]', 'r', 'normalized', ['i'], 1505), ('[i]', 'r', 'normalized', ['i'], 1505)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<LENGTH(values)  i++
induction variable: ['i']
{
L1506: (values[i].typeMother,r) 
L1507: (values[i].strikeMother,r) 
L1508: (values[i].typeDaughter,r) 
L1509: (values[i].strikeDaughter,r) 
L1510: (values[i].tMother,r) 
L1511: (values[i].tDaughter,r) 
L1512: (values[i].s,r) 
L1513: (values[i].q,r) 
L1514: (values[i].r,r) 
L1515: (values[i].v,r) 
L1516: (values[i].npv,r) (values[i].npv,r) 
L1517: (values[i].tol,r) 
L1518: (values[i].s,r) 
L1519: (values[i].q,r) (values[i].r,r) 
L1520: (values[i].v,r) (values[i].npv,r) 
L1521: (values[i].delta,r) 
L1522: (values[i].tol,r) 
L1523: (values[i].s,r) 
L1524: (values[i].q,r) (values[i].r,r) 
L1525: (values[i].v,r) (values[i].delta,r) 
L1526: (values[i].gamma,r) 
L1527: (values[i].tol,r) 
L1528: (values[i].s,r) 
L1529: (values[i].q,r) (values[i].r,r) 
L1530: (values[i].v,r) (values[i].gamma,r) 
L1531: (values[i].vega,r) 
L1532: (values[i].tol,r) 
L1533: (values[i].s,r) 
L1534: (values[i].q,r) (values[i].r,r) 
L1535: (values[i].v,r) (values[i].vega,r) 
L1536: (values[i].theta,r) 
L1537: (values[i].tol,r) 
L1538: (values[i].s,r) 
L1539: (values[i].q,r) (values[i].r,r) 
L1540: (values[i].v,r) (values[i].theta,r) 
}
array table
-----------------------------------------------
values -> [('[i]', 'r', 'normalized', ['i'], 1506), ('[i]', 'r', 'normalized', ['i'], 1507), ('[i]', 'r', 'normalized', ['i'], 1508), ('[i]', 'r', 'normalized', ['i'], 1509), ('[i]', 'r', 'normalized', ['i'], 1510), ('[i]', 'r', 'normalized', ['i'], 1511), ('[i]', 'r', 'normalized', ['i'], 1512), ('[i]', 'r', 'normalized', ['i'], 1513), ('[i]', 'r', 'normalized', ['i'], 1514), ('[i]', 'r', 'normalized', ['i'], 1515), ('[i]', 'r', 'normalized', ['i'], 1516), ('[i]', 'r', 'normalized', ['i'], 1516), ('[i]', 'r', 'normalized', ['i'], 1517), ('[i]', 'r', 'normalized', ['i'], 1518), ('[i]', 'r', 'normalized', ['i'], 1519), ('[i]', 'r', 'normalized', ['i'], 1519), ('[i]', 'r', 'normalized', ['i'], 1520), ('[i]', 'r', 'normalized', ['i'], 1520), ('[i]', 'r', 'normalized', ['i'], 1521), ('[i]', 'r', 'normalized', ['i'], 1522), ('[i]', 'r', 'normalized', ['i'], 1523), ('[i]', 'r', 'normalized', ['i'], 1524), ('[i]', 'r', 'normalized', ['i'], 1524), ('[i]', 'r', 'normalized', ['i'], 1525), ('[i]', 'r', 'normalized', ['i'], 1525), ('[i]', 'r', 'normalized', ['i'], 1526), ('[i]', 'r', 'normalized', ['i'], 1527), ('[i]', 'r', 'normalized', ['i'], 1528), ('[i]', 'r', 'normalized', ['i'], 1529), ('[i]', 'r', 'normalized', ['i'], 1529), ('[i]', 'r', 'normalized', ['i'], 1530), ('[i]', 'r', 'normalized', ['i'], 1530), ('[i]', 'r', 'normalized', ['i'], 1531), ('[i]', 'r', 'normalized', ['i'], 1532), ('[i]', 'r', 'normalized', ['i'], 1533), ('[i]', 'r', 'normalized', ['i'], 1534), ('[i]', 'r', 'normalized', ['i'], 1534), ('[i]', 'r', 'normalized', ['i'], 1535), ('[i]', 'r', 'normalized', ['i'], 1535), ('[i]', 'r', 'normalized', ['i'], 1536), ('[i]', 'r', 'normalized', ['i'], 1537), ('[i]', 'r', 'normalized', ['i'], 1538), ('[i]', 'r', 'normalized', ['i'], 1539), ('[i]', 'r', 'normalized', ['i'], 1539), ('[i]', 'r', 'normalized', ['i'], 1540), ('[i]', 'r', 'normalized', ['i'], 1540)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/hestonmodel.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: i = 0  i < 8  ++i
induction variable: ['i']
{
L1541: (t[i],r) 
L1542: (r[i],r) 
}
array table
-----------------------------------------------
r -> [('[i]', 'r', 'normalized', ['i'], 1542)]
LDEs formed:0

t -> [('[i]', 'r', 'normalized', ['i'], 1541)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size s = 0  s < 13  ++s
induction variable: ['s']
{
	loop info: Size m = 0  m < 8  ++m
	induction variable: ['s', 'm']
	{
	L1542: (v[s*8+m],r) 
	L1543: (t[m]+,r) 
	L1544: (strike[s],r) 
	}
 }
array table
-----------------------------------------------
strike -> [('[s]', 'r', 'normalized', ['s', 'm'], 1544)]
LDEs formed:0

t -> [('[m]', 'r', 'normalized', ['s', 'm'], 1543)]
LDEs formed:0

v -> [('[s*8+m]', 'r', 'normalized', ['s', 'm'], 1542)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i = 0  i < optionMaturities.size()  ++i
induction variable: ['i']
{
	loop info: Real moneyness = -1.0  moneyness < 2.0  moneyness += 1.0
	induction variable: ['i', 'moneyness']
	{
	L1543: (optionMaturities[i],r) 
	L1544: (optionMaturities[i],r) 
	}
 }
array table
-----------------------------------------------
optionMaturities -> [('[i]', 'r', 'normalized', ['i', 'moneyness'], 1543), ('[i]', 'r', 'normalized', ['i', 'moneyness'], 1544)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i = 0  i < 13*8  ++i
induction variable: ['i']
{
L1545: (options[i]-,r) 
}
array table
-----------------------------------------------
options -> [('[i]', 'r', 'normalized', ['i'], 1545)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: i = 0  i < 6  ++i
induction variable: ['i']
{
L1546: (K[i%3],r) 
L1547: (calculated2[i]=,w) 
}
array table
-----------------------------------------------
calculated2 -> [('[i]', 'w', 'normalized', ['i'], 1547)]
LDEs formed:1

K -> [('[i%3]', 'r', 'normalized', ['i'], 1546)]
LDEs formed:0

distinct LDEs:
i1=i2
#########################################################################################
loop info: i = 0  i < 3  ++i
induction variable: ['i']
{
L1547: (calculated2[i]+,r) (calculated2[i+3]-,r) (calculated2[i],r) 
L1548: (expected2[i],r) 
L1549: (expected2[i],r) 
}
array table
-----------------------------------------------
calculated2 -> [('[i]', 'r', 'normalized', ['i'], 1547), ('[i+3]', 'r', 'normalized', ['i'], 1547), ('[i]', 'r', 'normalized', ['i'], 1547)]
LDEs formed:0

expected2 -> [('[i]', 'r', 'normalized', ['i'], 1548), ('[i]', 'r', 'normalized', ['i'], 1549)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i < LENGTH(descriptions)  ++i
induction variable: ['i']
{
L1550: (descriptions[i].discretization,r) 
L1551: (descriptions[i].nSteps,r) 
L1552: (descriptions[i].name,r) 
L1553: (descriptions[i].name,r) 
}
array table
-----------------------------------------------
descriptions -> [('[i]', 'r', 'normalized', ['i'], 1550), ('[i]', 'r', 'normalized', ['i'], 1551), ('[i]', 'r', 'normalized', ['i'], 1552), ('[i]', 'r', 'normalized', ['i'], 1553)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i < LENGTH(maturities)  ++i
induction variable: ['i']
{
L1554: (maturities[i],r) 
	loop info: Size j=0  j < LENGTH(strikes)  ++j
	induction variable: ['i', 'j']
	{
		loop info: Size k=0  k < LENGTH(types)  ++k
		induction variable: ['i', 'j', 'k']
		{
		L1555: (types[k],r) (strikes[j],r) 
		}
 	}
 }
array table
-----------------------------------------------
maturities -> [('[i]', 'r', 'normalized', ['i', 'j', 'k'], 1554)]
LDEs formed:0

strikes -> [('[j]', 'r', 'normalized', ['i', 'j', 'k'], 1555)]
LDEs formed:0

types -> [('[k]', 'r', 'normalized', ['i', 'j', 'k'], 1555)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i < strikes.size()  ++i
induction variable: ['i']
{
L1556: (strikes[i],r) 
}
array table
-----------------------------------------------
strikes -> [('[i]', 'r', 'normalized', ['i'], 1556)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i = 0  i < 13*8  ++i
induction variable: ['i']
{
L1557: (options[i]-,r) 
}
array table
-----------------------------------------------
options -> [('[i]', 'r', 'normalized', ['i'], 1557)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i < LENGTH(strikes)  ++i
induction variable: ['i']
{
L1558: (strikes[i],r) 
	loop info: Size j=0  j < LENGTH(types)  ++j
	induction variable: ['i', 'j']
	{
	L1559: (types[j],r) 
		loop info: Size k=0  k < LENGTH(engines)  ++k
		induction variable: ['i', 'j', 'k']
		{
		L1560: (engines[k],r) 
		L1561: (expectedResults[i][j],r) 
		}
 	}
 }
array table
-----------------------------------------------
engines -> [('[k]', 'r', 'normalized', ['i', 'j', 'k'], 1560)]
LDEs formed:0

types -> [('[j]', 'r', 'normalized', ['i', 'j', 'k'], 1559)]
LDEs formed:0

strikes -> [('[i]', 'r', 'normalized', ['i', 'j', 'k'], 1558)]
LDEs formed:0

expectedResults -> [('[i][j]', 'r', 'normalized', ['i', 'j', 'k'], 1561)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i < LENGTH(strikes)  ++i
induction variable: ['i']
{
L1562: (strikes[i],r) 
	loop info: Size j=0  j < LENGTH(types)  ++j
	induction variable: ['i', 'j']
	{
	L1563: (types[j],r) 
		loop info: Size k=0  k < LENGTH(engines)  ++k
		induction variable: ['i', 'j', 'k']
		{
		L1564: (engines[k],r) 
		L1565: (expectedResults[i][j],r) 
		L1566: (tol[k],r) 
		}
 	}
 }
array table
-----------------------------------------------
tol -> [('[k]', 'r', 'normalized', ['i', 'j', 'k'], 1566)]
LDEs formed:0

engines -> [('[k]', 'r', 'normalized', ['i', 'j', 'k'], 1564)]
LDEs formed:0

types -> [('[j]', 'r', 'normalized', ['i', 'j', 'k'], 1563)]
LDEs formed:0

strikes -> [('[i]', 'r', 'normalized', ['i', 'j', 'k'], 1562)]
LDEs formed:0

expectedResults -> [('[i][j]', 'r', 'normalized', ['i', 'j', 'k'], 1565)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size j=0  j < LENGTH(terms)  ++j
induction variable: ['j']
{
L1566: (terms[j],r) 
	loop info: Size i=0  i < LENGTH(strikes)  ++i
	induction variable: ['j', 'i']
	{
	L1567: (strikes[i],r) 
		loop info: Size k=0  k < LENGTH(expansions)  ++k
		induction variable: ['j', 'i', 'k']
		{
		L1568: (expansions[k],r) 
		L1569: (referenceVols[j][i],r) 
		L1570: (tolAtm[k][j],r) (tol[k][j],r) 
		}
 	}
 }
array table
-----------------------------------------------
tolAtm -> [('[k][j]', 'r', 'normalized', ['j', 'i', 'k'], 1570)]
LDEs formed:0

terms -> [('[j]', 'r', 'normalized', ['j', 'i', 'k'], 1566)]
LDEs formed:0

expansions -> [('[k]', 'r', 'normalized', ['j', 'i', 'k'], 1568)]
LDEs formed:0

strikes -> [('[i]', 'r', 'normalized', ['j', 'i', 'k'], 1567)]
LDEs formed:0

tol -> [('[k][j]', 'r', 'normalized', ['j', 'i', 'k'], 1570)]
LDEs formed:0

referenceVols -> [('[j][i]', 'r', 'normalized', ['j', 'i', 'k'], 1569)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/cdo.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i = 0  i < LENGTH(hwData7)  i++
induction variable: ['i']
{
L1570: (hwData7[i].correlation,r) 
L1571: (hwData7[i].trancheSpread,r) 
L1572: (hwData7[i].nm==,r) (hwData7[i].nz==,r) 
L1573: (hwData7[i].nm,r) (hwData7[i].nz,r) 
L1574: (hwData7[i].nm,r) 
L1575: (hwData7[i].nz,r) 
L1576: (hwData7[i].nm,r) (hwData7[i].nz==,r) 
L1577: (hwData7[i].nm,r) 
L1578: (hwData7[i].nm==,r) (hwData7[i].nz,r) 
L1579: (hwData7[i].nz,r) 
	loop info: Size j = 0  j < LENGTH(hwAttachment)  j ++
	induction variable: ['i', 'j']
	{
	L1580: (hwAttachment[j],r) (hwDetachment[j],r) 
	L1581: (hwAttachment[j]<<,r) (hwDetachment[j],r) 
		loop info: Size im=0  im<basketModels.size()  im++
		induction variable: ['i', 'j', 'im']
		{
		L1582: (basketModels[im],r) 
		L1583: (modelNames[im],r) 
		L1584: (hwData7[i].trancheSpread,r) 
		L1585: (absoluteTolerance[im],r) (relativeToleranceMidp[im],r) 
		L1586: (modelNames[im],r) 
		L1587: (hwData7[i].trancheSpread,r) 
		L1588: (absoluteTolerance[im],r) (relativeTolerancePeriod[im],r) 
		}
 	}
 }
array table
-----------------------------------------------
hwDetachment -> [('[j]', 'r', 'normalized', ['i', 'j', 'im'], 1580), ('[j]', 'r', 'normalized', ['i', 'j', 'im'], 1581)]
LDEs formed:0

relativeTolerancePeriod -> [('[im]', 'r', 'normalized', ['i', 'j', 'im'], 1588)]
LDEs formed:0

relativeToleranceMidp -> [('[im]', 'r', 'normalized', ['i', 'j', 'im'], 1585)]
LDEs formed:0

modelNames -> [('[im]', 'r', 'normalized', ['i', 'j', 'im'], 1583), ('[im]', 'r', 'normalized', ['i', 'j', 'im'], 1586)]
LDEs formed:0

absoluteTolerance -> [('[im]', 'r', 'normalized', ['i', 'j', 'im'], 1585), ('[im]', 'r', 'normalized', ['i', 'j', 'im'], 1588)]
LDEs formed:0

hwAttachment -> [('[j]', 'r', 'normalized', ['i', 'j', 'im'], 1580), ('[j]', 'r', 'normalized', ['i', 'j', 'im'], 1581)]
LDEs formed:0

basketModels -> [('[im]', 'r', 'normalized', ['i', 'j', 'im'], 1582)]
LDEs formed:0

hwData7 -> [('[i]', 'r', 'normalized', ['i', 'j', 'im'], 1570), ('[i]', 'r', 'normalized', ['i', 'j', 'im'], 1571), ('[i]', 'r', 'normalized', ['i', 'j', 'im'], 1572), ('[i]', 'r', 'normalized', ['i', 'j', 'im'], 1572), ('[i]', 'r', 'normalized', ['i', 'j', 'im'], 1573), ('[i]', 'r', 'normalized', ['i', 'j', 'im'], 1573), ('[i]', 'r', 'normalized', ['i', 'j', 'im'], 1574), ('[i]', 'r', 'normalized', ['i', 'j', 'im'], 1575), ('[i]', 'r', 'normalized', ['i', 'j', 'im'], 1576), ('[i]', 'r', 'normalized', ['i', 'j', 'im'], 1576), ('[i]', 'r', 'normalized', ['i', 'j', 'im'], 1577), ('[i]', 'r', 'normalized', ['i', 'j', 'im'], 1578), ('[i]', 'r', 'normalized', ['i', 'j', 'im'], 1578), ('[i]', 'r', 'normalized', ['i', 'j', 'im'], 1579), ('[i]', 'r', 'normalized', ['i', 'j', 'im'], 1584), ('[i]', 'r', 'normalized', ['i', 'j', 'im'], 1587)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/businessdayconventions.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<n  i++
induction variable: ['i']
{
L1588: (testCases[i].calendar,r) 
L1589: (testCases[i].start,r) 
L1590: (testCases[i].period,r) 
L1591: (testCases[i].convention,r) 
L1592: (testCases[i].endOfMonth,r) 
L1593: (testCases[i].result,r) 
L1594: (testCases[i].start<<,r) 
L1595: (testCases[i].period<<,r) (testCases[i].endOfMonth<<,r) 
L1596: (testCases[i].convention<<,r) 
L1597: (testCases[i].result<<,r) 
}
array table
-----------------------------------------------
testCases -> [('[i]', 'r', 'normalized', ['i'], 1588), ('[i]', 'r', 'normalized', ['i'], 1589), ('[i]', 'r', 'normalized', ['i'], 1590), ('[i]', 'r', 'normalized', ['i'], 1591), ('[i]', 'r', 'normalized', ['i'], 1592), ('[i]', 'r', 'normalized', ['i'], 1593), ('[i]', 'r', 'normalized', ['i'], 1594), ('[i]', 'r', 'normalized', ['i'], 1595), ('[i]', 'r', 'normalized', ['i'], 1595), ('[i]', 'r', 'normalized', ['i'], 1596), ('[i]', 'r', 'normalized', ['i'], 1597)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/spreadoption.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<LENGTH(cases)  ++i
induction variable: ['i']
{
L1598: (cases[i].length,r) 
L1599: (cases[i].F1,r) 
L1600: (cases[i].F2,r) 
L1601: (cases[i].r,r) 
L1602: (cases[i].rho,r) 
L1603: (cases[i].sigma1,r) 
L1604: (cases[i].sigma2,r) 
L1605: (cases[i].X,r) 
L1606: (cases[i].result,r) 
}
array table
-----------------------------------------------
cases -> [('[i]', 'r', 'normalized', ['i'], 1598), ('[i]', 'r', 'normalized', ['i'], 1599), ('[i]', 'r', 'normalized', ['i'], 1600), ('[i]', 'r', 'normalized', ['i'], 1601), ('[i]', 'r', 'normalized', ['i'], 1602), ('[i]', 'r', 'normalized', ['i'], 1603), ('[i]', 'r', 'normalized', ['i'], 1604), ('[i]', 'r', 'normalized', ['i'], 1605), ('[i]', 'r', 'normalized', ['i'], 1606)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/americanoption.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<LENGTH(values)  i++
induction variable: ['i']
{
L1607: (values[i].type,r) (values[i].strike,r) 
L1608: (values[i].t*,r) 
L1609: (values[i].s,r) 
L1610: (values[i].q,r) 
L1611: (values[i].r,r) 
L1612: (values[i].v,r) 
L1613: (values[i].result,r) 
L1614: (values[i].s,r) (values[i].q,r) 
L1615: (values[i].r,r) (values[i].v,r) (values[i].result,r) 
}
array table
-----------------------------------------------
values -> [('[i]', 'r', 'normalized', ['i'], 1607), ('[i]', 'r', 'normalized', ['i'], 1607), ('[i]', 'r', 'normalized', ['i'], 1608), ('[i]', 'r', 'normalized', ['i'], 1609), ('[i]', 'r', 'normalized', ['i'], 1610), ('[i]', 'r', 'normalized', ['i'], 1611), ('[i]', 'r', 'normalized', ['i'], 1612), ('[i]', 'r', 'normalized', ['i'], 1613), ('[i]', 'r', 'normalized', ['i'], 1614), ('[i]', 'r', 'normalized', ['i'], 1614), ('[i]', 'r', 'normalized', ['i'], 1615), ('[i]', 'r', 'normalized', ['i'], 1615), ('[i]', 'r', 'normalized', ['i'], 1615)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<LENGTH(values)  i++
induction variable: ['i']
{
L1616: (values[i].type,r) (values[i].strike,r) 
L1617: (values[i].t*,r) 
L1618: (values[i].s,r) 
L1619: (values[i].q,r) 
L1620: (values[i].r,r) 
L1621: (values[i].v,r) 
L1622: (values[i].result,r) 
L1623: (values[i].s,r) (values[i].q,r) 
L1624: (values[i].r,r) (values[i].v,r) (values[i].result,r) 
}
array table
-----------------------------------------------
values -> [('[i]', 'r', 'normalized', ['i'], 1616), ('[i]', 'r', 'normalized', ['i'], 1616), ('[i]', 'r', 'normalized', ['i'], 1617), ('[i]', 'r', 'normalized', ['i'], 1618), ('[i]', 'r', 'normalized', ['i'], 1619), ('[i]', 'r', 'normalized', ['i'], 1620), ('[i]', 'r', 'normalized', ['i'], 1621), ('[i]', 'r', 'normalized', ['i'], 1622), ('[i]', 'r', 'normalized', ['i'], 1623), ('[i]', 'r', 'normalized', ['i'], 1623), ('[i]', 'r', 'normalized', ['i'], 1624), ('[i]', 'r', 'normalized', ['i'], 1624), ('[i]', 'r', 'normalized', ['i'], 1624)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<LENGTH(juValues)  i++
induction variable: ['i']
{
L1625: (juValues[i].type,r) (juValues[i].strike,r) 
L1626: (juValues[i].t*,r) 
L1627: (juValues[i].s,r) 
L1628: (juValues[i].q,r) 
L1629: (juValues[i].r,r) 
L1630: (juValues[i].v,r) 
L1631: (juValues[i].result,r) 
L1632: (juValues[i].s,r) 
L1633: (juValues[i].q,r) (juValues[i].r,r) 
L1634: (juValues[i].v,r) (juValues[i].result,r) 
}
array table
-----------------------------------------------
juValues -> [('[i]', 'r', 'normalized', ['i'], 1625), ('[i]', 'r', 'normalized', ['i'], 1625), ('[i]', 'r', 'normalized', ['i'], 1626), ('[i]', 'r', 'normalized', ['i'], 1627), ('[i]', 'r', 'normalized', ['i'], 1628), ('[i]', 'r', 'normalized', ['i'], 1629), ('[i]', 'r', 'normalized', ['i'], 1630), ('[i]', 'r', 'normalized', ['i'], 1631), ('[i]', 'r', 'normalized', ['i'], 1632), ('[i]', 'r', 'normalized', ['i'], 1633), ('[i]', 'r', 'normalized', ['i'], 1633), ('[i]', 'r', 'normalized', ['i'], 1634), ('[i]', 'r', 'normalized', ['i'], 1634)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<LENGTH(juValues)  i++
induction variable: ['i']
{
L1635: (juValues[i].type,r) (juValues[i].strike,r) 
L1636: (juValues[i].t*,r) 
L1637: (juValues[i].s,r) 
L1638: (juValues[i].q,r) 
L1639: (juValues[i].r,r) 
L1640: (juValues[i].v,r) 
L1641: (juValues[i].result,r) 
L1642: (juValues[i].s,r) 
L1643: (juValues[i].q,r) (juValues[i].r,r) 
L1644: (juValues[i].v,r) (juValues[i].result,r) 
}
array table
-----------------------------------------------
juValues -> [('[i]', 'r', 'normalized', ['i'], 1635), ('[i]', 'r', 'normalized', ['i'], 1635), ('[i]', 'r', 'normalized', ['i'], 1636), ('[i]', 'r', 'normalized', ['i'], 1637), ('[i]', 'r', 'normalized', ['i'], 1638), ('[i]', 'r', 'normalized', ['i'], 1639), ('[i]', 'r', 'normalized', ['i'], 1640), ('[i]', 'r', 'normalized', ['i'], 1641), ('[i]', 'r', 'normalized', ['i'], 1642), ('[i]', 'r', 'normalized', ['i'], 1643), ('[i]', 'r', 'normalized', ['i'], 1643), ('[i]', 'r', 'normalized', ['i'], 1644), ('[i]', 'r', 'normalized', ['i'], 1644)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<LENGTH(types)  i++
induction variable: ['i']
{
	loop info: Size j=0  j<LENGTH(strikes)  j++
	induction variable: ['i', 'j']
	{
		loop info: Size k=0  k<LENGTH(years)  k++
		induction variable: ['i', 'j', 'k']
		{
		L1645: (years[k]*,r) 
		L1646: (types[i],r) (strikes[j],r) 
			loop info: Size l=0  l<LENGTH(underlyings)  l++
			induction variable: ['i', 'j', 'k', 'l']
			{
				loop info: Size m=0  m<LENGTH(qRates)  m++
				induction variable: ['i', 'j', 'k', 'l', 'm']
				{
					loop info: Size n=0  n<LENGTH(rRates)  n++
					induction variable: ['i', 'j', 'k', 'l', 'm', 'n']
					{
						loop info: Size p=0  p<LENGTH(vols)  p++
						induction variable: ['i', 'j', 'k', 'l', 'm', 'n', 'p']
						{
						L1647: (underlyings[l],r) 
						L1648: (qRates[m],r) 
						L1649: (rRates[n],r) 
						L1650: (vols[p],r) 
						L1651: (calculated["delta"]=,w) 
						L1652: (calculated["gamma"]=,w) 
						L1653: (calculated["theta"]=,w) 
						L1654: (expected["delta"]=,w) 
						L1655: (expected["gamma"]=,w) 
						L1656: (expected["theta"]=,w) 
						L1657: (calculated[greek],r) 
						}
 					}
 				}
 			}
 		}
 	}
 }
array table
-----------------------------------------------
rRates -> [('[n]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p'], 1649)]
LDEs formed:0

calculated -> [('["delta"]', 'w', 'not normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p'], 1651), ('["gamma"]', 'w', 'not normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p'], 1652), ('["theta"]', 'w', 'not normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p'], 1653), ('[greek]', 'r', 'not normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p'], 1657)]
LDEs formed:9

qRates -> [('[m]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p'], 1648)]
LDEs formed:0

strikes -> [('[j]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p'], 1646)]
LDEs formed:0

years -> [('[k]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p'], 1645)]
LDEs formed:0

underlyings -> [('[l]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p'], 1647)]
LDEs formed:0

vols -> [('[p]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p'], 1650)]
LDEs formed:0

expected -> [('["delta"]', 'w', 'not normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p'], 1654), ('["gamma"]', 'w', 'not normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p'], 1655), ('["theta"]', 'w', 'not normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p'], 1656)]
LDEs formed:6

types -> [('[i]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p'], 1646)]
LDEs formed:0

distinct LDEs:
"theta"="theta"
"delta"="gamma"
"gamma"="theta"
"gamma"="gamma"
"delta"="delta"
"delta"="theta"
"theta"=greek
"delta"=greek
"gamma"=greek
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/barrieroption.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<LENGTH(values)  i++
induction variable: ['i']
{
L1647: (values[i].t*,r) 
L1648: (values[i].s,r) 
L1649: (values[i].q,r) 
L1650: (values[i].r,r) 
L1651: (values[i].v,r) 
L1652: (values[i].type,r) 
L1653: (values[i].strike,r) 
L1654: (values[i].exType==,r) 
L1655: (values[i].barrierType,r) 
L1656: (values[i].barrier,r) 
L1657: (values[i].rebate,r) 
L1658: (values[i].exType==,r) 
L1659: (values[i].result,r) 
L1660: (values[i].tol,r) 
L1661: (values[i].barrierType,r) (values[i].barrier,r) 
L1662: (values[i].rebate,r) (values[i].s,r) 
L1663: (values[i].q,r) (values[i].r,r) (values[i].v,r) 
L1664: (values[i].tol,r) 
L1665: (values[i].result,r) 
L1666: (values[i].barrierType,r) (values[i].barrier,r) 
L1667: (values[i].rebate,r) (values[i].s,r) 
L1668: (values[i].q,r) (values[i].r,r) (values[i].v,r) 
L1669: (values[i].tol,r) 
L1670: (values[i].result,r) 
L1671: (values[i].barrierType,r) (values[i].barrier,r) 
L1672: (values[i].rebate,r) (values[i].s,r) 
L1673: (values[i].q,r) (values[i].r,r) (values[i].v,r) 
L1674: (values[i].result,r) 
L1675: (values[i].barrierType,r) (values[i].barrier,r) 
L1676: (values[i].rebate,r) (values[i].s,r) 
L1677: (values[i].q,r) (values[i].r,r) (values[i].v,r) 
}
array table
-----------------------------------------------
values -> [('[i]', 'r', 'normalized', ['i'], 1647), ('[i]', 'r', 'normalized', ['i'], 1648), ('[i]', 'r', 'normalized', ['i'], 1649), ('[i]', 'r', 'normalized', ['i'], 1650), ('[i]', 'r', 'normalized', ['i'], 1651), ('[i]', 'r', 'normalized', ['i'], 1652), ('[i]', 'r', 'normalized', ['i'], 1653), ('[i]', 'r', 'normalized', ['i'], 1654), ('[i]', 'r', 'normalized', ['i'], 1655), ('[i]', 'r', 'normalized', ['i'], 1656), ('[i]', 'r', 'normalized', ['i'], 1657), ('[i]', 'r', 'normalized', ['i'], 1658), ('[i]', 'r', 'normalized', ['i'], 1659), ('[i]', 'r', 'normalized', ['i'], 1660), ('[i]', 'r', 'normalized', ['i'], 1661), ('[i]', 'r', 'normalized', ['i'], 1661), ('[i]', 'r', 'normalized', ['i'], 1662), ('[i]', 'r', 'normalized', ['i'], 1662), ('[i]', 'r', 'normalized', ['i'], 1663), ('[i]', 'r', 'normalized', ['i'], 1663), ('[i]', 'r', 'normalized', ['i'], 1663), ('[i]', 'r', 'normalized', ['i'], 1664), ('[i]', 'r', 'normalized', ['i'], 1665), ('[i]', 'r', 'normalized', ['i'], 1666), ('[i]', 'r', 'normalized', ['i'], 1666), ('[i]', 'r', 'normalized', ['i'], 1667), ('[i]', 'r', 'normalized', ['i'], 1667), ('[i]', 'r', 'normalized', ['i'], 1668), ('[i]', 'r', 'normalized', ['i'], 1668), ('[i]', 'r', 'normalized', ['i'], 1668), ('[i]', 'r', 'normalized', ['i'], 1669), ('[i]', 'r', 'normalized', ['i'], 1670), ('[i]', 'r', 'normalized', ['i'], 1671), ('[i]', 'r', 'normalized', ['i'], 1671), ('[i]', 'r', 'normalized', ['i'], 1672), ('[i]', 'r', 'normalized', ['i'], 1672), ('[i]', 'r', 'normalized', ['i'], 1673), ('[i]', 'r', 'normalized', ['i'], 1673), ('[i]', 'r', 'normalized', ['i'], 1673), ('[i]', 'r', 'normalized', ['i'], 1674), ('[i]', 'r', 'normalized', ['i'], 1675), ('[i]', 'r', 'normalized', ['i'], 1675), ('[i]', 'r', 'normalized', ['i'], 1676), ('[i]', 'r', 'normalized', ['i'], 1676), ('[i]', 'r', 'normalized', ['i'], 1677), ('[i]', 'r', 'normalized', ['i'], 1677), ('[i]', 'r', 'normalized', ['i'], 1677)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<LENGTH(values)  i++
induction variable: ['i']
{
L1678: (values[i].volatility,r) 
L1679: (values[i].strike,r) 
L1680: (values[i].type,r) 
L1681: (values[i].barrier,r) 
L1682: (values[i].callValue,r) 
L1683: (values[i].type,r) (values[i].barrier,r) 
L1684: (values[i].volatility,r) 
L1685: (values[i].type,r) (values[i].barrier,r) 
L1686: (values[i].volatility,r) 
}
array table
-----------------------------------------------
values -> [('[i]', 'r', 'normalized', ['i'], 1678), ('[i]', 'r', 'normalized', ['i'], 1679), ('[i]', 'r', 'normalized', ['i'], 1680), ('[i]', 'r', 'normalized', ['i'], 1681), ('[i]', 'r', 'normalized', ['i'], 1682), ('[i]', 'r', 'normalized', ['i'], 1683), ('[i]', 'r', 'normalized', ['i'], 1683), ('[i]', 'r', 'normalized', ['i'], 1684), ('[i]', 'r', 'normalized', ['i'], 1685), ('[i]', 'r', 'normalized', ['i'], 1685), ('[i]', 'r', 'normalized', ['i'], 1686)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<LENGTH(values)  i++
induction variable: ['i']
{
L1687: (values[i].volatility,r) 
L1688: (values[i].strike,r) 
L1689: (values[i].type,r) 
L1690: (values[i].barrier,r) 
L1691: (values[i].callValue,r) 
L1692: (values[i].type,r) (values[i].barrier,r) 
L1693: (values[i].volatility,r) 
L1694: (values[i].type,r) (values[i].barrier,r) 
L1695: (values[i].volatility,r) 
}
array table
-----------------------------------------------
values -> [('[i]', 'r', 'normalized', ['i'], 1687), ('[i]', 'r', 'normalized', ['i'], 1688), ('[i]', 'r', 'normalized', ['i'], 1689), ('[i]', 'r', 'normalized', ['i'], 1690), ('[i]', 'r', 'normalized', ['i'], 1691), ('[i]', 'r', 'normalized', ['i'], 1692), ('[i]', 'r', 'normalized', ['i'], 1692), ('[i]', 'r', 'normalized', ['i'], 1693), ('[i]', 'r', 'normalized', ['i'], 1694), ('[i]', 'r', 'normalized', ['i'], 1694), ('[i]', 'r', 'normalized', ['i'], 1695)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i = 0  i < 8  ++i
induction variable: ['i']
{
L1696: (t[i],r) 
L1697: (r[i],r) 
}
array table
-----------------------------------------------
r -> [('[i]', 'r', 'normalized', ['i'], 1697)]
LDEs formed:0

t -> [('[i]', 'r', 'normalized', ['i'], 1696)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i < strikes.size()  ++i
induction variable: ['i']
{
L1697: (blackVolMatrix[i][j-1]=,w) (v[i*(dates.size()-1)+j-1],r) 
}
array table
-----------------------------------------------
blackVolMatrix -> [('[i][j-1]', 'w', 'not normalized', ['i'], 1697)]
LDEs formed:2

v -> [('[i*(dates.size()-1)+j-1]', 'r', 'not normalized', ['i'], 1697)]
LDEs formed:0

distinct LDEs:
i1=i2,j-1=j-1
#########################################################################################
loop info: Size i=0  i<LENGTH(values)  i++
induction variable: ['i']
{
L1698: (values[i].s,r) 
L1699: (values[i].q,r) 
L1700: (values[i].r,r) 
L1701: (values[i].vol25Put,r) 
L1702: (values[i].volAtm,r) 
L1703: (values[i].vol25Call,r) 
L1704: (values[i].type,r) 
L1705: (values[i].strike,r) 
L1706: (values[i].t*,r) 
L1707: (values[i].t,r) 
L1708: (values[i].t,r) 
L1709: (values[i].t,r) 
L1710: (values[i].barrierType,r) 
L1711: (values[i].barrier,r) 
L1712: (values[i].rebate,r) 
L1713: (values[i].type,r) (values[i].strike,r) 
L1714: (values[i].t,r) (values[i].t,r) 
L1715: (values[i].v*,r) (values[i].t,r) (values[i].t,r) 
L1716: (values[i].result,r) 
L1717: (values[i].tol,r) 
L1718: (values[i].barrierType,r) (values[i].barrier,r) 
L1719: (values[i].rebate,r) (values[i].s,r) 
L1720: (values[i].q,r) (values[i].r,r) (values[i].vol25Put,r) 
L1721: (values[i].volAtm,r) (values[i].vol25Call,r) (values[i].v,r) 
L1722: (values[i].tol,r) 
}
array table
-----------------------------------------------
values -> [('[i]', 'r', 'normalized', ['i'], 1698), ('[i]', 'r', 'normalized', ['i'], 1699), ('[i]', 'r', 'normalized', ['i'], 1700), ('[i]', 'r', 'normalized', ['i'], 1701), ('[i]', 'r', 'normalized', ['i'], 1702), ('[i]', 'r', 'normalized', ['i'], 1703), ('[i]', 'r', 'normalized', ['i'], 1704), ('[i]', 'r', 'normalized', ['i'], 1705), ('[i]', 'r', 'normalized', ['i'], 1706), ('[i]', 'r', 'normalized', ['i'], 1707), ('[i]', 'r', 'normalized', ['i'], 1708), ('[i]', 'r', 'normalized', ['i'], 1709), ('[i]', 'r', 'normalized', ['i'], 1710), ('[i]', 'r', 'normalized', ['i'], 1711), ('[i]', 'r', 'normalized', ['i'], 1712), ('[i]', 'r', 'normalized', ['i'], 1713), ('[i]', 'r', 'normalized', ['i'], 1713), ('[i]', 'r', 'normalized', ['i'], 1714), ('[i]', 'r', 'normalized', ['i'], 1714), ('[i]', 'r', 'normalized', ['i'], 1715), ('[i]', 'r', 'normalized', ['i'], 1715), ('[i]', 'r', 'normalized', ['i'], 1715), ('[i]', 'r', 'normalized', ['i'], 1716), ('[i]', 'r', 'normalized', ['i'], 1717), ('[i]', 'r', 'normalized', ['i'], 1718), ('[i]', 'r', 'normalized', ['i'], 1718), ('[i]', 'r', 'normalized', ['i'], 1719), ('[i]', 'r', 'normalized', ['i'], 1719), ('[i]', 'r', 'normalized', ['i'], 1720), ('[i]', 'r', 'normalized', ['i'], 1720), ('[i]', 'r', 'normalized', ['i'], 1720), ('[i]', 'r', 'normalized', ['i'], 1721), ('[i]', 'r', 'normalized', ['i'], 1721), ('[i]', 'r', 'normalized', ['i'], 1721), ('[i]', 'r', 'normalized', ['i'], 1722)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/gaussianquadratures.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<LENGTH(order)  i++
induction variable: ['i']
{
L1723: (order[i],r) 
L1724: (order[i]<<,r) 
}
array table
-----------------------------------------------
order -> [('[i]', 'r', 'normalized', ['i'], 1723), ('[i]', 'r', 'normalized', ['i'], 1724)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/amortizingbond.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<LENGTH(rates)  ++i
induction variable: ['i']
{
L1725: (rates[i],r) 
	loop info: Size k=0  k < cashflows.size() / 2  ++k
	induction variable: ['i', 'k']
	{
	L1726: (cashflows[2*k]-,r) 
	L1727: (cashflows[2*k+1]-,r) 
	L1728: (amounts[i],r) 
	L1729: (rates[i]<<,r) 
	L1730: (amounts[i]<<,r) 
	L1731: (notionals[k]*,r) (rates[i]/,r) 
	L1732: (rates[i]<<,r) 
	}
 }
array table
-----------------------------------------------
amounts -> [('[i]', 'r', 'normalized', ['i', 'k'], 1728), ('[i]', 'r', 'normalized', ['i', 'k'], 1730)]
LDEs formed:0

rates -> [('[i]', 'r', 'normalized', ['i', 'k'], 1725), ('[i]', 'r', 'normalized', ['i', 'k'], 1729), ('[i]', 'r', 'normalized', ['i', 'k'], 1731), ('[i]', 'r', 'normalized', ['i', 'k'], 1732)]
LDEs formed:0

cashflows -> [('[2*k]', 'r', 'normalized', ['i', 'k'], 1726), ('[2*k+1]', 'r', 'normalized', ['i', 'k'], 1727)]
LDEs formed:0

notionals -> [('[k]', 'r', 'normalized', ['i', 'k'], 1731)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/cashflows.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/daycounters.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<n  i++
induction variable: ['i']
{
L1732: (testCases[i].convention,r) 
L1733: (testCases[i].start,r) 
L1734: (testCases[i].end,r) 
L1735: (testCases[i].refStart,r) 
L1736: (testCases[i].refEnd,r) 
L1737: (testCases[i].result,r) 
L1738: (testCases[i].convention==,r) 
L1739: (testCases[i].result,r) 
}
array table
-----------------------------------------------
testCases -> [('[i]', 'r', 'normalized', ['i'], 1732), ('[i]', 'r', 'normalized', ['i'], 1733), ('[i]', 'r', 'normalized', ['i'], 1734), ('[i]', 'r', 'normalized', ['i'], 1735), ('[i]', 'r', 'normalized', ['i'], 1736), ('[i]', 'r', 'normalized', ['i'], 1737), ('[i]', 'r', 'normalized', ['i'], 1738), ('[i]', 'r', 'normalized', ['i'], 1739)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Date start = first  start <= last  start++
induction variable: ['start']
{
	loop info: Size i=0  i<n  i++
	induction variable: ['start', 'i']
	{
	L1740: (p[i],r) 
	L1741: (expected[i],r) 
	L1742: (expected[i],r) 
	}
 }
array table
-----------------------------------------------
expected -> [('[i]', 'r', 'normalized', ['start', 'i'], 1741), ('[i]', 'r', 'normalized', ['start', 'i'], 1742)]
LDEs formed:0

p -> [('[i]', 'r', 'normalized', ['start', 'i'], 1740)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Date start = first  start <= last  start++
induction variable: ['start']
{
	loop info: Size i=0  i<n  i++
	induction variable: ['start', 'i']
	{
	L1741: (p[i],r) 
	L1742: (expected[i],r) 
	L1743: (expected[i],r) 
	}
 }
array table
-----------------------------------------------
expected -> [('[i]', 'r', 'normalized', ['start', 'i'], 1742), ('[i]', 'r', 'normalized', ['start', 'i'], 1743)]
LDEs formed:0

p -> [('[i]', 'r', 'normalized', ['start', 'i'], 1741)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=1  i<testDates.size()  i++
induction variable: ['i']
{
L1742: (testDates[i-1],r) (testDates[i],r) 
L1743: (expected[i-1],r) 
L1744: (testDates[i-1],r) 
L1745: (testDates[i]<<,r) 
L1746: (expected[i-1],r) 
}
array table
-----------------------------------------------
expected -> [('[i-1]', 'r', 'normalized', ['i'], 1743), ('[i-1]', 'r', 'normalized', ['i'], 1746)]
LDEs formed:0

testDates -> [('[i-1]', 'r', 'normalized', ['i'], 1742), ('[i]', 'r', 'normalized', ['i'], 1742), ('[i-1]', 'r', 'normalized', ['i'], 1744), ('[i]', 'r', 'normalized', ['i'], 1745)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=1  i<testDates.size()  i++
induction variable: ['i']
{
L1746: (testDates[i-1],r) (testDates[i],r) 
L1747: (expected[i-1],r) 
L1748: (testDates[i-1],r) 
L1749: (testDates[i]<<,r) 
L1750: (expected[i-1],r) 
}
array table
-----------------------------------------------
expected -> [('[i-1]', 'r', 'normalized', ['i'], 1747), ('[i-1]', 'r', 'normalized', ['i'], 1750)]
LDEs formed:0

testDates -> [('[i-1]', 'r', 'normalized', ['i'], 1746), ('[i]', 'r', 'normalized', ['i'], 1746), ('[i-1]', 'r', 'normalized', ['i'], 1748), ('[i]', 'r', 'normalized', ['i'], 1749)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i = 0  i < testStartDates.size()  i++
induction variable: ['i']
{
L1750: (testStartDates[i],r) (testEndDates[i],r) 
L1751: (expected[i],r) 
L1752: (testStartDates[i],r) 
L1753: (testEndDates[i]<<,r) 
L1754: (expected[i],r) 
}
array table
-----------------------------------------------
expected -> [('[i]', 'r', 'normalized', ['i'], 1751), ('[i]', 'r', 'normalized', ['i'], 1754)]
LDEs formed:0

testStartDates -> [('[i]', 'r', 'normalized', ['i'], 1750), ('[i]', 'r', 'normalized', ['i'], 1752)]
LDEs formed:0

testEndDates -> [('[i]', 'r', 'normalized', ['i'], 1750), ('[i]', 'r', 'normalized', ['i'], 1753)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i = 0  i < testStartDates.size()  i++
induction variable: ['i']
{
L1754: (testStartDates[i],r) (testEndDates[i],r) 
L1755: (expected[i],r) 
L1756: (testStartDates[i],r) 
L1757: (testEndDates[i]<<,r) 
L1758: (expected[i],r) 
}
array table
-----------------------------------------------
expected -> [('[i]', 'r', 'normalized', ['i'], 1755), ('[i]', 'r', 'normalized', ['i'], 1758)]
LDEs formed:0

testStartDates -> [('[i]', 'r', 'normalized', ['i'], 1754), ('[i]', 'r', 'normalized', ['i'], 1756)]
LDEs formed:0

testEndDates -> [('[i]', 'r', 'normalized', ['i'], 1754), ('[i]', 'r', 'normalized', ['i'], 1757)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/piecewiseyieldcurve.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<deposits  i++
induction variable: ['i']
{
L1758: (rates[i]=,w) 
L1759: (depositData[i].rate/,r) 
}
array table
-----------------------------------------------
depositData -> [('[i]', 'r', 'normalized', ['i'], 1759)]
LDEs formed:0

rates -> [('[i]', 'w', 'normalized', ['i'], 1758)]
LDEs formed:1

distinct LDEs:
i1=i2
#########################################################################################
loop info: Size i=0  i<swaps  i++
induction variable: ['i']
{
L1759: (rates[i+deposits]=,w) 
L1760: (swapData[i].rate/,r) 
}
array table
-----------------------------------------------
swapData -> [('[i]', 'r', 'normalized', ['i'], 1760)]
LDEs formed:0

rates -> [('[i+deposits]', 'w', 'not normalized', ['i'], 1759)]
LDEs formed:1

distinct LDEs:
i1+deposits=i2+deposits
#########################################################################################
loop info: Size i=0  i<fras  i++
induction variable: ['i']
{
L1760: (fraRates[i]=,w) 
L1761: (fraData[i].rate/,r) 
}
array table
-----------------------------------------------
fraRates -> [('[i]', 'w', 'normalized', ['i'], 1760)]
LDEs formed:1

fraData -> [('[i]', 'r', 'normalized', ['i'], 1761)]
LDEs formed:0

distinct LDEs:
i1=i2
#########################################################################################
loop info: Size i = 0  i<bonds  i++
induction variable: ['i']
{
L1762: (prices[i]=,w) 
L1763: (bondData[i].price,r) 
}
array table
-----------------------------------------------
prices -> [('[i]', 'w', 'normalized', ['i'], 1762)]
LDEs formed:1

bondData -> [('[i]', 'r', 'normalized', ['i'], 1763)]
LDEs formed:0

distinct LDEs:
i1=i2
#########################################################################################
loop info: Size i = 0  i<immFuts  i++
induction variable: ['i']
{
L1764: (immFutPrices[i]=,w) 
L1765: (immFutData[i].rate,r) 
}
array table
-----------------------------------------------
immFutPrices -> [('[i]', 'w', 'normalized', ['i'], 1764)]
LDEs formed:1

immFutData -> [('[i]', 'r', 'normalized', ['i'], 1765)]
LDEs formed:0

distinct LDEs:
i1=i2
#########################################################################################
loop info: Size i = 0  i<asxFuts  i++
induction variable: ['i']
{
L1766: (asxFutPrices[i]=,w) 
L1767: (asxFutData[i].rate,r) 
}
array table
-----------------------------------------------
asxFutPrices -> [('[i]', 'w', 'normalized', ['i'], 1766)]
LDEs formed:1

asxFutData -> [('[i]', 'r', 'normalized', ['i'], 1767)]
LDEs formed:0

distinct LDEs:
i1=i2
#########################################################################################
loop info: Size i = 0  i<bmas  i++
induction variable: ['i']
{
L1768: (fractions[i]=,w) 
L1769: (bmaData[i].rate/,r) 
}
array table
-----------------------------------------------
fractions -> [('[i]', 'w', 'normalized', ['i'], 1768)]
LDEs formed:1

bmaData -> [('[i]', 'r', 'normalized', ['i'], 1769)]
LDEs formed:0

distinct LDEs:
i1=i2
#########################################################################################
loop info: Size i=0  i<deposits  i++
induction variable: ['i']
{
L1770: (rates[i],r) 
L1771: (instruments[i]=,w) 
L1772: (depositData[i].n*,r) (depositData[i].units,r) 
}
array table
-----------------------------------------------
instruments -> [('[i]', 'w', 'normalized', ['i'], 1771)]
LDEs formed:1

rates -> [('[i]', 'r', 'normalized', ['i'], 1770)]
LDEs formed:0

depositData -> [('[i]', 'r', 'normalized', ['i'], 1772), ('[i]', 'r', 'normalized', ['i'], 1772)]
LDEs formed:0

distinct LDEs:
i1=i2
#########################################################################################
loop info: Size i=0  i<swaps  i++
induction variable: ['i']
{
L1773: (rates[i+deposits],r) 
L1774: (instruments[i+deposits]=,w) 
L1775: (swapData[i].n*,r) (swapData[i].units,r) 
}
array table
-----------------------------------------------
instruments -> [('[i+deposits]', 'w', 'not normalized', ['i'], 1774)]
LDEs formed:1

rates -> [('[i+deposits]', 'r', 'not normalized', ['i'], 1773)]
LDEs formed:0

swapData -> [('[i]', 'r', 'normalized', ['i'], 1775), ('[i]', 'r', 'normalized', ['i'], 1775)]
LDEs formed:0

distinct LDEs:
i1+deposits=i2+deposits
#########################################################################################
loop info: Size i=0  i<fras  i++
induction variable: ['i']
{
L1776: (fraRates[i],r) 
L1777: (fraHelpers[i]=,w) 
L1778: (fraData[i].n,r) (fraData[i].n+,r) 
}
array table
-----------------------------------------------
fraRates -> [('[i]', 'r', 'normalized', ['i'], 1776)]
LDEs formed:0

fraData -> [('[i]', 'r', 'normalized', ['i'], 1778), ('[i]', 'r', 'normalized', ['i'], 1778)]
LDEs formed:0

fraHelpers -> [('[i]', 'w', 'normalized', ['i'], 1777)]
LDEs formed:1

distinct LDEs:
i1=i2
#########################################################################################
loop info: Size i = 0  i<immFuts  i++
induction variable: ['i']
{
L1778: (immFutPrices[i],r) 
L1779: (immFutHelpers[i]=,w) 
}
array table
-----------------------------------------------
immFutPrices -> [('[i]', 'r', 'normalized', ['i'], 1778)]
LDEs formed:0

immFutHelpers -> [('[i]', 'w', 'normalized', ['i'], 1779)]
LDEs formed:1

distinct LDEs:
i1=i2
#########################################################################################
loop info: Size i = 0  i<asxFuts  i++
induction variable: ['i']
{
L1780: (asxFutPrices[i],r) 
L1781: (asxFutHelpers[i]=,w) 
}
array table
-----------------------------------------------
asxFutHelpers -> [('[i]', 'w', 'normalized', ['i'], 1781)]
LDEs formed:1

asxFutPrices -> [('[i]', 'r', 'normalized', ['i'], 1780)]
LDEs formed:0

distinct LDEs:
i1=i2
#########################################################################################
loop info: Size i=0  i<bonds  i++
induction variable: ['i']
{
L1781: (prices[i],r) 
L1782: (bondData[i].n,r) (bondData[i].units,r) 
L1783: (bondData[i].length,r) 
L1784: (bondData[i].coupon/,r) 
L1785: (schedules[i]=,w) 
L1786: (bondData[i].frequency,r) 
L1787: (bondHelpers[i]=,w) 
L1788: (schedules[i],r) 
}
array table
-----------------------------------------------
prices -> [('[i]', 'r', 'normalized', ['i'], 1781)]
LDEs formed:0

bondHelpers -> [('[i]', 'w', 'normalized', ['i'], 1787)]
LDEs formed:1

bondData -> [('[i]', 'r', 'normalized', ['i'], 1782), ('[i]', 'r', 'normalized', ['i'], 1782), ('[i]', 'r', 'normalized', ['i'], 1783), ('[i]', 'r', 'normalized', ['i'], 1784), ('[i]', 'r', 'normalized', ['i'], 1786)]
LDEs formed:0

schedules -> [('[i]', 'w', 'normalized', ['i'], 1785), ('[i]', 'r', 'normalized', ['i'], 1788)]
LDEs formed:2

distinct LDEs:
i1=i2
#########################################################################################
loop info: Size i=0  i<vars.deposits  i++
induction variable: ['i']
{
L1789: (depositData[i].n*,r) (depositData[i].units,r) 
L1790: (depositData[i].rate/,r) 
L1791: (depositData[i].n<<,r) 
L1792: (depositData[i].units==,r) 
}
array table
-----------------------------------------------
depositData -> [('[i]', 'r', 'normalized', ['i'], 1789), ('[i]', 'r', 'normalized', ['i'], 1789), ('[i]', 'r', 'normalized', ['i'], 1790), ('[i]', 'r', 'normalized', ['i'], 1791), ('[i]', 'r', 'normalized', ['i'], 1792)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<vars.swaps  i++
induction variable: ['i']
{
L1793: (swapData[i].n*,r) (swapData[i].units,r) 
L1794: (swapData[i].rate/,r) 
L1795: (swapData[i].n<<,r) 
}
array table
-----------------------------------------------
swapData -> [('[i]', 'r', 'normalized', ['i'], 1793), ('[i]', 'r', 'normalized', ['i'], 1793), ('[i]', 'r', 'normalized', ['i'], 1794), ('[i]', 'r', 'normalized', ['i'], 1795)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<vars.bonds  i++
induction variable: ['i']
{
L1796: (bondData[i].n,r) 
L1797: (bondData[i].units,r) 
L1798: (bondData[i].length,r) 
L1799: (bondData[i].coupon/,r) 
L1800: (vars.schedules[i],r) 
L1801: (bondData[i].price,r) 
}
array table
-----------------------------------------------
vars.schedules -> [('[i]', 'r', 'normalized', ['i'], 1800)]
LDEs formed:0

bondData -> [('[i]', 'r', 'normalized', ['i'], 1796), ('[i]', 'r', 'normalized', ['i'], 1797), ('[i]', 'r', 'normalized', ['i'], 1798), ('[i]', 'r', 'normalized', ['i'], 1799), ('[i]', 'r', 'normalized', ['i'], 1801)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<vars.fras  i++
induction variable: ['i']
{
L1802: (fraData[i].n,r) 
L1803: (fraData[i].units,r) 
L1804: (fraData[i].rate/,r) 
L1805: (fraData[i].rate/,r) 
}
array table
-----------------------------------------------
fraData -> [('[i]', 'r', 'normalized', ['i'], 1802), ('[i]', 'r', 'normalized', ['i'], 1803), ('[i]', 'r', 'normalized', ['i'], 1804), ('[i]', 'r', 'normalized', ['i'], 1805)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i = 0  i<vars.immFuts  i++
induction variable: ['i']
{
L1806: (immFutData[i].rate/,r) 
L1807: (immFutData[i].rate/,r) 
}
array table
-----------------------------------------------
immFutData -> [('[i]', 'r', 'normalized', ['i'], 1806), ('[i]', 'r', 'normalized', ['i'], 1807)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i = 0  i<vars.asxFuts  i++
induction variable: ['i']
{
L1808: (asxFutData[i].rate/,r) 
L1809: (asxFutData[i].rate/,r) 
}
array table
-----------------------------------------------
asxFutData -> [('[i]', 'r', 'normalized', ['i'], 1808), ('[i]', 'r', 'normalized', ['i'], 1809)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<vars.bmas  ++i
induction variable: ['i']
{
L1810: (vars.fractions[i],r) 
L1811: (vars.bmaHelpers[i]=,w) 
L1812: (bmaData[i].n*,r) (bmaData[i].units,r) 
}
array table
-----------------------------------------------
bmaData -> [('[i]', 'r', 'normalized', ['i'], 1812), ('[i]', 'r', 'normalized', ['i'], 1812)]
LDEs formed:0

vars.bmaHelpers -> [('[i]', 'w', 'normalized', ['i'], 1811)]
LDEs formed:1

vars.fractions -> [('[i]', 'r', 'normalized', ['i'], 1810)]
LDEs formed:0

distinct LDEs:
i1=i2
#########################################################################################
loop info: Size i=0  i<vars.bmas  i++
induction variable: ['i']
{
L1811: (bmaData[i].n*,r) (bmaData[i].units,r) 
L1812: (bmaData[i].rate/,r) 
L1813: (bmaData[i].n<<,r) 
}
array table
-----------------------------------------------
bmaData -> [('[i]', 'r', 'normalized', ['i'], 1811), ('[i]', 'r', 'normalized', ['i'], 1811), ('[i]', 'r', 'normalized', ['i'], 1812), ('[i]', 'r', 'normalized', ['i'], 1813)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<vars.deposits+vars.swaps  i++
induction variable: ['i']
{
L1814: (vars.instruments[i]-,r) 
L1815: (vars.rates[i]-,r) (vars.rates[i]-,r) 
L1816: (vars.rates[i]-,r) (vars.rates[i]-,r) 
}
array table
-----------------------------------------------
vars.instruments -> [('[i]', 'r', 'normalized', ['i'], 1814)]
LDEs formed:0

vars.rates -> [('[i]', 'r', 'normalized', ['i'], 1815), ('[i]', 'r', 'normalized', ['i'], 1815), ('[i]', 'r', 'normalized', ['i'], 1816), ('[i]', 'r', 'normalized', ['i'], 1816)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<vars.swaps  i++
induction variable: ['i']
{
L1817: (vars.rates[i+vars.deposits],r) 
L1818: (swapHelpers[i]=,w) 
L1819: (swapData[i].n,r) (swapData[i].units,r) 
}
array table
-----------------------------------------------
swapData -> [('[i]', 'r', 'normalized', ['i'], 1819), ('[i]', 'r', 'normalized', ['i'], 1819)]
LDEs formed:0

vars.rates -> [('[i+vars.deposits]', 'r', 'not normalized', ['i'], 1817)]
LDEs formed:0

swapHelpers -> [('[i]', 'w', 'normalized', ['i'], 1818)]
LDEs formed:1

distinct LDEs:
i1=i2
#########################################################################################
loop info: Size i=0  i<vars.swaps  i++
induction variable: ['i']
{
L1819: (swapData[i].n*,r) (swapData[i].units,r) 
L1820: (swapData[i].rate/,r) 
L1821: (swapData[i].n<<,r) 
}
array table
-----------------------------------------------
swapData -> [('[i]', 'r', 'normalized', ['i'], 1819), ('[i]', 'r', 'normalized', ['i'], 1819), ('[i]', 'r', 'normalized', ['i'], 1820), ('[i]', 'r', 'normalized', ['i'], 1821)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<vars.swaps  i++
induction variable: ['i']
{
L1822: (swapData[i].n*,r) (swapData[i].units,r) 
L1823: (swapData[i].rate/,r) 
L1824: (swapData[i].n<<,r) 
}
array table
-----------------------------------------------
swapData -> [('[i]', 'r', 'normalized', ['i'], 1822), ('[i]', 'r', 'normalized', ['i'], 1822), ('[i]', 'r', 'normalized', ['i'], 1823), ('[i]', 'r', 'normalized', ['i'], 1824)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<vars.swaps  i++
induction variable: ['i']
{
L1825: (vars.rates[i]=,w) 
L1826: (swapData[i].rate/,r) 
}
array table
-----------------------------------------------
swapData -> [('[i]', 'r', 'normalized', ['i'], 1826)]
LDEs formed:0

vars.rates -> [('[i]', 'w', 'normalized', ['i'], 1825)]
LDEs formed:1

distinct LDEs:
i1=i2
#########################################################################################
loop info: Size i=0  i<vars.swaps  i++
induction variable: ['i']
{
L1826: (vars.rates[i],r) 
L1827: (vars.instruments[i]=,w) 
L1828: (swapData[i].n*,r) (swapData[i].units,r) 
}
array table
-----------------------------------------------
swapData -> [('[i]', 'r', 'normalized', ['i'], 1828), ('[i]', 'r', 'normalized', ['i'], 1828)]
LDEs formed:0

vars.instruments -> [('[i]', 'w', 'normalized', ['i'], 1827)]
LDEs formed:1

vars.rates -> [('[i]', 'r', 'normalized', ['i'], 1826)]
LDEs formed:0

distinct LDEs:
i1=i2
#########################################################################################
loop info: Size i=0  i<vars.swaps  i++
induction variable: ['i']
{
L1827: (swapData[i].n*,r) (swapData[i].units,r) 
L1828: (swapData[i].rate/,r) 
L1829: (swapData[i].n<<,r) 
}
array table
-----------------------------------------------
swapData -> [('[i]', 'r', 'normalized', ['i'], 1827), ('[i]', 'r', 'normalized', ['i'], 1827), ('[i]', 'r', 'normalized', ['i'], 1828), ('[i]', 'r', 'normalized', ['i'], 1829)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<vars.rates.size()  ++i
induction variable: ['i']
{
L1830: (vars.rates[i]-,r) (vars.rates[i]-,r) 
}
array table
-----------------------------------------------
vars.rates -> [('[i]', 'r', 'normalized', ['i'], 1830), ('[i]', 'r', 'normalized', ['i'], 1830)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/interpolations.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<LENGTH(points)  i++
induction variable: ['i']
{
L1831: (points[i],r) 
L1832: (tabulatedErrors[i],r) (toleranceOnTabErr[i],r) 
L1833: (tabulatedErrors[i],r) 
L1834: (tabulatedMCErrors[i],r) (toleranceOnTabMCErr[i],r) 
L1835: (tabulatedMCErrors[i],r) 
}
array table
-----------------------------------------------
tabulatedErrors -> [('[i]', 'r', 'normalized', ['i'], 1832), ('[i]', 'r', 'normalized', ['i'], 1833)]
LDEs formed:0

toleranceOnTabErr -> [('[i]', 'r', 'normalized', ['i'], 1832)]
LDEs formed:0

points -> [('[i]', 'r', 'normalized', ['i'], 1831)]
LDEs formed:0

tabulatedMCErrors -> [('[i]', 'r', 'normalized', ['i'], 1834), ('[i]', 'r', 'normalized', ['i'], 1835)]
LDEs formed:0

toleranceOnTabMCErr -> [('[i]', 'r', 'normalized', ['i'], 1834)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: i=0  i<n  i++
induction variable: ['i']
{
L1835: (generic_x[i],r) 
L1836: (generic_natural_y2[i],r) 
L1837: (generic_x[i],r) 
L1838: (generic_natural_y2[i],r) 
}
array table
-----------------------------------------------
generic_natural_y2 -> [('[i]', 'r', 'normalized', ['i'], 1836), ('[i]', 'r', 'normalized', ['i'], 1838)]
LDEs formed:0

generic_x -> [('[i]', 'r', 'normalized', ['i'], 1835), ('[i]', 'r', 'normalized', ['i'], 1837)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: i = 0  i < 5  ++i
induction variable: ['i']
{
L1838: (offsets[i],r) 
	loop info: j = 0  j < dim[i]  temp += r, ++j
	induction variable: ['i', 'temp', 'j']
	{
	}
 }
array table
-----------------------------------------------
offsets -> [('[i]', 'r', 'normalized', ['i', 'temp', 'j'], 1838)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: i = 0  i < dim[0]  ++i
induction variable: ['i']
{
	loop info: i = 1  i < dim[0]-1  ++i
	induction variable: ['i']
	{
	L1839: (grid[0][i],r) 
	L1840: (grid[1][j],r) 
	L1841: (grid[2][k],r) 
	L1842: (grid[3][l],r) 
	L1843: (grid[4][m],r) 
	L1844: (y5[i][j][k][l][m],r) 
	}
	loop info: i = 0  i < 1023  ++i
	induction variable: ['i']
	{
	L1845: (grid[0].front,r) (next[0]*,r) (grid[0].back,r) (grid[0].front,r) 
	L1846: (grid[1].front,r) (next[1]*,r) (grid[1].back,r) (grid[1].front,r) 
	L1847: (grid[2].front,r) (next[2]*,r) (grid[2].back,r) (grid[2].front,r) 
	L1848: (grid[3].front,r) (next[3]*,r) (grid[3].back,r) (grid[3].front,r) 
	L1849: (grid[4].front,r) (next[4]*,r) (grid[4].back,r) (grid[4].front,r) 
	}
 }
array table
-----------------------------------------------
y5 -> [('[i][j][k][l][m]', 'r', 'not normalized', ['i'], 1844)]
LDEs formed:0

grid -> [('[0][i]', 'r', 'normalized', ['i'], 1839), ('[1][j]', 'r', 'not normalized', ['i'], 1840), ('[2][k]', 'r', 'not normalized', ['i'], 1841), ('[3][l]', 'r', 'not normalized', ['i'], 1842), ('[4][m]', 'r', 'not normalized', ['i'], 1843), ('[0]', 'r', 'normalized', ['i'], 1845), ('[0]', 'r', 'normalized', ['i'], 1845), ('[0]', 'r', 'normalized', ['i'], 1845), ('[1]', 'r', 'normalized', ['i'], 1846), ('[1]', 'r', 'normalized', ['i'], 1846), ('[1]', 'r', 'normalized', ['i'], 1846), ('[2]', 'r', 'normalized', ['i'], 1847), ('[2]', 'r', 'normalized', ['i'], 1847), ('[2]', 'r', 'normalized', ['i'], 1847), ('[3]', 'r', 'normalized', ['i'], 1848), ('[3]', 'r', 'normalized', ['i'], 1848), ('[3]', 'r', 'normalized', ['i'], 1848), ('[4]', 'r', 'normalized', ['i'], 1849), ('[4]', 'r', 'normalized', ['i'], 1849), ('[4]', 'r', 'normalized', ['i'], 1849)]
LDEs formed:0

next -> [('[0]', 'r', 'normalized', ['i'], 1845), ('[1]', 'r', 'normalized', ['i'], 1846), ('[2]', 'r', 'normalized', ['i'], 1847), ('[3]', 'r', 'normalized', ['i'], 1848), ('[4]', 'r', 'normalized', ['i'], 1849)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<N  i++
induction variable: ['i']
{
L1850: (x2[i],r) 
L1851: (y2[i]-,r) 
L1852: (y2[i],r) 
L1853: (y2[i]-,r) 
}
array table
-----------------------------------------------
x2 -> [('[i]', 'r', 'normalized', ['i'], 1850)]
LDEs formed:0

y2 -> [('[i]', 'r', 'normalized', ['i'], 1851), ('[i]', 'r', 'normalized', ['i'], 1852), ('[i]', 'r', 'normalized', ['i'], 1853)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: i=0  i<N  i++
induction variable: ['i']
{
L1854: (x[i],r) 
L1855: (y[i],r) 
}
array table
-----------------------------------------------
y -> [('[i]', 'r', 'normalized', ['i'], 1855)]
LDEs formed:0

x -> [('[i]', 'r', 'normalized', ['i'], 1854)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: i=0  i<N-1  i++
induction variable: ['i']
{
L1855: (x[i]+,r) (x[i+1],r) 
L1856: (y[i+1],r) 
}
array table
-----------------------------------------------
y -> [('[i+1]', 'r', 'normalized', ['i'], 1856)]
LDEs formed:0

x -> [('[i]', 'r', 'normalized', ['i'], 1855), ('[i+1]', 'r', 'normalized', ['i'], 1855)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: i=1  i<N  i++
induction variable: ['i']
{
L1856: (x[i]-,r) (x[i-1],r) (y[i],r) 
L1857: (x[i],r) 
L1858: (x[i],r) 
}
array table
-----------------------------------------------
y -> [('[i]', 'r', 'normalized', ['i'], 1856)]
LDEs formed:0

x -> [('[i]', 'r', 'normalized', ['i'], 1856), ('[i-1]', 'r', 'normalized', ['i'], 1856), ('[i]', 'r', 'normalized', ['i'], 1857), ('[i]', 'r', 'normalized', ['i'], 1858)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: i=0  i<N-1  i++
induction variable: ['i']
{
L1859: (x[i]+,r) (x[i+1],r) 
L1860: (x[i+1]-,r) (x[i],r) (y[i+1]/,r) 
L1861: (x[i+1]-,r) (x[i],r) (y[i+1]/,r) 
L1862: (x[i],r) 
}
array table
-----------------------------------------------
y -> [('[i+1]', 'r', 'normalized', ['i'], 1860), ('[i+1]', 'r', 'normalized', ['i'], 1861)]
LDEs formed:0

x -> [('[i]', 'r', 'normalized', ['i'], 1859), ('[i+1]', 'r', 'normalized', ['i'], 1859), ('[i+1]', 'r', 'normalized', ['i'], 1860), ('[i]', 'r', 'normalized', ['i'], 1860), ('[i+1]', 'r', 'normalized', ['i'], 1861), ('[i]', 'r', 'normalized', ['i'], 1861), ('[i]', 'r', 'normalized', ['i'], 1862)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: i=0  i<N  i++
induction variable: ['i']
{
L1863: (x[i],r) 
L1864: (y[i],r) 
}
array table
-----------------------------------------------
y -> [('[i]', 'r', 'normalized', ['i'], 1864)]
LDEs formed:0

x -> [('[i]', 'r', 'normalized', ['i'], 1863)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: i=0  i<N-1  i++
induction variable: ['i']
{
L1864: (x[i]+,r) (x[i+1],r) 
L1865: (y[i],r) 
}
array table
-----------------------------------------------
y -> [('[i]', 'r', 'normalized', ['i'], 1865)]
LDEs formed:0

x -> [('[i]', 'r', 'normalized', ['i'], 1864), ('[i+1]', 'r', 'normalized', ['i'], 1864)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: i=1  i<N  i++
induction variable: ['i']
{
L1865: (x[i]-,r) (x[i-1],r) (y[i-1],r) 
L1866: (x[i],r) 
L1867: (x[i],r) 
}
array table
-----------------------------------------------
y -> [('[i-1]', 'r', 'normalized', ['i'], 1865)]
LDEs formed:0

x -> [('[i]', 'r', 'normalized', ['i'], 1865), ('[i-1]', 'r', 'normalized', ['i'], 1865), ('[i]', 'r', 'normalized', ['i'], 1866), ('[i]', 'r', 'normalized', ['i'], 1867)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: i=0  i<N-1  i++
induction variable: ['i']
{
L1868: (x[i]+,r) (x[i+1],r) 
L1869: (x[i+1]-,r) (x[i],r) (y[i]/,r) 
L1870: (x[i+1]-,r) (x[i],r) (y[i]/,r) 
}
array table
-----------------------------------------------
y -> [('[i]', 'r', 'normalized', ['i'], 1869), ('[i]', 'r', 'normalized', ['i'], 1870)]
LDEs formed:0

x -> [('[i]', 'r', 'normalized', ['i'], 1868), ('[i+1]', 'r', 'normalized', ['i'], 1868), ('[i+1]', 'r', 'normalized', ['i'], 1869), ('[i]', 'r', 'normalized', ['i'], 1869), ('[i+1]', 'r', 'normalized', ['i'], 1870), ('[i]', 'r', 'normalized', ['i'], 1870)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i< strikes.size()  i++
induction variable: ['i']
{
L1871: (strikes[i],r) 
L1872: (volatilities[i]-,r) 
L1873: (strikes[i],r) 
L1874: (volatilities[i],r) 
L1875: (volatilities[i],r) 
}
array table
-----------------------------------------------
volatilities -> [('[i]', 'r', 'normalized', ['i'], 1872), ('[i]', 'r', 'normalized', ['i'], 1874), ('[i]', 'r', 'normalized', ['i'], 1875)]
LDEs formed:0

strikes -> [('[i]', 'r', 'normalized', ['i'], 1871), ('[i]', 'r', 'normalized', ['i'], 1873)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size j=0  j<methods_.size()  ++j
induction variable: ['j']
{
	loop info: Size i=0  i<LENGTH(vegaWeighted)  ++i
	induction variable: ['j', 'i']
	{
		loop info: Size k_a=0  k_a<LENGTH(isAlphaFixed)  ++k_a
		induction variable: ['j', 'i', 'k_a']
		{
			loop info: Size k_b=0  k_b<LENGTH(isBetaFixed)  ++k_b
			induction variable: ['j', 'i', 'k_a', 'k_b']
			{
				loop info: Size k_n=0  k_n<LENGTH(isNuFixed)  ++k_n
				induction variable: ['j', 'i', 'k_a', 'k_b', 'k_n']
				{
					loop info: Size k_r=0  k_r<LENGTH(isRhoFixed)  ++k_r
					induction variable: ['j', 'i', 'k_a', 'k_b', 'k_n', 'k_r']
					{
					L1874: (isAlphaFixed[k_a],r) 
					L1875: (isBetaFixed[k_b],r) 
					L1876: (isNuFixed[k_n],r) 
					L1877: (isRhoFixed[k_r],r) (isAlphaFixed[k_a],r) 
					L1878: (isBetaFixed[k_b],r) (isNuFixed[k_n],r) (isRhoFixed[k_r],r) 
					L1879: (vegaWeighted[i],r) (methods_[j],r) 
					L1880: (isAlphaFixed[k_a]<<,r) 
					L1881: (isBetaFixed[k_b]<<,r) 
					L1882: (isNuFixed[k_n]<<,r) 
					L1883: (isRhoFixed[k_r]<<,r) 
					L1884: (vegaWeighted[i],r) (vegaWeighted[i],r) 
					}
 				}
 			}
 		}
 	}
 }
array table
-----------------------------------------------
isNuFixed -> [('[k_n]', 'r', 'normalized', ['j', 'i', 'k_a', 'k_b', 'k_n', 'k_r'], 1876), ('[k_n]', 'r', 'normalized', ['j', 'i', 'k_a', 'k_b', 'k_n', 'k_r'], 1878), ('[k_n]', 'r', 'normalized', ['j', 'i', 'k_a', 'k_b', 'k_n', 'k_r'], 1882)]
LDEs formed:0

isRhoFixed -> [('[k_r]', 'r', 'normalized', ['j', 'i', 'k_a', 'k_b', 'k_n', 'k_r'], 1877), ('[k_r]', 'r', 'normalized', ['j', 'i', 'k_a', 'k_b', 'k_n', 'k_r'], 1878), ('[k_r]', 'r', 'normalized', ['j', 'i', 'k_a', 'k_b', 'k_n', 'k_r'], 1883)]
LDEs formed:0

isAlphaFixed -> [('[k_a]', 'r', 'normalized', ['j', 'i', 'k_a', 'k_b', 'k_n', 'k_r'], 1874), ('[k_a]', 'r', 'normalized', ['j', 'i', 'k_a', 'k_b', 'k_n', 'k_r'], 1877), ('[k_a]', 'r', 'normalized', ['j', 'i', 'k_a', 'k_b', 'k_n', 'k_r'], 1880)]
LDEs formed:0

methods_ -> [('[j]', 'r', 'normalized', ['j', 'i', 'k_a', 'k_b', 'k_n', 'k_r'], 1879)]
LDEs formed:0

isBetaFixed -> [('[k_b]', 'r', 'normalized', ['j', 'i', 'k_a', 'k_b', 'k_n', 'k_r'], 1875), ('[k_b]', 'r', 'normalized', ['j', 'i', 'k_a', 'k_b', 'k_n', 'k_r'], 1878), ('[k_b]', 'r', 'normalized', ['j', 'i', 'k_a', 'k_b', 'k_n', 'k_r'], 1881)]
LDEs formed:0

vegaWeighted -> [('[i]', 'r', 'normalized', ['j', 'i', 'k_a', 'k_b', 'k_n', 'k_r'], 1879), ('[i]', 'r', 'normalized', ['j', 'i', 'k_a', 'k_b', 'k_n', 'k_r'], 1884), ('[i]', 'r', 'normalized', ['j', 'i', 'k_a', 'k_b', 'k_n', 'k_r'], 1884)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<lambdaVec.size()  ++i
induction variable: ['i']
{
L1885: (lambdaVec[i],r) 
	loop info: Size j=0  j<yd.size()  ++j
	induction variable: ['i', 'j']
	{
	L1886: (yd[j],r) 
		loop info: Size dIt=0  dIt< deltaGrid.size()  ++dIt
		induction variable: ['i', 'j', 'dIt']
		{
		L1887: (currY[dIt],r) 
		L1888: (deltaGrid[dIt],r) 
		L1889: (deltaGrid[dIt],r) 
		}
 	}
 }
array table
-----------------------------------------------
currY -> [('[dIt]', 'r', 'normalized', ['i', 'j', 'dIt'], 1887)]
LDEs formed:0

deltaGrid -> [('[dIt]', 'r', 'normalized', ['i', 'j', 'dIt'], 1888), ('[dIt]', 'r', 'normalized', ['i', 'j', 'dIt'], 1889)]
LDEs formed:0

lambdaVec -> [('[i]', 'r', 'normalized', ['i', 'j', 'dIt'], 1885)]
LDEs formed:0

yd -> [('[j]', 'r', 'normalized', ['i', 'j', 'dIt'], 1886)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size j=0  j< ytd.size()  ++j
induction variable: ['j']
{
L1887: (yd[j],r) 
L1888: (ytd[j],r) 
	loop info: Size dIt=0  dIt< testDeltaGrid.size()  ++dIt
	induction variable: ['j', 'dIt']
	{
	L1889: (currTY[dIt],r) 
	L1890: (testDeltaGrid[dIt],r) 
	L1891: (deltaGrid[dIt],r) 
	}
 }
array table
-----------------------------------------------
deltaGrid -> [('[dIt]', 'r', 'normalized', ['j', 'dIt'], 1891)]
LDEs formed:0

ytd -> [('[j]', 'r', 'normalized', ['j', 'dIt'], 1888)]
LDEs formed:0

currTY -> [('[dIt]', 'r', 'normalized', ['j', 'dIt'], 1889)]
LDEs formed:0

yd -> [('[j]', 'r', 'normalized', ['j', 'dIt'], 1887)]
LDEs formed:0

testDeltaGrid -> [('[dIt]', 'r', 'normalized', ['j', 'dIt'], 1890)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0 i<M.rows() ++i
induction variable: ['i']
{
	loop info: Size j=0 j<M.columns() ++j
	induction variable: ['i', 'j']
	{
	L1891: (xVec[i],r) (yVec[j],r) 
	L1892: (M[i][j],r) 
	L1893: (xVec[i],r) 
	L1894: (yVec[j],r) 
	}
 }
array table
-----------------------------------------------
yVec -> [('[j]', 'r', 'normalized', ['i', 'j'], 1891), ('[j]', 'r', 'normalized', ['i', 'j'], 1894)]
LDEs formed:0

xVec -> [('[i]', 'r', 'normalized', ['i', 'j'], 1891), ('[i]', 'r', 'normalized', ['i', 'j'], 1893)]
LDEs formed:0

M -> [('[i][j]', 'r', 'normalized', ['i', 'j'], 1892)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0 i<M1.rows() ++i
induction variable: ['i']
{
	loop info: Size j=0 j<M1.columns() ++j
	induction variable: ['i', 'j']
	{
	L1893: (xVec1[i],r) (yVec1[j],r) 
	L1894: (M1[i][j],r) 
	L1895: (xVec1[i],r) 
	L1896: (yVec1[j],r) 
	}
 }
array table
-----------------------------------------------
yVec1 -> [('[j]', 'r', 'normalized', ['i', 'j'], 1893), ('[j]', 'r', 'normalized', ['i', 'j'], 1896)]
LDEs formed:0

M1 -> [('[i][j]', 'r', 'normalized', ['i', 'j'], 1894)]
LDEs formed:0

xVec1 -> [('[i]', 'r', 'normalized', ['i', 'j'], 1893), ('[i]', 'r', 'normalized', ['i', 'j'], 1895)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0 i<M1.rows() ++i
induction variable: ['i']
{
	loop info: Size j=0 j<M1.columns() ++j
	induction variable: ['i', 'j']
	{
	L1896: (xVec1[i],r) (yVec1[j],r) 
	L1897: (M1[i][j],r) 
	L1898: (xVec1[i],r) 
	L1899: (yVec1[j],r) 
	}
 }
array table
-----------------------------------------------
yVec1 -> [('[j]', 'r', 'normalized', ['i', 'j'], 1896), ('[j]', 'r', 'normalized', ['i', 'j'], 1899)]
LDEs formed:0

M1 -> [('[i][j]', 'r', 'normalized', ['i', 'j'], 1897)]
LDEs formed:0

xVec1 -> [('[i]', 'r', 'normalized', ['i', 'j'], 1896), ('[i]', 'r', 'normalized', ['i', 'j'], 1898)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i < 100  ++i
induction variable: ['i']
{
L1899: (x[i]=,w) (y[i]=,w) 
}
array table
-----------------------------------------------
y -> [('[i]', 'w', 'normalized', ['i'], 1899)]
LDEs formed:1

x -> [('[i]', 'w', 'normalized', ['i'], 1899)]
LDEs formed:1

distinct LDEs:
i1=i2
#########################################################################################
loop info: Size i=5  i < 95  i+=10
induction variable: ['i']
{
	loop info: Size j=5  j < 95  j+=10
	induction variable: ['i', 'j']
	{
	L1900: (x[j],r) (y[i],r) 
	L1901: (x[j],r) (y[i],r) 
	L1902: (x[j],r) (y[i],r) 
	L1903: (x[j],r) (y[i],r) 
	L1904: (x[j],r) (y[i],r) 
	L1905: (y[i]/,r) (x[j],r) 
	L1906: (y[i]/,r) (x[j],r) 
	L1907: (x[j],r) (y[i],r) 
	L1908: (y[i],r) 
	L1909: (x[j],r) 
	}
 }
array table
-----------------------------------------------
y -> [('[i]', 'r', 'normalized', ['i', 'j'], 1900), ('[i]', 'r', 'normalized', ['i', 'j'], 1901), ('[i]', 'r', 'normalized', ['i', 'j'], 1902), ('[i]', 'r', 'normalized', ['i', 'j'], 1903), ('[i]', 'r', 'normalized', ['i', 'j'], 1904), ('[i]', 'r', 'normalized', ['i', 'j'], 1905), ('[i]', 'r', 'normalized', ['i', 'j'], 1906), ('[i]', 'r', 'normalized', ['i', 'j'], 1907), ('[i]', 'r', 'normalized', ['i', 'j'], 1908)]
LDEs formed:0

x -> [('[j]', 'r', 'normalized', ['i', 'j'], 1900), ('[j]', 'r', 'normalized', ['i', 'j'], 1901), ('[j]', 'r', 'normalized', ['i', 'j'], 1902), ('[j]', 'r', 'normalized', ['i', 'j'], 1903), ('[j]', 'r', 'normalized', ['i', 'j'], 1904), ('[j]', 'r', 'normalized', ['i', 'j'], 1905), ('[j]', 'r', 'normalized', ['i', 'j'], 1906), ('[j]', 'r', 'normalized', ['i', 'j'], 1907), ('[j]', 'r', 'normalized', ['i', 'j'], 1909)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i < N  ++i
induction variable: ['i']
{
L1910: (x[i]=,w) (y[i]=,w) 
}
array table
-----------------------------------------------
y -> [('[i]', 'w', 'normalized', ['i'], 1910)]
LDEs formed:1

x -> [('[i]', 'w', 'normalized', ['i'], 1910)]
LDEs formed:1

distinct LDEs:
i1=i2
#########################################################################################
loop info: Size i = 0  i < strikes.size()  i++
induction variable: ['i']
{
L1911: (strikes[i],r) 
L1912: (volatilities[i]-,r) 
L1913: (strikes[i],r) 
L1914: (volatilities[i],r) 
L1915: (volatilities[i],r) 
}
array table
-----------------------------------------------
volatilities -> [('[i]', 'r', 'normalized', ['i'], 1912), ('[i]', 'r', 'normalized', ['i'], 1914), ('[i]', 'r', 'normalized', ['i'], 1915)]
LDEs formed:0

strikes -> [('[i]', 'r', 'normalized', ['i'], 1911), ('[i]', 'r', 'normalized', ['i'], 1913)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size j=1  j<methods_.size()  ++j
induction variable: ['j']
{
	loop info: Size i=0  i<LENGTH(vegaWeighted)  ++i
	induction variable: ['j', 'i']
	{
		loop info: Size k_a=0  k_a<LENGTH(isAlphaFixed)  ++k_a
		induction variable: ['j', 'i', 'k_a']
		{
			loop info: Size k_b=0  k_b<1/*LENGTH(isBetaFixed)*/  ++k_b
			induction variable: ['j', 'i', 'k_a', 'k_b']
			{
				loop info: Size k_n=0  k_n<LENGTH(isNuFixed)  ++k_n
				induction variable: ['j', 'i', 'k_a', 'k_b', 'k_n']
				{
					loop info: Size k_r=0  k_r<LENGTH(isRhoFixed)  ++k_r
					induction variable: ['j', 'i', 'k_a', 'k_b', 'k_n', 'k_r']
					{
					L1914: (isAlphaFixed[k_a],r) 
					L1915: (isBetaFixed[k_b],r) 
					L1916: (isNuFixed[k_n],r) 
					L1917: (isRhoFixed[k_r],r) 
					L1918: (isAlphaFixed[k_a],r) (isBetaFixed[k_b],r) 
					L1919: (isNuFixed[k_n],r) (isRhoFixed[k_r],r) 
					L1920: (vegaWeighted[i],r) 
					L1921: (methods_[j],r) 
					L1922: (isAlphaFixed[k_a]<<,r) 
					L1923: (isBetaFixed[k_b]<<,r) 
					L1924: (isNuFixed[k_n]<<,r) 
					L1925: (isRhoFixed[k_r]<<,r) 
					L1926: (vegaWeighted[i],r) (vegaWeighted[i],r) 
					}
 				}
 			}
 		}
 	}
 }
array table
-----------------------------------------------
isNuFixed -> [('[k_n]', 'r', 'normalized', ['j', 'i', 'k_a', 'k_b', 'k_n', 'k_r'], 1916), ('[k_n]', 'r', 'normalized', ['j', 'i', 'k_a', 'k_b', 'k_n', 'k_r'], 1919), ('[k_n]', 'r', 'normalized', ['j', 'i', 'k_a', 'k_b', 'k_n', 'k_r'], 1924)]
LDEs formed:0

isRhoFixed -> [('[k_r]', 'r', 'normalized', ['j', 'i', 'k_a', 'k_b', 'k_n', 'k_r'], 1917), ('[k_r]', 'r', 'normalized', ['j', 'i', 'k_a', 'k_b', 'k_n', 'k_r'], 1919), ('[k_r]', 'r', 'normalized', ['j', 'i', 'k_a', 'k_b', 'k_n', 'k_r'], 1925)]
LDEs formed:0

isAlphaFixed -> [('[k_a]', 'r', 'normalized', ['j', 'i', 'k_a', 'k_b', 'k_n', 'k_r'], 1914), ('[k_a]', 'r', 'normalized', ['j', 'i', 'k_a', 'k_b', 'k_n', 'k_r'], 1918), ('[k_a]', 'r', 'normalized', ['j', 'i', 'k_a', 'k_b', 'k_n', 'k_r'], 1922)]
LDEs formed:0

methods_ -> [('[j]', 'r', 'normalized', ['j', 'i', 'k_a', 'k_b', 'k_n', 'k_r'], 1921)]
LDEs formed:0

isBetaFixed -> [('[k_b]', 'r', 'normalized', ['j', 'i', 'k_a', 'k_b', 'k_n', 'k_r'], 1915), ('[k_b]', 'r', 'normalized', ['j', 'i', 'k_a', 'k_b', 'k_n', 'k_r'], 1918), ('[k_b]', 'r', 'normalized', ['j', 'i', 'k_a', 'k_b', 'k_n', 'k_r'], 1923)]
LDEs formed:0

vegaWeighted -> [('[i]', 'r', 'normalized', ['j', 'i', 'k_a', 'k_b', 'k_n', 'k_r'], 1920), ('[i]', 'r', 'normalized', ['j', 'i', 'k_a', 'k_b', 'k_n', 'k_r'], 1926), ('[i]', 'r', 'normalized', ['j', 'i', 'k_a', 'k_b', 'k_n', 'k_r'], 1926)]
LDEs formed:0

distinct LDEs:
#########################################################################################
L1927: (y[0],r) (y[1],r) (y[2],r) (y[3],r) 
L1928: (z[0],r) (y[0],r) (z[1],r) (y[1],r) (z[2],r) (y[2],r) 
L1929: (z[3],r) (y[3],r) 
L1930: (y[0]<<,r) (y[1]<<,r) (y[2]<<,r) (y[3],r) 
L1931: (z[0]<<,r) (z[1]<<,r) (z[2]<<,r) 
L1932: (z[3]<<,r) (z[0]-,r) (y[0]<<,r) 
L1933: (z[1]-,r) (y[1]<<,r) (z[2]-,r) (y[2]<<,r) 
L1934: (z[3]-,r) (y[3]<<,r) 
L1935: (y[0],r) 
L1936: (y[1],r) 
L1937: (y[2],r) 
L1938: (y[3],r) 
L1939: (z[0],r) (y[0],r) (z[1],r) (y[1],r) (z[2],r) (y[2],r) 
L1940: (z[3],r) (y[3],r) 
L1941: (y[0]<<,r) (y[1]<<,r) (y[2]<<,r) (y[3],r) 
L1942: (z[0]<<,r) (z[1]<<,r) (z[2]<<,r) 
L1943: (z[3]<<,r) (z[0]-,r) (y[0]<<,r) 
L1944: (z[1]-,r) (y[1]<<,r) (z[2]-,r) (y[2]<<,r) 
L1945: (z[3]-,r) (y[3]<<,r) 
}
array table
-----------------------------------------------
y -> [('[0]', 'r', 'normalized', ['i', 'j'], 1927), ('[1]', 'r', 'normalized', ['i', 'j'], 1927), ('[2]', 'r', 'normalized', ['i', 'j'], 1927), ('[3]', 'r', 'normalized', ['i', 'j'], 1927), ('[0]', 'r', 'normalized', ['i', 'j'], 1928), ('[1]', 'r', 'normalized', ['i', 'j'], 1928), ('[2]', 'r', 'normalized', ['i', 'j'], 1928), ('[3]', 'r', 'normalized', ['i', 'j'], 1929), ('[0]', 'r', 'normalized', ['i', 'j'], 1930), ('[1]', 'r', 'normalized', ['i', 'j'], 1930), ('[2]', 'r', 'normalized', ['i', 'j'], 1930), ('[3]', 'r', 'normalized', ['i', 'j'], 1930), ('[0]', 'r', 'normalized', ['i', 'j'], 1932), ('[1]', 'r', 'normalized', ['i', 'j'], 1933), ('[2]', 'r', 'normalized', ['i', 'j'], 1933), ('[3]', 'r', 'normalized', ['i', 'j'], 1934), ('[0]', 'r', 'normalized', ['i', 'j'], 1935), ('[1]', 'r', 'normalized', ['i', 'j'], 1936), ('[2]', 'r', 'normalized', ['i', 'j'], 1937), ('[3]', 'r', 'normalized', ['i', 'j'], 1938), ('[0]', 'r', 'normalized', ['i', 'j'], 1939), ('[1]', 'r', 'normalized', ['i', 'j'], 1939), ('[2]', 'r', 'normalized', ['i', 'j'], 1939), ('[3]', 'r', 'normalized', ['i', 'j'], 1940), ('[0]', 'r', 'normalized', ['i', 'j'], 1941), ('[1]', 'r', 'normalized', ['i', 'j'], 1941), ('[2]', 'r', 'normalized', ['i', 'j'], 1941), ('[3]', 'r', 'normalized', ['i', 'j'], 1941), ('[0]', 'r', 'normalized', ['i', 'j'], 1943), ('[1]', 'r', 'normalized', ['i', 'j'], 1944), ('[2]', 'r', 'normalized', ['i', 'j'], 1944), ('[3]', 'r', 'normalized', ['i', 'j'], 1945)]
LDEs formed:0

z -> [('[0]', 'r', 'normalized', ['i', 'j'], 1928), ('[1]', 'r', 'normalized', ['i', 'j'], 1928), ('[2]', 'r', 'normalized', ['i', 'j'], 1928), ('[3]', 'r', 'normalized', ['i', 'j'], 1929), ('[0]', 'r', 'normalized', ['i', 'j'], 1931), ('[1]', 'r', 'normalized', ['i', 'j'], 1931), ('[2]', 'r', 'normalized', ['i', 'j'], 1931), ('[3]', 'r', 'normalized', ['i', 'j'], 1932), ('[0]', 'r', 'normalized', ['i', 'j'], 1932), ('[1]', 'r', 'normalized', ['i', 'j'], 1933), ('[2]', 'r', 'normalized', ['i', 'j'], 1933), ('[3]', 'r', 'normalized', ['i', 'j'], 1934), ('[0]', 'r', 'normalized', ['i', 'j'], 1939), ('[1]', 'r', 'normalized', ['i', 'j'], 1939), ('[2]', 'r', 'normalized', ['i', 'j'], 1939), ('[3]', 'r', 'normalized', ['i', 'j'], 1940), ('[0]', 'r', 'normalized', ['i', 'j'], 1942), ('[1]', 'r', 'normalized', ['i', 'j'], 1942), ('[2]', 'r', 'normalized', ['i', 'j'], 1942), ('[3]', 'r', 'normalized', ['i', 'j'], 1943), ('[0]', 'r', 'normalized', ['i', 'j'], 1943), ('[1]', 'r', 'normalized', ['i', 'j'], 1944), ('[2]', 'r', 'normalized', ['i', 'j'], 1944), ('[3]', 'r', 'normalized', ['i', 'j'], 1945)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/hybridhestonhullwhiteprocess.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i < LENGTH(corr)  ++i
induction variable: ['i']
{
L1946: (corr[i],r) 
L1947: (expectedVol[i],r) 
L1948: (expectedVol[i],r) 
L1949: (expectedVol[i],r) 
}
array table
-----------------------------------------------
expectedVol -> [('[i]', 'r', 'normalized', ['i'], 1947), ('[i]', 'r', 'normalized', ['i'], 1948), ('[i]', 'r', 'normalized', ['i'], 1949)]
LDEs formed:0

corr -> [('[i]', 'r', 'normalized', ['i'], 1946)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i < LENGTH(types)  ++i
induction variable: ['i']
{
	loop info: Size j=0  j < LENGTH(strike)  ++j
	induction variable: ['i', 'j']
	{
		loop info: Size l=0  l < LENGTH(maturity)  ++l
		induction variable: ['i', 'j', 'l']
		{
		L1947: (maturity[l],r) 
		L1948: (strike[j]*,r) 
		L1949: (types[i],r) 
		L1950: (strike[j],r) 
		L1951: (maturity[l],r) 
		L1952: (types[i]==,r) 
		}
 	}
 }
array table
-----------------------------------------------
strike -> [('[j]', 'r', 'normalized', ['i', 'j', 'l'], 1948), ('[j]', 'r', 'normalized', ['i', 'j', 'l'], 1950)]
LDEs formed:0

maturity -> [('[l]', 'r', 'normalized', ['i', 'j', 'l'], 1947), ('[l]', 'r', 'normalized', ['i', 'j', 'l'], 1951)]
LDEs formed:0

types -> [('[i]', 'r', 'normalized', ['i', 'j', 'l'], 1949), ('[i]', 'r', 'normalized', ['i', 'j', 'l'], 1952)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i < nrTrails  ++i
induction variable: ['i']
{
	loop info: Size j=1  j < m  ++j
	induction variable: ['i', 'j']
	{
	L1953: (grid[j],r) 
	L1954: (grid[j+optionTenor],r) 
		loop info: Size k=0  k < jointProcess->size()  ++k
		induction variable: ['i', 'j', 'k']
		{
		L1955: (states[k]=,w) (path.value[k][j],r) 
		L1956: (optionStates[k]=,w) (path.value[k][j+optionTenor],r) 
		}
	L1957: (states[2],r) 
	L1958: (zeroStat[j].add,r) 
	L1959: (optionStat[j].add,r) 
	}
 }
array table
-----------------------------------------------
zeroStat -> [('[j]', 'r', 'normalized', ['i', 'j', 'k'], 1958)]
LDEs formed:0

states -> [('[k]', 'w', 'normalized', ['i', 'j', 'k'], 1955), ('[2]', 'r', 'normalized', ['i', 'j', 'k'], 1957)]
LDEs formed:2

path.value -> [('[k][j]', 'r', 'normalized', ['i', 'j', 'k'], 1955), ('[k][j+optionTenor]', 'r', 'not normalized', ['i', 'j', 'k'], 1956)]
LDEs formed:0

optionStat -> [('[j]', 'r', 'normalized', ['i', 'j', 'k'], 1959)]
LDEs formed:0

grid -> [('[j]', 'r', 'normalized', ['i', 'j', 'k'], 1953), ('[j+optionTenor]', 'r', 'not normalized', ['i', 'j', 'k'], 1954)]
LDEs formed:0

optionStates -> [('[k]', 'w', 'normalized', ['i', 'j', 'k'], 1956)]
LDEs formed:1

distinct LDEs:
k1=2
k1=k2
#########################################################################################
loop info: Size j=1  j < m  ++j
induction variable: ['j']
{
L1957: (grid[j],r) 
L1958: (zeroStat[j].mean,r) 
L1959: (grid[j+optionTenor],r) 
L1960: (optionStat[j].mean,r) 
}
array table
-----------------------------------------------
zeroStat -> [('[j]', 'r', 'normalized', ['j'], 1958)]
LDEs formed:0

optionStat -> [('[j]', 'r', 'normalized', ['j'], 1960)]
LDEs formed:0

grid -> [('[j]', 'r', 'normalized', ['j'], 1957), ('[j+optionTenor]', 'r', 'not normalized', ['j'], 1959)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i < LENGTH(corr)  ++i
induction variable: ['i']
{
	loop info: Size j=0  j < LENGTH(strike)  ++j
	induction variable: ['i', 'j']
	{
	L1960: (corr[i],r) 
	L1961: (strike[j],r) 
	L1962: (corr[i],r) 
	L1963: (corr[i],r) 
	L1964: (corr[i]==,r) 
	L1965: (corr[i],r) 
	L1966: (strike[j],r) 
	}
 }
array table
-----------------------------------------------
strike -> [('[j]', 'r', 'normalized', ['i', 'j'], 1961), ('[j]', 'r', 'normalized', ['i', 'j'], 1966)]
LDEs formed:0

corr -> [('[i]', 'r', 'normalized', ['i', 'j'], 1960), ('[i]', 'r', 'normalized', ['i', 'j'], 1962), ('[i]', 'r', 'normalized', ['i', 'j'], 1963), ('[i]', 'r', 'normalized', ['i', 'j'], 1964), ('[i]', 'r', 'normalized', ['i', 'j'], 1965)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i < LENGTH(corr)  ++i
induction variable: ['i']
{
	loop info: Size j=0  j < LENGTH(strike)  ++j
	induction variable: ['i', 'j']
	{
	L1966: (corr[i],r) 
	L1967: (strike[j],r) 
	L1968: (corr[i],r) 
	L1969: (strike[j],r) 
	}
 }
array table
-----------------------------------------------
strike -> [('[j]', 'r', 'normalized', ['i', 'j'], 1967), ('[j]', 'r', 'normalized', ['i', 'j'], 1969)]
LDEs formed:0

corr -> [('[i]', 'r', 'normalized', ['i', 'j'], 1966), ('[i]', 'r', 'normalized', ['i', 'j'], 1968)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i < LENGTH(types)  ++i
induction variable: ['i']
{
	loop info: Size j=0  j < LENGTH(strike)  ++j
	induction variable: ['i', 'j']
	{
	L1969: (types[i],r) (strike[j],r) 
	L1970: (strike[j],r) 
	}
 }
array table
-----------------------------------------------
strike -> [('[j]', 'r', 'normalized', ['i', 'j'], 1969), ('[j]', 'r', 'normalized', ['i', 'j'], 1970)]
LDEs formed:0

types -> [('[i]', 'r', 'normalized', ['i', 'j'], 1969)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i < maturity  ++i
induction variable: ['i']
{
L1970: (redemption[i]=,w) 
}
array table
-----------------------------------------------
redemption -> [('[i]', 'w', 'normalized', ['i'], 1970)]
LDEs formed:1

distinct LDEs:
i1=i2
#########################################################################################
loop info: Size i=0  i < nrTrails  ++i
induction variable: ['i']
{
	loop info: Size j=1  j <= maturity  ++j
	induction variable: ['i', 'j']
	{
	L1971: (path.value[0][j],r) 
		loop info: Size k=0  k < 3  ++k
		induction variable: ['i', 'j', 'k']
			{
			L1972: (states[k]=,w) (path.value[k][j],r) 
			}
	L1973: (redemption[j-1],r) 
	L1974: (grid[j],r) 
		loop info: Size k=0  k < 3  ++k
		induction variable: ['i', 'j', 'k']
			{
			L1975: (states[k]=,w) (path.value[k][j],r) 
			}
	L1976: (grid[j],r) 
	}
 }
array table
-----------------------------------------------
states -> [('[k]', 'w', 'normalized', ['i', 'j', 'k'], 1972), ('[k]', 'w', 'normalized', ['i', 'j', 'k'], 1975)]
LDEs formed:3

path.value -> [('[0][j]', 'r', 'normalized', ['i', 'j', 'k'], 1971), ('[k][j]', 'r', 'normalized', ['i', 'j', 'k'], 1972), ('[k][j]', 'r', 'normalized', ['i', 'j', 'k'], 1975)]
LDEs formed:0

grid -> [('[j]', 'r', 'normalized', ['i', 'j', 'k'], 1974), ('[j]', 'r', 'normalized', ['i', 'j', 'k'], 1976)]
LDEs formed:0

redemption -> [('[j-1]', 'r', 'normalized', ['i', 'j', 'k'], 1973)]
LDEs formed:0

distinct LDEs:
k1=k2
#########################################################################################
loop info: Size i=0  i < LENGTH(corr)  ++i
induction variable: ['i']
{
	loop info: Size j=0  j < LENGTH(strike)  ++j
	induction variable: ['i', 'j']
	{
	L1974: (strike[j],r) 
	L1975: (corr[i],r) 
	L1976: (corr[i],r) 
	L1977: (corr[i],r) 
	L1978: (strike[j],r) 
	}
 }
array table
-----------------------------------------------
strike -> [('[j]', 'r', 'normalized', ['i', 'j'], 1974), ('[j]', 'r', 'normalized', ['i', 'j'], 1978)]
LDEs formed:0

corr -> [('[i]', 'r', 'normalized', ['i', 'j'], 1975), ('[i]', 'r', 'normalized', ['i', 'j'], 1976), ('[i]', 'r', 'normalized', ['i', 'j'], 1977)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i < LENGTH(corr)  ++i
induction variable: ['i']
{
	loop info: Size j=0  j < LENGTH(strike)  ++j
	induction variable: ['i', 'j']
	{
	L1978: (strike[j],r) 
	L1979: (corr[i],r) 
	L1980: (corr[i],r) 
	L1981: (corr[i],r) 
	L1982: (strike[j],r) 
	L1983: (corr[i],r) 
	L1984: (strike[j],r) 
	L1985: (corr[i],r) 
	L1986: (strike[j],r) 
	}
 }
array table
-----------------------------------------------
strike -> [('[j]', 'r', 'normalized', ['i', 'j'], 1978), ('[j]', 'r', 'normalized', ['i', 'j'], 1982), ('[j]', 'r', 'normalized', ['i', 'j'], 1984), ('[j]', 'r', 'normalized', ['i', 'j'], 1986)]
LDEs formed:0

corr -> [('[i]', 'r', 'normalized', ['i', 'j'], 1979), ('[i]', 'r', 'normalized', ['i', 'j'], 1980), ('[i]', 'r', 'normalized', ['i', 'j'], 1981), ('[i]', 'r', 'normalized', ['i', 'j'], 1983), ('[i]', 'r', 'normalized', ['i', 'j'], 1985)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size l=0  l < LENGTH(schemes)  ++l
induction variable: ['l']
{
L1986: (schemes[l],r) 
	loop info: Size i=0  i < LENGTH(controlVariate)  ++i
	induction variable: ['l', 'i']
	{
		loop info: Size u=0  u < LENGTH(listOfTimeStepsPerYear)  ++u
		induction variable: ['l', 'i', 'u']
		{
		L1987: (listOfTimeStepsPerYear[u],r) 
		L1988: (controlVariate[i],r) 
			loop info: Size k=0  k < LENGTH(strikes)  ++k
			induction variable: ['l', 'i', 'u', 'k']
			{
			L1989: (strikes[k],r) 
			}
		L1990: (controlVariate[i]&,r) (tolWithCV[l],r) 
		L1991: (controlVariate[i]&,r) (tolWithOutCV[l],r) 
		}
 	}
 }
array table
-----------------------------------------------
controlVariate -> [('[i]', 'r', 'normalized', ['l', 'i', 'u', 'k'], 1988), ('[i]', 'r', 'normalized', ['l', 'i', 'u', 'k'], 1990), ('[i]', 'r', 'normalized', ['l', 'i', 'u', 'k'], 1991)]
LDEs formed:0

tolWithOutCV -> [('[l]', 'r', 'normalized', ['l', 'i', 'u', 'k'], 1991)]
LDEs formed:0

tolWithCV -> [('[l]', 'r', 'normalized', ['l', 'i', 'u', 'k'], 1990)]
LDEs formed:0

strikes -> [('[k]', 'r', 'normalized', ['l', 'i', 'u', 'k'], 1989)]
LDEs formed:0

schemes -> [('[l]', 'r', 'normalized', ['l', 'i', 'u', 'k'], 1986)]
LDEs formed:0

listOfTimeStepsPerYear -> [('[u]', 'r', 'normalized', ['l', 'i', 'u', 'k'], 1987)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size u=0  u < LENGTH(listOfTimeStepsPerYear)  ++u
induction variable: ['u']
{
	loop info: Size i=0  i < LENGTH(schemes)  ++i
	induction variable: ['u', 'i']
	{
		loop info: Size j=0  j < LENGTH(hestonModels)  ++j
		induction variable: ['u', 'i', 'j']
		{
		L1988: (hestonModels[j],r) 
		L1989: (listOfTimeStepsPerYear[u],r) 
		L1990: (schemes[i].schemeDesc,r) 
			loop info: Size k=0  k < LENGTH(strikes)  ++k
			induction variable: ['u', 'i', 'j', 'k']
			{
			L1991: (strikes[k],r) 
			}
		L1992: (tol[i],r) 
		L1993: (schemes[i].name<<,r) 
		L1994: (hestonModels[j].name<<,r) 
		L1995: (tol[i],r) 
		}
 	}
 }
array table
-----------------------------------------------
hestonModels -> [('[j]', 'r', 'normalized', ['u', 'i', 'j', 'k'], 1988), ('[j]', 'r', 'normalized', ['u', 'i', 'j', 'k'], 1994)]
LDEs formed:0

listOfTimeStepsPerYear -> [('[u]', 'r', 'normalized', ['u', 'i', 'j', 'k'], 1989)]
LDEs formed:0

schemes -> [('[i]', 'r', 'normalized', ['u', 'i', 'j', 'k'], 1990), ('[i]', 'r', 'normalized', ['u', 'i', 'j', 'k'], 1993)]
LDEs formed:0

tol -> [('[i]', 'r', 'normalized', ['u', 'i', 'j', 'k'], 1992), ('[i]', 'r', 'normalized', ['u', 'i', 'j', 'k'], 1995)]
LDEs formed:0

strikes -> [('[k]', 'r', 'normalized', ['u', 'i', 'j', 'k'], 1991)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i < LENGTH(maturities)  ++i
induction variable: ['i']
{
L1992: (maturities[i]*,r) 
	loop info: Size j=0  j < LENGTH(strikes)  ++j
	induction variable: ['i', 'j']
	{
	L1993: (strikes[j],r) 
	L1994: (vol[i*LENGTH(strikes)+j],r) 
	L1995: (strikes[j],r) 
	}
 }
array table
-----------------------------------------------
vol -> [('[i*LENGTH(strikes)+j]', 'r', 'not normalized', ['i', 'j'], 1994)]
LDEs formed:0

maturities -> [('[i]', 'r', 'normalized', ['i', 'j'], 1992)]
LDEs formed:0

strikes -> [('[j]', 'r', 'normalized', ['i', 'j'], 1993), ('[j]', 'r', 'normalized', ['i', 'j'], 1995)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i < LENGTH(maturities)  ++i
induction variable: ['i']
{
L1996: (maturities[i]*,r) 
L1997: (maturities[i]*,r) 
	loop info: Size j=0  j < LENGTH(strikes)  ++j
	induction variable: ['i', 'j']
	{
	L1998: (strikes[js],r) 
	L1999: (vol[i*LENGTH(strikes)+js],r) 
	L2000: (strikes[js],r) 
	}
 }
array table
-----------------------------------------------
vol -> [('[i*LENGTH(strikes)+js]', 'r', 'not normalized', ['i', 'j'], 1999)]
LDEs formed:0

maturities -> [('[i]', 'r', 'normalized', ['i', 'j'], 1996), ('[i]', 'r', 'normalized', ['i', 'j'], 1997)]
LDEs formed:0

strikes -> [('[js]', 'r', 'not normalized', ['i', 'j'], 1998), ('[js]', 'r', 'not normalized', ['i', 'j'], 2000)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size j=0  j < LENGTH(sigma_v)  ++j
induction variable: ['j']
{
L2001: (sigma_v[j],r) 
	loop info: Size i=0  i < LENGTH(strikes)  ++i
	induction variable: ['j', 'i']
	{
	L2002: (strikes[i],r) 
	L2003: (expected[j][i]-,r) 
	L2004: (expected[j][i],r) 
	L2005: (strikes[i],r) 
	L2006: (sigma_v[j],r) 
	}
 }
array table
-----------------------------------------------
expected -> [('[j][i]', 'r', 'normalized', ['j', 'i'], 2003), ('[j][i]', 'r', 'normalized', ['j', 'i'], 2004)]
LDEs formed:0

sigma_v -> [('[j]', 'r', 'normalized', ['j', 'i'], 2001), ('[j]', 'r', 'normalized', ['j', 'i'], 2006)]
LDEs formed:0

strikes -> [('[i]', 'r', 'normalized', ['j', 'i'], 2002), ('[i]', 'r', 'normalized', ['j', 'i'], 2005)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/margrabeoption.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<LENGTH(values)  i++
induction variable: ['i']
{
L2006: (values[i].t*,r) 
L2007: (values[i].s1,r) 
L2008: (values[i].s2,r) 
L2009: (values[i].q1,r) 
L2010: (values[i].q2,r) 
L2011: (values[i].r,r) 
L2012: (values[i].v1,r) 
L2013: (values[i].v2,r) 
L2014: (values[i].rho,r) 
	loop info: Integer j=0  j < 2  j++
	induction variable: ['i', 'j']
	{
	L2015: (correlationMatrix[j][j]=,w) 
	}
L2016: (values[i].rho,r) 
L2017: (values[i].Q1,r) (values[i].Q2,r) 
L2018: (values[i].result,r) 
L2019: (values[i].tol,r) 
L2020: (values[i].s1,r) (values[i].s2,r) (values[i].Q1,r) 
L2021: (values[i].Q2,r) (values[i].q1,r) (values[i].q2,r) 
L2022: (values[i].r,r) (values[i].v1,r) 
L2023: (values[i].v2,r) (values[i].rho,r) 
L2024: (values[i].delta1,r) 
L2025: (values[i].s1,r) (values[i].s2,r) (values[i].Q1,r) 
L2026: (values[i].Q2,r) (values[i].q1,r) (values[i].q2,r) 
L2027: (values[i].r,r) (values[i].v1,r) 
L2028: (values[i].v2,r) (values[i].rho,r) 
L2029: (values[i].delta2,r) 
L2030: (values[i].s1,r) (values[i].s2,r) (values[i].Q1,r) 
L2031: (values[i].Q2,r) (values[i].q1,r) (values[i].q2,r) 
L2032: (values[i].r,r) (values[i].v1,r) 
L2033: (values[i].v2,r) (values[i].rho,r) 
L2034: (values[i].gamma1,r) 
L2035: (values[i].s1,r) (values[i].s2,r) (values[i].Q1,r) 
L2036: (values[i].Q2,r) (values[i].q1,r) (values[i].q2,r) 
L2037: (values[i].r,r) (values[i].v1,r) 
L2038: (values[i].v2,r) (values[i].rho,r) 
L2039: (values[i].gamma2,r) 
L2040: (values[i].s1,r) (values[i].s2,r) (values[i].Q1,r) 
L2041: (values[i].Q2,r) (values[i].q1,r) (values[i].q2,r) 
L2042: (values[i].r,r) (values[i].v1,r) 
L2043: (values[i].v2,r) (values[i].rho,r) 
L2044: (values[i].theta,r) 
L2045: (values[i].s1,r) (values[i].s2,r) (values[i].Q1,r) 
L2046: (values[i].Q2,r) (values[i].q1,r) (values[i].q2,r) 
L2047: (values[i].r,r) (values[i].v1,r) 
L2048: (values[i].v2,r) (values[i].rho,r) 
L2049: (values[i].rho_greek,r) 
L2050: (values[i].s1,r) (values[i].s2,r) (values[i].Q1,r) 
L2051: (values[i].Q2,r) (values[i].q1,r) (values[i].q2,r) 
L2052: (values[i].r,r) (values[i].v1,r) 
L2053: (values[i].v2,r) (values[i].rho,r) 
}
array table
-----------------------------------------------
values -> [('[i]', 'r', 'normalized', ['i', 'j'], 2006), ('[i]', 'r', 'normalized', ['i', 'j'], 2007), ('[i]', 'r', 'normalized', ['i', 'j'], 2008), ('[i]', 'r', 'normalized', ['i', 'j'], 2009), ('[i]', 'r', 'normalized', ['i', 'j'], 2010), ('[i]', 'r', 'normalized', ['i', 'j'], 2011), ('[i]', 'r', 'normalized', ['i', 'j'], 2012), ('[i]', 'r', 'normalized', ['i', 'j'], 2013), ('[i]', 'r', 'normalized', ['i', 'j'], 2014), ('[i]', 'r', 'normalized', ['i', 'j'], 2016), ('[i]', 'r', 'normalized', ['i', 'j'], 2017), ('[i]', 'r', 'normalized', ['i', 'j'], 2017), ('[i]', 'r', 'normalized', ['i', 'j'], 2018), ('[i]', 'r', 'normalized', ['i', 'j'], 2019), ('[i]', 'r', 'normalized', ['i', 'j'], 2020), ('[i]', 'r', 'normalized', ['i', 'j'], 2020), ('[i]', 'r', 'normalized', ['i', 'j'], 2020), ('[i]', 'r', 'normalized', ['i', 'j'], 2021), ('[i]', 'r', 'normalized', ['i', 'j'], 2021), ('[i]', 'r', 'normalized', ['i', 'j'], 2021), ('[i]', 'r', 'normalized', ['i', 'j'], 2022), ('[i]', 'r', 'normalized', ['i', 'j'], 2022), ('[i]', 'r', 'normalized', ['i', 'j'], 2023), ('[i]', 'r', 'normalized', ['i', 'j'], 2023), ('[i]', 'r', 'normalized', ['i', 'j'], 2024), ('[i]', 'r', 'normalized', ['i', 'j'], 2025), ('[i]', 'r', 'normalized', ['i', 'j'], 2025), ('[i]', 'r', 'normalized', ['i', 'j'], 2025), ('[i]', 'r', 'normalized', ['i', 'j'], 2026), ('[i]', 'r', 'normalized', ['i', 'j'], 2026), ('[i]', 'r', 'normalized', ['i', 'j'], 2026), ('[i]', 'r', 'normalized', ['i', 'j'], 2027), ('[i]', 'r', 'normalized', ['i', 'j'], 2027), ('[i]', 'r', 'normalized', ['i', 'j'], 2028), ('[i]', 'r', 'normalized', ['i', 'j'], 2028), ('[i]', 'r', 'normalized', ['i', 'j'], 2029), ('[i]', 'r', 'normalized', ['i', 'j'], 2030), ('[i]', 'r', 'normalized', ['i', 'j'], 2030), ('[i]', 'r', 'normalized', ['i', 'j'], 2030), ('[i]', 'r', 'normalized', ['i', 'j'], 2031), ('[i]', 'r', 'normalized', ['i', 'j'], 2031), ('[i]', 'r', 'normalized', ['i', 'j'], 2031), ('[i]', 'r', 'normalized', ['i', 'j'], 2032), ('[i]', 'r', 'normalized', ['i', 'j'], 2032), ('[i]', 'r', 'normalized', ['i', 'j'], 2033), ('[i]', 'r', 'normalized', ['i', 'j'], 2033), ('[i]', 'r', 'normalized', ['i', 'j'], 2034), ('[i]', 'r', 'normalized', ['i', 'j'], 2035), ('[i]', 'r', 'normalized', ['i', 'j'], 2035), ('[i]', 'r', 'normalized', ['i', 'j'], 2035), ('[i]', 'r', 'normalized', ['i', 'j'], 2036), ('[i]', 'r', 'normalized', ['i', 'j'], 2036), ('[i]', 'r', 'normalized', ['i', 'j'], 2036), ('[i]', 'r', 'normalized', ['i', 'j'], 2037), ('[i]', 'r', 'normalized', ['i', 'j'], 2037), ('[i]', 'r', 'normalized', ['i', 'j'], 2038), ('[i]', 'r', 'normalized', ['i', 'j'], 2038), ('[i]', 'r', 'normalized', ['i', 'j'], 2039), ('[i]', 'r', 'normalized', ['i', 'j'], 2040), ('[i]', 'r', 'normalized', ['i', 'j'], 2040), ('[i]', 'r', 'normalized', ['i', 'j'], 2040), ('[i]', 'r', 'normalized', ['i', 'j'], 2041), ('[i]', 'r', 'normalized', ['i', 'j'], 2041), ('[i]', 'r', 'normalized', ['i', 'j'], 2041), ('[i]', 'r', 'normalized', ['i', 'j'], 2042), ('[i]', 'r', 'normalized', ['i', 'j'], 2042), ('[i]', 'r', 'normalized', ['i', 'j'], 2043), ('[i]', 'r', 'normalized', ['i', 'j'], 2043), ('[i]', 'r', 'normalized', ['i', 'j'], 2044), ('[i]', 'r', 'normalized', ['i', 'j'], 2045), ('[i]', 'r', 'normalized', ['i', 'j'], 2045), ('[i]', 'r', 'normalized', ['i', 'j'], 2045), ('[i]', 'r', 'normalized', ['i', 'j'], 2046), ('[i]', 'r', 'normalized', ['i', 'j'], 2046), ('[i]', 'r', 'normalized', ['i', 'j'], 2046), ('[i]', 'r', 'normalized', ['i', 'j'], 2047), ('[i]', 'r', 'normalized', ['i', 'j'], 2047), ('[i]', 'r', 'normalized', ['i', 'j'], 2048), ('[i]', 'r', 'normalized', ['i', 'j'], 2048), ('[i]', 'r', 'normalized', ['i', 'j'], 2049), ('[i]', 'r', 'normalized', ['i', 'j'], 2050), ('[i]', 'r', 'normalized', ['i', 'j'], 2050), ('[i]', 'r', 'normalized', ['i', 'j'], 2050), ('[i]', 'r', 'normalized', ['i', 'j'], 2051), ('[i]', 'r', 'normalized', ['i', 'j'], 2051), ('[i]', 'r', 'normalized', ['i', 'j'], 2051), ('[i]', 'r', 'normalized', ['i', 'j'], 2052), ('[i]', 'r', 'normalized', ['i', 'j'], 2052), ('[i]', 'r', 'normalized', ['i', 'j'], 2053), ('[i]', 'r', 'normalized', ['i', 'j'], 2053)]
LDEs formed:0

correlationMatrix -> [('[j][j]', 'w', 'normalized', ['i', 'j'], 2015)]
LDEs formed:2

distinct LDEs:
j1=j2,j1=j2
#########################################################################################
loop info: Size k=0  k<LENGTH(residualTimes)  k++
induction variable: ['k']
{
L2016: (residualTimes[k],r) 
	loop info: Integer j=0  j < 2  j++
	induction variable: ['k', 'j']
	{
	L2017: (correlationMatrix[j][j]=,w) 
		loop info: Size l=0  l<LENGTH(underlyings1)  l++
		induction variable: ['k', 'j', 'l']
		{
			loop info: Size m=0  m<LENGTH(qRates1)  m++
			induction variable: ['k', 'j', 'l', 'm']
			{
				loop info: Size n=0  n<LENGTH(rRates)  n++
				induction variable: ['k', 'j', 'l', 'm', 'n']
				{
					loop info: Size p=0  p<LENGTH(vols1)  p++
					induction variable: ['k', 'j', 'l', 'm', 'n', 'p']
					{
					L2018: (underlyings1[l],r) 
					L2019: (underlyings2[l],r) 
					L2020: (qRates1[m],r) 
					L2021: (qRates2[m],r) 
					L2022: (rRates[n],r) 
					L2023: (vols1[p],r) 
					L2024: (vols2[p],r) 
					L2025: (calculated["delta1"]=,w) 
					L2026: (calculated["delta2"]=,w) 
					L2027: (calculated["gamma1"]=,w) 
					L2028: (calculated["gamma2"]=,w) 
					L2029: (calculated["theta"]=,w) 
					L2030: (calculated["rho"]=,w) 
					L2031: (expected["delta1"]=,w) 
					L2032: (expected["gamma1"]=,w) 
					L2033: (expected["delta2"]=,w) 
					L2034: (expected["gamma2"]=,w) 
					L2035: (expected["rho"]=,w) 
					L2036: (expected["theta"]=,w) 
					L2037: (calculated[greek],r) 
					}
 				}
 			}
 		}
 	}
 }
array table
-----------------------------------------------
residualTimes -> [('[k]', 'r', 'normalized', ['k', 'j', 'l', 'm', 'n', 'p'], 2016)]
LDEs formed:0

rRates -> [('[n]', 'r', 'normalized', ['k', 'j', 'l', 'm', 'n', 'p'], 2022)]
LDEs formed:0

vols1 -> [('[p]', 'r', 'normalized', ['k', 'j', 'l', 'm', 'n', 'p'], 2023)]
LDEs formed:0

vols2 -> [('[p]', 'r', 'normalized', ['k', 'j', 'l', 'm', 'n', 'p'], 2024)]
LDEs formed:0

qRates1 -> [('[m]', 'r', 'normalized', ['k', 'j', 'l', 'm', 'n', 'p'], 2020)]
LDEs formed:0

calculated -> [('["delta1"]', 'w', 'not normalized', ['k', 'j', 'l', 'm', 'n', 'p'], 2025), ('["delta2"]', 'w', 'not normalized', ['k', 'j', 'l', 'm', 'n', 'p'], 2026), ('["gamma1"]', 'w', 'not normalized', ['k', 'j', 'l', 'm', 'n', 'p'], 2027), ('["gamma2"]', 'w', 'not normalized', ['k', 'j', 'l', 'm', 'n', 'p'], 2028), ('["theta"]', 'w', 'not normalized', ['k', 'j', 'l', 'm', 'n', 'p'], 2029), ('["rho"]', 'w', 'not normalized', ['k', 'j', 'l', 'm', 'n', 'p'], 2030), ('[greek]', 'r', 'not normalized', ['k', 'j', 'l', 'm', 'n', 'p'], 2037)]
LDEs formed:27

qRates2 -> [('[m]', 'r', 'normalized', ['k', 'j', 'l', 'm', 'n', 'p'], 2021)]
LDEs formed:0

correlationMatrix -> [('[j][j]', 'w', 'normalized', ['k', 'j', 'l', 'm', 'n', 'p'], 2017)]
LDEs formed:2

underlyings1 -> [('[l]', 'r', 'normalized', ['k', 'j', 'l', 'm', 'n', 'p'], 2018)]
LDEs formed:0

underlyings2 -> [('[l]', 'r', 'normalized', ['k', 'j', 'l', 'm', 'n', 'p'], 2019)]
LDEs formed:0

expected -> [('["delta1"]', 'w', 'not normalized', ['k', 'j', 'l', 'm', 'n', 'p'], 2031), ('["gamma1"]', 'w', 'not normalized', ['k', 'j', 'l', 'm', 'n', 'p'], 2032), ('["delta2"]', 'w', 'not normalized', ['k', 'j', 'l', 'm', 'n', 'p'], 2033), ('["gamma2"]', 'w', 'not normalized', ['k', 'j', 'l', 'm', 'n', 'p'], 2034), ('["rho"]', 'w', 'not normalized', ['k', 'j', 'l', 'm', 'n', 'p'], 2035), ('["theta"]', 'w', 'not normalized', ['k', 'j', 'l', 'm', 'n', 'p'], 2036)]
LDEs formed:21

distinct LDEs:
"gamma2"="theta"
"gamma1"="gamma1"
"delta2"="theta"
"gamma1"=greek
"theta"="rho"
"theta"="theta"
"delta1"="gamma1"
"gamma1"="rho"
"delta2"="rho"
"gamma2"="rho"
"rho"="rho"
"delta2"="gamma2"
"delta1"="theta"
"delta1"=greek
"delta1"="delta2"
"delta2"=greek
"gamma2"="gamma2"
"delta1"="gamma2"
"rho"=greek
"gamma1"="gamma2"
"gamma1"="theta"
"gamma2"=greek
"delta2"="gamma1"
"delta2"="delta2"
"theta"=greek
"delta1"="rho"
"delta1"="delta1"
j1=j2,j1=j2
#########################################################################################
loop info: Size i=0  i<LENGTH(values)  i++
induction variable: ['i']
{
L2037: (values[i].t*,r) 
L2038: (values[i].s1,r) 
L2039: (values[i].s2,r) 
L2040: (values[i].q1,r) 
L2041: (values[i].q2,r) 
L2042: (values[i].r,r) 
L2043: (values[i].v1,r) 
L2044: (values[i].v2,r) 
L2045: (values[i].rho,r) 
	loop info: Integer j=0  j < 2  j++
	induction variable: ['i', 'j']
	{
	L2046: (correlationMatrix[j][j]=,w) 
	}
L2047: (values[i].rho,r) 
L2048: (values[i].Q1,r) (values[i].Q2,r) 
L2049: (values[i].result,r) 
L2050: (values[i].tol,r) 
L2051: (values[i].s1,r) (values[i].s2,r) (values[i].Q1,r) 
L2052: (values[i].Q2,r) (values[i].q1,r) (values[i].q2,r) 
L2053: (values[i].r,r) (values[i].v1,r) 
L2054: (values[i].v2,r) (values[i].rho,r) 
}
array table
-----------------------------------------------
values -> [('[i]', 'r', 'normalized', ['i', 'j'], 2037), ('[i]', 'r', 'normalized', ['i', 'j'], 2038), ('[i]', 'r', 'normalized', ['i', 'j'], 2039), ('[i]', 'r', 'normalized', ['i', 'j'], 2040), ('[i]', 'r', 'normalized', ['i', 'j'], 2041), ('[i]', 'r', 'normalized', ['i', 'j'], 2042), ('[i]', 'r', 'normalized', ['i', 'j'], 2043), ('[i]', 'r', 'normalized', ['i', 'j'], 2044), ('[i]', 'r', 'normalized', ['i', 'j'], 2045), ('[i]', 'r', 'normalized', ['i', 'j'], 2047), ('[i]', 'r', 'normalized', ['i', 'j'], 2048), ('[i]', 'r', 'normalized', ['i', 'j'], 2048), ('[i]', 'r', 'normalized', ['i', 'j'], 2049), ('[i]', 'r', 'normalized', ['i', 'j'], 2050), ('[i]', 'r', 'normalized', ['i', 'j'], 2051), ('[i]', 'r', 'normalized', ['i', 'j'], 2051), ('[i]', 'r', 'normalized', ['i', 'j'], 2051), ('[i]', 'r', 'normalized', ['i', 'j'], 2052), ('[i]', 'r', 'normalized', ['i', 'j'], 2052), ('[i]', 'r', 'normalized', ['i', 'j'], 2052), ('[i]', 'r', 'normalized', ['i', 'j'], 2053), ('[i]', 'r', 'normalized', ['i', 'j'], 2053), ('[i]', 'r', 'normalized', ['i', 'j'], 2054), ('[i]', 'r', 'normalized', ['i', 'j'], 2054)]
LDEs formed:0

correlationMatrix -> [('[j][j]', 'w', 'normalized', ['i', 'j'], 2046)]
LDEs formed:2

distinct LDEs:
j1=j2,j1=j2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/numericaldifferentiation.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Natural order=0  order < 5  ++order
induction variable: ['order']
{
	loop info: Natural i=0  i < nGridPoints  ++i
	induction variable: ['order', 'i']
		{
		L2047: (gridPoints[i]=,w) 
		}
 }
array table
-----------------------------------------------
gridPoints -> [('[i]', 'w', 'normalized', ['order', 'i'], 2047)]
LDEs formed:1

distinct LDEs:
i1=i2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/binaryoption.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<LENGTH(values)  i++
induction variable: ['i']
{
L2048: (values[i].type,r) (values[i].strike,r) (values[i].cash,r) 
L2049: (values[i].t*,r) 
L2050: (values[i].s,r) 
L2051: (values[i].q,r) 
L2052: (values[i].r,r) 
L2053: (values[i].v,r) 
L2054: (values[i].barrierType,r) 
L2055: (values[i].barrier,r) 
L2056: (values[i].result,r) 
L2057: (values[i].tol,r) 
L2058: (values[i].barrierType,r) 
L2059: (values[i].barrier,r) (values[i].s,r) 
L2060: (values[i].q,r) (values[i].r,r) (values[i].v,r) 
L2061: (values[i].result,r) (values[i].tol,r) 
}
array table
-----------------------------------------------
values -> [('[i]', 'r', 'normalized', ['i'], 2048), ('[i]', 'r', 'normalized', ['i'], 2048), ('[i]', 'r', 'normalized', ['i'], 2048), ('[i]', 'r', 'normalized', ['i'], 2049), ('[i]', 'r', 'normalized', ['i'], 2050), ('[i]', 'r', 'normalized', ['i'], 2051), ('[i]', 'r', 'normalized', ['i'], 2052), ('[i]', 'r', 'normalized', ['i'], 2053), ('[i]', 'r', 'normalized', ['i'], 2054), ('[i]', 'r', 'normalized', ['i'], 2055), ('[i]', 'r', 'normalized', ['i'], 2056), ('[i]', 'r', 'normalized', ['i'], 2057), ('[i]', 'r', 'normalized', ['i'], 2058), ('[i]', 'r', 'normalized', ['i'], 2059), ('[i]', 'r', 'normalized', ['i'], 2059), ('[i]', 'r', 'normalized', ['i'], 2060), ('[i]', 'r', 'normalized', ['i'], 2060), ('[i]', 'r', 'normalized', ['i'], 2060), ('[i]', 'r', 'normalized', ['i'], 2061), ('[i]', 'r', 'normalized', ['i'], 2061)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<LENGTH(values)  i++
induction variable: ['i']
{
L2062: (values[i].type,r) (values[i].strike,r) 
L2063: (values[i].t*,r) 
L2064: (values[i].s,r) 
L2065: (values[i].q,r) 
L2066: (values[i].r,r) 
L2067: (values[i].v,r) 
L2068: (values[i].barrierType,r) 
L2069: (values[i].barrier,r) 
L2070: (values[i].result,r) 
L2071: (values[i].tol,r) 
L2072: (values[i].barrierType,r) 
L2073: (values[i].barrier,r) (values[i].s,r) 
L2074: (values[i].q,r) (values[i].r,r) (values[i].v,r) 
L2075: (values[i].result,r) (values[i].tol,r) 
}
array table
-----------------------------------------------
values -> [('[i]', 'r', 'normalized', ['i'], 2062), ('[i]', 'r', 'normalized', ['i'], 2062), ('[i]', 'r', 'normalized', ['i'], 2063), ('[i]', 'r', 'normalized', ['i'], 2064), ('[i]', 'r', 'normalized', ['i'], 2065), ('[i]', 'r', 'normalized', ['i'], 2066), ('[i]', 'r', 'normalized', ['i'], 2067), ('[i]', 'r', 'normalized', ['i'], 2068), ('[i]', 'r', 'normalized', ['i'], 2069), ('[i]', 'r', 'normalized', ['i'], 2070), ('[i]', 'r', 'normalized', ['i'], 2071), ('[i]', 'r', 'normalized', ['i'], 2072), ('[i]', 'r', 'normalized', ['i'], 2073), ('[i]', 'r', 'normalized', ['i'], 2073), ('[i]', 'r', 'normalized', ['i'], 2074), ('[i]', 'r', 'normalized', ['i'], 2074), ('[i]', 'r', 'normalized', ['i'], 2074), ('[i]', 'r', 'normalized', ['i'], 2075), ('[i]', 'r', 'normalized', ['i'], 2075)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/dates.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: int i=0  i<40  ++i
induction variable: ['i']
{
L2076: (IMMcodes[i],r) 
L2077: (IMMcodes[i],r) 
L2078: (IMMcodes[i],r) 
}
array table
-----------------------------------------------
IMMcodes -> [('[i]', 'r', 'normalized', ['i'], 2076), ('[i]', 'r', 'normalized', ['i'], 2077), ('[i]', 'r', 'normalized', ['i'], 2078)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: int i = 0  i<120  ++i
induction variable: ['i']
{
L2079: (ASXcodes[i],r) 
L2080: (ASXcodes[i],r) 
L2081: (ASXcodes[i],r) 
}
array table
-----------------------------------------------
ASXcodes -> [('[i]', 'r', 'normalized', ['i'], 2079), ('[i]', 'r', 'normalized', ['i'], 2080), ('[i]', 'r', 'normalized', ['i'], 2081)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/creditdefaultswap.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=1  i<dates.size()  ++i
induction variable: ['i']
{
L2082: (dates[0],r) (dates[i-1],r) 
L2083: (dates[0],r) (dates[i],r) 
L2084: (defaultProbabilities[i-1],r) 
L2085: (defaultProbabilities[i],r) 
}
array table
-----------------------------------------------
dates -> [('[0]', 'r', 'normalized', ['i'], 2082), ('[i-1]', 'r', 'normalized', ['i'], 2082), ('[0]', 'r', 'normalized', ['i'], 2083), ('[i]', 'r', 'normalized', ['i'], 2083)]
LDEs formed:0

defaultProbabilities -> [('[i-1]', 'r', 'normalized', ['i'], 2084), ('[i]', 'r', 'normalized', ['i'], 2085)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/stats.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: i = 0  i<LENGTH(data)  i++
induction variable: ['i']
{
L2086: (data[i],r) 
L2087: (weights[i],r) 
}
array table
-----------------------------------------------
weights -> [('[i]', 'r', 'normalized', ['i'], 2087)]
LDEs formed:0

data -> [('[i]', 'r', 'normalized', ['i'], 2086)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: i=0  i<dimension  i++
induction variable: ['i']
{
L2087: (calculated[i],r) 
L2088: (calculated[i]<<,r) 
}
array table
-----------------------------------------------
calculated -> [('[i]', 'r', 'normalized', ['i'], 2087), ('[i]', 'r', 'normalized', ['i'], 2088)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: i=0  i<dimension  i++
induction variable: ['i']
{
L2089: (calculated[i],r) 
L2090: (calculated[i]<<,r) 
}
array table
-----------------------------------------------
calculated -> [('[i]', 'r', 'normalized', ['i'], 2089), ('[i]', 'r', 'normalized', ['i'], 2090)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: i=0  i<dimension  i++
induction variable: ['i']
{
L2091: (calculated[i]-,r) 
L2092: (calculated[i]<<,r) 
}
array table
-----------------------------------------------
calculated -> [('[i]', 'r', 'normalized', ['i'], 2091), ('[i]', 'r', 'normalized', ['i'], 2092)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: i=0  i<dimension  i++
induction variable: ['i']
{
L2093: (calculated[i]-,r) 
L2094: (calculated[i]<<,r) 
}
array table
-----------------------------------------------
calculated -> [('[i]', 'r', 'normalized', ['i'], 2093), ('[i]', 'r', 'normalized', ['i'], 2094)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: i=0  i<dimension  i++
induction variable: ['i']
{
L2095: (calculated[i]-,r) 
L2096: (calculated[i]<<,r) 
}
array table
-----------------------------------------------
calculated -> [('[i]', 'r', 'normalized', ['i'], 2095), ('[i]', 'r', 'normalized', ['i'], 2096)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: i=0  i<dimension  i++
induction variable: ['i']
{
L2097: (calculated[i]-,r) 
L2098: (calculated[i]<<,r) 
}
array table
-----------------------------------------------
calculated -> [('[i]', 'r', 'normalized', ['i'], 2097), ('[i]', 'r', 'normalized', ['i'], 2098)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: i=0  i<dimension  i++
induction variable: ['i']
{
L2099: (calculated[i]-,r) 
L2100: (calculated[i]<<,r) 
}
array table
-----------------------------------------------
calculated -> [('[i]', 'r', 'normalized', ['i'], 2099), ('[i]', 'r', 'normalized', ['i'], 2100)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/twoassetbarrieroption.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<LENGTH(values)  i++
induction variable: ['i']
{
L2101: (values[i].s1,r) 
L2102: (values[i].q1,r) 
L2103: (values[i].v1,r) 
L2104: (values[i].s2,r) 
L2105: (values[i].q2,r) 
L2106: (values[i].v2,r) 
L2107: (values[i].correlation,r) 
L2108: (values[i].r,r) 
L2109: (values[i].type,r) (values[i].strike,r) 
L2110: (values[i].barrierType,r) 
L2111: (values[i].barrier,r) 
L2112: (values[i].result,r) 
}
array table
-----------------------------------------------
values -> [('[i]', 'r', 'normalized', ['i'], 2101), ('[i]', 'r', 'normalized', ['i'], 2102), ('[i]', 'r', 'normalized', ['i'], 2103), ('[i]', 'r', 'normalized', ['i'], 2104), ('[i]', 'r', 'normalized', ['i'], 2105), ('[i]', 'r', 'normalized', ['i'], 2106), ('[i]', 'r', 'normalized', ['i'], 2107), ('[i]', 'r', 'normalized', ['i'], 2108), ('[i]', 'r', 'normalized', ['i'], 2109), ('[i]', 'r', 'normalized', ['i'], 2109), ('[i]', 'r', 'normalized', ['i'], 2110), ('[i]', 'r', 'normalized', ['i'], 2111), ('[i]', 'r', 'normalized', ['i'], 2112)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/optimizers.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<optimizationMethodNb  ++i
induction variable: ['i']
{
L2113: (optimizationMethodTypes[i],r) 
L2114: (optimizationMethodTypes[i],r) 
}
array table
-----------------------------------------------
optimizationMethodTypes -> [('[i]', 'r', 'normalized', ['i'], 2113), ('[i]', 'r', 'normalized', ['i'], 2114)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<costFunctions_.size()  ++i
induction variable: ['i']
{
L2115: (costFunctions_[i],r) (constraints_[i],r) 
L2116: (initialValues_[i],r) 
	loop info: Size j=0  j<(optimizationMethods_[i]).size()  ++j
	induction variable: ['i', 'j']
	{
	L2117: (endCriterias_[i]-,r) 
		loop info: Size k=0  k<endCriteriaTests  ++k
		induction variable: ['i', 'j', 'k']
		{
		L2118: (endCriterias_[i]-,r) 
		L2119: (endCriterias_[i]-,r) 
		L2120: (endCriterias_[i]-,r) 
		L2121: (endCriterias_[i]-,r) 
		L2122: (optimizationMethods_[i][j].optimizationMethod-,r) 
		L2123: (xMinExpected_[i],r) 
		L2124: (yMinExpected_[i],r) 
		L2125: (optimizationMethods_[i][j].name<<,r) 
		L2126: (xMinExpected_[i]<<,r) 
		L2127: (xMinExpected_[i]-,r) 
		L2128: (yMinExpected_[i]<<,r) 
		L2129: (yMinExpected_[i]-,r) 
		}
 	}
 }
array table
-----------------------------------------------
yMinExpected_ -> [('[i]', 'r', 'normalized', ['i', 'j', 'k'], 2124), ('[i]', 'r', 'normalized', ['i', 'j', 'k'], 2128), ('[i]', 'r', 'normalized', ['i', 'j', 'k'], 2129)]
LDEs formed:0

initialValues_ -> [('[i]', 'r', 'normalized', ['i', 'j', 'k'], 2116)]
LDEs formed:0

constraints_ -> [('[i]', 'r', 'normalized', ['i', 'j', 'k'], 2115)]
LDEs formed:0

optimizationMethods_ -> [('[i][j]', 'r', 'normalized', ['i', 'j', 'k'], 2122), ('[i][j]', 'r', 'normalized', ['i', 'j', 'k'], 2125)]
LDEs formed:0

costFunctions_ -> [('[i]', 'r', 'normalized', ['i', 'j', 'k'], 2115)]
LDEs formed:0

xMinExpected_ -> [('[i]', 'r', 'normalized', ['i', 'j', 'k'], 2123), ('[i]', 'r', 'normalized', ['i', 'j', 'k'], 2126), ('[i]', 'r', 'normalized', ['i', 'j', 'k'], 2127)]
LDEs formed:0

endCriterias_ -> [('[i]', 'r', 'normalized', ['i', 'j', 'k'], 2117), ('[i]', 'r', 'normalized', ['i', 'j', 'k'], 2118), ('[i]', 'r', 'normalized', ['i', 'j', 'k'], 2119), ('[i]', 'r', 'normalized', ['i', 'j', 'k'], 2120), ('[i]', 'r', 'normalized', ['i', 'j', 'k'], 2121)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<x.size()  ++i
induction variable: ['i']
{
L2122: (x[i],r) (x[i],r) 
}
array table
-----------------------------------------------
x -> [('[i]', 'r', 'normalized', ['i'], 2122), ('[i]', 'r', 'normalized', ['i'], 2122)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<x.size()  ++i
induction variable: ['i']
{
L2123: (x[i],r) 
}
array table
-----------------------------------------------
x -> [('[i]', 'r', 'normalized', ['i'], 2123)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<x.size()  ++i
induction variable: ['i']
{
L2124: (x[i]*,r) (x[i]/,r) 
}
array table
-----------------------------------------------
x -> [('[i]', 'r', 'normalized', ['i'], 2124), ('[i]', 'r', 'normalized', ['i'], 2124)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<x.size()  ++i
induction variable: ['i']
{
L2125: (x[i]/,r) 
}
array table
-----------------------------------------------
x -> [('[i]', 'r', 'normalized', ['i'], 2125)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i = 0  i < costFunctions.size()  ++i
induction variable: ['i']
{
L2126: (costFunctions[i],r) (constraints[i],r) (initialValues[i],r) 
L2127: (diffEvolOptimisers[i].minimize,r) (endCriteria[i],r) 
L2128: (minima[i],r) 
L2129: (minima[i],r) 
}
array table
-----------------------------------------------
minima -> [('[i]', 'r', 'normalized', ['i'], 2128), ('[i]', 'r', 'normalized', ['i'], 2129)]
LDEs formed:0

costFunctions -> [('[i]', 'r', 'normalized', ['i'], 2126)]
LDEs formed:0

diffEvolOptimisers -> [('[i]', 'r', 'normalized', ['i'], 2127)]
LDEs formed:0

initialValues -> [('[i]', 'r', 'normalized', ['i'], 2126)]
LDEs formed:0

constraints -> [('[i]', 'r', 'normalized', ['i'], 2126)]
LDEs formed:0

endCriteria -> [('[i]', 'r', 'normalized', ['i'], 2127)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/calendars.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<std::min<Size>(hol.size(), expectedHol.size())  i++
induction variable: ['i']
{
L2128: (hol[i],r) (expectedHol[i],r) 
L2129: (expectedHol[i],r) 
L2130: (hol[i],r) 
}
array table
-----------------------------------------------
hol -> [('[i]', 'r', 'normalized', ['i'], 2128), ('[i]', 'r', 'normalized', ['i'], 2130)]
LDEs formed:0

expectedHol -> [('[i]', 'r', 'normalized', ['i'], 2128), ('[i]', 'r', 'normalized', ['i'], 2129)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<std::min<Size>(hol.size(), expectedHol.size())  i++
induction variable: ['i']
{
L2130: (hol[i],r) (expectedHol[i],r) 
L2131: (expectedHol[i],r) 
L2132: (hol[i],r) 
}
array table
-----------------------------------------------
hol -> [('[i]', 'r', 'normalized', ['i'], 2130), ('[i]', 'r', 'normalized', ['i'], 2132)]
LDEs formed:0

expectedHol -> [('[i]', 'r', 'normalized', ['i'], 2130), ('[i]', 'r', 'normalized', ['i'], 2131)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: i=0  i<std::min<Size>(hol.size(), expectedHol.size())  i++
induction variable: ['i']
{
L2132: (hol[i],r) (expectedHol[i],r) 
L2133: (expectedHol[i],r) 
L2134: (hol[i],r) 
}
array table
-----------------------------------------------
hol -> [('[i]', 'r', 'normalized', ['i'], 2132), ('[i]', 'r', 'normalized', ['i'], 2134)]
LDEs formed:0

expectedHol -> [('[i]', 'r', 'normalized', ['i'], 2132), ('[i]', 'r', 'normalized', ['i'], 2133)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: i=0  i<histClose.size()  i++
induction variable: ['i']
{
L2134: (histClose[i],r) 
L2135: (histClose[i],r) 
}
array table
-----------------------------------------------
histClose -> [('[i]', 'r', 'normalized', ['i'], 2134), ('[i]', 'r', 'normalized', ['i'], 2135)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<std::min<Size>(hol.size(), expectedHol.size())  i++
induction variable: ['i']
{
L2136: (hol[i],r) (expectedHol[i],r) 
L2137: (expectedHol[i],r) 
L2138: (hol[i],r) 
}
array table
-----------------------------------------------
hol -> [('[i]', 'r', 'normalized', ['i'], 2136), ('[i]', 'r', 'normalized', ['i'], 2138)]
LDEs formed:0

expectedHol -> [('[i]', 'r', 'normalized', ['i'], 2136), ('[i]', 'r', 'normalized', ['i'], 2137)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<std::min<Size>(hol.size(), expectedHol.size())  i++
induction variable: ['i']
{
L2138: (hol[i],r) (expectedHol[i],r) 
L2139: (expectedHol[i],r) 
L2140: (hol[i],r) 
}
array table
-----------------------------------------------
hol -> [('[i]', 'r', 'normalized', ['i'], 2138), ('[i]', 'r', 'normalized', ['i'], 2140)]
LDEs formed:0

expectedHol -> [('[i]', 'r', 'normalized', ['i'], 2138), ('[i]', 'r', 'normalized', ['i'], 2139)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<std::min<Size>(hol.size(), expectedHol.size())  i++
induction variable: ['i']
{
L2140: (hol[i],r) (expectedHol[i],r) 
L2141: (expectedHol[i],r) 
L2142: (hol[i],r) 
}
array table
-----------------------------------------------
hol -> [('[i]', 'r', 'normalized', ['i'], 2140), ('[i]', 'r', 'normalized', ['i'], 2142)]
LDEs formed:0

expectedHol -> [('[i]', 'r', 'normalized', ['i'], 2140), ('[i]', 'r', 'normalized', ['i'], 2141)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<std::min<Size>(hol.size(), expectedHol.size())  i++
induction variable: ['i']
{
L2142: (hol[i],r) (expectedHol[i],r) 
L2143: (expectedHol[i],r) 
L2144: (hol[i],r) 
}
array table
-----------------------------------------------
hol -> [('[i]', 'r', 'normalized', ['i'], 2142), ('[i]', 'r', 'normalized', ['i'], 2144)]
LDEs formed:0

expectedHol -> [('[i]', 'r', 'normalized', ['i'], 2142), ('[i]', 'r', 'normalized', ['i'], 2143)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<std::min<Size>(hol.size(), expectedHol.size())  i++
induction variable: ['i']
{
L2144: (hol[i],r) (expectedHol[i],r) 
L2145: (expectedHol[i],r) 
L2146: (hol[i],r) 
}
array table
-----------------------------------------------
hol -> [('[i]', 'r', 'normalized', ['i'], 2144), ('[i]', 'r', 'normalized', ['i'], 2146)]
LDEs formed:0

expectedHol -> [('[i]', 'r', 'normalized', ['i'], 2144), ('[i]', 'r', 'normalized', ['i'], 2145)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<std::min<Size>(hol.size(), expectedHol.size())  i++
induction variable: ['i']
{
L2146: (hol[i],r) (expectedHol[i],r) 
L2147: (expectedHol[i],r) 
L2148: (hol[i],r) 
}
array table
-----------------------------------------------
hol -> [('[i]', 'r', 'normalized', ['i'], 2146), ('[i]', 'r', 'normalized', ['i'], 2148)]
LDEs formed:0

expectedHol -> [('[i]', 'r', 'normalized', ['i'], 2146), ('[i]', 'r', 'normalized', ['i'], 2147)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<std::min<Size>(hol.size(), expectedHol.size())  i++
induction variable: ['i']
{
L2148: (hol[i],r) (expectedHol[i],r) 
L2149: (expectedHol[i],r) 
L2150: (hol[i],r) 
}
array table
-----------------------------------------------
hol -> [('[i]', 'r', 'normalized', ['i'], 2148), ('[i]', 'r', 'normalized', ['i'], 2150)]
LDEs formed:0

expectedHol -> [('[i]', 'r', 'normalized', ['i'], 2148), ('[i]', 'r', 'normalized', ['i'], 2149)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<std::min<Size>(hol.size(), expectedHol.size())  i++
induction variable: ['i']
{
L2150: (hol[i],r) (expectedHol[i],r) 
L2151: (expectedHol[i],r) 
L2152: (hol[i],r) 
}
array table
-----------------------------------------------
hol -> [('[i]', 'r', 'normalized', ['i'], 2150), ('[i]', 'r', 'normalized', ['i'], 2152)]
LDEs formed:0

expectedHol -> [('[i]', 'r', 'normalized', ['i'], 2150), ('[i]', 'r', 'normalized', ['i'], 2151)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<std::min<Size>(hol.size(), expectedHol.size())  i++
induction variable: ['i']
{
L2152: (hol[i],r) (expectedHol[i],r) 
L2153: (expectedHol[i],r) 
L2154: (hol[i],r) 
}
array table
-----------------------------------------------
hol -> [('[i]', 'r', 'normalized', ['i'], 2152), ('[i]', 'r', 'normalized', ['i'], 2154)]
LDEs formed:0

expectedHol -> [('[i]', 'r', 'normalized', ['i'], 2152), ('[i]', 'r', 'normalized', ['i'], 2153)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<std::min<Size>(hol.size(), expectedHol.size())  i++
induction variable: ['i']
{
L2154: (hol[i],r) (expectedHol[i],r) 
L2155: (expectedHol[i],r) 
L2156: (hol[i],r) 
}
array table
-----------------------------------------------
hol -> [('[i]', 'r', 'normalized', ['i'], 2154), ('[i]', 'r', 'normalized', ['i'], 2156)]
LDEs formed:0

expectedHol -> [('[i]', 'r', 'normalized', ['i'], 2154), ('[i]', 'r', 'normalized', ['i'], 2155)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<std::min<Size>(hol.size(), expectedHol.size())  i++
induction variable: ['i']
{
L2156: (hol[i],r) (expectedHol[i],r) 
L2157: (expectedHol[i],r) 
L2158: (hol[i],r) 
}
array table
-----------------------------------------------
hol -> [('[i]', 'r', 'normalized', ['i'], 2156), ('[i]', 'r', 'normalized', ['i'], 2158)]
LDEs formed:0

expectedHol -> [('[i]', 'r', 'normalized', ['i'], 2156), ('[i]', 'r', 'normalized', ['i'], 2157)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=1  i<testDates.size()  i++
induction variable: ['i']
{
L2158: (testDates[i-1],r) 
L2159: (testDates[i],r) 
L2160: (expected[i-1],r) 
L2161: (testDates[i-1],r) 
L2162: (testDates[i]<<,r) 
L2163: (expected[i-1],r) 
}
array table
-----------------------------------------------
expected -> [('[i-1]', 'r', 'normalized', ['i'], 2160), ('[i-1]', 'r', 'normalized', ['i'], 2163)]
LDEs formed:0

testDates -> [('[i-1]', 'r', 'normalized', ['i'], 2158), ('[i]', 'r', 'normalized', ['i'], 2159), ('[i-1]', 'r', 'normalized', ['i'], 2161), ('[i]', 'r', 'normalized', ['i'], 2162)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/fdheston.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<LENGTH(values)  i++
induction variable: ['i']
{
L2163: (values[i].t*,r) 
L2164: (values[i].s,r) 
L2165: (values[i].q,r) 
L2166: (values[i].r,r) 
L2167: (values[i].v,r) 
L2168: (values[i].type,r) (values[i].strike,r) 
L2169: (values[i].barrierType,r) (values[i].barrier,r) 
L2170: (values[i].rebate,r) 
}
array table
-----------------------------------------------
values -> [('[i]', 'r', 'normalized', ['i'], 2163), ('[i]', 'r', 'normalized', ['i'], 2164), ('[i]', 'r', 'normalized', ['i'], 2165), ('[i]', 'r', 'normalized', ['i'], 2166), ('[i]', 'r', 'normalized', ['i'], 2167), ('[i]', 'r', 'normalized', ['i'], 2168), ('[i]', 'r', 'normalized', ['i'], 2168), ('[i]', 'r', 'normalized', ['i'], 2169), ('[i]', 'r', 'normalized', ['i'], 2169), ('[i]', 'r', 'normalized', ['i'], 2170)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i < LENGTH(strikes)  ++i
induction variable: ['i']
{
L2171: (strikes[i],r) 
L2172: (expected[i],r) 
L2173: (strikes[i],r) 
L2174: (expected[i],r) 
}
array table
-----------------------------------------------
expected -> [('[i]', 'r', 'normalized', ['i'], 2172), ('[i]', 'r', 'normalized', ['i'], 2174)]
LDEs formed:0

strikes -> [('[i]', 'r', 'normalized', ['i'], 2171), ('[i]', 'r', 'normalized', ['i'], 2173)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i < LENGTH(strikes)  ++i
induction variable: ['i']
{
L2174: (strikes[i],r) 
L2175: (strikes[i],r) 
L2176: (strikes[i],r) 
}
array table
-----------------------------------------------
strikes -> [('[i]', 'r', 'normalized', ['i'], 2174), ('[i]', 'r', 'normalized', ['i'], 2175), ('[i]', 'r', 'normalized', ['i'], 2176)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size l=0  l < LENGTH(schemes)  ++l
induction variable: ['l']
{
	loop info: Size i=0  i < LENGTH(values)  ++i
	induction variable: ['l', 'i']
	{
		loop info: Size j=0  j < LENGTH(tn)  ++j
		induction variable: ['l', 'i', 'j']
		{
			loop info: Size k=0  k < LENGTH(v0)  ++k
			induction variable: ['l', 'i', 'j', 'k']
			{
			L2177: (values[i].r,r) 
			L2178: (values[i].q,r) 
			L2179: (v0[k],r) 
			L2180: (values[i].kappa,r) 
			L2181: (values[i].theta,r) 
			L2182: (values[i].sigma,r) 
			L2183: (values[i].rho,r) 
			L2184: (values[i].T*,r) 
			L2185: (values[i].K,r) 
			L2186: (tn[j],r) 
			L2187: (schemes[l],r) 
			}
 		}
 	}
 }
array table
-----------------------------------------------
v0 -> [('[k]', 'r', 'normalized', ['l', 'i', 'j', 'k'], 2179)]
LDEs formed:0

tn -> [('[j]', 'r', 'normalized', ['l', 'i', 'j', 'k'], 2186)]
LDEs formed:0

schemes -> [('[l]', 'r', 'normalized', ['l', 'i', 'j', 'k'], 2187)]
LDEs formed:0

values -> [('[i]', 'r', 'normalized', ['l', 'i', 'j', 'k'], 2177), ('[i]', 'r', 'normalized', ['l', 'i', 'j', 'k'], 2178), ('[i]', 'r', 'normalized', ['l', 'i', 'j', 'k'], 2180), ('[i]', 'r', 'normalized', ['l', 'i', 'j', 'k'], 2181), ('[i]', 'r', 'normalized', ['l', 'i', 'j', 'k'], 2182), ('[i]', 'r', 'normalized', ['l', 'i', 'j', 'k'], 2183), ('[i]', 'r', 'normalized', ['l', 'i', 'j', 'k'], 2184), ('[i]', 'r', 'normalized', ['l', 'i', 'j', 'k'], 2185)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i < x.size()  ++i
induction variable: ['i']
{
L2186: (payoffTimesDensity[i]=,w) (x[i],r) (p[i],r) 
}
array table
-----------------------------------------------
x -> [('[i]', 'r', 'normalized', ['i'], 2186)]
LDEs formed:0

payoffTimesDensity -> [('[i]', 'w', 'normalized', ['i'], 2186)]
LDEs formed:1

p -> [('[i]', 'r', 'normalized', ['i'], 2186)]
LDEs formed:0

distinct LDEs:
i1=i2
#########################################################################################
loop info: Size i=0  i < LENGTH(strikes)  ++i
induction variable: ['i']
{
L2187: (strikes[i],r) 
L2188: (strikes[i],r) 
L2189: (strikes[i],r) 
L2190: (strikes[i],r) 
}
array table
-----------------------------------------------
strikes -> [('[i]', 'r', 'normalized', ['i'], 2187), ('[i]', 'r', 'normalized', ['i'], 2188), ('[i]', 'r', 'normalized', ['i'], 2189), ('[i]', 'r', 'normalized', ['i'], 2190)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i < 5  ++i
induction variable: ['i']
{
L2191: (expected[i][0]-,r) 
L2192: (expected[i][1]-,r) 
L2193: (expected[i][2]-,r) 
L2194: (expected[i][3]-,r) 
L2195: (expected[i][4]-,r) 
}
array table
-----------------------------------------------
expected -> [('[i][0]', 'r', 'normalized', ['i'], 2191), ('[i][1]', 'r', 'normalized', ['i'], 2192), ('[i][2]', 'r', 'normalized', ['i'], 2193), ('[i][3]', 'r', 'normalized', ['i'], 2194), ('[i][4]', 'r', 'normalized', ['i'], 2195)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i < vGrid  ++i
induction variable: ['i']
{
L2196: (v[i]=,w) 
}
array table
-----------------------------------------------
v -> [('[i]', 'w', 'normalized', ['i'], 2196)]
LDEs formed:1

distinct LDEs:
i1=i2
#########################################################################################
loop info: Size i=0  i < vGrid/2  ++i
induction variable: ['i']
{
L2197: (v[i+1]-,r) (v[i],r) 
L2198: (v[i+2]-,r) (v[i+1],r) 
L2199: (q[i]+,r) (q[i+1]+,r) (q[i+2],r) 
L2200: (v[i]*,r) (v[i]*,r) (q[i],r) 
}
array table
-----------------------------------------------
q -> [('[i]', 'r', 'normalized', ['i'], 2199), ('[i+1]', 'r', 'normalized', ['i'], 2199), ('[i+2]', 'r', 'normalized', ['i'], 2199), ('[i]', 'r', 'normalized', ['i'], 2200)]
LDEs formed:0

v -> [('[i+1]', 'r', 'normalized', ['i'], 2197), ('[i]', 'r', 'normalized', ['i'], 2197), ('[i+2]', 'r', 'normalized', ['i'], 2198), ('[i+1]', 'r', 'normalized', ['i'], 2198), ('[i]', 'r', 'normalized', ['i'], 2200), ('[i]', 'r', 'normalized', ['i'], 2200)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i < p.size()  ++i
induction variable: ['i']
{
L2201: (p[i]=,w) 
L2202: (x[i],r) 
}
array table
-----------------------------------------------
p -> [('[i]', 'w', 'normalized', ['i'], 2201)]
LDEs formed:1

x -> [('[i]', 'r', 'normalized', ['i'], 2202)]
LDEs formed:0

distinct LDEs:
i1=i2
#########################################################################################
loop info: Size i=0  i < x.size()  ++i
induction variable: ['i']
{
L2203: (x[i],r) 
L2204: (p[i],r) 
L2205: (x[i],r) 
}
array table
-----------------------------------------------
x -> [('[i]', 'r', 'normalized', ['i'], 2203), ('[i]', 'r', 'normalized', ['i'], 2205)]
LDEs formed:0

p -> [('[i]', 'r', 'normalized', ['i'], 2204)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i < LENGTH(strikes)  ++i
induction variable: ['i']
{
L2205: (strikes[i],r) 
L2206: (pd[idx]=,w) (p[idx],r) 
}
array table
-----------------------------------------------
p -> [('[idx]', 'r', 'not normalized', ['i'], 2206)]
LDEs formed:0

pd -> [('[idx]', 'w', 'not normalized', ['i'], 2206)]
LDEs formed:1

strikes -> [('[i]', 'r', 'normalized', ['i'], 2205)]
LDEs formed:0

distinct LDEs:
idx=idx
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/variancegamma.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<LENGTH(processes)  i++
induction variable: ['i']
{
L2206: (processes[i].s,r) 
L2207: (processes[i].q,r) 
L2208: (processes[i].r,r) 
L2209: (processes[i].sigma,r) 
L2210: (processes[i].nu,r) 
L2211: (processes[i].theta,r) 
	loop info: Size j=0  j<LENGTH(options)  j++
	induction variable: ['i', 'j']
	{
	L2212: (options[j].t*,r) 
	L2213: (options[j].type,r) (options[j].strike,r) 
	L2214: (results[i][j],r) 
	L2215: (processes[i].s,r) (processes[i].q,r) (processes[i].r,r) 
	L2216: (processes[i].sigma,r) (processes[i].nu,r) 
	L2217: (processes[i].theta,r) 
	}
	loop info: Size j=0  j<LENGTH(options)  j++
	induction variable: ['i', 'j']
	{
	L2218: (optionList[j],r) 
	L2219: (results[i][j],r) 
	L2220: (processes[i].s,r) (processes[i].q,r) (processes[i].r,r) 
	L2221: (processes[i].sigma,r) (processes[i].nu,r) 
	L2222: (processes[i].theta,r) 
	}
 }
array table
-----------------------------------------------
processes -> [('[i]', 'r', 'normalized', ['i', 'j'], 2206), ('[i]', 'r', 'normalized', ['i', 'j'], 2207), ('[i]', 'r', 'normalized', ['i', 'j'], 2208), ('[i]', 'r', 'normalized', ['i', 'j'], 2209), ('[i]', 'r', 'normalized', ['i', 'j'], 2210), ('[i]', 'r', 'normalized', ['i', 'j'], 2211), ('[i]', 'r', 'normalized', ['i', 'j'], 2215), ('[i]', 'r', 'normalized', ['i', 'j'], 2215), ('[i]', 'r', 'normalized', ['i', 'j'], 2215), ('[i]', 'r', 'normalized', ['i', 'j'], 2216), ('[i]', 'r', 'normalized', ['i', 'j'], 2216), ('[i]', 'r', 'normalized', ['i', 'j'], 2217), ('[i]', 'r', 'normalized', ['i', 'j'], 2220), ('[i]', 'r', 'normalized', ['i', 'j'], 2220), ('[i]', 'r', 'normalized', ['i', 'j'], 2220), ('[i]', 'r', 'normalized', ['i', 'j'], 2221), ('[i]', 'r', 'normalized', ['i', 'j'], 2221), ('[i]', 'r', 'normalized', ['i', 'j'], 2222)]
LDEs formed:0

optionList -> [('[j]', 'r', 'normalized', ['i', 'j'], 2218)]
LDEs formed:0

options -> [('[j]', 'r', 'normalized', ['i', 'j'], 2212), ('[j]', 'r', 'normalized', ['i', 'j'], 2213), ('[j]', 'r', 'normalized', ['i', 'j'], 2213)]
LDEs formed:0

results -> [('[i][j]', 'r', 'normalized', ['i', 'j'], 2214), ('[i][j]', 'r', 'normalized', ['i', 'j'], 2219)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/swapforwardmappings.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<nbRates_  ++i
induction variable: ['i']
{
L2220: (forwards_[i]=,w) 
L2221: (accruals_[i]=,w) (rateTimes_[i+1]-,r) (rateTimes_[i],r) 
L2222: (discountFactors_[i+1]=,w) (discountFactors_[i],r) 
L2223: (forwards_[i]*,r) (accruals_[i],r) 
}
array table
-----------------------------------------------
accruals_ -> [('[i]', 'w', 'normalized', ['i'], 2221), ('[i]', 'r', 'normalized', ['i'], 2223)]
LDEs formed:2

discountFactors_ -> [('[i+1]', 'w', 'normalized', ['i'], 2222), ('[i]', 'r', 'normalized', ['i'], 2222)]
LDEs formed:2

forwards_ -> [('[i]', 'w', 'normalized', ['i'], 2220), ('[i]', 'r', 'normalized', ['i'], 2223)]
LDEs formed:2

rateTimes_ -> [('[i+1]', 'r', 'normalized', ['i'], 2221), ('[i]', 'r', 'normalized', ['i'], 2221)]
LDEs formed:0

distinct LDEs:
i1+1=i2
i1+1=i2+1
i1=i2
#########################################################################################
loop info: Size i = 0  i < payoffs.size()  ++i
induction variable: ['i']
{
L2222: (payoffs[i]=,w) 
}
array table
-----------------------------------------------
payoffs -> [('[i]', 'w', 'normalized', ['i'], 2222)]
LDEs formed:1

distinct LDEs:
i1=i2
#########################################################################################
loop info: Size i=0  i < nbRates  ++i
induction variable: ['i']
{
L2223: (bumpedForwards[j]+=,w) 
L2224: (bumpedForwards[j]-=,w) 
L2225: (coinitialJacobian[i][j]=,w) 
}
array table
-----------------------------------------------
coinitialJacobian -> [('[i][j]', 'w', 'not normalized', ['i'], 2225)]
LDEs formed:2

bumpedForwards -> [('[j]', 'w', 'not normalized', ['i'], 2223), ('[j]', 'w', 'not normalized', ['i'], 2224)]
LDEs formed:3

distinct LDEs:
i1=i2,j=j
j=j
#########################################################################################
loop info: Size i=0  i < nbRates  ++i
induction variable: ['i']
{
L2225: (modelJacobian[i][j],r) 
L2226: (coinitialJacobian[i][j],r) 
}
array table
-----------------------------------------------
modelJacobian -> [('[i][j]', 'r', 'not normalized', ['i'], 2225)]
LDEs formed:0

coinitialJacobian -> [('[i][j]', 'r', 'not normalized', ['i'], 2226)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info:  Size spanningForwards = 1  spanningForwards < nbRates  ++spanningForwards
induction variable: ['spanningForwards']
{
	loop info: Size i=0  i < nbRates  ++i
	induction variable: ['spanningForwards', 'i']
	{
	L2227: (bumpedForwards[j]+=,w) 
	L2228: (bumpedForwards[j]-=,w) 
	L2229: (cmsJacobian[i][j]=,w) 
	}
	loop info: Size i=0  i < nbRates  ++i
	induction variable: ['spanningForwards', 'i']
	{
	L2230: (modelJacobian[i][j],r) 
	L2231: (cmsJacobian[i][j],r) 
	}
 }
array table
-----------------------------------------------
modelJacobian -> [('[i][j]', 'r', 'not normalized', ['spanningForwards', 'i'], 2230)]
LDEs formed:0

cmsJacobian -> [('[i][j]', 'w', 'not normalized', ['spanningForwards', 'i'], 2229), ('[i][j]', 'r', 'not normalized', ['spanningForwards', 'i'], 2231)]
LDEs formed:4

bumpedForwards -> [('[j]', 'w', 'not normalized', ['spanningForwards', 'i'], 2227), ('[j]', 'w', 'not normalized', ['spanningForwards', 'i'], 2228)]
LDEs formed:3

distinct LDEs:
i1=i2,j=j
j=j
#########################################################################################
loop info: Size i=0  i<nbRates  ++i
induction variable: ['i']
{
L2229: (rateTimes[i],r) 
L2230: (todaysCoterminalSwapRates[i]+,r) 
L2231: (cotSwapsCovariance[i][i],r) 
L2232: (todaysDiscounts[i],r) 
L2233: (results[i],r) 
L2234: (results[i],r) 
L2235: (errors[i]<<,r) 
L2236: (results[i]-,r) (errors[i],r) 
}
array table
-----------------------------------------------
errors -> [('[i]', 'r', 'normalized', ['i'], 2235), ('[i]', 'r', 'normalized', ['i'], 2236)]
LDEs formed:0

cotSwapsCovariance -> [('[i][i]', 'r', 'normalized', ['i'], 2231)]
LDEs formed:0

todaysCoterminalSwapRates -> [('[i]', 'r', 'normalized', ['i'], 2230)]
LDEs formed:0

results -> [('[i]', 'r', 'normalized', ['i'], 2233), ('[i]', 'r', 'normalized', ['i'], 2234), ('[i]', 'r', 'normalized', ['i'], 2236)]
LDEs formed:0

todaysDiscounts -> [('[i]', 'r', 'normalized', ['i'], 2232)]
LDEs formed:0

rateTimes -> [('[i]', 'r', 'normalized', ['i'], 2229)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size startIndex = 1  startIndex+2 < nbRates  startIndex = startIndex+5
induction variable: ['startIndex']
{
L2230: (rateTimes[startIndex],r) 
L2231: (results[0],r) 
L2232: (errors[0],r) 
L2233: (results[0],r) 
L2234: (errors[0]<<,r) 
}
array table
-----------------------------------------------
rateTimes -> [('[startIndex]', 'r', 'normalized', ['startIndex'], 2230)]
LDEs formed:0

errors -> [('[0]', 'r', 'normalized', ['startIndex'], 2232), ('[0]', 'r', 'normalized', ['startIndex'], 2234)]
LDEs formed:0

results -> [('[0]', 'r', 'normalized', ['startIndex'], 2231), ('[0]', 'r', 'normalized', ['startIndex'], 2233)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/quotes.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Integer i=0  i<3  i++
induction variable: ['i']
{
L2234: (funcs[i],r) 
L2235: (funcs[i],r) 
}
array table
-----------------------------------------------
funcs -> [('[i]', 'r', 'normalized', ['i'], 2234), ('[i]', 'r', 'normalized', ['i'], 2235)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Integer i=0  i<3  i++
induction variable: ['i']
{
L2236: (funcs[i],r) 
L2237: (funcs[i],r) 
}
array table
-----------------------------------------------
funcs -> [('[i]', 'r', 'normalized', ['i'], 2236), ('[i]', 'r', 'normalized', ['i'], 2237)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/digitalcoupon.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i = 0  i< LENGTH(vols)  i++
induction variable: ['i']
{
L2238: (vols[i],r) 
	loop info: Size j=0  j<LENGTH(strikes)  j++
	induction variable: ['i', 'j']
	{
	L2239: (strikes[j],r) 
		loop info: Size k=9  k<10  k++
		induction variable: ['i', 'j', 'k']
		{
			loop info: Size h=0  h<LENGTH(gearings)  h++
			induction variable: ['i', 'j', 'k', 'h']
			{
			L2240: (gearings[h],r) 
			L2241: (spreads[h],r) 
			}
 		}
 	}
 }
array table
-----------------------------------------------
spreads -> [('[h]', 'r', 'normalized', ['i', 'j', 'k', 'h'], 2241)]
LDEs formed:0

gearings -> [('[h]', 'r', 'normalized', ['i', 'j', 'k', 'h'], 2240)]
LDEs formed:0

strikes -> [('[j]', 'r', 'normalized', ['i', 'j', 'k', 'h'], 2239)]
LDEs formed:0

vols -> [('[i]', 'r', 'normalized', ['i', 'j', 'k', 'h'], 2238)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i = 0  i< LENGTH(vols)  i++
induction variable: ['i']
{
L2239: (vols[i],r) 
	loop info: Size j = 0  j< LENGTH(strikes)  j++
	induction variable: ['i', 'j']
	{
	L2240: (strikes[j],r) 
		loop info: Size k = 0  k<10  k++
		induction variable: ['i', 'j', 'k']
		{
		}
 	}
 }
array table
-----------------------------------------------
strikes -> [('[j]', 'r', 'normalized', ['i', 'j', 'k'], 2240)]
LDEs formed:0

vols -> [('[i]', 'r', 'normalized', ['i', 'j', 'k'], 2239)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i = 0  i< LENGTH(vols)  i++
induction variable: ['i']
{
L2240: (vols[i],r) 
	loop info: Size j = 0  j< LENGTH(strikes)  j++
	induction variable: ['i', 'j']
	{
	L2241: (strikes[j],r) 
		loop info: Size k = 0  k<10  k++
		induction variable: ['i', 'j', 'k']
		{
		}
 	}
 }
array table
-----------------------------------------------
strikes -> [('[j]', 'r', 'normalized', ['i', 'j', 'k'], 2241)]
LDEs formed:0

vols -> [('[i]', 'r', 'normalized', ['i', 'j', 'k'], 2240)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i = 0  i< LENGTH(vols)  i++
induction variable: ['i']
{
L2241: (vols[i],r) 
	loop info: Size j = 0  j< LENGTH(strikes)  j++
	induction variable: ['i', 'j']
	{
	L2242: (strikes[j],r) 
		loop info: Size k = 0  k<10  k++
		induction variable: ['i', 'j', 'k']
		{
		}
 	}
 }
array table
-----------------------------------------------
strikes -> [('[j]', 'r', 'normalized', ['i', 'j', 'k'], 2242)]
LDEs formed:0

vols -> [('[i]', 'r', 'normalized', ['i', 'j', 'k'], 2241)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/optionletstripper.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<optionTenors.size()  ++i
induction variable: ['i']
{
L2242: (atmTermVolHandle[i]=,w) 
L2243: (atmTermV[i],r) 
}
array table
-----------------------------------------------
atmTermVolHandle -> [('[i]', 'w', 'normalized', ['i'], 2242)]
LDEs formed:1

atmTermV -> [('[i]', 'r', 'normalized', ['i'], 2243)]
LDEs formed:0

distinct LDEs:
i1=i2
#########################################################################################
loop info: Size tenorIndex=0  tenorIndex<vars.optionTenors.size()  ++tenorIndex
induction variable: ['tenorIndex']
{
	loop info: Size strikeIndex=0  strikeIndex<vars.strikes.size()  ++strikeIndex
	induction variable: ['tenorIndex', 'strikeIndex']
	{
	L2244: (vars.optionTenors[tenorIndex],r) 
	L2245: (vars.strikes[strikeIndex],r) 
	L2246: (vars.termV[tenorIndex][strikeIndex],r) 
	L2247: (vars.optionTenors[tenorIndex]<<,r) 
	L2248: (vars.strikes[strikeIndex],r) 
	}
 }
array table
-----------------------------------------------
vars.strikes -> [('[strikeIndex]', 'r', 'normalized', ['tenorIndex', 'strikeIndex'], 2245), ('[strikeIndex]', 'r', 'normalized', ['tenorIndex', 'strikeIndex'], 2248)]
LDEs formed:0

vars.termV -> [('[tenorIndex][strikeIndex]', 'r', 'normalized', ['tenorIndex', 'strikeIndex'], 2246)]
LDEs formed:0

vars.optionTenors -> [('[tenorIndex]', 'r', 'normalized', ['tenorIndex', 'strikeIndex'], 2244), ('[tenorIndex]', 'r', 'normalized', ['tenorIndex', 'strikeIndex'], 2247)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size tenorIndex=0  tenorIndex<vars.optionTenors.size()  ++tenorIndex
induction variable: ['tenorIndex']
{
	loop info: Size strikeIndex=0  strikeIndex<vars.strikes.size()  ++strikeIndex
	induction variable: ['tenorIndex', 'strikeIndex']
	{
	L2248: (vars.optionTenors[tenorIndex],r) 
	L2249: (vars.strikes[strikeIndex],r) 
	L2250: (vars.termV[tenorIndex][strikeIndex],r) 
	L2251: (vars.optionTenors[tenorIndex]<<,r) 
	L2252: (vars.strikes[strikeIndex],r) 
	}
 }
array table
-----------------------------------------------
vars.strikes -> [('[strikeIndex]', 'r', 'normalized', ['tenorIndex', 'strikeIndex'], 2249), ('[strikeIndex]', 'r', 'normalized', ['tenorIndex', 'strikeIndex'], 2252)]
LDEs formed:0

vars.termV -> [('[tenorIndex][strikeIndex]', 'r', 'normalized', ['tenorIndex', 'strikeIndex'], 2250)]
LDEs formed:0

vars.optionTenors -> [('[tenorIndex]', 'r', 'normalized', ['tenorIndex', 'strikeIndex'], 2248), ('[tenorIndex]', 'r', 'normalized', ['tenorIndex', 'strikeIndex'], 2251)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size strikeIndex=0  strikeIndex<vars.strikes.size()  ++strikeIndex
induction variable: ['strikeIndex']
{
	loop info: Size tenorIndex=0  tenorIndex<vars.optionTenors.size()  ++tenorIndex
	induction variable: ['strikeIndex', 'tenorIndex']
	{
	L2252: (vars.optionTenors[tenorIndex],r) 
	L2253: (vars.strikes[strikeIndex],r) 
	L2254: (vars.optionTenors[tenorIndex],r) 
	L2255: (vars.strikes[strikeIndex],r) 
	L2256: (vars.optionTenors[tenorIndex],r) 
	L2257: (vars.strikes[strikeIndex],r) 
	L2258: (vars.optionTenors[tenorIndex]<<,r) 
	L2259: (vars.strikes[strikeIndex],r) 
	}
 }
array table
-----------------------------------------------
vars.strikes -> [('[strikeIndex]', 'r', 'normalized', ['strikeIndex', 'tenorIndex'], 2253), ('[strikeIndex]', 'r', 'normalized', ['strikeIndex', 'tenorIndex'], 2255), ('[strikeIndex]', 'r', 'normalized', ['strikeIndex', 'tenorIndex'], 2257), ('[strikeIndex]', 'r', 'normalized', ['strikeIndex', 'tenorIndex'], 2259)]
LDEs formed:0

vars.optionTenors -> [('[tenorIndex]', 'r', 'normalized', ['strikeIndex', 'tenorIndex'], 2252), ('[tenorIndex]', 'r', 'normalized', ['strikeIndex', 'tenorIndex'], 2254), ('[tenorIndex]', 'r', 'normalized', ['strikeIndex', 'tenorIndex'], 2256), ('[tenorIndex]', 'r', 'normalized', ['strikeIndex', 'tenorIndex'], 2258)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size strikeIndex=0  strikeIndex<vars.strikes.size()  ++strikeIndex
induction variable: ['strikeIndex']
{
	loop info: Size tenorIndex=0  tenorIndex<vars.optionTenors.size()  ++tenorIndex
	induction variable: ['strikeIndex', 'tenorIndex']
	{
	L2259: (vars.optionTenors[tenorIndex],r) 
	L2260: (vars.strikes[strikeIndex],r) 
	L2261: (vars.optionTenors[tenorIndex],r) 
	L2262: (vars.strikes[strikeIndex],r) 
	L2263: (vars.optionTenors[tenorIndex],r) 
	L2264: (vars.strikes[strikeIndex],r) 
	L2265: (vars.optionTenors[tenorIndex]<<,r) 
	L2266: (vars.strikes[strikeIndex],r) 
	}
 }
array table
-----------------------------------------------
vars.strikes -> [('[strikeIndex]', 'r', 'normalized', ['strikeIndex', 'tenorIndex'], 2260), ('[strikeIndex]', 'r', 'normalized', ['strikeIndex', 'tenorIndex'], 2262), ('[strikeIndex]', 'r', 'normalized', ['strikeIndex', 'tenorIndex'], 2264), ('[strikeIndex]', 'r', 'normalized', ['strikeIndex', 'tenorIndex'], 2266)]
LDEs formed:0

vars.optionTenors -> [('[tenorIndex]', 'r', 'normalized', ['strikeIndex', 'tenorIndex'], 2259), ('[tenorIndex]', 'r', 'normalized', ['strikeIndex', 'tenorIndex'], 2261), ('[tenorIndex]', 'r', 'normalized', ['strikeIndex', 'tenorIndex'], 2263), ('[tenorIndex]', 'r', 'normalized', ['strikeIndex', 'tenorIndex'], 2265)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/himalayaoption.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/overnightindexedswap.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<LENGTH(lengths)  i++
induction variable: ['i']
{
	loop info: Size j=0  j<LENGTH(spreads)  j++
	induction variable: ['i', 'j']
	{
	L2266: (lengths[i],r) (spreads[j],r) 
	L2267: (lengths[i],r) (spreads[j],r) 
	L2268: (lengths[i]<<,r) 
	L2269: (spreads[j],r) 
	}
 }
array table
-----------------------------------------------
lengths -> [('[i]', 'r', 'normalized', ['i', 'j'], 2266), ('[i]', 'r', 'normalized', ['i', 'j'], 2267), ('[i]', 'r', 'normalized', ['i', 'j'], 2268)]
LDEs formed:0

spreads -> [('[j]', 'r', 'normalized', ['i', 'j'], 2266), ('[j]', 'r', 'normalized', ['i', 'j'], 2267), ('[j]', 'r', 'normalized', ['i', 'j'], 2269)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<LENGTH(lengths)  i++
induction variable: ['i']
{
	loop info: Size j=0  j<LENGTH(rates)  j++
	induction variable: ['i', 'j']
	{
	L2270: (lengths[i],r) (rates[j],r) 
	L2271: (lengths[i],r) (rates[j],r) 
	L2272: (lengths[i]<<,r) 
	L2273: (rates[j],r) 
	}
 }
array table
-----------------------------------------------
lengths -> [('[i]', 'r', 'normalized', ['i', 'j'], 2270), ('[i]', 'r', 'normalized', ['i', 'j'], 2271), ('[i]', 'r', 'normalized', ['i', 'j'], 2272)]
LDEs formed:0

rates -> [('[j]', 'r', 'normalized', ['i', 'j'], 2270), ('[j]', 'r', 'normalized', ['i', 'j'], 2271), ('[j]', 'r', 'normalized', ['i', 'j'], 2273)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i = 0  i < LENGTH(depositData)  i++
induction variable: ['i']
{
L2274: (depositData[i].rate,r) 
L2275: (depositData[i].n*,r) (depositData[i].unit,r) 
L2276: (depositData[i].settlementDays,r) 
}
array table
-----------------------------------------------
depositData -> [('[i]', 'r', 'normalized', ['i'], 2274), ('[i]', 'r', 'normalized', ['i'], 2275), ('[i]', 'r', 'normalized', ['i'], 2275), ('[i]', 'r', 'normalized', ['i'], 2276)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i = 0  i < LENGTH(fraData)  i++
induction variable: ['i']
{
L2277: (fraData[i].rate,r) 
L2278: (fraData[i].nExpiry,r) 
L2279: (fraData[i].nMaturity,r) 
L2280: (fraData[i].settlementDays,r) 
}
array table
-----------------------------------------------
fraData -> [('[i]', 'r', 'normalized', ['i'], 2277), ('[i]', 'r', 'normalized', ['i'], 2278), ('[i]', 'r', 'normalized', ['i'], 2279), ('[i]', 'r', 'normalized', ['i'], 2280)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i = 0  i < LENGTH(eoniaSwapData)  i++
induction variable: ['i']
{
L2281: (eoniaSwapData[i].rate,r) 
L2282: (eoniaSwapData[i].n*,r) (eoniaSwapData[i].unit,r) 
L2283: (eoniaSwapData[i].settlementDays,r) 
}
array table
-----------------------------------------------
eoniaSwapData -> [('[i]', 'r', 'normalized', ['i'], 2281), ('[i]', 'r', 'normalized', ['i'], 2282), ('[i]', 'r', 'normalized', ['i'], 2282), ('[i]', 'r', 'normalized', ['i'], 2283)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i = 0  i < LENGTH(swapData)  i++
induction variable: ['i']
{
L2284: (swapData[i].rate,r) 
L2285: (swapData[i].nIndexUnits*,r) (swapData[i].indexUnit,r) 
L2286: (swapData[i].nTermUnits*,r) (swapData[i].termUnit,r) 
}
array table
-----------------------------------------------
swapData -> [('[i]', 'r', 'normalized', ['i'], 2284), ('[i]', 'r', 'normalized', ['i'], 2285), ('[i]', 'r', 'normalized', ['i'], 2285), ('[i]', 'r', 'normalized', ['i'], 2286), ('[i]', 'r', 'normalized', ['i'], 2286)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i = 0  i < LENGTH(eoniaSwapData)  i++
induction variable: ['i']
{
L2287: (eoniaSwapData[i].rate,r) 
L2288: (eoniaSwapData[i].n*,r) (eoniaSwapData[i].unit,r) 
}
array table
-----------------------------------------------
eoniaSwapData -> [('[i]', 'r', 'normalized', ['i'], 2287), ('[i]', 'r', 'normalized', ['i'], 2288), ('[i]', 'r', 'normalized', ['i'], 2288)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/matrices.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size k=0  k<LENGTH(testMatrices)  k++
induction variable: ['k']
{
L2289: (testMatrices[k],r) 
	loop info: Size i=0  i<N  i++
	induction variable: ['k', 'i']
	{
		loop info: Size j=0  j<N  j++
		induction variable: ['k', 'i', 'j']
		{
		}
	L2290: (eigenValues[i]*,r) 
	L2291: (eigenValues[i],r) 
	L2292: (eigenValues[i],r) 
	}
 }
array table
-----------------------------------------------
eigenValues -> [('[i]', 'r', 'normalized', ['k', 'i', 'j'], 2290), ('[i]', 'r', 'normalized', ['k', 'i', 'j'], 2291), ('[i]', 'r', 'normalized', ['k', 'i', 'j'], 2292)]
LDEs formed:0

testMatrices -> [('[k]', 'r', 'normalized', ['k', 'i', 'j'], 2289)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size j = 0  j < LENGTH(testMatrices)  j++
induction variable: ['j']
{
L2290: (testMatrices[j],r) 
	loop info: Size i=0  i < S.rows()  i++
	induction variable: ['j', 'i']
	{
	L2291: (S[i][i],r) (s[i],r) 
	}
 }
array table
-----------------------------------------------
S -> [('[i][i]', 'r', 'normalized', ['j', 'i'], 2291)]
LDEs formed:0

testMatrices -> [('[j]', 'r', 'normalized', ['j', 'i'], 2290)]
LDEs formed:0

s -> [('[i]', 'r', 'normalized', ['j', 'i'], 2291)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size j = 0  j < LENGTH(testMatrices)  j++
induction variable: ['j']
{
L2292: (testMatrices[j],r) 
	loop info: Size i=0  i < P.columns()  ++i
	induction variable: ['j', 'i']
	{
	L2293: (ipvt[i],r) 
	}
 }
array table
-----------------------------------------------
testMatrices -> [('[j]', 'r', 'normalized', ['j', 'i'], 2292)]
LDEs formed:0

ipvt -> [('[i]', 'r', 'normalized', ['j', 'i'], 2293)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i < std::min(bigM.rows(), bigM.columns())  ++i
induction variable: ['i']
{
L2294: (bigM[i][i]=,w) 
}
array table
-----------------------------------------------
bigM -> [('[i][i]', 'w', 'normalized', ['i'], 2294)]
LDEs formed:2

distinct LDEs:
i1=i2,i1=i2
#########################################################################################
loop info: Size j = 0  j < LENGTH(testMatrices)  j++
induction variable: ['j']
{
L2295: (testMatrices[j],r) 
	loop info: Size k=0  k < 10  ++k
	induction variable: ['j', 'k']
	{
		loop info: Array::iterator iter = b.begin()  iter != b.end()  ++iter
		induction variable: ['j', 'k', 'iter']
		{
		}
		loop info: Size i=0  i<n  ++i
		induction variable: ['j', 'k', 'iter', 'i']
			{
			L2296: (w[i],r) 
			L2297: (w[i],r) 
				loop info: Size j=0  j<n  ++j
				induction variable: ['j', 'k', 'iter', 'i']
					{
					L2298: (xr[j]+=,w) (V[j][i],r) 
					}
 			}
 	}
 }
array table
-----------------------------------------------
xr -> [('[j]', 'w', 'normalized', ['j', 'k', 'iter', 'i'], 2298)]
LDEs formed:1

testMatrices -> [('[j]', 'r', 'normalized', ['j', 'k', 'iter', 'i'], 2295)]
LDEs formed:0

w -> [('[i]', 'r', 'normalized', ['j', 'k', 'iter', 'i'], 2296), ('[i]', 'r', 'normalized', ['j', 'k', 'iter', 'i'], 2297)]
LDEs formed:0

V -> [('[j][i]', 'r', 'normalized', ['j', 'k', 'iter', 'i'], 2298)]
LDEs formed:0

distinct LDEs:
j1=j2
#########################################################################################
loop info: Size j = 0  j < LENGTH(testMatrices)  j++
induction variable: ['j']
{
L2299: (testMatrices[j],r) 
	loop info: Size i=0  i < A.rows()  ++i
	induction variable: ['j', 'i']
	{
	}
 }
array table
-----------------------------------------------
testMatrices -> [('[j]', 'r', 'normalized', ['j', 'i'], 2299)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size j=0  j<LENGTH(testMatrices)  ++j
induction variable: ['j']
{
L2300: (testMatrices[j],r) 
L2301: (expected[j]-,r) 
L2302: (testMatrices[j],r) 
L2303: (expected[j],r) 
}
array table
-----------------------------------------------
expected -> [('[j]', 'r', 'normalized', ['j'], 2301), ('[j]', 'r', 'normalized', ['j'], 2303)]
LDEs formed:0

testMatrices -> [('[j]', 'r', 'normalized', ['j'], 2300), ('[j]', 'r', 'normalized', ['j'], 2302)]
LDEs formed:0

distinct LDEs:
#########################################################################################
L2303: (m[0][0],r) 
L2304: (m[0][1],r) 
L2305: (m[0][2],r) 
L2306: (m[1][0],r) 
L2307: (m[1][1],r) 
L2308: (m[1][2],r) 
L2309: (m[2][0],r) 
L2310: (m[2][1],r) 
L2311: (m[2][2],r) 
}
array table
-----------------------------------------------
m -> [('[0][0]', 'r', 'normalized', ['j', 'iter'], 2303), ('[0][1]', 'r', 'normalized', ['j', 'iter'], 2304), ('[0][2]', 'r', 'normalized', ['j', 'iter'], 2305), ('[1][0]', 'r', 'normalized', ['j', 'iter'], 2306), ('[1][1]', 'r', 'normalized', ['j', 'iter'], 2307), ('[1][2]', 'r', 'normalized', ['j', 'iter'], 2308), ('[2][0]', 'r', 'normalized', ['j', 'iter'], 2309), ('[2][1]', 'r', 'normalized', ['j', 'iter'], 2310), ('[2][2]', 'r', 'normalized', ['j', 'iter'], 2311)]
LDEs formed:0

distinct LDEs:
#########################################################################################
	loop info: Size j=0  j < dimension  ++j
	induction variable: ['i', 'j', 'k']
		{
		L2312: (test[i][j],r) 
		L2313: (test[i][j]*,r) (test[i][j],r) 
		}
 }
array table
-----------------------------------------------
test -> [('[i][j]', 'r', 'normalized', ['i', 'j', 'k'], 2312), ('[i][j]', 'r', 'normalized', ['i', 'j', 'k'], 2313), ('[i][j]', 'r', 'normalized', ['i', 'j', 'k'], 2313)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/array.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: i=0  i<size  ++i
induction variable: ['i']
{
L2314: (a3[i],r) 
L2315: (a3[i],r) 
}
array table
-----------------------------------------------
a3 -> [('[i]', 'r', 'normalized', ['i'], 2314), ('[i]', 'r', 'normalized', ['i'], 2315)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: i=0  i<size  i++
induction variable: ['i']
{
L2316: (a4[i],r) 
L2317: (a4[i],r) 
}
array table
-----------------------------------------------
a4 -> [('[i]', 'r', 'normalized', ['i'], 2316), ('[i]', 'r', 'normalized', ['i'], 2317)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: i=0  i<a3.size()  i++
induction variable: ['i']
{
L2318: (a6[i],r) (a3[i],r) 
L2319: (a3[i],r) 
L2320: (a6[i],r) 
}
array table
-----------------------------------------------
a3 -> [('[i]', 'r', 'normalized', ['i'], 2318), ('[i]', 'r', 'normalized', ['i'], 2319)]
LDEs formed:0

a6 -> [('[i]', 'r', 'normalized', ['i'], 2318), ('[i]', 'r', 'normalized', ['i'], 2320)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: i=0  i<size  i++
induction variable: ['i']
{
L2321: (temp2[i],r) 
L2322: (temp2[i],r) 
}
array table
-----------------------------------------------
temp2 -> [('[i]', 'r', 'normalized', ['i'], 2321), ('[i]', 'r', 'normalized', ['i'], 2322)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: i=0  i<size  i++
induction variable: ['i']
{
L2323: (a7[i],r) 
L2324: (a7[i],r) 
}
array table
-----------------------------------------------
a7 -> [('[i]', 'r', 'normalized', ['i'], 2323), ('[i]', 'r', 'normalized', ['i'], 2324)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: i=0  i<a7.size()  i++
induction variable: ['i']
{
L2325: (a8[i],r) (a7[i],r) 
L2326: (a7[i],r) 
L2327: (a8[i],r) 
}
array table
-----------------------------------------------
a8 -> [('[i]', 'r', 'normalized', ['i'], 2325), ('[i]', 'r', 'normalized', ['i'], 2327)]
LDEs formed:0

a7 -> [('[i]', 'r', 'normalized', ['i'], 2325), ('[i]', 'r', 'normalized', ['i'], 2326)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: i=0  i<size  i++
induction variable: ['i']
{
L2327: (a9[i],r) 
L2328: (a9[i],r) 
}
array table
-----------------------------------------------
a9 -> [('[i]', 'r', 'normalized', ['i'], 2327), ('[i]', 'r', 'normalized', ['i'], 2328)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: i=0  i < a10.size()  i++
induction variable: ['i']
{
L2329: (a10[i]=,w) 
}
array table
-----------------------------------------------
a10 -> [('[i]', 'w', 'normalized', ['i'], 2329)]
LDEs formed:1

distinct LDEs:
i1=i2
#########################################################################################
loop info: i=0  i < a10.size()  i++
induction variable: ['i']
{
L2330: (a10[i]-,r) 
L2331: (a10[i]<<,r) 
}
array table
-----------------------------------------------
a10 -> [('[i]', 'r', 'normalized', ['i'], 2330), ('[i]', 'r', 'normalized', ['i'], 2331)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i < a.size()  ++i
induction variable: ['i']
{
L2332: (a[i]=,w) 
}
array table
-----------------------------------------------
a -> [('[i]', 'w', 'normalized', ['i'], 2332)]
LDEs formed:1

distinct LDEs:
i1=i2
#########################################################################################
loop info: Size i=0  i < a.size()  ++i
induction variable: ['i']
{
L2333: (p[i]-,r) (a[i],r) 
L2334: (e[i]-,r) (a[i],r) 
L2335: (l[i]-,r) (a[i],r) 
L2336: (s[i]-,r) (a[i],r) 
}
array table
-----------------------------------------------
a -> [('[i]', 'r', 'normalized', ['i'], 2333), ('[i]', 'r', 'normalized', ['i'], 2334), ('[i]', 'r', 'normalized', ['i'], 2335), ('[i]', 'r', 'normalized', ['i'], 2336)]
LDEs formed:0

p -> [('[i]', 'r', 'normalized', ['i'], 2333)]
LDEs formed:0

s -> [('[i]', 'r', 'normalized', ['i'], 2336)]
LDEs formed:0

e -> [('[i]', 'r', 'normalized', ['i'], 2334)]
LDEs formed:0

l -> [('[i]', 'r', 'normalized', ['i'], 2335)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/jumpdiffusion.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<LENGTH(values)  i++
induction variable: ['i']
{
L2336: (values[i].type,r) (values[i].strike,r) 
L2337: (values[i].t*,r) 
L2338: (values[i].s,r) 
L2339: (values[i].q,r) 
L2340: (values[i].r,r) 
L2341: (values[i].jumpIntensity,r) 
L2342: (values[i].v*,r) 
L2343: (values[i].gamma/,r) (values[i].jumpIntensity,r) 
L2344: (values[i].v*,r) (values[i].gamma,r) 
L2345: (values[i].jumpIntensity*,r) 
L2346: (values[i].v,r) 
L2347: (values[i].result,r) 
L2348: (values[i].tol,r) 
L2349: (values[i].s,r) (values[i].q,r) (values[i].r,r) 
L2350: (values[i].v,r) (values[i].jumpIntensity,r) 
L2351: (values[i].gamma,r) (values[i].result,r) 
L2352: (values[i].tol,r) 
}
array table
-----------------------------------------------
values -> [('[i]', 'r', 'normalized', ['i'], 2336), ('[i]', 'r', 'normalized', ['i'], 2336), ('[i]', 'r', 'normalized', ['i'], 2337), ('[i]', 'r', 'normalized', ['i'], 2338), ('[i]', 'r', 'normalized', ['i'], 2339), ('[i]', 'r', 'normalized', ['i'], 2340), ('[i]', 'r', 'normalized', ['i'], 2341), ('[i]', 'r', 'normalized', ['i'], 2342), ('[i]', 'r', 'normalized', ['i'], 2343), ('[i]', 'r', 'normalized', ['i'], 2343), ('[i]', 'r', 'normalized', ['i'], 2344), ('[i]', 'r', 'normalized', ['i'], 2344), ('[i]', 'r', 'normalized', ['i'], 2345), ('[i]', 'r', 'normalized', ['i'], 2346), ('[i]', 'r', 'normalized', ['i'], 2347), ('[i]', 'r', 'normalized', ['i'], 2348), ('[i]', 'r', 'normalized', ['i'], 2349), ('[i]', 'r', 'normalized', ['i'], 2349), ('[i]', 'r', 'normalized', ['i'], 2349), ('[i]', 'r', 'normalized', ['i'], 2350), ('[i]', 'r', 'normalized', ['i'], 2350), ('[i]', 'r', 'normalized', ['i'], 2351), ('[i]', 'r', 'normalized', ['i'], 2351), ('[i]', 'r', 'normalized', ['i'], 2352)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<LENGTH(types)  i++
induction variable: ['i']
{
	loop info: Size j=0  j<LENGTH(strikes)  j++
	induction variable: ['i', 'j']
	{
		loop info: Size jj1=0  jj1<LENGTH(jInt)  jj1++
		induction variable: ['i', 'j', 'jj1']
		{
		L2353: (jInt[jj1],r) 
			loop info: Size jj2=0  jj2<LENGTH(mLJ)  jj2++
			induction variable: ['i', 'j', 'jj1', 'jj2']
			{
			L2354: (mLJ[jj2],r) 
				loop info: Size jj3=0  jj3<LENGTH(jV)  jj3++
				induction variable: ['i', 'j', 'jj1', 'jj2', 'jj3']
				{
				L2355: (jV[jj3],r) 
					loop info: Size k=0  k<LENGTH(residualTimes)  k++
					induction variable: ['i', 'j', 'jj1', 'jj2', 'jj3', 'k']
					{
					L2356: (residualTimes[k]*,r) 
						loop info: Size kk=0  kk<1  kk++
						induction variable: ['i', 'j', 'jj1', 'jj2', 'jj3', 'k', 'kk']
						{
						L2357: (types[i],r) (strikes[j],r) 
						L2358: (types[i],r) (strikes[j],r) 
						L2359: (types[i],r) (strikes[j],r) 
						L2360: (types[i],r) (strikes[j],r) 
							loop info: Size l=0  l<LENGTH(underlyings)  l++
							induction variable: ['i', 'j', 'jj1', 'jj2', 'jj3', 'k', 'kk', 'l']
							{
							L2361: (underlyings[l],r) 
								loop info: Size m=0  m<LENGTH(qRates)  m++
								induction variable: ['i', 'j', 'jj1', 'jj2', 'jj3', 'k', 'kk', 'l', 'm']
								{
								L2362: (qRates[m],r) 
									loop info: Size n=0  n<LENGTH(rRates)  n++
									induction variable: ['i', 'j', 'jj1', 'jj2', 'jj3', 'k', 'kk', 'l', 'm', 'n']
									{
									L2363: (rRates[n],r) 
										loop info: Size p=0  p<LENGTH(vols)  p++
										induction variable: ['i', 'j', 'jj1', 'jj2', 'jj3', 'k', 'kk', 'l', 'm', 'n', 'p']
										{
										L2364: (vols[p],r) 
										L2365: (calculated["delta"]=,w) 
										L2366: (calculated["gamma"]=,w) 
										L2367: (calculated["theta"]=,w) 
										L2368: (calculated["rho"]=,w) 
										L2369: (calculated["divRho"]=,w) 
										L2370: (calculated["vega"]=,w) 
										L2371: (expected["delta"]=,w) 
										L2372: (expected["gamma"]=,w) 
										L2373: (expected["rho"]=,w) 
										L2374: (expected["divRho"]=,w) 
										L2375: (expected["vega"]=,w) 
										L2376: (expected["theta"]=,w) 
										L2377: (calculated[greek],r) 
										L2378: (jInt[jj1],r) (mLJ[jj2],r) 
										L2379: (jV[jj3],r) 
										}
 									}
 								}
 							}
 						}
 					}
 				}
 			}
 		}
 	}
 }
array table
-----------------------------------------------
residualTimes -> [('[k]', 'r', 'normalized', ['i', 'j', 'jj1', 'jj2', 'jj3', 'k', 'kk', 'l', 'm', 'n', 'p'], 2356)]
LDEs formed:0

rRates -> [('[n]', 'r', 'normalized', ['i', 'j', 'jj1', 'jj2', 'jj3', 'k', 'kk', 'l', 'm', 'n', 'p'], 2363)]
LDEs formed:0

mLJ -> [('[jj2]', 'r', 'normalized', ['i', 'j', 'jj1', 'jj2', 'jj3', 'k', 'kk', 'l', 'm', 'n', 'p'], 2354), ('[jj2]', 'r', 'normalized', ['i', 'j', 'jj1', 'jj2', 'jj3', 'k', 'kk', 'l', 'm', 'n', 'p'], 2378)]
LDEs formed:0

jV -> [('[jj3]', 'r', 'normalized', ['i', 'j', 'jj1', 'jj2', 'jj3', 'k', 'kk', 'l', 'm', 'n', 'p'], 2355), ('[jj3]', 'r', 'normalized', ['i', 'j', 'jj1', 'jj2', 'jj3', 'k', 'kk', 'l', 'm', 'n', 'p'], 2379)]
LDEs formed:0

qRates -> [('[m]', 'r', 'normalized', ['i', 'j', 'jj1', 'jj2', 'jj3', 'k', 'kk', 'l', 'm', 'n', 'p'], 2362)]
LDEs formed:0

strikes -> [('[j]', 'r', 'normalized', ['i', 'j', 'jj1', 'jj2', 'jj3', 'k', 'kk', 'l', 'm', 'n', 'p'], 2357), ('[j]', 'r', 'normalized', ['i', 'j', 'jj1', 'jj2', 'jj3', 'k', 'kk', 'l', 'm', 'n', 'p'], 2358), ('[j]', 'r', 'normalized', ['i', 'j', 'jj1', 'jj2', 'jj3', 'k', 'kk', 'l', 'm', 'n', 'p'], 2359), ('[j]', 'r', 'normalized', ['i', 'j', 'jj1', 'jj2', 'jj3', 'k', 'kk', 'l', 'm', 'n', 'p'], 2360)]
LDEs formed:0

jInt -> [('[jj1]', 'r', 'normalized', ['i', 'j', 'jj1', 'jj2', 'jj3', 'k', 'kk', 'l', 'm', 'n', 'p'], 2353), ('[jj1]', 'r', 'normalized', ['i', 'j', 'jj1', 'jj2', 'jj3', 'k', 'kk', 'l', 'm', 'n', 'p'], 2378)]
LDEs formed:0

underlyings -> [('[l]', 'r', 'normalized', ['i', 'j', 'jj1', 'jj2', 'jj3', 'k', 'kk', 'l', 'm', 'n', 'p'], 2361)]
LDEs formed:0

vols -> [('[p]', 'r', 'normalized', ['i', 'j', 'jj1', 'jj2', 'jj3', 'k', 'kk', 'l', 'm', 'n', 'p'], 2364)]
LDEs formed:0

expected -> [('["delta"]', 'w', 'not normalized', ['i', 'j', 'jj1', 'jj2', 'jj3', 'k', 'kk', 'l', 'm', 'n', 'p'], 2371), ('["gamma"]', 'w', 'not normalized', ['i', 'j', 'jj1', 'jj2', 'jj3', 'k', 'kk', 'l', 'm', 'n', 'p'], 2372), ('["rho"]', 'w', 'not normalized', ['i', 'j', 'jj1', 'jj2', 'jj3', 'k', 'kk', 'l', 'm', 'n', 'p'], 2373), ('["divRho"]', 'w', 'not normalized', ['i', 'j', 'jj1', 'jj2', 'jj3', 'k', 'kk', 'l', 'm', 'n', 'p'], 2374), ('["vega"]', 'w', 'not normalized', ['i', 'j', 'jj1', 'jj2', 'jj3', 'k', 'kk', 'l', 'm', 'n', 'p'], 2375), ('["theta"]', 'w', 'not normalized', ['i', 'j', 'jj1', 'jj2', 'jj3', 'k', 'kk', 'l', 'm', 'n', 'p'], 2376)]
LDEs formed:21

calculated -> [('["delta"]', 'w', 'not normalized', ['i', 'j', 'jj1', 'jj2', 'jj3', 'k', 'kk', 'l', 'm', 'n', 'p'], 2365), ('["gamma"]', 'w', 'not normalized', ['i', 'j', 'jj1', 'jj2', 'jj3', 'k', 'kk', 'l', 'm', 'n', 'p'], 2366), ('["theta"]', 'w', 'not normalized', ['i', 'j', 'jj1', 'jj2', 'jj3', 'k', 'kk', 'l', 'm', 'n', 'p'], 2367), ('["rho"]', 'w', 'not normalized', ['i', 'j', 'jj1', 'jj2', 'jj3', 'k', 'kk', 'l', 'm', 'n', 'p'], 2368), ('["divRho"]', 'w', 'not normalized', ['i', 'j', 'jj1', 'jj2', 'jj3', 'k', 'kk', 'l', 'm', 'n', 'p'], 2369), ('["vega"]', 'w', 'not normalized', ['i', 'j', 'jj1', 'jj2', 'jj3', 'k', 'kk', 'l', 'm', 'n', 'p'], 2370), ('[greek]', 'r', 'not normalized', ['i', 'j', 'jj1', 'jj2', 'jj3', 'k', 'kk', 'l', 'm', 'n', 'p'], 2377)]
LDEs formed:27

types -> [('[i]', 'r', 'normalized', ['i', 'j', 'jj1', 'jj2', 'jj3', 'k', 'kk', 'l', 'm', 'n', 'p'], 2357), ('[i]', 'r', 'normalized', ['i', 'j', 'jj1', 'jj2', 'jj3', 'k', 'kk', 'l', 'm', 'n', 'p'], 2358), ('[i]', 'r', 'normalized', ['i', 'j', 'jj1', 'jj2', 'jj3', 'k', 'kk', 'l', 'm', 'n', 'p'], 2359), ('[i]', 'r', 'normalized', ['i', 'j', 'jj1', 'jj2', 'jj3', 'k', 'kk', 'l', 'm', 'n', 'p'], 2360)]
LDEs formed:0

distinct LDEs:
"gamma"="divRho"
"divRho"="divRho"
"theta"="theta"
"vega"="theta"
"divRho"="vega"
"rho"="rho"
"gamma"="vega"
"delta"="delta"
"rho"="vega"
"delta"="theta"
"rho"="theta"
"divRho"="theta"
"delta"="rho"
"gamma"="theta"
"vega"="vega"
"rho"=greek
"delta"="divRho"
"delta"=greek
"gamma"=greek
"gamma"="rho"
"vega"=greek
"delta"="gamma"
"gamma"="gamma"
"delta"="vega"
"rho"="divRho"
"theta"=greek
"divRho"=greek
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/swaptionvolatilitymatrix.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<atm.tenors.options.size()  ++i
induction variable: ['i']
{
L2361: (atm.tenors.options[i],r) 
L2362: (atm.tenors.options[i]<<,r) 
L2363: (atm.tenors.options[i]<<,r) 
}
array table
-----------------------------------------------
atm.tenors.options -> [('[i]', 'r', 'normalized', ['i'], 2361), ('[i]', 'r', 'normalized', ['i'], 2362), ('[i]', 'r', 'normalized', ['i'], 2363)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size j=0  j<atm.tenors.swaps.size()  j++
induction variable: ['j']
{
L2364: (atm.tenors.swaps[j],r) 
L2365: (atm.tenors.swaps[j],r) 
L2366: (atm.tenors.swaps[j]<<,r) 
L2367: (atm.tenors.swaps[j],r) 
L2368: (atm.tenors.swaps[j],r) 
	loop info: Size i=0  i<atm.tenors.options.size()  ++i
	induction variable: ['j', 'i']
	{
	L2369: (atm.vols[i][j],r) 
	L2370: (atm.tenors.options[i],r) 
	L2371: (atm.tenors.swaps[j],r) 
	L2372: (atm.tenors.options[i]<<,r) 
	L2373: (atm.tenors.swaps[j]<<,r) 
	L2374: (atm.tenors.options[i],r) 
	L2375: (atm.tenors.swaps[j],r) 
	L2376: (atm.tenors.options[i]<<,r) 
	L2377: (atm.tenors.swaps[j]<<,r) 
	L2378: (atm.tenors.options[i]<<,r) 
	L2379: (atm.tenors.swaps[j]<<,r) 
	L2380: (atm.tenors.options[i],r) 
	L2381: (atm.tenors.options[i]<<,r) 
	L2382: (atm.tenors.swaps[j]<<,r) 
	L2383: (atm.tenors.options[i]<<,r) 
	L2384: (atm.tenors.swaps[j]<<,r) 
	}
 }
array table
-----------------------------------------------
atm.vols -> [('[i][j]', 'r', 'normalized', ['j', 'i'], 2369)]
LDEs formed:0

atm.tenors.swaps -> [('[j]', 'r', 'normalized', ['j', 'i'], 2364), ('[j]', 'r', 'normalized', ['j', 'i'], 2365), ('[j]', 'r', 'normalized', ['j', 'i'], 2366), ('[j]', 'r', 'normalized', ['j', 'i'], 2367), ('[j]', 'r', 'normalized', ['j', 'i'], 2368), ('[j]', 'r', 'normalized', ['j', 'i'], 2371), ('[j]', 'r', 'normalized', ['j', 'i'], 2373), ('[j]', 'r', 'normalized', ['j', 'i'], 2375), ('[j]', 'r', 'normalized', ['j', 'i'], 2377), ('[j]', 'r', 'normalized', ['j', 'i'], 2379), ('[j]', 'r', 'normalized', ['j', 'i'], 2382), ('[j]', 'r', 'normalized', ['j', 'i'], 2384)]
LDEs formed:0

atm.tenors.options -> [('[i]', 'r', 'normalized', ['j', 'i'], 2370), ('[i]', 'r', 'normalized', ['j', 'i'], 2372), ('[i]', 'r', 'normalized', ['j', 'i'], 2374), ('[i]', 'r', 'normalized', ['j', 'i'], 2376), ('[i]', 'r', 'normalized', ['j', 'i'], 2378), ('[i]', 'r', 'normalized', ['j', 'i'], 2380), ('[i]', 'r', 'normalized', ['j', 'i'], 2381), ('[i]', 'r', 'normalized', ['j', 'i'], 2383)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/garch.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: std::size_t i = 0  i < 50000  ++i, d += 1
induction variable: ['i', 'd']
{
L2384: (ts[d]=,w) 
}
array table
-----------------------------------------------
ts -> [('[d]', 'w', 'normalized', ['i', 'd'], 2384)]
LDEs formed:1

distinct LDEs:
d1=d2
#########################################################################################
loop info: std::size_t i = 0  i < 10  ++i, d += 1
induction variable: ['i', 'd']
{
L2385: (ts[d]=,w) 
}
array table
-----------------------------------------------
ts -> [('[d]', 'w', 'normalized', ['i', 'd'], 2385)]
LDEs formed:1

distinct LDEs:
d1=d2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/curvestates.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=1  i<=N  ++i
induction variable: ['i']
{
L2386: (coterminalAnnuity[N-1]=,w) (accruals[N-1]*,r) (todaysDiscounts[N],r) 
L2387: (coterminalAnnuity[N-i]=,w) (coterminalAnnuity[N-i+1]+,r) 
L2388: (accruals[N-i]*,r) (todaysDiscounts[N-i+1],r) 
L2389: (todaysDiscounts[N-i]-,r) (todaysDiscounts[N],r) 
L2390: (todaysCoterminalSwapRates[N-i]=,w) 
L2391: (coterminalAnnuity[N-i],r) 
}
array table
-----------------------------------------------
coterminalAnnuity -> [('[N-1]', 'w', 'not normalized', ['i'], 2386), ('[N-i]', 'w', 'not normalized', ['i'], 2387), ('[N-i+1]', 'r', 'not normalized', ['i'], 2387), ('[N-i]', 'r', 'not normalized', ['i'], 2391)]
LDEs formed:7

accruals -> [('[N-1]', 'r', 'not normalized', ['i'], 2386), ('[N-i]', 'r', 'not normalized', ['i'], 2388)]
LDEs formed:0

todaysCoterminalSwapRates -> [('[N-i]', 'w', 'not normalized', ['i'], 2390)]
LDEs formed:1

todaysDiscounts -> [('[N]', 'r', 'not normalized', ['i'], 2386), ('[N-i+1]', 'r', 'not normalized', ['i'], 2388), ('[N-i]', 'r', 'not normalized', ['i'], 2389), ('[N]', 'r', 'not normalized', ['i'], 2389)]
LDEs formed:0

distinct LDEs:
N-1=N-1
N-1=N-i2+1
N-i1=N-i2
N-i1=N-i2+1
N-1=N-i2
#########################################################################################
loop info: Size i = 0  i<nbRates  ++i
induction variable: ['i']
{
L2390: (lmmDrifts[i]<<,r) (cmsDrifts[i]<<,r) 
}
array table
-----------------------------------------------
lmmDrifts -> [('[i]', 'r', 'normalized', ['i'], 2390)]
LDEs formed:0

cmsDrifts -> [('[i]', 'r', 'normalized', ['i'], 2390)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/integrals.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i < LENGTH(nr)  ++i
induction variable: ['i']
{
L2391: (nr[i],r) 
L2392: (expected[i],r) 
L2393: (expected[i],r) 
L2394: (expected[i],r) 
L2395: (expected[i],r) 
}
array table
-----------------------------------------------
expected -> [('[i]', 'r', 'normalized', ['i'], 2392), ('[i]', 'r', 'normalized', ['i'], 2393), ('[i]', 'r', 'normalized', ['i'], 2394), ('[i]', 'r', 'normalized', ['i'], 2395)]
LDEs formed:0

nr -> [('[i]', 'r', 'normalized', ['i'], 2391)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/shortratemodels.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<LENGTH(data)  i++
induction variable: ['i']
{
L2392: (data[i].volatility,r) 
L2393: (data[i].start,r) 
L2394: (data[i].length,r) 
}
array table
-----------------------------------------------
data -> [('[i]', 'r', 'normalized', ['i'], 2392), ('[i]', 'r', 'normalized', ['i'], 2393), ('[i]', 'r', 'normalized', ['i'], 2394)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<LENGTH(data)  i++
induction variable: ['i']
{
L2395: (data[i].volatility,r) 
L2396: (data[i].start,r) 
L2397: (data[i].length,r) 
}
array table
-----------------------------------------------
data -> [('[i]', 'r', 'normalized', ['i'], 2395), ('[i]', 'r', 'normalized', ['i'], 2396), ('[i]', 'r', 'normalized', ['i'], 2397)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<LENGTH(data)  i++
induction variable: ['i']
{
L2398: (data[i].volatility,r) 
L2399: (data[i].start,r) 
L2400: (data[i].length,r) 
}
array table
-----------------------------------------------
data -> [('[i]', 'r', 'normalized', ['i'], 2398), ('[i]', 'r', 'normalized', ['i'], 2399), ('[i]', 'r', 'normalized', ['i'], 2400)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<LENGTH(start)  i++
induction variable: ['i']
{
L2401: (start[i],r) 
L2402: (pastFixings[fixingDate]=,w) 
	loop info: Size j=0  j<LENGTH(length)  j++
	induction variable: ['i', 'j']
	{
	L2403: (length[i],r) 
		loop info: Size k=0  k<LENGTH(rates)  k++
		induction variable: ['i', 'j', 'k']
		{
		L2404: (rates[k],r) 
		}
 	}
 }
array table
-----------------------------------------------
start -> [('[i]', 'r', 'normalized', ['i', 'j', 'k'], 2401)]
LDEs formed:0

length -> [('[i]', 'r', 'normalized', ['i', 'j', 'k'], 2403)]
LDEs formed:0

rates -> [('[k]', 'r', 'normalized', ['i', 'j', 'k'], 2404)]
LDEs formed:0

pastFixings -> [('[fixingDate]', 'w', 'not normalized', ['i', 'j', 'k'], 2402)]
LDEs formed:1

distinct LDEs:
fixingDate=fixingDate
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/nthtodefault.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i = 0  i < lambda.size()  i++
induction variable: ['i']
{
L2403: (lambda[i],r) 
}
array table
-----------------------------------------------
lambda -> [('[i]', 'r', 'normalized', ['i'], 2403)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<names  i++
induction variable: ['i']
{
L2404: (probabilities[i],r) 
}
array table
-----------------------------------------------
probabilities -> [('[i]', 'r', 'normalized', ['i'], 2404)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size j = 0  j < LENGTH(hwCorrelation)  j++
induction variable: ['j']
{
L2405: (hwCorrelation[j],r) 
	loop info: Size i = 0  i < ntd.size()  i++
	induction variable: ['j', 'i']
	{
	L2406: (ntd[i].rank,r) (hwData[i].rank,r) 
	L2407: (hwData[i].spread,r) 
	L2408: (ntd[i].fairPremium,r) (hwData[i].spread,r) 
	L2409: (hwData[i].spread,r) 
	}
 }
array table
-----------------------------------------------
hwCorrelation -> [('[j]', 'r', 'normalized', ['j', 'i'], 2405)]
LDEs formed:0

hwData -> [('[i]', 'r', 'normalized', ['j', 'i'], 2406), ('[i]', 'r', 'normalized', ['j', 'i'], 2407), ('[i]', 'r', 'normalized', ['j', 'i'], 2408), ('[i]', 'r', 'normalized', ['j', 'i'], 2409)]
LDEs formed:0

ntd -> [('[i]', 'r', 'normalized', ['j', 'i'], 2406), ('[i]', 'r', 'normalized', ['j', 'i'], 2408)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i = 0  i < lambda.size()  i++
induction variable: ['i']
{
L2409: (lambda[i],r) 
}
array table
-----------------------------------------------
lambda -> [('[i]', 'r', 'normalized', ['i'], 2409)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<names  i++
induction variable: ['i']
{
L2410: (probabilities[i],r) 
}
array table
-----------------------------------------------
probabilities -> [('[i]', 'r', 'normalized', ['i'], 2410)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i = 0  i < ntd.size()  i++
induction variable: ['i']
{
L2411: (ntd[i].rank,r) (hwDataDist[i].rank,r) 
L2412: (ntd[i].fairPremium,r) (hwDataDist[i].spread,r) 
L2413: (hwDataDist[i].spread,r) 
}
array table
-----------------------------------------------
hwDataDist -> [('[i]', 'r', 'normalized', ['i'], 2411), ('[i]', 'r', 'normalized', ['i'], 2412), ('[i]', 'r', 'normalized', ['i'], 2413)]
LDEs formed:0

ntd -> [('[i]', 'r', 'normalized', ['i'], 2411), ('[i]', 'r', 'normalized', ['i'], 2412)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i = 0  i < ntd.size()  i++
induction variable: ['i']
{
L2413: (ntd[i].rank,r) (hwDataDist[i].rank,r) 
L2414: (ntd[i].fairPremium,r) (hwDataDist[i].spread,r) 
L2415: (hwDataDist[i].spread,r) 
}
array table
-----------------------------------------------
hwDataDist -> [('[i]', 'r', 'normalized', ['i'], 2413), ('[i]', 'r', 'normalized', ['i'], 2414), ('[i]', 'r', 'normalized', ['i'], 2415)]
LDEs formed:0

ntd -> [('[i]', 'r', 'normalized', ['i'], 2413), ('[i]', 'r', 'normalized', ['i'], 2414)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/dividendoption.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<LENGTH(types)  i++
induction variable: ['i']
{
	loop info: Size j=0  j<LENGTH(strikes)  j++
	induction variable: ['i', 'j']
	{
		loop info: Size k=0  k<LENGTH(lengths)  k++
		induction variable: ['i', 'j', 'k']
		{
		L2415: (lengths[k]*,r) 
		L2416: (types[i],r) (strikes[j],r) 
			loop info: Size l=0  l<LENGTH(underlyings)  l++
			induction variable: ['i', 'j', 'k', 'l']
			{
				loop info: Size m=0  m<LENGTH(qRates)  m++
				induction variable: ['i', 'j', 'k', 'l', 'm']
				{
					loop info: Size n=0  n<LENGTH(rRates)  n++
					induction variable: ['i', 'j', 'k', 'l', 'm', 'n']
					{
						loop info: Size p=0  p<LENGTH(vols)  p++
						induction variable: ['i', 'j', 'k', 'l', 'm', 'n', 'p']
						{
						L2417: (underlyings[l],r) 
						L2418: (qRates[m],r) 
						L2419: (rRates[n],r) 
						L2420: (vols[p],r) 
						}
 					}
 				}
 			}
 		}
 	}
 }
array table
-----------------------------------------------
rRates -> [('[n]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p'], 2419)]
LDEs formed:0

lengths -> [('[k]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p'], 2415)]
LDEs formed:0

qRates -> [('[m]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p'], 2418)]
LDEs formed:0

strikes -> [('[j]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p'], 2416)]
LDEs formed:0

underlyings -> [('[l]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p'], 2417)]
LDEs formed:0

vols -> [('[p]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p'], 2420)]
LDEs formed:0

types -> [('[i]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p'], 2416)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<LENGTH(types)  i++
induction variable: ['i']
{
	loop info: Size j=0  j<LENGTH(strikes)  j++
	induction variable: ['i', 'j']
	{
		loop info: Size k=0  k<LENGTH(lengths)  k++
		induction variable: ['i', 'j', 'k']
		{
		L2417: (lengths[k]*,r) 
		L2418: (types[i],r) (strikes[j],r) 
			loop info: Size l=0  l<LENGTH(underlyings)  l++
			induction variable: ['i', 'j', 'k', 'l']
			{
				loop info: Size m=0  m<LENGTH(qRates)  m++
				induction variable: ['i', 'j', 'k', 'l', 'm']
				{
					loop info: Size n=0  n<LENGTH(rRates)  n++
					induction variable: ['i', 'j', 'k', 'l', 'm', 'n']
					{
						loop info: Size p=0  p<LENGTH(vols)  p++
						induction variable: ['i', 'j', 'k', 'l', 'm', 'n', 'p']
						{
						L2419: (underlyings[l],r) 
						L2420: (qRates[m],r) 
						L2421: (rRates[n],r) 
						L2422: (vols[p],r) 
						}
 					}
 				}
 			}
 		}
 	}
 }
array table
-----------------------------------------------
rRates -> [('[n]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p'], 2421)]
LDEs formed:0

lengths -> [('[k]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p'], 2417)]
LDEs formed:0

qRates -> [('[m]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p'], 2420)]
LDEs formed:0

strikes -> [('[j]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p'], 2418)]
LDEs formed:0

underlyings -> [('[l]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p'], 2419)]
LDEs formed:0

vols -> [('[p]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p'], 2422)]
LDEs formed:0

types -> [('[i]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p'], 2418)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<LENGTH(types)  i++
induction variable: ['i']
{
	loop info: Size j=0  j<LENGTH(strikes)  j++
	induction variable: ['i', 'j']
	{
		loop info: Size k=0  k<LENGTH(lengths)  k++
		induction variable: ['i', 'j', 'k']
		{
		L2419: (lengths[k]*,r) 
		L2420: (types[i],r) (strikes[j],r) 
		L2421: (types[i],r) 
		L2422: (strikes[j]+,r) 
			loop info: Size l=0  l<LENGTH(underlyings)  l++
			induction variable: ['i', 'j', 'k', 'l']
			{
				loop info: Size m=0  m<LENGTH(qRates)  m++
				induction variable: ['i', 'j', 'k', 'l', 'm']
				{
					loop info: Size n=0  n<LENGTH(rRates)  n++
					induction variable: ['i', 'j', 'k', 'l', 'm', 'n']
					{
						loop info: Size p=0  p<LENGTH(vols)  p++
						induction variable: ['i', 'j', 'k', 'l', 'm', 'n', 'p']
						{
						L2423: (underlyings[l],r) 
						L2424: (qRates[m],r) 
						L2425: (rRates[n],r) 
						L2426: (vols[p],r) 
						}
 					}
 				}
 			}
 		}
 	}
 }
array table
-----------------------------------------------
rRates -> [('[n]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p'], 2425)]
LDEs formed:0

lengths -> [('[k]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p'], 2419)]
LDEs formed:0

qRates -> [('[m]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p'], 2424)]
LDEs formed:0

strikes -> [('[j]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p'], 2420), ('[j]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p'], 2422)]
LDEs formed:0

underlyings -> [('[l]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p'], 2423)]
LDEs formed:0

vols -> [('[p]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p'], 2426)]
LDEs formed:0

types -> [('[i]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p'], 2420), ('[i]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p'], 2421)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<LENGTH(types)  i++
induction variable: ['i']
{
	loop info: Size j=0  j<LENGTH(strikes)  j++
	induction variable: ['i', 'j']
	{
		loop info: Size k=0  k<LENGTH(lengths)  k++
		induction variable: ['i', 'j', 'k']
		{
		L2422: (lengths[k]*,r) 
		L2423: (types[i],r) (strikes[j],r) 
			loop info: Size l=0  l<LENGTH(underlyings)  l++
			induction variable: ['i', 'j', 'k', 'l']
			{
				loop info: Size m=0  m<LENGTH(qRates)  m++
				induction variable: ['i', 'j', 'k', 'l', 'm']
				{
					loop info: Size n=0  n<LENGTH(rRates)  n++
					induction variable: ['i', 'j', 'k', 'l', 'm', 'n']
					{
						loop info: Size p=0  p<LENGTH(vols)  p++
						induction variable: ['i', 'j', 'k', 'l', 'm', 'n', 'p']
						{
						L2424: (underlyings[l],r) 
						L2425: (qRates[m],r) 
						L2426: (rRates[n],r) 
						L2427: (vols[p],r) 
						L2428: (calculated["delta"]=,w) 
						L2429: (calculated["gamma"]=,w) 
						L2430: (calculated["theta"]=,w) 
						L2431: (calculated["rho"]=,w) 
						L2432: (calculated["vega"]=,w) 
						L2433: (expected["delta"]=,w) 
						L2434: (expected["gamma"]=,w) 
						L2435: (expected["rho"]=,w) 
						L2436: (expected["vega"]=,w) 
						L2437: (expected["theta"]=,w) 
						L2438: (calculated[greek],r) 
						}
 					}
 				}
 			}
 		}
 	}
 }
array table
-----------------------------------------------
rRates -> [('[n]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p'], 2426)]
LDEs formed:0

lengths -> [('[k]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p'], 2422)]
LDEs formed:0

calculated -> [('["delta"]', 'w', 'not normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p'], 2428), ('["gamma"]', 'w', 'not normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p'], 2429), ('["theta"]', 'w', 'not normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p'], 2430), ('["rho"]', 'w', 'not normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p'], 2431), ('["vega"]', 'w', 'not normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p'], 2432), ('[greek]', 'r', 'not normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p'], 2438)]
LDEs formed:20

qRates -> [('[m]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p'], 2425)]
LDEs formed:0

strikes -> [('[j]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p'], 2423)]
LDEs formed:0

underlyings -> [('[l]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p'], 2424)]
LDEs formed:0

vols -> [('[p]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p'], 2427)]
LDEs formed:0

expected -> [('["delta"]', 'w', 'not normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p'], 2433), ('["gamma"]', 'w', 'not normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p'], 2434), ('["rho"]', 'w', 'not normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p'], 2435), ('["vega"]', 'w', 'not normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p'], 2436), ('["theta"]', 'w', 'not normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p'], 2437)]
LDEs formed:15

types -> [('[i]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p'], 2423)]
LDEs formed:0

distinct LDEs:
"theta"="theta"
"delta"="gamma"
"gamma"="theta"
"rho"="vega"
"delta"="vega"
"theta"="vega"
"rho"=greek
"rho"="rho"
"theta"="rho"
"delta"="delta"
"gamma"="gamma"
"delta"="theta"
"delta"="rho"
"theta"=greek
"delta"=greek
"gamma"=greek
"gamma"="rho"
"gamma"="vega"
"vega"=greek
"vega"="vega"
#########################################################################################
loop info: Size i=0  i<LENGTH(types)  i++
induction variable: ['i']
{
	loop info: Size j=0  j<LENGTH(strikes)  j++
	induction variable: ['i', 'j']
	{
		loop info: Size k=0  k<LENGTH(lengths)  k++
		induction variable: ['i', 'j', 'k']
		{
		L2424: (lengths[k]*,r) 
		L2425: (types[i],r) (strikes[j],r) 
			loop info: Size l=0  l<LENGTH(underlyings)  l++
			induction variable: ['i', 'j', 'k', 'l']
			{
				loop info: Size m=0  m<LENGTH(qRates)  m++
				induction variable: ['i', 'j', 'k', 'l', 'm']
				{
					loop info: Size n=0  n<LENGTH(rRates)  n++
					induction variable: ['i', 'j', 'k', 'l', 'm', 'n']
					{
						loop info: Size p=0  p<LENGTH(vols)  p++
						induction variable: ['i', 'j', 'k', 'l', 'm', 'n', 'p']
						{
						L2426: (underlyings[l],r) 
						L2427: (qRates[m],r) 
						L2428: (rRates[n],r) 
						L2429: (vols[p],r) 
						}
 					}
 				}
 			}
 		}
 	}
 }
array table
-----------------------------------------------
rRates -> [('[n]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p'], 2428)]
LDEs formed:0

lengths -> [('[k]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p'], 2424)]
LDEs formed:0

qRates -> [('[m]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p'], 2427)]
LDEs formed:0

strikes -> [('[j]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p'], 2425)]
LDEs formed:0

underlyings -> [('[l]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p'], 2426)]
LDEs formed:0

vols -> [('[p]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p'], 2429)]
LDEs formed:0

types -> [('[i]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p'], 2425)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<LENGTH(types)  i++
induction variable: ['i']
{
	loop info: Size j=0  j<LENGTH(strikes)  j++
	induction variable: ['i', 'j']
	{
	L2426: (types[i],r) (strikes[j],r) 
		loop info: Size l=0  l<LENGTH(underlyings)  l++
		induction variable: ['i', 'j', 'l']
		{
			loop info: Size m=0  m<LENGTH(qRates)  m++
			induction variable: ['i', 'j', 'l', 'm']
			{
				loop info: Size n=0  n<LENGTH(rRates)  n++
				induction variable: ['i', 'j', 'l', 'm', 'n']
				{
					loop info: Size p=0  p<LENGTH(vols)  p++
					induction variable: ['i', 'j', 'l', 'm', 'n', 'p']
					{
					L2427: (underlyings[l],r) 
					L2428: (qRates[m],r) 
					L2429: (rRates[n],r) 
					L2430: (vols[p],r) 
					L2431: (calculated["delta"]=,w) 
					L2432: (calculated["gamma"]=,w) 
					L2433: (calculated["theta"]=,w) 
					L2434: (expected["delta"]=,w) 
					L2435: (expected["gamma"]=,w) 
					L2436: (expected["theta"]=,w) 
					L2437: (calculated[greek],r) 
					}
 				}
 			}
 		}
 	}
 }
array table
-----------------------------------------------
rRates -> [('[n]', 'r', 'normalized', ['i', 'j', 'l', 'm', 'n', 'p'], 2429)]
LDEs formed:0

calculated -> [('["delta"]', 'w', 'not normalized', ['i', 'j', 'l', 'm', 'n', 'p'], 2431), ('["gamma"]', 'w', 'not normalized', ['i', 'j', 'l', 'm', 'n', 'p'], 2432), ('["theta"]', 'w', 'not normalized', ['i', 'j', 'l', 'm', 'n', 'p'], 2433), ('[greek]', 'r', 'not normalized', ['i', 'j', 'l', 'm', 'n', 'p'], 2437)]
LDEs formed:9

qRates -> [('[m]', 'r', 'normalized', ['i', 'j', 'l', 'm', 'n', 'p'], 2428)]
LDEs formed:0

strikes -> [('[j]', 'r', 'normalized', ['i', 'j', 'l', 'm', 'n', 'p'], 2426)]
LDEs formed:0

underlyings -> [('[l]', 'r', 'normalized', ['i', 'j', 'l', 'm', 'n', 'p'], 2427)]
LDEs formed:0

vols -> [('[p]', 'r', 'normalized', ['i', 'j', 'l', 'm', 'n', 'p'], 2430)]
LDEs formed:0

expected -> [('["delta"]', 'w', 'not normalized', ['i', 'j', 'l', 'm', 'n', 'p'], 2434), ('["gamma"]', 'w', 'not normalized', ['i', 'j', 'l', 'm', 'n', 'p'], 2435), ('["theta"]', 'w', 'not normalized', ['i', 'j', 'l', 'm', 'n', 'p'], 2436)]
LDEs formed:6

types -> [('[i]', 'r', 'normalized', ['i', 'j', 'l', 'm', 'n', 'p'], 2426)]
LDEs formed:0

distinct LDEs:
"theta"="theta"
"delta"="gamma"
"gamma"="theta"
"gamma"="gamma"
"delta"="delta"
"delta"="theta"
"theta"=greek
"delta"=greek
"gamma"=greek
#########################################################################################
loop info: Size i=0  i<LENGTH(lengths)  i++
induction variable: ['i']
{
L2427: (lengths[i]*,r) 
}
array table
-----------------------------------------------
lengths -> [('[i]', 'r', 'normalized', ['i'], 2427)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<LENGTH(lengths)  i++
induction variable: ['i']
{
L2428: (lengths[i]*,r) 
}
array table
-----------------------------------------------
lengths -> [('[i]', 'r', 'normalized', ['i'], 2428)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/swingoption.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size n=0  n < LENGTH(f)  ++n
induction variable: ['n']
{
L2429: (f[n],r) 
	loop info: Size i=0  i < LENGTH(discr)-1  ++i
	induction variable: ['n', 'i']
	{
	L2430: (f[n],r) (discr[i],r) 
		loop info: Size j=0  j < nTimeSteps  ++j
		induction variable: ['n', 'i', 'j']
		{
		}
 	}
 }
array table
-----------------------------------------------
discr -> [('[i]', 'r', 'normalized', ['n', 'i', 'j'], 2430)]
LDEs formed:0

f -> [('[n]', 'r', 'normalized', ['n', 'i', 'j'], 2429), ('[n]', 'r', 'normalized', ['n', 'i', 'j'], 2430)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i < n  ++i
induction variable: ['i']
{
L2431: (dw[0]=,w) 
L2432: (dw[1]=,w) 
L2433: (dw[2]=,w) 
L2434: (path[i]=,w) 
}
array table
-----------------------------------------------
dw -> [('[0]', 'w', 'normalized', ['i'], 2431), ('[1]', 'w', 'normalized', ['i'], 2432), ('[2]', 'w', 'normalized', ['i'], 2433)]
LDEs formed:6

path -> [('[i]', 'w', 'normalized', ['i'], 2434)]
LDEs formed:1

distinct LDEs:
2=2
0=0
0=1
0=2
i1=i2
1=1
1=2
#########################################################################################
loop info: Size n=0  n < nrTrails  ++n
induction variable: ['n']
{
L2435: (path.value[0].back,r) 
L2436: (path.value[1].back,r) 
}
array table
-----------------------------------------------
path.value -> [('[0]', 'r', 'normalized', ['n'], 2435), ('[1]', 'r', 'normalized', ['n'], 2436)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i < exerciseDates.size()  ++i
induction variable: ['i']
{
	loop info: Size j=exerciseDates.size()-i-1  j < exerciseDates.size()  ++j
	induction variable: ['i', 'j']
	{
	L2437: (exerciseDates[j],r) 
	}
 }
array table
-----------------------------------------------
exerciseDates -> [('[j]', 'r', 'normalized', ['i', 'j'], 2437)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i < exerciseTimes.size()  ++i
induction variable: ['i']
{
L2438: (exerciseTimes[i],r) 
L2439: (exerciseDates[i],r) 
}
array table
-----------------------------------------------
exerciseDates -> [('[i]', 'r', 'normalized', ['i'], 2439)]
LDEs formed:0

exerciseTimes -> [('[i]', 'r', 'normalized', ['i'], 2438)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i < exerciseIndex.size()  ++i
induction variable: ['i']
{
L2439: (exerciseIndex[i]=,w) (exerciseTimes[i],r) 
}
array table
-----------------------------------------------
exerciseTimes -> [('[i]', 'r', 'normalized', ['i'], 2439)]
LDEs formed:0

exerciseIndex -> [('[i]', 'w', 'normalized', ['i'], 2439)]
LDEs formed:1

distinct LDEs:
i1=i2
#########################################################################################
loop info: Size i=0  i < exerciseDates.size()  ++i
induction variable: ['i']
{
	loop info: Size j=exerciseDates.size()-i-1  j < exerciseDates.size()  ++j
	induction variable: ['i', 'j']
	{
	L2440: (exerciseDates[j],r) 
	}
	loop info: Size n=0  n < nrTrails  ++n
	induction variable: ['i', 'j', 'n']
	{
		loop info: Size k=0  k < exerciseTimes.size()  ++k
		induction variable: ['i', 'j', 'n', 'k']
		{
		L2441: (path.value[0],r) (exerciseIndex[k],r) 
		L2442: (path.value[1],r) (exerciseIndex[k],r) 
		L2443: (exerciseValues[k]=,w) (exerciseDates[k],r) 
		}
 	}
 }
array table
-----------------------------------------------
exerciseDates -> [('[j]', 'r', 'normalized', ['i', 'j', 'n', 'k'], 2440), ('[k]', 'r', 'normalized', ['i', 'j', 'n', 'k'], 2443)]
LDEs formed:0

path.value -> [('[0]', 'r', 'normalized', ['i', 'j', 'n', 'k'], 2441), ('[1]', 'r', 'normalized', ['i', 'j', 'n', 'k'], 2442)]
LDEs formed:0

exerciseValues -> [('[k]', 'w', 'normalized', ['i', 'j', 'n', 'k'], 2443)]
LDEs formed:1

exerciseIndex -> [('[k]', 'r', 'normalized', ['i', 'j', 'n', 'k'], 2441), ('[k]', 'r', 'normalized', ['i', 'j', 'n', 'k'], 2442)]
LDEs formed:0

distinct LDEs:
k1=k2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/quantooption.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<LENGTH(values)  i++
induction variable: ['i']
{
L2443: (values[i].type,r) (values[i].strike,r) 
L2444: (values[i].t*,r) 
L2445: (values[i].s,r) 
L2446: (values[i].q,r) 
L2447: (values[i].r,r) 
L2448: (values[i].v,r) 
L2449: (values[i].fxr,r) 
L2450: (values[i].fxv,r) 
L2451: (values[i].corr,r) 
L2452: (values[i].result,r) 
L2453: (values[i].s,r) 
L2454: (values[i].q,r) (values[i].r,r) 
L2455: (values[i].v,r) (values[i].fxr,r) (values[i].fxv,r) 
L2456: (values[i].corr,r) (values[i].result,r) 
}
array table
-----------------------------------------------
values -> [('[i]', 'r', 'normalized', ['i'], 2443), ('[i]', 'r', 'normalized', ['i'], 2443), ('[i]', 'r', 'normalized', ['i'], 2444), ('[i]', 'r', 'normalized', ['i'], 2445), ('[i]', 'r', 'normalized', ['i'], 2446), ('[i]', 'r', 'normalized', ['i'], 2447), ('[i]', 'r', 'normalized', ['i'], 2448), ('[i]', 'r', 'normalized', ['i'], 2449), ('[i]', 'r', 'normalized', ['i'], 2450), ('[i]', 'r', 'normalized', ['i'], 2451), ('[i]', 'r', 'normalized', ['i'], 2452), ('[i]', 'r', 'normalized', ['i'], 2453), ('[i]', 'r', 'normalized', ['i'], 2454), ('[i]', 'r', 'normalized', ['i'], 2454), ('[i]', 'r', 'normalized', ['i'], 2455), ('[i]', 'r', 'normalized', ['i'], 2455), ('[i]', 'r', 'normalized', ['i'], 2455), ('[i]', 'r', 'normalized', ['i'], 2456), ('[i]', 'r', 'normalized', ['i'], 2456)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<LENGTH(types)  i++
induction variable: ['i']
{
	loop info: Size j=0  j<LENGTH(strikes)  j++
	induction variable: ['i', 'j']
	{
		loop info: Size k=0  k<LENGTH(lengths)  k++
		induction variable: ['i', 'j', 'k']
		{
		L2457: (lengths[k]*,r) 
		L2458: (types[i],r) (strikes[j],r) 
			loop info: Size l=0  l<LENGTH(underlyings)  l++
			induction variable: ['i', 'j', 'k', 'l']
			{
				loop info: Size m=0  m<LENGTH(qRates)  m++
				induction variable: ['i', 'j', 'k', 'l', 'm']
				{
					loop info: Size n=0  n<LENGTH(rRates)  n++
					induction variable: ['i', 'j', 'k', 'l', 'm', 'n']
					{
						loop info: Size p=0  p<LENGTH(vols)  p++
						induction variable: ['i', 'j', 'k', 'l', 'm', 'n', 'p']
						{
							loop info: Size a=0  a<LENGTH(rRates)  a++
							induction variable: ['i', 'j', 'k', 'l', 'm', 'n', 'p', 'a']
							{
								loop info: Size b=0  b<LENGTH(vols)  b++
								induction variable: ['i', 'j', 'k', 'l', 'm', 'n', 'p', 'a', 'b']
								{
									loop info: Size c=0  c<LENGTH(correlations)  c++
									induction variable: ['i', 'j', 'k', 'l', 'm', 'n', 'p', 'a', 'b', 'c']
									{
									L2459: (underlyings[l],r) 
									L2460: (qRates[m],r) 
									L2461: (rRates[n],r) 
									L2462: (vols[p],r) 
									L2463: (rRates[a],r) 
									L2464: (vols[b],r) 
									L2465: (correlations[c],r) 
									L2466: (calculated["delta"]=,w) 
									L2467: (calculated["gamma"]=,w) 
									L2468: (calculated["theta"]=,w) 
									L2469: (calculated["rho"]=,w) 
									L2470: (calculated["divRho"]=,w) 
									L2471: (calculated["vega"]=,w) 
									L2472: (calculated["qrho"]=,w) 
									L2473: (calculated["qvega"]=,w) 
									L2474: (calculated["qlambda"]=,w) 
									L2475: (expected["delta"]=,w) 
									L2476: (expected["gamma"]=,w) 
									L2477: (expected["rho"]=,w) 
									L2478: (expected["divRho"]=,w) 
									L2479: (expected["vega"]=,w) 
									L2480: (expected["qrho"]=,w) 
									L2481: (expected["qvega"]=,w) 
									L2482: (expected["qlambda"]=,w) 
									L2483: (expected["theta"]=,w) 
									L2484: (calculated[greek],r) 
									}
 								}
 							}
 						}
 					}
 				}
 			}
 		}
 	}
 }
array table
-----------------------------------------------
rRates -> [('[n]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p', 'a', 'b', 'c'], 2461), ('[a]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p', 'a', 'b', 'c'], 2463)]
LDEs formed:0

lengths -> [('[k]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p', 'a', 'b', 'c'], 2457)]
LDEs formed:0

calculated -> [('["delta"]', 'w', 'not normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p', 'a', 'b', 'c'], 2466), ('["gamma"]', 'w', 'not normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p', 'a', 'b', 'c'], 2467), ('["theta"]', 'w', 'not normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p', 'a', 'b', 'c'], 2468), ('["rho"]', 'w', 'not normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p', 'a', 'b', 'c'], 2469), ('["divRho"]', 'w', 'not normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p', 'a', 'b', 'c'], 2470), ('["vega"]', 'w', 'not normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p', 'a', 'b', 'c'], 2471), ('["qrho"]', 'w', 'not normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p', 'a', 'b', 'c'], 2472), ('["qvega"]', 'w', 'not normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p', 'a', 'b', 'c'], 2473), ('["qlambda"]', 'w', 'not normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p', 'a', 'b', 'c'], 2474), ('[greek]', 'r', 'not normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p', 'a', 'b', 'c'], 2484)]
LDEs formed:54

correlations -> [('[c]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p', 'a', 'b', 'c'], 2465)]
LDEs formed:0

qRates -> [('[m]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p', 'a', 'b', 'c'], 2460)]
LDEs formed:0

strikes -> [('[j]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p', 'a', 'b', 'c'], 2458)]
LDEs formed:0

underlyings -> [('[l]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p', 'a', 'b', 'c'], 2459)]
LDEs formed:0

vols -> [('[p]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p', 'a', 'b', 'c'], 2462), ('[b]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p', 'a', 'b', 'c'], 2464)]
LDEs formed:0

expected -> [('["delta"]', 'w', 'not normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p', 'a', 'b', 'c'], 2475), ('["gamma"]', 'w', 'not normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p', 'a', 'b', 'c'], 2476), ('["rho"]', 'w', 'not normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p', 'a', 'b', 'c'], 2477), ('["divRho"]', 'w', 'not normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p', 'a', 'b', 'c'], 2478), ('["vega"]', 'w', 'not normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p', 'a', 'b', 'c'], 2479), ('["qrho"]', 'w', 'not normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p', 'a', 'b', 'c'], 2480), ('["qvega"]', 'w', 'not normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p', 'a', 'b', 'c'], 2481), ('["qlambda"]', 'w', 'not normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p', 'a', 'b', 'c'], 2482), ('["theta"]', 'w', 'not normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p', 'a', 'b', 'c'], 2483)]
LDEs formed:45

types -> [('[i]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p', 'a', 'b', 'c'], 2458)]
LDEs formed:0

distinct LDEs:
"rho"="rho"
"gamma"="qlambda"
"divRho"="divRho"
"theta"="rho"
"theta"="qlambda"
"gamma"="qvega"
"theta"="theta"
"divRho"="qlambda"
"qlambda"=greek
"gamma"="vega"
"vega"="qrho"
"qrho"=greek
"gamma"="qrho"
"gamma"="divRho"
"theta"="qrho"
"divRho"="vega"
"delta"="delta"
"rho"="vega"
"delta"="theta"
"divRho"="qvega"
"rho"="qlambda"
"vega"="qvega"
"qvega"="qvega"
"delta"="qrho"
"theta"="qvega"
"delta"="qlambda"
"rho"="qrho"
"delta"="rho"
"gamma"="theta"
"qvega"="qlambda"
"vega"="vega"
"rho"=greek
"delta"="divRho"
"divRho"="qrho"
"delta"=greek
"gamma"=greek
"gamma"="rho"
"vega"=greek
"delta"="qvega"
"delta"="gamma"
"vega"="qlambda"
"gamma"="gamma"
"qrho"="qvega"
"rho"="qvega"
"qrho"="qrho"
"delta"="vega"
"theta"="divRho"
"rho"="divRho"
"qvega"=greek
"theta"=greek
"divRho"=greek
"qlambda"="qlambda"
"qrho"="qlambda"
"theta"="vega"
#########################################################################################
loop info: Size i=0  i<LENGTH(values)  i++
induction variable: ['i']
{
L2459: (values[i].type,r) 
L2460: (values[i].t*,r) 
L2461: (values[i].start*,r) 
L2462: (values[i].s,r) 
L2463: (values[i].q,r) 
L2464: (values[i].r,r) 
L2465: (values[i].v,r) 
L2466: (values[i].fxr,r) 
L2467: (values[i].fxv,r) 
L2468: (values[i].corr,r) 
L2469: (values[i].moneyness,r) 
L2470: (values[i].result,r) 
L2471: (values[i].moneyness,r) 
L2472: (values[i].s,r) 
L2473: (values[i].q,r) (values[i].r,r) 
L2474: (values[i].v,r) (values[i].fxr,r) (values[i].fxv,r) 
L2475: (values[i].corr,r) (values[i].result,r) 
}
array table
-----------------------------------------------
values -> [('[i]', 'r', 'normalized', ['i'], 2459), ('[i]', 'r', 'normalized', ['i'], 2460), ('[i]', 'r', 'normalized', ['i'], 2461), ('[i]', 'r', 'normalized', ['i'], 2462), ('[i]', 'r', 'normalized', ['i'], 2463), ('[i]', 'r', 'normalized', ['i'], 2464), ('[i]', 'r', 'normalized', ['i'], 2465), ('[i]', 'r', 'normalized', ['i'], 2466), ('[i]', 'r', 'normalized', ['i'], 2467), ('[i]', 'r', 'normalized', ['i'], 2468), ('[i]', 'r', 'normalized', ['i'], 2469), ('[i]', 'r', 'normalized', ['i'], 2470), ('[i]', 'r', 'normalized', ['i'], 2471), ('[i]', 'r', 'normalized', ['i'], 2472), ('[i]', 'r', 'normalized', ['i'], 2473), ('[i]', 'r', 'normalized', ['i'], 2473), ('[i]', 'r', 'normalized', ['i'], 2474), ('[i]', 'r', 'normalized', ['i'], 2474), ('[i]', 'r', 'normalized', ['i'], 2474), ('[i]', 'r', 'normalized', ['i'], 2475), ('[i]', 'r', 'normalized', ['i'], 2475)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<LENGTH(types)  i++
induction variable: ['i']
{
	loop info: Size j=0  j<LENGTH(moneyness)  j++
	induction variable: ['i', 'j']
	{
		loop info: Size k=0  k<LENGTH(lengths)  k++
		induction variable: ['i', 'j', 'k']
		{
			loop info: Size h=0  h<LENGTH(startMonths)  h++
			induction variable: ['i', 'j', 'k', 'h']
			{
			L2476: (lengths[k]*,r) 
			L2477: (startMonths[h]*,r) 
			L2478: (types[i],r) 
			L2479: (moneyness[j],r) 
				loop info: Size l=0  l<LENGTH(underlyings)  l++
				induction variable: ['i', 'j', 'k', 'h', 'l']
				{
					loop info: Size m=0  m<LENGTH(qRates)  m++
					induction variable: ['i', 'j', 'k', 'h', 'l', 'm']
					{
						loop info: Size n=0  n<LENGTH(rRates)  n++
						induction variable: ['i', 'j', 'k', 'h', 'l', 'm', 'n']
						{
							loop info: Size p=0  p<LENGTH(vols)  p++
							induction variable: ['i', 'j', 'k', 'h', 'l', 'm', 'n', 'p']
							{
								loop info: Size a=0  a<LENGTH(rRates)  a++
								induction variable: ['i', 'j', 'k', 'h', 'l', 'm', 'n', 'p', 'a']
								{
									loop info: Size b=0  b<LENGTH(vols)  b++
									induction variable: ['i', 'j', 'k', 'h', 'l', 'm', 'n', 'p', 'a', 'b']
									{
										loop info: Size c=0  c<LENGTH(correlations)  c++
										induction variable: ['i', 'j', 'k', 'h', 'l', 'm', 'n', 'p', 'a', 'b', 'c']
										{
										L2480: (underlyings[l],r) 
										L2481: (qRates[m],r) 
										L2482: (rRates[n],r) 
										L2483: (vols[p],r) 
										L2484: (rRates[a],r) 
										L2485: (vols[b],r) 
										L2486: (correlations[c],r) 
										L2487: (calculated["delta"]=,w) 
										L2488: (calculated["gamma"]=,w) 
										L2489: (calculated["theta"]=,w) 
										L2490: (calculated["rho"]=,w) 
										L2491: (calculated["divRho"]=,w) 
										L2492: (calculated["vega"]=,w) 
										L2493: (calculated["qrho"]=,w) 
										L2494: (calculated["qvega"]=,w) 
										L2495: (calculated["qlambda"]=,w) 
										L2496: (expected["delta"]=,w) 
										L2497: (expected["gamma"]=,w) 
										L2498: (expected["rho"]=,w) 
										L2499: (expected["divRho"]=,w) 
										L2500: (expected["vega"]=,w) 
										L2501: (expected["qrho"]=,w) 
										L2502: (expected["qvega"]=,w) 
										L2503: (expected["qlambda"]=,w) 
										L2504: (expected["theta"]=,w) 
										L2505: (calculated[greek],r) 
										L2506: (moneyness[j],r) 
										}
 									}
 								}
 							}
 						}
 					}
 				}
 			}
 		}
 	}
 }
array table
-----------------------------------------------
rRates -> [('[n]', 'r', 'normalized', ['i', 'j', 'k', 'h', 'l', 'm', 'n', 'p', 'a', 'b', 'c'], 2482), ('[a]', 'r', 'normalized', ['i', 'j', 'k', 'h', 'l', 'm', 'n', 'p', 'a', 'b', 'c'], 2484)]
LDEs formed:0

lengths -> [('[k]', 'r', 'normalized', ['i', 'j', 'k', 'h', 'l', 'm', 'n', 'p', 'a', 'b', 'c'], 2476)]
LDEs formed:0

startMonths -> [('[h]', 'r', 'normalized', ['i', 'j', 'k', 'h', 'l', 'm', 'n', 'p', 'a', 'b', 'c'], 2477)]
LDEs formed:0

correlations -> [('[c]', 'r', 'normalized', ['i', 'j', 'k', 'h', 'l', 'm', 'n', 'p', 'a', 'b', 'c'], 2486)]
LDEs formed:0

qRates -> [('[m]', 'r', 'normalized', ['i', 'j', 'k', 'h', 'l', 'm', 'n', 'p', 'a', 'b', 'c'], 2481)]
LDEs formed:0

underlyings -> [('[l]', 'r', 'normalized', ['i', 'j', 'k', 'h', 'l', 'm', 'n', 'p', 'a', 'b', 'c'], 2480)]
LDEs formed:0

vols -> [('[p]', 'r', 'normalized', ['i', 'j', 'k', 'h', 'l', 'm', 'n', 'p', 'a', 'b', 'c'], 2483), ('[b]', 'r', 'normalized', ['i', 'j', 'k', 'h', 'l', 'm', 'n', 'p', 'a', 'b', 'c'], 2485)]
LDEs formed:0

expected -> [('["delta"]', 'w', 'not normalized', ['i', 'j', 'k', 'h', 'l', 'm', 'n', 'p', 'a', 'b', 'c'], 2496), ('["gamma"]', 'w', 'not normalized', ['i', 'j', 'k', 'h', 'l', 'm', 'n', 'p', 'a', 'b', 'c'], 2497), ('["rho"]', 'w', 'not normalized', ['i', 'j', 'k', 'h', 'l', 'm', 'n', 'p', 'a', 'b', 'c'], 2498), ('["divRho"]', 'w', 'not normalized', ['i', 'j', 'k', 'h', 'l', 'm', 'n', 'p', 'a', 'b', 'c'], 2499), ('["vega"]', 'w', 'not normalized', ['i', 'j', 'k', 'h', 'l', 'm', 'n', 'p', 'a', 'b', 'c'], 2500), ('["qrho"]', 'w', 'not normalized', ['i', 'j', 'k', 'h', 'l', 'm', 'n', 'p', 'a', 'b', 'c'], 2501), ('["qvega"]', 'w', 'not normalized', ['i', 'j', 'k', 'h', 'l', 'm', 'n', 'p', 'a', 'b', 'c'], 2502), ('["qlambda"]', 'w', 'not normalized', ['i', 'j', 'k', 'h', 'l', 'm', 'n', 'p', 'a', 'b', 'c'], 2503), ('["theta"]', 'w', 'not normalized', ['i', 'j', 'k', 'h', 'l', 'm', 'n', 'p', 'a', 'b', 'c'], 2504)]
LDEs formed:45

moneyness -> [('[j]', 'r', 'normalized', ['i', 'j', 'k', 'h', 'l', 'm', 'n', 'p', 'a', 'b', 'c'], 2479), ('[j]', 'r', 'normalized', ['i', 'j', 'k', 'h', 'l', 'm', 'n', 'p', 'a', 'b', 'c'], 2506)]
LDEs formed:0

calculated -> [('["delta"]', 'w', 'not normalized', ['i', 'j', 'k', 'h', 'l', 'm', 'n', 'p', 'a', 'b', 'c'], 2487), ('["gamma"]', 'w', 'not normalized', ['i', 'j', 'k', 'h', 'l', 'm', 'n', 'p', 'a', 'b', 'c'], 2488), ('["theta"]', 'w', 'not normalized', ['i', 'j', 'k', 'h', 'l', 'm', 'n', 'p', 'a', 'b', 'c'], 2489), ('["rho"]', 'w', 'not normalized', ['i', 'j', 'k', 'h', 'l', 'm', 'n', 'p', 'a', 'b', 'c'], 2490), ('["divRho"]', 'w', 'not normalized', ['i', 'j', 'k', 'h', 'l', 'm', 'n', 'p', 'a', 'b', 'c'], 2491), ('["vega"]', 'w', 'not normalized', ['i', 'j', 'k', 'h', 'l', 'm', 'n', 'p', 'a', 'b', 'c'], 2492), ('["qrho"]', 'w', 'not normalized', ['i', 'j', 'k', 'h', 'l', 'm', 'n', 'p', 'a', 'b', 'c'], 2493), ('["qvega"]', 'w', 'not normalized', ['i', 'j', 'k', 'h', 'l', 'm', 'n', 'p', 'a', 'b', 'c'], 2494), ('["qlambda"]', 'w', 'not normalized', ['i', 'j', 'k', 'h', 'l', 'm', 'n', 'p', 'a', 'b', 'c'], 2495), ('[greek]', 'r', 'not normalized', ['i', 'j', 'k', 'h', 'l', 'm', 'n', 'p', 'a', 'b', 'c'], 2505)]
LDEs formed:54

types -> [('[i]', 'r', 'normalized', ['i', 'j', 'k', 'h', 'l', 'm', 'n', 'p', 'a', 'b', 'c'], 2478)]
LDEs formed:0

distinct LDEs:
"qrho"="theta"
"divRho"="theta"
"gamma"="divRho"
"gamma"="qlambda"
"divRho"="divRho"
"divRho"="qrho"
"gamma"="qvega"
"theta"="theta"
"delta"=greek
"qlambda"="theta"
"divRho"="qlambda"
"qlambda"=greek
"qvega"="theta"
"gamma"="vega"
"vega"="qrho"
"qrho"=greek
"gamma"="qrho"
"rho"="rho"
"vega"="qvega"
"divRho"="vega"
"delta"="delta"
"rho"="vega"
"delta"="theta"
"divRho"="qvega"
"rho"="qlambda"
"rho"="theta"
"qvega"="qvega"
"delta"="qrho"
"delta"="qlambda"
"rho"="qrho"
"delta"="rho"
"gamma"="theta"
"qvega"="qlambda"
"vega"="vega"
"rho"=greek
"delta"="divRho"
"vega"="theta"
"gamma"=greek
"gamma"="rho"
"vega"=greek
"delta"="qvega"
"delta"="gamma"
"vega"="qlambda"
"gamma"="gamma"
"qrho"="qvega"
"rho"="qvega"
"qrho"="qrho"
"delta"="vega"
"rho"="divRho"
"qvega"=greek
"theta"=greek
"divRho"=greek
"qlambda"="qlambda"
"qrho"="qlambda"
#########################################################################################
loop info: Size i=0  i<LENGTH(values)  i++
induction variable: ['i']
{
L2479: (values[i].type,r) (values[i].moneyness,r) 
L2480: (values[i].type,r) 
L2481: (values[i].t*,r) 
L2482: (values[i].start*,r) 
L2483: (values[i].s,r) 
L2484: (values[i].q,r) 
L2485: (values[i].r,r) 
L2486: (values[i].v,r) 
L2487: (values[i].fxr,r) 
L2488: (values[i].fxv,r) 
L2489: (values[i].corr,r) 
L2490: (values[i].moneyness,r) 
L2491: (values[i].result,r) 
L2492: (values[i].moneyness,r) 
L2493: (values[i].s,r) (values[i].q,r) (values[i].r,r) 
L2494: (values[i].v,r) (values[i].fxr,r) (values[i].fxv,r) (values[i].corr,r) 
L2495: (values[i].result,r) 
}
array table
-----------------------------------------------
values -> [('[i]', 'r', 'normalized', ['i'], 2479), ('[i]', 'r', 'normalized', ['i'], 2479), ('[i]', 'r', 'normalized', ['i'], 2480), ('[i]', 'r', 'normalized', ['i'], 2481), ('[i]', 'r', 'normalized', ['i'], 2482), ('[i]', 'r', 'normalized', ['i'], 2483), ('[i]', 'r', 'normalized', ['i'], 2484), ('[i]', 'r', 'normalized', ['i'], 2485), ('[i]', 'r', 'normalized', ['i'], 2486), ('[i]', 'r', 'normalized', ['i'], 2487), ('[i]', 'r', 'normalized', ['i'], 2488), ('[i]', 'r', 'normalized', ['i'], 2489), ('[i]', 'r', 'normalized', ['i'], 2490), ('[i]', 'r', 'normalized', ['i'], 2491), ('[i]', 'r', 'normalized', ['i'], 2492), ('[i]', 'r', 'normalized', ['i'], 2493), ('[i]', 'r', 'normalized', ['i'], 2493), ('[i]', 'r', 'normalized', ['i'], 2493), ('[i]', 'r', 'normalized', ['i'], 2494), ('[i]', 'r', 'normalized', ['i'], 2494), ('[i]', 'r', 'normalized', ['i'], 2494), ('[i]', 'r', 'normalized', ['i'], 2494), ('[i]', 'r', 'normalized', ['i'], 2495)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<LENGTH(values)  i++
induction variable: ['i']
{
L2496: (values[i].type,r) (values[i].strike,r) 
L2497: (values[i].t*,r) 
L2498: (values[i].s,r) 
L2499: (values[i].q,r) 
L2500: (values[i].r,r) 
L2501: (values[i].v,r) 
L2502: (values[i].fxr,r) 
L2503: (values[i].fxv,r) 
L2504: (values[i].corr,r) 
L2505: (values[i].barrierType,r) 
L2506: (values[i].barrier,r) 
L2507: (values[i].rebate,r) 
L2508: (values[i].result,r) 
L2509: (values[i].tol,r) 
L2510: (values[i].barrierType,r) 
L2511: (values[i].barrier,r) 
L2512: (values[i].rebate,r) 
L2513: (values[i].s,r) (values[i].q,r) (values[i].r,r) 
L2514: (values[i].v,r) (values[i].fxr,r) (values[i].fxv,r) (values[i].corr,r) 
L2515: (values[i].result,r) 
}
array table
-----------------------------------------------
values -> [('[i]', 'r', 'normalized', ['i'], 2496), ('[i]', 'r', 'normalized', ['i'], 2496), ('[i]', 'r', 'normalized', ['i'], 2497), ('[i]', 'r', 'normalized', ['i'], 2498), ('[i]', 'r', 'normalized', ['i'], 2499), ('[i]', 'r', 'normalized', ['i'], 2500), ('[i]', 'r', 'normalized', ['i'], 2501), ('[i]', 'r', 'normalized', ['i'], 2502), ('[i]', 'r', 'normalized', ['i'], 2503), ('[i]', 'r', 'normalized', ['i'], 2504), ('[i]', 'r', 'normalized', ['i'], 2505), ('[i]', 'r', 'normalized', ['i'], 2506), ('[i]', 'r', 'normalized', ['i'], 2507), ('[i]', 'r', 'normalized', ['i'], 2508), ('[i]', 'r', 'normalized', ['i'], 2509), ('[i]', 'r', 'normalized', ['i'], 2510), ('[i]', 'r', 'normalized', ['i'], 2511), ('[i]', 'r', 'normalized', ['i'], 2512), ('[i]', 'r', 'normalized', ['i'], 2513), ('[i]', 'r', 'normalized', ['i'], 2513), ('[i]', 'r', 'normalized', ['i'], 2513), ('[i]', 'r', 'normalized', ['i'], 2514), ('[i]', 'r', 'normalized', ['i'], 2514), ('[i]', 'r', 'normalized', ['i'], 2514), ('[i]', 'r', 'normalized', ['i'], 2514), ('[i]', 'r', 'normalized', ['i'], 2515)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<LENGTH(values)  i++
induction variable: ['i']
{
L2516: (values[i].type,r) (values[i].strike,r) 
L2517: (values[i].t*,r) 
L2518: (values[i].s,r) 
L2519: (values[i].q,r) 
L2520: (values[i].r,r) 
L2521: (values[i].v,r) 
L2522: (values[i].fxr,r) 
L2523: (values[i].fxv,r) 
L2524: (values[i].corr,r) 
L2525: (values[i].barrierType,r) 
L2526: (values[i].barrier_lo,r) 
L2527: (values[i].barrier_hi,r) 
L2528: (values[i].rebate,r) 
L2529: (values[i].result,r) 
L2530: (values[i].tol,r) 
L2531: (values[i].barrierType,r) 
L2532: (values[i].barrier_lo,r) 
L2533: (values[i].barrier_hi,r) 
L2534: (values[i].rebate,r) 
L2535: (values[i].s,r) (values[i].q,r) (values[i].r,r) 
L2536: (values[i].v,r) (values[i].fxr,r) (values[i].fxv,r) (values[i].corr,r) 
L2537: (values[i].result,r) 
}
array table
-----------------------------------------------
values -> [('[i]', 'r', 'normalized', ['i'], 2516), ('[i]', 'r', 'normalized', ['i'], 2516), ('[i]', 'r', 'normalized', ['i'], 2517), ('[i]', 'r', 'normalized', ['i'], 2518), ('[i]', 'r', 'normalized', ['i'], 2519), ('[i]', 'r', 'normalized', ['i'], 2520), ('[i]', 'r', 'normalized', ['i'], 2521), ('[i]', 'r', 'normalized', ['i'], 2522), ('[i]', 'r', 'normalized', ['i'], 2523), ('[i]', 'r', 'normalized', ['i'], 2524), ('[i]', 'r', 'normalized', ['i'], 2525), ('[i]', 'r', 'normalized', ['i'], 2526), ('[i]', 'r', 'normalized', ['i'], 2527), ('[i]', 'r', 'normalized', ['i'], 2528), ('[i]', 'r', 'normalized', ['i'], 2529), ('[i]', 'r', 'normalized', ['i'], 2530), ('[i]', 'r', 'normalized', ['i'], 2531), ('[i]', 'r', 'normalized', ['i'], 2532), ('[i]', 'r', 'normalized', ['i'], 2533), ('[i]', 'r', 'normalized', ['i'], 2534), ('[i]', 'r', 'normalized', ['i'], 2535), ('[i]', 'r', 'normalized', ['i'], 2535), ('[i]', 'r', 'normalized', ['i'], 2535), ('[i]', 'r', 'normalized', ['i'], 2536), ('[i]', 'r', 'normalized', ['i'], 2536), ('[i]', 'r', 'normalized', ['i'], 2536), ('[i]', 'r', 'normalized', ['i'], 2536), ('[i]', 'r', 'normalized', ['i'], 2537)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/swap.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<LENGTH(lengths)  i++
induction variable: ['i']
{
	loop info: Size j=0  j<LENGTH(spreads)  j++
	induction variable: ['i', 'j']
	{
	L2538: (lengths[i],r) (spreads[j],r) 
	L2539: (lengths[i],r) (spreads[j],r) 
	L2540: (lengths[i]<<,r) 
	L2541: (spreads[j],r) 
	}
 }
array table
-----------------------------------------------
lengths -> [('[i]', 'r', 'normalized', ['i', 'j'], 2538), ('[i]', 'r', 'normalized', ['i', 'j'], 2539), ('[i]', 'r', 'normalized', ['i', 'j'], 2540)]
LDEs formed:0

spreads -> [('[j]', 'r', 'normalized', ['i', 'j'], 2538), ('[j]', 'r', 'normalized', ['i', 'j'], 2539), ('[j]', 'r', 'normalized', ['i', 'j'], 2541)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<LENGTH(lengths)  i++
induction variable: ['i']
{
	loop info: Size j=0  j<LENGTH(rates)  j++
	induction variable: ['i', 'j']
	{
	L2542: (lengths[i],r) (rates[j],r) 
	L2543: (lengths[i],r) (rates[j],r) 
	L2544: (lengths[i]<<,r) 
	L2545: (rates[j],r) 
	}
 }
array table
-----------------------------------------------
lengths -> [('[i]', 'r', 'normalized', ['i', 'j'], 2542), ('[i]', 'r', 'normalized', ['i', 'j'], 2543), ('[i]', 'r', 'normalized', ['i', 'j'], 2544)]
LDEs formed:0

rates -> [('[j]', 'r', 'normalized', ['i', 'j'], 2542), ('[j]', 'r', 'normalized', ['i', 'j'], 2543), ('[j]', 'r', 'normalized', ['i', 'j'], 2545)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<LENGTH(lengths)  i++
induction variable: ['i']
{
	loop info: Size j=0  j<LENGTH(spreads)  j++
	induction variable: ['i', 'j']
	{
		loop info: Size k=0  k<LENGTH(rates)  k++
		induction variable: ['i', 'j', 'k']
		{
		L2546: (lengths[i],r) (rates[k],r) (spreads[j],r) 
		}
	L2547: (lengths[i]<<,r) 
	L2548: (swap_values[n],r) 
	L2549: (rates[n],r) 
	L2550: (swap_values[n+1],r) 
	L2551: (rates[n+1],r) 
	}
 }
array table
-----------------------------------------------
lengths -> [('[i]', 'r', 'normalized', ['i', 'j', 'k'], 2546), ('[i]', 'r', 'normalized', ['i', 'j', 'k'], 2547)]
LDEs formed:0

spreads -> [('[j]', 'r', 'normalized', ['i', 'j', 'k'], 2546)]
LDEs formed:0

rates -> [('[k]', 'r', 'normalized', ['i', 'j', 'k'], 2546), ('[n]', 'r', 'not normalized', ['i', 'j', 'k'], 2549), ('[n+1]', 'r', 'not normalized', ['i', 'j', 'k'], 2551)]
LDEs formed:0

swap_values -> [('[n]', 'r', 'not normalized', ['i', 'j', 'k'], 2548), ('[n+1]', 'r', 'not normalized', ['i', 'j', 'k'], 2550)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<LENGTH(lengths)  i++
induction variable: ['i']
{
	loop info: Size j=0  j<LENGTH(rates)  j++
	induction variable: ['i', 'j']
	{
		loop info: Size k=0  k<LENGTH(spreads)  k++
		induction variable: ['i', 'j', 'k']
		{
		L2551: (lengths[i],r) (rates[j],r) (spreads[k],r) 
		}
	L2552: (lengths[i]<<,r) 
	L2553: (swap_values[n],r) 
	L2554: (spreads[n],r) 
	L2555: (swap_values[n+1],r) 
	L2556: (spreads[n+1],r) 
	}
 }
array table
-----------------------------------------------
lengths -> [('[i]', 'r', 'normalized', ['i', 'j', 'k'], 2551), ('[i]', 'r', 'normalized', ['i', 'j', 'k'], 2552)]
LDEs formed:0

spreads -> [('[k]', 'r', 'normalized', ['i', 'j', 'k'], 2551), ('[n]', 'r', 'not normalized', ['i', 'j', 'k'], 2554), ('[n+1]', 'r', 'not normalized', ['i', 'j', 'k'], 2556)]
LDEs formed:0

rates -> [('[j]', 'r', 'normalized', ['i', 'j', 'k'], 2551)]
LDEs formed:0

swap_values -> [('[n]', 'r', 'not normalized', ['i', 'j', 'k'], 2553), ('[n+1]', 'r', 'not normalized', ['i', 'j', 'k'], 2555)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/batesmodel.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i = 0  i < options.size()  ++i
induction variable: ['i']
{
L2556: (options[i]-,r) 
}
array table
-----------------------------------------------
options -> [('[i]', 'r', 'normalized', ['i'], 2556)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i < LENGTH(hestonModels)  ++i
induction variable: ['i']
{
L2557: (hestonModels[i].r,r) 
L2558: (hestonModels[i].q,r) 
L2559: (hestonModels[i].v0,r) 
L2560: (hestonModels[i].kappa,r) 
L2561: (hestonModels[i].theta,r) 
L2562: (hestonModels[i].sigma,r) 
L2563: (hestonModels[i].rho,r) 
}
array table
-----------------------------------------------
hestonModels -> [('[i]', 'r', 'normalized', ['i'], 2557), ('[i]', 'r', 'normalized', ['i'], 2558), ('[i]', 'r', 'normalized', ['i'], 2559), ('[i]', 'r', 'normalized', ['i'], 2560), ('[i]', 'r', 'normalized', ['i'], 2561), ('[i]', 'r', 'normalized', ['i'], 2562), ('[i]', 'r', 'normalized', ['i'], 2563)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i = 0  i < 8  ++i
induction variable: ['i']
{
L2564: (t[i],r) 
L2565: (r[i],r) 
}
array table
-----------------------------------------------
r -> [('[i]', 'r', 'normalized', ['i'], 2565)]
LDEs formed:0

t -> [('[i]', 'r', 'normalized', ['i'], 2564)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size s = 0  s < 13  ++s
induction variable: ['s']
{
	loop info: Size m = 0  m < 8  ++m
	induction variable: ['s', 'm']
	{
	L2565: (v[s*8+m],r) 
	L2566: (t[m]+,r) 
	L2567: (strike[s],r) 
	}
 }
array table
-----------------------------------------------
strike -> [('[s]', 'r', 'normalized', ['s', 'm'], 2567)]
LDEs formed:0

t -> [('[m]', 'r', 'normalized', ['s', 'm'], 2566)]
LDEs formed:0

v -> [('[s*8+m]', 'r', 'normalized', ['s', 'm'], 2565)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i = 0  i < pricingEngines.size()  ++i
induction variable: ['i']
{
	loop info: Size j = 0  j < options.size()  ++j
	induction variable: ['i', 'j']
	{
	L2566: (options[j]-,r) (pricingEngines[i],r) 
	}
L2567: (expectedValues[i],r) 
L2568: (expectedValues[i],r) 
}
array table
-----------------------------------------------
pricingEngines -> [('[i]', 'r', 'normalized', ['i', 'j'], 2566)]
LDEs formed:0

expectedValues -> [('[i]', 'r', 'normalized', ['i', 'j'], 2567), ('[i]', 'r', 'normalized', ['i', 'j'], 2568)]
LDEs formed:0

options -> [('[j]', 'r', 'normalized', ['i', 'j'], 2566)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/solvers.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<LENGTH(accuracy)  i++
induction variable: ['i']
{
L2567: (accuracy[i],r) 
L2568: (accuracy[i],r) 
L2569: (accuracy[i],r) 
}
array table
-----------------------------------------------
accuracy -> [('[i]', 'r', 'normalized', ['i'], 2567), ('[i]', 'r', 'normalized', ['i'], 2568), ('[i]', 'r', 'normalized', ['i'], 2569)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<LENGTH(accuracy)  i++
induction variable: ['i']
{
L2570: (accuracy[i],r) 
L2571: (accuracy[i],r) 
L2572: (accuracy[i],r) 
}
array table
-----------------------------------------------
accuracy -> [('[i]', 'r', 'normalized', ['i'], 2570), ('[i]', 'r', 'normalized', ['i'], 2571), ('[i]', 'r', 'normalized', ['i'], 2572)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<4  ++i
induction variable: ['i']
{
L2573: (offsets[i],r) 
L2574: (guesses[i],r) (mins[i],r) (maxs[i],r) 
L2575: (offsets[i],r) 
L2576: (guesses[i],r) (steps[i],r) 
}
array table
-----------------------------------------------
maxs -> [('[i]', 'r', 'normalized', ['i'], 2574)]
LDEs formed:0

mins -> [('[i]', 'r', 'normalized', ['i'], 2574)]
LDEs formed:0

guesses -> [('[i]', 'r', 'normalized', ['i'], 2574), ('[i]', 'r', 'normalized', ['i'], 2576)]
LDEs formed:0

steps -> [('[i]', 'r', 'normalized', ['i'], 2576)]
LDEs formed:0

offsets -> [('[i]', 'r', 'normalized', ['i'], 2573), ('[i]', 'r', 'normalized', ['i'], 2575)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/libormarketmodelprocess.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i < len  ++i
induction variable: ['i']
{
L2576: (vols[i]/,r) 
}
array table
-----------------------------------------------
vols -> [('[i]', 'r', 'normalized', ['i'], 2576)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Integer daysOffset=0  daysOffset < 1825 /* 5 year*/  daysOffset+=8
induction variable: ['daysOffset']
{
	loop info: Size i=1  i < fixings.size()-1  ++i
	induction variable: ['daysOffset', 'i']
	{
	L2577: (fixings[i]-,r) 
	L2578: (fixings[i]+,r) 
	L2579: (fixings[i],r) 
	}
 }
array table
-----------------------------------------------
fixings -> [('[i]', 'r', 'normalized', ['daysOffset', 'i'], 2577), ('[i]', 'r', 'normalized', ['daysOffset', 'i'], 2578), ('[i]', 'r', 'normalized', ['daysOffset', 'i'], 2579)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<9  ++i
induction variable: ['i']
{
L2580: (covar[i+1][i+1],r) 
L2581: (lambdaExpected[i]/,r) 
}
array table
-----------------------------------------------
covar -> [('[i+1][i+1]', 'r', 'normalized', ['i'], 2580)]
LDEs formed:0

lambdaExpected -> [('[i]', 'r', 'normalized', ['i'], 2581)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size t=0  t<grid.size()  ++t
induction variable: ['t']
{
L2582: (grid[t],r) 
L2583: (grid[t],r) 
	loop info: Size i=0  i<diff.rows()  ++i
	induction variable: ['t', 'i']
	{
		loop info: Size j=0  j<diff.columns()  ++j
		induction variable: ['t', 'i', 'j']
		{
		L2584: (diff[i][j],r) 
		L2585: (diff[i][j],r) 
		}
 	}
 }
array table
-----------------------------------------------
diff -> [('[i][j]', 'r', 'normalized', ['t', 'i', 'j'], 2584), ('[i][j]', 'r', 'normalized', ['t', 'i', 'j'], 2585)]
LDEs formed:0

grid -> [('[t]', 'r', 'normalized', ['t', 'i', 'j'], 2582), ('[t]', 'r', 'normalized', ['t', 'i', 'j'], 2583)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: i=0  i < tmp.size()  ++i
induction variable: ['i']
{
L2584: (tmp[i],r) 
}
array table
-----------------------------------------------
tmp -> [('[i]', 'r', 'normalized', ['i'], 2584)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: i=0  i<nrTrails  ++i
induction variable: ['i']
{
	loop info: Size j=0  j<process1->size()  ++j
	induction variable: ['i', 'j']
	{
	L2585: (rates1[j]=,w) (path1.value[j],r) (location[j],r) 
	L2586: (rates2[j]=,w) (path2.value[j],r) (location[j],r) 
	}
	loop info: Size k=0  k<process1->size()  ++k
	induction variable: ['i', 'j', 'k']
	{
	L2587: (rates1[k]-,r) 
	L2588: (rates2[k]-,r) 
	L2589: (stat1[k].add,r) (dis1[k]*,r) 
	L2590: (stat2[k].add,r) (dis2[k]*,r) 
	L2591: (rates2[k]-,r) (rates2[k-1]+,r) 
	L2592: (stat3[k-1].add,r) (dis2[k]*,r) 
	}
 }
array table
-----------------------------------------------
dis1 -> [('[k]', 'r', 'normalized', ['i', 'j', 'k'], 2589)]
LDEs formed:0

dis2 -> [('[k]', 'r', 'normalized', ['i', 'j', 'k'], 2590), ('[k]', 'r', 'normalized', ['i', 'j', 'k'], 2592)]
LDEs formed:0

rates1 -> [('[j]', 'w', 'normalized', ['i', 'j', 'k'], 2585), ('[k]', 'r', 'normalized', ['i', 'j', 'k'], 2587)]
LDEs formed:2

stat2 -> [('[k]', 'r', 'normalized', ['i', 'j', 'k'], 2590)]
LDEs formed:0

stat1 -> [('[k]', 'r', 'normalized', ['i', 'j', 'k'], 2589)]
LDEs formed:0

rates2 -> [('[j]', 'w', 'normalized', ['i', 'j', 'k'], 2586), ('[k]', 'r', 'normalized', ['i', 'j', 'k'], 2588), ('[k]', 'r', 'normalized', ['i', 'j', 'k'], 2591), ('[k-1]', 'r', 'normalized', ['i', 'j', 'k'], 2591)]
LDEs formed:4

path2.value -> [('[j]', 'r', 'normalized', ['i', 'j', 'k'], 2586)]
LDEs formed:0

path1.value -> [('[j]', 'r', 'normalized', ['i', 'j', 'k'], 2585)]
LDEs formed:0

location -> [('[j]', 'r', 'normalized', ['i', 'j', 'k'], 2585), ('[j]', 'r', 'normalized', ['i', 'j', 'k'], 2586)]
LDEs formed:0

stat3 -> [('[k-1]', 'r', 'normalized', ['i', 'j', 'k'], 2592)]
LDEs formed:0

distinct LDEs:
j1=j2
j1=k2-1
j1=k2
#########################################################################################
loop info: Size k=0  k < process1->size()  ++k
induction variable: ['k']
{
L2593: (stat1[k].mean,r) 
L2594: (stat1[k].errorEstimate,r) 
L2595: (capletNpv[k],r) 
L2596: (stat2[k].mean,r) 
L2597: (stat2[k].errorEstimate,r) 
L2598: (stat3[k-1].mean,r) 
L2599: (stat3[k-1].errorEstimate,r) 
L2600: (ratchetNpv[k-1],r) 
}
array table
-----------------------------------------------
stat3 -> [('[k-1]', 'r', 'normalized', ['k'], 2598), ('[k-1]', 'r', 'normalized', ['k'], 2599)]
LDEs formed:0

ratchetNpv -> [('[k-1]', 'r', 'normalized', ['k'], 2600)]
LDEs formed:0

capletNpv -> [('[k]', 'r', 'normalized', ['k'], 2595)]
LDEs formed:0

stat2 -> [('[k]', 'r', 'normalized', ['k'], 2596), ('[k]', 'r', 'normalized', ['k'], 2597)]
LDEs formed:0

stat1 -> [('[k]', 'r', 'normalized', ['k'], 2593), ('[k]', 'r', 'normalized', ['k'], 2594)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/markovfunctional.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: int i = 0  i < 10 + 15 + 35  i++
induction variable: ['i']
{
L2595: (q6mh[i],r) 
}
array table
-----------------------------------------------
q6mh -> [('[i]', 'r', 'normalized', ['i'], 2595)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: int i = 0  i < 10  i++
induction variable: ['i']
{
L2596: (q6m[i],r) (q6mh1[i],r) 
}
array table
-----------------------------------------------
q6m -> [('[i]', 'r', 'normalized', ['i'], 2596)]
LDEs formed:0

q6mh1 -> [('[i]', 'r', 'normalized', ['i'], 2596)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: int i = 0  i < 18  i++
induction variable: ['i']
{
L2597: (q6m[10 + i],r) 
}
array table
-----------------------------------------------
q6m -> [('[10 + i]', 'r', 'normalized', ['i'], 2597)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: int i = 0  i < 15 + 35  i++
induction variable: ['i']
{
L2598: (q6m[10 + i],r) (q6mh2[i],r) 
}
array table
-----------------------------------------------
q6m -> [('[10 + i]', 'r', 'normalized', ['i'], 2598)]
LDEs formed:0

q6mh2 -> [('[i]', 'r', 'normalized', ['i'], 2598)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: int i = 0  i < 20  i++
induction variable: ['i']
{
	loop info: int j = 0  j < 14  j++
	induction variable: ['i', 'j']
	{
	L2599: (qSwAtmh[i * 14 + j],r) 
	}
 }
array table
-----------------------------------------------
qSwAtmh -> [('[i * 14 + j]', 'r', 'normalized', ['i', 'j'], 2599)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: int i = 0  i < 30  i++
induction variable: ['i']
{
	loop info: int j = 0  j < 9  j++
	induction variable: ['i', 'j']
	{
	L2600: (qSwSmileh[i * 9 + j],r) 
	}
 }
array table
-----------------------------------------------
qSwSmileh -> [('[i * 9 + j]', 'r', 'normalized', ['i', 'j'], 2600)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: int i = 0  i < 30  i++
induction variable: ['i']
{
	loop info: int j = 0  j < 4  j++
	induction variable: ['i', 'j']
	{
	L2601: (qSwSmileh1[i * 4 + j],r) 
	}
 }
array table
-----------------------------------------------
qSwSmileh1 -> [('[i * 4 + j]', 'r', 'normalized', ['i', 'j'], 2601)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i = 0  i < nStrikes  i++
induction variable: ['i']
{
	loop info: Size j = 0  j < nOptTen  j++
	induction variable: ['i', 'j']
	{
	L2602: (vols[j][i]=,w) (volsa[i][j],r) 
	}
 }
array table
-----------------------------------------------
volsa -> [('[i][j]', 'r', 'normalized', ['i', 'j'], 2602)]
LDEs formed:0

vols -> [('[j][i]', 'w', 'normalized', ['i', 'j'], 2602)]
LDEs formed:2

distinct LDEs:
j1=j2,i1=i2
#########################################################################################
loop info: Size i = 0  i < prices.size()  i++
induction variable: ['i']
{
L2603: (strikes[i],r) 
L2604: (prices[i],r) 
}
array table
-----------------------------------------------
prices -> [('[i]', 'r', 'normalized', ['i'], 2604)]
LDEs formed:0

strikes -> [('[i]', 'r', 'normalized', ['i'], 2603)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i = 0  i < strikes.size()  i++
induction variable: ['i']
{
L2604: (strikes[i]/,r) 
L2605: (strikes[i],r) 
}
array table
-----------------------------------------------
strikes -> [('[i]', 'r', 'normalized', ['i'], 2604), ('[i]', 'r', 'normalized', ['i'], 2605)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i = 1  i < strikes.size()  i++
induction variable: ['i']
{
L2606: (strikes[i],r) 
L2607: (strikes[i],r) 
L2608: (strikes[i]<<,r) 
}
array table
-----------------------------------------------
strikes -> [('[i]', 'r', 'normalized', ['i'], 2606), ('[i]', 'r', 'normalized', ['i'], 2607), ('[i]', 'r', 'normalized', ['i'], 2608)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i = 0  i < outputs1.expiries_.size()  i++
induction variable: ['i']
{
L2609: (outputs1.marketZerorate_[i]-,r) (outputs1.modelZerorate_[i],r) 
L2610: (outputs1.marketZerorate_[i],r) 
L2611: (outputs1.modelZerorate_[i]<<,r) 
}
array table
-----------------------------------------------
outputs1.marketZerorate_ -> [('[i]', 'r', 'normalized', ['i'], 2609), ('[i]', 'r', 'normalized', ['i'], 2610)]
LDEs formed:0

outputs1.modelZerorate_ -> [('[i]', 'r', 'normalized', ['i'], 2609), ('[i]', 'r', 'normalized', ['i'], 2611)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i = 0  i < outputs1.expiries_.size()  i++
induction variable: ['i']
{
	loop info: Size j = 0  j < outputs1.smileStrikes_[i].size()  j++
	induction variable: ['i', 'j']
	{
	L2612: (outputs1.marketCallPremium_[i][j]-,r) 
	L2613: (outputs1.modelCallPremium_[i][j],r) 
	L2614: (outputs1.marketCallPremium_[i][j],r) 
	L2615: (outputs1.modelCallPremium_[i][j]<<,r) 
	L2616: (outputs1.marketPutPremium_[i][j]-,r) 
	L2617: (outputs1.modelPutPremium_[i][j],r) 
	L2618: (outputs1.marketPutPremium_[i][j],r) 
	L2619: (outputs1.modelPutPremium_[i][j]<<,r) 
	}
 }
array table
-----------------------------------------------
outputs1.marketCallPremium_ -> [('[i][j]', 'r', 'normalized', ['i', 'j'], 2612), ('[i][j]', 'r', 'normalized', ['i', 'j'], 2614)]
LDEs formed:0

outputs1.modelPutPremium_ -> [('[i][j]', 'r', 'normalized', ['i', 'j'], 2617), ('[i][j]', 'r', 'normalized', ['i', 'j'], 2619)]
LDEs formed:0

outputs1.modelCallPremium_ -> [('[i][j]', 'r', 'normalized', ['i', 'j'], 2613), ('[i][j]', 'r', 'normalized', ['i', 'j'], 2615)]
LDEs formed:0

outputs1.marketPutPremium_ -> [('[i][j]', 'r', 'normalized', ['i', 'j'], 2616), ('[i][j]', 'r', 'normalized', ['i', 'j'], 2618)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i = 0  i < outputs2.expiries_.size()  i++
induction variable: ['i']
{
L2619: (outputs2.marketZerorate_[i]-,r) (outputs2.modelZerorate_[i],r) 
L2620: (outputs2.marketZerorate_[i],r) 
L2621: (outputs2.modelZerorate_[i]<<,r) 
}
array table
-----------------------------------------------
outputs2.modelZerorate_ -> [('[i]', 'r', 'normalized', ['i'], 2619), ('[i]', 'r', 'normalized', ['i'], 2621)]
LDEs formed:0

outputs2.marketZerorate_ -> [('[i]', 'r', 'normalized', ['i'], 2619), ('[i]', 'r', 'normalized', ['i'], 2620)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i = 0  i < outputs2.expiries_.size()  i++
induction variable: ['i']
{
	loop info: Size j = 0  j < outputs2.smileStrikes_[i].size()  j++
	induction variable: ['i', 'j']
	{
	L2621: (outputs2.marketCallPremium_[i][j]-,r) 
	L2622: (outputs2.modelCallPremium_[i][j],r) 
	L2623: (outputs2.marketCallPremium_[i][j],r) 
	L2624: (outputs2.modelCallPremium_[i][j]<<,r) 
	L2625: (outputs2.marketPutPremium_[i][j]-,r) 
	L2626: (outputs2.modelPutPremium_[i][j],r) 
	L2627: (outputs2.marketPutPremium_[i][j],r) 
	L2628: (outputs2.modelPutPremium_[i][j]<<,r) 
	}
 }
array table
-----------------------------------------------
outputs2.modelPutPremium_ -> [('[i][j]', 'r', 'normalized', ['i', 'j'], 2626), ('[i][j]', 'r', 'normalized', ['i', 'j'], 2628)]
LDEs formed:0

outputs2.marketCallPremium_ -> [('[i][j]', 'r', 'normalized', ['i', 'j'], 2621), ('[i][j]', 'r', 'normalized', ['i', 'j'], 2623)]
LDEs formed:0

outputs2.modelCallPremium_ -> [('[i][j]', 'r', 'normalized', ['i', 'j'], 2622), ('[i][j]', 'r', 'normalized', ['i', 'j'], 2624)]
LDEs formed:0

outputs2.marketPutPremium_ -> [('[i][j]', 'r', 'normalized', ['i', 'j'], 2625), ('[i][j]', 'r', 'normalized', ['i', 'j'], 2627)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i = 0  i < outputs3.expiries_.size()  i++
induction variable: ['i']
{
L2628: (outputs3.marketZerorate_[i]-,r) (outputs3.modelZerorate_[i],r) 
L2629: (outputs3.marketZerorate_[i],r) 
L2630: (outputs3.modelZerorate_[i]<<,r) 
}
array table
-----------------------------------------------
outputs3.marketZerorate_ -> [('[i]', 'r', 'normalized', ['i'], 2628), ('[i]', 'r', 'normalized', ['i'], 2629)]
LDEs formed:0

outputs3.modelZerorate_ -> [('[i]', 'r', 'normalized', ['i'], 2628), ('[i]', 'r', 'normalized', ['i'], 2630)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i = 0  i < outputs3.expiries_.size()  i++
induction variable: ['i']
{
	loop info: Size j = 0  j < outputs3.smileStrikes_[i].size()  j++
	induction variable: ['i', 'j']
	{
	L2631: (outputs3.marketCallPremium_[i][j]-,r) 
	L2632: (outputs3.modelCallPremium_[i][j],r) 
	L2633: (outputs3.marketCallPremium_[i][j],r) 
	L2634: (outputs3.modelCallPremium_[i][j]<<,r) 
	L2635: (outputs3.marketPutPremium_[i][j]-,r) 
	L2636: (outputs3.modelPutPremium_[i][j],r) 
	L2637: (outputs3.marketPutPremium_[i][j],r) 
	L2638: (outputs3.modelPutPremium_[i][j]<<,r) 
	}
 }
array table
-----------------------------------------------
outputs3.marketCallPremium_ -> [('[i][j]', 'r', 'normalized', ['i', 'j'], 2631), ('[i][j]', 'r', 'normalized', ['i', 'j'], 2633)]
LDEs formed:0

outputs3.modelCallPremium_ -> [('[i][j]', 'r', 'normalized', ['i', 'j'], 2632), ('[i][j]', 'r', 'normalized', ['i', 'j'], 2634)]
LDEs formed:0

outputs3.marketPutPremium_ -> [('[i][j]', 'r', 'normalized', ['i', 'j'], 2635), ('[i][j]', 'r', 'normalized', ['i', 'j'], 2637)]
LDEs formed:0

outputs3.modelPutPremium_ -> [('[i][j]', 'r', 'normalized', ['i', 'j'], 2636), ('[i][j]', 'r', 'normalized', ['i', 'j'], 2638)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i = 0  i < outputs4.expiries_.size()  i++
induction variable: ['i']
{
L2639: (outputs4.marketZerorate_[i]-,r) (outputs4.modelZerorate_[i],r) 
L2640: (outputs4.marketZerorate_[i],r) 
L2641: (outputs4.modelZerorate_[i]<<,r) 
}
array table
-----------------------------------------------
outputs4.marketZerorate_ -> [('[i]', 'r', 'normalized', ['i'], 2639), ('[i]', 'r', 'normalized', ['i'], 2640)]
LDEs formed:0

outputs4.modelZerorate_ -> [('[i]', 'r', 'normalized', ['i'], 2639), ('[i]', 'r', 'normalized', ['i'], 2641)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i = 0  i < outputs4.expiries_.size()  i++
induction variable: ['i']
{
	loop info: Size j = 0  j < outputs4.smileStrikes_[i].size()  j++
	induction variable: ['i', 'j']
	{
	L2642: (outputs4.marketCallPremium_[i][j]-,r) 
	L2643: (outputs4.modelCallPremium_[i][j],r) 
	L2644: (outputs4.marketCallPremium_[i][j],r) 
	L2645: (outputs4.modelCallPremium_[i][j]<<,r) 
	L2646: (outputs4.marketPutPremium_[i][j]-,r) 
	L2647: (outputs4.modelPutPremium_[i][j],r) 
	L2648: (outputs4.marketPutPremium_[i][j],r) 
	L2649: (outputs4.modelPutPremium_[i][j]<<,r) 
	}
 }
array table
-----------------------------------------------
outputs4.marketCallPremium_ -> [('[i][j]', 'r', 'normalized', ['i', 'j'], 2642), ('[i][j]', 'r', 'normalized', ['i', 'j'], 2644)]
LDEs formed:0

outputs4.marketPutPremium_ -> [('[i][j]', 'r', 'normalized', ['i', 'j'], 2646), ('[i][j]', 'r', 'normalized', ['i', 'j'], 2648)]
LDEs formed:0

outputs4.modelCallPremium_ -> [('[i][j]', 'r', 'normalized', ['i', 'j'], 2643), ('[i][j]', 'r', 'normalized', ['i', 'j'], 2645)]
LDEs formed:0

outputs4.modelPutPremium_ -> [('[i][j]', 'r', 'normalized', ['i', 'j'], 2647), ('[i][j]', 'r', 'normalized', ['i', 'j'], 2649)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i = 0  i < outputs1.expiries_.size()  i++
induction variable: ['i']
{
	loop info: Size j = 0  j < outputs1.smileStrikes_[0].size()  j++
	induction variable: ['i', 'j']
	{
	L2650: (outputs1.tenors_[i],r) 
	L2651: (outputs1.smileStrikes_[i][j],r) 
	L2652: (outputs1.expiries_[i],r) 
	L2653: (outputs1.tenors_[i],r) 
	L2654: (outputs1.smileStrikes_[i][j],r) 
	L2655: (outputs1.expiries_[i],r) 
	L2656: (outputs1.expiries_[i],r) 
	}
 }
array table
-----------------------------------------------
outputs1.tenors_ -> [('[i]', 'r', 'normalized', ['i', 'j'], 2650), ('[i]', 'r', 'normalized', ['i', 'j'], 2653)]
LDEs formed:0

outputs1.expiries_ -> [('[i]', 'r', 'normalized', ['i', 'j'], 2652), ('[i]', 'r', 'normalized', ['i', 'j'], 2655), ('[i]', 'r', 'normalized', ['i', 'j'], 2656)]
LDEs formed:0

outputs1.smileStrikes_ -> [('[i][j]', 'r', 'normalized', ['i', 'j'], 2651), ('[i][j]', 'r', 'normalized', ['i', 'j'], 2654)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i = 0  i < c2.size()  i++
induction variable: ['i']
{
L2655: (c2[i].setPricingEngine,r) 
L2656: (c2[i].NPV,r) 
L2657: (c2[i].setPricingEngine,r) 
L2658: (c2[i].NPV,r) 
}
array table
-----------------------------------------------
c2 -> [('[i]', 'r', 'normalized', ['i'], 2655), ('[i]', 'r', 'normalized', ['i'], 2656), ('[i]', 'r', 'normalized', ['i'], 2657), ('[i]', 'r', 'normalized', ['i'], 2658)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i = 0  i < outputs3.expiries_.size()  i++
induction variable: ['i']
{
	loop info: Size j = 0  j < outputs3.smileStrikes_[0].size()  j++
	induction variable: ['i', 'j']
	{
	L2659: (outputs3.tenors_[i],r) 
	L2660: (outputs3.smileStrikes_[i][j],r) 
	L2661: (outputs3.expiries_[i],r) 
	L2662: (outputs3.tenors_[i],r) 
	L2663: (outputs3.smileStrikes_[i][j],r) 
	L2664: (outputs3.expiries_[i],r) 
	L2665: (outputs3.expiries_[i],r) 
	L2666: (outputs3.marketCallPremium_[i][j]-,r) 
	L2667: (outputs3.marketRawCallPremium_[i][j],r) 
	L2668: (outputs3.marketPutPremium_[i][j]-,r) 
	L2669: (outputs3.marketRawPutPremium_[i][j],r) 
	}
 }
array table
-----------------------------------------------
outputs3.marketPutPremium_ -> [('[i][j]', 'r', 'normalized', ['i', 'j'], 2668)]
LDEs formed:0

outputs3.expiries_ -> [('[i]', 'r', 'normalized', ['i', 'j'], 2661), ('[i]', 'r', 'normalized', ['i', 'j'], 2664), ('[i]', 'r', 'normalized', ['i', 'j'], 2665)]
LDEs formed:0

outputs3.tenors_ -> [('[i]', 'r', 'normalized', ['i', 'j'], 2659), ('[i]', 'r', 'normalized', ['i', 'j'], 2662)]
LDEs formed:0

outputs3.marketRawCallPremium_ -> [('[i][j]', 'r', 'normalized', ['i', 'j'], 2667)]
LDEs formed:0

outputs3.smileStrikes_ -> [('[i][j]', 'r', 'normalized', ['i', 'j'], 2660), ('[i][j]', 'r', 'normalized', ['i', 'j'], 2663)]
LDEs formed:0

outputs3.marketRawPutPremium_ -> [('[i][j]', 'r', 'normalized', ['i', 'j'], 2669)]
LDEs formed:0

outputs3.marketCallPremium_ -> [('[i][j]', 'r', 'normalized', ['i', 'j'], 2666)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i = 0  i < c4.size()  i++
induction variable: ['i']
{
L2667: (c4[i].setPricingEngine,r) 
L2668: (c4[i].NPV,r) 
L2669: (c4[i].result,r) 
L2670: (c4[i].setPricingEngine,r) 
L2671: (c4[i].result,r) 
L2672: (c4[i].NPV,r) 
}
array table
-----------------------------------------------
c4 -> [('[i]', 'r', 'normalized', ['i'], 2667), ('[i]', 'r', 'normalized', ['i'], 2668), ('[i]', 'r', 'normalized', ['i'], 2669), ('[i]', 'r', 'normalized', ['i'], 2670), ('[i]', 'r', 'normalized', ['i'], 2671), ('[i]', 'r', 'normalized', ['i'], 2672)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i = 0  i < ch1.size()  i++
induction variable: ['i']
{
L2673: (calibrationHelperVols1[i],r) 
L2674: (ch1[i].setPricingEngine,r) 
L2675: (ch1[i].NPV,r) 
L2676: (ch1[i].result,r) 
L2677: (ch1[i].setPricingEngine,r) 
L2678: (ch1[i].NPV,r) 
}
array table
-----------------------------------------------
ch1 -> [('[i]', 'r', 'normalized', ['i'], 2674), ('[i]', 'r', 'normalized', ['i'], 2675), ('[i]', 'r', 'normalized', ['i'], 2676), ('[i]', 'r', 'normalized', ['i'], 2677), ('[i]', 'r', 'normalized', ['i'], 2678)]
LDEs formed:0

calibrationHelperVols1 -> [('[i]', 'r', 'normalized', ['i'], 2673)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i = 0  i < ch2.size()  i++
induction variable: ['i']
{
L2674: (calibrationHelperVols2[i],r) 
L2675: (ch2[i].setPricingEngine,r) 
L2676: (ch2[i].NPV,r) 
L2677: (ch2[i].result,r) 
L2678: (ch2[i].setPricingEngine,r) 
L2679: (ch2[i].NPV,r) 
}
array table
-----------------------------------------------
ch2 -> [('[i]', 'r', 'normalized', ['i'], 2675), ('[i]', 'r', 'normalized', ['i'], 2676), ('[i]', 'r', 'normalized', ['i'], 2677), ('[i]', 'r', 'normalized', ['i'], 2678), ('[i]', 'r', 'normalized', ['i'], 2679)]
LDEs formed:0

calibrationHelperVols2 -> [('[i]', 'r', 'normalized', ['i'], 2674)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i = 0  i < expiries.size()  i++
induction variable: ['i']
{
L2675: (expiries[i],r) 
L2676: (europeanExercises[i],r) 
}
array table
-----------------------------------------------
expiries -> [('[i]', 'r', 'normalized', ['i'], 2675)]
LDEs formed:0

europeanExercises -> [('[i]', 'r', 'normalized', ['i'], 2676)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i = 0  i < expiries.size()  i++
induction variable: ['i']
{
L2677: (europeanSwaptions[i].NPV,r) 
L2678: (cachedValues[i],r) 
L2679: (cachedValues[i]<<,r) 
}
array table
-----------------------------------------------
europeanSwaptions -> [('[i]', 'r', 'normalized', ['i'], 2677)]
LDEs formed:0

cachedValues -> [('[i]', 'r', 'normalized', ['i'], 2678), ('[i]', 'r', 'normalized', ['i'], 2679)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/fdmlinearop.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size k=0  k < dim[0]  ++k
induction variable: ['k']
{
	loop info: Size l=0  l < dim[1]  ++l
	induction variable: ['k', 'l']
	{
		loop info: Size m=0  m < dim[2]  ++m
		induction variable: ['k', 'l', 'm']
		{
		L2680: (tmp[0]=,w) (tmp[1]=,w) (tmp[2]=,w) 
		L2681: (dim[0]+,r) (dim[0]*,r) (dim[1],r) 
		}
 	}
 }
array table
-----------------------------------------------
tmp -> [('[0]', 'w', 'normalized', ['k', 'l', 'm'], 2680), ('[1]', 'w', 'normalized', ['k', 'l', 'm'], 2680), ('[2]', 'w', 'normalized', ['k', 'l', 'm'], 2680)]
LDEs formed:6

dim -> [('[0]', 'r', 'normalized', ['k', 'l', 'm'], 2681), ('[0]', 'r', 'normalized', ['k', 'l', 'm'], 2681), ('[1]', 'r', 'normalized', ['k', 'l', 'm'], 2681)]
LDEs formed:0

distinct LDEs:
2=2
0=0
0=1
0=2
1=1
1=2
#########################################################################################
loop info: Size m=0  m < dim[2]  ++m
induction variable: ['m']
{
	loop info: Size l=0  l < dim[1]  ++l
	induction variable: ['m', 'l']
	{
		loop info: Size k=0  k < dim[0]  ++k, ++iter
		induction variable: ['m', 'l', 'k', 'iter']
		{
			loop info: Size n=1  n < 4  ++n
			induction variable: ['m', 'l', 'k', 'iter', 'n']
			{
			L2682: (dim[0]*,r) (dim[1],r) 
			L2683: (dim[1]-,r) 
			L2684: (dim[1]-,r) (dim[1]-,r) (dim[0],r) 
			}
			loop info: Size n=1  n < 7  ++n
			induction variable: ['m', 'l', 'k', 'iter', 'n']
			{
			L2685: (dim[0],r) 
			L2686: (dim[0]*,r) (dim[1],r) 
			}
 		}
 	}
 }
array table
-----------------------------------------------
dim -> [('[0]', 'r', 'normalized', ['m', 'l', 'k', 'iter', 'n'], 2682), ('[1]', 'r', 'normalized', ['m', 'l', 'k', 'iter', 'n'], 2682), ('[1]', 'r', 'normalized', ['m', 'l', 'k', 'iter', 'n'], 2683), ('[1]', 'r', 'normalized', ['m', 'l', 'k', 'iter', 'n'], 2684), ('[1]', 'r', 'normalized', ['m', 'l', 'k', 'iter', 'n'], 2684), ('[0]', 'r', 'normalized', ['m', 'l', 'k', 'iter', 'n'], 2684), ('[0]', 'r', 'normalized', ['m', 'l', 'k', 'iter', 'n'], 2685), ('[0]', 'r', 'normalized', ['m', 'l', 'k', 'iter', 'n'], 2686), ('[1]', 'r', 'normalized', ['m', 'l', 'k', 'iter', 'n'], 2686)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: FdmLinearOpIterator iter = index->begin()  iter != endIter  ++iter
induction variable: ['iter']
{
L2687: (r[iter.index()]=,w) 
}
array table
-----------------------------------------------
r -> [('[iter.index()]', 'w', 'not normalized', ['iter'], 2687)]
LDEs formed:1

distinct LDEs:
iter1.index()=iter2.index()
#########################################################################################
loop info: FdmLinearOpIterator iter = index->begin()  iter != endIter  ++iter
induction variable: ['iter']
{
L2688: (dims[2]-,r) (dims[2]-,r) 
L2689: (boundaries[2].first+,r) 
L2690: (boundaries[2].first+,r) 
L2691: (boundaries[2].first+,r) 
L2692: (boundaries[2].first,r) 
L2693: (dim[2]-,r) 
L2694: (boundaries[2].second,r) 
L2695: (boundaries[2].second-,r) 
L2696: (t[iter.index()],r) 
}
array table
-----------------------------------------------
boundaries -> [('[2]', 'r', 'normalized', ['iter'], 2689), ('[2]', 'r', 'normalized', ['iter'], 2690), ('[2]', 'r', 'normalized', ['iter'], 2691), ('[2]', 'r', 'normalized', ['iter'], 2692), ('[2]', 'r', 'normalized', ['iter'], 2694), ('[2]', 'r', 'normalized', ['iter'], 2695)]
LDEs formed:0

dims -> [('[2]', 'r', 'normalized', ['iter'], 2688), ('[2]', 'r', 'normalized', ['iter'], 2688)]
LDEs formed:0

t -> [('[iter.index()]', 'r', 'not normalized', ['iter'], 2696)]
LDEs formed:0

dim -> [('[2]', 'r', 'normalized', ['iter'], 2693)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: FdmLinearOpIterator iter = index->begin()  iter != endIter  ++iter
induction variable: ['iter']
{
L2694: (r[iter.index()]=,w) 
}
array table
-----------------------------------------------
r -> [('[iter.index()]', 'w', 'not normalized', ['iter'], 2694)]
LDEs formed:1

distinct LDEs:
iter1.index()=iter2.index()
#########################################################################################
loop info: FdmLinearOpIterator iter = index->begin()  iter != endIter  ++iter
induction variable: ['iter']
{
L2695: (dims[0]-,r) 
L2696: (t[i],r) 
}
array table
-----------------------------------------------
dims -> [('[0]', 'r', 'normalized', ['iter'], 2695)]
LDEs formed:0

t -> [('[i]', 'r', 'not normalized', ['iter'], 2696)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: FdmLinearOpIterator iter = index->begin()  iter != endIter  ++iter
induction variable: ['iter']
{
L2697: (dims[1]-,r) 
L2698: (t[i],r) 
}
array table
-----------------------------------------------
dims -> [('[1]', 'r', 'normalized', ['iter'], 2697)]
LDEs formed:0

t -> [('[i]', 'r', 'not normalized', ['iter'], 2698)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: FdmLinearOpIterator iter = index->begin()  iter != endIter  ++iter
induction variable: ['iter']
{
L2699: (dims[2]-,r) 
L2700: (t[i],r) 
}
array table
-----------------------------------------------
dims -> [('[2]', 'r', 'normalized', ['iter'], 2699)]
LDEs formed:0

t -> [('[i]', 'r', 'not normalized', ['iter'], 2700)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size direction=0  direction < 3  ++direction
induction variable: ['direction']
{
L2701: (twoPoints[0]=,w) 
L2702: (twoPoints[1]=,w) 
L2703: (twoPoints[0]=,w) 
L2704: (twoPoints[1]=,w) 
L2705: (threePoints[0]=,w) 
L2706: (threePoints[1]=,w) 
L2707: (threePoints[2]=,w) 
}
array table
-----------------------------------------------
threePoints -> [('[0]', 'w', 'normalized', ['direction'], 2705), ('[1]', 'w', 'normalized', ['direction'], 2706), ('[2]', 'w', 'normalized', ['direction'], 2707)]
LDEs formed:6

twoPoints -> [('[0]', 'w', 'normalized', ['direction'], 2701), ('[1]', 'w', 'normalized', ['direction'], 2702), ('[0]', 'w', 'normalized', ['direction'], 2703), ('[1]', 'w', 'normalized', ['direction'], 2704)]
LDEs formed:10

distinct LDEs:
2=2
0=0
0=1
0=2
1=1
1=2
#########################################################################################
loop info: FdmLinearOpIterator iter = index->begin()  iter != endIter  ++iter
induction variable: ['iter']
{
L2705: (r[iter.index()]=,w) 
}
array table
-----------------------------------------------
r -> [('[iter.index()]', 'w', 'not normalized', ['iter'], 2705)]
LDEs formed:1

distinct LDEs:
iter1.index()=iter2.index()
#########################################################################################
loop info: FdmLinearOpIterator iter = index->begin()  iter != endIter  ++iter
induction variable: ['iter']
{
L2706: (t[i],r) 
L2707: (t[i]-,r) (u[i],r) 
L2708: (t[i]-,r) (u[i],r) 
}
array table
-----------------------------------------------
u -> [('[i]', 'r', 'not normalized', ['iter'], 2707), ('[i]', 'r', 'not normalized', ['iter'], 2708)]
LDEs formed:0

t -> [('[i]', 'r', 'not normalized', ['iter'], 2706), ('[i]', 'r', 'not normalized', ['iter'], 2707), ('[i]', 'r', 'not normalized', ['iter'], 2708)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: FdmLinearOpIterator iter = index->begin()  iter != endIter  ++iter
induction variable: ['iter']
{
L2709: (t[i],r) 
L2710: (t[i]-,r) (u[i],r) 
L2711: (t[i]-,r) (u[i],r) 
}
array table
-----------------------------------------------
u -> [('[i]', 'r', 'not normalized', ['iter'], 2710), ('[i]', 'r', 'not normalized', ['iter'], 2711)]
LDEs formed:0

t -> [('[i]', 'r', 'not normalized', ['iter'], 2709), ('[i]', 'r', 'not normalized', ['iter'], 2710), ('[i]', 'r', 'not normalized', ['iter'], 2711)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: FdmLinearOpIterator iter = index->begin()  iter != endIter  ++iter
induction variable: ['iter']
{
L2712: (t[i],r) 
L2713: (t[i]-,r) (u[i],r) 
L2714: (t[i]-,r) (u[i],r) 
}
array table
-----------------------------------------------
u -> [('[i]', 'r', 'not normalized', ['iter'], 2713), ('[i]', 'r', 'not normalized', ['iter'], 2714)]
LDEs formed:0

t -> [('[i]', 'r', 'not normalized', ['iter'], 2712), ('[i]', 'r', 'not normalized', ['iter'], 2713), ('[i]', 'r', 'not normalized', ['iter'], 2714)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i < u.size()  ++i
induction variable: ['i']
{
L2715: (u[i]-,r) (t[i],r) 
L2716: (u[i],r) 
L2717: (t[i],r) 
}
array table
-----------------------------------------------
u -> [('[i]', 'r', 'normalized', ['i'], 2715), ('[i]', 'r', 'normalized', ['i'], 2716)]
LDEs formed:0

t -> [('[i]', 'r', 'normalized', ['i'], 2715), ('[i]', 'r', 'normalized', ['i'], 2717)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i < u.size()  ++i
induction variable: ['i']
{
L2718: (u[i]-,r) (t[i],r) 
L2719: (u[i],r) 
L2720: (t[i],r) 
}
array table
-----------------------------------------------
u -> [('[i]', 'r', 'normalized', ['i'], 2718), ('[i]', 'r', 'normalized', ['i'], 2719)]
LDEs formed:0

t -> [('[i]', 'r', 'normalized', ['i'], 2718), ('[i]', 'r', 'normalized', ['i'], 2720)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i < u.size()  ++i
induction variable: ['i']
{
L2721: (u[i]-,r) (t[i],r) 
L2722: (u[i],r) 
L2723: (t[i],r) 
}
array table
-----------------------------------------------
u -> [('[i]', 'r', 'normalized', ['i'], 2721), ('[i]', 'r', 'normalized', ['i'], 2722)]
LDEs formed:0

t -> [('[i]', 'r', 'normalized', ['i'], 2721), ('[i]', 'r', 'normalized', ['i'], 2723)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i < u.size()  ++i
induction variable: ['i']
{
L2724: (u[i]-,r) (t[i],r) 
L2725: (u[i],r) 
L2726: (t[i],r) 
}
array table
-----------------------------------------------
u -> [('[i]', 'r', 'normalized', ['i'], 2724), ('[i]', 'r', 'normalized', ['i'], 2725)]
LDEs formed:0

t -> [('[i]', 'r', 'normalized', ['i'], 2724), ('[i]', 'r', 'normalized', ['i'], 2726)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size k=0  k < dim[2]  ++k
induction variable: ['k']
{
L2727: (dim[0],r) (dim[1],r) 
	loop info: Size i=0  i < dim[0]  ++i
	induction variable: ['k', 'i']
	{
	}
 }
array table
-----------------------------------------------
dim -> [('[0]', 'r', 'normalized', ['k', 'i'], 2727), ('[1]', 'r', 'normalized', ['k', 'i'], 2727)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i < b.size()  ++i
induction variable: ['i']
{
L2728: (b[i]=,w) 
}
array table
-----------------------------------------------
b -> [('[i]', 'w', 'normalized', ['i'], 2728)]
LDEs formed:1

distinct LDEs:
i1=i2
#########################################################################################
loop info: Size i=0  i < v.size()  ++i
induction variable: ['i']
{
L2729: (v[i],r) 
	loop info: Size j=0  j < nElements  ++j
	induction variable: ['i', 'j']
	{
	}
 }
array table
-----------------------------------------------
v -> [('[i]', 'r', 'normalized', ['i', 'j'], 2729)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/sampledcurve.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/fastfouriertransform.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: size_t i = 0  i<8  i++
induction variable: ['i']
{
L2730: (b[i].real,r) (expected[i].real,r) 
L2731: (b[i].imag,r) (expected[i].imag,r) 
L2732: (b[i]<<,r) 
L2733: (expected[i],r) 
}
array table
-----------------------------------------------
expected -> [('[i]', 'r', 'normalized', ['i'], 2730), ('[i]', 'r', 'normalized', ['i'], 2731), ('[i]', 'r', 'normalized', ['i'], 2733)]
LDEs formed:0

b -> [('[i]', 'r', 'normalized', ['i'], 2730), ('[i]', 'r', 'normalized', ['i'], 2731), ('[i]', 'r', 'normalized', ['i'], 2732)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<nFrq  ++i
induction variable: ['i']
{
L2733: (tmp[i]=,w) (ft[i],r) 
L2734: (ft[i]=,w) 
}
array table
-----------------------------------------------
tmp -> [('[i]', 'w', 'normalized', ['i'], 2733)]
LDEs formed:1

ft -> [('[i]', 'r', 'normalized', ['i'], 2733), ('[i]', 'w', 'normalized', ['i'], 2734)]
LDEs formed:2

distinct LDEs:
i1=i2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/catbonds.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/europeanoption.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<LENGTH(values)  i++
induction variable: ['i']
{
L2735: (values[i].type,r) (values[i].strike,r) 
L2736: (values[i].t,r) 
L2737: (values[i].s,r) 
L2738: (values[i].q,r) 
L2739: (values[i].r,r) 
L2740: (values[i].v,r) 
L2741: (values[i].result,r) 
L2742: (values[i].tol,r) 
L2743: (values[i].s,r) 
L2744: (values[i].q,r) (values[i].r,r) 
L2745: (values[i].v,r) (values[i].result,r) 
L2746: (values[i].result,r) 
L2747: (values[i].s,r) 
L2748: (values[i].q,r) (values[i].r,r) 
L2749: (values[i].v,r) (values[i].result,r) 
}
array table
-----------------------------------------------
values -> [('[i]', 'r', 'normalized', ['i'], 2735), ('[i]', 'r', 'normalized', ['i'], 2735), ('[i]', 'r', 'normalized', ['i'], 2736), ('[i]', 'r', 'normalized', ['i'], 2737), ('[i]', 'r', 'normalized', ['i'], 2738), ('[i]', 'r', 'normalized', ['i'], 2739), ('[i]', 'r', 'normalized', ['i'], 2740), ('[i]', 'r', 'normalized', ['i'], 2741), ('[i]', 'r', 'normalized', ['i'], 2742), ('[i]', 'r', 'normalized', ['i'], 2743), ('[i]', 'r', 'normalized', ['i'], 2744), ('[i]', 'r', 'normalized', ['i'], 2744), ('[i]', 'r', 'normalized', ['i'], 2745), ('[i]', 'r', 'normalized', ['i'], 2745), ('[i]', 'r', 'normalized', ['i'], 2746), ('[i]', 'r', 'normalized', ['i'], 2747), ('[i]', 'r', 'normalized', ['i'], 2748), ('[i]', 'r', 'normalized', ['i'], 2748), ('[i]', 'r', 'normalized', ['i'], 2749), ('[i]', 'r', 'normalized', ['i'], 2749)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<LENGTH(types)  i++
induction variable: ['i']
{
	loop info: Size j=0  j<LENGTH(strikes)  j++
	induction variable: ['i', 'j']
	{
		loop info: Size k=0  k<LENGTH(residualTimes)  k++
		induction variable: ['i', 'j', 'k']
		{
		L2750: (residualTimes[k],r) 
			loop info: Size kk=0  kk<4  kk++
			induction variable: ['i', 'j', 'k', 'kk']
			{
			L2751: (types[i],r) (strikes[j],r) 
			L2752: (types[i],r) (strikes[j],r) 
			L2753: (types[i],r) (strikes[j],r) 
			L2754: (types[i],r) (strikes[j],r) 
				loop info: Size l=0  l<LENGTH(underlyings)  l++
				induction variable: ['i', 'j', 'k', 'kk', 'l']
				{
					loop info: Size m=0  m<LENGTH(qRates)  m++
					induction variable: ['i', 'j', 'k', 'kk', 'l', 'm']
					{
						loop info: Size n=0  n<LENGTH(rRates)  n++
						induction variable: ['i', 'j', 'k', 'kk', 'l', 'm', 'n']
						{
							loop info: Size p=0  p<LENGTH(vols)  p++
							induction variable: ['i', 'j', 'k', 'kk', 'l', 'm', 'n', 'p']
							{
							L2755: (underlyings[l],r) 
							L2756: (qRates[m],r) 
							L2757: (rRates[n],r) 
							L2758: (vols[p],r) 
							L2759: (calculated["delta"]=,w) 
							L2760: (calculated["gamma"]=,w) 
							L2761: (calculated["theta"]=,w) 
							L2762: (calculated["rho"]=,w) 
							L2763: (calculated["divRho"]=,w) 
							L2764: (calculated["vega"]=,w) 
							L2765: (expected["delta"]=,w) 
							L2766: (expected["gamma"]=,w) 
							L2767: (expected["rho"]=,w) 
							L2768: (expected["divRho"]=,w) 
							L2769: (expected["vega"]=,w) 
							L2770: (expected["theta"]=,w) 
							L2771: (calculated[greek],r) 
							}
 						}
 					}
 				}
 			}
 		}
 	}
 }
array table
-----------------------------------------------
residualTimes -> [('[k]', 'r', 'normalized', ['i', 'j', 'k', 'kk', 'l', 'm', 'n', 'p'], 2750)]
LDEs formed:0

rRates -> [('[n]', 'r', 'normalized', ['i', 'j', 'k', 'kk', 'l', 'm', 'n', 'p'], 2757)]
LDEs formed:0

calculated -> [('["delta"]', 'w', 'not normalized', ['i', 'j', 'k', 'kk', 'l', 'm', 'n', 'p'], 2759), ('["gamma"]', 'w', 'not normalized', ['i', 'j', 'k', 'kk', 'l', 'm', 'n', 'p'], 2760), ('["theta"]', 'w', 'not normalized', ['i', 'j', 'k', 'kk', 'l', 'm', 'n', 'p'], 2761), ('["rho"]', 'w', 'not normalized', ['i', 'j', 'k', 'kk', 'l', 'm', 'n', 'p'], 2762), ('["divRho"]', 'w', 'not normalized', ['i', 'j', 'k', 'kk', 'l', 'm', 'n', 'p'], 2763), ('["vega"]', 'w', 'not normalized', ['i', 'j', 'k', 'kk', 'l', 'm', 'n', 'p'], 2764), ('[greek]', 'r', 'not normalized', ['i', 'j', 'k', 'kk', 'l', 'm', 'n', 'p'], 2771)]
LDEs formed:27

qRates -> [('[m]', 'r', 'normalized', ['i', 'j', 'k', 'kk', 'l', 'm', 'n', 'p'], 2756)]
LDEs formed:0

strikes -> [('[j]', 'r', 'normalized', ['i', 'j', 'k', 'kk', 'l', 'm', 'n', 'p'], 2751), ('[j]', 'r', 'normalized', ['i', 'j', 'k', 'kk', 'l', 'm', 'n', 'p'], 2752), ('[j]', 'r', 'normalized', ['i', 'j', 'k', 'kk', 'l', 'm', 'n', 'p'], 2753), ('[j]', 'r', 'normalized', ['i', 'j', 'k', 'kk', 'l', 'm', 'n', 'p'], 2754)]
LDEs formed:0

underlyings -> [('[l]', 'r', 'normalized', ['i', 'j', 'k', 'kk', 'l', 'm', 'n', 'p'], 2755)]
LDEs formed:0

vols -> [('[p]', 'r', 'normalized', ['i', 'j', 'k', 'kk', 'l', 'm', 'n', 'p'], 2758)]
LDEs formed:0

expected -> [('["delta"]', 'w', 'not normalized', ['i', 'j', 'k', 'kk', 'l', 'm', 'n', 'p'], 2765), ('["gamma"]', 'w', 'not normalized', ['i', 'j', 'k', 'kk', 'l', 'm', 'n', 'p'], 2766), ('["rho"]', 'w', 'not normalized', ['i', 'j', 'k', 'kk', 'l', 'm', 'n', 'p'], 2767), ('["divRho"]', 'w', 'not normalized', ['i', 'j', 'k', 'kk', 'l', 'm', 'n', 'p'], 2768), ('["vega"]', 'w', 'not normalized', ['i', 'j', 'k', 'kk', 'l', 'm', 'n', 'p'], 2769), ('["theta"]', 'w', 'not normalized', ['i', 'j', 'k', 'kk', 'l', 'm', 'n', 'p'], 2770)]
LDEs formed:21

types -> [('[i]', 'r', 'normalized', ['i', 'j', 'k', 'kk', 'l', 'm', 'n', 'p'], 2751), ('[i]', 'r', 'normalized', ['i', 'j', 'k', 'kk', 'l', 'm', 'n', 'p'], 2752), ('[i]', 'r', 'normalized', ['i', 'j', 'k', 'kk', 'l', 'm', 'n', 'p'], 2753), ('[i]', 'r', 'normalized', ['i', 'j', 'k', 'kk', 'l', 'm', 'n', 'p'], 2754)]
LDEs formed:0

distinct LDEs:
"gamma"="divRho"
"divRho"="divRho"
"theta"="rho"
"theta"="theta"
"gamma"="vega"
"theta"="vega"
"rho"="rho"
"divRho"="vega"
"delta"="delta"
"rho"="vega"
"delta"="theta"
"delta"="rho"
"gamma"="theta"
"vega"="vega"
"rho"=greek
"delta"="divRho"
"delta"=greek
"gamma"=greek
"gamma"="rho"
"vega"=greek
"delta"="gamma"
"gamma"="gamma"
"delta"="vega"
"theta"="divRho"
"rho"="divRho"
"theta"=greek
"divRho"=greek
#########################################################################################
loop info: Size i=0  i<LENGTH(types)  i++
induction variable: ['i']
{
	loop info: Size j=0  j<LENGTH(strikes)  j++
	induction variable: ['i', 'j']
	{
		loop info: Size k=0  k<LENGTH(lengths)  k++
		induction variable: ['i', 'j', 'k']
		{
		L2755: (lengths[k],r) 
		L2756: (types[i],r) (strikes[j],r) 
			loop info: Size l=0  l<LENGTH(underlyings)  l++
			induction variable: ['i', 'j', 'k', 'l']
			{
				loop info: Size m=0  m<LENGTH(qRates)  m++
				induction variable: ['i', 'j', 'k', 'l', 'm']
				{
					loop info: Size n=0  n<LENGTH(rRates)  n++
					induction variable: ['i', 'j', 'k', 'l', 'm', 'n']
					{
						loop info: Size p=0  p<LENGTH(vols)  p++
						induction variable: ['i', 'j', 'k', 'l', 'm', 'n', 'p']
						{
						L2757: (underlyings[l],r) 
						L2758: (qRates[m],r) 
						L2759: (rRates[n],r) 
						L2760: (vols[p],r) 
						L2761: (types[i]<<,r) 
						L2762: (strikes[j]<<,r) 
						L2763: (types[i]<<,r) 
						L2764: (strikes[j]<<,r) 
						}
 					}
 				}
 			}
 		}
 	}
 }
array table
-----------------------------------------------
rRates -> [('[n]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p'], 2759)]
LDEs formed:0

lengths -> [('[k]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p'], 2755)]
LDEs formed:0

qRates -> [('[m]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p'], 2758)]
LDEs formed:0

strikes -> [('[j]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p'], 2756), ('[j]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p'], 2762), ('[j]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p'], 2764)]
LDEs formed:0

underlyings -> [('[l]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p'], 2757)]
LDEs formed:0

vols -> [('[p]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p'], 2760)]
LDEs formed:0

types -> [('[i]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p'], 2756), ('[i]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p'], 2761), ('[i]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p'], 2763)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<LENGTH(types)  i++
induction variable: ['i']
{
	loop info: Size j=0  j<LENGTH(strikes)  j++
	induction variable: ['i', 'j']
	{
		loop info: Size k=0  k<LENGTH(lengths)  k++
		induction variable: ['i', 'j', 'k']
		{
		L2764: (lengths[k]*,r) 
		L2765: (types[i],r) (strikes[j],r) 
			loop info: Size l=0  l<LENGTH(underlyings)  l++
			induction variable: ['i', 'j', 'k', 'l']
			{
				loop info: Size m=0  m<LENGTH(qRates)  m++
				induction variable: ['i', 'j', 'k', 'l', 'm']
				{
					loop info: Size n=0  n<LENGTH(rRates)  n++
					induction variable: ['i', 'j', 'k', 'l', 'm', 'n']
					{
						loop info: Size p=0  p<LENGTH(vols)  p++
						induction variable: ['i', 'j', 'k', 'l', 'm', 'n', 'p']
						{
						L2766: (underlyings[l],r) 
						L2767: (qRates[m],r) 
						L2768: (rRates[n],r) 
						L2769: (vols[p],r) 
						L2770: (expected["value"]=,w) 
						L2771: (calculated["value"]=,w) 
						L2772: (expected["delta"]=,w) 
						L2773: (expected["gamma"]=,w) 
						L2774: (expected["theta"]=,w) 
						L2775: (calculated["delta"]=,w) 
						L2776: (calculated["gamma"]=,w) 
						L2777: (calculated["theta"]=,w) 
						L2778: (calculated[greek],r) 
						}
 					}
 				}
 			}
 		}
 	}
 }
array table
-----------------------------------------------
rRates -> [('[n]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p'], 2768)]
LDEs formed:0

lengths -> [('[k]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p'], 2764)]
LDEs formed:0

calculated -> [('["value"]', 'w', 'not normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p'], 2771), ('["delta"]', 'w', 'not normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p'], 2775), ('["gamma"]', 'w', 'not normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p'], 2776), ('["theta"]', 'w', 'not normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p'], 2777), ('[greek]', 'r', 'not normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p'], 2778)]
LDEs formed:14

qRates -> [('[m]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p'], 2767)]
LDEs formed:0

strikes -> [('[j]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p'], 2765)]
LDEs formed:0

underlyings -> [('[l]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p'], 2766)]
LDEs formed:0

vols -> [('[p]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p'], 2769)]
LDEs formed:0

expected -> [('["value"]', 'w', 'not normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p'], 2770), ('["delta"]', 'w', 'not normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p'], 2772), ('["gamma"]', 'w', 'not normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p'], 2773), ('["theta"]', 'w', 'not normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p'], 2774)]
LDEs formed:10

types -> [('[i]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'm', 'n', 'p'], 2765)]
LDEs formed:0

distinct LDEs:
"delta"="delta"
"delta"="gamma"
"gamma"="theta"
"value"="delta"
"gamma"="gamma"
"value"="gamma"
"delta"=greek
"delta"="theta"
"value"=greek
"theta"="theta"
"value"="value"
"theta"=greek
"gamma"=greek
"value"="theta"
#########################################################################################
loop info: Size i=0  i<LENGTH(values)  i++
induction variable: ['i']
{
L2766: (values[i].type,r) (values[i].strike,r) 
L2767: (values[i].t,r) 
L2768: (values[i].s,r) 
L2769: (values[i].q,r) 
L2770: (values[i].r,r) 
L2771: (values[i].v,r) 
L2772: (values[i].s,r) 
L2773: (values[i].q,r) (values[i].r,r) 
L2774: (values[i].v,r) (values[i].result,r) 
	loop info: Size i=start  i < end  i++
	induction variable: ['i']
	{
	L2775: (values[i].q,r) (values[i].r,r) 
	L2776: (values[i].v,r) 
	}
 }
array table
-----------------------------------------------
values -> [('[i]', 'r', 'normalized', ['i'], 2766), ('[i]', 'r', 'normalized', ['i'], 2766), ('[i]', 'r', 'normalized', ['i'], 2767), ('[i]', 'r', 'normalized', ['i'], 2768), ('[i]', 'r', 'normalized', ['i'], 2769), ('[i]', 'r', 'normalized', ['i'], 2770), ('[i]', 'r', 'normalized', ['i'], 2771), ('[i]', 'r', 'normalized', ['i'], 2772), ('[i]', 'r', 'normalized', ['i'], 2773), ('[i]', 'r', 'normalized', ['i'], 2773), ('[i]', 'r', 'normalized', ['i'], 2774), ('[i]', 'r', 'normalized', ['i'], 2774), ('[i]', 'r', 'normalized', ['i'], 2775), ('[i]', 'r', 'normalized', ['i'], 2775), ('[i]', 'r', 'normalized', ['i'], 2776)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i = 0  i < 8  ++i
induction variable: ['i']
{
L2777: (t[i],r) 
L2778: (r[i],r) 
}
array table
-----------------------------------------------
r -> [('[i]', 'r', 'normalized', ['i'], 2778)]
LDEs formed:0

t -> [('[i]', 'r', 'normalized', ['i'], 2777)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i < strikes.size()  ++i
induction variable: ['i']
{
L2778: (blackVolMatrix[i][j-1]=,w) (v[i*(dates.size()-1)+j-1],r) 
}
array table
-----------------------------------------------
blackVolMatrix -> [('[i][j-1]', 'w', 'not normalized', ['i'], 2778)]
LDEs formed:2

v -> [('[i*(dates.size()-1)+j-1]', 'r', 'not normalized', ['i'], 2778)]
LDEs formed:0

distinct LDEs:
i1=i2,j-1=j-1
#########################################################################################
loop info: Size i=2  i < dates.size()  ++i
induction variable: ['i']
{
	loop info: Size j=3  j < strikes.size()-5  j+=5
	induction variable: ['i', 'j']
	{
	L2779: (dates[i],r) 
	L2780: (strikes[j],r) 
	}
 }
array table
-----------------------------------------------
dates -> [('[i]', 'r', 'normalized', ['i', 'j'], 2779)]
LDEs formed:0

strikes -> [('[j]', 'r', 'normalized', ['i', 'j'], 2780)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/brownianbridge.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<samples  ++i
induction variable: ['i']
{
L2781: (temp[0]=,w) (temp[0]*,r) (times[0],r) 
	loop info: Size j=1  j<N  ++j
	induction variable: ['i', 'j']
	{
	}
 }
array table
-----------------------------------------------
temp -> [('[0]', 'w', 'normalized', ['i', 'j'], 2781), ('[0]', 'r', 'normalized', ['i', 'j'], 2781)]
LDEs formed:2

times -> [('[0]', 'r', 'normalized', ['i', 'j'], 2781)]
LDEs formed:0

distinct LDEs:
0=0
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/lowdiscrepancysequences.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

	loop info: i=0  i<dimensionality  i++
	induction variable: ['j', 'k', 'i']
	{
	L2782: (mean[i]-,r) 
	L2783: (mean[i],r) 
	}
 }
array table
-----------------------------------------------
mean -> [('[i]', 'r', 'normalized', ['j', 'k', 'i'], 2782), ('[i]', 'r', 'normalized', ['j', 'k', 'i'], 2783)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: i=0  i<points  i++
induction variable: ['i']
{
L2784: (point[0]-,r) (vanderCorputSequenceModuloTwo[i],r) 
L2785: (point[0],r) 
L2786: (vanderCorputSequenceModuloTwo[i],r) 
}
array table
-----------------------------------------------
vanderCorputSequenceModuloTwo -> [('[i]', 'r', 'normalized', ['i'], 2784), ('[i]', 'r', 'normalized', ['i'], 2786)]
LDEs formed:0

point -> [('[0]', 'r', 'normalized', ['i'], 2784), ('[0]', 'r', 'normalized', ['i'], 2785)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: i=0  i<points  i++
induction variable: ['i']
{
L2786: (point[0]-,r) (vanderCorputSequenceModuloTwo[i],r) 
L2787: (point[0],r) 
L2788: (vanderCorputSequenceModuloTwo[i],r) 
}
array table
-----------------------------------------------
vanderCorputSequenceModuloTwo -> [('[i]', 'r', 'normalized', ['i'], 2786), ('[i]', 'r', 'normalized', ['i'], 2788)]
LDEs formed:0

point -> [('[0]', 'r', 'normalized', ['i'], 2786), ('[0]', 'r', 'normalized', ['i'], 2787)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: i=0  i<points  i++
induction variable: ['i']
{
L2788: (point[0]-,r) (vanderCorputSequenceModuloTwo[i],r) 
L2789: (point[0],r) 
L2790: (vanderCorputSequenceModuloTwo[i],r) 
L2791: (point[1]-,r) (FaureDimensionTwoOfTwo[i],r) 
L2792: (point[1],r) 
L2793: (FaureDimensionTwoOfTwo[i],r) 
}
array table
-----------------------------------------------
FaureDimensionTwoOfTwo -> [('[i]', 'r', 'normalized', ['i'], 2791), ('[i]', 'r', 'normalized', ['i'], 2793)]
LDEs formed:0

vanderCorputSequenceModuloTwo -> [('[i]', 'r', 'normalized', ['i'], 2788), ('[i]', 'r', 'normalized', ['i'], 2790)]
LDEs formed:0

point -> [('[0]', 'r', 'normalized', ['i'], 2788), ('[0]', 'r', 'normalized', ['i'], 2789), ('[1]', 'r', 'normalized', ['i'], 2791), ('[1]', 'r', 'normalized', ['i'], 2792)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: i=0  i<points  i++
induction variable: ['i']
{
L2793: (point[0]-,r) (FaureDimensionOneOfThree[i],r) 
L2794: (point[0],r) 
L2795: (FaureDimensionOneOfThree[i],r) 
L2796: (point[1]-,r) (FaureDimensionTwoOfThree[i],r) 
L2797: (point[1],r) 
L2798: (FaureDimensionTwoOfThree[i],r) 
L2799: (point[2]-,r) (FaureDimensionThreeOfThree[i],r) 
L2800: (point[2],r) 
L2801: (FaureDimensionThreeOfThree[i],r) 
}
array table
-----------------------------------------------
FaureDimensionTwoOfThree -> [('[i]', 'r', 'normalized', ['i'], 2796), ('[i]', 'r', 'normalized', ['i'], 2798)]
LDEs formed:0

FaureDimensionOneOfThree -> [('[i]', 'r', 'normalized', ['i'], 2793), ('[i]', 'r', 'normalized', ['i'], 2795)]
LDEs formed:0

FaureDimensionThreeOfThree -> [('[i]', 'r', 'normalized', ['i'], 2799), ('[i]', 'r', 'normalized', ['i'], 2801)]
LDEs formed:0

point -> [('[0]', 'r', 'normalized', ['i'], 2793), ('[0]', 'r', 'normalized', ['i'], 2794), ('[1]', 'r', 'normalized', ['i'], 2796), ('[1]', 'r', 'normalized', ['i'], 2797), ('[2]', 'r', 'normalized', ['i'], 2799), ('[2]', 'r', 'normalized', ['i'], 2800)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: i=0  i<points  i++
induction variable: ['i']
{
L2801: (point[0]-,r) (vanderCorputSequenceModuloTwo[i],r) 
L2802: (point[0],r) 
L2803: (vanderCorputSequenceModuloTwo[i],r) 
}
array table
-----------------------------------------------
vanderCorputSequenceModuloTwo -> [('[i]', 'r', 'normalized', ['i'], 2801), ('[i]', 'r', 'normalized', ['i'], 2803)]
LDEs formed:0

point -> [('[0]', 'r', 'normalized', ['i'], 2801), ('[0]', 'r', 'normalized', ['i'], 2802)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: i=0  i<points  i++
induction variable: ['i']
{
L2803: (point[0]-,r) (vanderCorputSequenceModuloTwo[i],r) 
L2804: (point[0],r) 
L2805: (vanderCorputSequenceModuloTwo[i],r) 
L2806: (point[1]-,r) (vanderCorputSequenceModuloThree[i],r) 
L2807: (point[1],r) 
L2808: (vanderCorputSequenceModuloThree[i],r) 
}
array table
-----------------------------------------------
vanderCorputSequenceModuloThree -> [('[i]', 'r', 'normalized', ['i'], 2806), ('[i]', 'r', 'normalized', ['i'], 2808)]
LDEs formed:0

vanderCorputSequenceModuloTwo -> [('[i]', 'r', 'normalized', ['i'], 2803), ('[i]', 'r', 'normalized', ['i'], 2805)]
LDEs formed:0

point -> [('[0]', 'r', 'normalized', ['i'], 2803), ('[0]', 'r', 'normalized', ['i'], 2804), ('[1]', 'r', 'normalized', ['i'], 2806), ('[1]', 'r', 'normalized', ['i'], 2807)]
LDEs formed:0

distinct LDEs:
#########################################################################################
L2808: (mean[0]-,r) 
L2809: (mean[0],r) 
}
array table
-----------------------------------------------
mean -> [('[0]', 'r', 'normalized', ['j', 'k'], 2808), ('[0]', 'r', 'normalized', ['j', 'k'], 2809)]
LDEs formed:0

distinct LDEs:
#########################################################################################
L2810: (mean[1]-,r) 
L2811: (mean[1],r) 
}
array table
-----------------------------------------------
mean -> [('[1]', 'r', 'normalized', ['j', 'k'], 2810), ('[1]', 'r', 'normalized', ['j', 'k'], 2811)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Integer i = 0  i<8  i++
induction variable: ['i']
{
L2812: (dimensionality[i],r) 
	loop info: j=jMin  j<jMin+sampleLoops  j++
	induction variable: ['i', 'j']
		{
			loop info:   k<points  k++
			induction variable: ['i', 'j', 'k']
			{
			}
		L2813: (discrepancy[i][j-jMin],r) 
		L2814: (dimensionality[i],r) 
		L2815: (discrepancy[i][j-jMin],r) 
		}
 }
array table
-----------------------------------------------
dimensionality -> [('[i]', 'r', 'normalized', ['i', 'j', 'k'], 2812), ('[i]', 'r', 'normalized', ['i', 'j', 'k'], 2814)]
LDEs formed:0

discrepancy -> [('[i][j-jMin]', 'r', 'not normalized', ['i', 'j', 'k'], 2813), ('[i][j-jMin]', 'r', 'not normalized', ['i', 'j', 'k'], 2815)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<LENGTH(integers)  i++
induction variable: ['i']
{
	loop info: Size j=0  j<LENGTH(dimensionality)  j++
	induction variable: ['i', 'j']
	{
		loop info: Size k=0  k<LENGTH(skip)  k++
		induction variable: ['i', 'j', 'k']
		{
		L2816: (dimensionality[j],r) (integers[i],r) 
			loop info: Size l=0  l<skip[k]  l++
			induction variable: ['i', 'j', 'k', 'l']
			{
			}
		L2817: (dimensionality[j],r) (integers[i],r) 
		L2818: (skip[k],r) 
			loop info: Size m=0  m<100  m++
			induction variable: ['i', 'j', 'k', 'l', 'm']
			{
				loop info: Size n=0  n<s1.size()  n++
				induction variable: ['i', 'j', 'k', 'l', 'm', 'n']
				{
				L2819: (s1[n],r) (s2[n],r) 
				L2820: (dimensionality[j],r) 
				L2821: (integers[i],r) 
				L2822: (skip[k],r) 
				L2823: (s1[n],r) 
				L2824: (s2[n],r) 
				}
 			}
 		}
 	}
 }
array table
-----------------------------------------------
s2 -> [('[n]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'm', 'n'], 2819), ('[n]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'm', 'n'], 2824)]
LDEs formed:0

integers -> [('[i]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'm', 'n'], 2816), ('[i]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'm', 'n'], 2817), ('[i]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'm', 'n'], 2821)]
LDEs formed:0

s1 -> [('[n]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'm', 'n'], 2819), ('[n]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'm', 'n'], 2823)]
LDEs formed:0

dimensionality -> [('[j]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'm', 'n'], 2816), ('[j]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'm', 'n'], 2817), ('[j]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'm', 'n'], 2820)]
LDEs formed:0

skip -> [('[k]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'm', 'n'], 2818), ('[k]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'm', 'n'], 2822)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/lookbackoptions.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<LENGTH(values)  i++
induction variable: ['i']
{
L2823: (values[i].t*,r) 
L2824: (values[i].s,r) 
L2825: (values[i].q,r) 
L2826: (values[i].r,r) 
L2827: (values[i].v,r) 
L2828: (values[i].type,r) 
L2829: (values[i].minmax,r) 
L2830: (values[i].result,r) 
L2831: (values[i].tol,r) 
L2832: (values[i].minmax,r) 
L2833: (values[i].s,r) (values[i].q,r) 
L2834: (values[i].r,r) (values[i].v,r) 
L2835: (values[i].tol,r) 
}
array table
-----------------------------------------------
values -> [('[i]', 'r', 'normalized', ['i'], 2823), ('[i]', 'r', 'normalized', ['i'], 2824), ('[i]', 'r', 'normalized', ['i'], 2825), ('[i]', 'r', 'normalized', ['i'], 2826), ('[i]', 'r', 'normalized', ['i'], 2827), ('[i]', 'r', 'normalized', ['i'], 2828), ('[i]', 'r', 'normalized', ['i'], 2829), ('[i]', 'r', 'normalized', ['i'], 2830), ('[i]', 'r', 'normalized', ['i'], 2831), ('[i]', 'r', 'normalized', ['i'], 2832), ('[i]', 'r', 'normalized', ['i'], 2833), ('[i]', 'r', 'normalized', ['i'], 2833), ('[i]', 'r', 'normalized', ['i'], 2834), ('[i]', 'r', 'normalized', ['i'], 2834), ('[i]', 'r', 'normalized', ['i'], 2835)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<LENGTH(values)  i++
induction variable: ['i']
{
L2836: (values[i].t*,r) 
L2837: (values[i].s,r) 
L2838: (values[i].q,r) 
L2839: (values[i].r,r) 
L2840: (values[i].v,r) 
L2841: (values[i].type,r) (values[i].strike,r) 
L2842: (values[i].minmax,r) 
L2843: (values[i].result,r) 
L2844: (values[i].tol,r) 
L2845: (values[i].minmax,r) 
L2846: (values[i].s,r) (values[i].q,r) (values[i].r,r) 
L2847: (values[i].v,r) 
L2848: (values[i].tol,r) 
}
array table
-----------------------------------------------
values -> [('[i]', 'r', 'normalized', ['i'], 2836), ('[i]', 'r', 'normalized', ['i'], 2837), ('[i]', 'r', 'normalized', ['i'], 2838), ('[i]', 'r', 'normalized', ['i'], 2839), ('[i]', 'r', 'normalized', ['i'], 2840), ('[i]', 'r', 'normalized', ['i'], 2841), ('[i]', 'r', 'normalized', ['i'], 2841), ('[i]', 'r', 'normalized', ['i'], 2842), ('[i]', 'r', 'normalized', ['i'], 2843), ('[i]', 'r', 'normalized', ['i'], 2844), ('[i]', 'r', 'normalized', ['i'], 2845), ('[i]', 'r', 'normalized', ['i'], 2846), ('[i]', 'r', 'normalized', ['i'], 2846), ('[i]', 'r', 'normalized', ['i'], 2846), ('[i]', 'r', 'normalized', ['i'], 2847), ('[i]', 'r', 'normalized', ['i'], 2848)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<LENGTH(values)  i++
induction variable: ['i']
{
L2849: (values[i].t*,r) 
L2850: (values[i].s,r) 
L2851: (values[i].q,r) 
L2852: (values[i].r,r) 
L2853: (values[i].v,r) 
L2854: (values[i].type,r) 
L2855: (values[i].t1*,r) 
L2856: (values[i].minmax,r) 
L2857: (values[i].l,r) 
L2858: (values[i].result,r) 
L2859: (values[i].tol,r) 
L2860: (values[i].minmax,r) 
L2861: (values[i].s,r) (values[i].q,r) 
L2862: (values[i].r,r) (values[i].v,r) 
L2863: (values[i].tol,r) 
}
array table
-----------------------------------------------
values -> [('[i]', 'r', 'normalized', ['i'], 2849), ('[i]', 'r', 'normalized', ['i'], 2850), ('[i]', 'r', 'normalized', ['i'], 2851), ('[i]', 'r', 'normalized', ['i'], 2852), ('[i]', 'r', 'normalized', ['i'], 2853), ('[i]', 'r', 'normalized', ['i'], 2854), ('[i]', 'r', 'normalized', ['i'], 2855), ('[i]', 'r', 'normalized', ['i'], 2856), ('[i]', 'r', 'normalized', ['i'], 2857), ('[i]', 'r', 'normalized', ['i'], 2858), ('[i]', 'r', 'normalized', ['i'], 2859), ('[i]', 'r', 'normalized', ['i'], 2860), ('[i]', 'r', 'normalized', ['i'], 2861), ('[i]', 'r', 'normalized', ['i'], 2861), ('[i]', 'r', 'normalized', ['i'], 2862), ('[i]', 'r', 'normalized', ['i'], 2862), ('[i]', 'r', 'normalized', ['i'], 2863)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<LENGTH(values)  i++
induction variable: ['i']
{
L2864: (values[i].t*,r) 
L2865: (values[i].s,r) 
L2866: (values[i].q,r) 
L2867: (values[i].r,r) 
L2868: (values[i].v,r) 
L2869: (values[i].type,r) (values[i].strike,r) 
L2870: (values[i].t1*,r) 
L2871: (values[i].result,r) 
L2872: (values[i].tol,r) 
L2873: (values[i].minmax,r) 
L2874: (values[i].s,r) (values[i].q,r) (values[i].r,r) 
L2875: (values[i].v,r) 
L2876: (values[i].tol,r) 
}
array table
-----------------------------------------------
values -> [('[i]', 'r', 'normalized', ['i'], 2864), ('[i]', 'r', 'normalized', ['i'], 2865), ('[i]', 'r', 'normalized', ['i'], 2866), ('[i]', 'r', 'normalized', ['i'], 2867), ('[i]', 'r', 'normalized', ['i'], 2868), ('[i]', 'r', 'normalized', ['i'], 2869), ('[i]', 'r', 'normalized', ['i'], 2869), ('[i]', 'r', 'normalized', ['i'], 2870), ('[i]', 'r', 'normalized', ['i'], 2871), ('[i]', 'r', 'normalized', ['i'], 2872), ('[i]', 'r', 'normalized', ['i'], 2873), ('[i]', 'r', 'normalized', ['i'], 2874), ('[i]', 'r', 'normalized', ['i'], 2874), ('[i]', 'r', 'normalized', ['i'], 2874), ('[i]', 'r', 'normalized', ['i'], 2875), ('[i]', 'r', 'normalized', ['i'], 2876)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/pathgenerator.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: j=0  j<assets  j++
induction variable: ['j']
{
L2877: (calculated[j]-,r) (expected[j],r) 
L2878: (calculated[j]<<,r) 
L2879: (expected[j]<<,r) 
}
array table
-----------------------------------------------
expected -> [('[j]', 'r', 'normalized', ['j'], 2877), ('[j]', 'r', 'normalized', ['j'], 2879)]
LDEs formed:0

calculated -> [('[j]', 'r', 'normalized', ['j'], 2877), ('[j]', 'r', 'normalized', ['j'], 2878)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: j=0  j<assets  j++
induction variable: ['j']
{
L2879: (calculated[j]-,r) (antithetic[j],r) 
L2880: (calculated[j]<<,r) 
L2881: (antithetic[j]<<,r) 
}
array table
-----------------------------------------------
calculated -> [('[j]', 'r', 'normalized', ['j'], 2879), ('[j]', 'r', 'normalized', ['j'], 2880)]
LDEs formed:0

antithetic -> [('[j]', 'r', 'normalized', ['j'], 2879), ('[j]', 'r', 'normalized', ['j'], 2881)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/test-suite/digitaloption.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<LENGTH(values)  i++
induction variable: ['i']
{
L2882: (values[i].type,r) (values[i].strike,r) 
L2883: (values[i].t*,r) 
L2884: (values[i].s,r) 
L2885: (values[i].q,r) 
L2886: (values[i].r,r) 
L2887: (values[i].v,r) 
L2888: (values[i].result,r) 
L2889: (values[i].tol,r) 
L2890: (values[i].s,r) (values[i].q,r) 
L2891: (values[i].r,r) (values[i].v,r) (values[i].result,r) 
L2892: (values[i].tol,r) (values[i].knockin,r) 
}
array table
-----------------------------------------------
values -> [('[i]', 'r', 'normalized', ['i'], 2882), ('[i]', 'r', 'normalized', ['i'], 2882), ('[i]', 'r', 'normalized', ['i'], 2883), ('[i]', 'r', 'normalized', ['i'], 2884), ('[i]', 'r', 'normalized', ['i'], 2885), ('[i]', 'r', 'normalized', ['i'], 2886), ('[i]', 'r', 'normalized', ['i'], 2887), ('[i]', 'r', 'normalized', ['i'], 2888), ('[i]', 'r', 'normalized', ['i'], 2889), ('[i]', 'r', 'normalized', ['i'], 2890), ('[i]', 'r', 'normalized', ['i'], 2890), ('[i]', 'r', 'normalized', ['i'], 2891), ('[i]', 'r', 'normalized', ['i'], 2891), ('[i]', 'r', 'normalized', ['i'], 2891), ('[i]', 'r', 'normalized', ['i'], 2892), ('[i]', 'r', 'normalized', ['i'], 2892)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<LENGTH(values)  i++
induction variable: ['i']
{
L2893: (values[i].type,r) (values[i].strike,r) 
L2894: (values[i].t*,r) 
L2895: (values[i].s,r) 
L2896: (values[i].q,r) 
L2897: (values[i].r,r) 
L2898: (values[i].v,r) 
L2899: (values[i].result,r) 
L2900: (values[i].tol,r) 
L2901: (values[i].s,r) (values[i].q,r) 
L2902: (values[i].r,r) (values[i].v,r) (values[i].result,r) 
L2903: (values[i].tol,r) (values[i].knockin,r) 
}
array table
-----------------------------------------------
values -> [('[i]', 'r', 'normalized', ['i'], 2893), ('[i]', 'r', 'normalized', ['i'], 2893), ('[i]', 'r', 'normalized', ['i'], 2894), ('[i]', 'r', 'normalized', ['i'], 2895), ('[i]', 'r', 'normalized', ['i'], 2896), ('[i]', 'r', 'normalized', ['i'], 2897), ('[i]', 'r', 'normalized', ['i'], 2898), ('[i]', 'r', 'normalized', ['i'], 2899), ('[i]', 'r', 'normalized', ['i'], 2900), ('[i]', 'r', 'normalized', ['i'], 2901), ('[i]', 'r', 'normalized', ['i'], 2901), ('[i]', 'r', 'normalized', ['i'], 2902), ('[i]', 'r', 'normalized', ['i'], 2902), ('[i]', 'r', 'normalized', ['i'], 2902), ('[i]', 'r', 'normalized', ['i'], 2903), ('[i]', 'r', 'normalized', ['i'], 2903)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<LENGTH(values)  i++
induction variable: ['i']
{
L2904: (values[i].type,r) (values[i].strike,r) 
L2905: (values[i].t*,r) 
L2906: (values[i].s,r) 
L2907: (values[i].q,r) 
L2908: (values[i].r,r) 
L2909: (values[i].v,r) 
L2910: (values[i].result,r) 
L2911: (values[i].tol,r) 
L2912: (values[i].s,r) (values[i].q,r) 
L2913: (values[i].r,r) (values[i].v,r) (values[i].result,r) 
L2914: (values[i].tol,r) (values[i].knockin,r) 
}
array table
-----------------------------------------------
values -> [('[i]', 'r', 'normalized', ['i'], 2904), ('[i]', 'r', 'normalized', ['i'], 2904), ('[i]', 'r', 'normalized', ['i'], 2905), ('[i]', 'r', 'normalized', ['i'], 2906), ('[i]', 'r', 'normalized', ['i'], 2907), ('[i]', 'r', 'normalized', ['i'], 2908), ('[i]', 'r', 'normalized', ['i'], 2909), ('[i]', 'r', 'normalized', ['i'], 2910), ('[i]', 'r', 'normalized', ['i'], 2911), ('[i]', 'r', 'normalized', ['i'], 2912), ('[i]', 'r', 'normalized', ['i'], 2912), ('[i]', 'r', 'normalized', ['i'], 2913), ('[i]', 'r', 'normalized', ['i'], 2913), ('[i]', 'r', 'normalized', ['i'], 2913), ('[i]', 'r', 'normalized', ['i'], 2914), ('[i]', 'r', 'normalized', ['i'], 2914)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<LENGTH(values)  i++
induction variable: ['i']
{
L2915: (values[i].type,r) (values[i].strike,r) 
L2916: (values[i].t*,r) 
L2917: (values[i].s,r) 
L2918: (values[i].q,r) 
L2919: (values[i].r,r) 
L2920: (values[i].v,r) 
L2921: (values[i].result,r) 
L2922: (values[i].tol,r) 
L2923: (values[i].s,r) 
L2924: (values[i].q,r) (values[i].r,r) (values[i].v,r) 
L2925: (values[i].result,r) (values[i].tol,r) (values[i].knockin,r) 
}
array table
-----------------------------------------------
values -> [('[i]', 'r', 'normalized', ['i'], 2915), ('[i]', 'r', 'normalized', ['i'], 2915), ('[i]', 'r', 'normalized', ['i'], 2916), ('[i]', 'r', 'normalized', ['i'], 2917), ('[i]', 'r', 'normalized', ['i'], 2918), ('[i]', 'r', 'normalized', ['i'], 2919), ('[i]', 'r', 'normalized', ['i'], 2920), ('[i]', 'r', 'normalized', ['i'], 2921), ('[i]', 'r', 'normalized', ['i'], 2922), ('[i]', 'r', 'normalized', ['i'], 2923), ('[i]', 'r', 'normalized', ['i'], 2924), ('[i]', 'r', 'normalized', ['i'], 2924), ('[i]', 'r', 'normalized', ['i'], 2924), ('[i]', 'r', 'normalized', ['i'], 2925), ('[i]', 'r', 'normalized', ['i'], 2925), ('[i]', 'r', 'normalized', ['i'], 2925)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<LENGTH(values)  i++
induction variable: ['i']
{
L2926: (values[i].type,r) (values[i].strike,r) 
L2927: (values[i].t*,r) 
L2928: (values[i].s,r) 
L2929: (values[i].q,r) 
L2930: (values[i].r,r) 
L2931: (values[i].v,r) 
L2932: (values[i].result,r) 
L2933: (values[i].tol,r) 
L2934: (values[i].s,r) 
L2935: (values[i].q,r) (values[i].r,r) (values[i].v,r) 
L2936: (values[i].result,r) (values[i].tol,r) (values[i].knockin,r) 
}
array table
-----------------------------------------------
values -> [('[i]', 'r', 'normalized', ['i'], 2926), ('[i]', 'r', 'normalized', ['i'], 2926), ('[i]', 'r', 'normalized', ['i'], 2927), ('[i]', 'r', 'normalized', ['i'], 2928), ('[i]', 'r', 'normalized', ['i'], 2929), ('[i]', 'r', 'normalized', ['i'], 2930), ('[i]', 'r', 'normalized', ['i'], 2931), ('[i]', 'r', 'normalized', ['i'], 2932), ('[i]', 'r', 'normalized', ['i'], 2933), ('[i]', 'r', 'normalized', ['i'], 2934), ('[i]', 'r', 'normalized', ['i'], 2935), ('[i]', 'r', 'normalized', ['i'], 2935), ('[i]', 'r', 'normalized', ['i'], 2935), ('[i]', 'r', 'normalized', ['i'], 2936), ('[i]', 'r', 'normalized', ['i'], 2936), ('[i]', 'r', 'normalized', ['i'], 2936)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<LENGTH(values)  i++
induction variable: ['i']
{
L2937: (values[i].type,r) (values[i].strike,r) 
L2938: (values[i].t*,r) 
L2939: (values[i].s,r) 
L2940: (values[i].q,r) 
L2941: (values[i].r,r) 
L2942: (values[i].v,r) 
L2943: (values[i].knockin,r) 
L2944: (values[i].result,r) 
L2945: (values[i].tol,r) 
L2946: (values[i].s,r) 
L2947: (values[i].q,r) (values[i].r,r) (values[i].v,r) 
L2948: (values[i].result,r) (values[i].tol,r) (values[i].knockin,r) 
}
array table
-----------------------------------------------
values -> [('[i]', 'r', 'normalized', ['i'], 2937), ('[i]', 'r', 'normalized', ['i'], 2937), ('[i]', 'r', 'normalized', ['i'], 2938), ('[i]', 'r', 'normalized', ['i'], 2939), ('[i]', 'r', 'normalized', ['i'], 2940), ('[i]', 'r', 'normalized', ['i'], 2941), ('[i]', 'r', 'normalized', ['i'], 2942), ('[i]', 'r', 'normalized', ['i'], 2943), ('[i]', 'r', 'normalized', ['i'], 2944), ('[i]', 'r', 'normalized', ['i'], 2945), ('[i]', 'r', 'normalized', ['i'], 2946), ('[i]', 'r', 'normalized', ['i'], 2947), ('[i]', 'r', 'normalized', ['i'], 2947), ('[i]', 'r', 'normalized', ['i'], 2947), ('[i]', 'r', 'normalized', ['i'], 2948), ('[i]', 'r', 'normalized', ['i'], 2948), ('[i]', 'r', 'normalized', ['i'], 2948)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<LENGTH(values)  i++
induction variable: ['i']
{
L2949: (values[i].type,r) (values[i].strike,r) 
L2950: (values[i].t*,r) 
L2951: (values[i].s,r) 
L2952: (values[i].q,r) 
L2953: (values[i].r,r) 
L2954: (values[i].v,r) 
L2955: (values[i].knockin,r) 
L2956: (values[i].result,r) 
L2957: (values[i].tol,r) 
L2958: (values[i].s,r) 
L2959: (values[i].q,r) (values[i].r,r) (values[i].v,r) 
L2960: (values[i].result,r) (values[i].tol,r) (values[i].knockin,r) 
}
array table
-----------------------------------------------
values -> [('[i]', 'r', 'normalized', ['i'], 2949), ('[i]', 'r', 'normalized', ['i'], 2949), ('[i]', 'r', 'normalized', ['i'], 2950), ('[i]', 'r', 'normalized', ['i'], 2951), ('[i]', 'r', 'normalized', ['i'], 2952), ('[i]', 'r', 'normalized', ['i'], 2953), ('[i]', 'r', 'normalized', ['i'], 2954), ('[i]', 'r', 'normalized', ['i'], 2955), ('[i]', 'r', 'normalized', ['i'], 2956), ('[i]', 'r', 'normalized', ['i'], 2957), ('[i]', 'r', 'normalized', ['i'], 2958), ('[i]', 'r', 'normalized', ['i'], 2959), ('[i]', 'r', 'normalized', ['i'], 2959), ('[i]', 'r', 'normalized', ['i'], 2959), ('[i]', 'r', 'normalized', ['i'], 2960), ('[i]', 'r', 'normalized', ['i'], 2960), ('[i]', 'r', 'normalized', ['i'], 2960)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size j=0  j<LENGTH(engines)  j++
induction variable: ['j']
{
	loop info: Size i1=0  i1<LENGTH(types)  i1++
	induction variable: ['j', 'i1']
	{
		loop info: Size i6=0  i6<LENGTH(strikes)  i6++
		induction variable: ['j', 'i1', 'i6']
		{
		L2961: (types[i1],r) 
		L2962: (strikes[i6],r) 
		L2963: (exercises[j],r) 
		L2964: (engines[j],r) 
			loop info: Size i2=0  i2<LENGTH(underlyings)  i2++
			induction variable: ['j', 'i1', 'i6', 'i2']
			{
				loop info: Size i4=0  i4<LENGTH(qRates)  i4++
				induction variable: ['j', 'i1', 'i6', 'i2', 'i4']
				{
					loop info: Size i3=0  i3<LENGTH(rRates)  i3++
					induction variable: ['j', 'i1', 'i6', 'i2', 'i4', 'i3']
					{
						loop info: Size i7=0  i7<LENGTH(vols)  i7++
						induction variable: ['j', 'i1', 'i6', 'i2', 'i4', 'i3', 'i7']
						{
						L2965: (underlyings[i2],r) 
						L2966: (qRates[i4],r) 
						L2967: (rRates[i3],r) 
						L2968: (vols[i7],r) 
						L2969: (calculated["delta"]=,w) 
						L2970: (calculated["gamma"]=,w) 
						L2971: (calculated["theta"]=,w) 
						L2972: (calculated["rho"]=,w) 
						L2973: (calculated["divRho"]=,w) 
						L2974: (calculated["vega"]=,w) 
						L2975: (expected["delta"]=,w) 
						L2976: (expected["gamma"]=,w) 
						L2977: (expected["rho"]=,w) 
						L2978: (expected["divRho"]=,w) 
						L2979: (expected["vega"]=,w) 
						L2980: (expected["theta"]=,w) 
						L2981: (calculated[greek],r) 
						}
 					}
 				}
 			}
 		}
 	}
 }
array table
-----------------------------------------------
rRates -> [('[i3]', 'r', 'normalized', ['j', 'i1', 'i6', 'i2', 'i4', 'i3', 'i7'], 2967)]
LDEs formed:0

engines -> [('[j]', 'r', 'normalized', ['j', 'i1', 'i6', 'i2', 'i4', 'i3', 'i7'], 2964)]
LDEs formed:0

calculated -> [('["delta"]', 'w', 'not normalized', ['j', 'i1', 'i6', 'i2', 'i4', 'i3', 'i7'], 2969), ('["gamma"]', 'w', 'not normalized', ['j', 'i1', 'i6', 'i2', 'i4', 'i3', 'i7'], 2970), ('["theta"]', 'w', 'not normalized', ['j', 'i1', 'i6', 'i2', 'i4', 'i3', 'i7'], 2971), ('["rho"]', 'w', 'not normalized', ['j', 'i1', 'i6', 'i2', 'i4', 'i3', 'i7'], 2972), ('["divRho"]', 'w', 'not normalized', ['j', 'i1', 'i6', 'i2', 'i4', 'i3', 'i7'], 2973), ('["vega"]', 'w', 'not normalized', ['j', 'i1', 'i6', 'i2', 'i4', 'i3', 'i7'], 2974), ('[greek]', 'r', 'not normalized', ['j', 'i1', 'i6', 'i2', 'i4', 'i3', 'i7'], 2981)]
LDEs formed:27

qRates -> [('[i4]', 'r', 'normalized', ['j', 'i1', 'i6', 'i2', 'i4', 'i3', 'i7'], 2966)]
LDEs formed:0

strikes -> [('[i6]', 'r', 'normalized', ['j', 'i1', 'i6', 'i2', 'i4', 'i3', 'i7'], 2962)]
LDEs formed:0

expected -> [('["delta"]', 'w', 'not normalized', ['j', 'i1', 'i6', 'i2', 'i4', 'i3', 'i7'], 2975), ('["gamma"]', 'w', 'not normalized', ['j', 'i1', 'i6', 'i2', 'i4', 'i3', 'i7'], 2976), ('["rho"]', 'w', 'not normalized', ['j', 'i1', 'i6', 'i2', 'i4', 'i3', 'i7'], 2977), ('["divRho"]', 'w', 'not normalized', ['j', 'i1', 'i6', 'i2', 'i4', 'i3', 'i7'], 2978), ('["vega"]', 'w', 'not normalized', ['j', 'i1', 'i6', 'i2', 'i4', 'i3', 'i7'], 2979), ('["theta"]', 'w', 'not normalized', ['j', 'i1', 'i6', 'i2', 'i4', 'i3', 'i7'], 2980)]
LDEs formed:21

underlyings -> [('[i2]', 'r', 'normalized', ['j', 'i1', 'i6', 'i2', 'i4', 'i3', 'i7'], 2965)]
LDEs formed:0

vols -> [('[i7]', 'r', 'normalized', ['j', 'i1', 'i6', 'i2', 'i4', 'i3', 'i7'], 2968)]
LDEs formed:0

exercises -> [('[j]', 'r', 'normalized', ['j', 'i1', 'i6', 'i2', 'i4', 'i3', 'i7'], 2963)]
LDEs formed:0

types -> [('[i1]', 'r', 'normalized', ['j', 'i1', 'i6', 'i2', 'i4', 'i3', 'i7'], 2961)]
LDEs formed:0

distinct LDEs:
"gamma"="divRho"
"divRho"="divRho"
"theta"="rho"
"theta"="theta"
"gamma"="vega"
"theta"="vega"
"rho"="rho"
"divRho"="vega"
"delta"="delta"
"rho"="vega"
"delta"="theta"
"delta"="rho"
"gamma"="theta"
"vega"="vega"
"rho"=greek
"delta"="divRho"
"delta"=greek
"gamma"=greek
"gamma"="rho"
"vega"=greek
"delta"="gamma"
"gamma"="gamma"
"delta"="vega"
"theta"="divRho"
"rho"="divRho"
"theta"=greek
"divRho"=greek
#########################################################################################
loop info: Size i=0  i<LENGTH(values)  i++
induction variable: ['i']
{
L2962: (values[i].type,r) (values[i].strike,r) 
L2963: (values[i].t*,r) 
L2964: (values[i].s,r) 
L2965: (values[i].q,r) 
L2966: (values[i].r,r) 
L2967: (values[i].v,r) 
L2968: (values[i].result,r) 
L2969: (values[i].tol,r) 
L2970: (values[i].s,r) 
L2971: (values[i].q,r) (values[i].r,r) (values[i].v,r) 
L2972: (values[i].result,r) (values[i].tol,r) (values[i].knockin,r) 
}
array table
-----------------------------------------------
values -> [('[i]', 'r', 'normalized', ['i'], 2962), ('[i]', 'r', 'normalized', ['i'], 2962), ('[i]', 'r', 'normalized', ['i'], 2963), ('[i]', 'r', 'normalized', ['i'], 2964), ('[i]', 'r', 'normalized', ['i'], 2965), ('[i]', 'r', 'normalized', ['i'], 2966), ('[i]', 'r', 'normalized', ['i'], 2967), ('[i]', 'r', 'normalized', ['i'], 2968), ('[i]', 'r', 'normalized', ['i'], 2969), ('[i]', 'r', 'normalized', ['i'], 2970), ('[i]', 'r', 'normalized', ['i'], 2971), ('[i]', 'r', 'normalized', ['i'], 2971), ('[i]', 'r', 'normalized', ['i'], 2971), ('[i]', 'r', 'normalized', ['i'], 2972), ('[i]', 'r', 'normalized', ['i'], 2972), ('[i]', 'r', 'normalized', ['i'], 2972)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/prices.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: i = d.begin()  i != d.end()  ++i
induction variable: ['i']
{
L2973: (retval[*i]=,w) 
}
array table
-----------------------------------------------
retval -> [('[*i]', 'w', 'normalized', ['i'], 2973)]
LDEs formed:1

distinct LDEs:
*i1=*i2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/discretizedasset.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: i=0  i<exerciseTimes_.size()  i++
induction variable: ['i']
{
L2974: (exerciseTimes_[i],r) 
}
array table
-----------------------------------------------
exerciseTimes_ -> [('[i]', 'r', 'normalized', ['i'], 2974)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/timegrid.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/currencies/exchangeratemanager.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/experimental/commodities/energyfuture.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/experimental/commodities/commoditycurve.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i = 1  i < dates_.size()  i++
induction variable: ['i']
{
L2975: (dates_[i],r) (dates_[i-1],r) 
L2976: (dates_[i]<<,r) 
L2977: (dates_[i-1]<<,r) 
L2978: (times_[i]=,w) (dates_[0],r) (dates_[i],r) 
}
array table
-----------------------------------------------
dates_ -> [('[i]', 'r', 'normalized', ['i'], 2975), ('[i-1]', 'r', 'normalized', ['i'], 2975), ('[i]', 'r', 'normalized', ['i'], 2976), ('[i-1]', 'r', 'normalized', ['i'], 2977), ('[0]', 'r', 'normalized', ['i'], 2978), ('[i]', 'r', 'normalized', ['i'], 2978)]
LDEs formed:0

times_ -> [('[i]', 'w', 'normalized', ['i'], 2978)]
LDEs formed:1

distinct LDEs:
i1=i2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/experimental/commodities/commoditypricinghelpers.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/experimental/variancegamma/fftengine.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: PayoffMap::const_iterator payIt = payoffMap.begin()  payIt != payoffMap.end()  ++payIt
induction variable: ['payIt']
{
	loop info: Size i=0  i<n  i++
	induction variable: ['payIt', 'i']
	{
	L2979: (fti[i]=,w) 
	}
	loop info: Size i=0  i<n  i++
	induction variable: ['payIt', 'i']
	{
	L2980: (prices[i]=,w) (results[i].real,r) 
	L2981: (strikes[i]=,w) 
	}
L2982: (resultMap_[expiryDate][payoff]=,w) 
L2983: (resultMap_[expiryDate][payoff]=,w) 
}
array table
-----------------------------------------------
fti -> [('[i]', 'w', 'normalized', ['payIt', 'i'], 2979)]
LDEs formed:1

prices -> [('[i]', 'w', 'normalized', ['payIt', 'i'], 2980)]
LDEs formed:1

resultMap_ -> [('[expiryDate][payoff]', 'w', 'not normalized', ['payIt', 'i'], 2982), ('[expiryDate][payoff]', 'w', 'not normalized', ['payIt', 'i'], 2983)]
LDEs formed:6

results -> [('[i]', 'r', 'normalized', ['payIt', 'i'], 2980)]
LDEs formed:0

strikes -> [('[i]', 'w', 'normalized', ['payIt', 'i'], 2981)]
LDEs formed:1

distinct LDEs:
expiryDate=expiryDate,payoff=payoff
i1=i2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/experimental/swaptions/irregularswap.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<fixedCoupons.size()  ++i
induction variable: ['i']
{
L2982: (fixedCoupons[i],r) 
L2983: (fixedPayDates[i]=,w) 
L2984: (fixedResetDates[i]=,w) 
L2985: (fixedCoupons[i]=,w) 
L2986: (fixedNominals[i]=,w) 
}
array table
-----------------------------------------------
fixedNominals -> [('[i]', 'w', 'normalized', ['i'], 2986)]
LDEs formed:1

fixedCoupons -> [('[i]', 'r', 'normalized', ['i'], 2982), ('[i]', 'w', 'normalized', ['i'], 2985)]
LDEs formed:2

fixedResetDates -> [('[i]', 'w', 'normalized', ['i'], 2984)]
LDEs formed:1

fixedPayDates -> [('[i]', 'w', 'normalized', ['i'], 2983)]
LDEs formed:1

distinct LDEs:
i1=i2
#########################################################################################
loop info: Size i=0  i<floatingCoupons.size()  ++i
induction variable: ['i']
{
L2984: (floatingCoupons[i],r) 
L2985: (floatingResetDates[i]=,w) 
L2986: (floatingPayDates[i]=,w) 
L2987: (floatingFixingDates[i]=,w) 
L2988: (floatingAccrualTimes[i]=,w) 
L2989: (floatingSpreads[i]=,w) 
L2990: (floatingNominals[i]=,w) 
L2991: (floatingCoupons[i]=,w) 
L2992: (floatingCoupons[i]=,w) 
}
array table
-----------------------------------------------
floatingResetDates -> [('[i]', 'w', 'normalized', ['i'], 2985)]
LDEs formed:1

floatingSpreads -> [('[i]', 'w', 'normalized', ['i'], 2989)]
LDEs formed:1

floatingFixingDates -> [('[i]', 'w', 'normalized', ['i'], 2987)]
LDEs formed:1

floatingCoupons -> [('[i]', 'r', 'normalized', ['i'], 2984), ('[i]', 'w', 'normalized', ['i'], 2991), ('[i]', 'w', 'normalized', ['i'], 2992)]
LDEs formed:5

floatingPayDates -> [('[i]', 'w', 'normalized', ['i'], 2986)]
LDEs formed:1

floatingAccrualTimes -> [('[i]', 'w', 'normalized', ['i'], 2988)]
LDEs formed:1

floatingNominals -> [('[i]', 'w', 'normalized', ['i'], 2990)]
LDEs formed:1

distinct LDEs:
i1=i2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/experimental/swaptions/haganirregularswaptionengine.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i = 0  i < fixedLeg.size()  ++i
induction variable: ['i']
{
L2991: (fixedLeg[i],r) 
	loop info: Size j = 0  j < floatLeg.size()  ++j
	induction variable: ['i', 'j']
	{
	L2992: (floatLeg[j],r) 
	L2993: (expiries_[i],r) 
	}
L2994: (annuities_[i],r) 
}
array table
-----------------------------------------------
fixedLeg -> [('[i]', 'r', 'normalized', ['i', 'j'], 2991)]
LDEs formed:0

annuities_ -> [('[i]', 'r', 'normalized', ['i', 'j'], 2994)]
LDEs formed:0

floatLeg -> [('[j]', 'r', 'normalized', ['i', 'j'], 2992)]
LDEs formed:0

expiries_ -> [('[i]', 'r', 'normalized', ['i', 'j'], 2993)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size r = 0  r < n  ++r
induction variable: ['r']
{
	loop info: Size c = r  c < n  ++c
	induction variable: ['r', 'c']
	{
	L2994: (arr[r][c]=,w) (fairRates_[c]+,r) 
	}
L2995: (arr[r][r]+=,w) 
}
array table
-----------------------------------------------
fairRates_ -> [('[c]', 'r', 'normalized', ['r', 'c'], 2994)]
LDEs formed:0

arr -> [('[r][c]', 'w', 'normalized', ['r', 'c'], 2994), ('[r][r]', 'w', 'normalized', ['r', 'c'], 2995)]
LDEs formed:6

distinct LDEs:
r1=r2,c1=c2
r1=r2,c1=r2
r1=r2,r1=r2
#########################################################################################
loop info: Size r = 0  r < n  ++r
induction variable: ['r']
{
L2996: (rhs[r]=,w) 
L2997: (rhs[r]=,w) 
}
array table
-----------------------------------------------
rhs -> [('[r]', 'w', 'normalized', ['r'], 2996), ('[r]', 'w', 'normalized', ['r'], 2997)]
LDEs formed:3

distinct LDEs:
r1=r2
#########################################################################################
loop info: Size j = 0  j < floatLeg.size()  ++j
induction variable: ['j']
{
L2998: (floatLeg[j],r) 
}
array table
-----------------------------------------------
floatLeg -> [('[j]', 'r', 'normalized', ['j'], 2998)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i = 0  i < fixedLeg.size()  ++i
induction variable: ['i']
{
L2999: (fixedLeg[i],r) 
}
array table
-----------------------------------------------
fixedLeg -> [('[i]', 'r', 'normalized', ['i'], 2999)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<weights.size()  ++i
induction variable: ['i']
{
L3000: (weights[i]*,r) 
}
array table
-----------------------------------------------
weights -> [('[i]', 'r', 'normalized', ['i'], 3000)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/experimental/exoticoptions/continuousarithmeticasianvecerengine.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Natural i= 0  i<= SVec.size()-1 i++
induction variable: ['i']
{
L3001: (SVec[i]=,w) 
}
array table
-----------------------------------------------
SVec -> [('[i]', 'w', 'normalized', ['i'], 3001)]
LDEs formed:1

distinct LDEs:
i1=i2
#########################################################################################
loop info: Natural i= 0  i<= SVec.size()-1 i++
induction variable: ['i']
{
L3002: (u_initial[i]=,w) (SVec[i],r) 
}
array table
-----------------------------------------------
u_initial -> [('[i]', 'w', 'normalized', ['i'], 3002)]
LDEs formed:1

SVec -> [('[i]', 'r', 'normalized', ['i'], 3002)]
LDEs formed:0

distinct LDEs:
i1=i2
#########################################################################################
loop info: Natural i=0  i<=assetSteps_  i++
induction variable: ['i']
{
L3003: (u_surface[i]=,w) (u[i],r) 
}
array table
-----------------------------------------------
u_surface -> [('[i]', 'w', 'normalized', ['i'], 3003)]
LDEs formed:1

u -> [('[i]', 'r', 'normalized', ['i'], 3003)]
LDEs formed:0

distinct LDEs:
i1=i2
#########################################################################################
loop info: Natural j = 1  j<=timeSteps_ j++
induction variable: ['j']
{
	loop info: Natural i = 1  i<= SVec.size()-2 i++
	induction variable: ['j', 'i']
		{
		L3004: (SVec[i]-,r) 
		L3005: (lowerD[i-1],r) 
		L3006: (Dia[i],r) 
		L3007: (upperD[i],r) 
		}
L3008: (u[assetSteps_]=,w) (u[assetSteps_-1]+,r) 
L3009: (u[0]=,w) 
	loop info: Natural i = 1  i<= SVec.size()-2 i++
	induction variable: ['j', 'i']
		{
		L3010: (SVec[i]-,r) 
		L3011: (lowerD[i-1],r) 
		L3012: (Dia[i],r) 
		L3013: (upperD[i],r) 
		}
L3014: (rhs[0]=,w) 
L3015: (rhs[assetSteps_]=,w) 
	loop info: Natural i=0  i<=assetSteps_  i++
	induction variable: ['j', 'i']
	{
	L3016: (u_surface[j*(assetSteps_+1) + i]=,w) (u[i],r) 
	}
 }
array table
-----------------------------------------------
u_surface -> [('[j*(assetSteps_+1) + i]', 'w', 'not normalized', ['j', 'i'], 3016)]
LDEs formed:1

rhs -> [('[0]', 'w', 'normalized', ['j', 'i'], 3014), ('[assetSteps_]', 'w', 'not normalized', ['j', 'i'], 3015)]
LDEs formed:3

Dia -> [('[i]', 'r', 'normalized', ['j', 'i'], 3006), ('[i]', 'r', 'normalized', ['j', 'i'], 3012)]
LDEs formed:0

upperD -> [('[i]', 'r', 'normalized', ['j', 'i'], 3007), ('[i]', 'r', 'normalized', ['j', 'i'], 3013)]
LDEs formed:0

u -> [('[assetSteps_]', 'w', 'not normalized', ['j', 'i'], 3008), ('[assetSteps_-1]', 'r', 'not normalized', ['j', 'i'], 3008), ('[0]', 'w', 'normalized', ['j', 'i'], 3009), ('[i]', 'r', 'normalized', ['j', 'i'], 3016)]
LDEs formed:7

lowerD -> [('[i-1]', 'r', 'normalized', ['j', 'i'], 3005), ('[i-1]', 'r', 'normalized', ['j', 'i'], 3011)]
LDEs formed:0

SVec -> [('[i]', 'r', 'normalized', ['j', 'i'], 3004), ('[i]', 'r', 'normalized', ['j', 'i'], 3010)]
LDEs formed:0

distinct LDEs:
j1*(assetSteps_+1) + i1=j2*(assetSteps_+1) + i2
assetSteps_=assetSteps_
assetSteps_-1=0
assetSteps_=i2
assetSteps_=assetSteps_-1
0=0
0=assetSteps_
0=i2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/experimental/exoticoptions/mceverestengine.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size j=1  j<numAssets  ++j
induction variable: ['j']
{
L3011: (multiPath[j].back,r) (multiPath[j].front,r) 
}
array table
-----------------------------------------------
multiPath -> [('[j]', 'r', 'normalized', ['j'], 3011), ('[j]', 'r', 'normalized', ['j'], 3011)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/experimental/exoticoptions/mcpagodaengine.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i = 1  i < numSteps  i++
induction variable: ['i']
{
	loop info: Size j = 0  j < numAssets  j++
	induction variable: ['i', 'j']
	{
	L3012: (multiPath[j].front,r) 
	L3013: (multiPath[j][i]/,r) (multiPath[j][i-1]-,r) 
	}
 }
array table
-----------------------------------------------
multiPath -> [('[j]', 'r', 'normalized', ['i', 'j'], 3012), ('[j][i]', 'r', 'normalized', ['i', 'j'], 3013), ('[j][i-1]', 'r', 'normalized', ['i', 'j'], 3013)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/experimental/exoticoptions/mchimalayaengine.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i = 1  i < numNodes  i++
induction variable: ['i']
{
	loop info: Size j = 0  j < numAssets  j++
	induction variable: ['i', 'j']
	{
	L3014: (remainingAssets[j],r) 
	L3015: (multiPath[j][i],r) 
	L3016: (multiPath[j].front,r) 
	}
L3017: (remainingAssets[removeAsset]=,w) 
}
array table
-----------------------------------------------
remainingAssets -> [('[j]', 'r', 'normalized', ['i', 'j'], 3014), ('[removeAsset]', 'w', 'not normalized', ['i', 'j'], 3017)]
LDEs formed:2

multiPath -> [('[j][i]', 'r', 'normalized', ['i', 'j'], 3015), ('[j]', 'r', 'normalized', ['i', 'j'], 3016)]
LDEs formed:0

distinct LDEs:
removeAsset=removeAsset
j1=removeAsset
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/experimental/callablebonds/callablebond.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<putCallSchedule_.size() ++i
induction variable: ['i']
{
L3017: (putCallSchedule_[i]-,r) 
}
array table
-----------------------------------------------
putCallSchedule_ -> [('[i]', 'r', 'normalized', ['i'], 3017)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i = 0  i<cashflows_.size()  ++i
induction variable: ['i']
{
L3018: (cashflows_[i]-,r) 
L3019: (cashflows_[i],r) 
}
array table
-----------------------------------------------
cashflows_ -> [('[i]', 'r', 'normalized', ['i'], 3018), ('[i]', 'r', 'normalized', ['i'], 3019)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<cfs.size()-1  i++
induction variable: ['i']
{
L3020: (cfs[i]-,r) 
L3021: (cfs[i]-,r) 
L3022: (cfs[i]-,r) 
}
array table
-----------------------------------------------
cfs -> [('[i]', 'r', 'normalized', ['i'], 3020), ('[i]', 'r', 'normalized', ['i'], 3021), ('[i]', 'r', 'normalized', ['i'], 3022)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<putCallSchedule_.size()  i++
induction variable: ['i']
{
L3023: (putCallSchedule_[i]-,r) 
L3024: (putCallSchedule_[i]-,r) 
L3025: (putCallSchedule_[i]-,r) 
L3026: (putCallSchedule_[i]-,r) 
L3027: (putCallSchedule_[i]-,r) 
}
array table
-----------------------------------------------
putCallSchedule_ -> [('[i]', 'r', 'normalized', ['i'], 3023), ('[i]', 'r', 'normalized', ['i'], 3024), ('[i]', 'r', 'normalized', ['i'], 3025), ('[i]', 'r', 'normalized', ['i'], 3026), ('[i]', 'r', 'normalized', ['i'], 3027)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/experimental/callablebonds/discretizedcallablefixedratebond.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<callabilityTimes_.size()  i++
induction variable: ['i']
{
L3028: (callabilityTimes_[i],r) 
	loop info: Size j=0  j<couponTimes_.size()  j++
	induction variable: ['i', 'j']
	{
	L3029: (couponTimes_[j],r) 
	L3030: (couponTimes_[j]=,w) 
	}
 }
array table
-----------------------------------------------
callabilityTimes_ -> [('[i]', 'r', 'normalized', ['i', 'j'], 3028)]
LDEs formed:0

couponTimes_ -> [('[j]', 'r', 'normalized', ['i', 'j'], 3029), ('[j]', 'w', 'normalized', ['i', 'j'], 3030)]
LDEs formed:2

distinct LDEs:
j1=j2
#########################################################################################
loop info: i=0  i<couponTimes_.size()  i++
induction variable: ['i']
{
L3031: (couponTimes_[i],r) 
}
array table
-----------------------------------------------
couponTimes_ -> [('[i]', 'r', 'normalized', ['i'], 3031)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: i=0  i<callabilityTimes_.size()  i++
induction variable: ['i']
{
L3032: (callabilityTimes_[i],r) 
}
array table
-----------------------------------------------
callabilityTimes_ -> [('[i]', 'r', 'normalized', ['i'], 3032)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<callabilityTimes_.size()  i++
induction variable: ['i']
{
L3033: (callabilityTimes_[i],r) 
}
array table
-----------------------------------------------
callabilityTimes_ -> [('[i]', 'r', 'normalized', ['i'], 3033)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<couponTimes_.size()  i++
induction variable: ['i']
{
L3034: (couponTimes_[i],r) 
}
array table
-----------------------------------------------
couponTimes_ -> [('[i]', 'r', 'normalized', ['i'], 3034)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: j=0  j<values_.size()  j++
induction variable: ['j']
{
L3035: (values_[j]=,w) 
L3036: (arguments_.callabilityPrices[i],r) 
L3037: (values_[j],r) 
}
array table
-----------------------------------------------
arguments_.callabilityPrices -> [('[i]', 'r', 'not normalized', ['j'], 3036)]
LDEs formed:0

values_ -> [('[j]', 'w', 'normalized', ['j'], 3035), ('[j]', 'r', 'normalized', ['j'], 3037)]
LDEs formed:2

distinct LDEs:
j1=j2
#########################################################################################
loop info: j=0  j<values_.size()  j++
induction variable: ['j']
{
L3038: (values_[j]=,w) (values_[j],r) 
L3039: (arguments_.callabilityPrices[i],r) 
}
array table
-----------------------------------------------
arguments_.callabilityPrices -> [('[i]', 'r', 'not normalized', ['j'], 3039)]
LDEs formed:0

values_ -> [('[j]', 'w', 'normalized', ['j'], 3038), ('[j]', 'r', 'normalized', ['j'], 3038)]
LDEs formed:2

distinct LDEs:
j1=j2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/experimental/callablebonds/blackcallablebondengine.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i = 0  i < cf.size() - 1  ++i
induction variable: ['i']
{
L3039: (cf[i]-,r) 
L3040: (cf[i]-,r) 
L3041: (cf[i]-,r) 
L3042: (cf[i]-,r) 
}
array table
-----------------------------------------------
cf -> [('[i]', 'r', 'normalized', ['i'], 3039), ('[i]', 'r', 'normalized', ['i'], 3040), ('[i]', 'r', 'normalized', ['i'], 3041), ('[i]', 'r', 'normalized', ['i'], 3042)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/experimental/catbonds/riskynotional.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info:   i<notionalRate_.size() && notionalRate_[i].first<=date  ++i
induction variable: ['i']
{
L3043: (notionalRate_[i-1].second,r) 
}
array table
-----------------------------------------------
notionalRate_ -> [('[i-1]', 'r', 'normalized', ['i'], 3043)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: size_t i=0  i<events.size()  ++i
induction variable: ['i']
{
L3044: (events[i].second,r) 
L3045: (events[i].first,r) 
}
array table
-----------------------------------------------
events -> [('[i]', 'r', 'normalized', ['i'], 3044), ('[i]', 'r', 'normalized', ['i'], 3045)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/experimental/catbonds/montecarlocatbondengine.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<arguments_.cashflows.size()  ++i
induction variable: ['i']
{
L3046: (arguments_.cashflows[i]-,r) 
L3047: (arguments_.cashflows[i],r) 
L3048: (arguments_.cashflows[i]-,r) 
}
array table
-----------------------------------------------
arguments_.cashflows -> [('[i]', 'r', 'normalized', ['i'], 3046), ('[i]', 'r', 'normalized', ['i'], 3047), ('[i]', 'r', 'normalized', ['i'], 3048)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/experimental/shortrate/generalizedhullwhite.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<size  i++
induction variable: ['i']
{
L3049: (times_[i],r) 
L3050: (params[i],r) 
}
array table
-----------------------------------------------
params -> [('[i]', 'r', 'normalized', ['i'], 3050)]
LDEs formed:0

times_ -> [('[i]', 'r', 'normalized', ['i'], 3049)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size j=0  j<size_  j++
induction variable: ['j']
{
L3050: (statePrices_[j]*,r) 
}
array table
-----------------------------------------------
statePrices_ -> [('[j]', 'r', 'normalized', ['j'], 3050)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i< sigma_.size() i++
induction variable: ['i']
{
L3051: (vol[i],r) 
}
array table
-----------------------------------------------
vol -> [('[i]', 'r', 'normalized', ['i'], 3051)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i< a_.size() i++
induction variable: ['i']
{
L3052: (speed[i],r) 
}
array table
-----------------------------------------------
speed -> [('[i]', 'r', 'normalized', ['i'], 3052)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<(grid.size() - 1)  i++
induction variable: ['i']
{
L3053: (grid[i+1],r) 
L3054: (grid[i],r) 
}
array table
-----------------------------------------------
grid -> [('[i+1]', 'r', 'normalized', ['i'], 3053), ('[i]', 'r', 'normalized', ['i'], 3054)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/experimental/coupons/subperiodcoupons.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<observations_  ++i
induction variable: ['i']
{
L3055: (observationDates_[i],r) 
}
array table
-----------------------------------------------
observationDates_ -> [('[i]', 'r', 'normalized', ['i'], 3055)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<observationDates.size()  i++
induction variable: ['i']
{
L3056: (observationDates[i],r) 
L3057: (initialValues_[i]=,w) 
L3058: (observationIndexStartDates_[i]=,w) 
L3059: (observationIndexEndDates_[i]=,w) 
L3060: (observationCvg_[i]=,w) 
}
array table
-----------------------------------------------
observationCvg_ -> [('[i]', 'w', 'normalized', ['i'], 3060)]
LDEs formed:1

observationIndexEndDates_ -> [('[i]', 'w', 'normalized', ['i'], 3059)]
LDEs formed:1

initialValues_ -> [('[i]', 'w', 'normalized', ['i'], 3057)]
LDEs formed:1

observationDates -> [('[i]', 'r', 'normalized', ['i'], 3056)]
LDEs formed:0

observationIndexStartDates_ -> [('[i]', 'w', 'normalized', ['i'], 3058)]
LDEs formed:1

distinct LDEs:
i1=i2
#########################################################################################
loop info: Size i=0  i<nCount  i++
induction variable: ['i']
{
L3059: (initialValues_[i]*,r) (observationCvg_[i],r) 
L3060: (observationCvg_[i],r) 
}
array table
-----------------------------------------------
observationCvg_ -> [('[i]', 'r', 'normalized', ['i'], 3059), ('[i]', 'r', 'normalized', ['i'], 3060)]
LDEs formed:0

initialValues_ -> [('[i]', 'r', 'normalized', ['i'], 3059)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<nCount  i++
induction variable: ['i']
{
L3060: (initialValues_[i]*,r) (observationCvg_[i]*,r) 
L3061: (observationCvg_[i],r) 
}
array table
-----------------------------------------------
observationCvg_ -> [('[i]', 'r', 'normalized', ['i'], 3060), ('[i]', 'r', 'normalized', ['i'], 3061)]
LDEs formed:0

initialValues_ -> [('[i]', 'r', 'normalized', ['i'], 3060)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/experimental/barrieroption/discretizeddoublebarrieroption.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<stoppingTimes_.size()  ++i
induction variable: ['i']
{
L3061: (stoppingTimes_[i]=,w) 
L3062: (stoppingTimes_[i]=,w) (stoppingTimes_[i],r) 
}
array table
-----------------------------------------------
stoppingTimes_ -> [('[i]', 'w', 'normalized', ['i'], 3061), ('[i]', 'w', 'normalized', ['i'], 3062), ('[i]', 'r', 'normalized', ['i'], 3062)]
LDEs formed:5

distinct LDEs:
i1=i2
#########################################################################################
loop info: Size i=0  i<stoppingTimes_.size()  i++
induction variable: ['i']
{
L3063: (stoppingTimes_[i],r) 
}
array table
-----------------------------------------------
stoppingTimes_ -> [('[i]', 'r', 'normalized', ['i'], 3063)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size j=0  j<optvalues.size()  j++
induction variable: ['j']
{
L3064: (grid[j],r) 
L3065: (optvalues[j]=,w) 
L3066: (grid[j],r) 
L3067: (optvalues[j]=,w) 
L3068: (grid[j],r) 
L3069: (optvalues[j]=,w) 
L3070: (grid[j],r) 
L3071: (optvalues[j]=,w) 
L3072: (optvalues[j]=,w) 
L3073: (grid[j],r) 
L3074: (optvalues[j]=,w) 
L3075: (grid[j],r) 
L3076: (optvalues[j]=,w) 
L3077: (optvalues[j]=,w) (optvalues[j],r) 
L3078: (grid[j],r) 
L3079: (grid[j],r) 
L3080: (optvalues[j]=,w) 
L3081: (grid[j],r) 
L3082: (optvalues[j]=,w) 
L3083: (grid[j],r) 
L3084: (optvalues[j]=,w) 
L3085: (optvalues[j]=,w) 
L3086: (grid[j],r) 
L3087: (optvalues[j]=,w) 
L3088: (grid[j],r) 
L3089: (optvalues[j]=,w) 
L3090: (grid[j],r) 
L3091: (optvalues[j]=,w) 
L3092: (optvalues[j]=,w) 
}
array table
-----------------------------------------------
optvalues -> [('[j]', 'w', 'normalized', ['j'], 3065), ('[j]', 'w', 'normalized', ['j'], 3067), ('[j]', 'w', 'normalized', ['j'], 3069), ('[j]', 'w', 'normalized', ['j'], 3071), ('[j]', 'w', 'normalized', ['j'], 3072), ('[j]', 'w', 'normalized', ['j'], 3074), ('[j]', 'w', 'normalized', ['j'], 3076), ('[j]', 'w', 'normalized', ['j'], 3077), ('[j]', 'r', 'normalized', ['j'], 3077), ('[j]', 'w', 'normalized', ['j'], 3080), ('[j]', 'w', 'normalized', ['j'], 3082), ('[j]', 'w', 'normalized', ['j'], 3084), ('[j]', 'w', 'normalized', ['j'], 3085), ('[j]', 'w', 'normalized', ['j'], 3087), ('[j]', 'w', 'normalized', ['j'], 3089), ('[j]', 'w', 'normalized', ['j'], 3091), ('[j]', 'w', 'normalized', ['j'], 3092)]
LDEs formed:152

grid -> [('[j]', 'r', 'normalized', ['j'], 3064), ('[j]', 'r', 'normalized', ['j'], 3066), ('[j]', 'r', 'normalized', ['j'], 3068), ('[j]', 'r', 'normalized', ['j'], 3070), ('[j]', 'r', 'normalized', ['j'], 3073), ('[j]', 'r', 'normalized', ['j'], 3075), ('[j]', 'r', 'normalized', ['j'], 3078), ('[j]', 'r', 'normalized', ['j'], 3079), ('[j]', 'r', 'normalized', ['j'], 3081), ('[j]', 'r', 'normalized', ['j'], 3083), ('[j]', 'r', 'normalized', ['j'], 3086), ('[j]', 'r', 'normalized', ['j'], 3088), ('[j]', 'r', 'normalized', ['j'], 3090)]
LDEs formed:0

distinct LDEs:
j1=j2
#########################################################################################
loop info: Size j=0  j<optvalues.size()-1  ++j
induction variable: ['j']
{
L3091: (grid[j],r) (grid[j+1],r) 
L3092: (grid[j+1],r) (grid[j],r) 
L3093: (optvalues[j+1],r) 
L3094: (grid[j],r) 
L3095: (grid[j+1]-,r) 
L3096: (grid[j+1]-,r) (grid[j],r) 
L3097: (optvalues[j+1]=,w) 
L3098: (grid[j],r) (grid[j+1],r) 
L3099: (grid[j+1],r) (grid[j],r) 
L3100: (optvalues[j],r) 
L3101: (grid[j],r) 
L3102: (grid[j+1]-,r) 
L3103: (grid[j+1]-,r) (grid[j],r) 
L3104: (optvalues[j]=,w) 
}
array table
-----------------------------------------------
optvalues -> [('[j+1]', 'r', 'normalized', ['j'], 3093), ('[j+1]', 'w', 'normalized', ['j'], 3097), ('[j]', 'r', 'normalized', ['j'], 3100), ('[j]', 'w', 'normalized', ['j'], 3104)]
LDEs formed:7

grid -> [('[j]', 'r', 'normalized', ['j'], 3091), ('[j+1]', 'r', 'normalized', ['j'], 3091), ('[j+1]', 'r', 'normalized', ['j'], 3092), ('[j]', 'r', 'normalized', ['j'], 3092), ('[j]', 'r', 'normalized', ['j'], 3094), ('[j+1]', 'r', 'normalized', ['j'], 3095), ('[j+1]', 'r', 'normalized', ['j'], 3096), ('[j]', 'r', 'normalized', ['j'], 3096), ('[j]', 'r', 'normalized', ['j'], 3098), ('[j+1]', 'r', 'normalized', ['j'], 3098), ('[j+1]', 'r', 'normalized', ['j'], 3099), ('[j]', 'r', 'normalized', ['j'], 3099), ('[j]', 'r', 'normalized', ['j'], 3101), ('[j+1]', 'r', 'normalized', ['j'], 3102), ('[j+1]', 'r', 'normalized', ['j'], 3103), ('[j]', 'r', 'normalized', ['j'], 3103)]
LDEs formed:0

distinct LDEs:
j1+1=j2+1
j1=j2
j1+1=j2
#########################################################################################
loop info: Size j=0  j<optvalues.size()-1  ++j
induction variable: ['j']
{
L3104: (grid[j],r) (grid[j+1],r) 
L3105: (grid[j+1],r) (grid[j],r) 
L3106: (optvalues[j+1],r) 
L3107: (grid[j],r) 
L3108: (grid[j+1]-,r) 
L3109: (grid[j+1]-,r) (grid[j],r) 
L3110: (optvalues[j+1]=,w) 
L3111: (grid[j],r) (grid[j+1],r) 
L3112: (grid[j+1],r) (grid[j],r) 
L3113: (optvalues[j],r) 
L3114: (grid[j],r) 
L3115: (grid[j+1]-,r) 
L3116: (grid[j+1]-,r) (grid[j],r) 
L3117: (optvalues[j]=,w) 
}
array table
-----------------------------------------------
optvalues -> [('[j+1]', 'r', 'normalized', ['j'], 3106), ('[j+1]', 'w', 'normalized', ['j'], 3110), ('[j]', 'r', 'normalized', ['j'], 3113), ('[j]', 'w', 'normalized', ['j'], 3117)]
LDEs formed:7

grid -> [('[j]', 'r', 'normalized', ['j'], 3104), ('[j+1]', 'r', 'normalized', ['j'], 3104), ('[j+1]', 'r', 'normalized', ['j'], 3105), ('[j]', 'r', 'normalized', ['j'], 3105), ('[j]', 'r', 'normalized', ['j'], 3107), ('[j+1]', 'r', 'normalized', ['j'], 3108), ('[j+1]', 'r', 'normalized', ['j'], 3109), ('[j]', 'r', 'normalized', ['j'], 3109), ('[j]', 'r', 'normalized', ['j'], 3111), ('[j+1]', 'r', 'normalized', ['j'], 3111), ('[j+1]', 'r', 'normalized', ['j'], 3112), ('[j]', 'r', 'normalized', ['j'], 3112), ('[j]', 'r', 'normalized', ['j'], 3114), ('[j+1]', 'r', 'normalized', ['j'], 3115), ('[j+1]', 'r', 'normalized', ['j'], 3116), ('[j]', 'r', 'normalized', ['j'], 3116)]
LDEs formed:0

distinct LDEs:
j1+1=j2+1
j1=j2
j1+1=j2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/experimental/barrieroption/perturbativebarrieroptionengine.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: I = 1  I<=IM  I++
induction variable: ['I']
{
L3117: (EI[I],r) (EI[IP],r) 
L3118: (FI[I],r) 
L3119: (EI[I]*,r) (EI[I],r) 
}
array table
-----------------------------------------------
FI -> [('[I]', 'r', 'normalized', ['I'], 3118)]
LDEs formed:0

EI -> [('[I]', 'r', 'normalized', ['I'], 3117), ('[IP]', 'r', 'not normalized', ['I'], 3117), ('[I]', 'r', 'normalized', ['I'], 3119), ('[I]', 'r', 'normalized', ['I'], 3119)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: J = 1  J<= N  J++
induction variable: ['J']
{
L3120: (XGK[J+1],r) 
L3121: (WGK[J+1]*,r) 
L3122: (WG[1+J/2]*,r) 
}
array table
-----------------------------------------------
WG -> [('[1+J/2]', 'r', 'normalized', ['J'], 3122)]
LDEs formed:0

XGK -> [('[J+1]', 'r', 'normalized', ['J'], 3120)]
LDEs formed:0

WGK -> [('[J+1]', 'r', 'normalized', ['J'], 3121)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: I = 1 I<= LG  I++
induction variable: ['I']
{
	loop info:  IS = -1  IS<= 1  IS=IS+2
	induction variable: ['I', 'IS']
	{
	L3122: (XL[I][NG]+,r) 
	L3123: (WL[I][NG]*,r) 
	}
 }
array table
-----------------------------------------------
WL -> [('[I][NG]', 'r', 'not normalized', ['I', 'IS'], 3123)]
LDEs formed:0

XL -> [('[I][NG]', 'r', 'not normalized', ['I', 'IS'], 3122)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: I = 1  I<= LG I++
induction variable: ['I']
{
	loop info:  IS = -1  IS<=1  IS=IS+2
	induction variable: ['I', 'IS']
	{
	L3123: (XL[I][NG]+,r) 
	L3124: (WL[I][NG]*,r) 
	}
 }
array table
-----------------------------------------------
WL -> [('[I][NG]', 'r', 'not normalized', ['I', 'IS'], 3124)]
LDEs formed:0

XL -> [('[I][NG]', 'r', 'not normalized', ['I', 'IS'], 3123)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/experimental/barrieroption/analyticdoublebarrierbinaryengine.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/experimental/barrieroption/analyticdoublebarrierengine.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/experimental/barrieroption/wulinyongdoublebarrierengine.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/experimental/convertiblebonds/convertiblebond.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<n  i++
induction variable: ['i']
{
L3124: (callability_[i]-,r) 
L3125: (callability_[i]-,r) 
L3126: (callability_[i]-,r) 
L3127: (callability_[i]-,r) 
L3128: (callability_[i]-,r) 
L3129: (callability_[i]-,r) 
L3130: (callability_[i],r) 
}
array table
-----------------------------------------------
callability_ -> [('[i]', 'r', 'normalized', ['i'], 3124), ('[i]', 'r', 'normalized', ['i'], 3125), ('[i]', 'r', 'normalized', ['i'], 3126), ('[i]', 'r', 'normalized', ['i'], 3127), ('[i]', 'r', 'normalized', ['i'], 3128), ('[i]', 'r', 'normalized', ['i'], 3129), ('[i]', 'r', 'normalized', ['i'], 3130)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<cashflows.size()-1  i++
induction variable: ['i']
{
L3131: (cashflows[i]-,r) 
L3132: (cashflows[i]-,r) 
L3133: (cashflows[i]-,r) 
}
array table
-----------------------------------------------
cashflows -> [('[i]', 'r', 'normalized', ['i'], 3131), ('[i]', 'r', 'normalized', ['i'], 3132), ('[i]', 'r', 'normalized', ['i'], 3133)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<dividends_.size()  i++
induction variable: ['i']
{
L3134: (dividends_[i]-,r) 
L3135: (dividends_[i],r) 
L3136: (dividends_[i]-,r) 
}
array table
-----------------------------------------------
dividends_ -> [('[i]', 'r', 'normalized', ['i'], 3134), ('[i]', 'r', 'normalized', ['i'], 3135), ('[i]', 'r', 'normalized', ['i'], 3136)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/experimental/convertiblebonds/discretizedconvertible.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<arguments_.dividends.size()  i++
induction variable: ['i']
{
L3137: (arguments_.dividends[i]-,r) 
L3138: (dividendValues_[i]=,w) 
L3139: (arguments_.dividends[i]-,r) 
L3140: (arguments_.dividends[i]-,r) 
}
array table
-----------------------------------------------
dividendValues_ -> [('[i]', 'w', 'normalized', ['i'], 3138)]
LDEs formed:1

arguments_.dividends -> [('[i]', 'r', 'normalized', ['i'], 3137), ('[i]', 'r', 'normalized', ['i'], 3139), ('[i]', 'r', 'normalized', ['i'], 3140)]
LDEs formed:0

distinct LDEs:
i1=i2
#########################################################################################
loop info: Size j=0  j<values_.size()  j++
induction variable: ['j']
{
L3141: (spreadAdjustedRate_[j]=,w) 
L3142: (conversionProbability_[j]*,r) 
L3143: (conversionProbability_[j],r) 
}
array table
-----------------------------------------------
conversionProbability_ -> [('[j]', 'r', 'normalized', ['j'], 3142), ('[j]', 'r', 'normalized', ['j'], 3143)]
LDEs formed:0

spreadAdjustedRate_ -> [('[j]', 'w', 'normalized', ['j'], 3141)]
LDEs formed:1

distinct LDEs:
j1=j2
#########################################################################################
loop info: Size i=0  i<stoppingTimes_.size()  ++i
induction variable: ['i']
{
L3142: (stoppingTimes_[i],r) 
}
array table
-----------------------------------------------
stoppingTimes_ -> [('[i]', 'r', 'normalized', ['i'], 3142)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<callabilityTimes_.size()  i++
induction variable: ['i']
{
L3143: (callabilityTimes_[i],r) 
}
array table
-----------------------------------------------
callabilityTimes_ -> [('[i]', 'r', 'normalized', ['i'], 3143)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<couponTimes_.size()  i++
induction variable: ['i']
{
L3144: (couponTimes_[i],r) 
}
array table
-----------------------------------------------
couponTimes_ -> [('[i]', 'r', 'normalized', ['i'], 3144)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size j=0  j<values_.size()  j++
induction variable: ['j']
{
L3145: (grid[j],r) 
L3146: (values_[j],r) 
L3147: (values_[j]=,w) 
L3148: (conversionProbability_[j]=,w) 
}
array table
-----------------------------------------------
grid -> [('[j]', 'r', 'normalized', ['j'], 3145)]
LDEs formed:0

conversionProbability_ -> [('[j]', 'w', 'normalized', ['j'], 3148)]
LDEs formed:1

values_ -> [('[j]', 'r', 'normalized', ['j'], 3146), ('[j]', 'w', 'normalized', ['j'], 3147)]
LDEs formed:2

distinct LDEs:
j1=j2
#########################################################################################
loop info: j=0  j<values_.size()  j++
induction variable: ['j']
{
L3148: (grid[j],r) 
L3149: (values_[j]=,w) 
L3150: (arguments_.callabilityPrices[i],r) 
L3151: (grid[j],r) 
L3152: (values_[j],r) 
}
array table
-----------------------------------------------
grid -> [('[j]', 'r', 'normalized', ['j'], 3148), ('[j]', 'r', 'normalized', ['j'], 3151)]
LDEs formed:0

arguments_.callabilityPrices -> [('[i]', 'r', 'not normalized', ['j'], 3150)]
LDEs formed:0

values_ -> [('[j]', 'w', 'normalized', ['j'], 3149), ('[j]', 'r', 'normalized', ['j'], 3152)]
LDEs formed:2

distinct LDEs:
j1=j2
#########################################################################################
loop info: j=0  j<values_.size()  j++
induction variable: ['j']
{
L3153: (values_[j]=,w) 
L3154: (arguments_.callabilityPrices[i],r) 
L3155: (grid[j],r) 
L3156: (values_[j],r) 
}
array table
-----------------------------------------------
grid -> [('[j]', 'r', 'normalized', ['j'], 3155)]
LDEs formed:0

arguments_.callabilityPrices -> [('[i]', 'r', 'not normalized', ['j'], 3154)]
LDEs formed:0

values_ -> [('[j]', 'w', 'normalized', ['j'], 3153), ('[j]', 'r', 'normalized', ['j'], 3156)]
LDEs formed:2

distinct LDEs:
j1=j2
#########################################################################################
loop info: j=0  j<values_.size()  j++
induction variable: ['j']
{
L3157: (values_[j]=,w) (arguments_.callabilityPrices[i],r) 
L3158: (values_[j],r) 
}
array table
-----------------------------------------------
arguments_.callabilityPrices -> [('[i]', 'r', 'not normalized', ['j'], 3157)]
LDEs formed:0

values_ -> [('[j]', 'w', 'normalized', ['j'], 3157), ('[j]', 'r', 'normalized', ['j'], 3158)]
LDEs formed:2

distinct LDEs:
j1=j2
#########################################################################################
loop info: j=0  j<values_.size()  j++
induction variable: ['j']
{
L3159: (values_[j]=,w) (values_[j],r) 
L3160: (arguments_.callabilityPrices[i],r) 
}
array table
-----------------------------------------------
arguments_.callabilityPrices -> [('[i]', 'r', 'not normalized', ['j'], 3160)]
LDEs formed:0

values_ -> [('[j]', 'w', 'normalized', ['j'], 3159), ('[j]', 'r', 'normalized', ['j'], 3159)]
LDEs formed:2

distinct LDEs:
j1=j2
#########################################################################################
loop info: Size i=0  i<arguments_.dividends.size()  i++
induction variable: ['i']
{
L3160: (dividendTimes_[i],r) 
L3161: (arguments_.dividends[i],r) 
	loop info: Size j=0  j<grid.size()  j++
	induction variable: ['i', 'j']
		{
		}
 }
array table
-----------------------------------------------
dividendTimes_ -> [('[i]', 'r', 'normalized', ['i', 'j'], 3160)]
LDEs formed:0

arguments_.dividends -> [('[i]', 'r', 'normalized', ['i', 'j'], 3161)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/experimental/amortizingbonds/amortizingfixedratebond.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i = 0  i < (Size)nPeriods-1  ++i
induction variable: ['i']
{
L3162: (notionals[i+1]=,w) 
}
array table
-----------------------------------------------
notionals -> [('[i+1]', 'w', 'normalized', ['i'], 3162)]
LDEs formed:1

distinct LDEs:
i1+1=i2+1
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/experimental/varianceoption/integralhestonvarianceoptionengine.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: j=0 j<=mm-1 j++
induction variable: ['j']
{
L3163: (xiv[j+1]=,w) 
}
array table
-----------------------------------------------
xiv -> [('[j+1]', 'w', 'normalized', ['j'], 3163)]
LDEs formed:1

distinct LDEs:
j1+1=j2+1
#########################################################################################
loop info: j=0 j<=mm-1 j++
induction variable: ['j']
{
L3164: (xiv[j+1],r) 
L3165: (ff[j+1]=,w) 
L3166: (ff[j+1]=,w) (ff[j+1]*,r) 
}
array table
-----------------------------------------------
ff -> [('[j+1]', 'w', 'normalized', ['j'], 3165), ('[j+1]', 'w', 'normalized', ['j'], 3166), ('[j+1]', 'r', 'normalized', ['j'], 3166)]
LDEs formed:5

xiv -> [('[j+1]', 'r', 'normalized', ['j'], 3164)]
LDEs formed:0

distinct LDEs:
j1+1=j2+1
#########################################################################################
loop info: j=0 j<=mm-1 j++
induction variable: ['j']
{
L3165: (ff[j+1]*,r) 
}
array table
-----------------------------------------------
ff -> [('[j+1]', 'r', 'normalized', ['j'], 3165)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: j=0 j<=mm-1 j++
induction variable: ['j']
{
L3166: (xiv[j+1]=,w) 
L3167: (ivet[j+1]=,w) 
}
array table
-----------------------------------------------
ivet -> [('[j+1]', 'w', 'normalized', ['j'], 3167)]
LDEs formed:1

xiv -> [('[j+1]', 'w', 'normalized', ['j'], 3166)]
LDEs formed:1

distinct LDEs:
j1+1=j2+1
#########################################################################################
loop info: j=0 j<=mm-1 j++
induction variable: ['j']
{
L3167: (xiv[j+1],r) 
L3168: (ff[j+1]=,w) 
}
array table
-----------------------------------------------
ff -> [('[j+1]', 'w', 'normalized', ['j'], 3168)]
LDEs formed:1

xiv -> [('[j+1]', 'r', 'normalized', ['j'], 3167)]
LDEs formed:0

distinct LDEs:
j1+1=j2+1
#########################################################################################
loop info: k=0 k<=mm-1 k++
induction variable: ['k']
{
L3168: (ivet[k+1],r) 
	loop info: j=0 j<=mm-1 j++
	induction variable: ['k', 'j']
	{
	L3169: (ff[j+1]*,r) 
	}
 }
array table
-----------------------------------------------
ff -> [('[j+1]', 'r', 'normalized', ['k', 'j'], 3169)]
LDEs formed:0

ivet -> [('[k+1]', 'r', 'normalized', ['k', 'j'], 3168)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/experimental/finitedifferences/dynprogvppintrinsicvalueengine.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/experimental/finitedifferences/glued1dmesher.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i < locations_.size()-1  ++i
induction variable: ['i']
{
L3169: (dplus_[i]=,w) (dminus_[i+1]=,w) (locations_[i+1]-,r) (locations_[i],r) 
}
array table
-----------------------------------------------
locations_ -> [('[i+1]', 'r', 'normalized', ['i'], 3169), ('[i]', 'r', 'normalized', ['i'], 3169)]
LDEs formed:0

dminus_ -> [('[i+1]', 'w', 'normalized', ['i'], 3169)]
LDEs formed:1

dplus_ -> [('[i]', 'w', 'normalized', ['i'], 3169)]
LDEs formed:1

distinct LDEs:
i1+1=i2+1
i1=i2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/experimental/finitedifferences/fdmvppstartlimitstepcondition.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i < nStates_  ++i
induction variable: ['i']
{
L3170: (retVal[i]=,w) (state[i+1],r) (state[tMinUp_+i+1],r) 
L3171: (retVal[i]=,w) (state[i+tMinUp_+1],r) 
L3172: (state[i],r) (state[i+tMinUp_],r) 
L3173: (retVal[i]=,w) (retVal[i-tMinUp_],r) 
L3174: (retVal[i]=,w) (state[i+1],r) 
L3175: (retVal[i]=,w) (state[i],r) 
L3176: (state[tMinUp_],r) 
L3177: (retVal[i]=,w) (state[i],r) 
L3178: (state[i+1-2*sss],r) (state[i+1-2*sss+tMinUp_],r) 
L3179: (retVal[i]=,w) (state[i],r) 
}
array table
-----------------------------------------------
state -> [('[i+1]', 'r', 'normalized', ['i'], 3170), ('[tMinUp_+i+1]', 'r', 'not normalized', ['i'], 3170), ('[i+tMinUp_+1]', 'r', 'not normalized', ['i'], 3171), ('[i]', 'r', 'normalized', ['i'], 3172), ('[i+tMinUp_]', 'r', 'not normalized', ['i'], 3172), ('[i+1]', 'r', 'normalized', ['i'], 3174), ('[i]', 'r', 'normalized', ['i'], 3175), ('[tMinUp_]', 'r', 'not normalized', ['i'], 3176), ('[i]', 'r', 'normalized', ['i'], 3177), ('[i+1-2*sss]', 'r', 'not normalized', ['i'], 3178), ('[i+1-2*sss+tMinUp_]', 'r', 'not normalized', ['i'], 3178), ('[i]', 'r', 'normalized', ['i'], 3179)]
LDEs formed:0

retVal -> [('[i]', 'w', 'normalized', ['i'], 3170), ('[i]', 'w', 'normalized', ['i'], 3171), ('[i]', 'w', 'normalized', ['i'], 3173), ('[i-tMinUp_]', 'r', 'not normalized', ['i'], 3173), ('[i]', 'w', 'normalized', ['i'], 3174), ('[i]', 'w', 'normalized', ['i'], 3175), ('[i]', 'w', 'normalized', ['i'], 3177), ('[i]', 'w', 'normalized', ['i'], 3179)]
LDEs formed:35

distinct LDEs:
i1=i2-tMinUp_
i1=i2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/experimental/finitedifferences/fdsimpleklugeextouvppengine.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i < results.size()  ++i
induction variable: ['i']
{
L3180: (x[3]=,w) 
L3181: (results[i]=,w) 
}
array table
-----------------------------------------------
x -> [('[3]', 'w', 'normalized', ['i'], 3180)]
LDEs formed:1

results -> [('[i]', 'w', 'normalized', ['i'], 3181)]
LDEs formed:1

distinct LDEs:
3=3
i1=i2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/experimental/finitedifferences/fdmextoujumpop.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i < yInt.size()  ++i
induction variable: ['i']
{
L3182: (yInt[i],r) (weights[i],r) 
L3183: (yInt[i]/,r) 
L3184: (yLoc[l],r) (yLoc[l+1]-,r) (yLoc[l],r) 
}
array table
-----------------------------------------------
yInt -> [('[i]', 'r', 'normalized', ['i'], 3182), ('[i]', 'r', 'normalized', ['i'], 3183)]
LDEs formed:0

yLoc -> [('[l]', 'r', 'not normalized', ['i'], 3184), ('[l+1]', 'r', 'not normalized', ['i'], 3184), ('[l]', 'r', 'not normalized', ['i'], 3184)]
LDEs formed:0

weights -> [('[i]', 'r', 'normalized', ['i'], 3182)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size k=0  k < extraDims  ++k
induction variable: ['k']
{
	loop info: Size i=0  i < f[k].columns()  ++i
	induction variable: ['k', 'i']
	{
	L3183: (interpl[k][i]=,w) 
	L3184: (y[k].begin,r) (y[k].end,r) 
	L3185: (f[k].column_begin,r) 
	}
 }
array table
-----------------------------------------------
y -> [('[k]', 'r', 'normalized', ['k', 'i'], 3184), ('[k]', 'r', 'normalized', ['k', 'i'], 3184)]
LDEs formed:0

interpl -> [('[k][i]', 'w', 'normalized', ['k', 'i'], 3183)]
LDEs formed:2

f -> [('[k]', 'r', 'normalized', ['k', 'i'], 3185)]
LDEs formed:0

distinct LDEs:
k1=k2,i1=i2
#########################################################################################
loop info: FdmLinearOpIterator iter=layout->begin()  iter!=endIter  ++iter
induction variable: ['iter']
{
L3186: (integral[iter.index()]=,w) 
L3187: (interpl[k][i],r) (y[k][j],r) 
}
array table
-----------------------------------------------
y -> [('[k][j]', 'r', 'not normalized', ['iter'], 3187)]
LDEs formed:0

integral -> [('[iter.index()]', 'w', 'not normalized', ['iter'], 3186)]
LDEs formed:1

interpl -> [('[k][i]', 'r', 'not normalized', ['iter'], 3187)]
LDEs formed:0

distinct LDEs:
iter1.index()=iter2.index()
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/experimental/finitedifferences/fdmvppstepcondition.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i < nStates_  ++i
induction variable: ['i']
{
L3188: (stateEvolveFcts_[i]=,w) 
L3189: (stateEvolveFcts_[i]=,w) 
}
array table
-----------------------------------------------
stateEvolveFcts_ -> [('[i]', 'w', 'normalized', ['i'], 3188), ('[i]', 'w', 'normalized', ['i'], 3189)]
LDEs formed:3

distinct LDEs:
i1=i2
#########################################################################################
loop info: FdmLinearOpIterator iter=layout->begin() iter != endIter  ++iter
induction variable: ['iter']
{
L3190: (a[iter.index()]+=,w) 
}
array table
-----------------------------------------------
a -> [('[iter.index()]', 'w', 'not normalized', ['iter'], 3190)]
LDEs formed:1

distinct LDEs:
iter1.index()=iter2.index()
#########################################################################################
loop info: FdmLinearOpIterator iter=layout->begin() iter != endIter  ++iter
induction variable: ['iter']
{
	loop info: Size i=0  i < nStates  ++i
	induction variable: ['iter', 'i']
		{
		L3191: (x[i]=,w) (a[layout->neighbourhood(iter, stateDirection_, i)],r) 
		}
	loop info: Size i=0  i < nStates  ++i
	induction variable: ['iter', 'i']
		{
		L3192: (a[layout->neighbourhood(iter, stateDirection_, i)]=,w) (x[i],r) 
		}
 }
array table
-----------------------------------------------
a -> [('[layout->neighbourhood(iter, stateDirection_, i)]', 'r', 'not normalized', ['iter', 'i'], 3191), ('[layout->neighbourhood(iter, stateDirection_, i)]', 'w', 'not normalized', ['iter', 'i'], 3192)]
LDEs formed:2

x -> [('[i]', 'w', 'normalized', ['iter', 'i'], 3191), ('[i]', 'r', 'normalized', ['iter', 'i'], 3192)]
LDEs formed:2

distinct LDEs:
layout->neighbourhood(iter1, stateDirection_, i1)=layout->neighbourhood(iter2, stateDirection_, i2)
i1=i2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/experimental/finitedifferences/fdsimpleextoustorageengine.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/experimental/math/expm.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i < result.size()  i++
induction variable: ['i']
{
L3193: (result[i]=,w) 
}
array table
-----------------------------------------------
result -> [('[i]', 'w', 'normalized', ['i'], 3193)]
LDEs formed:1

distinct LDEs:
i1=i2
#########################################################################################
loop info: Size i=0  i < n  ++i
induction variable: ['i']
{
L3194: (x0[i]=,w) 
}
array table
-----------------------------------------------
x0 -> [('[i]', 'w', 'normalized', ['i'], 3194)]
LDEs formed:1

distinct LDEs:
i1=i2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/experimental/math/tcopulapolicy.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size iFactor=0  iFactor<vals.tOrders.size()  iFactor++
induction variable: ['iFactor']
{
L3195: (vals.tOrders[iFactor],r) 
L3196: (vals.tOrders[iFactor],r) 
L3197: (vals.tOrders[iFactor]-,r) (vals.tOrders[iFactor],r) 
}
array table
-----------------------------------------------
vals.tOrders -> [('[iFactor]', 'r', 'normalized', ['iFactor'], 3195), ('[iFactor]', 'r', 'normalized', ['iFactor'], 3196), ('[iFactor]', 'r', 'normalized', ['iFactor'], 3197), ('[iFactor]', 'r', 'normalized', ['iFactor'], 3197)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size iLVar=0  iLVar<factorWeights.size()  iLVar++
induction variable: ['iLVar']
{
L3198: (factorWeights[iLVar].size,r) 
L3199: (factorWeights[iLVar].begin,r) 
L3200: (factorWeights[iLVar].end,r) (factorWeights[iLVar].begin,r) 
	loop info: Size iFactor=0  iFactor<factorWeights[iLVar].size()  iFactor++
	induction variable: ['iLVar', 'iFactor']
	{
	}
 }
array table
-----------------------------------------------
factorWeights -> [('[iLVar]', 'r', 'normalized', ['iLVar', 'iFactor'], 3198), ('[iLVar]', 'r', 'normalized', ['iLVar', 'iFactor'], 3199), ('[iLVar]', 'r', 'normalized', ['iLVar', 'iFactor'], 3200), ('[iLVar]', 'r', 'normalized', ['iLVar', 'iFactor'], 3200)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/experimental/math/convolvedstudentt.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<degreesFreedom.size()  i++
induction variable: ['i']
{
L3201: (degreesFreedom[i]%,r) 
L3202: (degreesFreedom[i],r) 
}
array table
-----------------------------------------------
degreesFreedom -> [('[i]', 'r', 'normalized', ['i'], 3201), ('[i]', 'r', 'normalized', ['i'], 3202)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<degreesFreedom_.size()  i++
induction variable: ['i']
{
	loop info: Size k=1  k<polynCharFnc_[i].size()  k++
	induction variable: ['i', 'k']
	{
	L3203: (factors_[i],r) 
	L3204: (polynCharFnc_[i][k]*=,w) 
	}
 }
array table
-----------------------------------------------
polynCharFnc_ -> [('[i][k]', 'w', 'normalized', ['i', 'k'], 3204)]
LDEs formed:2

factors_ -> [('[i]', 'r', 'normalized', ['i', 'k'], 3203)]
LDEs formed:0

distinct LDEs:
i1=i2,k1=k2
#########################################################################################
loop info: Size polyOrdr=0  polyOrdr<resultB.size()  polyOrdr++
induction variable: ['polyOrdr']
{
L3204: (resultB[polyOrdr]+=,w) (shorter[i]*,r) (longer[polyOrdr-i],r) 
}
array table
-----------------------------------------------
shorter -> [('[i]', 'r', 'not normalized', ['polyOrdr'], 3204)]
LDEs formed:0

resultB -> [('[polyOrdr]', 'w', 'normalized', ['polyOrdr'], 3204)]
LDEs formed:1

longer -> [('[polyOrdr-i]', 'r', 'not normalized', ['polyOrdr'], 3204)]
LDEs formed:0

distinct LDEs:
polyOrdr1=polyOrdr2
#########################################################################################
loop info: Size exponent = 2  exponent <polyConvolved_.size()  exponent++
induction variable: ['exponent']
{
L3205: (polyConvolved_[exponent]*,r) 
}
array table
-----------------------------------------------
polyConvolved_ -> [('[exponent]', 'r', 'normalized', ['exponent'], 3205)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size exponent=1  exponent <polyConvolved_.size()  exponent++
induction variable: ['exponent']
{
L3206: (polyConvolved_[exponent]*,r) 
}
array table
-----------------------------------------------
polyConvolved_ -> [('[exponent]', 'r', 'normalized', ['exponent'], 3206)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/experimental/math/numericaldifferentiation.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size n=1  n < N  ++n
induction variable: ['n']
{
	loop info: Size nu=0  nu < n  ++nu
	induction variable: ['n', 'nu']
	{
	L3207: (x[n]-,r) (x[nu],r) 
		loop info: Size m=0  m <= std::min(n, M)  ++m
		induction variable: ['n', 'nu', 'm']
		{
		L3208: (d[m][n][nu]=,w) (x[n]*,r) (d[m][n-1][nu],r) 
		L3209: (d[m-1][n-1][nu],r) 
		}
 	}
	loop info: Size m=0  m <= M  ++m
	induction variable: ['n', 'nu', 'm']
	{
	L3210: (d[m][n][n]=,w) (d[m-1][n-1][n-1],r) 
	L3211: (x[n-1]*,r) (d[m][n-1][n-1],r) 
	}
 }
array table
-----------------------------------------------
x -> [('[n]', 'r', 'normalized', ['n', 'nu', 'm'], 3207), ('[nu]', 'r', 'normalized', ['n', 'nu', 'm'], 3207), ('[n]', 'r', 'normalized', ['n', 'nu', 'm'], 3208), ('[n-1]', 'r', 'normalized', ['n', 'nu', 'm'], 3211)]
LDEs formed:0

d -> [('[m][n][nu]', 'w', 'normalized', ['n', 'nu', 'm'], 3208), ('[m][n-1][nu]', 'r', 'normalized', ['n', 'nu', 'm'], 3208), ('[m-1][n-1][nu]', 'r', 'normalized', ['n', 'nu', 'm'], 3209), ('[m][n][n]', 'w', 'normalized', ['n', 'nu', 'm'], 3210), ('[m-1][n-1][n-1]', 'r', 'normalized', ['n', 'nu', 'm'], 3210), ('[m][n-1][n-1]', 'r', 'normalized', ['n', 'nu', 'm'], 3211)]
LDEs formed:33

distinct LDEs:
m1=m2,n1-1=n2,nu1=n2
m1=m2,n1=n2,nu1=nu2
m1=m2,n1=n2,n1=n2
m1=m2,n1=n2,nu1=n2
m1-1=m2,n1-1=n2,nu1=n2
m1=m2-1,n1=n2-1,nu1=n2-1
m1=m2,n1=n2-1,nu1=n2-1
m1=m2,n1=n2-1,n1=n2-1
m1=m2,n1=n2-1,nu1=nu2
m1=m2-1,n1=n2-1,nu1=nu2
m1=m2-1,n1=n2-1,n1=n2-1
#########################################################################################
loop info: Size i=0  i < N  ++i
induction variable: ['i']
{
L3212: (retVal[i]=,w) (d[M][N-1][i],r) 
}
array table
-----------------------------------------------
retVal -> [('[i]', 'w', 'normalized', ['i'], 3212)]
LDEs formed:1

d -> [('[M][N-1][i]', 'r', 'not normalized', ['i'], 3212)]
LDEs formed:0

distinct LDEs:
i1=i2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/experimental/math/zigguratrng.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info:   
induction variable: []
{
L3213: (c[f]*,r) (w_[i],r) 
L3214: (k_[i],r) 
L3215: (f_[i-1]-,r) (f_[i],r) (f_[i],r) 
L3216: (c[f]*,r) 
}
array table
-----------------------------------------------
w_ -> [('[i]', 'r', 'not normalized', [], 3213)]
LDEs formed:0

c -> [('[f]', 'r', 'not normalized', [], 3213), ('[f]', 'r', 'not normalized', [], 3216)]
LDEs formed:0

k_ -> [('[i]', 'r', 'not normalized', [], 3214)]
LDEs formed:0

f_ -> [('[i-1]', 'r', 'not normalized', [], 3215), ('[i]', 'r', 'not normalized', [], 3215), ('[i]', 'r', 'not normalized', [], 3215)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/experimental/inflation/cpicapfloortermpricesurface.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size j = 0  j <cfMaturities_.size()  j++
induction variable: ['j']
{
L3216: (cfMaturities[j],r) 
L3217: (cfMaturities[j],r) (cfMaturities[j-1],r) 
	loop info: Size i = 0  i <fPrice_.rows()  i++
	induction variable: ['j', 'i']
	{
	L3218: (fPrice_[i][j],r) 
	L3219: (fPrice_[i][j],r) 
	L3220: (fPrice_[i][j],r) (fPrice_[i-1][j],r) 
	}
L3221: (cPrice_[i][j],r) 
L3222: (cPrice_[i][j],r) 
L3223: (cPrice_[i][j],r) (cPrice_[i-1][j],r) 
L3224: (cPrice_[i][j]<<,r) (cPrice_[i-1][j],r) 
}
array table
-----------------------------------------------
fPrice_ -> [('[i][j]', 'r', 'normalized', ['j', 'i'], 3218), ('[i][j]', 'r', 'normalized', ['j', 'i'], 3219), ('[i][j]', 'r', 'normalized', ['j', 'i'], 3220), ('[i-1][j]', 'r', 'normalized', ['j', 'i'], 3220)]
LDEs formed:0

cPrice_ -> [('[i][j]', 'r', 'normalized', ['j', 'i'], 3221), ('[i][j]', 'r', 'normalized', ['j', 'i'], 3222), ('[i][j]', 'r', 'normalized', ['j', 'i'], 3223), ('[i-1][j]', 'r', 'normalized', ['j', 'i'], 3223), ('[i][j]', 'r', 'normalized', ['j', 'i'], 3224), ('[i-1][j]', 'r', 'normalized', ['j', 'i'], 3224)]
LDEs formed:0

cfMaturities -> [('[j]', 'r', 'normalized', ['j', 'i'], 3216), ('[j]', 'r', 'normalized', ['j', 'i'], 3217), ('[j-1]', 'r', 'normalized', ['j', 'i'], 3217)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i = 0  i < cStrikes_.size()  i++
induction variable: ['i']
{
L3218: (cStrikes[i],r) 
}
array table
-----------------------------------------------
cStrikes -> [('[i]', 'r', 'normalized', ['i'], 3218)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/experimental/inflation/yoycapfloortermpricesurface.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size j = 0  j <cfMaturities_.size()  j++
induction variable: ['j']
{
L3219: (cfMaturities[j],r) 
L3220: (cfMaturities[j],r) (cfMaturities[j-1],r) 
	loop info: Size i = 0  i <fPrice_.rows()  i++
	induction variable: ['j', 'i']
	{
	L3221: (fPrice_[i][j],r) 
	L3222: (fPrice_[i][j],r) 
	L3223: (fPrice_[i][j],r) (fPrice_[i-1][j],r) 
	}
L3224: (cPrice_[i][j],r) 
L3225: (cPrice_[i][j],r) 
L3226: (cPrice_[i][j],r) (cPrice_[i-1][j],r) 
}
array table
-----------------------------------------------
fPrice_ -> [('[i][j]', 'r', 'normalized', ['j', 'i'], 3221), ('[i][j]', 'r', 'normalized', ['j', 'i'], 3222), ('[i][j]', 'r', 'normalized', ['j', 'i'], 3223), ('[i-1][j]', 'r', 'normalized', ['j', 'i'], 3223)]
LDEs formed:0

cPrice_ -> [('[i][j]', 'r', 'normalized', ['j', 'i'], 3224), ('[i][j]', 'r', 'normalized', ['j', 'i'], 3225), ('[i][j]', 'r', 'normalized', ['j', 'i'], 3226), ('[i-1][j]', 'r', 'normalized', ['j', 'i'], 3226)]
LDEs formed:0

cfMaturities -> [('[j]', 'r', 'normalized', ['j', 'i'], 3219), ('[j]', 'r', 'normalized', ['j', 'i'], 3220), ('[j-1]', 'r', 'normalized', ['j', 'i'], 3220)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i = 0  i < cStrikes_.size()  i++
induction variable: ['i']
{
L3221: (cStrikes[i],r) 
}
array table
-----------------------------------------------
cStrikes -> [('[i]', 'r', 'normalized', ['i'], 3221)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/experimental/mcbasket/mcpathbasketengine.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i = 0  i < numberOfTimes  ++i
induction variable: ['i']
{
L3222: (timePositions_[i],r) 
	loop info: Size j = 0  j < numberOfAssets  ++j
	induction variable: ['i', 'j']
	{
	}
 }
array table
-----------------------------------------------
timePositions_ -> [('[i]', 'r', 'normalized', ['i', 'j'], 3222)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/experimental/mcbasket/longstaffschwartzmultipathpricer.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i = 0  i < numberOfTimes  ++i
induction variable: ['i']
{
L3223: (timePositions_[i],r) 
	loop info: Size j = 0  j < numberOfAssets  ++j
	induction variable: ['i', 'j']
	{
	}
 }
array table
-----------------------------------------------
timePositions_ -> [('[i]', 'r', 'normalized', ['i', 'j'], 3223)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Integer i = len - 2  i >= 0  --i
induction variable: ['i']
{
L3224: (dF_[i + 1]/,r) (dF_[i],r) 
L3225: (path.exercises[i],r) 
L3226: (coeff_[i].size,r) 
L3227: (lowerBounds_[i],r) 
L3228: (path.states[i],r) 
L3229: (coeff_[i].size,r) 
L3230: (coeff_[i].empty,r) (lowerBounds_[i],r) 
	loop info: Size l = 0  l < v_.size()  ++l
	induction variable: ['i', 'l']
				{
				L3231: (coeff_[i][l]*,r) (v_[l],r) 
				}
L3232: (path.payments[i],r) 
}
array table
-----------------------------------------------
path.exercises -> [('[i]', 'r', 'normalized', ['i', 'l'], 3225)]
LDEs formed:0

dF_ -> [('[i + 1]', 'r', 'normalized', ['i', 'l'], 3224), ('[i]', 'r', 'normalized', ['i', 'l'], 3224)]
LDEs formed:0

lowerBounds_ -> [('[i]', 'r', 'normalized', ['i', 'l'], 3227), ('[i]', 'r', 'normalized', ['i', 'l'], 3230)]
LDEs formed:0

path.payments -> [('[i]', 'r', 'normalized', ['i', 'l'], 3232)]
LDEs formed:0

path.states -> [('[i]', 'r', 'normalized', ['i', 'l'], 3228)]
LDEs formed:0

coeff_ -> [('[i]', 'r', 'normalized', ['i', 'l'], 3226), ('[i]', 'r', 'normalized', ['i', 'l'], 3229), ('[i]', 'r', 'normalized', ['i', 'l'], 3230), ('[i][l]', 'r', 'normalized', ['i', 'l'], 3231)]
LDEs formed:0

v_ -> [('[l]', 'r', 'normalized', ['i', 'l'], 3231)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size j = 0  j < n  ++j
induction variable: ['j']
{
L3232: (paths_[j].payments,r) 
L3233: (paths_[j].exercises,r) 
L3234: (paths_[j].states,r) 
L3235: (prices[j]+=,w) 
L3236: (prices[j]+=,w) 
}
array table
-----------------------------------------------
prices -> [('[j]', 'w', 'normalized', ['j'], 3235), ('[j]', 'w', 'normalized', ['j'], 3236)]
LDEs formed:3

paths_ -> [('[j]', 'r', 'normalized', ['j'], 3232), ('[j]', 'r', 'normalized', ['j'], 3233), ('[j]', 'r', 'normalized', ['j'], 3234)]
LDEs formed:0

distinct LDEs:
j1=j2
#########################################################################################
loop info: Integer i = len - 2  i >= 0  --i
induction variable: ['i']
{
L3235: (dF_[i + 1]/,r) (dF_[i],r) 
L3236: (lowerBounds_[i + 1]*=,w) 
	loop info: Size j = 0  j < n  ++j
	induction variable: ['i', 'j']
	{
	L3237: (exercise[j]=,w) (paths_[j].exercises,r) 
	L3238: (paths_[j].states,r) 
	L3239: (exercise[j],r) (lowerBounds_[i + 1],r) 
	L3240: (prices[j],r) 
	}
L3241: (coeff_[i]=,w) 
L3242: (coeff_[i]=,w) 
	loop info: Size j = 0, k = 0  j < n  ++j
	induction variable: ['i', 'j']
	{
	L3243: (prices[j],r) 
	L3244: (lsExercise[j]=,w) 
	L3245: (paths_[j].states,r) 
	L3246: (exercise[j],r) 
	L3247: (coeff_[i].empty,r) (exercise[j],r) (lowerBounds_[i + 1],r) 
		loop info: Size l = 0  l < v_.size()  ++l
		induction variable: ['i', 'j', 'l']
				{
				L3248: (coeff_[i][l]*,r) (v_[l],r) (x[k],r) 
				}
	L3249: (exercise[j],r) 
	L3250: (lsExercise[j]=,w) 
	L3251: (prices[j],r) 
	L3252: (lsExercise[j],r) (exercise[j],r) (prices[j],r) 
	}
L3253: (lowerBounds_[i + 1],r) 
	loop info: Size j = 0  j < n  ++j
	induction variable: ['i', 'j', 'l']
		{
		L3254: (prices[j]=,w) (lsExercise[j],r) (exercise[j],r) (prices[j],r) 
		}
	loop info: Size j = 0  j < n  ++j
	induction variable: ['i', 'j', 'l']
		{
		L3255: (paths_[j].states,r) 
		L3256: (prices[j]=,w) (exercise[j],r) (prices[j],r) 
		}
L3257: (coeff_[i]=,w) 
L3258: (coeff_[i]=,w) 
	loop info: Size j = 0  j < n  ++j
	induction variable: ['i', 'j', 'l']
	{
	L3259: (paths_[j].payments,r) 
	L3260: (prices[j]+=,w) 
	}
L3261: (lowerBounds_[i]=,w) 
}
array table
-----------------------------------------------
dF_ -> [('[i + 1]', 'r', 'normalized', ['i', 'j', 'l'], 3235), ('[i]', 'r', 'normalized', ['i', 'j', 'l'], 3235)]
LDEs formed:0

lsExercise -> [('[j]', 'w', 'normalized', ['i', 'j', 'l'], 3244), ('[j]', 'w', 'normalized', ['i', 'j', 'l'], 3250), ('[j]', 'r', 'normalized', ['i', 'j', 'l'], 3252), ('[j]', 'r', 'normalized', ['i', 'j', 'l'], 3254)]
LDEs formed:7

lowerBounds_ -> [('[i + 1]', 'w', 'normalized', ['i', 'j', 'l'], 3236), ('[i + 1]', 'r', 'normalized', ['i', 'j', 'l'], 3239), ('[i + 1]', 'r', 'normalized', ['i', 'j', 'l'], 3247), ('[i + 1]', 'r', 'normalized', ['i', 'j', 'l'], 3253), ('[i]', 'w', 'normalized', ['i', 'j', 'l'], 3261)]
LDEs formed:9

coeff_ -> [('[i]', 'w', 'normalized', ['i', 'j', 'l'], 3241), ('[i]', 'w', 'normalized', ['i', 'j', 'l'], 3242), ('[i]', 'r', 'normalized', ['i', 'j', 'l'], 3247), ('[i][l]', 'r', 'normalized', ['i', 'j', 'l'], 3248), ('[i]', 'w', 'normalized', ['i', 'j', 'l'], 3257), ('[i]', 'w', 'normalized', ['i', 'j', 'l'], 3258)]
LDEs formed:18

paths_ -> [('[j]', 'r', 'normalized', ['i', 'j', 'l'], 3237), ('[j]', 'r', 'normalized', ['i', 'j', 'l'], 3238), ('[j]', 'r', 'normalized', ['i', 'j', 'l'], 3245), ('[j]', 'r', 'normalized', ['i', 'j', 'l'], 3255), ('[j]', 'r', 'normalized', ['i', 'j', 'l'], 3259)]
LDEs formed:0

prices -> [('[j]', 'r', 'normalized', ['i', 'j', 'l'], 3240), ('[j]', 'r', 'normalized', ['i', 'j', 'l'], 3243), ('[j]', 'r', 'normalized', ['i', 'j', 'l'], 3251), ('[j]', 'r', 'normalized', ['i', 'j', 'l'], 3252), ('[j]', 'w', 'normalized', ['i', 'j', 'l'], 3254), ('[j]', 'r', 'normalized', ['i', 'j', 'l'], 3254), ('[j]', 'w', 'normalized', ['i', 'j', 'l'], 3256), ('[j]', 'r', 'normalized', ['i', 'j', 'l'], 3256), ('[j]', 'w', 'normalized', ['i', 'j', 'l'], 3260)]
LDEs formed:24

x -> [('[k]', 'r', 'not normalized', ['i', 'j', 'l'], 3248)]
LDEs formed:0

exercise -> [('[j]', 'w', 'normalized', ['i', 'j', 'l'], 3237), ('[j]', 'r', 'normalized', ['i', 'j', 'l'], 3239), ('[j]', 'r', 'normalized', ['i', 'j', 'l'], 3246), ('[j]', 'r', 'normalized', ['i', 'j', 'l'], 3247), ('[j]', 'r', 'normalized', ['i', 'j', 'l'], 3249), ('[j]', 'r', 'normalized', ['i', 'j', 'l'], 3252), ('[j]', 'r', 'normalized', ['i', 'j', 'l'], 3254), ('[j]', 'r', 'normalized', ['i', 'j', 'l'], 3256)]
LDEs formed:8

v_ -> [('[l]', 'r', 'normalized', ['i', 'j', 'l'], 3248)]
LDEs formed:0

distinct LDEs:
i1 + 1=i2
j1=j2
i1=i2
i1 + 1=i2 + 1
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/experimental/credit/randomdefaultmodel.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size j = 0  j < pool_->size()  j++
induction variable: ['j']
{
L3249: (defaultKeys_[j],r) 
L3250: (values[0]+,r) (values[j+1],r) 
}
array table
-----------------------------------------------
values -> [('[0]', 'r', 'normalized', ['j'], 3250), ('[j+1]', 'r', 'normalized', ['j'], 3250)]
LDEs formed:0

defaultKeys_ -> [('[j]', 'r', 'normalized', ['j'], 3249)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/experimental/credit/integralntdengine.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i = 0  i < arguments_.premiumLeg.size()  i++
induction variable: ['i']
{
L3250: (arguments_.premiumLeg[i],r) 
L3251: (arguments_.premiumLeg[i]-,r) 
L3252: (arguments_.premiumLeg[i]-,r) 
L3253: (probsTriggering1[iName]-,r) 
L3254: (probsTriggering[iName],r) 
}
array table
-----------------------------------------------
arguments_.premiumLeg -> [('[i]', 'r', 'normalized', ['i'], 3250), ('[i]', 'r', 'normalized', ['i'], 3251), ('[i]', 'r', 'normalized', ['i'], 3252)]
LDEs formed:0

probsTriggering1 -> [('[iName]', 'r', 'not normalized', ['i'], 3253)]
LDEs formed:0

probsTriggering -> [('[iName]', 'r', 'not normalized', ['i'], 3254)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/experimental/credit/syntheticcdo.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/experimental/credit/onefactorcopula.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i = 0  i < y_.size()  i++
induction variable: ['i']
{
L3255: (y_[i],r) 
L3256: (y_[i]-,r) (cumulativeY_[i-1],r) 
L3257: (y_[i-1],r) (cumulativeY_[i],r) 
L3258: (y_[i]-,r) (y_[i-1],r) 
}
array table
-----------------------------------------------
cumulativeY_ -> [('[i-1]', 'r', 'normalized', ['i'], 3256), ('[i]', 'r', 'normalized', ['i'], 3257)]
LDEs formed:0

y_ -> [('[i]', 'r', 'normalized', ['i'], 3255), ('[i]', 'r', 'normalized', ['i'], 3256), ('[i-1]', 'r', 'normalized', ['i'], 3257), ('[i]', 'r', 'normalized', ['i'], 3258), ('[i-1]', 'r', 'normalized', ['i'], 3258)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i = 0  i < cumulativeY_.size()  i++
induction variable: ['i']
{
L3259: (cumulativeY_[i],r) 
L3260: (cumulativeY_[i]-,r) (y_[i-1],r) 
L3261: (cumulativeY_[i-1],r) (y_[i],r) 
L3262: (cumulativeY_[i]-,r) (cumulativeY_[i-1],r) 
}
array table
-----------------------------------------------
cumulativeY_ -> [('[i]', 'r', 'normalized', ['i'], 3259), ('[i]', 'r', 'normalized', ['i'], 3260), ('[i-1]', 'r', 'normalized', ['i'], 3261), ('[i]', 'r', 'normalized', ['i'], 3262), ('[i-1]', 'r', 'normalized', ['i'], 3262)]
LDEs formed:0

y_ -> [('[i-1]', 'r', 'normalized', ['i'], 3260), ('[i]', 'r', 'normalized', ['i'], 3261)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/experimental/credit/defaultevent.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/experimental/credit/onefactorgaussiancopula.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/experimental/credit/riskyassetswap.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i = 1  i < floatSchedule_.size()  i++
induction variable: ['i']
{
L3262: (floatSchedule_[i-1],r) 
L3263: (floatSchedule_[i],r) 
L3264: (floatSchedule_[i],r) 
}
array table
-----------------------------------------------
floatSchedule_ -> [('[i-1]', 'r', 'normalized', ['i'], 3262), ('[i]', 'r', 'normalized', ['i'], 3263), ('[i]', 'r', 'normalized', ['i'], 3264)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i = 1  i < floatSchedule_.size()  i++
induction variable: ['i']
{
L3265: (floatSchedule_[i-1],r) 
L3266: (floatSchedule_[i],r) 
L3267: (floatSchedule_[i],r) 
}
array table
-----------------------------------------------
floatSchedule_ -> [('[i-1]', 'r', 'normalized', ['i'], 3265), ('[i]', 'r', 'normalized', ['i'], 3266), ('[i]', 'r', 'normalized', ['i'], 3267)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i = 1  i < fixedSchedule_.size()  i++
induction variable: ['i']
{
L3268: (fixedSchedule_[i-1],r) 
L3269: (fixedSchedule_[i-1],r) 
L3270: (fixedSchedule_[i],r) 
}
array table
-----------------------------------------------
fixedSchedule_ -> [('[i-1]', 'r', 'normalized', ['i'], 3268), ('[i-1]', 'r', 'normalized', ['i'], 3269), ('[i]', 'r', 'normalized', ['i'], 3270)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i = 1  i < fixedSchedule_.size()  i++
induction variable: ['i']
{
L3271: (fixedSchedule_[i-1],r) 
L3272: (fixedSchedule_[i],r) 
L3273: (fixedSchedule_[i],r) 
L3274: (fixedSchedule_[i],r) 
}
array table
-----------------------------------------------
fixedSchedule_ -> [('[i-1]', 'r', 'normalized', ['i'], 3271), ('[i]', 'r', 'normalized', ['i'], 3272), ('[i]', 'r', 'normalized', ['i'], 3273), ('[i]', 'r', 'normalized', ['i'], 3274)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i = 1  i < fixedSchedule_.size()  i++
induction variable: ['i']
{
L3275: (fixedSchedule_[i-1],r) 
L3276: (fixedSchedule_[i],r) 
L3277: (fixedSchedule_[i],r) 
L3278: (fixedSchedule_[i],r) 
}
array table
-----------------------------------------------
fixedSchedule_ -> [('[i-1]', 'r', 'normalized', ['i'], 3275), ('[i]', 'r', 'normalized', ['i'], 3276), ('[i]', 'r', 'normalized', ['i'], 3277), ('[i]', 'r', 'normalized', ['i'], 3278)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/experimental/credit/basket.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i = 0  i < notionals_.size()  i++
induction variable: ['i']
{
L3279: (notionals_[i],r) 
L3280: (notionals_[i]*,r) 
L3281: (notionals_[i]*,r) 
}
array table
-----------------------------------------------
notionals_ -> [('[i]', 'r', 'normalized', ['i'], 3279), ('[i]', 'r', 'normalized', ['i'], 3280), ('[i]', 'r', 'normalized', ['i'], 3281)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i = 0  i < size()  i++
induction variable: ['i']
{
L3282: (notionals_[i],r) 
}
array table
-----------------------------------------------
notionals_ -> [('[i]', 'r', 'normalized', ['i'], 3282)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i = 0  i < size()  i++
induction variable: ['i']
{
L3283: (notionals_[i],r) 
}
array table
-----------------------------------------------
notionals_ -> [('[i]', 'r', 'normalized', ['i'], 3283)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i = 0  i < size()  i++
induction variable: ['i']
{
L3284: (defKeys[i],r) 
L3285: (notionals_[i],r) 
}
array table
-----------------------------------------------
notionals_ -> [('[i]', 'r', 'normalized', ['i'], 3285)]
LDEs formed:0

defKeys -> [('[i]', 'r', 'normalized', ['i'], 3284)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/experimental/credit/lossdistribution.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size j = 0  j < n  j++
induction variable: ['j']
{
L3285: (probability[0]=,w) (prev[0]*,r) (p[j],r) 
	loop info: Size i = 1  i <= j  i++
	induction variable: ['j', 'i']
	{
	}
L3286: (probability[j+1]=,w) (prev[j]*,r) (p[j],r) 
}
array table
-----------------------------------------------
p -> [('[j]', 'r', 'normalized', ['j', 'i'], 3285), ('[j]', 'r', 'normalized', ['j', 'i'], 3286)]
LDEs formed:0

prev -> [('[0]', 'r', 'normalized', ['j', 'i'], 3285), ('[j]', 'r', 'normalized', ['j', 'i'], 3286)]
LDEs formed:0

probability -> [('[0]', 'w', 'normalized', ['j', 'i'], 3285), ('[j+1]', 'w', 'normalized', ['j', 'i'], 3286)]
LDEs formed:3

distinct LDEs:
j1+1=j2+1
0=j2+1
0=0
#########################################################################################
loop info: Size i = 0  i <= n  i++
induction variable: ['i']
{
L3287: (probability_[i]=,w) 
L3288: (probability_[i]/,r) 
}
array table
-----------------------------------------------
probability_ -> [('[i]', 'w', 'normalized', ['i'], 3287), ('[i]', 'r', 'normalized', ['i'], 3288)]
LDEs formed:2

distinct LDEs:
i1=i2
#########################################################################################
loop info: Size k = 0  k < n_  k++
induction variable: ['k']
{
L3289: (probability_[0]=,w) (prev[0]*,r) (p[k],r) 
	loop info: Size i = 1  i <= k  i++
	induction variable: ['k', 'i']
	{
	}
L3290: (probability_[k+1]=,w) (prev[k]*,r) (p[k],r) 
}
array table
-----------------------------------------------
p -> [('[k]', 'r', 'normalized', ['k', 'i'], 3289), ('[k]', 'r', 'normalized', ['k', 'i'], 3290)]
LDEs formed:0

prev -> [('[0]', 'r', 'normalized', ['k', 'i'], 3289), ('[k]', 'r', 'normalized', ['k', 'i'], 3290)]
LDEs formed:0

probability_ -> [('[0]', 'w', 'normalized', ['k', 'i'], 3289), ('[k+1]', 'w', 'normalized', ['k', 'i'], 3290)]
LDEs formed:3

distinct LDEs:
0=k2+1
k1+1=k2+1
0=0
#########################################################################################
loop info: Size i = 0  i <= n_  i++
induction variable: ['i']
{
L3291: (probability_[i]/,r) 
}
array table
-----------------------------------------------
probability_ -> [('[i]', 'r', 'normalized', ['i'], 3291)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i = 0  i < nominals.size()  i++
induction variable: ['i']
{
L3292: (nominals[i],r) 
L3293: (probabilities[i],r) 
	loop info: int k = a.size()-1  k >= 0  k--
	induction variable: ['i', 'k']
	{
	L3294: (p[k],r) 
	L3295: (a[k]+,r) 
	L3296: (p[k]*,r) 
	L3297: (a[k]+=,w) 
	L3298: (a[u],r) (p[u],r) 
	L3299: (a[u],r) 
	L3300: (p[u]/,r) 
	L3301: (p[k],r) 
	L3302: (p[u]/,r) (p[k],r) 
	L3303: (p[u]/,r) (p[k],r) 
	L3304: (a[u]=,w) (a[u]+,r) (a[k]+,r) 
	L3305: (p[u]+,r) 
	L3306: (a[u]=,w) (p[u]*,r) (a[u]+,r) (a[k]+,r) 
	L3307: (p[u]+,r) 
	L3308: (p[u]+=,w) 
	L3309: (p[k]-=,w) 
	L3310: (a[k]+,r) (a[k],r) 
	}
 }
array table
-----------------------------------------------
probabilities -> [('[i]', 'r', 'normalized', ['i', 'k'], 3293)]
LDEs formed:0

p -> [('[k]', 'r', 'normalized', ['i', 'k'], 3294), ('[k]', 'r', 'normalized', ['i', 'k'], 3296), ('[u]', 'r', 'not normalized', ['i', 'k'], 3298), ('[u]', 'r', 'not normalized', ['i', 'k'], 3300), ('[k]', 'r', 'normalized', ['i', 'k'], 3301), ('[u]', 'r', 'not normalized', ['i', 'k'], 3302), ('[k]', 'r', 'normalized', ['i', 'k'], 3302), ('[u]', 'r', 'not normalized', ['i', 'k'], 3303), ('[k]', 'r', 'normalized', ['i', 'k'], 3303), ('[u]', 'r', 'not normalized', ['i', 'k'], 3305), ('[u]', 'r', 'not normalized', ['i', 'k'], 3306), ('[u]', 'r', 'not normalized', ['i', 'k'], 3307), ('[u]', 'w', 'not normalized', ['i', 'k'], 3308), ('[k]', 'w', 'normalized', ['i', 'k'], 3309)]
LDEs formed:27

a -> [('[k]', 'r', 'normalized', ['i', 'k'], 3295), ('[k]', 'w', 'normalized', ['i', 'k'], 3297), ('[u]', 'r', 'not normalized', ['i', 'k'], 3298), ('[u]', 'r', 'not normalized', ['i', 'k'], 3299), ('[u]', 'w', 'not normalized', ['i', 'k'], 3304), ('[u]', 'r', 'not normalized', ['i', 'k'], 3304), ('[k]', 'r', 'normalized', ['i', 'k'], 3304), ('[u]', 'w', 'not normalized', ['i', 'k'], 3306), ('[u]', 'r', 'not normalized', ['i', 'k'], 3306), ('[k]', 'r', 'normalized', ['i', 'k'], 3306), ('[k]', 'r', 'normalized', ['i', 'k'], 3310), ('[k]', 'r', 'normalized', ['i', 'k'], 3310)]
LDEs formed:33

nominals -> [('[i]', 'r', 'normalized', ['i', 'k'], 3292)]
LDEs formed:0

distinct LDEs:
u=u
k1=k2
k1=u
#########################################################################################
loop info: Size i = 0  i < nBuckets_  i++
induction variable: ['i']
{
L3293: (p[i]/,r) 
L3294: (a[i],r) 
}
array table
-----------------------------------------------
a -> [('[i]', 'r', 'normalized', ['i'], 3294)]
LDEs formed:0

p -> [('[i]', 'r', 'normalized', ['i'], 3293)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i = 0  i < simulations_  i++
induction variable: ['i']
{
	loop info: Size j = 0  j < nominals.size()  j++
	induction variable: ['i', 'j']
	{
	L3294: (probabilities[j],r) 
	L3295: (nominals[j],r) 
	}
 }
array table
-----------------------------------------------
probabilities -> [('[j]', 'r', 'normalized', ['i', 'j'], 3294)]
LDEs formed:0

nominals -> [('[j]', 'r', 'normalized', ['i', 'j'], 3295)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/experimental/credit/cdo.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i = 0  i < nominals_.size()  i++
induction variable: ['i']
{
L3296: (nominals_[i]*,r) 
L3297: (nominals_[i],r) 
L3298: (lgds_[i],r) 
}
array table
-----------------------------------------------
nominals_ -> [('[i]', 'r', 'normalized', ['i'], 3296), ('[i]', 'r', 'normalized', ['i'], 3297)]
LDEs formed:0

lgds_ -> [('[i]', 'r', 'normalized', ['i'], 3298)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i = 1  i < premiumSchedule_.size()  i++
induction variable: ['i']
{
L3299: (premiumSchedule_[i],r) 
L3300: (premiumSchedule_[i-1],r) 
}
array table
-----------------------------------------------
premiumSchedule_ -> [('[i]', 'r', 'normalized', ['i'], 3299), ('[i-1]', 'r', 'normalized', ['i'], 3300)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/experimental/credit/riskybond.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i = 0  i < cf.size()  i++
induction variable: ['i']
{
L3301: (cf[i]-,r) 
L3302: (cf[i]-,r) 
}
array table
-----------------------------------------------
cf -> [('[i]', 'r', 'normalized', ['i'], 3301), ('[i]', 'r', 'normalized', ['i'], 3302)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i = 0  i < cf.size()  i++
induction variable: ['i']
{
L3303: (cf[i]-,r) 
L3304: (cf[i]-,r) 
}
array table
-----------------------------------------------
cf -> [('[i]', 'r', 'normalized', ['i'], 3303), ('[i]', 'r', 'normalized', ['i'], 3304)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i = 0  i < cf.size()  i++
induction variable: ['i']
{
L3305: (cf[i]-,r) 
L3306: (cf[i]-,r) 
}
array table
-----------------------------------------------
cf -> [('[i]', 'r', 'normalized', ['i'], 3305), ('[i]', 'r', 'normalized', ['i'], 3306)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i = 0  i < cf.size()  i++
induction variable: ['i']
{
L3307: (cf[i]-,r) 
L3308: (cf[i]-,r) 
}
array table
-----------------------------------------------
cf -> [('[i]', 'r', 'normalized', ['i'], 3307), ('[i]', 'r', 'normalized', ['i'], 3308)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i = 1  i < dates.size()  i++
induction variable: ['i']
{
L3309: (notionals_[i],r) 
L3310: (dates[i],r) 
L3311: (dates[i-1],r) (dates[i],r) 
L3312: (dates[i],r) 
}
array table
-----------------------------------------------
notionals_ -> [('[i]', 'r', 'normalized', ['i'], 3309)]
LDEs formed:0

dates -> [('[i]', 'r', 'normalized', ['i'], 3310), ('[i-1]', 'r', 'normalized', ['i'], 3311), ('[i]', 'r', 'normalized', ['i'], 3311), ('[i]', 'r', 'normalized', ['i'], 3312)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i = 0  i < schedule_.size()  i++
induction variable: ['i']
{
L3313: (schedule_[i],r) 
L3314: (notionals_[i],r) 
}
array table
-----------------------------------------------
notionals_ -> [('[i]', 'r', 'normalized', ['i'], 3314)]
LDEs formed:0

schedule_ -> [('[i]', 'r', 'normalized', ['i'], 3313)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i = 1  i < dates.size()  i++
induction variable: ['i']
{
L3314: (notionals_[i],r) 
L3315: (dates[i],r) (dates[i-1],r) (dates[i],r) 
L3316: (dates[i],r) 
}
array table
-----------------------------------------------
notionals_ -> [('[i]', 'r', 'normalized', ['i'], 3314)]
LDEs formed:0

dates -> [('[i]', 'r', 'normalized', ['i'], 3315), ('[i-1]', 'r', 'normalized', ['i'], 3315), ('[i]', 'r', 'normalized', ['i'], 3315), ('[i]', 'r', 'normalized', ['i'], 3316)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i = 0  i < schedule_.size()  i++
induction variable: ['i']
{
L3317: (schedule_[i],r) 
L3318: (notionals_[i],r) 
}
array table
-----------------------------------------------
notionals_ -> [('[i]', 'r', 'normalized', ['i'], 3318)]
LDEs formed:0

schedule_ -> [('[i]', 'r', 'normalized', ['i'], 3317)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/experimental/credit/gaussianlhplossmodel.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/experimental/credit/defaultprobabilitykey.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/experimental/credit/issuer.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i <eventTypes.size()  i++
induction variable: ['i']
{
L3318: (eventTypes[i],r) (currencies[i],r) 
L3319: (seniorities[i],r) 
L3320: (curves[i],r) 
}
array table
-----------------------------------------------
eventTypes -> [('[i]', 'r', 'normalized', ['i'], 3318)]
LDEs formed:0

currencies -> [('[i]', 'r', 'normalized', ['i'], 3318)]
LDEs formed:0

curves -> [('[i]', 'r', 'normalized', ['i'], 3320)]
LDEs formed:0

seniorities -> [('[i]', 'r', 'normalized', ['i'], 3319)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/experimental/credit/distribution.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: int i = 0  i < nBuckets  i++
induction variable: ['i']
{
L3320: (dx_[i]=,w) 
L3321: (x_[i]=,w) (x_[i-1]+,r) (dx_[i-1],r) 
}
array table
-----------------------------------------------
dx_ -> [('[i]', 'w', 'normalized', ['i'], 3320), ('[i-1]', 'r', 'normalized', ['i'], 3321)]
LDEs formed:2

x_ -> [('[i]', 'w', 'normalized', ['i'], 3321), ('[i-1]', 'r', 'normalized', ['i'], 3321)]
LDEs formed:2

distinct LDEs:
i1=i2-1
i1=i2
#########################################################################################
loop info: Size i = 0  i < x_.size()  i++
induction variable: ['i']
{
L3322: (x_[i],r) 
}
array table
-----------------------------------------------
x_ -> [('[i]', 'r', 'normalized', ['i'], 3322)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i = 0  i < count_.size()  i++
induction variable: ['i']
{
L3323: (x_[i]+,r) (dx_[i],r) 
L3324: (count_[i]++,w) 
L3325: (average_[i]+=,w) 
}
array table
-----------------------------------------------
dx_ -> [('[i]', 'r', 'normalized', ['i'], 3323)]
LDEs formed:0

average_ -> [('[i]', 'w', 'normalized', ['i'], 3325)]
LDEs formed:1

x_ -> [('[i]', 'r', 'normalized', ['i'], 3323)]
LDEs formed:0

count_ -> [('[i]', 'w', 'normalized', ['i'], 3324)]
LDEs formed:1

distinct LDEs:
i1=i2
#########################################################################################
loop info: int i = 0  i < size_  i++
induction variable: ['i']
{
L3325: (density_[i]=,w) (dx_[i]*,r) (count_[i]/,r) 
L3326: (count_[i],r) 
L3327: (average_[i]/=,w) (count_[i],r) 
L3328: (density_[i]==,r) 
L3329: (average_[i]=,w) (x_[i]+,r) (dx_[i]/,r) 
L3330: (cumulativeDensity_[i]=,w) (density_[i]*,r) (dx_[i],r) 
L3331: (cumulativeDensity_[i]+=,w) (cumulativeDensity_[i-1],r) 
L3332: (excessProbability_[i]=,w) (cumulativeDensity_[i-1],r) 
L3333: (excessProbability_[i]=,w) (excessProbability_[i-1],r) 
L3334: (density_[i-1]*,r) (dx_[i-1],r) 
L3335: (cumulativeExcessProbability_[i],r) 
L3336: (excessProbability_[i-1]+,r) 
L3337: (excessProbability_[i],r) (dx_[i-1],r) 
L3338: (cumulativeExcessProbability_[i-1],r) 
L3339: (cumulativeExcessProbability_[i],r) 
L3340: (excessProbability_[i-1]*,r) (dx_[i-1],r) 
L3341: (cumulativeExcessProbability_[i-1],r) 
}
array table
-----------------------------------------------
dx_ -> [('[i]', 'r', 'normalized', ['i'], 3325), ('[i]', 'r', 'normalized', ['i'], 3329), ('[i]', 'r', 'normalized', ['i'], 3330), ('[i-1]', 'r', 'normalized', ['i'], 3334), ('[i-1]', 'r', 'normalized', ['i'], 3337), ('[i-1]', 'r', 'normalized', ['i'], 3340)]
LDEs formed:0

cumulativeDensity_ -> [('[i]', 'w', 'normalized', ['i'], 3330), ('[i]', 'w', 'normalized', ['i'], 3331), ('[i-1]', 'r', 'normalized', ['i'], 3331), ('[i-1]', 'r', 'normalized', ['i'], 3332)]
LDEs formed:7

average_ -> [('[i]', 'w', 'normalized', ['i'], 3327), ('[i]', 'w', 'normalized', ['i'], 3329)]
LDEs formed:3

excessProbability_ -> [('[i]', 'w', 'normalized', ['i'], 3332), ('[i]', 'w', 'normalized', ['i'], 3333), ('[i-1]', 'r', 'normalized', ['i'], 3333), ('[i-1]', 'r', 'normalized', ['i'], 3336), ('[i]', 'r', 'normalized', ['i'], 3337), ('[i-1]', 'r', 'normalized', ['i'], 3340)]
LDEs formed:11

x_ -> [('[i]', 'r', 'normalized', ['i'], 3329)]
LDEs formed:0

count_ -> [('[i]', 'r', 'normalized', ['i'], 3325), ('[i]', 'r', 'normalized', ['i'], 3326), ('[i]', 'r', 'normalized', ['i'], 3327)]
LDEs formed:0

density_ -> [('[i]', 'w', 'normalized', ['i'], 3325), ('[i]', 'r', 'normalized', ['i'], 3328), ('[i]', 'r', 'normalized', ['i'], 3330), ('[i-1]', 'r', 'normalized', ['i'], 3334)]
LDEs formed:4

cumulativeExcessProbability_ -> [('[i]', 'r', 'normalized', ['i'], 3335), ('[i-1]', 'r', 'normalized', ['i'], 3338), ('[i]', 'r', 'normalized', ['i'], 3339), ('[i-1]', 'r', 'normalized', ['i'], 3341)]
LDEs formed:0

distinct LDEs:
i1=i2-1
i1=i2
#########################################################################################
loop info: int i = 0  i < size_  i++
induction variable: ['i']
{
L3342: (cumulativeDensity_[i],r) 
L3343: (x_[i]+,r) (dx_[i],r) 
}
array table
-----------------------------------------------
cumulativeDensity_ -> [('[i]', 'r', 'normalized', ['i'], 3342)]
LDEs formed:0

dx_ -> [('[i]', 'r', 'normalized', ['i'], 3343)]
LDEs formed:0

x_ -> [('[i]', 'r', 'normalized', ['i'], 3343)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: int i = 0  i < size_  i++
induction variable: ['i']
{
L3344: (x_[i]+,r) (dx_[i]/,r) 
L3345: (dx_[i]*,r) (density_[i],r) 
}
array table
-----------------------------------------------
dx_ -> [('[i]', 'r', 'normalized', ['i'], 3344), ('[i]', 'r', 'normalized', ['i'], 3345)]
LDEs formed:0

x_ -> [('[i]', 'r', 'normalized', ['i'], 3344)]
LDEs formed:0

density_ -> [('[i]', 'r', 'normalized', ['i'], 3345)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: int i = 0  i < size_  i++
induction variable: ['i']
{
L3346: (x_[i]+,r) (dx_[i]/,r) 
L3347: (dx_[i]*,r) (density_[i],r) 
}
array table
-----------------------------------------------
dx_ -> [('[i]', 'r', 'normalized', ['i'], 3346), ('[i]', 'r', 'normalized', ['i'], 3347)]
LDEs formed:0

x_ -> [('[i]', 'r', 'normalized', ['i'], 3346)]
LDEs formed:0

density_ -> [('[i]', 'r', 'normalized', ['i'], 3347)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: int i = 0  i < size_  i++
induction variable: ['i']
{
L3348: (x_[i],r) 
L3349: (x_[i],r) 
L3350: (dx_[i]*,r) (excessProbability_[i],r) 
}
array table
-----------------------------------------------
dx_ -> [('[i]', 'r', 'normalized', ['i'], 3350)]
LDEs formed:0

excessProbability_ -> [('[i]', 'r', 'normalized', ['i'], 3350)]
LDEs formed:0

x_ -> [('[i]', 'r', 'normalized', ['i'], 3348), ('[i]', 'r', 'normalized', ['i'], 3349)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: int i = 0  i < size_  i++
induction variable: ['i']
{
L3350: (x_[i]+,r) (dx_[i]+,r) 
L3351: (x_[i],r) (cumulativeDensity_[i],r) 
L3352: (x_[i]+,r) (dx_[i]-,r) (cumulativeDensity_[i-1],r) (dx_[i],r) 
}
array table
-----------------------------------------------
dx_ -> [('[i]', 'r', 'normalized', ['i'], 3350), ('[i]', 'r', 'normalized', ['i'], 3352), ('[i]', 'r', 'normalized', ['i'], 3352)]
LDEs formed:0

cumulativeDensity_ -> [('[i]', 'r', 'normalized', ['i'], 3351), ('[i-1]', 'r', 'normalized', ['i'], 3352)]
LDEs formed:0

x_ -> [('[i]', 'r', 'normalized', ['i'], 3350), ('[i]', 'r', 'normalized', ['i'], 3351), ('[i]', 'r', 'normalized', ['i'], 3352)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i = 0  i < x_.size()  i++
induction variable: ['i']
{
L3353: (x_[i]=,w) (x_[i]-,r) 
}
array table
-----------------------------------------------
x_ -> [('[i]', 'w', 'normalized', ['i'], 3353), ('[i]', 'r', 'normalized', ['i'], 3353)]
LDEs formed:2

distinct LDEs:
i1=i2
#########################################################################################
loop info: Integer i=1  i<size_-1  i++
induction variable: ['i']
{
L3354: (cumulativeDensity_[i-1],r) 
L3355: (cumulativeDensity_[i]-,r) 
L3356: (cumulativeDensity_[i-1],r) (dx_[i],r) 
}
array table
-----------------------------------------------
cumulativeDensity_ -> [('[i-1]', 'r', 'normalized', ['i'], 3354), ('[i]', 'r', 'normalized', ['i'], 3355), ('[i-1]', 'r', 'normalized', ['i'], 3356)]
LDEs formed:0

dx_ -> [('[i]', 'r', 'normalized', ['i'], 3356)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i1 = 0  i1 < d1.size()  i1++
induction variable: ['i1']
{
L3357: (d1.dx_[i1],r) 
	loop info: Size i2 = 0  i2 < d2.size()  i2++
	induction variable: ['i1', 'i2']
	{
	}
 }
array table
-----------------------------------------------
d1.dx_ -> [('[i1]', 'r', 'normalized', ['i1', 'i2'], 3357)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i = 0  i < dist.size()  i++
induction variable: ['i']
{
L3358: (dist.cumulativeDensity_[i]=,w) (dist.density_[i]*,r) (dist.dx_[i],r) 
L3359: (dist.cumulativeDensity_[i]+=,w) (dist.cumulativeDensity_[i-1],r) 
L3360: (dist.excessProbability_[i]=,w) (dist.excessProbability_[i-1],r) 
L3361: (dist.density_[i-1]*,r) (dist.dx_[i-1],r) 
}
array table
-----------------------------------------------
dist.excessProbability_ -> [('[i]', 'w', 'normalized', ['i'], 3360), ('[i-1]', 'r', 'normalized', ['i'], 3360)]
LDEs formed:2

dist.dx_ -> [('[i]', 'r', 'normalized', ['i'], 3358), ('[i-1]', 'r', 'normalized', ['i'], 3361)]
LDEs formed:0

dist.cumulativeDensity_ -> [('[i]', 'w', 'normalized', ['i'], 3358), ('[i]', 'w', 'normalized', ['i'], 3359), ('[i-1]', 'r', 'normalized', ['i'], 3359)]
LDEs formed:5

dist.density_ -> [('[i]', 'r', 'normalized', ['i'], 3358), ('[i-1]', 'r', 'normalized', ['i'], 3361)]
LDEs formed:0

distinct LDEs:
i1=i2-1
i1=i2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/experimental/credit/midpointcdoengine.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i = 0  i < arguments_.normalizedLeg.size()  i++
induction variable: ['i']
{
L3362: (arguments_.normalizedLeg[i]-,r) 
L3363: (arguments_.normalizedLeg[i],r) 
}
array table
-----------------------------------------------
arguments_.normalizedLeg -> [('[i]', 'r', 'normalized', ['i'], 3362), ('[i]', 'r', 'normalized', ['i'], 3363)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/experimental/credit/integralcdoengine.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i = 0  i < arguments_.normalizedLeg.size()  i++
induction variable: ['i']
{
L3364: (arguments_.normalizedLeg[i]-,r) 
L3365: (arguments_.normalizedLeg[i],r) 
}
array table
-----------------------------------------------
arguments_.normalizedLeg -> [('[i]', 'r', 'normalized', ['i'], 3364), ('[i]', 'r', 'normalized', ['i'], 3365)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/experimental/credit/onefactorstudentcopula.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/experimental/risk/sensitivityanalysis.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size j=0  j<m  ++j
induction variable: ['j']
{
L3366: (deltaVector[j]=,w) 
L3367: (gammaVector[j]=,w) 
}
array table
-----------------------------------------------
gammaVector -> [('[j]', 'w', 'normalized', ['j'], 3367)]
LDEs formed:1

deltaVector -> [('[j]', 'w', 'normalized', ['j'], 3366)]
LDEs formed:1

distinct LDEs:
j1=j2
#########################################################################################
loop info: Size j=0  j<m  ++j
induction variable: ['j']
{
L3367: (params[j]-,r) 
L3368: (refVals[j]=,w) (params[j]-,r) 
}
array table
-----------------------------------------------
refVals -> [('[j]', 'w', 'normalized', ['j'], 3368)]
LDEs formed:1

params -> [('[j]', 'r', 'normalized', ['j'], 3367), ('[j]', 'r', 'normalized', ['j'], 3368)]
LDEs formed:0

distinct LDEs:
j1=j2
#########################################################################################
loop info: Size j=0  j<m  ++j
induction variable: ['j']
{
L3369: (gammaVector[j]=,w) 
L3370: (refVals[j],r) 
L3371: (deltaVector[j]=,w) (params[j]-,r) (refVals[j],r) 
L3372: (deltaVector[j]=,w) 
}
array table
-----------------------------------------------
refVals -> [('[j]', 'r', 'normalized', ['j'], 3370), ('[j]', 'r', 'normalized', ['j'], 3371)]
LDEs formed:0

gammaVector -> [('[j]', 'w', 'normalized', ['j'], 3369)]
LDEs formed:1

deltaVector -> [('[j]', 'w', 'normalized', ['j'], 3371), ('[j]', 'w', 'normalized', ['j'], 3372)]
LDEs formed:3

params -> [('[j]', 'r', 'normalized', ['j'], 3371)]
LDEs formed:0

distinct LDEs:
j1=j2
#########################################################################################
loop info: Size j=0  j<m  ++j
induction variable: ['j']
{
L3372: (refVals[j],r) 
L3373: (plus[j]=,w) (params[j]-,r) 
}
array table
-----------------------------------------------
refVals -> [('[j]', 'r', 'normalized', ['j'], 3372)]
LDEs formed:0

params -> [('[j]', 'r', 'normalized', ['j'], 3373)]
LDEs formed:0

plus -> [('[j]', 'w', 'normalized', ['j'], 3373)]
LDEs formed:1

distinct LDEs:
j1=j2
#########################################################################################
loop info: Size j=0  j<m  ++j
induction variable: ['j']
{
L3374: (refVals[j],r) 
L3375: (params[j]-,r) 
L3376: (deltaVector[j]=,w) (plus[j]-,r) 
L3377: (gammaVector[j]=,w) (plus[j]-,r) (refVals[j]+,r) 
L3378: (deltaVector[j]=,w) 
L3379: (gammaVector[j]=,w) 
}
array table
-----------------------------------------------
refVals -> [('[j]', 'r', 'normalized', ['j'], 3374), ('[j]', 'r', 'normalized', ['j'], 3377)]
LDEs formed:0

deltaVector -> [('[j]', 'w', 'normalized', ['j'], 3376), ('[j]', 'w', 'normalized', ['j'], 3378)]
LDEs formed:3

params -> [('[j]', 'r', 'normalized', ['j'], 3375)]
LDEs formed:0

plus -> [('[j]', 'r', 'normalized', ['j'], 3376), ('[j]', 'r', 'normalized', ['j'], 3377)]
LDEs formed:0

gammaVector -> [('[j]', 'w', 'normalized', ['j'], 3377), ('[j]', 'w', 'normalized', ['j'], 3379)]
LDEs formed:3

distinct LDEs:
j1=j2
#########################################################################################
loop info: Size i=0  i<n  ++i
induction variable: ['i']
{
L3380: (quotes[i],r) 
L3381: (result.first[i]=,w) 
L3382: (result.second[i]=,w) 
}
array table
-----------------------------------------------
quotes -> [('[i]', 'r', 'normalized', ['i'], 3380)]
LDEs formed:0

result.second -> [('[i]', 'w', 'normalized', ['i'], 3382)]
LDEs formed:1

result.first -> [('[i]', 'w', 'normalized', ['i'], 3381)]
LDEs formed:1

distinct LDEs:
i1=i2
#########################################################################################
loop info: Size i=0  i<m  ++i
induction variable: ['i']
{
L3382: (parameters[i]-,r) 
L3383: (referenceValues[i]=,w) (parameters[i]-,r) 
}
array table
-----------------------------------------------
referenceValues -> [('[i]', 'w', 'normalized', ['i'], 3383)]
LDEs formed:1

parameters -> [('[i]', 'r', 'normalized', ['i'], 3382), ('[i]', 'r', 'normalized', ['i'], 3383)]
LDEs formed:0

distinct LDEs:
i1=i2
#########################################################################################
loop info: Size i=0  i<n  ++i
induction variable: ['i']
{
L3384: (deltaMatrix[i],r) (gammaMatrix[i],r) 
L3385: (quotes[i],r) 
}
array table
-----------------------------------------------
quotes -> [('[i]', 'r', 'normalized', ['i'], 3385)]
LDEs formed:0

deltaMatrix -> [('[i]', 'r', 'normalized', ['i'], 3384)]
LDEs formed:0

gammaMatrix -> [('[i]', 'r', 'normalized', ['i'], 3384)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<n  ++i
induction variable: ['i']
{
L3385: (quotes[i].size,r) 
L3386: (first[i]=,w) 
L3387: (second[i]=,w) 
}
array table
-----------------------------------------------
quotes -> [('[i]', 'r', 'normalized', ['i'], 3385)]
LDEs formed:0

second -> [('[i]', 'w', 'normalized', ['i'], 3387)]
LDEs formed:1

first -> [('[i]', 'w', 'normalized', ['i'], 3386)]
LDEs formed:1

distinct LDEs:
i1=i2
#########################################################################################
loop info: Size i=0  i<n  ++i
induction variable: ['i']
{
	loop info: Size j=0  j<quotes[i].size()  ++j
	induction variable: ['i', 'j']
	{
	L3387: (quotes[i][j],r) 
	L3388: (result.first[i][j]=,w) 
	L3389: (result.second[i][j]=,w) 
	}
 }
array table
-----------------------------------------------
quotes -> [('[i][j]', 'r', 'normalized', ['i', 'j'], 3387)]
LDEs formed:0

result.second -> [('[i][j]', 'w', 'normalized', ['i', 'j'], 3389)]
LDEs formed:2

result.first -> [('[i][j]', 'w', 'normalized', ['i', 'j'], 3388)]
LDEs formed:2

distinct LDEs:
i1=i2,j1=j2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/experimental/risk/creditriskplus.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i = 0  i < m_  ++i
induction variable: ['i']
{
L3389: (exposure_[i],r) 
L3390: (exposure_[i]<<,r) 
L3391: (pd_[i],r) (pd_[i],r) 
L3392: (sector_[i],r) (sector_[i],r) 
L3393: (exposure_[i],r) 
L3394: (pd_[i]*,r) (exposure_[i],r) 
L3395: (pd_[i]*,r) (exposure_[i]*,r) (exposure_[i],r) 
}
array table
-----------------------------------------------
pd_ -> [('[i]', 'r', 'normalized', ['i'], 3391), ('[i]', 'r', 'normalized', ['i'], 3391), ('[i]', 'r', 'normalized', ['i'], 3394), ('[i]', 'r', 'normalized', ['i'], 3395)]
LDEs formed:0

sector_ -> [('[i]', 'r', 'normalized', ['i'], 3392), ('[i]', 'r', 'normalized', ['i'], 3392)]
LDEs formed:0

exposure_ -> [('[i]', 'r', 'normalized', ['i'], 3389), ('[i]', 'r', 'normalized', ['i'], 3390), ('[i]', 'r', 'normalized', ['i'], 3393), ('[i]', 'r', 'normalized', ['i'], 3394), ('[i]', 'r', 'normalized', ['i'], 3395), ('[i]', 'r', 'normalized', ['i'], 3395)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size k = 0  k < m_  ++k
induction variable: ['k']
{
L3396: (exposure_[k]/,r) 
L3397: (exposure_[k],r) 
L3398: (pdAdj[k]=,w) (exposure_[k],r) 
L3399: (exposure_[k]*,r) (pd_[k]/,r) 
L3400: (pdAdj[k],r) 
}
array table
-----------------------------------------------
pd_ -> [('[k]', 'r', 'normalized', ['k'], 3399)]
LDEs formed:0

exposure_ -> [('[k]', 'r', 'normalized', ['k'], 3396), ('[k]', 'r', 'normalized', ['k'], 3397), ('[k]', 'r', 'normalized', ['k'], 3398), ('[k]', 'r', 'normalized', ['k'], 3399)]
LDEs formed:0

pdAdj -> [('[k]', 'w', 'normalized', ['k'], 3398), ('[k]', 'r', 'normalized', ['k'], 3400)]
LDEs formed:2

distinct LDEs:
k1=k2
#########################################################################################
loop info: Size k = 0  k < m_  ++k
induction variable: ['k']
{
L3401: (pdAdj[k],r) 
L3402: (sector_[k],r) (pd_[k],r) 
L3403: (sector_[k],r) (exposure_[k],r) 
L3404: (sector_[k],r) (exposure_[k]*,r) (pd_[k],r) 
}
array table
-----------------------------------------------
pd_ -> [('[k]', 'r', 'normalized', ['k'], 3402), ('[k]', 'r', 'normalized', ['k'], 3404)]
LDEs formed:0

sector_ -> [('[k]', 'r', 'normalized', ['k'], 3402), ('[k]', 'r', 'normalized', ['k'], 3403), ('[k]', 'r', 'normalized', ['k'], 3404)]
LDEs formed:0

exposure_ -> [('[k]', 'r', 'normalized', ['k'], 3403), ('[k]', 'r', 'normalized', ['k'], 3404)]
LDEs formed:0

pdAdj -> [('[k]', 'r', 'normalized', ['k'], 3401)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i = 0  i < n_  ++i
induction variable: ['i']
{
L3402: (sectorSpecTerms_[i]+=,w) (relativeDefaultVariance_[i]*,r) (sectorEl_[i],r) 
	loop info: Size j = 0  j < n_  ++j
	induction variable: ['i', 'j']
	{
	L3403: (sectorSpecTerms_[i]+=,w) 
	L3404: (correlation_[i][j]*,r) 
	L3405: (relativeDefaultVariance_[i]*,r) 
	L3406: (relativeDefaultVariance_[j],r) 
	L3407: (sectorEl_[j],r) 
	}
 }
array table
-----------------------------------------------
relativeDefaultVariance_ -> [('[i]', 'r', 'normalized', ['i', 'j'], 3402), ('[i]', 'r', 'normalized', ['i', 'j'], 3405), ('[j]', 'r', 'normalized', ['i', 'j'], 3406)]
LDEs formed:0

sectorSpecTerms_ -> [('[i]', 'w', 'normalized', ['i', 'j'], 3402), ('[i]', 'w', 'normalized', ['i', 'j'], 3403)]
LDEs formed:3

sectorEl_ -> [('[i]', 'r', 'normalized', ['i', 'j'], 3402), ('[j]', 'r', 'normalized', ['i', 'j'], 3407)]
LDEs formed:0

correlation_ -> [('[i][j]', 'r', 'normalized', ['i', 'j'], 3404)]
LDEs formed:0

distinct LDEs:
i1=i2
#########################################################################################
loop info: Size i = 0  i < n_  ++i
induction variable: ['i']
{
L3405: (sectorUl_[i]=,w) 
L3406: (relativeDefaultVariance_[i]*,r) (sectorEl_[i]*,r) (sectorEl_[i],r) 
L3407: (sectorUl_[i],r) 
	loop info: Size j = 0  j < n_  ++j
	induction variable: ['i', 'j']
	{
	L3408: (correlation_[i][j]*,r) 
	L3409: (relativeDefaultVariance_[i]*,r) 
	L3410: (relativeDefaultVariance_[j],r) 
	L3411: (sectorEl_[i]*,r) (sectorEl_[j],r) 
	}
 }
array table
-----------------------------------------------
relativeDefaultVariance_ -> [('[i]', 'r', 'normalized', ['i', 'j'], 3406), ('[i]', 'r', 'normalized', ['i', 'j'], 3409), ('[j]', 'r', 'normalized', ['i', 'j'], 3410)]
LDEs formed:0

correlation_ -> [('[i][j]', 'r', 'normalized', ['i', 'j'], 3408)]
LDEs formed:0

sectorUl_ -> [('[i]', 'w', 'normalized', ['i', 'j'], 3405), ('[i]', 'r', 'normalized', ['i', 'j'], 3407)]
LDEs formed:2

sectorEl_ -> [('[i]', 'r', 'normalized', ['i', 'j'], 3406), ('[i]', 'r', 'normalized', ['i', 'j'], 3406), ('[i]', 'r', 'normalized', ['i', 'j'], 3411), ('[j]', 'r', 'normalized', ['i', 'j'], 3411)]
LDEs formed:0

distinct LDEs:
i1=i2
#########################################################################################
loop info: Size k = 0  k < m_  ++k
induction variable: ['k']
{
L3412: (pd_[k]*,r) (exposure_[k]*,r) (exposure_[k],r) 
L3413: (sector_[k],r) 
}
array table
-----------------------------------------------
pd_ -> [('[k]', 'r', 'normalized', ['k'], 3412)]
LDEs formed:0

sector_ -> [('[k]', 'r', 'normalized', ['k'], 3413)]
LDEs formed:0

exposure_ -> [('[k]', 'r', 'normalized', ['k'], 3412), ('[k]', 'r', 'normalized', ['k'], 3412)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size k = 0  k < m_  ++k
induction variable: ['k']
{
L3413: (marginalLoss_[k]=,w) (pd_[k]*,r) (exposure_[k]/,r) 
L3414: (sector_[k],r) (exposure_[k],r) 
}
array table
-----------------------------------------------
pd_ -> [('[k]', 'r', 'normalized', ['k'], 3413)]
LDEs formed:0

sector_ -> [('[k]', 'r', 'normalized', ['k'], 3414)]
LDEs formed:0

exposure_ -> [('[k]', 'r', 'normalized', ['k'], 3413), ('[k]', 'r', 'normalized', ['k'], 3414)]
LDEs formed:0

marginalLoss_ -> [('[k]', 'w', 'normalized', ['k'], 3413)]
LDEs formed:1

distinct LDEs:
k1=k2
#########################################################################################
loop info: unsigned long n = 0  n < upperIndex_ - 1  ++n
induction variable: ['n']
{
L3414: (loss_[n - j]*,r) 
L3415: (loss_[n - j],r) 
}
array table
-----------------------------------------------
loss_ -> [('[n - j]', 'r', 'not normalized', ['n'], 3414), ('[n - j]', 'r', 'not normalized', ['n'], 3415)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/experimental/volatility/extendedblackvariancesurface.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size j=1  j<=dates.size()  j++
induction variable: ['j']
{
L3416: (times_[j]=,w) (dates[j-1],r) 
L3417: (times_[j],r) (times_[j-1],r) 
}
array table
-----------------------------------------------
dates -> [('[j-1]', 'r', 'normalized', ['j'], 3416)]
LDEs formed:0

times_ -> [('[j]', 'w', 'normalized', ['j'], 3416), ('[j]', 'r', 'normalized', ['j'], 3417), ('[j-1]', 'r', 'normalized', ['j'], 3417)]
LDEs formed:3

distinct LDEs:
j1=j2
j1=j2-1
#########################################################################################
loop info: Size i=0  i<times_.size()+1  i++
induction variable: ['i']
{
L3418: (variances_[0][i]=,w) 
}
array table
-----------------------------------------------
variances_ -> [('[0][i]', 'w', 'normalized', ['i'], 3418)]
LDEs formed:2

distinct LDEs:
0=0,i1=i2
#########################################################################################
loop info: Size j=1  j<=times_.size()  j++
induction variable: ['j']
{
	loop info: Size i=0  i<strikes_.size()  i++
	induction variable: ['j', 'i']
	{
	L3419: (volatilities_[i*times_.size()+j-1]-,r) 
	L3420: (variances_[i][j]=,w) (times_[j]*,r) 
	L3421: (variances_[i][j],r) (variances_[i][j-1],r) 
	}
 }
array table
-----------------------------------------------
times_ -> [('[j]', 'r', 'normalized', ['j', 'i'], 3420)]
LDEs formed:0

volatilities_ -> [('[i*times_.size()+j-1]', 'r', 'not normalized', ['j', 'i'], 3419)]
LDEs formed:0

variances_ -> [('[i][j]', 'w', 'normalized', ['j', 'i'], 3420), ('[i][j]', 'r', 'normalized', ['j', 'i'], 3421), ('[i][j-1]', 'r', 'normalized', ['j', 'i'], 3421)]
LDEs formed:6

distinct LDEs:
i1=i2,j1=j2-1
i1=i2,j1=j2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/experimental/volatility/sviinterpolatedsmilesection.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i = 0  i < volHandles_.size()  ++i
induction variable: ['i']
{
L3422: (volHandles_[i]-,r) 
L3423: (strikes_[i],r) 
L3424: (volHandles_[i]-,r) 
L3425: (strikes_[i],r) 
L3426: (volHandles_[i]-,r) 
}
array table
-----------------------------------------------
volHandles_ -> [('[i]', 'r', 'normalized', ['i'], 3422), ('[i]', 'r', 'normalized', ['i'], 3424), ('[i]', 'r', 'normalized', ['i'], 3426)]
LDEs formed:0

strikes_ -> [('[i]', 'r', 'normalized', ['i'], 3423), ('[i]', 'r', 'normalized', ['i'], 3425)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/experimental/volatility/noarbsabr.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: int iTau = -1  iTau <= 0  ++iTau
induction variable: ['iTau']
{
	loop info: int iSigma = -1  iSigma <= 0  ++iSigma
	induction variable: ['iTau', 'iSigma']
	{
		loop info: int iRho = -1  iRho <= 0  ++iRho
		induction variable: ['iTau', 'iSigma', 'iRho']
		{
			loop info: int iNu = -1  iNu <= 0  ++iNu
			induction variable: ['iTau', 'iSigma', 'iRho', 'iNu']
			{
				loop info: int iBeta = -1  iBeta <= 0  ++iBeta
				induction variable: ['iTau', 'iSigma', 'iRho', 'iNu', 'iBeta']
				{
				L3426: (sabrabsprob[ind]/,r) 
				}
 			}
 		}
 	}
 }
array table
-----------------------------------------------
sabrabsprob -> [('[ind]', 'r', 'not normalized', ['iTau', 'iSigma', 'iRho', 'iNu', 'iBeta'], 3426)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/experimental/volatility/abcdatmvolcurve.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<nOptionTenors_  ++i
induction variable: ['i']
{
L3427: (optionDates_[i]=,w) (optionTenors_[i],r) 
L3428: (optionTimes_[i]=,w) (optionDates_[i],r) 
}
array table
-----------------------------------------------
optionTenors_ -> [('[i]', 'r', 'normalized', ['i'], 3427)]
LDEs formed:0

optionDates_ -> [('[i]', 'w', 'normalized', ['i'], 3427), ('[i]', 'r', 'normalized', ['i'], 3428)]
LDEs formed:2

optionTimes_ -> [('[i]', 'w', 'normalized', ['i'], 3428)]
LDEs formed:1

distinct LDEs:
i1=i2
#########################################################################################
loop info: Size i=0  i<nOptionTenors_  ++i
induction variable: ['i']
{
L3429: (inclusionInInterpolation_[i]==,r) 
L3430: (optionTimes_[i],r) 
L3431: (optionTenors_[i],r) 
}
array table
-----------------------------------------------
optionTenors_ -> [('[i]', 'r', 'normalized', ['i'], 3431)]
LDEs formed:0

optionTimes_ -> [('[i]', 'r', 'normalized', ['i'], 3430)]
LDEs formed:0

inclusionInInterpolation_ -> [('[i]', 'r', 'normalized', ['i'], 3429)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<nOptionTenors_  ++i
induction variable: ['i']
{
L3430: (vols_[i]=,w) (volHandles_[i]-,r) 
L3431: (inclusionInInterpolation_[i]==,r) 
L3432: (vols_[i],r) 
}
array table
-----------------------------------------------
volHandles_ -> [('[i]', 'r', 'normalized', ['i'], 3430)]
LDEs formed:0

inclusionInInterpolation_ -> [('[i]', 'r', 'normalized', ['i'], 3431)]
LDEs formed:0

vols_ -> [('[i]', 'w', 'normalized', ['i'], 3430), ('[i]', 'r', 'normalized', ['i'], 3432)]
LDEs formed:2

distinct LDEs:
i1=i2
#########################################################################################
loop info: Size i=0  i<vols_.size()  ++i
induction variable: ['i']
{
L3433: (vols_[i]=,w) (volHandles_[i]-,r) 
L3434: (inclusionInInterpolation_[i]==,r) 
L3435: (vols_[i],r) 
}
array table
-----------------------------------------------
volHandles_ -> [('[i]', 'r', 'normalized', ['i'], 3433)]
LDEs formed:0

inclusionInInterpolation_ -> [('[i]', 'r', 'normalized', ['i'], 3434)]
LDEs formed:0

vols_ -> [('[i]', 'w', 'normalized', ['i'], 3433), ('[i]', 'r', 'normalized', ['i'], 3435)]
LDEs formed:2

distinct LDEs:
i1=i2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/experimental/volatility/zabr.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size m = 0  m < y.size()  m++
induction variable: ['m']
{
L3436: (y[m]*,r) (y[m]-,r) 
L3437: (y[m],r) 
L3438: (result[y.size() - 1 - m]=,w) 
L3439: (y[m]-,r) 
}
array table
-----------------------------------------------
y -> [('[m]', 'r', 'normalized', ['m'], 3436), ('[m]', 'r', 'normalized', ['m'], 3436), ('[m]', 'r', 'normalized', ['m'], 3437), ('[m]', 'r', 'normalized', ['m'], 3439)]
LDEs formed:0

result -> [('[y.size() - 1 - m]', 'w', 'not normalized', ['m'], 3438)]
LDEs formed:1

distinct LDEs:
y.size() - 1 - m1=y.size() - 1 - m2
#########################################################################################
loop info: int dir = 1  dir >= -1  dir -= 2
induction variable: ['dir']
{
L3439: (y[m],r) 
L3440: (result[y.size() - 1 - m]=,w) 
L3441: (y[m],r) 
}
array table
-----------------------------------------------
y -> [('[m]', 'r', 'not normalized', ['dir'], 3439), ('[m]', 'r', 'not normalized', ['dir'], 3441)]
LDEs formed:0

result -> [('[y.size() - 1 - m]', 'w', 'not normalized', ['dir'], 3440)]
LDEs formed:1

distinct LDEs:
y.size() - 1 - m=y.size() - 1 - m
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/experimental/volatility/noarbsabrinterpolatedsmilesection.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<volHandles_.size()  ++i
induction variable: ['i']
{
L3441: (volHandles_[i]-,r) 
L3442: (strikes_[i],r) 
L3443: (volHandles_[i]-,r) 
L3444: (strikes_[i],r) 
L3445: (volHandles_[i]-,r) 
}
array table
-----------------------------------------------
volHandles_ -> [('[i]', 'r', 'normalized', ['i'], 3441), ('[i]', 'r', 'normalized', ['i'], 3443), ('[i]', 'r', 'normalized', ['i'], 3445)]
LDEs formed:0

strikes_ -> [('[i]', 'r', 'normalized', ['i'], 3442), ('[i]', 'r', 'normalized', ['i'], 3444)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/experimental/volatility/volcube.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<surfaces_.size()  ++i
induction variable: ['i']
{
L3445: (surfaces_[i]-,r) 
L3446: (surfaces_[i],r) 
}
array table
-----------------------------------------------
surfaces_ -> [('[i]', 'r', 'normalized', ['i'], 3445), ('[i]', 'r', 'normalized', ['i'], 3446)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<curves_.size()  ++i
induction variable: ['i']
{
L3447: (curves_[i]-,r) 
}
array table
-----------------------------------------------
curves_ -> [('[i]', 'r', 'normalized', ['i'], 3447)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/experimental/volatility/extendedblackvariancecurve.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size j=1  j<=dates.size()  ++j
induction variable: ['j']
{
L3448: (times_[j]=,w) (dates[j-1],r) 
L3449: (times_[j],r) (times_[j-1],r) 
}
array table
-----------------------------------------------
dates -> [('[j-1]', 'r', 'normalized', ['j'], 3448)]
LDEs formed:0

times_ -> [('[j]', 'w', 'normalized', ['j'], 3448), ('[j]', 'r', 'normalized', ['j'], 3449), ('[j-1]', 'r', 'normalized', ['j'], 3449)]
LDEs formed:3

distinct LDEs:
j1=j2
j1=j2-1
#########################################################################################
loop info: Size j=1  j<=volatilities_.size()  j++
induction variable: ['j']
{
L3450: (volatilities_[j-1]-,r) 
L3451: (variances_[j]=,w) (times_[j]*,r) 
L3452: (variances_[j],r) (variances_[j-1],r) 
}
array table
-----------------------------------------------
times_ -> [('[j]', 'r', 'normalized', ['j'], 3451)]
LDEs formed:0

volatilities_ -> [('[j-1]', 'r', 'normalized', ['j'], 3450)]
LDEs formed:0

variances_ -> [('[j]', 'w', 'normalized', ['j'], 3451), ('[j]', 'r', 'normalized', ['j'], 3452), ('[j-1]', 'r', 'normalized', ['j'], 3452)]
LDEs formed:3

distinct LDEs:
j1=j2
j1=j2-1
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/experimental/volatility/sabrvolsurface.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<optionTenors_.size()  ++i
induction variable: ['i']
{
L3453: (optionDates_[i]=,w) (optionTenors_[i],r) 
L3454: (optionTimes_[i]=,w) (optionDates_[i],r) 
L3455: (sabrGuesses_[i][0]=,w) 
L3456: (sabrGuesses_[i][1]=,w) 
L3457: (sabrGuesses_[i][2]=,w) 
L3458: (sabrGuesses_[i][3]=,w) 
}
array table
-----------------------------------------------
optionTenors_ -> [('[i]', 'r', 'normalized', ['i'], 3453)]
LDEs formed:0

optionDates_ -> [('[i]', 'w', 'normalized', ['i'], 3453), ('[i]', 'r', 'normalized', ['i'], 3454)]
LDEs formed:2

optionTimes_ -> [('[i]', 'w', 'normalized', ['i'], 3454)]
LDEs formed:1

sabrGuesses_ -> [('[i][0]', 'w', 'normalized', ['i'], 3455), ('[i][1]', 'w', 'normalized', ['i'], 3456), ('[i][2]', 'w', 'normalized', ['i'], 3457), ('[i][3]', 'w', 'normalized', ['i'], 3458)]
LDEs formed:20

distinct LDEs:
i1=i2,2=2
i1=i2,2=3
i1=i2,3=3
i1=i2,0=0
i1=i2,0=1
i1=i2,0=2
i1=i2,0=3
i1=i2
i1=i2,1=1
i1=i2,1=3
i1=i2,1=2
#########################################################################################
loop info: Size i=0  i<nAtmRateSpreads  ++i
induction variable: ['i']
{
	loop info: Size j=0  j<nOptionsTimes  ++j
	induction variable: ['i', 'j']
	{
	L3459: (vols[j]=,w) (volSpreads_[j][i],r) 
	}
L3460: (interpolatedVols[i]=,w) 
}
array table
-----------------------------------------------
interpolatedVols -> [('[i]', 'w', 'normalized', ['i', 'j'], 3460)]
LDEs formed:1

vols -> [('[j]', 'w', 'normalized', ['i', 'j'], 3459)]
LDEs formed:1

volSpreads_ -> [('[j][i]', 'r', 'normalized', ['i', 'j'], 3459)]
LDEs formed:0

distinct LDEs:
j1=j2
i1=i2
#########################################################################################
loop info: Size i=0  i<optionTenors_.size()  ++i
induction variable: ['i']
{
L3460: (optionDates_[i]=,w) (optionTenors_[i],r) 
L3461: (optionTimes_[i]=,w) (optionDates_[i],r) 
}
array table
-----------------------------------------------
optionTenors_ -> [('[i]', 'r', 'normalized', ['i'], 3460)]
LDEs formed:0

optionDates_ -> [('[i]', 'w', 'normalized', ['i'], 3460), ('[i]', 'r', 'normalized', ['i'], 3461)]
LDEs formed:2

optionTimes_ -> [('[i]', 'w', 'normalized', ['i'], 3461)]
LDEs formed:1

distinct LDEs:
i1=i2
#########################################################################################
loop info: Size i=0  i<optionTenors_.size()  ++i
induction variable: ['i']
{
	loop info: Size j=0  j<atmRateSpreads_.size()  ++j
	induction variable: ['i', 'j']
	{
	L3462: (volSpreads_[i][j],r) 
	}
 }
array table
-----------------------------------------------
volSpreads_ -> [('[i][j]', 'r', 'normalized', ['i', 'j'], 3462)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/model.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<instruments_.size()  i++
induction variable: ['i']
{
L3463: (instruments_[i]-,r) 
L3464: (weights_[i],r) 
}
array table
-----------------------------------------------
instruments_ -> [('[i]', 'r', 'normalized', ['i'], 3463)]
LDEs formed:0

weights_ -> [('[i]', 'r', 'normalized', ['i'], 3464)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<instruments_.size()  i++
induction variable: ['i']
{
L3465: (values[i]=,w) (instruments_[i]-,r) 
L3466: (weights_[i],r) 
}
array table
-----------------------------------------------
values -> [('[i]', 'w', 'normalized', ['i'], 3465)]
LDEs formed:1

instruments_ -> [('[i]', 'r', 'normalized', ['i'], 3465)]
LDEs formed:0

weights_ -> [('[i]', 'r', 'normalized', ['i'], 3466)]
LDEs formed:0

distinct LDEs:
i1=i2
#########################################################################################
loop info: i=0  i<arguments_.size()  i++
induction variable: ['i']
{
	loop info: Size j=0  j<arguments_[i].size()  j++, k++
	induction variable: ['i', 'j', 'k']
	{
	L3467: (params[k]=,w) (arguments_[i].params,r) 
	}
 }
array table
-----------------------------------------------
arguments_ -> [('[i]', 'r', 'normalized', ['i', 'j', 'k'], 3467)]
LDEs formed:0

params -> [('[k]', 'w', 'normalized', ['i', 'j', 'k'], 3467)]
LDEs formed:1

distinct LDEs:
k1=k2
#########################################################################################
loop info: Size i=0  i<arguments_.size()  ++i
induction variable: ['i']
{
	loop info: Size j=0  j<arguments_[i].size()  ++j, ++p
	induction variable: ['i', 'j', 'p']
	{
	L3468: (arguments_[i].setParam,r) 
	}
 }
array table
-----------------------------------------------
arguments_ -> [('[i]', 'r', 'normalized', ['i', 'j', 'p'], 3468)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/shortrate/onefactormodel.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<(timeGrid.size() - 1)  i++
induction variable: ['i']
{
L3469: (t_[i+1],r) 
}
array table
-----------------------------------------------
t_ -> [('[i+1]', 'r', 'normalized', ['i'], 3469)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/shortrate/twofactormodels/g2.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<size_  i++
induction variable: ['i']
{
L3470: (A_[i]=,w) (t_[i],r) 
L3471: (Ba_[i]=,w) (t_[i]-,r) 
L3472: (Bb_[i]=,w) (t_[i]-,r) 
}
array table
-----------------------------------------------
Bb_ -> [('[i]', 'w', 'normalized', ['i'], 3472)]
LDEs formed:1

t_ -> [('[i]', 'r', 'normalized', ['i'], 3470), ('[i]', 'r', 'normalized', ['i'], 3471), ('[i]', 'r', 'normalized', ['i'], 3472)]
LDEs formed:0

A_ -> [('[i]', 'w', 'normalized', ['i'], 3470)]
LDEs formed:1

Ba_ -> [('[i]', 'w', 'normalized', ['i'], 3471)]
LDEs formed:1

distinct LDEs:
i1=i2
#########################################################################################
loop info: i=0  i<size_  i++
induction variable: ['i']
{
L3472: (t_[0]-,r) (t_[i]-,r) (t_[i-1],r) 
L3473: (lambda[i]=,w) (A_[i]*,r) (Ba_[i]*,r) 
}
array table
-----------------------------------------------
Ba_ -> [('[i]', 'r', 'normalized', ['i'], 3473)]
LDEs formed:0

t_ -> [('[0]', 'r', 'normalized', ['i'], 3472), ('[i]', 'r', 'normalized', ['i'], 3472), ('[i-1]', 'r', 'normalized', ['i'], 3472)]
LDEs formed:0

A_ -> [('[i]', 'r', 'normalized', ['i'], 3473)]
LDEs formed:0

lambda -> [('[i]', 'w', 'normalized', ['i'], 3473)]
LDEs formed:1

distinct LDEs:
i1=i2
#########################################################################################
loop info: i=0  i<size_  i++
induction variable: ['i']
{
L3474: (Bb_[i]*,r) 
L3475: (Bb_[i]*,r) 
L3476: (Bb_[i]+,r) 
L3477: (lambda[i]*,r) 
}
array table
-----------------------------------------------
Bb_ -> [('[i]', 'r', 'normalized', ['i'], 3474), ('[i]', 'r', 'normalized', ['i'], 3475), ('[i]', 'r', 'normalized', ['i'], 3476)]
LDEs formed:0

lambda -> [('[i]', 'r', 'normalized', ['i'], 3477)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<lambda_.size()  i++
induction variable: ['i']
{
L3478: (lambda_[i]*,r) (Bb_[i]*,r) 
}
array table
-----------------------------------------------
Bb_ -> [('[i]', 'r', 'normalized', ['i'], 3478)]
LDEs formed:0

lambda_ -> [('[i]', 'r', 'normalized', ['i'], 3478)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/shortrate/onefactormodels/hullwhite.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<(grid.size() - 1)  i++
induction variable: ['i']
{
L3479: (grid[i+1],r) 
	loop info: Size j=0  j<size  j++
	induction variable: ['i', 'j']
	{
	L3480: (statePrices[j]*,r) 
	}
L3481: (grid[i],r) 
}
array table
-----------------------------------------------
statePrices -> [('[j]', 'r', 'normalized', ['i', 'j'], 3480)]
LDEs formed:0

grid -> [('[i+1]', 'r', 'normalized', ['i', 'j'], 3479), ('[i]', 'r', 'normalized', ['i', 'j'], 3481)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/shortrate/onefactormodels/gsr.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i = 0  i < sigma_.size()  i++
induction variable: ['i']
{
L3482: (volatilities_[i]-,r) 
}
array table
-----------------------------------------------
volatilities_ -> [('[i]', 'r', 'normalized', ['i'], 3482)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i = 0  i < reversion_.size()  i++
induction variable: ['i']
{
L3483: (reversions_[i]-,r) 
}
array table
-----------------------------------------------
reversions_ -> [('[i]', 'r', 'normalized', ['i'], 3483)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i = 0  i < sigma_.size()  i++
induction variable: ['i']
{
L3484: (volatilities_[i]-,r) 
}
array table
-----------------------------------------------
volatilities_ -> [('[i]', 'r', 'normalized', ['i'], 3484)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i = 0  i < reversion_.size()  i++
induction variable: ['i']
{
L3485: (reversions_[i]-,r) 
}
array table
-----------------------------------------------
reversions_ -> [('[i]', 'r', 'normalized', ['i'], 3485)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/shortrate/onefactormodels/blackkarasinski.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size j=0  j<size_  j++
induction variable: ['j']
{
L3486: (statePrices_[j]*,r) 
}
array table
-----------------------------------------------
statePrices_ -> [('[j]', 'r', 'normalized', ['j'], 3486)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<(grid.size() - 1)  i++
induction variable: ['i']
{
L3487: (grid[i+1],r) 
L3488: (grid[i],r) 
}
array table
-----------------------------------------------
grid -> [('[i+1]', 'r', 'normalized', ['i'], 3487), ('[i]', 'r', 'normalized', ['i'], 3488)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/shortrate/onefactormodels/gaussian1dmodel.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i = 1  i < floatSched.size()  i++
induction variable: ['i']
{
L3489: (floatSched[i - 1],r) 
L3490: (floatSched[i],r) 
L3491: (floatSched[i],r) 
}
array table
-----------------------------------------------
floatSched -> [('[i - 1]', 'r', 'normalized', ['i'], 3489), ('[i]', 'r', 'normalized', ['i'], 3490), ('[i]', 'r', 'normalized', ['i'], 3491)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i = 0  i < yg.size()  i++
induction variable: ['i']
{
L3492: (yg[i],r) 
L3493: (yg[i],r) 
L3494: (p[i]=,w) 
L3495: (yg[i],r) 
}
array table
-----------------------------------------------
p -> [('[i]', 'w', 'normalized', ['i'], 3494)]
LDEs formed:1

yg -> [('[i]', 'r', 'normalized', ['i'], 3492), ('[i]', 'r', 'normalized', ['i'], 3493), ('[i]', 'r', 'normalized', ['i'], 3495)]
LDEs formed:0

distinct LDEs:
i1=i2
#########################################################################################
loop info: Size i = 0  i < z.size() - 1  i++
induction variable: ['i']
{
L3496: (p[i],r) (z[i],r) (z[i],r) (z[i + 1],r) 
}
array table
-----------------------------------------------
p -> [('[i]', 'r', 'normalized', ['i'], 3496)]
LDEs formed:0

z -> [('[i]', 'r', 'normalized', ['i'], 3496), ('[i]', 'r', 'normalized', ['i'], 3496), ('[i + 1]', 'r', 'normalized', ['i'], 3496)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: int j = -gridPoints  j <= gridPoints  j++
induction variable: ['j']
{
L3497: (result[j + gridPoints]=,w) 
}
array table
-----------------------------------------------
result -> [('[j + gridPoints]', 'w', 'not normalized', ['j'], 3497)]
LDEs formed:1

distinct LDEs:
j1 + gridPoints=j2 + gridPoints
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/shortrate/onefactormodels/markovfunctional.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i = 0  i < normalIntegralX_.size()  i++
induction variable: ['i']
{
L3498: (normalIntegralW_[i]*=,w) 
L3499: (normalIntegralX_[i]*,r) (normalIntegralX_[i],r) 
L3500: (normalIntegralX_[i]*=,w) 
}
array table
-----------------------------------------------
normalIntegralX_ -> [('[i]', 'r', 'normalized', ['i'], 3499), ('[i]', 'r', 'normalized', ['i'], 3499), ('[i]', 'w', 'normalized', ['i'], 3500)]
LDEs formed:3

normalIntegralW_ -> [('[i]', 'w', 'normalized', ['i'], 3498)]
LDEs formed:1

distinct LDEs:
i1=i2
#########################################################################################
loop info: Size i = 0  i < sigma_.size()  i++
induction variable: ['i']
{
L3499: (volatilities_[i],r) 
}
array table
-----------------------------------------------
volatilities_ -> [('[i]', 'r', 'normalized', ['i'], 3499)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size j = 0  j < k.size()  j++
induction variable: ['j']
{
L3500: (k[j],r) 
}
array table
-----------------------------------------------
k -> [('[j]', 'r', 'normalized', ['j'], 3500)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: unsigned int k = 0  k < i->second.paymentDates_.size()  k++
induction variable: ['k']
{
L3501: (second.paymentDates_[k],r) 
L3502: (times_[idx],r) 
L3503: (second.yearFractions_[k],r) 
}
array table
-----------------------------------------------
second.yearFractions_ -> [('[k]', 'r', 'normalized', ['k'], 3503)]
LDEs formed:0

second.paymentDates_ -> [('[k]', 'r', 'normalized', ['k'], 3501)]
LDEs formed:0

times_ -> [('[idx]', 'r', 'not normalized', ['k'], 3502)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: int j = y_.size() - 1  j >= 0  j--
induction variable: ['j']
{
L3503: (discreteDeflatedAnnuities[j - 1],r) (y_[j - 1],r) 
L3504: (y_[j],r) 
L3505: (discreteDeflatedAnnuities[j - 1],r) (y_[j - 1],r) 
L3506: (y_[j],r) 
L3507: (discreteDeflatedAnnuities[j],r) 
L3508: (y_[j],r) (y_[j],r) (y_[j + 1],r) 
L3509: (times_[idx]<<,r) 
L3510: (y_[j],r) 
L3511: (y_[j + 1]<<,r) 
L3512: (discreteDeflatedAnnuities[j]+,r) 
L3513: (deflatedFinalPayments[j],r) 
}
array table
-----------------------------------------------
discreteDeflatedAnnuities -> [('[j - 1]', 'r', 'normalized', ['j'], 3503), ('[j - 1]', 'r', 'normalized', ['j'], 3505), ('[j]', 'r', 'normalized', ['j'], 3507), ('[j]', 'r', 'normalized', ['j'], 3512)]
LDEs formed:0

deflatedFinalPayments -> [('[j]', 'r', 'normalized', ['j'], 3513)]
LDEs formed:0

y_ -> [('[j - 1]', 'r', 'normalized', ['j'], 3503), ('[j]', 'r', 'normalized', ['j'], 3504), ('[j - 1]', 'r', 'normalized', ['j'], 3505), ('[j]', 'r', 'normalized', ['j'], 3506), ('[j]', 'r', 'normalized', ['j'], 3508), ('[j]', 'r', 'normalized', ['j'], 3508), ('[j + 1]', 'r', 'normalized', ['j'], 3508), ('[j]', 'r', 'normalized', ['j'], 3510), ('[j + 1]', 'r', 'normalized', ['j'], 3511)]
LDEs formed:0

times_ -> [('[idx]', 'r', 'not normalized', ['j'], 3509)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i = 1  i < times_.size() - 1  i++
induction variable: ['i']
{
L3510: (times_[i],r) 
L3511: (times_[i],r) (times_[i],r) 
}
array table
-----------------------------------------------
times_ -> [('[i]', 'r', 'normalized', ['i'], 3510), ('[i]', 'r', 'normalized', ['i'], 3511), ('[i]', 'r', 'normalized', ['i'], 3511)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size j = 0  j < money.size()  j++
induction variable: ['j']
{
L3512: (money[j]*,r) 
L3513: (strikes[j],r) 
L3514: (strikes[j],r) 
L3515: (strikes[j],r) 
L3516: (strikes[j],r) 
L3517: (strikes[j],r) 
L3518: (strikes[j],r) 
L3519: (strikes[j],r) 
L3520: (strikes[j],r) 
L3521: (strikes[j],r) 
}
array table
-----------------------------------------------
money -> [('[j]', 'r', 'normalized', ['j'], 3512)]
LDEs formed:0

strikes -> [('[j]', 'r', 'normalized', ['j'], 3513), ('[j]', 'r', 'normalized', ['j'], 3514), ('[j]', 'r', 'normalized', ['j'], 3515), ('[j]', 'r', 'normalized', ['j'], 3516), ('[j]', 'r', 'normalized', ['j'], 3517), ('[j]', 'r', 'normalized', ['j'], 3518), ('[j]', 'r', 'normalized', ['j'], 3519), ('[j]', 'r', 'normalized', ['j'], 3520), ('[j]', 'r', 'normalized', ['j'], 3521)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size j = 0  j < y.size()  j++
induction variable: ['j']
{
L3522: (y[j],r) 
L3523: (numeraire_[i - 1],r) 
L3524: (numeraire_[i],r) 
L3525: (res[j]=,w) 
}
array table
-----------------------------------------------
y -> [('[j]', 'r', 'normalized', ['j'], 3522)]
LDEs formed:0

numeraire_ -> [('[i - 1]', 'r', 'not normalized', ['j'], 3523), ('[i]', 'r', 'not normalized', ['j'], 3524)]
LDEs formed:0

res -> [('[j]', 'w', 'normalized', ['j'], 3525)]
LDEs formed:1

distinct LDEs:
j1=j2
#########################################################################################
loop info: Size j = 0  j < y.size()  j++
induction variable: ['j']
{
	loop info: Size i = 0  i < modelSettings_.gaussHermitePoints_  i++
	induction variable: ['j', 'i']
	{
	L3526: (ya[i]=,w) (y[j]*,r) (normalIntegralX_[i],r) 
	}
	loop info: Size i = 0  i < modelSettings_.gaussHermitePoints_  i++
	induction variable: ['j', 'i']
	{
	L3527: (result[j]+=,w) (normalIntegralW_[i]/,r) (res[i],r) 
	}
 }
array table
-----------------------------------------------
ya -> [('[i]', 'w', 'normalized', ['j', 'i'], 3526)]
LDEs formed:1

res -> [('[i]', 'r', 'normalized', ['j', 'i'], 3527)]
LDEs formed:0

result -> [('[j]', 'w', 'normalized', ['j', 'i'], 3527)]
LDEs formed:1

normalIntegralW_ -> [('[i]', 'r', 'normalized', ['j', 'i'], 3527)]
LDEs formed:0

y -> [('[j]', 'r', 'normalized', ['j', 'i'], 3526)]
LDEs formed:0

normalIntegralX_ -> [('[i]', 'r', 'normalized', ['j', 'i'], 3526)]
LDEs formed:0

distinct LDEs:
j1=j2
i1=i2
#########################################################################################
loop info: Size i = 0  i < m.expiries_.size()  i++
induction variable: ['i']
{
L3527: (m.expiries_[i]<<,r) (m.tenors_[i]<<,r) (m.atm_[i],r) 
L3528: (m.annuity_[i]<<,r) 
L3529: (m.digitalsAdjustmentFactors_[i]<<,r) 
L3530: (m.adjustmentFactors_[i]<<,r) (m.marketZerorate_[i]<<,r) 
L3531: (m.modelZerorate_[i]<<,r) 
L3532: (m.marketZerorate_[i]-,r) (m.modelZerorate_[i],r) 
}
array table
-----------------------------------------------
m.atm_ -> [('[i]', 'r', 'normalized', ['i'], 3527)]
LDEs formed:0

m.modelZerorate_ -> [('[i]', 'r', 'normalized', ['i'], 3531), ('[i]', 'r', 'normalized', ['i'], 3532)]
LDEs formed:0

m.expiries_ -> [('[i]', 'r', 'normalized', ['i'], 3527)]
LDEs formed:0

m.tenors_ -> [('[i]', 'r', 'normalized', ['i'], 3527)]
LDEs formed:0

m.adjustmentFactors_ -> [('[i]', 'r', 'normalized', ['i'], 3530)]
LDEs formed:0

m.digitalsAdjustmentFactors_ -> [('[i]', 'r', 'normalized', ['i'], 3529)]
LDEs formed:0

m.annuity_ -> [('[i]', 'r', 'normalized', ['i'], 3528)]
LDEs formed:0

m.marketZerorate_ -> [('[i]', 'r', 'normalized', ['i'], 3530), ('[i]', 'r', 'normalized', ['i'], 3532)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i = 0  i < m.expiries_.size()  i++
induction variable: ['i']
{
L3533: (m.expiries_[i]<<,r) (m.tenors_[i],r) 
}
array table
-----------------------------------------------
m.expiries_ -> [('[i]', 'r', 'normalized', ['i'], 3533)]
LDEs formed:0

m.tenors_ -> [('[i]', 'r', 'normalized', ['i'], 3533)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size j = 0  j < m.smileStrikes_[0].size()  j++
induction variable: ['j']
{
	loop info: Size i = 0  i < m.expiries_.size()  i++
	induction variable: ['j', 'i']
	{
	L3534: (m.smileStrikes_[i][j]<<,r) 
	L3535: (m.marketRawCallPremium_[i][j]<<,r) 
	L3536: (m.marketCallPremium_[i][j]<<,r) 
	L3537: (m.modelCallPremium_[i][j]<<,r) 
	L3538: (m.marketRawPutPremium_[i][j]<<,r) 
	L3539: (m.marketPutPremium_[i][j]<<,r) 
	L3540: (m.modelPutPremium_[i][j]<<,r) (m.marketVega_[i][j],r) 
	}
 }
array table
-----------------------------------------------
m.marketVega_ -> [('[i][j]', 'r', 'normalized', ['j', 'i'], 3540)]
LDEs formed:0

m.marketCallPremium_ -> [('[i][j]', 'r', 'normalized', ['j', 'i'], 3536)]
LDEs formed:0

m.smileStrikes_ -> [('[i][j]', 'r', 'normalized', ['j', 'i'], 3534)]
LDEs formed:0

m.modelPutPremium_ -> [('[i][j]', 'r', 'normalized', ['j', 'i'], 3540)]
LDEs formed:0

m.marketRawCallPremium_ -> [('[i][j]', 'r', 'normalized', ['j', 'i'], 3535)]
LDEs formed:0

m.marketPutPremium_ -> [('[i][j]', 'r', 'normalized', ['j', 'i'], 3539)]
LDEs formed:0

m.marketRawPutPremium_ -> [('[i][j]', 'r', 'normalized', ['j', 'i'], 3538)]
LDEs formed:0

m.modelCallPremium_ -> [('[i][j]', 'r', 'normalized', ['j', 'i'], 3537)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i = 0  i < yg.size()  i++
induction variable: ['i']
{
L3538: (yg[i],r) 
L3539: (yg[i],r) 
L3540: (p[i]=,w) 
L3541: (yg[i],r) 
}
array table
-----------------------------------------------
p -> [('[i]', 'w', 'normalized', ['i'], 3540)]
LDEs formed:1

yg -> [('[i]', 'r', 'normalized', ['i'], 3538), ('[i]', 'r', 'normalized', ['i'], 3539), ('[i]', 'r', 'normalized', ['i'], 3541)]
LDEs formed:0

distinct LDEs:
i1=i2
#########################################################################################
loop info: Size i = 0  i < z.size() - 1  i++
induction variable: ['i']
{
L3542: (p[i],r) (z[i],r) (z[i],r) (z[i + 1],r) 
}
array table
-----------------------------------------------
p -> [('[i]', 'r', 'normalized', ['i'], 3542)]
LDEs formed:0

z -> [('[i]', 'r', 'normalized', ['i'], 3542), ('[i]', 'r', 'normalized', ['i'], 3542), ('[i + 1]', 'r', 'normalized', ['i'], 3542)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i = 0  i < yg.size()  i++
induction variable: ['i']
{
L3543: (yg[i],r) 
L3544: (yg[i],r) 
L3545: (p[i]=,w) 
L3546: (yg[i],r) 
}
array table
-----------------------------------------------
p -> [('[i]', 'w', 'normalized', ['i'], 3545)]
LDEs formed:1

yg -> [('[i]', 'r', 'normalized', ['i'], 3543), ('[i]', 'r', 'normalized', ['i'], 3544), ('[i]', 'r', 'normalized', ['i'], 3546)]
LDEs formed:0

distinct LDEs:
i1=i2
#########################################################################################
loop info: Size i = 0  i < z.size() - 1  i++
induction variable: ['i']
{
L3547: (p[i],r) (z[i],r) (z[i],r) (z[i + 1],r) 
}
array table
-----------------------------------------------
p -> [('[i]', 'r', 'normalized', ['i'], 3547)]
LDEs formed:0

z -> [('[i]', 'r', 'normalized', ['i'], 3547), ('[i]', 'r', 'normalized', ['i'], 3547), ('[i + 1]', 'r', 'normalized', ['i'], 3547)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/volatility/garch.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: std::size_t i = 2  i < idx_.size()  ++i
induction variable: ['i']
{
L3548: (target[i]=,w) (idx_[i],r) 
L3549: (fct2fit[i]=,w) (idx_[i]-,r) (fct2fit[1],r) 
}
array table
-----------------------------------------------
fct2fit -> [('[i]', 'w', 'normalized', ['i'], 3549), ('[1]', 'r', 'normalized', ['i'], 3549)]
LDEs formed:2

idx_ -> [('[i]', 'r', 'normalized', ['i'], 3548), ('[i]', 'r', 'normalized', ['i'], 3549)]
LDEs formed:0

target -> [('[i]', 'w', 'normalized', ['i'], 3548)]
LDEs formed:1

distinct LDEs:
i1=1
i1=i2
#########################################################################################
loop info: std::size_t i = 2  i < idx_.size()  ++i
induction variable: ['i']
{
L3549: (target[i]=,w) (idx_[i],r) 
L3550: (idx_[i]-,r) 
L3551: (fct2fit[i]=,w) (fct2fit[1],r) 
L3552: (grad_fct2fit[i][0]=,w) (idx_[i]-,r) (fct2fit[1]+,r) (grad_fct2fit[1][0],r) 
L3553: (grad_fct2fit[i][1]=,w) (grad_fct2fit[1][1],r) 
}
array table
-----------------------------------------------
fct2fit -> [('[i]', 'w', 'normalized', ['i'], 3551), ('[1]', 'r', 'normalized', ['i'], 3551), ('[1]', 'r', 'normalized', ['i'], 3552)]
LDEs formed:3

idx_ -> [('[i]', 'r', 'normalized', ['i'], 3549), ('[i]', 'r', 'normalized', ['i'], 3550), ('[i]', 'r', 'normalized', ['i'], 3552)]
LDEs formed:0

target -> [('[i]', 'w', 'normalized', ['i'], 3549)]
LDEs formed:1

grad_fct2fit -> [('[i][0]', 'w', 'normalized', ['i'], 3552), ('[1][0]', 'r', 'normalized', ['i'], 3552), ('[i][1]', 'w', 'normalized', ['i'], 3553), ('[1][1]', 'r', 'normalized', ['i'], 3553)]
LDEs formed:14

distinct LDEs:
1=i2,0=1
i1=1,0=1
i1=1,0=0
i1=1,1=1
i1=i2,0=0
i1=i2,0=1
i1=i2
i1=i2,1=1
i1=1
#########################################################################################
loop info: std::size_t i = 0  i <= nCov  ++i
induction variable: ['i']
{
L3554: (acf[i],r) (acf[i-1],r) (acf[i-1],r) (acf[i],r) 
}
array table
-----------------------------------------------
acf -> [('[i]', 'r', 'normalized', ['i'], 3554), ('[i-1]', 'r', 'normalized', ['i'], 3554), ('[i-1]', 'r', 'normalized', ['i'], 3554), ('[i]', 'r', 'normalized', ['i'], 3554)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: std::size_t i = 0  i <= nCov  ++i
induction variable: ['i']
{
L3555: (acf[i],r) (acf[i-1],r) (acf[i-1],r) (acf[i],r) 
L3556: (acf[i]/,r) (acf[i-1],r) 
}
array table
-----------------------------------------------
acf -> [('[i]', 'r', 'normalized', ['i'], 3555), ('[i-1]', 'r', 'normalized', ['i'], 3555), ('[i-1]', 'r', 'normalized', ['i'], 3555), ('[i]', 'r', 'normalized', ['i'], 3555), ('[i]', 'r', 'normalized', ['i'], 3556), ('[i-1]', 'r', 'normalized', ['i'], 3556)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/volatility/constantestimator.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=size_  i < volatilitySeries.size()  i++
induction variable: ['i']
{
	loop info: j=i-size_  j <i  j++
	induction variable: ['i', 'j']
	{
	L3557: (u[j],r) 
	L3558: (u[j]*,r) (u[j],r) 
	}
L3559: (retval[cur->first]=,w) 
}
array table
-----------------------------------------------
retval -> [('[cur->first]', 'w', 'not normalized', ['i', 'j'], 3559)]
LDEs formed:1

u -> [('[j]', 'r', 'normalized', ['i', 'j'], 3557), ('[j]', 'r', 'normalized', ['i', 'j'], 3558), ('[j]', 'r', 'normalized', ['i', 'j'], 3558)]
LDEs formed:0

distinct LDEs:
cur->first=cur->first
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/marketmodeldifferences.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<totalCovariance1.columns()  ++i
induction variable: ['i']
{
L3559: (totalCovariance1[i][i]-,r) (totalCovariance2[i][i],r) 
L3560: (result[i]=,w) (maturities[i],r) 
}
array table
-----------------------------------------------
maturities -> [('[i]', 'r', 'normalized', ['i'], 3560)]
LDEs formed:0

totalCovariance2 -> [('[i][i]', 'r', 'normalized', ['i'], 3559)]
LDEs formed:0

totalCovariance1 -> [('[i][i]', 'r', 'normalized', ['i'], 3559)]
LDEs formed:0

result -> [('[i]', 'w', 'normalized', ['i'], 3560)]
LDEs formed:1

distinct LDEs:
i1=i2
#########################################################################################
loop info: Size i=0  i<evolutionTimes.size()  ++i
induction variable: ['i']
{
L3561: (evolutionTimes[i],r) 
L3562: (covariance1[index][index]-,r) (covariance2[index][index],r) 
L3563: (result[i]=,w) 
}
array table
-----------------------------------------------
result -> [('[i]', 'w', 'normalized', ['i'], 3563)]
LDEs formed:1

covariance2 -> [('[index][index]', 'r', 'not normalized', ['i'], 3562)]
LDEs formed:0

evolutionTimes -> [('[i]', 'r', 'normalized', ['i'], 3561)]
LDEs formed:0

covariance1 -> [('[index][index]', 'r', 'not normalized', ['i'], 3562)]
LDEs formed:0

distinct LDEs:
i1=i2
#########################################################################################
loop info: Size i=1  i<rateTimes.size()  ++i
induction variable: ['i']
{
L3563: (rateTimes[i]-,r) (rateTimes[i-1],r) 
	loop info: Size j=0  j<correlations.rows()  ++j
	induction variable: ['i', 'j']
	{
	L3564: (piecewiseConstantVariances[j]-,r) 
	}
 }
array table
-----------------------------------------------
rateTimes -> [('[i]', 'r', 'normalized', ['i', 'j'], 3563), ('[i-1]', 'r', 'normalized', ['i', 'j'], 3563)]
LDEs formed:0

piecewiseConstantVariances -> [('[j]', 'r', 'normalized', ['i', 'j'], 3564)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/utilities.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<times.size()  i++
induction variable: ['i']
{
L3565: (times[i].begin,r) 
L3566: (times[i].end,r) 
}
array table
-----------------------------------------------
times -> [('[i]', 'r', 'normalized', ['i'], 3565), ('[i]', 'r', 'normalized', ['i'], 3566)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<times.size()  i++
induction variable: ['i']
{
L3567: (isPresent[i].resize,r) 
	loop info: Size j=0  j<allTimes.size()  j++
	induction variable: ['i', 'j']
	{
	L3568: (isPresent[i][j]=,w) (times[i].begin,r) 
	L3569: (times[i].end,r) 
	L3570: (allTimes[j],r) 
	}
 }
array table
-----------------------------------------------
isPresent -> [('[i]', 'r', 'normalized', ['i', 'j'], 3567), ('[i][j]', 'w', 'normalized', ['i', 'j'], 3568)]
LDEs formed:4

allTimes -> [('[j]', 'r', 'normalized', ['i', 'j'], 3570)]
LDEs formed:0

times -> [('[i]', 'r', 'normalized', ['i', 'j'], 3568), ('[i]', 'r', 'normalized', ['i', 'j'], 3569)]
LDEs formed:0

distinct LDEs:
i1=i2,j1=j2
i1=i2
#########################################################################################
loop info: Size i=0  i<dimSet  ++i
induction variable: ['i']
{
L3570: (set[i],r) 
	loop info:   
	induction variable: ['i']
	{
	L3571: (subset[j],r) 
	L3572: (result[i]=,w) 
	L3573: (result[i],r) 
	L3574: (result[i]=,w) 
	}
 }
array table
-----------------------------------------------
subset -> [('[j]', 'r', 'not normalized', ['i'], 3571)]
LDEs formed:0

set -> [('[i]', 'r', 'normalized', ['i'], 3570)]
LDEs formed:0

result -> [('[i]', 'w', 'normalized', ['i'], 3572), ('[i]', 'r', 'normalized', ['i'], 3573), ('[i]', 'w', 'normalized', ['i'], 3574)]
LDEs formed:5

distinct LDEs:
i1=i2
#########################################################################################
loop info: Size i=0  i<nTimes-1  ++i
induction variable: ['i']
{
L3575: (taus[i]=,w) (times[i+1]-,r) (times[i],r) 
L3576: (taus[i],r) 
L3577: (times[" << i   << "]=,w) (times[i]<<,r) 
L3578: (times[" << i+1 << "]=,w) (times[i+1],r) 
}
array table
-----------------------------------------------
taus -> [('[i]', 'w', 'normalized', ['i'], 3575), ('[i]', 'r', 'normalized', ['i'], 3576)]
LDEs formed:2

times -> [('[i+1]', 'r', 'normalized', ['i'], 3575), ('[i]', 'r', 'normalized', ['i'], 3575), ('[" << i   << "]', 'w', 'normalized', ['i'], 3577), ('[i]', 'r', 'normalized', ['i'], 3577), ('[" << i+1 << "]', 'w', 'normalized', ['i'], 3578), ('[i+1]', 'r', 'normalized', ['i'], 3578)]
LDEs formed:11

distinct LDEs:
i1=" << i2+1 << "
i1+1=" << i2+1 << "
" << i1+1 << "=" << i2+1 << "
i1+1=" << i2   << "
" << i1   << "=" << i2   << "
i1=i2
" << i1   << "=" << i2+1 << "
i1=" << i2   << "
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/marketmodel.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size j=0  j<numberOfSteps()  ++j
induction variable: ['j']
{
L3579: (evolutionTime[j]-,r) 
L3580: (result[j]=,w) 
L3581: (evolutionTime[j],r) 
}
array table
-----------------------------------------------
evolutionTime -> [('[j]', 'r', 'normalized', ['j'], 3579), ('[j]', 'r', 'normalized', ['j'], 3581)]
LDEs formed:0

result -> [('[j]', 'w', 'normalized', ['j'], 3580)]
LDEs formed:1

distinct LDEs:
j1=j2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/forwardforwardmappings.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size l=0  l < k  ++l
induction variable: ['l']
{
	loop info: Size r=0  r < multiplier  ++r, ++m
	induction variable: ['l', 'r', 'm']
	{
	L3581: (tau[m]*,r) 
	L3582: (jacobian[l][m]=,w) 
	}
 }
array table
-----------------------------------------------
tau -> [('[m]', 'r', 'normalized', ['l', 'r', 'm'], 3581)]
LDEs formed:0

jacobian -> [('[l][m]', 'w', 'normalized', ['l', 'r', 'm'], 3582)]
LDEs formed:2

distinct LDEs:
l1=l2,m1=m2
#########################################################################################
loop info: Size i=0  i < k   ++i
induction variable: ['i']
{
L3583: (longDisplacements[i],r) 
	loop info: Size j=0  j < n  ++j
	induction variable: ['i', 'j']
	{
	L3584: (shortDisplacements[j],r) 
	L3585: (jacobian[i][j]*=,w) 
	}
 }
array table
-----------------------------------------------
shortDisplacements -> [('[j]', 'r', 'normalized', ['i', 'j'], 3584)]
LDEs formed:0

jacobian -> [('[i][j]', 'w', 'normalized', ['i', 'j'], 3585)]
LDEs formed:2

longDisplacements -> [('[i]', 'r', 'normalized', ['i', 'j'], 3583)]
LDEs formed:0

distinct LDEs:
i1=i2,j1=j2
#########################################################################################
loop info: Size i=0  i < k+1  ++i
induction variable: ['i']
{
L3584: (times[i]=,w) 
L3585: (discRatios[i]=,w) 
}
array table
-----------------------------------------------
discRatios -> [('[i]', 'w', 'normalized', ['i'], 3585)]
LDEs formed:1

times -> [('[i]', 'w', 'normalized', ['i'], 3584)]
LDEs formed:1

distinct LDEs:
i1=i2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/pathwiseaccountingengine.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<numberProducts_  ++i
induction variable: ['i']
{
L3585: (cashFlowsGenerated_[i].resize,r) 
	loop info: Size j=0  j < cashFlowsGenerated_[i].size()  ++j
	induction variable: ['i', 'j']
	{
	}
L3586: (numberCashFlowsThisIndex_[i].resize,r) 
}
array table
-----------------------------------------------
cashFlowsGenerated_ -> [('[i]', 'r', 'normalized', ['i', 'j'], 3585)]
LDEs formed:0

numberCashFlowsThisIndex_ -> [('[i]', 'r', 'normalized', ['i', 'j'], 3586)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i < numberCashFlowTimes_  ++i
induction variable: ['i']
{
L3587: (cashFlowTimes[i],r) 
L3588: (cashFlowIndicesThisStep_[index].push_back,r) 
}
array table
-----------------------------------------------
cashFlowTimes -> [('[i]', 'r', 'normalized', ['i'], 3587)]
LDEs formed:0

cashFlowIndicesThisStep_ -> [('[index]', 'r', 'not normalized', ['i'], 3588)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i < numberProducts_  ++i
induction variable: ['i']
{
L3589: (numerairesHeld_[i]=,w) 
	loop info: Size j=0  j < numberCashFlowTimes_  ++j
	induction variable: ['i', 'j']
	{
	L3590: (numberCashFlowsThisIndex_[i][j]=,w) 
		loop info: Size k=0  k <= numberRates_  ++k
		induction variable: ['i', 'j', 'k']
		{
		}
 	}
	loop info: Size l=0   l< numberRates_  ++l
	induction variable: ['i', 'j', 'k', 'l']
	{
	}
 }
array table
-----------------------------------------------
numerairesHeld_ -> [('[i]', 'w', 'normalized', ['i', 'j', 'k', 'l'], 3589)]
LDEs formed:1

numberCashFlowsThisIndex_ -> [('[i][j]', 'w', 'normalized', ['i', 'j', 'k', 'l'], 3590)]
LDEs formed:2

distinct LDEs:
i1=i2,j1=j2
i1=i2
#########################################################################################
loop info: unsigned long i=0  i < numberRates_  ++i
induction variable: ['i']
{
L3591: (StepsDiscountsSquared_[storeStep][i]=,w) 
L3592: (LIBORRatios_[storeStep][i]=,w) (currentForwards_[i]/,r) (lastForwards_[i],r) 
L3593: (LIBORRates_[storeStep][i]=,w) (currentForwards_[i],r) 
L3594: (Discounts_[storeStep][i+1]=,w) 
}
array table
-----------------------------------------------
LIBORRates_ -> [('[storeStep][i]', 'w', 'not normalized', ['i'], 3593)]
LDEs formed:2

currentForwards_ -> [('[i]', 'r', 'normalized', ['i'], 3592), ('[i]', 'r', 'normalized', ['i'], 3593)]
LDEs formed:0

lastForwards_ -> [('[i]', 'r', 'normalized', ['i'], 3592)]
LDEs formed:0

LIBORRatios_ -> [('[storeStep][i]', 'w', 'not normalized', ['i'], 3592)]
LDEs formed:2

Discounts_ -> [('[storeStep][i+1]', 'w', 'not normalized', ['i'], 3594)]
LDEs formed:2

StepsDiscountsSquared_ -> [('[storeStep][i]', 'w', 'not normalized', ['i'], 3591)]
LDEs formed:2

distinct LDEs:
storeStep=storeStep,i1+1=i2+1
storeStep=storeStep,i1=i2
#########################################################################################
loop info: Size i=0  i<numberProducts_  ++i
induction variable: ['i']
{
	loop info: Size j=0  j<numberCashFlowsThisStep_[i]  ++j
	induction variable: ['i', 'j']
	{
	L3592: (cashFlowsGenerated_[i][j].timeIndex,r) 
	L3593: (++numberCashFlowsThisIndex_[i][ k],w) 
		loop info: Size l=0  l <= numberRates_  ++l
		induction variable: ['i', 'j', 'l']
		{
		}
 	}
 }
array table
-----------------------------------------------
cashFlowsGenerated_ -> [('[i][j]', 'r', 'normalized', ['i', 'j', 'l'], 3592)]
LDEs formed:0

numberCashFlowsThisIndex_ -> [('[i][ k]', 'w', 'not normalized', ['i', 'j', 'l'], 3593)]
LDEs formed:2

distinct LDEs:
i1=i2, k= k
#########################################################################################
loop info: Integer currentStep =  numberSteps_-1  currentStep >=0   --currentStep
induction variable: ['currentStep']
{
	loop info: Size k=0  k < cashFlowIndicesThisStep_[currentStep].size()  ++k
	induction variable: ['currentStep', 'k']
	{
	L3594: (cashFlowIndicesThisStep_[currentStep][k],r) 
		loop info: Size l=0  l < numberProducts_ && noFlows  ++l
		induction variable: ['currentStep', 'k', 'l']
		{
		}
	L3595: (discounters_[cashFlowIndex].getFactors,r) 
		loop info: Size j=0  j < numberProducts_  ++j
		induction variable: ['currentStep', 'k', 'l', 'j']
			{
			L3596: (numberCashFlowsThisIndex_[j][cashFlowIndex],r) 
			L3597: (totalCashFlowsThisIndex_[j][cashFlowIndex][0],r) 
			L3598: (deflatorAndDerivatives_[0],r) 
			L3599: (cashFlowsGenerated_[j][cashFlowIndex].amount,r) (deflatorAndDerivatives_[0],r) 
			L3600: (numerairesHeld_[j]+=,w) 
				loop info: Size i=1  i <= numberRates_  ++i
				induction variable: ['currentStep', 'k', 'l', 'j', 'i']
					{
					L3601: (totalCashFlowsThisIndex_[j][cashFlowIndex][i],r) 
					L3602: (deflatorAndDerivatives_[0],r) 
					L3603: (totalCashFlowsThisIndex_[j][cashFlowIndex][0]*,r) (deflatorAndDerivatives_[i],r) 
					L3604: (V_[j][stepToUse][i-1]+=,w) 
					}
 			}
 	}
	loop info: Size i=0  i < numberProducts_  ++i
	induction variable: ['currentStep', 'k', 'l', 'j', 'i']
			{
				loop info: Size f=0  f < factors  ++f
				induction variable: ['currentStep', 'k', 'l', 'j', 'i', 'f']
				{
				L3605: (LIBORRates_[stepToUse][numberRates_-1],r) 
				L3606: (V_[i][stepToUse][numberRates_-1],r) 
				L3607: (thisPseudoRoot_[numberRates_-1][f],r) 
				L3608: (partials_[f][numberRates_-1]=,w) 
					loop info: Integer r = numberRates_-2  r >=0   --r
					induction variable: ['currentStep', 'k', 'l', 'j', 'i', 'f', 'r']
					{
					L3609: (LIBORRates_[stepToUse][r]*,r) (V_[i][stepToUse][r]*,r) (thisPseudoRoot_[r][f],r) 
					L3610: (partials_[f][r]=,w) (partials_[f][r+1]+,r) 
					}
 				}
			L3611: (V_[i][stepToUse][j]*,r) (LIBORRatios_[stepToUse][j],r) 
			L3612: (V_[i][nextStepIndex][j]=,w) 
				loop info: Size f=0  f < factors  ++f
				induction variable: ['currentStep', 'k', 'l', 'j', 'i', 'f', 'r']
					{
					}
			L3613: (taus[j]*,r) (StepsDiscountsSquared_[stepToUse][j],r) 
			L3614: (V_[i][nextStepIndex][j]+=,w) 
			}
 }
array table
-----------------------------------------------
cashFlowsGenerated_ -> [('[j][cashFlowIndex]', 'r', 'not normalized', ['currentStep', 'k', 'l', 'j', 'i', 'f', 'r'], 3599)]
LDEs formed:0

discounters_ -> [('[cashFlowIndex]', 'r', 'not normalized', ['currentStep', 'k', 'l', 'j', 'i', 'f', 'r'], 3595)]
LDEs formed:0

thisPseudoRoot_ -> [('[numberRates_-1][f]', 'r', 'not normalized', ['currentStep', 'k', 'l', 'j', 'i', 'f', 'r'], 3607), ('[r][f]', 'r', 'normalized', ['currentStep', 'k', 'l', 'j', 'i', 'f', 'r'], 3609)]
LDEs formed:0

LIBORRates_ -> [('[stepToUse][numberRates_-1]', 'r', 'not normalized', ['currentStep', 'k', 'l', 'j', 'i', 'f', 'r'], 3605), ('[stepToUse][r]', 'r', 'not normalized', ['currentStep', 'k', 'l', 'j', 'i', 'f', 'r'], 3609)]
LDEs formed:0

deflatorAndDerivatives_ -> [('[0]', 'r', 'normalized', ['currentStep', 'k', 'l', 'j', 'i', 'f', 'r'], 3598), ('[0]', 'r', 'normalized', ['currentStep', 'k', 'l', 'j', 'i', 'f', 'r'], 3599), ('[0]', 'r', 'normalized', ['currentStep', 'k', 'l', 'j', 'i', 'f', 'r'], 3602), ('[i]', 'r', 'normalized', ['currentStep', 'k', 'l', 'j', 'i', 'f', 'r'], 3603)]
LDEs formed:0

numberCashFlowsThisIndex_ -> [('[j][cashFlowIndex]', 'r', 'not normalized', ['currentStep', 'k', 'l', 'j', 'i', 'f', 'r'], 3596)]
LDEs formed:0

taus -> [('[j]', 'r', 'normalized', ['currentStep', 'k', 'l', 'j', 'i', 'f', 'r'], 3613)]
LDEs formed:0

cashFlowIndicesThisStep_ -> [('[currentStep][k]', 'r', 'normalized', ['currentStep', 'k', 'l', 'j', 'i', 'f', 'r'], 3594)]
LDEs formed:0

LIBORRatios_ -> [('[stepToUse][j]', 'r', 'not normalized', ['currentStep', 'k', 'l', 'j', 'i', 'f', 'r'], 3611)]
LDEs formed:0

partials_ -> [('[f][numberRates_-1]', 'w', 'not normalized', ['currentStep', 'k', 'l', 'j', 'i', 'f', 'r'], 3608), ('[f][r]', 'w', 'normalized', ['currentStep', 'k', 'l', 'j', 'i', 'f', 'r'], 3610), ('[f][r+1]', 'r', 'normalized', ['currentStep', 'k', 'l', 'j', 'i', 'f', 'r'], 3610)]
LDEs formed:10

totalCashFlowsThisIndex_ -> [('[j][cashFlowIndex][0]', 'r', 'not normalized', ['currentStep', 'k', 'l', 'j', 'i', 'f', 'r'], 3597), ('[j][cashFlowIndex][i]', 'r', 'not normalized', ['currentStep', 'k', 'l', 'j', 'i', 'f', 'r'], 3601), ('[j][cashFlowIndex][0]', 'r', 'not normalized', ['currentStep', 'k', 'l', 'j', 'i', 'f', 'r'], 3603)]
LDEs formed:0

StepsDiscountsSquared_ -> [('[stepToUse][j]', 'r', 'not normalized', ['currentStep', 'k', 'l', 'j', 'i', 'f', 'r'], 3613)]
LDEs formed:0

numerairesHeld_ -> [('[j]', 'w', 'normalized', ['currentStep', 'k', 'l', 'j', 'i', 'f', 'r'], 3600)]
LDEs formed:1

V_ -> [('[j][stepToUse][i-1]', 'w', 'not normalized', ['currentStep', 'k', 'l', 'j', 'i', 'f', 'r'], 3604), ('[i][stepToUse][numberRates_-1]', 'r', 'not normalized', ['currentStep', 'k', 'l', 'j', 'i', 'f', 'r'], 3606), ('[i][stepToUse][r]', 'r', 'not normalized', ['currentStep', 'k', 'l', 'j', 'i', 'f', 'r'], 3609), ('[i][stepToUse][j]', 'r', 'not normalized', ['currentStep', 'k', 'l', 'j', 'i', 'f', 'r'], 3611), ('[i][nextStepIndex][j]', 'w', 'not normalized', ['currentStep', 'k', 'l', 'j', 'i', 'f', 'r'], 3612), ('[i][nextStepIndex][j]', 'w', 'not normalized', ['currentStep', 'k', 'l', 'j', 'i', 'f', 'r'], 3614)]
LDEs formed:45

distinct LDEs:
j1=j2,stepToUse=stepToUse,i1-1=i2-1
j1=i2,stepToUse=stepToUse,i1-1=numberRates_-1
f1=f2,r1=r2+1
j1=i2,stepToUse=stepToUse,i1-1=j2
i1=i2,nextStepIndex=nextStepIndex,j1=j2
f1=f2,r1=r2
j1=i2,stepToUse=stepToUse,i1-1=r2
j1=i2,stepToUse=nextStepIndex,i1-1=j2
f1=f2,numberRates_-1=r2
i1=i2,stepToUse=nextStepIndex,r1=j2
j1=j2
i1=i2,stepToUse=nextStepIndex,j1=j2
f1=f2,numberRates_-1=r2+1
f1=f2,numberRates_-1=numberRates_-1
i1=i2,stepToUse=nextStepIndex,numberRates_-1=j2
#########################################################################################
loop info: Size i=0  i < numberProducts_  ++i
induction variable: ['i']
{
L3615: (values[i]=,w) (numerairesHeld_[i]*,r) 
	loop info: Size j=0  j < numberRates_  ++j
	induction variable: ['i', 'j']
	{
	}
 }
array table
-----------------------------------------------
values -> [('[i]', 'w', 'normalized', ['i', 'j'], 3615)]
LDEs formed:1

numerairesHeld_ -> [('[i]', 'r', 'normalized', ['i', 'j'], 3615)]
LDEs formed:0

distinct LDEs:
i1=i2
#########################################################################################
loop info: Size i =0  i < numberSteps_  ++i
induction variable: ['i']
{
L3616: (vegaBumps[i].size,r) 
L3617: (numeraires_[i],r) 
L3618: (vegaBumps[i],r) 
}
array table
-----------------------------------------------
numeraires_ -> [('[i]', 'r', 'normalized', ['i'], 3617)]
LDEs formed:0

vegaBumps -> [('[i]', 'r', 'normalized', ['i'], 3616), ('[i]', 'r', 'normalized', ['i'], 3618)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<numberProducts_  ++i
induction variable: ['i']
{
L3619: (cashFlowsGenerated_[i].resize,r) 
	loop info: Size j=0  j < cashFlowsGenerated_[i].size()  ++j
	induction variable: ['i', 'j']
	{
	}
L3620: (numberCashFlowsThisIndex_[i].resize,r) 
}
array table
-----------------------------------------------
cashFlowsGenerated_ -> [('[i]', 'r', 'normalized', ['i', 'j'], 3619)]
LDEs formed:0

numberCashFlowsThisIndex_ -> [('[i]', 'r', 'normalized', ['i', 'j'], 3620)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i < numberCashFlowTimes_  ++i
induction variable: ['i']
{
L3621: (cashFlowTimes[i],r) 
L3622: (cashFlowIndicesThisStep_[index].push_back,r) 
}
array table
-----------------------------------------------
cashFlowTimes -> [('[i]', 'r', 'normalized', ['i'], 3621)]
LDEs formed:0

cashFlowIndicesThisStep_ -> [('[index]', 'r', 'not normalized', ['i'], 3622)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i < numberProducts_  ++i
induction variable: ['i']
{
L3623: (numerairesHeld_[i]=,w) 
	loop info: Size j=0  j < numberCashFlowTimes_  ++j
	induction variable: ['i', 'j']
	{
	L3624: (numberCashFlowsThisIndex_[i][j]=,w) 
		loop info: Size k=0  k <= numberRates_  ++k
		induction variable: ['i', 'j', 'k']
		{
		}
 	}
	loop info: Size l=0   l< numberRates_  ++l
	induction variable: ['i', 'j', 'k', 'l']
	{
	}
	loop info: Size p=0  p < numberBumps_  ++p
	induction variable: ['i', 'j', 'k', 'l', 'p']
	{
	}
 }
array table
-----------------------------------------------
numerairesHeld_ -> [('[i]', 'w', 'normalized', ['i', 'j', 'k', 'l', 'p'], 3623)]
LDEs formed:1

numberCashFlowsThisIndex_ -> [('[i][j]', 'w', 'normalized', ['i', 'j', 'k', 'l', 'p'], 3624)]
LDEs formed:2

distinct LDEs:
i1=i2,j1=j2
i1=i2
#########################################################################################
loop info: unsigned long i=0  i < numberRates_  ++i
induction variable: ['i']
{
L3625: (stepsDiscounts_[i+1]=,w) 
L3626: (StepsDiscountsSquared_[storeStep][i]=,w) 
L3627: (LIBORRatios_[storeStep][i]=,w) (currentForwards_[i]/,r) (lastForwards_[i],r) 
L3628: (LIBORRates_[storeStep][i]=,w) (currentForwards_[i],r) 
L3629: (Discounts_[storeStep][i+1]=,w) 
}
array table
-----------------------------------------------
LIBORRates_ -> [('[storeStep][i]', 'w', 'not normalized', ['i'], 3628)]
LDEs formed:2

currentForwards_ -> [('[i]', 'r', 'normalized', ['i'], 3627), ('[i]', 'r', 'normalized', ['i'], 3628)]
LDEs formed:0

stepsDiscounts_ -> [('[i+1]', 'w', 'normalized', ['i'], 3625)]
LDEs formed:1

lastForwards_ -> [('[i]', 'r', 'normalized', ['i'], 3627)]
LDEs formed:0

LIBORRatios_ -> [('[storeStep][i]', 'w', 'not normalized', ['i'], 3627)]
LDEs formed:2

Discounts_ -> [('[storeStep][i+1]', 'w', 'not normalized', ['i'], 3629)]
LDEs formed:2

StepsDiscountsSquared_ -> [('[storeStep][i]', 'w', 'not normalized', ['i'], 3626)]
LDEs formed:2

distinct LDEs:
storeStep=storeStep,i1+1=i2+1
i1+1=i2+1
storeStep=storeStep,i1=i2
#########################################################################################
loop info: Size i=0  i<numberProducts_  ++i
induction variable: ['i']
{
	loop info: Size j=0  j<numberCashFlowsThisStep_[i]  ++j
	induction variable: ['i', 'j']
	{
	L3627: (cashFlowsGenerated_[i][j].timeIndex,r) 
	L3628: (++numberCashFlowsThisIndex_[i][ k],w) 
		loop info: Size l=0  l <= numberRates_  ++l
		induction variable: ['i', 'j', 'l']
		{
		}
 	}
 }
array table
-----------------------------------------------
cashFlowsGenerated_ -> [('[i][j]', 'r', 'normalized', ['i', 'j', 'l'], 3627)]
LDEs formed:0

numberCashFlowsThisIndex_ -> [('[i][ k]', 'w', 'not normalized', ['i', 'j', 'l'], 3628)]
LDEs formed:2

distinct LDEs:
i1=i2, k= k
#########################################################################################
loop info: Integer currentStep =  numberSteps_-1  currentStep >=0   --currentStep
induction variable: ['currentStep']
{
	loop info: Size k=0  k < cashFlowIndicesThisStep_[currentStep].size()  ++k
	induction variable: ['currentStep', 'k']
	{
	L3629: (cashFlowIndicesThisStep_[currentStep][k],r) 
		loop info: Size l=0  l < numberProducts_ && noFlows  ++l
		induction variable: ['currentStep', 'k', 'l']
		{
		}
	L3630: (discounters_[cashFlowIndex].getFactors,r) 
		loop info: Size j=0  j < numberProducts_  ++j
		induction variable: ['currentStep', 'k', 'l', 'j']
			{
			L3631: (numberCashFlowsThisIndex_[j][cashFlowIndex],r) 
			L3632: (totalCashFlowsThisIndex_[j][cashFlowIndex][0],r) 
			L3633: (deflatorAndDerivatives_[0],r) 
			L3634: (cashFlowsGenerated_[j][cashFlowIndex].amount,r) (deflatorAndDerivatives_[0],r) 
			L3635: (numerairesHeld_[j]+=,w) 
				loop info: Size i=1  i <= numberRates_  ++i
				induction variable: ['currentStep', 'k', 'l', 'j', 'i']
					{
					L3636: (totalCashFlowsThisIndex_[j][cashFlowIndex][i],r) 
					L3637: (deflatorAndDerivatives_[0],r) 
					L3638: (totalCashFlowsThisIndex_[j][cashFlowIndex][0]*,r) (deflatorAndDerivatives_[i],r) 
					L3639: (fullDerivatives_[i-1]=,w) 
					L3640: (fullDerivatives_[i-1]=,w) 
					L3641: (V_[j][stepToUse][i-1]+=,w) 
					}
				loop info: Size k=0  k < numberBumps_  ++k
				induction variable: ['currentStep', 'k', 'l', 'j', 'i']
				{
				L3642: (vegasThisPath_[j][k]+=,w) (fullDerivatives_[i]*,r) (jacobiansThisPaths_[stepToUse-1][k][i],r) 
				}
			L3643: (numberCashFlowsThisIndex_[j][cashFlowIndex],r) 
			}
 	}
 }
array table
-----------------------------------------------
vegasThisPath_ -> [('[j][k]', 'w', 'normalized', ['currentStep', 'k', 'l', 'j', 'i'], 3642)]
LDEs formed:2

cashFlowsGenerated_ -> [('[j][cashFlowIndex]', 'r', 'not normalized', ['currentStep', 'k', 'l', 'j', 'i'], 3634)]
LDEs formed:0

discounters_ -> [('[cashFlowIndex]', 'r', 'not normalized', ['currentStep', 'k', 'l', 'j', 'i'], 3630)]
LDEs formed:0

deflatorAndDerivatives_ -> [('[0]', 'r', 'normalized', ['currentStep', 'k', 'l', 'j', 'i'], 3633), ('[0]', 'r', 'normalized', ['currentStep', 'k', 'l', 'j', 'i'], 3634), ('[0]', 'r', 'normalized', ['currentStep', 'k', 'l', 'j', 'i'], 3637), ('[i]', 'r', 'normalized', ['currentStep', 'k', 'l', 'j', 'i'], 3638)]
LDEs formed:0

jacobiansThisPaths_ -> [('[stepToUse-1][k][i]', 'r', 'not normalized', ['currentStep', 'k', 'l', 'j', 'i'], 3642)]
LDEs formed:0

numberCashFlowsThisIndex_ -> [('[j][cashFlowIndex]', 'r', 'not normalized', ['currentStep', 'k', 'l', 'j', 'i'], 3631), ('[j][cashFlowIndex]', 'r', 'not normalized', ['currentStep', 'k', 'l', 'j', 'i'], 3643)]
LDEs formed:0

cashFlowIndicesThisStep_ -> [('[currentStep][k]', 'r', 'normalized', ['currentStep', 'k', 'l', 'j', 'i'], 3629)]
LDEs formed:0

fullDerivatives_ -> [('[i-1]', 'w', 'normalized', ['currentStep', 'k', 'l', 'j', 'i'], 3639), ('[i-1]', 'w', 'normalized', ['currentStep', 'k', 'l', 'j', 'i'], 3640), ('[i]', 'r', 'normalized', ['currentStep', 'k', 'l', 'j', 'i'], 3642)]
LDEs formed:5

totalCashFlowsThisIndex_ -> [('[j][cashFlowIndex][0]', 'r', 'not normalized', ['currentStep', 'k', 'l', 'j', 'i'], 3632), ('[j][cashFlowIndex][i]', 'r', 'not normalized', ['currentStep', 'k', 'l', 'j', 'i'], 3636), ('[j][cashFlowIndex][0]', 'r', 'not normalized', ['currentStep', 'k', 'l', 'j', 'i'], 3638)]
LDEs formed:0

numerairesHeld_ -> [('[j]', 'w', 'normalized', ['currentStep', 'k', 'l', 'j', 'i'], 3635)]
LDEs formed:1

V_ -> [('[j][stepToUse][i-1]', 'w', 'not normalized', ['currentStep', 'k', 'l', 'j', 'i'], 3641)]
LDEs formed:3

distinct LDEs:
j1=j2
j1=j2,stepToUse=stepToUse,i1-1=i2-1
i1-1=i2
j1=j2,k1=k2
i1-1=i2-1
#########################################################################################
loop info: Size i=0  i < numberProducts_  ++i
induction variable: ['i']
{
	loop info: Size f=0  f < factors  ++f
	induction variable: ['i', 'f']
	{
	L3642: (LIBORRates_[stepToUse][numberRates_-1],r) 
	L3643: (V_[i][stepToUse][numberRates_-1],r) 
	L3644: (thisPseudoRoot_[numberRates_-1][f],r) 
	L3645: (partials_[f][numberRates_-1]=,w) 
		loop info: Integer r = numberRates_-2  r >=0   --r
		induction variable: ['i', 'f', 'r']
		{
		L3646: (LIBORRates_[stepToUse][r]*,r) (V_[i][stepToUse][r]*,r) (thisPseudoRoot_[r][f],r) 
		L3647: (partials_[f][r]=,w) (partials_[f][r+1]+,r) 
		}
 	}
	loop info: Size j=0  j < numberRates_  ++j
	induction variable: ['i', 'f', 'r', 'j']
	{
	L3648: (V_[i][stepToUse][j]*,r) (LIBORRatios_[stepToUse][j],r) 
	L3649: (V_[i][nextStepIndex][j]=,w) 
		loop info: Size f=0  f < factors  ++f
		induction variable: ['i', 'f', 'r', 'j']
		{
		}
	L3650: (taus[j]*,r) (StepsDiscountsSquared_[stepToUse][j],r) 
	L3651: (V_[i][nextStepIndex][j]+=,w) 
	}
	loop info: Size l=0  l < numberBumps_  ++l
	induction variable: ['i', 'f', 'r', 'j', 'l']
	{
	}
 }
array table
-----------------------------------------------
LIBORRates_ -> [('[stepToUse][numberRates_-1]', 'r', 'not normalized', ['i', 'f', 'r', 'j', 'l'], 3642), ('[stepToUse][r]', 'r', 'not normalized', ['i', 'f', 'r', 'j', 'l'], 3646)]
LDEs formed:0

thisPseudoRoot_ -> [('[numberRates_-1][f]', 'r', 'not normalized', ['i', 'f', 'r', 'j', 'l'], 3644), ('[r][f]', 'r', 'normalized', ['i', 'f', 'r', 'j', 'l'], 3646)]
LDEs formed:0

taus -> [('[j]', 'r', 'normalized', ['i', 'f', 'r', 'j', 'l'], 3650)]
LDEs formed:0

partials_ -> [('[f][numberRates_-1]', 'w', 'not normalized', ['i', 'f', 'r', 'j', 'l'], 3645), ('[f][r]', 'w', 'normalized', ['i', 'f', 'r', 'j', 'l'], 3647), ('[f][r+1]', 'r', 'normalized', ['i', 'f', 'r', 'j', 'l'], 3647)]
LDEs formed:10

LIBORRatios_ -> [('[stepToUse][j]', 'r', 'not normalized', ['i', 'f', 'r', 'j', 'l'], 3648)]
LDEs formed:0

StepsDiscountsSquared_ -> [('[stepToUse][j]', 'r', 'not normalized', ['i', 'f', 'r', 'j', 'l'], 3650)]
LDEs formed:0

V_ -> [('[i][stepToUse][numberRates_-1]', 'r', 'not normalized', ['i', 'f', 'r', 'j', 'l'], 3643), ('[i][stepToUse][r]', 'r', 'not normalized', ['i', 'f', 'r', 'j', 'l'], 3646), ('[i][stepToUse][j]', 'r', 'not normalized', ['i', 'f', 'r', 'j', 'l'], 3648), ('[i][nextStepIndex][j]', 'w', 'not normalized', ['i', 'f', 'r', 'j', 'l'], 3649), ('[i][nextStepIndex][j]', 'w', 'not normalized', ['i', 'f', 'r', 'j', 'l'], 3651)]
LDEs formed:27

distinct LDEs:
f1=f2,r1=r2+1
f1=f2,r1=r2
i1=i2,nextStepIndex=nextStepIndex,j1=j2
f1=f2,numberRates_-1=r2
i1=i2,stepToUse=nextStepIndex,r1=j2
i1=i2,stepToUse=nextStepIndex,j1=j2
f1=f2,numberRates_-1=r2+1
f1=f2,numberRates_-1=numberRates_-1
i1=i2,stepToUse=nextStepIndex,numberRates_-1=j2
#########################################################################################
loop info: Size i=0  i < numberProducts_  ++i
induction variable: ['i']
{
L3652: (values[i*entriesPerProduct]=,w) (numerairesHeld_[i]*,r) 
	loop info: Size j=0  j < numberRates_  ++j
	induction variable: ['i', 'j']
	{
	}
L3653: (values[i*entriesPerProduct + numberRates_ +k +1 ]=,w) (vegasThisPath_[i][k]*,r) 
}
array table
-----------------------------------------------
vegasThisPath_ -> [('[i][k]', 'r', 'not normalized', ['i', 'j'], 3653)]
LDEs formed:0

values -> [('[i*entriesPerProduct]', 'w', 'not normalized', ['i', 'j'], 3652), ('[i*entriesPerProduct + numberRates_ +k +1 ]', 'w', 'not normalized', ['i', 'j'], 3653)]
LDEs formed:3

numerairesHeld_ -> [('[i]', 'r', 'normalized', ['i', 'j'], 3652)]
LDEs formed:0

distinct LDEs:
i1*entriesPerProduct=i2*entriesPerProduct + numberRates_ +k +1 
i1*entriesPerProduct=i2*entriesPerProduct
i1*entriesPerProduct + numberRates_ +k +1 =i2*entriesPerProduct + numberRates_ +k +1 
#########################################################################################
loop info: Size i=0  i<numberOfPaths  ++i
induction variable: ['i']
{
	loop info: Size j=0  j < values.size()  ++j
	induction variable: ['i', 'j']
	{
	L3653: (sums[j]+=,w) (values[j],r) 
	L3654: (sumsqs[j]+=,w) (values[j]*,r) (values[j],r) 
	}
 }
array table
-----------------------------------------------
values -> [('[j]', 'r', 'normalized', ['i', 'j'], 3653), ('[j]', 'r', 'normalized', ['i', 'j'], 3654), ('[j]', 'r', 'normalized', ['i', 'j'], 3654)]
LDEs formed:0

sums -> [('[j]', 'w', 'normalized', ['i', 'j'], 3653)]
LDEs formed:1

sumsqs -> [('[j]', 'w', 'normalized', ['i', 'j'], 3654)]
LDEs formed:1

distinct LDEs:
j1=j2
#########################################################################################
loop info: Size j=0  j < values.size()  ++j
induction variable: ['j']
{
L3655: (means[j]=,w) (sums[j]/,r) 
L3656: (sumsqs[j]/,r) 
L3657: (means[j]*,r) (means[j],r) 
L3658: (errors[j]=,w) 
}
array table
-----------------------------------------------
errors -> [('[j]', 'w', 'normalized', ['j'], 3658)]
LDEs formed:1

sums -> [('[j]', 'r', 'normalized', ['j'], 3655)]
LDEs formed:0

sumsqs -> [('[j]', 'r', 'normalized', ['j'], 3656)]
LDEs formed:0

means -> [('[j]', 'w', 'normalized', ['j'], 3655), ('[j]', 'r', 'normalized', ['j'], 3657), ('[j]', 'r', 'normalized', ['j'], 3657)]
LDEs formed:3

distinct LDEs:
j1=j2
#########################################################################################
loop info: Size i =0  i < numberSteps_  ++i
induction variable: ['i']
{
L3658: (numeraires_[i],r) 
}
array table
-----------------------------------------------
numeraires_ -> [('[i]', 'r', 'normalized', ['i'], 3658)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<numberProducts_  ++i
induction variable: ['i']
{
L3659: (cashFlowsGenerated_[i].resize,r) 
	loop info: Size j=0  j < cashFlowsGenerated_[i].size()  ++j
	induction variable: ['i', 'j']
	{
	}
L3660: (numberCashFlowsThisIndex_[i].resize,r) 
}
array table
-----------------------------------------------
cashFlowsGenerated_ -> [('[i]', 'r', 'normalized', ['i', 'j'], 3659)]
LDEs formed:0

numberCashFlowsThisIndex_ -> [('[i]', 'r', 'normalized', ['i', 'j'], 3660)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i < numberCashFlowTimes_  ++i
induction variable: ['i']
{
L3661: (cashFlowTimes[i],r) 
L3662: (cashFlowIndicesThisStep_[index].push_back,r) 
}
array table
-----------------------------------------------
cashFlowTimes -> [('[i]', 'r', 'normalized', ['i'], 3661)]
LDEs formed:0

cashFlowIndicesThisStep_ -> [('[index]', 'r', 'not normalized', ['i'], 3662)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i < numberProducts_  ++i
induction variable: ['i']
{
L3663: (elementary_vegas_ThisPath_[i].resize,r) 
	loop info: Size j=0  j < numberSteps_  ++j
	induction variable: ['i', 'j']
	{
	L3664: (elementary_vegas_ThisPath_[i][j]=,w) 
	}
 }
array table
-----------------------------------------------
elementary_vegas_ThisPath_ -> [('[i]', 'r', 'normalized', ['i', 'j'], 3663), ('[i][j]', 'w', 'normalized', ['i', 'j'], 3664)]
LDEs formed:4

distinct LDEs:
i1=i2,j1=j2
i1=i2
#########################################################################################
loop info: Size i=0  i < numberProducts_  ++i
induction variable: ['i']
{
L3665: (numerairesHeld_[i]=,w) 
	loop info: Size j=0  j < numberCashFlowTimes_  ++j
	induction variable: ['i', 'j']
	{
	L3666: (numberCashFlowsThisIndex_[i][j]=,w) 
		loop info: Size k=0  k <= numberRates_  ++k
		induction variable: ['i', 'j', 'k']
		{
		}
 	}
	loop info: Size l=0   l< numberRates_  ++l
	induction variable: ['i', 'j', 'k', 'l']
	{
	}
 }
array table
-----------------------------------------------
numerairesHeld_ -> [('[i]', 'w', 'normalized', ['i', 'j', 'k', 'l'], 3665)]
LDEs formed:1

numberCashFlowsThisIndex_ -> [('[i][j]', 'w', 'normalized', ['i', 'j', 'k', 'l'], 3666)]
LDEs formed:2

distinct LDEs:
i1=i2,j1=j2
i1=i2
#########################################################################################
loop info: unsigned long i=0  i < numberRates_  ++i
induction variable: ['i']
{
L3667: (stepsDiscounts_[i+1]=,w) 
L3668: (StepsDiscountsSquared_[storeStep][i]=,w) 
L3669: (LIBORRatios_[storeStep][i]=,w) (currentForwards_[i]/,r) (lastForwards_[i],r) 
L3670: (LIBORRates_[storeStep][i]=,w) (currentForwards_[i],r) 
L3671: (Discounts_[storeStep][i+1]=,w) 
}
array table
-----------------------------------------------
LIBORRates_ -> [('[storeStep][i]', 'w', 'not normalized', ['i'], 3670)]
LDEs formed:2

currentForwards_ -> [('[i]', 'r', 'normalized', ['i'], 3669), ('[i]', 'r', 'normalized', ['i'], 3670)]
LDEs formed:0

stepsDiscounts_ -> [('[i+1]', 'w', 'normalized', ['i'], 3667)]
LDEs formed:1

lastForwards_ -> [('[i]', 'r', 'normalized', ['i'], 3669)]
LDEs formed:0

LIBORRatios_ -> [('[storeStep][i]', 'w', 'not normalized', ['i'], 3669)]
LDEs formed:2

Discounts_ -> [('[storeStep][i+1]', 'w', 'not normalized', ['i'], 3671)]
LDEs formed:2

StepsDiscountsSquared_ -> [('[storeStep][i]', 'w', 'not normalized', ['i'], 3668)]
LDEs formed:2

distinct LDEs:
storeStep=storeStep,i1+1=i2+1
i1+1=i2+1
storeStep=storeStep,i1=i2
#########################################################################################
loop info: Size i=0  i<numberProducts_  ++i
induction variable: ['i']
{
	loop info: Size j=0  j<numberCashFlowsThisStep_[i]  ++j
	induction variable: ['i', 'j']
	{
	L3669: (cashFlowsGenerated_[i][j].timeIndex,r) 
	L3670: (++numberCashFlowsThisIndex_[i][ k],w) 
		loop info: Size l=0  l <= numberRates_  ++l
		induction variable: ['i', 'j', 'l']
		{
		}
 	}
 }
array table
-----------------------------------------------
cashFlowsGenerated_ -> [('[i][j]', 'r', 'normalized', ['i', 'j', 'l'], 3669)]
LDEs formed:0

numberCashFlowsThisIndex_ -> [('[i][ k]', 'w', 'not normalized', ['i', 'j', 'l'], 3670)]
LDEs formed:2

distinct LDEs:
i1=i2, k= k
#########################################################################################
loop info: Integer currentStep =  numberSteps_-1  currentStep >=0   --currentStep
induction variable: ['currentStep']
{
	loop info: Size k=0  k < cashFlowIndicesThisStep_[currentStep].size()  ++k
	induction variable: ['currentStep', 'k']
	{
	L3671: (cashFlowIndicesThisStep_[currentStep][k],r) 
		loop info: Size l=0  l < numberProducts_ && noFlows  ++l
		induction variable: ['currentStep', 'k', 'l']
		{
		}
	L3672: (discounters_[cashFlowIndex].getFactors,r) 
		loop info: Size j=0  j < numberProducts_  ++j
		induction variable: ['currentStep', 'k', 'l', 'j']
			{
			L3673: (numberCashFlowsThisIndex_[j][cashFlowIndex],r) 
			L3674: (totalCashFlowsThisIndex_[j][cashFlowIndex][0],r) 
			L3675: (deflatorAndDerivatives_[0],r) 
			L3676: (cashFlowsGenerated_[j][cashFlowIndex].amount,r) (deflatorAndDerivatives_[0],r) 
			L3677: (numerairesHeld_[j]+=,w) 
				loop info: Size i=1  i <= numberRates_  ++i
				induction variable: ['currentStep', 'k', 'l', 'j', 'i']
					{
					L3678: (totalCashFlowsThisIndex_[j][cashFlowIndex][i],r) 
					L3679: (deflatorAndDerivatives_[0],r) 
					L3680: (totalCashFlowsThisIndex_[j][cashFlowIndex][0]*,r) (deflatorAndDerivatives_[i],r) 
					L3681: (fullDerivatives_[i-1]=,w) 
					L3682: (fullDerivatives_[i-1]=,w) 
					L3683: (V_[j][stepToUse][i-1]+=,w) 
					}
			L3684: (numberCashFlowsThisIndex_[j][cashFlowIndex],r) 
			}
 	}
	loop info: Size i=0  i < numberProducts_  ++i
	induction variable: ['currentStep', 'k', 'l', 'j', 'i']
			{
				loop info: Size f=0  f < factors  ++f
				induction variable: ['currentStep', 'k', 'l', 'j', 'i', 'f']
				{
				L3685: (LIBORRates_[stepToUse][numberRates_-1],r) 
				L3686: (V_[i][stepToUse][numberRates_-1],r) 
				L3687: (thisPseudoRoot_[numberRates_-1][f],r) 
				L3688: (partials_[f][numberRates_-1]=,w) 
					loop info: Integer r = numberRates_-2  r >=0   --r
					induction variable: ['currentStep', 'k', 'l', 'j', 'i', 'f', 'r']
					{
					L3689: (LIBORRates_[stepToUse][r]*,r) (V_[i][stepToUse][r]*,r) (thisPseudoRoot_[r][f],r) 
					L3690: (partials_[f][r]=,w) (partials_[f][r+1]+,r) 
					}
 				}
				loop info: Size j=0  j < numberRates_  ++j
				induction variable: ['currentStep', 'k', 'l', 'j', 'i', 'f', 'r']
				{
				L3691: (V_[i][stepToUse][j]*,r) (LIBORRatios_[stepToUse][j],r) 
				L3692: (V_[i][nextStepIndex][j]=,w) 
					loop info: Size f=0  f < factors  ++f
					induction variable: ['currentStep', 'k', 'l', 'j', 'i', 'f', 'r']
					{
					}
				L3693: (taus[j]*,r) (StepsDiscountsSquared_[stepToUse][j],r) 
				L3694: (V_[i][nextStepIndex][j]+=,w) 
				}
 			}
 }
array table
-----------------------------------------------
cashFlowsGenerated_ -> [('[j][cashFlowIndex]', 'r', 'not normalized', ['currentStep', 'k', 'l', 'j', 'i', 'f', 'r'], 3676)]
LDEs formed:0

discounters_ -> [('[cashFlowIndex]', 'r', 'not normalized', ['currentStep', 'k', 'l', 'j', 'i', 'f', 'r'], 3672)]
LDEs formed:0

thisPseudoRoot_ -> [('[numberRates_-1][f]', 'r', 'not normalized', ['currentStep', 'k', 'l', 'j', 'i', 'f', 'r'], 3687), ('[r][f]', 'r', 'normalized', ['currentStep', 'k', 'l', 'j', 'i', 'f', 'r'], 3689)]
LDEs formed:0

LIBORRates_ -> [('[stepToUse][numberRates_-1]', 'r', 'not normalized', ['currentStep', 'k', 'l', 'j', 'i', 'f', 'r'], 3685), ('[stepToUse][r]', 'r', 'not normalized', ['currentStep', 'k', 'l', 'j', 'i', 'f', 'r'], 3689)]
LDEs formed:0

deflatorAndDerivatives_ -> [('[0]', 'r', 'normalized', ['currentStep', 'k', 'l', 'j', 'i', 'f', 'r'], 3675), ('[0]', 'r', 'normalized', ['currentStep', 'k', 'l', 'j', 'i', 'f', 'r'], 3676), ('[0]', 'r', 'normalized', ['currentStep', 'k', 'l', 'j', 'i', 'f', 'r'], 3679), ('[i]', 'r', 'normalized', ['currentStep', 'k', 'l', 'j', 'i', 'f', 'r'], 3680)]
LDEs formed:0

numberCashFlowsThisIndex_ -> [('[j][cashFlowIndex]', 'r', 'not normalized', ['currentStep', 'k', 'l', 'j', 'i', 'f', 'r'], 3673), ('[j][cashFlowIndex]', 'r', 'not normalized', ['currentStep', 'k', 'l', 'j', 'i', 'f', 'r'], 3684)]
LDEs formed:0

taus -> [('[j]', 'r', 'normalized', ['currentStep', 'k', 'l', 'j', 'i', 'f', 'r'], 3693)]
LDEs formed:0

cashFlowIndicesThisStep_ -> [('[currentStep][k]', 'r', 'normalized', ['currentStep', 'k', 'l', 'j', 'i', 'f', 'r'], 3671)]
LDEs formed:0

fullDerivatives_ -> [('[i-1]', 'w', 'normalized', ['currentStep', 'k', 'l', 'j', 'i', 'f', 'r'], 3681), ('[i-1]', 'w', 'normalized', ['currentStep', 'k', 'l', 'j', 'i', 'f', 'r'], 3682)]
LDEs formed:3

LIBORRatios_ -> [('[stepToUse][j]', 'r', 'not normalized', ['currentStep', 'k', 'l', 'j', 'i', 'f', 'r'], 3691)]
LDEs formed:0

partials_ -> [('[f][numberRates_-1]', 'w', 'not normalized', ['currentStep', 'k', 'l', 'j', 'i', 'f', 'r'], 3688), ('[f][r]', 'w', 'normalized', ['currentStep', 'k', 'l', 'j', 'i', 'f', 'r'], 3690), ('[f][r+1]', 'r', 'normalized', ['currentStep', 'k', 'l', 'j', 'i', 'f', 'r'], 3690)]
LDEs formed:10

totalCashFlowsThisIndex_ -> [('[j][cashFlowIndex][0]', 'r', 'not normalized', ['currentStep', 'k', 'l', 'j', 'i', 'f', 'r'], 3674), ('[j][cashFlowIndex][i]', 'r', 'not normalized', ['currentStep', 'k', 'l', 'j', 'i', 'f', 'r'], 3678), ('[j][cashFlowIndex][0]', 'r', 'not normalized', ['currentStep', 'k', 'l', 'j', 'i', 'f', 'r'], 3680)]
LDEs formed:0

StepsDiscountsSquared_ -> [('[stepToUse][j]', 'r', 'not normalized', ['currentStep', 'k', 'l', 'j', 'i', 'f', 'r'], 3693)]
LDEs formed:0

numerairesHeld_ -> [('[j]', 'w', 'normalized', ['currentStep', 'k', 'l', 'j', 'i', 'f', 'r'], 3677)]
LDEs formed:1

V_ -> [('[j][stepToUse][i-1]', 'w', 'not normalized', ['currentStep', 'k', 'l', 'j', 'i', 'f', 'r'], 3683), ('[i][stepToUse][numberRates_-1]', 'r', 'not normalized', ['currentStep', 'k', 'l', 'j', 'i', 'f', 'r'], 3686), ('[i][stepToUse][r]', 'r', 'not normalized', ['currentStep', 'k', 'l', 'j', 'i', 'f', 'r'], 3689), ('[i][stepToUse][j]', 'r', 'not normalized', ['currentStep', 'k', 'l', 'j', 'i', 'f', 'r'], 3691), ('[i][nextStepIndex][j]', 'w', 'not normalized', ['currentStep', 'k', 'l', 'j', 'i', 'f', 'r'], 3692), ('[i][nextStepIndex][j]', 'w', 'not normalized', ['currentStep', 'k', 'l', 'j', 'i', 'f', 'r'], 3694)]
LDEs formed:45

distinct LDEs:
j1=j2,stepToUse=stepToUse,i1-1=i2-1
j1=i2,stepToUse=stepToUse,i1-1=numberRates_-1
f1=f2,r1=r2+1
j1=i2,stepToUse=stepToUse,i1-1=j2
i1=i2,nextStepIndex=nextStepIndex,j1=j2
f1=f2,numberRates_-1=r2+1
j1=i2,stepToUse=stepToUse,i1-1=r2
j1=i2,stepToUse=nextStepIndex,i1-1=j2
f1=f2,numberRates_-1=r2
i1=i2,stepToUse=nextStepIndex,r1=j2
j1=j2
i1=i2,stepToUse=nextStepIndex,j1=j2
f1=f2,r1=r2
f1=f2,numberRates_-1=numberRates_-1
i1=i2,stepToUse=nextStepIndex,numberRates_-1=j2
i1-1=i2-1
#########################################################################################
loop info: Size i=0  i < numberProducts_  ++i
induction variable: ['i']
{
	loop info: Size j=0  j < numberSteps_  ++j
	induction variable: ['i', 'j']
	{
		loop info: Size k=0  k < numberRates_  ++k
		induction variable: ['i', 'j', 'k']
		{
			loop info: Size r=0  r < numberRates_  ++r
			induction variable: ['i', 'j', 'k', 'r']
			{
			L3695: (V_[i][nextIndex][r]*,r) (jacobiansThisPaths_[j][r][k][f],r) 
			}
		L3696: (jacobiansThisPaths_[j][j][k][f]<<,r) (gaussians_[j][f]<<,r) (V_[i][nextIndex][j]<<,r) (LIBORRates_[nextIndex][j]<<,r) 
		L3697: (elementary_vegas_ThisPath_[i][j][k][f]=,w) 
		}
 	}
 }
array table
-----------------------------------------------
gaussians_ -> [('[j][f]', 'r', 'not normalized', ['i', 'j', 'k', 'r'], 3696)]
LDEs formed:0

jacobiansThisPaths_ -> [('[j][r][k][f]', 'r', 'not normalized', ['i', 'j', 'k', 'r'], 3695), ('[j][j][k][f]', 'r', 'not normalized', ['i', 'j', 'k', 'r'], 3696)]
LDEs formed:0

LIBORRates_ -> [('[nextIndex][j]', 'r', 'not normalized', ['i', 'j', 'k', 'r'], 3696)]
LDEs formed:0

elementary_vegas_ThisPath_ -> [('[i][j][k][f]', 'w', 'not normalized', ['i', 'j', 'k', 'r'], 3697)]
LDEs formed:4

V_ -> [('[i][nextIndex][r]', 'r', 'not normalized', ['i', 'j', 'k', 'r'], 3695), ('[i][nextIndex][j]', 'r', 'not normalized', ['i', 'j', 'k', 'r'], 3696)]
LDEs formed:0

distinct LDEs:
i1=i2,j1=j2,k1=k2,f=f
#########################################################################################
loop info: Size i=0  i < numberProducts_  ++i
induction variable: ['i']
{
L3697: (values[i*entriesPerProduct]=,w) (numerairesHeld_[i]*,r) 
	loop info: Size j=0  j < numberRates_  ++j
	induction variable: ['i', 'j']
	{
	}
	loop info: Size k=0  k < numberSteps_  ++k
	induction variable: ['i', 'j', 'k']
	{
	}
 }
array table
-----------------------------------------------
values -> [('[i*entriesPerProduct]', 'w', 'not normalized', ['i', 'j', 'k'], 3697)]
LDEs formed:1

numerairesHeld_ -> [('[i]', 'r', 'normalized', ['i', 'j', 'k'], 3697)]
LDEs formed:0

distinct LDEs:
i1*entriesPerProduct=i2*entriesPerProduct
#########################################################################################
loop info: Size i=0  i<numberOfPaths  ++i
induction variable: ['i']
{
	loop info: Size j=0  j < values.size()  ++j
	induction variable: ['i', 'j']
	{
	L3698: (sums[j]+=,w) (values[j],r) 
	L3699: (sumsqs[j]+=,w) (values[j]*,r) (values[j],r) 
	}
 }
array table
-----------------------------------------------
values -> [('[j]', 'r', 'normalized', ['i', 'j'], 3698), ('[j]', 'r', 'normalized', ['i', 'j'], 3699), ('[j]', 'r', 'normalized', ['i', 'j'], 3699)]
LDEs formed:0

sums -> [('[j]', 'w', 'normalized', ['i', 'j'], 3698)]
LDEs formed:1

sumsqs -> [('[j]', 'w', 'normalized', ['i', 'j'], 3699)]
LDEs formed:1

distinct LDEs:
j1=j2
#########################################################################################
loop info: Size j=0  j < values.size()  ++j
induction variable: ['j']
{
L3700: (means[j]=,w) (sums[j]/,r) 
L3701: (sumsqs[j]/,r) 
L3702: (means[j]*,r) (means[j],r) 
L3703: (errors[j]=,w) 
}
array table
-----------------------------------------------
errors -> [('[j]', 'w', 'normalized', ['j'], 3703)]
LDEs formed:1

sums -> [('[j]', 'r', 'normalized', ['j'], 3700)]
LDEs formed:0

sumsqs -> [('[j]', 'r', 'normalized', ['j'], 3701)]
LDEs formed:0

means -> [('[j]', 'w', 'normalized', ['j'], 3700), ('[j]', 'r', 'normalized', ['j'], 3702), ('[j]', 'r', 'normalized', ['j'], 3702)]
LDEs formed:3

distinct LDEs:
j1=j2
#########################################################################################
loop info: Size p=0  p < numberProducts_  ++p
induction variable: ['p']
{
	loop info: Size i=0  i < 1 + numberRates_  ++i
	induction variable: ['p', 'i']
	{
	L3703: (means[i+p*outDataPerProduct]=,w) (allMeans[i+p*inDataPerProduct],r) 
	L3704: (errors[i+p*outDataPerProduct]=,w) (allErrors[i+p*inDataPerProduct],r) 
	}
	loop info: Size bump=0  bump<numberBumps_  ++bump
	induction variable: ['p', 'i', 'bump']
	{
		loop info: Size t=0  t < numberSteps_  ++t
		induction variable: ['p', 'i', 'bump', 't']
		{
		}
	L3705: (means[p*outDataPerProduct+1+numberRates_+bump]=,w) 
	}
 }
array table
-----------------------------------------------
allErrors -> [('[i+p*inDataPerProduct]', 'r', 'not normalized', ['p', 'i', 'bump', 't'], 3704)]
LDEs formed:0

errors -> [('[i+p*outDataPerProduct]', 'w', 'not normalized', ['p', 'i', 'bump', 't'], 3704)]
LDEs formed:1

allMeans -> [('[i+p*inDataPerProduct]', 'r', 'not normalized', ['p', 'i', 'bump', 't'], 3703)]
LDEs formed:0

means -> [('[i+p*outDataPerProduct]', 'w', 'not normalized', ['p', 'i', 'bump', 't'], 3703), ('[p*outDataPerProduct+1+numberRates_+bump]', 'w', 'not normalized', ['p', 'i', 'bump', 't'], 3705)]
LDEs formed:3

distinct LDEs:
i1+p1*outDataPerProduct=i2+p2*outDataPerProduct
i1+p1*outDataPerProduct=p2*outDataPerProduct+1+numberRates_+bump2
p1*outDataPerProduct+1+numberRates_+bump1=p2*outDataPerProduct+1+numberRates_+bump2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/proxygreekengine.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<constrainedEvolvers_.size()  ++i
induction variable: ['i']
{
	loop info: Size j=0  j<constrainedEvolvers_[i].size()  ++j
	induction variable: ['i', 'j']
	{
	L3706: (constrainedEvolvers_[i][j]-,r) 
	L3707: (constrainedEvolvers_[i][j],r) 
	L3708: (modifiedValues[i][j],r) 
	}
 }
array table
-----------------------------------------------
constrainedEvolvers_ -> [('[i][j]', 'r', 'normalized', ['i', 'j'], 3706), ('[i][j]', 'r', 'normalized', ['i', 'j'], 3707)]
LDEs formed:0

modifiedValues -> [('[i][j]', 'r', 'normalized', ['i', 'j'], 3708)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<modifiedValues.size()  ++i
induction variable: ['i']
{
L3709: (modifiedValues[i].resize,r) (constrainedEvolvers_[i].size,r) 
	loop info: Size j=0  j<modifiedValues[i].size()  ++j
	induction variable: ['i', 'j']
	{
	}
 }
array table
-----------------------------------------------
modifiedValues -> [('[i]', 'r', 'normalized', ['i', 'j'], 3709)]
LDEs formed:0

constrainedEvolvers_ -> [('[i]', 'r', 'normalized', ['i', 'j'], 3709)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<numberOfPaths  ++i
induction variable: ['i']
{
	loop info: Size j=0  j<diffWeights_.size()  ++j
	induction variable: ['i', 'j']
	{
		loop info: Size k=0  k<diffWeights_[j].size()  ++k
		induction variable: ['i', 'j', 'k']
		{
		L3710: (diffWeights_[j][k],r) 
			loop info: Size l=0  l<N  ++l
			induction variable: ['i', 'j', 'k', 'l']
			{
			L3711: (results[l]=,w) (weights[0]*,r) (values[l],r) 
				loop info: Size n=1  n<weights.size()  ++n
				induction variable: ['i', 'j', 'k', 'l', 'n']
				{
				}
 			}
		L3712: (modifiedStats[j][k].add,r) 
		}
 	}
 }
array table
-----------------------------------------------
values -> [('[l]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'n'], 3711)]
LDEs formed:0

modifiedStats -> [('[j][k]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'n'], 3712)]
LDEs formed:0

diffWeights_ -> [('[j][k]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'n'], 3710)]
LDEs formed:0

weights -> [('[0]', 'r', 'normalized', ['i', 'j', 'k', 'l', 'n'], 3711)]
LDEs formed:0

results -> [('[l]', 'w', 'normalized', ['i', 'j', 'k', 'l', 'n'], 3711)]
LDEs formed:1

distinct LDEs:
l1=l2
#########################################################################################
loop info: Size i=0  i<numberProducts_  ++i
induction variable: ['i']
{
L3712: (cashFlowsGenerated_[i],r) 
	loop info: Size j=0  j<numberCashFlowsThisStep_[i]  ++j
	induction variable: ['i', 'j']
	{
	L3713: (cashflows[j].timeIndex,r) 
	L3714: (cashflows[j].amount*,r) 
	L3715: (numerairesHeld_[i]+=,w) 
	}
 }
array table
-----------------------------------------------
cashFlowsGenerated_ -> [('[i]', 'r', 'normalized', ['i', 'j'], 3712)]
LDEs formed:0

cashflows -> [('[j]', 'r', 'normalized', ['i', 'j'], 3713), ('[j]', 'r', 'normalized', ['i', 'j'], 3714)]
LDEs formed:0

numerairesHeld_ -> [('[i]', 'w', 'normalized', ['i', 'j'], 3715)]
LDEs formed:1

distinct LDEs:
i1=i2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/swapforwardmappings.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<n  ++i
induction variable: ['i']
{
	loop info: Size j=i  j<n  ++j
	induction variable: ['i', 'j']
	{
	L3716: (jacobian[i][j]=,w) 
	L3717: (p[j+1]*,r) (tau[j]/,r) (b[i]+,r) 
	L3718: (tau[j]/,r) 
	L3719: (tau[j]/,r) (f[j]*,r) (tau[j],r) 
	L3720: (tau[j]/,r) (f[j]*,r) (tau[j],r) 
	L3721: (a[j]*,r) (b[i]+,r) (a[i]*,r) (b[j],r) (b[i]*,r) (b[i],r) 
	L3722: (a[j]*,r) (a[i]*,r) 
	}
 }
array table
-----------------------------------------------
a -> [('[j]', 'r', 'normalized', ['i', 'j'], 3721), ('[i]', 'r', 'normalized', ['i', 'j'], 3721), ('[j]', 'r', 'normalized', ['i', 'j'], 3722), ('[i]', 'r', 'normalized', ['i', 'j'], 3722)]
LDEs formed:0

tau -> [('[j]', 'r', 'normalized', ['i', 'j'], 3717), ('[j]', 'r', 'normalized', ['i', 'j'], 3718), ('[j]', 'r', 'normalized', ['i', 'j'], 3719), ('[j]', 'r', 'normalized', ['i', 'j'], 3719), ('[j]', 'r', 'normalized', ['i', 'j'], 3720), ('[j]', 'r', 'normalized', ['i', 'j'], 3720)]
LDEs formed:0

b -> [('[i]', 'r', 'normalized', ['i', 'j'], 3717), ('[i]', 'r', 'normalized', ['i', 'j'], 3721), ('[j]', 'r', 'normalized', ['i', 'j'], 3721), ('[i]', 'r', 'normalized', ['i', 'j'], 3721), ('[i]', 'r', 'normalized', ['i', 'j'], 3721)]
LDEs formed:0

f -> [('[j]', 'r', 'normalized', ['i', 'j'], 3719), ('[j]', 'r', 'normalized', ['i', 'j'], 3720)]
LDEs formed:0

p -> [('[j+1]', 'r', 'normalized', ['i', 'j'], 3717)]
LDEs formed:0

jacobian -> [('[i][j]', 'w', 'normalized', ['i', 'j'], 3716)]
LDEs formed:2

distinct LDEs:
i1=i2,j1=j2
#########################################################################################
loop info: Size f=0  f < factors  ++f
induction variable: ['f']
{
	loop info: Size j=startIndex  j < endIndex ++j
	induction variable: ['f', 'j']
	{
	L3717: (cmsZed[startIndex][j]*,r) (thisPseudo[j][f],r) 
	}
 }
array table
-----------------------------------------------
cmsZed -> [('[startIndex][j]', 'r', 'not normalized', ['f', 'j'], 3717)]
LDEs formed:0

thisPseudo -> [('[j][f]', 'r', 'normalized', ['f', 'j'], 3717)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/historicalratesanalysis.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<nRates  ++i
induction variable: ['i']
{
L3718: (indexes[i]-,r) 
L3719: (sample[i]=,w) 
}
array table
-----------------------------------------------
sample -> [('[i]', 'w', 'normalized', ['i'], 3719)]
LDEs formed:1

indexes -> [('[i]', 'r', 'normalized', ['i'], 3718)]
LDEs formed:0

distinct LDEs:
i1=i2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/accountingengine.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<numberProducts_  ++i
induction variable: ['i']
{
L3719: (cashFlowsGenerated_[i],r) 
	loop info: Size j=0  j<numberCashFlowsThisStep_[i]  ++j
	induction variable: ['i', 'j']
	{
	L3720: (cashflows[j].timeIndex,r) 
	L3721: (cashflows[j].amount*,r) 
	L3722: (numerairesHeld_[i]+=,w) 
	}
 }
array table
-----------------------------------------------
cashFlowsGenerated_ -> [('[i]', 'r', 'normalized', ['i', 'j'], 3719)]
LDEs formed:0

cashflows -> [('[j]', 'r', 'normalized', ['i', 'j'], 3720), ('[j]', 'r', 'normalized', ['i', 'j'], 3721)]
LDEs formed:0

numerairesHeld_ -> [('[i]', 'w', 'normalized', ['i', 'j'], 3722)]
LDEs formed:1

distinct LDEs:
i1=i2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/evolutiondescription.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size j=0  j<numberOfSteps  ++j
induction variable: ['j']
{
L3723: (rateTimes_[firstAliveRate],r) 
L3724: (firstAliveRate_[j]=,w) 
L3725: (evolutionTimes_[j],r) 
}
array table
-----------------------------------------------
evolutionTimes_ -> [('[j]', 'r', 'normalized', ['j'], 3725)]
LDEs formed:0

rateTimes_ -> [('[firstAliveRate]', 'r', 'not normalized', ['j'], 3723)]
LDEs formed:0

firstAliveRate_ -> [('[j]', 'w', 'normalized', ['j'], 3724)]
LDEs formed:1

distinct LDEs:
j1=j2
#########################################################################################
loop info: Size i=0, j=0  i<evolutionTimes.size()  ++i
induction variable: ['i']
{
L3725: (rateTimes[j],r) (evolutionTimes[i],r) 
L3726: (numeraires[i]==,r) 
}
array table
-----------------------------------------------
rateTimes -> [('[j]', 'r', 'not normalized', ['i'], 3725)]
LDEs formed:0

evolutionTimes -> [('[i]', 'r', 'normalized', ['i'], 3725)]
LDEs formed:0

numeraires -> [('[i]', 'r', 'normalized', ['i'], 3726)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0, j=0  i<n  ++i
induction variable: ['i']
{
L3727: (rateTimes[j],r) (evolutionTimes[i],r) 
L3728: (numeraires[i]=,w) 
}
array table
-----------------------------------------------
rateTimes -> [('[j]', 'r', 'not normalized', ['i'], 3727)]
LDEs formed:0

evolutionTimes -> [('[i]', 'r', 'normalized', ['i'], 3727)]
LDEs formed:0

numeraires -> [('[i]', 'w', 'normalized', ['i'], 3728)]
LDEs formed:1

distinct LDEs:
i1=i2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/curvestate.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=nCotSwapRates-1  i>firstValidIndex  --i
induction variable: ['i']
{
L3729: (cotSwapAnnuities[i-1]=,w) (cotSwapAnnuities[i]+,r) (taus[i-1]*,r) (discountFactors[i],r) 
L3730: (cotSwapRates[i-1]=,w) 
L3731: (discountFactors[i-1]-,r) (discountFactors[nCotSwapRates],r) 
L3732: (cotSwapAnnuities[i-1],r) 
}
array table
-----------------------------------------------
discountFactors -> [('[i]', 'r', 'normalized', ['i'], 3729), ('[i-1]', 'r', 'normalized', ['i'], 3731), ('[nCotSwapRates]', 'r', 'not normalized', ['i'], 3731)]
LDEs formed:0

taus -> [('[i-1]', 'r', 'normalized', ['i'], 3729)]
LDEs formed:0

cotSwapRates -> [('[i-1]', 'w', 'normalized', ['i'], 3730)]
LDEs formed:1

cotSwapAnnuities -> [('[i-1]', 'w', 'normalized', ['i'], 3729), ('[i]', 'r', 'normalized', ['i'], 3729), ('[i-1]', 'r', 'normalized', ['i'], 3732)]
LDEs formed:3

distinct LDEs:
i1-1=i2
i1-1=i2-1
#########################################################################################
loop info: Size i=firstValidIndex  i<lastIndex  ++i
induction variable: ['i']
{
L3733: (constMatSwapAnnuities[firstValidIndex]+=,w) (taus[i]*,r) (ds[i+1],r) 
}
array table
-----------------------------------------------
taus -> [('[i]', 'r', 'normalized', ['i'], 3733)]
LDEs formed:0

constMatSwapAnnuities -> [('[firstValidIndex]', 'w', 'not normalized', ['i'], 3733)]
LDEs formed:1

ds -> [('[i+1]', 'r', 'normalized', ['i'], 3733)]
LDEs formed:0

distinct LDEs:
firstValidIndex=firstValidIndex
#########################################################################################
loop info: Size i=firstValidIndex+1  i<nConstMatSwapRates  ++i
induction variable: ['i']
{
L3734: (constMatSwapAnnuities[i]=,w) (constMatSwapAnnuities[i-1],r) 
L3735: (taus[i-1]*,r) (ds[i],r) 
L3736: (constMatSwapAnnuities[i]+=,w) (taus[lastIndex-1]*,r) (ds[lastIndex],r) 
L3737: (constMatSwapRates[i]=,w) (ds[i]-,r) (ds[lastIndex],r) 
L3738: (constMatSwapAnnuities[i],r) 
}
array table
-----------------------------------------------
constMatSwapRates -> [('[i]', 'w', 'normalized', ['i'], 3737)]
LDEs formed:1

taus -> [('[i-1]', 'r', 'normalized', ['i'], 3735), ('[lastIndex-1]', 'r', 'not normalized', ['i'], 3736)]
LDEs formed:0

constMatSwapAnnuities -> [('[i]', 'w', 'normalized', ['i'], 3734), ('[i-1]', 'r', 'normalized', ['i'], 3734), ('[i]', 'w', 'normalized', ['i'], 3736), ('[i]', 'r', 'normalized', ['i'], 3738)]
LDEs formed:7

ds -> [('[i]', 'r', 'normalized', ['i'], 3735), ('[lastIndex]', 'r', 'not normalized', ['i'], 3736), ('[i]', 'r', 'normalized', ['i'], 3737), ('[lastIndex]', 'r', 'not normalized', ['i'], 3737)]
LDEs formed:0

distinct LDEs:
i1=i2-1
i1=i2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/pathwisediscounter.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/browniangenerators/sobolbrowniangenerator.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<factors_  ++i
induction variable: ['i']
{
L3738: (orderedIndices_[i].begin,r) 
L3739: (orderedIndices_[i].end,r) 
L3740: (bridgedVariates_[i].begin,r) 
}
array table
-----------------------------------------------
bridgedVariates_ -> [('[i]', 'r', 'normalized', ['i'], 3740)]
LDEs formed:0

orderedIndices_ -> [('[i]', 'r', 'normalized', ['i'], 3738), ('[i]', 'r', 'normalized', ['i'], 3739)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size j=0  j < nPaths  ++j
induction variable: ['j']
{
	loop info: Size k=0  k < dim  ++k
	induction variable: ['j', 'k']
	{
	L3740: (sample[k]=,w) (variates[k][j],r) 
	}
L3741: (orderedIndices_[i].begin,r) 
L3742: (orderedIndices_[i].end,r) 
L3743: (retVal[i].begin,r) 
}
array table
-----------------------------------------------
sample -> [('[k]', 'w', 'normalized', ['j', 'k'], 3740)]
LDEs formed:1

variates -> [('[k][j]', 'r', 'normalized', ['j', 'k'], 3740)]
LDEs formed:0

retVal -> [('[i]', 'r', 'not normalized', ['j', 'k'], 3743)]
LDEs formed:0

orderedIndices_ -> [('[i]', 'r', 'not normalized', ['j', 'k'], 3741), ('[i]', 'r', 'not normalized', ['j', 'k'], 3742)]
LDEs formed:0

distinct LDEs:
k1=k2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/driftcomputation/lmmdriftcalculator.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=alive_  i<numberOfRates_  ++i
induction variable: ['i']
{
L3743: (downs_[i]=,w) 
L3744: (ups_[i]=,w) 
}
array table
-----------------------------------------------
ups_ -> [('[i]', 'w', 'normalized', ['i'], 3744)]
LDEs formed:1

downs_ -> [('[i]', 'w', 'normalized', ['i'], 3743)]
LDEs formed:1

distinct LDEs:
i1=i2
#########################################################################################
loop info: i=alive_  i<numberOfRates_  ++i
induction variable: ['i']
{
L3744: (drifts[i]=,w) (downs_[i],r) 
L3745: (ups_[i],r) 
L3746: (downs_[i],r) 
L3747: (drifts[i]=,w) (drifts[i],r) 
}
array table
-----------------------------------------------
ups_ -> [('[i]', 'r', 'normalized', ['i'], 3745)]
LDEs formed:0

downs_ -> [('[i]', 'r', 'normalized', ['i'], 3744), ('[i]', 'r', 'normalized', ['i'], 3746)]
LDEs formed:0

drifts -> [('[i]', 'w', 'normalized', ['i'], 3744), ('[i]', 'w', 'normalized', ['i'], 3747), ('[i]', 'r', 'normalized', ['i'], 3747)]
LDEs formed:5

distinct LDEs:
i1=i2
#########################################################################################
loop info: Size r=0  r<numberOfFactors_  ++r
induction variable: ['r']
{
L3748: (e_[r][i]=,w) (e_[r][i+1]+,r) (tmp_[i+1]*,r) (pseudo_[i+1][r],r) 
L3749: (drifts[i]-=,w) (e_[r][i]*,r) (pseudo_[i][r],r) 
}
array table
-----------------------------------------------
drifts -> [('[i]', 'w', 'not normalized', ['r'], 3749)]
LDEs formed:1

e_ -> [('[r][i]', 'w', 'not normalized', ['r'], 3748), ('[r][i+1]', 'r', 'not normalized', ['r'], 3748), ('[r][i]', 'r', 'not normalized', ['r'], 3749)]
LDEs formed:6

tmp_ -> [('[i+1]', 'r', 'not normalized', ['r'], 3748)]
LDEs formed:0

pseudo_ -> [('[i+1][r]', 'r', 'not normalized', ['r'], 3748), ('[i][r]', 'r', 'not normalized', ['r'], 3749)]
LDEs formed:0

distinct LDEs:
i=i
r1=r2,i=i
r1=r2,i=i+1
#########################################################################################
loop info: Size i=numeraire_  i<numberOfRates_  ++i
induction variable: ['i']
{
L3750: (drifts[i]=,w) 
	loop info: Size r=0  r<numberOfFactors_  ++r
	induction variable: ['i', 'r']
	{
	L3751: (e_[r][i]=,w) (tmp_[i]*,r) (pseudo_[i][r],r) 
	L3752: (e_[r][i]=,w) (e_[r][i-1]+,r) (tmp_[i]*,r) (pseudo_[i][r],r) 
	L3753: (drifts[i]+=,w) (e_[r][i]*,r) (pseudo_[i][r],r) 
	}
 }
array table
-----------------------------------------------
e_ -> [('[r][i]', 'w', 'normalized', ['i', 'r'], 3751), ('[r][i]', 'w', 'normalized', ['i', 'r'], 3752), ('[r][i-1]', 'r', 'normalized', ['i', 'r'], 3752), ('[r][i]', 'r', 'normalized', ['i', 'r'], 3753)]
LDEs formed:14

pseudo_ -> [('[i][r]', 'r', 'normalized', ['i', 'r'], 3751), ('[i][r]', 'r', 'normalized', ['i', 'r'], 3752), ('[i][r]', 'r', 'normalized', ['i', 'r'], 3753)]
LDEs formed:0

tmp_ -> [('[i]', 'r', 'normalized', ['i', 'r'], 3751), ('[i]', 'r', 'normalized', ['i', 'r'], 3752)]
LDEs formed:0

drifts -> [('[i]', 'w', 'normalized', ['i', 'r'], 3750), ('[i]', 'w', 'normalized', ['i', 'r'], 3753)]
LDEs formed:3

distinct LDEs:
r1=r2,i1=i2
r1=r2,i1=i2-1
i1=i2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/driftcomputation/lmmnormaldriftcalculator.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=alive_  i<numberOfRates_  ++i
induction variable: ['i']
{
L3754: (downs_[i]=,w) 
L3755: (ups_[i]=,w) 
}
array table
-----------------------------------------------
ups_ -> [('[i]', 'w', 'normalized', ['i'], 3755)]
LDEs formed:1

downs_ -> [('[i]', 'w', 'normalized', ['i'], 3754)]
LDEs formed:1

distinct LDEs:
i1=i2
#########################################################################################
loop info: i=alive_  i<numberOfRates_  ++i
induction variable: ['i']
{
L3755: (drifts[i]=,w) (downs_[i],r) 
L3756: (ups_[i],r) 
L3757: (downs_[i],r) 
L3758: (drifts[i]=,w) (drifts[i],r) 
}
array table
-----------------------------------------------
ups_ -> [('[i]', 'r', 'normalized', ['i'], 3756)]
LDEs formed:0

downs_ -> [('[i]', 'r', 'normalized', ['i'], 3755), ('[i]', 'r', 'normalized', ['i'], 3757)]
LDEs formed:0

drifts -> [('[i]', 'w', 'normalized', ['i'], 3755), ('[i]', 'w', 'normalized', ['i'], 3758), ('[i]', 'r', 'normalized', ['i'], 3758)]
LDEs formed:5

distinct LDEs:
i1=i2
#########################################################################################
loop info: Size r=0  r<numberOfFactors_  ++r
induction variable: ['r']
{
L3759: (e_[r][i]=,w) (e_[r][i+1]+,r) (tmp_[i+1]*,r) (pseudo_[i+1][r],r) 
L3760: (drifts[i]-=,w) (e_[r][i]*,r) (pseudo_[i][r],r) 
}
array table
-----------------------------------------------
drifts -> [('[i]', 'w', 'not normalized', ['r'], 3760)]
LDEs formed:1

e_ -> [('[r][i]', 'w', 'not normalized', ['r'], 3759), ('[r][i+1]', 'r', 'not normalized', ['r'], 3759), ('[r][i]', 'r', 'not normalized', ['r'], 3760)]
LDEs formed:6

tmp_ -> [('[i+1]', 'r', 'not normalized', ['r'], 3759)]
LDEs formed:0

pseudo_ -> [('[i+1][r]', 'r', 'not normalized', ['r'], 3759), ('[i][r]', 'r', 'not normalized', ['r'], 3760)]
LDEs formed:0

distinct LDEs:
i=i
r1=r2,i=i
r1=r2,i=i+1
#########################################################################################
loop info: Size i=numeraire_  i<numberOfRates_  ++i
induction variable: ['i']
{
L3761: (drifts[i]=,w) 
	loop info: Size r=0  r<numberOfFactors_  ++r
	induction variable: ['i', 'r']
	{
	L3762: (e_[r][i]=,w) (tmp_[i]*,r) (pseudo_[i][r],r) 
	L3763: (e_[r][i]=,w) (e_[r][i-1]+,r) (tmp_[i]*,r) (pseudo_[i][r],r) 
	L3764: (drifts[i]+=,w) (e_[r][i]*,r) (pseudo_[i][r],r) 
	}
 }
array table
-----------------------------------------------
e_ -> [('[r][i]', 'w', 'normalized', ['i', 'r'], 3762), ('[r][i]', 'w', 'normalized', ['i', 'r'], 3763), ('[r][i-1]', 'r', 'normalized', ['i', 'r'], 3763), ('[r][i]', 'r', 'normalized', ['i', 'r'], 3764)]
LDEs formed:14

pseudo_ -> [('[i][r]', 'r', 'normalized', ['i', 'r'], 3762), ('[i][r]', 'r', 'normalized', ['i', 'r'], 3763), ('[i][r]', 'r', 'normalized', ['i', 'r'], 3764)]
LDEs formed:0

tmp_ -> [('[i]', 'r', 'normalized', ['i', 'r'], 3762), ('[i]', 'r', 'normalized', ['i', 'r'], 3763)]
LDEs formed:0

drifts -> [('[i]', 'w', 'normalized', ['i', 'r'], 3761), ('[i]', 'w', 'normalized', ['i', 'r'], 3764)]
LDEs formed:3

distinct LDEs:
r1=r2,i1=i2
r1=r2,i1=i2-1
i1=i2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/driftcomputation/smmdriftcalculator.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size k=0  k<numberOfFactors_  ++k
induction variable: ['k']
{
L3765: (wkpj1_[k][numberOfRates_-1]=,w) 
L3766: (wkaj_[k][numberOfRates_-1]=,w) 
	loop info: Integer j=numberOfRates_-2  j>=static_cast<Integer>(alive_)-1  --j
	induction variable: ['k', 'j']
	{
	L3767: (wkpj_[k][j+1]=,w) (SR[j+1]*,r) 
	L3768: (pseudo_[j+1][k]*,r) (wkaj_[k][j+1],r) 
	L3769: (pseudo_[j+1][k]*,r) (displacements_[j+1]*,r) 
	L3770: (wkaj_[k][j]=,w) (wkpj_[k][j+1]*,r) (taus[j ]+,r) (wkaj_[k][j+1],r) 
	}
 }
array table
-----------------------------------------------
displacements_ -> [('[j+1]', 'r', 'normalized', ['k', 'j'], 3769)]
LDEs formed:0

pseudo_ -> [('[j+1][k]', 'r', 'normalized', ['k', 'j'], 3768), ('[j+1][k]', 'r', 'normalized', ['k', 'j'], 3769)]
LDEs formed:0

SR -> [('[j+1]', 'r', 'normalized', ['k', 'j'], 3767)]
LDEs formed:0

wkpj1_ -> [('[k][numberOfRates_-1]', 'w', 'not normalized', ['k', 'j'], 3765)]
LDEs formed:2

taus -> [('[j ]', 'r', 'normalized', ['k', 'j'], 3770)]
LDEs formed:0

wkpj_ -> [('[k][j+1]', 'w', 'normalized', ['k', 'j'], 3767), ('[k][j+1]', 'r', 'normalized', ['k', 'j'], 3770)]
LDEs formed:4

wkaj_ -> [('[k][numberOfRates_-1]', 'w', 'not normalized', ['k', 'j'], 3766), ('[k][j+1]', 'r', 'normalized', ['k', 'j'], 3768), ('[k][j]', 'w', 'normalized', ['k', 'j'], 3770), ('[k][j+1]', 'r', 'normalized', ['k', 'j'], 3770)]
LDEs formed:14

distinct LDEs:
k1=k2,numberOfRates_-1=j2
k1=k2,j1+1=j2+1
k1=k2,j1+1=j2
k1=k2,numberOfRates_-1=j2+1
k1=k2,numberOfRates_-1=numberOfRates_-1
k1=k2,j1=j2
#########################################################################################
loop info: Size k=0  k<numberOfFactors_  ++k
induction variable: ['k']
{
	loop info: Size j=alive_  j<numberOfRates_  ++j
	induction variable: ['k', 'j']
	{
	L3771: (wkajshifted_[k][j]=,w) (wkaj_[k][j]/,r) 
	L3772: (wkpj_[k][numeraire_],r) 
	}
 }
array table
-----------------------------------------------
wkajshifted_ -> [('[k][j]', 'w', 'normalized', ['k', 'j'], 3771)]
LDEs formed:2

wkaj_ -> [('[k][j]', 'r', 'normalized', ['k', 'j'], 3771)]
LDEs formed:0

wkpj_ -> [('[k][numeraire_]', 'r', 'not normalized', ['k', 'j'], 3772)]
LDEs formed:0

distinct LDEs:
k1=k2,j1=j2
#########################################################################################
loop info: Size j=alive_  j<numberOfRates_  ++j
induction variable: ['j']
{
L3773: (drifts[j]=,w) 
	loop info: Size k=0  k<numberOfFactors_  ++k
	induction variable: ['j', 'k']
	{
	L3774: (drifts[j]+=,w) (wkajshifted_[k][j]*,r) (pseudo_[j][k],r) 
	}
 }
array table
-----------------------------------------------
wkajshifted_ -> [('[k][j]', 'r', 'normalized', ['j', 'k'], 3774)]
LDEs formed:0

pseudo_ -> [('[j][k]', 'r', 'normalized', ['j', 'k'], 3774)]
LDEs formed:0

drifts -> [('[j]', 'w', 'normalized', ['j', 'k'], 3773), ('[j]', 'w', 'normalized', ['j', 'k'], 3774)]
LDEs formed:3

distinct LDEs:
j1=j2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/driftcomputation/cmsmmdriftcalculator.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=alive_  i<numberOfRates_  ++i
induction variable: ['i']
{
L3775: (downs_[i]=,w) 
L3776: (ups_[i]=,w) 
}
array table
-----------------------------------------------
ups_ -> [('[i]', 'w', 'normalized', ['i'], 3776)]
LDEs formed:1

downs_ -> [('[i]', 'w', 'normalized', ['i'], 3775)]
LDEs formed:1

distinct LDEs:
i1=i2
#########################################################################################
loop info: Size k=0  k<PjPnWk_.rows()  ++k
induction variable: ['k']
{
L3776: (PjPnWk_[k][numberOfRates_]=,w) 
L3777: (wkaj_[k][numberOfRates_-1]=,w) 
L3778: (wkaj_[k][j+1],r) 
L3779: (displacements_[j+1],r) 
L3780: (pseudo_[j+1][k],r) 
L3781: (PjPnWk_[k][endIndex],r) 
L3782: (PjPnWk_[k][j+1]=,w) 
L3783: (wkaj_[k][j]=,w) (wkaj_[k][j+1]+,r) (PjPnWk_[k][j+1]*,r) (taus[j],r) 
L3784: (wkaj_[k][j]-=,w) (PjPnWk_[k][endIndex]*,r) (taus[endIndex-1],r) 
}
array table
-----------------------------------------------
displacements_ -> [('[j+1]', 'r', 'not normalized', ['k'], 3779)]
LDEs formed:0

wkaj_ -> [('[k][numberOfRates_-1]', 'w', 'not normalized', ['k'], 3777), ('[k][j+1]', 'r', 'not normalized', ['k'], 3778), ('[k][j]', 'w', 'not normalized', ['k'], 3783), ('[k][j+1]', 'r', 'not normalized', ['k'], 3783), ('[k][j]', 'w', 'not normalized', ['k'], 3784)]
LDEs formed:24

pseudo_ -> [('[j+1][k]', 'r', 'not normalized', ['k'], 3780)]
LDEs formed:0

PjPnWk_ -> [('[k][numberOfRates_]', 'w', 'not normalized', ['k'], 3776), ('[k][endIndex]', 'r', 'not normalized', ['k'], 3781), ('[k][j+1]', 'w', 'not normalized', ['k'], 3782), ('[k][j+1]', 'r', 'not normalized', ['k'], 3783), ('[k][endIndex]', 'r', 'not normalized', ['k'], 3784)]
LDEs formed:18

taus -> [('[j]', 'r', 'not normalized', ['k'], 3783), ('[endIndex-1]', 'r', 'not normalized', ['k'], 3784)]
LDEs formed:0

distinct LDEs:
k1=k2,numberOfRates_-1=j
k1=k2,j+1=j
k1=k2,numberOfRates_=endIndex
k1=k2,numberOfRates_-1=numberOfRates_-1
k1=k2,numberOfRates_-1=j+1
k1=k2,numberOfRates_=numberOfRates_
k1=k2,endIndex=j+1
k1=k2,j=j
k1=k2,j+1=j+1
k1=k2,numberOfRates_=j+1
#########################################################################################
loop info: Size j=alive_  j<numberOfRates_  ++j
induction variable: ['j']
{
L3785: (drifts[j]=,w) 
	loop info: Size k=0  k<numberOfFactors_  ++k
	induction variable: ['j', 'k']
	{
	L3786: (drifts[j]+=,w) (pseudo_[j][k]*,r) (wkajN_[k][j],r) 
	}
L3787: (drifts[j]/=,w) 
}
array table
-----------------------------------------------
wkajN_ -> [('[k][j]', 'r', 'normalized', ['j', 'k'], 3786)]
LDEs formed:0

pseudo_ -> [('[j][k]', 'r', 'normalized', ['j', 'k'], 3786)]
LDEs formed:0

drifts -> [('[j]', 'w', 'normalized', ['j', 'k'], 3785), ('[j]', 'w', 'normalized', ['j', 'k'], 3786), ('[j]', 'w', 'normalized', ['j', 'k'], 3787)]
LDEs formed:6

distinct LDEs:
j1=j2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/curvestates/cmswapcurvestate.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=numberOfRates_-1  i>first_  --i
induction variable: ['i']
{
L3788: (discRatios_[i]=,w) (discRatios_[endIndex]+,r) 
L3789: (cmSwapRates_[i]*,r) (cmSwapAnnuities_[i],r) 
L3790: (cmSwapAnnuities_[i-1]=,w) (cmSwapAnnuities_[i],r) 
L3791: (discRatios_[i]*,r) (rateTaus_[i-1],r) 
L3792: (cmSwapAnnuities_[i-1]-=,w) (discRatios_[oldAnnuityEndIndex]*,r) (rateTaus_[oldAnnuityEndIndex-1 ],r) 
}
array table
-----------------------------------------------
cmSwapAnnuities_ -> [('[i]', 'r', 'normalized', ['i'], 3789), ('[i-1]', 'w', 'normalized', ['i'], 3790), ('[i]', 'r', 'normalized', ['i'], 3790), ('[i-1]', 'w', 'normalized', ['i'], 3792)]
LDEs formed:7

discRatios_ -> [('[i]', 'w', 'normalized', ['i'], 3788), ('[endIndex]', 'r', 'not normalized', ['i'], 3788), ('[i]', 'r', 'normalized', ['i'], 3791), ('[oldAnnuityEndIndex]', 'r', 'not normalized', ['i'], 3792)]
LDEs formed:4

rateTaus_ -> [('[i-1]', 'r', 'normalized', ['i'], 3791), ('[oldAnnuityEndIndex-1 ]', 'r', 'not normalized', ['i'], 3792)]
LDEs formed:0

cmSwapRates_ -> [('[i]', 'r', 'normalized', ['i'], 3789)]
LDEs formed:0

distinct LDEs:
i1=i2
i1-1=i2-1
i1=oldAnnuityEndIndex
i1=endIndex
i1=i2-1
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/curvestates/lmmcurvestate.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/curvestates/coterminalswapcurvestate.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=numberOfRates_-1  i>first_  --i
induction variable: ['i']
{
L3790: (discRatios_[i]=,w) (cotSwapRates_[i]*,r) (cotAnnuities_[i],r) 
L3791: (cotAnnuities_[i-1]=,w) (cotAnnuities_[i]+,r) (rateTaus_[i-1]*,r) (discRatios_[i],r) 
}
array table
-----------------------------------------------
discRatios_ -> [('[i]', 'w', 'normalized', ['i'], 3790), ('[i]', 'r', 'normalized', ['i'], 3791)]
LDEs formed:2

rateTaus_ -> [('[i-1]', 'r', 'normalized', ['i'], 3791)]
LDEs formed:0

cotAnnuities_ -> [('[i]', 'r', 'normalized', ['i'], 3790), ('[i-1]', 'w', 'normalized', ['i'], 3791), ('[i]', 'r', 'normalized', ['i'], 3791)]
LDEs formed:3

cotSwapRates_ -> [('[i]', 'r', 'normalized', ['i'], 3790)]
LDEs formed:0

distinct LDEs:
i1=i2-1
i1-1=i2-1
i1=i2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/models/alphafinder.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Integer i=0  i < stepindex_+1  ++i
induction variable: ['i']
{
L3791: (ratetwohomogeneousvols_[i]*,r) 
L3792: (rateonevols_[i]*,r) (correlations_[i],r) 
}
array table
-----------------------------------------------
correlations_ -> [('[i]', 'r', 'normalized', ['i'], 3792)]
LDEs formed:0

rateonevols_ -> [('[i]', 'r', 'normalized', ['i'], 3792)]
LDEs formed:0

ratetwohomogeneousvols_ -> [('[i]', 'r', 'normalized', ['i'], 3791)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Integer i=0  i < stepindex_+1  ++i
induction variable: ['i']
{
L3792: (ratetwohomogeneousvols_[i]*,r) 
}
array table
-----------------------------------------------
ratetwohomogeneousvols_ -> [('[i]', 'r', 'normalized', ['i'], 3792)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<=static_cast<Size>(stepindex_)+1  ++i
induction variable: ['i']
{
L3793: (putativevols_[i]-,r) (ratetwohomogeneousvols_[i],r) 
}
array table
-----------------------------------------------
putativevols_ -> [('[i]', 'r', 'normalized', ['i'], 3793)]
LDEs formed:0

ratetwohomogeneousvols_ -> [('[i]', 'r', 'normalized', ['i'], 3793)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Integer i =0  i < stepindex+1  ++i
induction variable: ['i']
{
L3794: (ratetwovols[i]=,w) (ratetwohomogeneousvols[i]*,r) 
L3795: (ratetwovols[i]*,r) (ratetwovols[i],r) 
}
array table
-----------------------------------------------
ratetwovols -> [('[i]', 'w', 'normalized', ['i'], 3794), ('[i]', 'r', 'normalized', ['i'], 3795), ('[i]', 'r', 'normalized', ['i'], 3795)]
LDEs formed:3

ratetwohomogeneousvols -> [('[i]', 'r', 'normalized', ['i'], 3794)]
LDEs formed:0

distinct LDEs:
i1=i2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/models/fwdperiodadapter.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size k = 0  k<numberOfSteps_  ++k
induction variable: ['k']
{
L3795: (pseudoRoots_[k]=,w) 
	loop info: Size i=0  i<alive[k]  ++i
	induction variable: ['k', 'i']
	{
	}
 }
array table
-----------------------------------------------
pseudoRoots_ -> [('[k]', 'w', 'normalized', ['k', 'i'], 3795)]
LDEs formed:1

distinct LDEs:
k1=k2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/models/flatvol.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size k=0, kk=0  k<numberOfSteps_  ++k
induction variable: ['k']
{
	loop info:   corrTimes[kk]<evolTimes[k]  ++kk
	induction variable: ['k', 'kk']
	{
	L3796: (corrTimes[kk],r) 
		loop info: Size i=0  i<numberOfRates_  ++i
		induction variable: ['k', 'kk', 'i']
		{
			loop info: Size j=i  j<numberOfRates_  ++j
			induction variable: ['k', 'kk', 'i', 'j']
			{
			L3797: (rateTimes[i],r) (rateTimes[j],r) 
			L3798: (vols[i],r) (vols[j],r) 
			L3799: (covariance[i][j]+=,w) (corrMatrix[i][j],r) 
			}
 		}
 	}
L3800: (evolTimes[k],r) 
	loop info: Size i=0  i<numberOfRates_  ++i
	induction variable: ['k', 'kk', 'i', 'j']
	{
		loop info: Size j=i  j<numberOfRates_  ++j
		induction variable: ['k', 'kk', 'i', 'j']
		{
		L3801: (rateTimes[i],r) (rateTimes[j],r) 
		L3802: (vols[i],r) (vols[j],r) 
		L3803: (covariance[i][j]+=,w) (corrMatrix[i][j],r) 
		}
 	}
L3804: (corrTimes[kk],r) (evolTimes[k],r) 
	loop info: Size i=0  i<numberOfRates_  ++i
	induction variable: ['k', 'kk', 'i', 'j']
	{
		loop info: Size j=i+1  j<numberOfRates_  ++j
		induction variable: ['k', 'kk', 'i', 'j']
		{
		L3805: (covariance[j][i]=,w) (covariance[i][j],r) 
		}
 	}
L3806: (pseudoRoots_[k]=,w) 
L3807: (pseudoRoots_[k].rows,r) 
L3808: (pseudoRoots_[k].rows,r) 
L3809: (pseudoRoots_[k].columns,r) 
L3810: (pseudoRoots_[k].columns,r) 
}
array table
-----------------------------------------------
evolTimes -> [('[k]', 'r', 'normalized', ['k', 'kk', 'i', 'j'], 3800), ('[k]', 'r', 'normalized', ['k', 'kk', 'i', 'j'], 3804)]
LDEs formed:0

pseudoRoots_ -> [('[k]', 'w', 'normalized', ['k', 'kk', 'i', 'j'], 3806), ('[k]', 'r', 'normalized', ['k', 'kk', 'i', 'j'], 3807), ('[k]', 'r', 'normalized', ['k', 'kk', 'i', 'j'], 3808), ('[k]', 'r', 'normalized', ['k', 'kk', 'i', 'j'], 3809), ('[k]', 'r', 'normalized', ['k', 'kk', 'i', 'j'], 3810)]
LDEs formed:5

corrMatrix -> [('[i][j]', 'r', 'normalized', ['k', 'kk', 'i', 'j'], 3799), ('[i][j]', 'r', 'normalized', ['k', 'kk', 'i', 'j'], 3803)]
LDEs formed:0

covariance -> [('[i][j]', 'w', 'normalized', ['k', 'kk', 'i', 'j'], 3799), ('[i][j]', 'w', 'normalized', ['k', 'kk', 'i', 'j'], 3803), ('[j][i]', 'w', 'normalized', ['k', 'kk', 'i', 'j'], 3805), ('[i][j]', 'r', 'normalized', ['k', 'kk', 'i', 'j'], 3805)]
LDEs formed:18

corrTimes -> [('[kk]', 'r', 'normalized', ['k', 'kk', 'i', 'j'], 3796), ('[kk]', 'r', 'normalized', ['k', 'kk', 'i', 'j'], 3804)]
LDEs formed:0

vols -> [('[i]', 'r', 'normalized', ['k', 'kk', 'i', 'j'], 3798), ('[j]', 'r', 'normalized', ['k', 'kk', 'i', 'j'], 3798), ('[i]', 'r', 'normalized', ['k', 'kk', 'i', 'j'], 3802), ('[j]', 'r', 'normalized', ['k', 'kk', 'i', 'j'], 3802)]
LDEs formed:0

rateTimes -> [('[i]', 'r', 'normalized', ['k', 'kk', 'i', 'j'], 3797), ('[j]', 'r', 'normalized', ['k', 'kk', 'i', 'j'], 3797), ('[i]', 'r', 'normalized', ['k', 'kk', 'i', 'j'], 3801), ('[j]', 'r', 'normalized', ['k', 'kk', 'i', 'j'], 3801)]
LDEs formed:0

distinct LDEs:
j1=j2,i1=i2
k1=k2
i1=i2,j1=j2
i1=j2,j1=i2
#########################################################################################
loop info: Size i=0  i<numberOfRates  ++i
induction variable: ['i']
{
L3802: (rateTimes[i],r) 
L3803: (displacedVolatilities[i]=,w) 
L3804: (initialRates[i]*,r) (initialRates[i]+,r) 
}
array table
-----------------------------------------------
rateTimes -> [('[i]', 'r', 'normalized', ['i'], 3802)]
LDEs formed:0

initialRates -> [('[i]', 'r', 'normalized', ['i'], 3804), ('[i]', 'r', 'normalized', ['i'], 3804)]
LDEs formed:0

displacedVolatilities -> [('[i]', 'w', 'normalized', ['i'], 3803)]
LDEs formed:1

distinct LDEs:
i1=i2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/models/piecewiseconstantabcdvariance.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<=resetIndex  ++i
induction variable: ['i']
{
L3804: (rateTimes_[i-1],r) 
L3805: (variances_[i]=,w) 
L3806: (rateTimes_[i],r) 
L3807: (rateTimes_[resetIndex],r) 
L3808: (rateTimes_[i]-,r) 
L3809: (volatilities_[i]=,w) (variances_[i]/,r) 
}
array table
-----------------------------------------------
volatilities_ -> [('[i]', 'w', 'normalized', ['i'], 3809)]
LDEs formed:1

rateTimes_ -> [('[i-1]', 'r', 'normalized', ['i'], 3804), ('[i]', 'r', 'normalized', ['i'], 3806), ('[resetIndex]', 'r', 'not normalized', ['i'], 3807), ('[i]', 'r', 'normalized', ['i'], 3808)]
LDEs formed:0

variances_ -> [('[i]', 'w', 'normalized', ['i'], 3805), ('[i]', 'r', 'normalized', ['i'], 3809)]
LDEs formed:2

distinct LDEs:
i1=i2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/models/capletcoterminalmaxhomogeneity.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info:   i<capletNumber+1  ++i
induction variable: ['i']
{
L3810: (previousRateSolution[i]*,r) 
L3811: (previousRateSolution[i],r) 
L3812: (homogeneousSolution[i]*,r) 
L3813: (homogeneousSolution[i],r) 
}
array table
-----------------------------------------------
previousRateSolution -> [('[i]', 'r', 'normalized', ['i'], 3810), ('[i]', 'r', 'normalized', ['i'], 3811)]
LDEs formed:0

homogeneousSolution -> [('[i]', 'r', 'normalized', ['i'], 3812), ('[i]', 'r', 'normalized', ['i'], 3813)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<capletNumber+1  ++i
induction variable: ['i']
{
L3814: (b[i]=,w) (correlations[i]*,r) (previousRateSolution[i]/,r) 
L3815: (cylinderCentre[i]=,w) (b[i],r) 
L3816: (targetArray[i]=,w) (homogeneousSolution[i],r) 
L3817: (targetArrayRestricted[i]=,w) (targetArray[i],r) 
L3818: (b[i]*,r) (b[i],r) 
}
array table
-----------------------------------------------
b -> [('[i]', 'w', 'normalized', ['i'], 3814), ('[i]', 'r', 'normalized', ['i'], 3815), ('[i]', 'r', 'normalized', ['i'], 3818), ('[i]', 'r', 'normalized', ['i'], 3818)]
LDEs formed:4

previousRateSolution -> [('[i]', 'r', 'normalized', ['i'], 3814)]
LDEs formed:0

correlations -> [('[i]', 'r', 'normalized', ['i'], 3814)]
LDEs formed:0

targetArrayRestricted -> [('[i]', 'w', 'normalized', ['i'], 3817)]
LDEs formed:1

homogeneousSolution -> [('[i]', 'r', 'normalized', ['i'], 3816)]
LDEs formed:0

cylinderCentre -> [('[i]', 'w', 'normalized', ['i'], 3815)]
LDEs formed:1

targetArray -> [('[i]', 'w', 'normalized', ['i'], 3816), ('[i]', 'r', 'normalized', ['i'], 3817)]
LDEs formed:2

distinct LDEs:
i1=i2
#########################################################################################
loop info: Size i=0  i<capletNumber+1  ++i
induction variable: ['i']
{
L3818: (ei[i]=,w) 
}
array table
-----------------------------------------------
ei -> [('[i]', 'w', 'normalized', ['i'], 3818)]
LDEs formed:1

distinct LDEs:
i1=i2
#########################################################################################
loop info: Size i=0  i<numberOfRates-1  ++i
induction variable: ['i']
{
L3819: (displacedSwapVariances[i+1]-,r) 
	loop info: Size j =0  j < i+2  ++j
	induction variable: ['i', 'j']
	{
	}
	loop info: Size k=0  k < i+1  k++
	induction variable: ['i', 'j', 'k']
	{
		loop info: Size l=0  l < numberOfFactors  ++l
		induction variable: ['i', 'j', 'k', 'l']
		{
		L3820: (corrPseudo[k][i][l],r) 
		L3821: (corrPseudo[k][i+1][l],r) 
		}
	L3822: (correlations[k]=,w) 
	}
L3823: (invertedZedMatrix[i][i],r) 
L3824: (invertedZedMatrix[i][i+1],r) 
	loop info: Size k = i+2  k <invertedZedMatrix.columns()  ++k
	induction variable: ['i', 'j', 'k', 'l']
	{
	}
L3825: (capletVols[i]*,r) (capletVols[i]*,r) (rateTimes[i],r) 
	loop info: Size j=0  j < i+2  ++j
	induction variable: ['i', 'j', 'k', 'l']
	{
	}
 }
array table
-----------------------------------------------
displacedSwapVariances -> [('[i+1]', 'r', 'normalized', ['i', 'j', 'k', 'l'], 3819)]
LDEs formed:0

correlations -> [('[k]', 'w', 'normalized', ['i', 'j', 'k', 'l'], 3822)]
LDEs formed:1

capletVols -> [('[i]', 'r', 'normalized', ['i', 'j', 'k', 'l'], 3825), ('[i]', 'r', 'normalized', ['i', 'j', 'k', 'l'], 3825)]
LDEs formed:0

invertedZedMatrix -> [('[i][i]', 'r', 'normalized', ['i', 'j', 'k', 'l'], 3823), ('[i][i+1]', 'r', 'normalized', ['i', 'j', 'k', 'l'], 3824)]
LDEs formed:0

corrPseudo -> [('[k][i][l]', 'r', 'normalized', ['i', 'j', 'k', 'l'], 3820), ('[k][i+1][l]', 'r', 'normalized', ['i', 'j', 'k', 'l'], 3821)]
LDEs formed:0

rateTimes -> [('[i]', 'r', 'normalized', ['i', 'j', 'k', 'l'], 3825)]
LDEs formed:0

distinct LDEs:
k1=k2
#########################################################################################
loop info: Size k=0  k<numberOfSteps  ++k
induction variable: ['k']
{
L3826: (swapCovariancePseudoRoots[k]=,w) (corrPseudo[k],r) 
	loop info: Size j=0  j<numberOfRates  ++j
	induction variable: ['k', 'j']
	{
	L3827: (newVols[j][k],r) 
		loop info: Size i=0  i<numberOfFactors  ++i
		induction variable: ['k', 'j', 'i']
		{
		}
 	}
L3828: (swapCovariancePseudoRoots[k].rows,r) 
L3829: (swapCovariancePseudoRoots[k].rows,r) 
L3830: (swapCovariancePseudoRoots[k].columns,r) 
L3831: (swapCovariancePseudoRoots[k].columns,r) 
}
array table
-----------------------------------------------
corrPseudo -> [('[k]', 'r', 'normalized', ['k', 'j', 'i'], 3826)]
LDEs formed:0

swapCovariancePseudoRoots -> [('[k]', 'w', 'normalized', ['k', 'j', 'i'], 3826), ('[k]', 'r', 'normalized', ['k', 'j', 'i'], 3828), ('[k]', 'r', 'normalized', ['k', 'j', 'i'], 3829), ('[k]', 'r', 'normalized', ['k', 'j', 'i'], 3830), ('[k]', 'r', 'normalized', ['k', 'j', 'i'], 3831)]
LDEs formed:5

newVols -> [('[j][k]', 'r', 'normalized', ['k', 'j', 'i'], 3827)]
LDEs formed:0

distinct LDEs:
k1=k2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/models/volatilityinterpolationspecifierabcd.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i < noBigRates_  ++i
induction variable: ['i']
{
L3828: (originalABCDVariances_[i].getABCD,r) 
L3829: (scalingFactors_[i],r) 
L3830: (scalingFactors_[i],r) 
L3831: (scalingFactors_[i],r) 
L3832: (originalABCDVariancesScaled_[i]=,w) (originalABCDVariances_[i].rateTimes,r) 
}
array table
-----------------------------------------------
originalABCDVariances_ -> [('[i]', 'r', 'normalized', ['i'], 3828), ('[i]', 'r', 'normalized', ['i'], 3832)]
LDEs formed:0

originalABCDVariancesScaled_ -> [('[i]', 'w', 'normalized', ['i'], 3832)]
LDEs formed:1

scalingFactors_ -> [('[i]', 'r', 'normalized', ['i'], 3829), ('[i]', 'r', 'normalized', ['i'], 3830), ('[i]', 'r', 'normalized', ['i'], 3831)]
LDEs formed:0

distinct LDEs:
i1=i2
#########################################################################################
loop info: Size j=0  j < noBigRates_-1  ++j
induction variable: ['j']
{
L3832: (originalABCDVariancesScaled_[j].getABCD,r) 
L3833: (originalABCDVariancesScaled_[j+1].getABCD,r) 
	loop info: Size i=0  i < period_  ++i
	induction variable: ['j', 'i']
	{
	}
 }
array table
-----------------------------------------------
originalABCDVariancesScaled_ -> [('[j]', 'r', 'normalized', ['j', 'i'], 3832), ('[j+1]', 'r', 'normalized', ['j', 'i'], 3833)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/models/capletcoterminalswaptioncalibration.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<numberOfSteps  ++i
induction variable: ['i']
{
L3834: (evolutionTimes[i-1],r) 
	loop info: Size j=i  j<numberOfRates  ++j
	induction variable: ['i', 'j']
	{
	L3835: (displacedSwapVariances[j]-,r) 
	L3836: (originalVariances[j]+=,w) (var[i],r) 
	L3837: (swapTimeInhomogeneousVariances[i][j]=,w) (var[i]/,r) 
	L3838: (alpha[j]*,r) (alpha[j]*,r) 
	L3839: (modifiedVariances[j]+=,w) (swapTimeInhomogeneousVariances[i][j],r) 
	}
 }
array table
-----------------------------------------------
displacedSwapVariances -> [('[j]', 'r', 'normalized', ['i', 'j'], 3835)]
LDEs formed:0

modifiedVariances -> [('[j]', 'w', 'normalized', ['i', 'j'], 3839)]
LDEs formed:1

swapTimeInhomogeneousVariances -> [('[i][j]', 'w', 'normalized', ['i', 'j'], 3837), ('[i][j]', 'r', 'normalized', ['i', 'j'], 3839)]
LDEs formed:4

evolutionTimes -> [('[i-1]', 'r', 'normalized', ['i', 'j'], 3834)]
LDEs formed:0

originalVariances -> [('[j]', 'w', 'normalized', ['i', 'j'], 3836)]
LDEs formed:1

var -> [('[i]', 'r', 'normalized', ['i', 'j'], 3836), ('[i]', 'r', 'normalized', ['i', 'j'], 3837)]
LDEs formed:0

alpha -> [('[j]', 'r', 'normalized', ['i', 'j'], 3838), ('[j]', 'r', 'normalized', ['i', 'j'], 3838)]
LDEs formed:0

distinct LDEs:
j1=j2
i1=i2,j1=j2
#########################################################################################
loop info: Size i=0  i<numberOfSteps  ++i
induction variable: ['i']
{
L3839: (CovarianceSwapPseudos[i]=,w) (corrPseudo[i],r) 
	loop info: Size j=0  j<numberOfRates  ++j
	induction variable: ['i', 'j']
	{
	}
L3840: (CovarianceSwapMarginalCovs[i]=,w) (CovarianceSwapPseudos[i]*,r) 
L3841: (CovarianceSwapPseudos[i],r) 
L3842: (CovarianceSwapCovs[i]=,w) (CovarianceSwapMarginalCovs[i],r) 
L3843: (CovarianceSwapCovs[i]+=,w) (CovarianceSwapCovs[i-1],r) 
}
array table
-----------------------------------------------
CovarianceSwapPseudos -> [('[i]', 'w', 'normalized', ['i', 'j'], 3839), ('[i]', 'r', 'normalized', ['i', 'j'], 3840), ('[i]', 'r', 'normalized', ['i', 'j'], 3841)]
LDEs formed:3

CovarianceSwapCovs -> [('[i]', 'w', 'normalized', ['i', 'j'], 3842), ('[i]', 'w', 'normalized', ['i', 'j'], 3843), ('[i-1]', 'r', 'normalized', ['i', 'j'], 3843)]
LDEs formed:5

CovarianceSwapMarginalCovs -> [('[i]', 'w', 'normalized', ['i', 'j'], 3840), ('[i]', 'r', 'normalized', ['i', 'j'], 3842)]
LDEs formed:2

corrPseudo -> [('[i]', 'r', 'normalized', ['i', 'j'], 3839)]
LDEs formed:0

distinct LDEs:
i1=i2-1
i1=i2
#########################################################################################
L3840: (corrPseudo[j],r) 
	loop info: Size k=0  k<numberOfFactors  ++k
	induction variable: ['i', 'jj', 'j', 'k']
		{
		}
L3841: (almostTotCovariance[i]+=,w) 
L3842: (swapTimeInhomogeneousVariances[j][i]*,r) 
L3843: (swapTimeInhomogeneousVariances[j][i-1],r) 
L3844: (corrPseudo[j],r) 
	loop info: Size k=0  k<numberOfFactors  ++k
	induction variable: ['i', 'jj', 'j', 'k']
		{
		}
L3845: (leftCovariance[i]=,w) 
L3846: (swapTimeInhomogeneousVariances[j][i]*,r) 
L3847: (swapTimeInhomogeneousVariances[j][i-1],r) 
}
array table
-----------------------------------------------
leftCovariance -> [('[i]', 'w', 'normalized', ['i', 'jj', 'j', 'k'], 3845)]
LDEs formed:1

swapTimeInhomogeneousVariances -> [('[j][i]', 'r', 'normalized', ['i', 'jj', 'j', 'k'], 3842), ('[j][i-1]', 'r', 'normalized', ['i', 'jj', 'j', 'k'], 3843), ('[j][i]', 'r', 'normalized', ['i', 'jj', 'j', 'k'], 3846), ('[j][i-1]', 'r', 'normalized', ['i', 'jj', 'j', 'k'], 3847)]
LDEs formed:0

corrPseudo -> [('[j]', 'r', 'normalized', ['i', 'jj', 'j', 'k'], 3840), ('[j]', 'r', 'normalized', ['i', 'jj', 'j', 'k'], 3844)]
LDEs formed:0

almostTotCovariance -> [('[i]', 'w', 'normalized', ['i', 'jj', 'j', 'k'], 3841)]
LDEs formed:1

distinct LDEs:
i1=i2
#########################################################################################
L3842: (swapTimeInhomogeneousVariances[j][i-1]*=,w) (b[i-1]*,r) (b[i-1],r) 
L3843: (invertedZedMatrix[i-1][i-1],r) 
L3844: (invertedZedMatrix[i-1][i],r) 
L3845: (capletVols[i-1]*,r) (capletVols[i-1]*,r) (rateTimes[i-1],r) 
	loop info: Size k = i+1  k < numberOfSteps  ++k
	induction variable: ['i', 'j', 'k']
	{
	}
L3846: (a[i-1],r) (b[i-1],r) 
	loop info: Size k = i+1  k < numberOfSteps  ++k
	induction variable: ['i', 'j', 'k']
	{
	L3847: (invertedZedMatrix[i-1][i-1]*,r) 
	L3848: (CovarianceSwapCovs[i-2][i-1][k]*,r) 
	L3849: (invertedZedMatrix[i-1][k]*,r) (a[i-1],r) 
	L3850: (invertedZedMatrix[i-1][k]*,r) 
	L3851: (CovarianceSwapCovs[i-2][k][i-1]*,r) 
	L3852: (invertedZedMatrix[i-1][i-1]*,r) (a[i-1],r) 
	L3853: (invertedZedMatrix[i-1][i-1]*,r) 
	L3854: (CovarianceSwapMarginalCovs[i-1][i-1][k]*,r) 
	L3855: (invertedZedMatrix[i-1][k]*,r) (b[i-1],r) 
	L3856: (invertedZedMatrix[i-1][k]*,r) 
	L3857: (CovarianceSwapCovs[i-1][k][i-1]*,r) 
	L3858: (invertedZedMatrix[i-1][i-1]*,r) (b[i-1],r) 
	}
	loop info: Size k = i+1  k < numberOfSteps  ++k
	induction variable: ['i', 'j', 'k']
	{
	L3859: (invertedZedMatrix[i-1][k]*,r) 
	L3860: (CovarianceSwapCovs[i-1][k][i]*,r) 
	L3861: (invertedZedMatrix[i-1][i],r) 
	L3862: (invertedZedMatrix[i-1][i]*,r) 
	L3863: (CovarianceSwapCovs[i-1][i][k]*,r) 
	L3864: (invertedZedMatrix[i-1][k],r) 
	}
L3865: (totVariance[i-1]+,r) 
L3866: (a[i-1]*,r) (almostTotCovariance[i]+,r) 
L3867: (b[i-1]*,r) (leftCovariance[i],r) 
L3868: (almostTotVariance[i],r) 
L3869: (almostTotVariance[i],r) 
L3870: (totVariance[i]-,r) 
L3871: (swapTimeInhomogeneousVariances[i][i],r) 
L3872: (almostTotVariance[i],r) 
L3873: (totVariance[i]-,r) 
L3874: (swapTimeInhomogeneousVariances[i][i],r) 
L3875: (a[i]=,w) 
L3876: (b[i]=,w) 
L3877: (a[i]=,w) 
L3878: (b[i]=,w) 
}
array table
-----------------------------------------------
a -> [('[i-1]', 'r', 'normalized', ['i', 'j', 'k'], 3846), ('[i-1]', 'r', 'normalized', ['i', 'j', 'k'], 3849), ('[i-1]', 'r', 'normalized', ['i', 'j', 'k'], 3852), ('[i-1]', 'r', 'normalized', ['i', 'j', 'k'], 3866), ('[i]', 'w', 'normalized', ['i', 'j', 'k'], 3875), ('[i]', 'w', 'normalized', ['i', 'j', 'k'], 3877)]
LDEs formed:11

b -> [('[i-1]', 'r', 'normalized', ['i', 'j', 'k'], 3842), ('[i-1]', 'r', 'normalized', ['i', 'j', 'k'], 3842), ('[i-1]', 'r', 'normalized', ['i', 'j', 'k'], 3846), ('[i-1]', 'r', 'normalized', ['i', 'j', 'k'], 3855), ('[i-1]', 'r', 'normalized', ['i', 'j', 'k'], 3858), ('[i-1]', 'r', 'normalized', ['i', 'j', 'k'], 3867), ('[i]', 'w', 'normalized', ['i', 'j', 'k'], 3876), ('[i]', 'w', 'normalized', ['i', 'j', 'k'], 3878)]
LDEs formed:15

swapTimeInhomogeneousVariances -> [('[j][i-1]', 'w', 'normalized', ['i', 'j', 'k'], 3842), ('[i][i]', 'r', 'normalized', ['i', 'j', 'k'], 3871), ('[i][i]', 'r', 'normalized', ['i', 'j', 'k'], 3874)]
LDEs formed:6

almostTotVariance -> [('[i]', 'r', 'normalized', ['i', 'j', 'k'], 3868), ('[i]', 'r', 'normalized', ['i', 'j', 'k'], 3869), ('[i]', 'r', 'normalized', ['i', 'j', 'k'], 3872)]
LDEs formed:0

capletVols -> [('[i-1]', 'r', 'normalized', ['i', 'j', 'k'], 3845), ('[i-1]', 'r', 'normalized', ['i', 'j', 'k'], 3845)]
LDEs formed:0

invertedZedMatrix -> [('[i-1][i-1]', 'r', 'normalized', ['i', 'j', 'k'], 3843), ('[i-1][i]', 'r', 'normalized', ['i', 'j', 'k'], 3844), ('[i-1][i-1]', 'r', 'normalized', ['i', 'j', 'k'], 3847), ('[i-1][k]', 'r', 'normalized', ['i', 'j', 'k'], 3849), ('[i-1][k]', 'r', 'normalized', ['i', 'j', 'k'], 3850), ('[i-1][i-1]', 'r', 'normalized', ['i', 'j', 'k'], 3852), ('[i-1][i-1]', 'r', 'normalized', ['i', 'j', 'k'], 3853), ('[i-1][k]', 'r', 'normalized', ['i', 'j', 'k'], 3855), ('[i-1][k]', 'r', 'normalized', ['i', 'j', 'k'], 3856), ('[i-1][i-1]', 'r', 'normalized', ['i', 'j', 'k'], 3858), ('[i-1][k]', 'r', 'normalized', ['i', 'j', 'k'], 3859), ('[i-1][i]', 'r', 'normalized', ['i', 'j', 'k'], 3861), ('[i-1][i]', 'r', 'normalized', ['i', 'j', 'k'], 3862), ('[i-1][k]', 'r', 'normalized', ['i', 'j', 'k'], 3864)]
LDEs formed:0

leftCovariance -> [('[i]', 'r', 'normalized', ['i', 'j', 'k'], 3867)]
LDEs formed:0

totVariance -> [('[i-1]', 'r', 'normalized', ['i', 'j', 'k'], 3865), ('[i]', 'r', 'normalized', ['i', 'j', 'k'], 3870), ('[i]', 'r', 'normalized', ['i', 'j', 'k'], 3873)]
LDEs formed:0

rateTimes -> [('[i-1]', 'r', 'normalized', ['i', 'j', 'k'], 3845)]
LDEs formed:0

CovarianceSwapMarginalCovs -> [('[i-1][i-1][k]', 'r', 'normalized', ['i', 'j', 'k'], 3854)]
LDEs formed:0

CovarianceSwapCovs -> [('[i-2][i-1][k]', 'r', 'normalized', ['i', 'j', 'k'], 3848), ('[i-2][k][i-1]', 'r', 'normalized', ['i', 'j', 'k'], 3851), ('[i-1][k][i-1]', 'r', 'normalized', ['i', 'j', 'k'], 3857), ('[i-1][k][i]', 'r', 'normalized', ['i', 'j', 'k'], 3860), ('[i-1][i][k]', 'r', 'normalized', ['i', 'j', 'k'], 3863)]
LDEs formed:0

almostTotCovariance -> [('[i]', 'r', 'normalized', ['i', 'j', 'k'], 3866)]
LDEs formed:0

distinct LDEs:
j1=j2,i1-1=i2-1
i1=i2
j1=i2,i1-1=i2
i1-1=i2
#########################################################################################
loop info: Size k=0  k<numberOfSteps  ++k
induction variable: ['k']
{
L3867: (swapCovariancePseudoRoots[k]=,w) (corrPseudo[k],r) 
	loop info: Size j=0  j<numberOfRates  ++j
	induction variable: ['k', 'j']
	{
	L3868: (swapTimeInhomogeneousVariances[k][j],r) 
		loop info: Size i=0  i<numberOfFactors  ++i
		induction variable: ['k', 'j', 'i']
		{
		}
 	}
L3869: (swapCovariancePseudoRoots[k].rows,r) 
L3870: (swapCovariancePseudoRoots[k].rows,r) 
L3871: (swapCovariancePseudoRoots[k].columns,r) 
L3872: (swapCovariancePseudoRoots[k].columns,r) 
}
array table
-----------------------------------------------
swapTimeInhomogeneousVariances -> [('[k][j]', 'r', 'normalized', ['k', 'j', 'i'], 3868)]
LDEs formed:0

corrPseudo -> [('[k]', 'r', 'normalized', ['k', 'j', 'i'], 3867)]
LDEs formed:0

swapCovariancePseudoRoots -> [('[k]', 'w', 'normalized', ['k', 'j', 'i'], 3867), ('[k]', 'r', 'normalized', ['k', 'j', 'i'], 3869), ('[k]', 'r', 'normalized', ['k', 'j', 'i'], 3870), ('[k]', 'r', 'normalized', ['k', 'j', 'i'], 3871), ('[k]', 'r', 'normalized', ['k', 'j', 'i'], 3872)]
LDEs formed:5

distinct LDEs:
k1=k2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/models/cotswaptofwdadapter.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i = 1  i<displacements.size()  ++i
induction variable: ['i']
{
L3873: (displacements[i]==,r) (displacements[0],r) 
L3874: (displacements[i]<<,r) 
L3875: (displacements[0]<<,r) 
}
array table
-----------------------------------------------
displacements -> [('[i]', 'r', 'normalized', ['i'], 3873), ('[0]', 'r', 'normalized', ['i'], 3873), ('[i]', 'r', 'normalized', ['i'], 3874), ('[0]', 'r', 'normalized', ['i'], 3875)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size k = 0  k<numberOfSteps_  ++k
induction variable: ['k']
{
L3876: (pseudoRoots_[k]=,w) 
	loop info: Size i=0  i<alive[k]  ++i
	induction variable: ['k', 'i']
	{
	}
 }
array table
-----------------------------------------------
pseudoRoots_ -> [('[k]', 'w', 'normalized', ['k', 'i'], 3876)]
LDEs formed:1

distinct LDEs:
k1=k2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/models/fwdtocotswapadapter.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i = 1  i<displacements.size()  ++i
induction variable: ['i']
{
L3877: (displacements[i]==,r) (displacements[0],r) 
L3878: (displacements[i]<<,r) 
L3879: (displacements[0]<<,r) 
}
array table
-----------------------------------------------
displacements -> [('[i]', 'r', 'normalized', ['i'], 3877), ('[0]', 'r', 'normalized', ['i'], 3877), ('[i]', 'r', 'normalized', ['i'], 3878), ('[0]', 'r', 'normalized', ['i'], 3879)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size k = 0  k<numberOfSteps_  ++k
induction variable: ['k']
{
L3880: (pseudoRoots_[k]=,w) 
	loop info: Size i=0  i<alive[k]  ++i
	induction variable: ['k', 'i']
	{
	}
 }
array table
-----------------------------------------------
pseudoRoots_ -> [('[k]', 'w', 'normalized', ['k', 'i'], 3880)]
LDEs formed:1

distinct LDEs:
k1=k2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/models/ctsmmcapletcalibration.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<numberOfRates_  ++i
induction variable: ['i']
{
L3881: (mdlSwaptionVols_[i]=,w) (swaptionTotCovariance[i][i]/,r) (rateTimes[i],r) 
L3882: (mktSwaptionVols_[i]-,r) (mdlSwaptionVols_[i],r) 
L3883: (mdlCapletVols_[i]=,w) (capletTotCovariance[i][i]/,r) (rateTimes[i],r) 
L3884: (mktCapletVols_[i]-,r) (mdlCapletVols_[i],r) 
L3885: (usedCapletVols_[i]*=,w) (mktCapletVols_[i]/,r) (mdlCapletVols_[i],r) 
}
array table
-----------------------------------------------
mktCapletVols_ -> [('[i]', 'r', 'normalized', ['i'], 3884), ('[i]', 'r', 'normalized', ['i'], 3885)]
LDEs formed:0

swaptionTotCovariance -> [('[i][i]', 'r', 'normalized', ['i'], 3881)]
LDEs formed:0

mdlSwaptionVols_ -> [('[i]', 'w', 'normalized', ['i'], 3881), ('[i]', 'r', 'normalized', ['i'], 3882)]
LDEs formed:2

capletTotCovariance -> [('[i][i]', 'r', 'normalized', ['i'], 3883)]
LDEs formed:0

mdlCapletVols_ -> [('[i]', 'w', 'normalized', ['i'], 3883), ('[i]', 'r', 'normalized', ['i'], 3884), ('[i]', 'r', 'normalized', ['i'], 3885)]
LDEs formed:3

rateTimes -> [('[i]', 'r', 'normalized', ['i'], 3881), ('[i]', 'r', 'normalized', ['i'], 3883)]
LDEs formed:0

mktSwaptionVols_ -> [('[i]', 'r', 'normalized', ['i'], 3882)]
LDEs formed:0

usedCapletVols_ -> [('[i]', 'w', 'normalized', ['i'], 3885)]
LDEs formed:1

distinct LDEs:
i1=i2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/models/abcdvol.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size k=0, kk=0  k<numberOfSteps_  ++k
induction variable: ['k']
{
	loop info:   corrTimes[kk]<evolTimes[k]  ++kk
	induction variable: ['k', 'kk']
	{
	L3886: (corrTimes[kk],r) 
		loop info: Size i=0  i<numberOfRates_  ++i
		induction variable: ['k', 'kk', 'i']
		{
			loop info: Size j=i  j<numberOfRates_  ++j
			induction variable: ['k', 'kk', 'i', 'j']
			{
			L3887: (ks[i]*,r) (ks[j]*,r) 
			L3888: (rateTimes[i],r) 
			L3889: (rateTimes[j],r) 
			L3890: (covariance[i][j]+=,w) (corrMatrix[i][j],r) 
			}
 		}
 	}
L3891: (evolTimes[k],r) 
	loop info: Size i=0  i<numberOfRates_  ++i
	induction variable: ['k', 'kk', 'i', 'j']
	{
		loop info: Size j=i  j<numberOfRates_  ++j
		induction variable: ['k', 'kk', 'i', 'j']
		{
		L3892: (ks[i]*,r) (ks[j]*,r) 
		L3893: (rateTimes[i],r) 
		L3894: (rateTimes[j],r) 
		L3895: (covariance[i][j]+=,w) (corrMatrix[i][j],r) 
		}
 	}
L3896: (corrTimes[kk],r) (evolTimes[k],r) 
	loop info: Size i=0  i<numberOfRates_  ++i
	induction variable: ['k', 'kk', 'i', 'j']
	{
		loop info: Size j=i+1  j<numberOfRates_  ++j
		induction variable: ['k', 'kk', 'i', 'j']
		{
		L3897: (covariance[j][i]=,w) (covariance[i][j],r) 
		}
 	}
L3898: (pseudoRoots_[k]=,w) 
L3899: (pseudoRoots_[k].rows,r) 
L3900: (pseudoRoots_[k].rows,r) 
L3901: (pseudoRoots_[k].columns,r) 
L3902: (pseudoRoots_[k].columns,r) 
}
array table
-----------------------------------------------
evolTimes -> [('[k]', 'r', 'normalized', ['k', 'kk', 'i', 'j'], 3891), ('[k]', 'r', 'normalized', ['k', 'kk', 'i', 'j'], 3896)]
LDEs formed:0

pseudoRoots_ -> [('[k]', 'w', 'normalized', ['k', 'kk', 'i', 'j'], 3898), ('[k]', 'r', 'normalized', ['k', 'kk', 'i', 'j'], 3899), ('[k]', 'r', 'normalized', ['k', 'kk', 'i', 'j'], 3900), ('[k]', 'r', 'normalized', ['k', 'kk', 'i', 'j'], 3901), ('[k]', 'r', 'normalized', ['k', 'kk', 'i', 'j'], 3902)]
LDEs formed:5

corrMatrix -> [('[i][j]', 'r', 'normalized', ['k', 'kk', 'i', 'j'], 3890), ('[i][j]', 'r', 'normalized', ['k', 'kk', 'i', 'j'], 3895)]
LDEs formed:0

covariance -> [('[i][j]', 'w', 'normalized', ['k', 'kk', 'i', 'j'], 3890), ('[i][j]', 'w', 'normalized', ['k', 'kk', 'i', 'j'], 3895), ('[j][i]', 'w', 'normalized', ['k', 'kk', 'i', 'j'], 3897), ('[i][j]', 'r', 'normalized', ['k', 'kk', 'i', 'j'], 3897)]
LDEs formed:18

ks -> [('[i]', 'r', 'normalized', ['k', 'kk', 'i', 'j'], 3887), ('[j]', 'r', 'normalized', ['k', 'kk', 'i', 'j'], 3887), ('[i]', 'r', 'normalized', ['k', 'kk', 'i', 'j'], 3892), ('[j]', 'r', 'normalized', ['k', 'kk', 'i', 'j'], 3892)]
LDEs formed:0

corrTimes -> [('[kk]', 'r', 'normalized', ['k', 'kk', 'i', 'j'], 3886), ('[kk]', 'r', 'normalized', ['k', 'kk', 'i', 'j'], 3896)]
LDEs formed:0

rateTimes -> [('[i]', 'r', 'normalized', ['k', 'kk', 'i', 'j'], 3888), ('[j]', 'r', 'normalized', ['k', 'kk', 'i', 'j'], 3889), ('[i]', 'r', 'normalized', ['k', 'kk', 'i', 'j'], 3893), ('[j]', 'r', 'normalized', ['k', 'kk', 'i', 'j'], 3894)]
LDEs formed:0

distinct LDEs:
j1=j2,i1=i2
k1=k2
i1=i2,j1=j2
i1=j2,j1=i2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/models/capletcoterminalperiodic.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i < numberBigRates  ++i
induction variable: ['i']
{
L3895: (marketSwaptionVols[i]=,w) 
}
array table
-----------------------------------------------
marketSwaptionVols -> [('[i]', 'w', 'normalized', ['i'], 3895)]
LDEs formed:1

distinct LDEs:
i1=i2
#########################################################################################
loop info: Size i=0  i < numberBigRates  ++i
induction variable: ['i']
{
L3896: (modelSwaptionVols[i]=,w) (swaptionTotCovariance[i][i]/,r) 
L3897: (marketSwaptionVols[i]/,r) (modelSwaptionVols[i],r) 
L3898: (scalingFactors[i]*=,w) 
L3899: (marketSwaptionVols[i]-,r) (modelSwaptionVols[i],r) (marketSwaptionVols[i]-,r) (modelSwaptionVols[i],r) 
}
array table
-----------------------------------------------
swaptionTotCovariance -> [('[i][i]', 'r', 'normalized', ['i'], 3896)]
LDEs formed:0

modelSwaptionVols -> [('[i]', 'w', 'normalized', ['i'], 3896), ('[i]', 'r', 'normalized', ['i'], 3897), ('[i]', 'r', 'normalized', ['i'], 3899), ('[i]', 'r', 'normalized', ['i'], 3899)]
LDEs formed:4

scalingFactors -> [('[i]', 'w', 'normalized', ['i'], 3898)]
LDEs formed:1

marketSwaptionVols -> [('[i]', 'r', 'normalized', ['i'], 3897), ('[i]', 'r', 'normalized', ['i'], 3899), ('[i]', 'r', 'normalized', ['i'], 3899)]
LDEs formed:0

distinct LDEs:
i1=i2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/models/pseudorootfacade.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size k=0  k<numberOfSteps_  ++k
induction variable: ['k']
{
L3900: (covariancePseudoRoots_[k].rows,r) 
L3901: (covariancePseudoRoots_[k].rows,r) 
L3902: (covariancePseudoRoots_[k].columns,r) 
L3903: (covariancePseudoRoots_[k].columns,r) 
}
array table
-----------------------------------------------
covariancePseudoRoots_ -> [('[k]', 'r', 'normalized', ['k'], 3900), ('[k]', 'r', 'normalized', ['k'], 3901), ('[k]', 'r', 'normalized', ['k'], 3902), ('[k]', 'r', 'normalized', ['k'], 3903)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/models/capletcoterminalalphacalibration.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<numberOfRates-1  ++i
induction variable: ['i']
{
L3904: (displacedSwapVariances[i+1]-,r) 
	loop info: Size j =0  j < i+2  ++j
	induction variable: ['i', 'j']
	{
	}
	loop info: Size k=0  k < i+1  k++
	induction variable: ['i', 'j', 'k']
	{
		loop info: Size l=0  l < numberOfFactors  ++l
		induction variable: ['i', 'j', 'k', 'l']
		{
		L3905: (corrPseudo[k][i][l],r) 
		L3906: (corrPseudo[k][i+1][l],r) 
		}
	L3907: (correlations[k]=,w) 
	}
L3908: (invertedZedMatrix[i][i],r) 
L3909: (invertedZedMatrix[i][i+1],r) 
	loop info: Size k = i+2  k <invertedZedMatrix.columns()  ++k
	induction variable: ['i', 'j', 'k', 'l']
	{
	}
L3910: (capletVols[i]*,r) (capletVols[i]*,r) (rateTimes[i],r) 
L3911: (alphaInitial[i+1],r) 
L3912: (alphaMax[i+1],r) 
L3913: (alphaMin[i+1],r) 
L3914: (alpha[i+1],r) 
L3915: (a[i+1],r) 
L3916: (b[i+1],r) 
L3917: (alphaInitial[i+1],r) 
L3918: (alphaMax[i+1],r) 
L3919: (alphaMin[i+1],r) 
L3920: (alpha[i+1],r) 
L3921: (a[i+1],r) 
L3922: (b[i+1],r) 
}
array table
-----------------------------------------------
displacedSwapVariances -> [('[i+1]', 'r', 'normalized', ['i', 'j', 'k', 'l'], 3904)]
LDEs formed:0

alphaMin -> [('[i+1]', 'r', 'normalized', ['i', 'j', 'k', 'l'], 3913), ('[i+1]', 'r', 'normalized', ['i', 'j', 'k', 'l'], 3919)]
LDEs formed:0

correlations -> [('[k]', 'w', 'normalized', ['i', 'j', 'k', 'l'], 3907)]
LDEs formed:1

a -> [('[i+1]', 'r', 'normalized', ['i', 'j', 'k', 'l'], 3915), ('[i+1]', 'r', 'normalized', ['i', 'j', 'k', 'l'], 3921)]
LDEs formed:0

capletVols -> [('[i]', 'r', 'normalized', ['i', 'j', 'k', 'l'], 3910), ('[i]', 'r', 'normalized', ['i', 'j', 'k', 'l'], 3910)]
LDEs formed:0

invertedZedMatrix -> [('[i][i]', 'r', 'normalized', ['i', 'j', 'k', 'l'], 3908), ('[i][i+1]', 'r', 'normalized', ['i', 'j', 'k', 'l'], 3909)]
LDEs formed:0

b -> [('[i+1]', 'r', 'normalized', ['i', 'j', 'k', 'l'], 3916), ('[i+1]', 'r', 'normalized', ['i', 'j', 'k', 'l'], 3922)]
LDEs formed:0

alphaInitial -> [('[i+1]', 'r', 'normalized', ['i', 'j', 'k', 'l'], 3911), ('[i+1]', 'r', 'normalized', ['i', 'j', 'k', 'l'], 3917)]
LDEs formed:0

alphaMax -> [('[i+1]', 'r', 'normalized', ['i', 'j', 'k', 'l'], 3912), ('[i+1]', 'r', 'normalized', ['i', 'j', 'k', 'l'], 3918)]
LDEs formed:0

corrPseudo -> [('[k][i][l]', 'r', 'normalized', ['i', 'j', 'k', 'l'], 3905), ('[k][i+1][l]', 'r', 'normalized', ['i', 'j', 'k', 'l'], 3906)]
LDEs formed:0

alpha -> [('[i+1]', 'r', 'normalized', ['i', 'j', 'k', 'l'], 3914), ('[i+1]', 'r', 'normalized', ['i', 'j', 'k', 'l'], 3920)]
LDEs formed:0

rateTimes -> [('[i]', 'r', 'normalized', ['i', 'j', 'k', 'l'], 3910)]
LDEs formed:0

distinct LDEs:
k1=k2
#########################################################################################
loop info: Size k=0  k<numberOfSteps  ++k
induction variable: ['k']
{
L3911: (swapCovariancePseudoRoots[k]=,w) (corrPseudo[k],r) 
	loop info: Size j=0  j<numberOfRates  ++j
	induction variable: ['k', 'j']
	{
	L3912: (newVols[j][k],r) 
		loop info: Size i=0  i<numberOfFactors  ++i
		induction variable: ['k', 'j', 'i']
		{
		}
 	}
L3913: (swapCovariancePseudoRoots[k].rows,r) 
L3914: (swapCovariancePseudoRoots[k].rows,r) 
L3915: (swapCovariancePseudoRoots[k].columns,r) 
L3916: (swapCovariancePseudoRoots[k].columns,r) 
}
array table
-----------------------------------------------
corrPseudo -> [('[k]', 'r', 'normalized', ['k', 'j', 'i'], 3911)]
LDEs formed:0

swapCovariancePseudoRoots -> [('[k]', 'w', 'normalized', ['k', 'j', 'i'], 3911), ('[k]', 'r', 'normalized', ['k', 'j', 'i'], 3913), ('[k]', 'r', 'normalized', ['k', 'j', 'i'], 3914), ('[k]', 'r', 'normalized', ['k', 'j', 'i'], 3915), ('[k]', 'r', 'normalized', ['k', 'j', 'i'], 3916)]
LDEs formed:5

newVols -> [('[j][k]', 'r', 'normalized', ['k', 'j', 'i'], 3912)]
LDEs formed:0

distinct LDEs:
k1=k2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/evolvers/lognormalfwdrateeuler.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size j=0  j<steps  ++j
induction variable: ['j']
{
L3913: (numeraires[j],r) 
L3914: (alive_[j],r) 
	loop info: Size k=0  k<numberOfRates_  ++k
	induction variable: ['j', 'k']
	{
	L3915: (fixed[k]=,w) 
	}
 }
array table
-----------------------------------------------
alive_ -> [('[j]', 'r', 'normalized', ['j', 'k'], 3914)]
LDEs formed:0

fixed -> [('[k]', 'w', 'normalized', ['j', 'k'], 3915)]
LDEs formed:1

numeraires -> [('[j]', 'r', 'normalized', ['j', 'k'], 3913)]
LDEs formed:0

distinct LDEs:
k1=k2
#########################################################################################
loop info: Size i=alive  i<numberOfRates_  i++
induction variable: ['i']
{
L3914: (logForwards_[i]+=,w) (drifts1_[i]+,r) (fixedDrift[i],r) 
L3915: (logForwards_[i]+=,w) 
L3916: (forwards_[i]=,w) (logForwards_[i],r) (displacements_[i],r) 
}
array table
-----------------------------------------------
fixedDrift -> [('[i]', 'r', 'normalized', ['i'], 3914)]
LDEs formed:0

drifts1_ -> [('[i]', 'r', 'normalized', ['i'], 3914)]
LDEs formed:0

forwards_ -> [('[i]', 'w', 'normalized', ['i'], 3916)]
LDEs formed:1

displacements_ -> [('[i]', 'r', 'normalized', ['i'], 3916)]
LDEs formed:0

logForwards_ -> [('[i]', 'w', 'normalized', ['i'], 3914), ('[i]', 'w', 'normalized', ['i'], 3915), ('[i]', 'r', 'normalized', ['i'], 3916)]
LDEs formed:5

distinct LDEs:
i1=i2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/evolvers/lognormalfwdrateipc.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size j=0  j<steps  ++j
induction variable: ['j']
{
L3917: (numeraires[j],r) 
L3918: (alive_[j],r) 
	loop info: Size k=0  k<numberOfRates_  ++k
	induction variable: ['j', 'k']
	{
	L3919: (C[k][k],r) 
	L3920: (fixed[k]=,w) 
	}
 }
array table
-----------------------------------------------
alive_ -> [('[j]', 'r', 'normalized', ['j', 'k'], 3918)]
LDEs formed:0

C -> [('[k][k]', 'r', 'normalized', ['j', 'k'], 3919)]
LDEs formed:0

fixed -> [('[k]', 'w', 'normalized', ['j', 'k'], 3920)]
LDEs formed:1

numeraires -> [('[j]', 'r', 'normalized', ['j', 'k'], 3917)]
LDEs formed:0

distinct LDEs:
k1=k2
#########################################################################################
loop info: Integer i=numberOfRates_-1  i>=alive  --i
induction variable: ['i']
{
	loop info: Size j=i+1  j<numberOfRates_  ++j
	induction variable: ['i', 'j']
	{
	L3918: (g_[j]*,r) (C[i][j],r) 
	}
L3919: (logForwards_[i]+=,w) (drifts1_[i]+,r) (fixedDrift[i],r) 
L3920: (logForwards_[i]+=,w) 
L3921: (forwards_[i]=,w) (logForwards_[i],r) (displacements_[i],r) 
L3922: (g_[i]=,w) (rateTaus_[i]*,r) (forwards_[i]+,r) (displacements_[i],r) 
L3923: (rateTaus_[i]*,r) (forwards_[i],r) 
}
array table
-----------------------------------------------
fixedDrift -> [('[i]', 'r', 'normalized', ['i', 'j'], 3919)]
LDEs formed:0

C -> [('[i][j]', 'r', 'normalized', ['i', 'j'], 3918)]
LDEs formed:0

rateTaus_ -> [('[i]', 'r', 'normalized', ['i', 'j'], 3922), ('[i]', 'r', 'normalized', ['i', 'j'], 3923)]
LDEs formed:0

displacements_ -> [('[i]', 'r', 'normalized', ['i', 'j'], 3921), ('[i]', 'r', 'normalized', ['i', 'j'], 3922)]
LDEs formed:0

g_ -> [('[j]', 'r', 'normalized', ['i', 'j'], 3918), ('[i]', 'w', 'normalized', ['i', 'j'], 3922)]
LDEs formed:2

drifts1_ -> [('[i]', 'r', 'normalized', ['i', 'j'], 3919)]
LDEs formed:0

logForwards_ -> [('[i]', 'w', 'normalized', ['i', 'j'], 3919), ('[i]', 'w', 'normalized', ['i', 'j'], 3920), ('[i]', 'r', 'normalized', ['i', 'j'], 3921)]
LDEs formed:5

forwards_ -> [('[i]', 'w', 'normalized', ['i', 'j'], 3921), ('[i]', 'r', 'normalized', ['i', 'j'], 3922), ('[i]', 'r', 'normalized', ['i', 'j'], 3923)]
LDEs formed:3

distinct LDEs:
j1=i2
i1=i2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/evolvers/lognormalfwdrateeulerconstrained.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size j=0  j<steps  ++j
induction variable: ['j']
{
L3924: (numeraires[j],r) 
L3925: (alive_[j],r) 
	loop info: Size k=0  k<numberOfRates_  ++k
	induction variable: ['j', 'k']
	{
	L3926: (variances[k]=,w) 
	L3927: (fixed[k]=,w) 
	}
 }
array table
-----------------------------------------------
alive_ -> [('[j]', 'r', 'normalized', ['j', 'k'], 3925)]
LDEs formed:0

variances -> [('[k]', 'w', 'normalized', ['j', 'k'], 3926)]
LDEs formed:1

fixed -> [('[k]', 'w', 'normalized', ['j', 'k'], 3927)]
LDEs formed:1

numeraires -> [('[j]', 'r', 'normalized', ['j', 'k'], 3924)]
LDEs formed:0

distinct LDEs:
k1=k2
#########################################################################################
loop info: Size i=0  i < startIndexOfSwapRate_.size()  ++i
induction variable: ['i']
{
L3925: (startIndexOfSwapRate_[i]+,r) (endIndexOfSwapRate_[i],r) 
	loop info: Size j=0  j < numberOfRates_  ++j
	induction variable: ['i', 'j']
	{
		loop info: Size k=0  k < numberOfFactors_  ++k
		induction variable: ['i', 'j', 'k']
		{
		}
	L3926: (covariances[j]=,w) 
	}
 }
array table
-----------------------------------------------
startIndexOfSwapRate_ -> [('[i]', 'r', 'normalized', ['i', 'j', 'k'], 3925)]
LDEs formed:0

covariances -> [('[j]', 'w', 'normalized', ['i', 'j', 'k'], 3926)]
LDEs formed:1

endIndexOfSwapRate_ -> [('[i]', 'r', 'normalized', ['i', 'j', 'k'], 3925)]
LDEs formed:0

distinct LDEs:
j1=j2
#########################################################################################
loop info: Size i=alive  i<numberOfRates_  i++
induction variable: ['i']
{
L3926: (logForwards_[i]+=,w) (drifts1_[i]+,r) (fixedDrift[i],r) 
L3927: (logForwards_[i]+=,w) 
}
array table
-----------------------------------------------
fixedDrift -> [('[i]', 'r', 'normalized', ['i'], 3926)]
LDEs formed:0

drifts1_ -> [('[i]', 'r', 'normalized', ['i'], 3926)]
LDEs formed:0

logForwards_ -> [('[i]', 'w', 'normalized', ['i'], 3926), ('[i]', 'w', 'normalized', ['i'], 3927)]
LDEs formed:3

distinct LDEs:
i1=i2
#########################################################################################
loop info: Size i=alive  i<numberOfRates_  i++
induction variable: ['i']
{
L3928: (logForwards_[i]+=,w) (covariances_[currentStep_][i],r) 
}
array table
-----------------------------------------------
covariances_ -> [('[currentStep_][i]', 'r', 'not normalized', ['i'], 3928)]
LDEs formed:0

logForwards_ -> [('[i]', 'w', 'normalized', ['i'], 3928)]
LDEs formed:1

distinct LDEs:
i1=i2
#########################################################################################
loop info: Size k=0  k < numberOfFactors_  k++
induction variable: ['k']
{
L3929: (A[index][k],r) 
L3930: (brownians_[k]+,r) 
L3931: (brownians_[k],r) 
}
array table
-----------------------------------------------
A -> [('[index][k]', 'r', 'not normalized', ['k'], 3929)]
LDEs formed:0

brownians_ -> [('[k]', 'r', 'normalized', ['k'], 3930), ('[k]', 'r', 'normalized', ['k'], 3931)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/evolvers/lognormalcmswapratepc.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size j=0  j<steps  ++j
induction variable: ['j']
{
L3932: (numeraires[j],r) 
L3933: (alive_[j],r) 
	loop info: Size k=0  k<numberOfRates_  ++k
	induction variable: ['j', 'k']
	{
	L3934: (fixed[k]=,w) 
	}
 }
array table
-----------------------------------------------
alive_ -> [('[j]', 'r', 'normalized', ['j', 'k'], 3933)]
LDEs formed:0

fixed -> [('[k]', 'w', 'normalized', ['j', 'k'], 3934)]
LDEs formed:1

numeraires -> [('[j]', 'r', 'normalized', ['j', 'k'], 3932)]
LDEs formed:0

distinct LDEs:
k1=k2
#########################################################################################
loop info: i=alive  i<numberOfRates_  ++i
induction variable: ['i']
{
L3933: (logSwapRates_[i]+=,w) (drifts1_[i]+,r) (fixedDrift[i],r) 
L3934: (logSwapRates_[i]+=,w) 
L3935: (swapRates_[i]=,w) (logSwapRates_[i],r) (displacements_[i],r) 
}
array table
-----------------------------------------------
fixedDrift -> [('[i]', 'r', 'normalized', ['i'], 3933)]
LDEs formed:0

swapRates_ -> [('[i]', 'w', 'normalized', ['i'], 3935)]
LDEs formed:1

drifts1_ -> [('[i]', 'r', 'normalized', ['i'], 3933)]
LDEs formed:0

logSwapRates_ -> [('[i]', 'w', 'normalized', ['i'], 3933), ('[i]', 'w', 'normalized', ['i'], 3934), ('[i]', 'r', 'normalized', ['i'], 3935)]
LDEs formed:5

displacements_ -> [('[i]', 'r', 'normalized', ['i'], 3935)]
LDEs formed:0

distinct LDEs:
i1=i2
#########################################################################################
loop info: i=alive  i<numberOfRates_  ++i
induction variable: ['i']
{
L3936: (logSwapRates_[i]+=,w) (drifts2_[i]-,r) (drifts1_[i],r) 
L3937: (swapRates_[i]=,w) (logSwapRates_[i],r) (displacements_[i],r) 
}
array table
-----------------------------------------------
drifts2_ -> [('[i]', 'r', 'normalized', ['i'], 3936)]
LDEs formed:0

swapRates_ -> [('[i]', 'w', 'normalized', ['i'], 3937)]
LDEs formed:1

drifts1_ -> [('[i]', 'r', 'normalized', ['i'], 3936)]
LDEs formed:0

logSwapRates_ -> [('[i]', 'w', 'normalized', ['i'], 3936), ('[i]', 'r', 'normalized', ['i'], 3937)]
LDEs formed:2

displacements_ -> [('[i]', 'r', 'normalized', ['i'], 3937)]
LDEs formed:0

distinct LDEs:
i1=i2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/evolvers/lognormalfwdrateiballand.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size j=0  j<steps  ++j
induction variable: ['j']
{
L3938: (numeraires[j],r) 
L3939: (alive_[j],r) 
	loop info: Size k=0  k<numberOfRates_  ++k
	induction variable: ['j', 'k']
	{
	L3940: (C[k][k],r) 
	L3941: (fixed[k]=,w) 
	}
 }
array table
-----------------------------------------------
alive_ -> [('[j]', 'r', 'normalized', ['j', 'k'], 3939)]
LDEs formed:0

C -> [('[k][k]', 'r', 'normalized', ['j', 'k'], 3940)]
LDEs formed:0

fixed -> [('[k]', 'w', 'normalized', ['j', 'k'], 3941)]
LDEs formed:1

numeraires -> [('[j]', 'r', 'normalized', ['j', 'k'], 3938)]
LDEs formed:0

distinct LDEs:
k1=k2
#########################################################################################
L3939: (logForwards_[i]+=,w) (fixedDrift[i],r) 
L3940: (logForwards_[i]+=,w) 
L3941: (forwards_[i]=,w) (logForwards_[i],r) (displacements_[i],r) 
L3942: (forwards_[i],r) 
L3943: (g_[i]=,w) (rateTaus_[i]*,r) (displacements_[i],r) 
L3944: (rateTaus_[i]*,r) 
}
array table
-----------------------------------------------
fixedDrift -> [('[i]', 'r', 'normalized', ['i', 'j'], 3939)]
LDEs formed:0

rateTaus_ -> [('[i]', 'r', 'normalized', ['i', 'j'], 3943), ('[i]', 'r', 'normalized', ['i', 'j'], 3944)]
LDEs formed:0

displacements_ -> [('[i]', 'r', 'normalized', ['i', 'j'], 3941), ('[i]', 'r', 'normalized', ['i', 'j'], 3943)]
LDEs formed:0

g_ -> [('[i]', 'w', 'normalized', ['i', 'j'], 3943)]
LDEs formed:1

logForwards_ -> [('[i]', 'w', 'normalized', ['i', 'j'], 3939), ('[i]', 'w', 'normalized', ['i', 'j'], 3940), ('[i]', 'r', 'normalized', ['i', 'j'], 3941)]
LDEs formed:5

forwards_ -> [('[i]', 'w', 'normalized', ['i', 'j'], 3941), ('[i]', 'r', 'normalized', ['i', 'j'], 3942)]
LDEs formed:2

distinct LDEs:
i1=i2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/evolvers/lognormalfwdratepc.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size j=0  j<steps  ++j
induction variable: ['j']
{
L3943: (numeraires[j],r) 
L3944: (alive_[j],r) 
	loop info: Size k=0  k<numberOfRates_  ++k
	induction variable: ['j', 'k']
	{
	L3945: (fixed[k]=,w) 
	}
 }
array table
-----------------------------------------------
alive_ -> [('[j]', 'r', 'normalized', ['j', 'k'], 3944)]
LDEs formed:0

fixed -> [('[k]', 'w', 'normalized', ['j', 'k'], 3945)]
LDEs formed:1

numeraires -> [('[j]', 'r', 'normalized', ['j', 'k'], 3943)]
LDEs formed:0

distinct LDEs:
k1=k2
#########################################################################################
loop info: i=alive  i<numberOfRates_  ++i
induction variable: ['i']
{
L3944: (logForwards_[i]+=,w) (drifts1_[i]+,r) (fixedDrift[i],r) 
L3945: (logForwards_[i]+=,w) 
L3946: (forwards_[i]=,w) (logForwards_[i],r) (displacements_[i],r) 
}
array table
-----------------------------------------------
fixedDrift -> [('[i]', 'r', 'normalized', ['i'], 3944)]
LDEs formed:0

drifts1_ -> [('[i]', 'r', 'normalized', ['i'], 3944)]
LDEs formed:0

forwards_ -> [('[i]', 'w', 'normalized', ['i'], 3946)]
LDEs formed:1

displacements_ -> [('[i]', 'r', 'normalized', ['i'], 3946)]
LDEs formed:0

logForwards_ -> [('[i]', 'w', 'normalized', ['i'], 3944), ('[i]', 'w', 'normalized', ['i'], 3945), ('[i]', 'r', 'normalized', ['i'], 3946)]
LDEs formed:5

distinct LDEs:
i1=i2
#########################################################################################
loop info: i=alive  i<numberOfRates_  ++i
induction variable: ['i']
{
L3947: (logForwards_[i]+=,w) (drifts2_[i]-,r) (drifts1_[i],r) 
L3948: (forwards_[i]=,w) (logForwards_[i],r) (displacements_[i],r) 
}
array table
-----------------------------------------------
drifts2_ -> [('[i]', 'r', 'normalized', ['i'], 3947)]
LDEs formed:0

drifts1_ -> [('[i]', 'r', 'normalized', ['i'], 3947)]
LDEs formed:0

forwards_ -> [('[i]', 'w', 'normalized', ['i'], 3948)]
LDEs formed:1

displacements_ -> [('[i]', 'r', 'normalized', ['i'], 3948)]
LDEs formed:0

logForwards_ -> [('[i]', 'w', 'normalized', ['i'], 3947), ('[i]', 'r', 'normalized', ['i'], 3948)]
LDEs formed:2

distinct LDEs:
i1=i2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/evolvers/lognormalcotswapratepc.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size j=0  j<steps  ++j
induction variable: ['j']
{
L3949: (numeraires[j],r) 
L3950: (alive_[j],r) 
	loop info: Size k=0  k<numberOfRates_  ++k
	induction variable: ['j', 'k']
	{
	L3951: (fixed[k]=,w) 
	}
 }
array table
-----------------------------------------------
alive_ -> [('[j]', 'r', 'normalized', ['j', 'k'], 3950)]
LDEs formed:0

fixed -> [('[k]', 'w', 'normalized', ['j', 'k'], 3951)]
LDEs formed:1

numeraires -> [('[j]', 'r', 'normalized', ['j', 'k'], 3949)]
LDEs formed:0

distinct LDEs:
k1=k2
#########################################################################################
loop info: i=alive  i<numberOfRates_  ++i
induction variable: ['i']
{
L3950: (logSwapRates_[i]+=,w) (drifts1_[i]+,r) (fixedDrift[i],r) 
L3951: (logSwapRates_[i]+=,w) 
L3952: (swapRates_[i]=,w) (logSwapRates_[i],r) (displacements_[i],r) 
}
array table
-----------------------------------------------
fixedDrift -> [('[i]', 'r', 'normalized', ['i'], 3950)]
LDEs formed:0

swapRates_ -> [('[i]', 'w', 'normalized', ['i'], 3952)]
LDEs formed:1

drifts1_ -> [('[i]', 'r', 'normalized', ['i'], 3950)]
LDEs formed:0

logSwapRates_ -> [('[i]', 'w', 'normalized', ['i'], 3950), ('[i]', 'w', 'normalized', ['i'], 3951), ('[i]', 'r', 'normalized', ['i'], 3952)]
LDEs formed:5

displacements_ -> [('[i]', 'r', 'normalized', ['i'], 3952)]
LDEs formed:0

distinct LDEs:
i1=i2
#########################################################################################
loop info: i=alive  i<numberOfRates_  ++i
induction variable: ['i']
{
L3953: (logSwapRates_[i]+=,w) (drifts2_[i]-,r) (drifts1_[i],r) 
L3954: (swapRates_[i]=,w) (logSwapRates_[i],r) (displacements_[i],r) 
}
array table
-----------------------------------------------
drifts2_ -> [('[i]', 'r', 'normalized', ['i'], 3953)]
LDEs formed:0

swapRates_ -> [('[i]', 'w', 'normalized', ['i'], 3954)]
LDEs formed:1

drifts1_ -> [('[i]', 'r', 'normalized', ['i'], 3953)]
LDEs formed:0

logSwapRates_ -> [('[i]', 'w', 'normalized', ['i'], 3953), ('[i]', 'r', 'normalized', ['i'], 3954)]
LDEs formed:2

displacements_ -> [('[i]', 'r', 'normalized', ['i'], 3954)]
LDEs formed:0

distinct LDEs:
i1=i2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/evolvers/normalfwdratepc.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size j=0  j<steps  ++j
induction variable: ['j']
{
L3955: (numeraires[j],r) 
L3956: (alive_[j],r) 
	loop info: Size k=0  k<numberOfRates_  ++k
	induction variable: ['j', 'k']
	{
	}
 }
array table
-----------------------------------------------
alive_ -> [('[j]', 'r', 'normalized', ['j', 'k'], 3956)]
LDEs formed:0

numeraires -> [('[j]', 'r', 'normalized', ['j', 'k'], 3955)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: i=alive  i<numberOfRates_  ++i
induction variable: ['i']
{
L3956: (forwards_[i]+=,w) (drifts1_[i],r) 
L3957: (forwards_[i]+=,w) 
}
array table
-----------------------------------------------
drifts1_ -> [('[i]', 'r', 'normalized', ['i'], 3956)]
LDEs formed:0

forwards_ -> [('[i]', 'w', 'normalized', ['i'], 3956), ('[i]', 'w', 'normalized', ['i'], 3957)]
LDEs formed:3

distinct LDEs:
i1=i2
#########################################################################################
loop info: i=alive  i<numberOfRates_  ++i
induction variable: ['i']
{
L3958: (forwards_[i]+=,w) (drifts2_[i]-,r) (drifts1_[i],r) 
}
array table
-----------------------------------------------
drifts2_ -> [('[i]', 'r', 'normalized', ['i'], 3958)]
LDEs formed:0

drifts1_ -> [('[i]', 'r', 'normalized', ['i'], 3958)]
LDEs formed:0

forwards_ -> [('[i]', 'w', 'normalized', ['i'], 3958)]
LDEs formed:1

distinct LDEs:
i1=i2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/evolvers/lognormalfwdrateballand.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size j=0  j<steps  ++j
induction variable: ['j']
{
L3959: (numeraires[j],r) 
L3960: (alive_[j],r) 
	loop info: Size k=0  k<numberOfRates_  ++k
	induction variable: ['j', 'k']
	{
	L3961: (C[k][k],r) 
	L3962: (fixed[k]=,w) 
	}
 }
array table
-----------------------------------------------
alive_ -> [('[j]', 'r', 'normalized', ['j', 'k'], 3960)]
LDEs formed:0

C -> [('[k][k]', 'r', 'normalized', ['j', 'k'], 3961)]
LDEs formed:0

fixed -> [('[k]', 'w', 'normalized', ['j', 'k'], 3962)]
LDEs formed:1

numeraires -> [('[j]', 'r', 'normalized', ['j', 'k'], 3959)]
LDEs formed:0

distinct LDEs:
k1=k2
#########################################################################################
loop info:  i = alive  i < numberOfRates_   ++i 
induction variable: ['i']
{
L3960: (logForwards_[i]+=,w) (drifts1_[i]+,r) (fixedDrift[i],r) 
L3961: (logForwards_[i]+=,w) 
L3962: (forwards_[i]=,w) (logForwards_[i],r) (displacements_[i],r) 
}
array table
-----------------------------------------------
fixedDrift -> [('[i]', 'r', 'normalized', ['i'], 3960)]
LDEs formed:0

drifts1_ -> [('[i]', 'r', 'normalized', ['i'], 3960)]
LDEs formed:0

forwards_ -> [('[i]', 'w', 'normalized', ['i'], 3962)]
LDEs formed:1

displacements_ -> [('[i]', 'r', 'normalized', ['i'], 3962)]
LDEs formed:0

logForwards_ -> [('[i]', 'w', 'normalized', ['i'], 3960), ('[i]', 'w', 'normalized', ['i'], 3961), ('[i]', 'r', 'normalized', ['i'], 3962)]
LDEs formed:5

distinct LDEs:
i1=i2
#########################################################################################
loop info:  i = alive  i < numberOfRates_   ++i 
induction variable: ['i']
{
L3963: (forwards_[i]=,w) (forwards_[i]*,r) 
}
array table
-----------------------------------------------
forwards_ -> [('[i]', 'w', 'normalized', ['i'], 3963), ('[i]', 'r', 'normalized', ['i'], 3963)]
LDEs formed:2

distinct LDEs:
i1=i2
#########################################################################################
loop info:  i = alive  i < numberOfRates_   ++i 
induction variable: ['i']
{
L3964: (logForwards_[i]+=,w) (drifts2_[i]-,r) (drifts1_[i],r) 
L3965: (forwards_[i]=,w) (logForwards_[i],r) (displacements_[i],r) 
}
array table
-----------------------------------------------
drifts2_ -> [('[i]', 'r', 'normalized', ['i'], 3964)]
LDEs formed:0

drifts1_ -> [('[i]', 'r', 'normalized', ['i'], 3964)]
LDEs formed:0

forwards_ -> [('[i]', 'w', 'normalized', ['i'], 3965)]
LDEs formed:1

displacements_ -> [('[i]', 'r', 'normalized', ['i'], 3965)]
LDEs formed:0

logForwards_ -> [('[i]', 'w', 'normalized', ['i'], 3964), ('[i]', 'r', 'normalized', ['i'], 3965)]
LDEs formed:2

distinct LDEs:
i1=i2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/evolvers/svddfwdratepc.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size j=0  j<steps  ++j
induction variable: ['j']
{
L3966: (numeraires[j],r) 
L3967: (alive_[j],r) 
	loop info: Size k=0  k<numberOfRates_  ++k
	induction variable: ['j', 'k']
	{
	L3968: (fixed[k]=,w) 
	}
 }
array table
-----------------------------------------------
alive_ -> [('[j]', 'r', 'normalized', ['j', 'k'], 3967)]
LDEs formed:0

fixed -> [('[k]', 'w', 'normalized', ['j', 'k'], 3968)]
LDEs formed:1

numeraires -> [('[j]', 'r', 'normalized', ['j', 'k'], 3966)]
LDEs formed:0

distinct LDEs:
k1=k2
#########################################################################################
loop info: Size i=0, j=0, k=0  i < allBrownians_.size()  ++i
induction variable: ['i']
{
L3967: (volBrownians_[j]=,w) (allBrownians_[i],r) 
}
array table
-----------------------------------------------
allBrownians_ -> [('[i]', 'r', 'normalized', ['i'], 3967)]
LDEs formed:0

volBrownians_ -> [('[j]', 'w', 'not normalized', ['i'], 3967)]
LDEs formed:1

distinct LDEs:
j=j
#########################################################################################
loop info: Size i=alive  i<numberOfRates_  ++i
induction variable: ['i']
{
L3968: (logForwards_[i]+=,w) (drifts1_[i]+,r) (fixedDrift[i],r) 
L3969: (logForwards_[i]+=,w) 
L3970: (forwards_[i]=,w) (logForwards_[i],r) (displacements_[i],r) 
}
array table
-----------------------------------------------
fixedDrift -> [('[i]', 'r', 'normalized', ['i'], 3968)]
LDEs formed:0

drifts1_ -> [('[i]', 'r', 'normalized', ['i'], 3968)]
LDEs formed:0

forwards_ -> [('[i]', 'w', 'normalized', ['i'], 3970)]
LDEs formed:1

displacements_ -> [('[i]', 'r', 'normalized', ['i'], 3970)]
LDEs formed:0

logForwards_ -> [('[i]', 'w', 'normalized', ['i'], 3968), ('[i]', 'w', 'normalized', ['i'], 3969), ('[i]', 'r', 'normalized', ['i'], 3970)]
LDEs formed:5

distinct LDEs:
i1=i2
#########################################################################################
loop info: Size i=alive  i<numberOfRates_  ++i
induction variable: ['i']
{
L3971: (logForwards_[i]+=,w) (drifts2_[i]-,r) (drifts1_[i],r) 
L3972: (forwards_[i]=,w) (logForwards_[i],r) (displacements_[i],r) 
}
array table
-----------------------------------------------
drifts2_ -> [('[i]', 'r', 'normalized', ['i'], 3971)]
LDEs formed:0

drifts1_ -> [('[i]', 'r', 'normalized', ['i'], 3971)]
LDEs formed:0

forwards_ -> [('[i]', 'w', 'normalized', ['i'], 3972)]
LDEs formed:1

displacements_ -> [('[i]', 'r', 'normalized', ['i'], 3972)]
LDEs formed:0

logForwards_ -> [('[i]', 'w', 'normalized', ['i'], 3971), ('[i]', 'r', 'normalized', ['i'], 3972)]
LDEs formed:2

distinct LDEs:
i1=i2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/evolvers/volprocesses/squarerootandersen.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=1  i < evolutionTimes.size()  ++i
induction variable: ['i']
{
L3973: (evolutionTimes[i]-,r) (evolutionTimes[i-1],r) 
	loop info: Size k=0  k < numberSubSteps_  ++k
	induction variable: ['i', 'k']
	{
	L3974: (dt_[j]=,w) 
	L3975: (eMinuskDt_[j]=,w) 
	}
 }
array table
-----------------------------------------------
dt_ -> [('[j]', 'w', 'not normalized', ['i', 'k'], 3974)]
LDEs formed:1

evolutionTimes -> [('[i]', 'r', 'normalized', ['i', 'k'], 3973), ('[i-1]', 'r', 'normalized', ['i', 'k'], 3973)]
LDEs formed:0

eMinuskDt_ -> [('[j]', 'w', 'not normalized', ['i', 'k'], 3975)]
LDEs formed:1

distinct LDEs:
j=j
#########################################################################################
loop info: Size j=0  j < numberSubSteps_  ++j
induction variable: ['j']
{
L3976: (variates[j],r) 
L3977: (vPath_[subStep_]=,w) 
}
array table
-----------------------------------------------
vPath_ -> [('[subStep_]', 'w', 'not normalized', ['j'], 3977)]
LDEs formed:1

variates -> [('[j]', 'r', 'normalized', ['j'], 3976)]
LDEs formed:0

distinct LDEs:
subStep_=subStep_
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/correlations/cotswapfromfwdcorrelation.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size k = 0  k<fwdCorrMatrices.size()  ++k
induction variable: ['k']
{
L3977: (swapCorrMatrices_[k]=,w) 
L3978: (fwdCorrMatrices[k]*,r) 
	loop info: Size i=0  i<numberOfRates_  ++i
	induction variable: ['k', 'i']
	{
	}
 }
array table
-----------------------------------------------
fwdCorrMatrices -> [('[k]', 'r', 'normalized', ['k', 'i'], 3978)]
LDEs formed:0

swapCorrMatrices_ -> [('[k]', 'w', 'normalized', ['k', 'i'], 3977)]
LDEs formed:1

distinct LDEs:
k1=k2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/correlations/expcorrelations.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<nbRows  ++i
induction variable: ['i']
{
L3978: (rateTimes[i],r) 
L3979: (correlations[i][i]=,w) 
	loop info: Size j=0  j<i  ++j
	induction variable: ['i', 'j']
		{
		L3980: (rateTimes[j],r) 
		L3981: (correlations[i][j]=,w) (correlations[j][i]=,w) 
		L3982: (rateTimes[i]-,r) 
		L3983: (rateTimes[j]-,r) 
		}
 }
array table
-----------------------------------------------
rateTimes -> [('[i]', 'r', 'normalized', ['i', 'j'], 3978), ('[j]', 'r', 'normalized', ['i', 'j'], 3980), ('[i]', 'r', 'normalized', ['i', 'j'], 3982), ('[j]', 'r', 'normalized', ['i', 'j'], 3983)]
LDEs formed:0

correlations -> [('[i][i]', 'w', 'normalized', ['i', 'j'], 3979), ('[i][j]', 'w', 'normalized', ['i', 'j'], 3981), ('[j][i]', 'w', 'normalized', ['i', 'j'], 3981)]
LDEs formed:12

distinct LDEs:
j1=j2,i1=i2
i1=i2,j1=j2
i1=j2,i1=i2
i1=i2,i1=j2
i1=j2,j1=i2
i1=i2,i1=i2
#########################################################################################
loop info: Size k=1  k<times_.size()  ++k
induction variable: ['k']
{
L3982: (times_[k]+,r) (times_[k-1],r) 
L3983: (correlations_[k]=,w) 
}
array table
-----------------------------------------------
correlations_ -> [('[k]', 'w', 'normalized', ['k'], 3983)]
LDEs formed:1

times_ -> [('[k]', 'r', 'normalized', ['k'], 3982), ('[k-1]', 'r', 'normalized', ['k'], 3982)]
LDEs formed:0

distinct LDEs:
k1=k2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/correlations/timehomogeneousforwardcorrelation.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

	loop info: Size i=k  i<numberOfRates  ++i
	induction variable: ['k', 'i']
	{
		loop info: Size j=k  j<i  ++j
		induction variable: ['k', 'i', 'j']
		{
		L3983: (correlations[k][i][j]=,w) (correlations[k][j][i]=,w) 
		L3984: (fwdCorrelation[i-k][j-k],r) 
		}
 	}
 }
array table
-----------------------------------------------
correlations -> [('[k][i][j]', 'w', 'normalized', ['k', 'i', 'j'], 3983), ('[k][j][i]', 'w', 'normalized', ['k', 'i', 'j'], 3983)]
LDEs formed:9

fwdCorrelation -> [('[i-k][j-k]', 'r', 'normalized', ['k', 'i', 'j'], 3984)]
LDEs formed:0

distinct LDEs:
k1=k2,i1=i2,j1=j2
k1=k2,j1=j2,i1=i2
k1=k2,i1=j2,j1=i2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/callability/parametricexerciseadapter.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<evolutionTimes.size()  ++i
induction variable: ['i']
{
L3985: (isExerciseTime_[i],r) 
L3986: (evolutionTimes[i],r) 
}
array table
-----------------------------------------------
isExerciseTime_ -> [('[i]', 'r', 'normalized', ['i'], 3985)]
LDEs formed:0

evolutionTimes -> [('[i]', 'r', 'normalized', ['i'], 3986)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/callability/lsstrategy.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: i=0  i<relevantTimes_.size()  ++i
induction variable: ['i']
{
L3987: (exerciseIndex_[i]=,w) 
L3988: (isRebateTime_[i],r) 
L3989: (isExerciseTime_[i]=,w) (v[idx++],r) 
L3990: (isExerciseTime_[i],r) 
L3991: (relevantTimes_[i],r) 
}
array table
-----------------------------------------------
isRebateTime_ -> [('[i]', 'r', 'normalized', ['i'], 3988)]
LDEs formed:0

relevantTimes_ -> [('[i]', 'r', 'normalized', ['i'], 3991)]
LDEs formed:0

isExerciseTime_ -> [('[i]', 'w', 'normalized', ['i'], 3989), ('[i]', 'r', 'normalized', ['i'], 3990)]
LDEs formed:2

v -> [('[idx++]', 'r', 'not normalized', ['i'], 3989)]
LDEs formed:0

exerciseIndex_ -> [('[i]', 'w', 'normalized', ['i'], 3987)]
LDEs formed:1

distinct LDEs:
i1=i2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/callability/swapratetrigger.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<exerciseTimes.size()  ++i
induction variable: ['i']
{
L3988: (rateTimes[j],r) (exerciseTimes[i],r) 
L3989: (rateIndex_[i]=,w) 
}
array table
-----------------------------------------------
rateTimes -> [('[j]', 'r', 'not normalized', ['i'], 3988)]
LDEs formed:0

rateIndex_ -> [('[i]', 'w', 'normalized', ['i'], 3989)]
LDEs formed:1

exerciseTimes -> [('[i]', 'r', 'normalized', ['i'], 3988)]
LDEs formed:0

distinct LDEs:
i1=i2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/callability/triggeredswapexercise.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<exerciseTimes.size()  ++i
induction variable: ['i']
{
L3989: (rateTimes[j],r) (exerciseTimes[i],r) 
L3990: (rateIndex_[i]=,w) 
}
array table
-----------------------------------------------
rateTimes -> [('[j]', 'r', 'not normalized', ['i'], 3989)]
LDEs formed:0

rateIndex_ -> [('[i]', 'w', 'normalized', ['i'], 3990)]
LDEs formed:1

exerciseTimes -> [('[i]', 'r', 'normalized', ['i'], 3989)]
LDEs formed:0

distinct LDEs:
i1=i2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/callability/collectnodedata.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: i=0  i<evolutionTimes.size()  ++i
induction variable: ['i']
{
L3990: (isRebateTime[i],r) 
L3991: (v[idx++],r) 
L3992: (isExerciseTime[i]=,w) 
}
array table
-----------------------------------------------
isRebateTime -> [('[i]', 'r', 'normalized', ['i'], 3990)]
LDEs formed:0

isExerciseTime -> [('[i]', 'w', 'normalized', ['i'], 3992)]
LDEs formed:1

v -> [('[idx++]', 'r', 'not normalized', ['i'], 3991)]
LDEs formed:0

distinct LDEs:
i1=i2
#########################################################################################
loop info: i=0  i<numberOfPaths  ++i
induction variable: ['i']
{
L3992: (collectedData[0][i].cumulatedCashFlows=,w) 
L3993: (numeraires[currentStep],r) 
L3994: (isRebateTime[currentStep],r) 
L3995: (isControlTime[currentStep],r) 
L3996: (isBasisTime[currentStep],r) 
L3997: (isExerciseTime[currentStep],r) 
L3998: (collectedData[nextExercise+1][i],r) 
L3999: (rebateDiscounters[exerciseValue.timeIndex],r) 
L4000: (controlDiscounters[controlValue.timeIndex],r) 
L4001: (isProductTime[currentStep],r) 
	loop info: Size j=0  j<numberCashFlowsThisStep[0]  ++j
	induction variable: ['i', 'j']
			{
			L4002: (cashFlowsGenerated[0][j],r) 
			L4003: (collectedData[nextExercise][i].cumulatedCashFlows+=,w) 
			L4004: (productDiscounters[cf.timeIndex],r) 
			}
L4005: (numeraires[currentStep+1],r) 
	loop info: Size j = nextExercise  j < exercises  ++j
	induction variable: ['i', 'j']
	{
	L4006: (collectedData[j+1][i],r) 
	}
 }
array table
-----------------------------------------------
isRebateTime -> [('[currentStep]', 'r', 'not normalized', ['i', 'j'], 3994)]
LDEs formed:0

collectedData -> [('[0][i]', 'w', 'normalized', ['i', 'j'], 3992), ('[nextExercise+1][i]', 'r', 'not normalized', ['i', 'j'], 3998), ('[nextExercise][i]', 'w', 'not normalized', ['i', 'j'], 4003), ('[j+1][i]', 'r', 'normalized', ['i', 'j'], 4006)]
LDEs formed:14

isExerciseTime -> [('[currentStep]', 'r', 'not normalized', ['i', 'j'], 3997)]
LDEs formed:0

controlDiscounters -> [('[controlValue.timeIndex]', 'r', 'not normalized', ['i', 'j'], 4000)]
LDEs formed:0

rebateDiscounters -> [('[exerciseValue.timeIndex]', 'r', 'not normalized', ['i', 'j'], 3999)]
LDEs formed:0

cashFlowsGenerated -> [('[0][j]', 'r', 'normalized', ['i', 'j'], 4002)]
LDEs formed:0

isBasisTime -> [('[currentStep]', 'r', 'not normalized', ['i', 'j'], 3996)]
LDEs formed:0

isControlTime -> [('[currentStep]', 'r', 'not normalized', ['i', 'j'], 3995)]
LDEs formed:0

numeraires -> [('[currentStep]', 'r', 'not normalized', ['i', 'j'], 3993), ('[currentStep+1]', 'r', 'not normalized', ['i', 'j'], 4005)]
LDEs formed:0

productDiscounters -> [('[cf.timeIndex]', 'r', 'not normalized', ['i', 'j'], 4004)]
LDEs formed:0

isProductTime -> [('[currentStep]', 'r', 'not normalized', ['i', 'j'], 4001)]
LDEs formed:0

distinct LDEs:
nextExercise=nextExercise,i1=i2
0=0,i1=i2
0=nextExercise+1,i1=i2
0=j2+1,i1=i2
nextExercise+1=nextExercise,i1=i2
nextExercise=j2+1,i1=i2
0=nextExercise,i1=i2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/callability/nothingexercisevalue.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/callability/swapbasissystem.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<exerciseTimes.size()  ++i
induction variable: ['i']
{
L4002: (rateTimes[j],r) (exerciseTimes[i],r) 
L4003: (rateIndex_[i]=,w) 
}
array table
-----------------------------------------------
rateTimes -> [('[j]', 'r', 'not normalized', ['i'], 4002)]
LDEs formed:0

rateIndex_ -> [('[i]', 'w', 'normalized', ['i'], 4003)]
LDEs formed:1

exerciseTimes -> [('[i]', 'r', 'normalized', ['i'], 4002)]
LDEs formed:0

distinct LDEs:
i1=i2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/callability/swapforwardbasissystem.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<exerciseTimes.size()  ++i
induction variable: ['i']
{
L4003: (rateTimes[j],r) (exerciseTimes[i],r) 
L4004: (rateIndex_[i]=,w) 
}
array table
-----------------------------------------------
rateTimes -> [('[j]', 'r', 'not normalized', ['i'], 4003)]
LDEs formed:0

rateIndex_ -> [('[i]', 'w', 'normalized', ['i'], 4004)]
LDEs formed:1

exerciseTimes -> [('[i]', 'r', 'normalized', ['i'], 4003)]
LDEs formed:0

distinct LDEs:
i1=i2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/callability/upperboundengine.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size k=0  k<numberOfSteps_  ++k
induction variable: ['k']
{
L4004: (isExerciseTime_[k],r) 
L4005: (innerEvolvers_[exercise++],r) 
}
array table
-----------------------------------------------
isExerciseTime_ -> [('[k]', 'r', 'normalized', ['k'], 4004)]
LDEs formed:0

innerEvolvers_ -> [('[exercise++]', 'r', 'not normalized', ['k'], 4005)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=beginProduct  i<endProduct  ++i
induction variable: ['i']
{
L4006: (cashFlowsGenerated_[i],r) 
	loop info: Size j=0  j<numberCashFlowsThisStep_[i]  ++j
	induction variable: ['i', 'j']
	{
	L4007: (cashflows[j].timeIndex,r) 
	L4008: (cashflows[j].amount*,r) 
	}
 }
array table
-----------------------------------------------
cashFlowsGenerated_ -> [('[i]', 'r', 'normalized', ['i', 'j'], 4006)]
LDEs formed:0

cashflows -> [('[j]', 'r', 'normalized', ['i', 'j'], 4007), ('[j]', 'r', 'normalized', ['i', 'j'], 4008)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/products/multiproductmultistep.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<n  ++i
induction variable: ['i']
{
L4009: (evolutionTimes[i]=,w) (rateTimes_[i],r) 
L4010: (relevanceRates[i]=,w) 
}
array table
-----------------------------------------------
relevanceRates -> [('[i]', 'w', 'normalized', ['i'], 4010)]
LDEs formed:1

evolutionTimes -> [('[i]', 'w', 'normalized', ['i'], 4009)]
LDEs formed:1

rateTimes_ -> [('[i]', 'r', 'normalized', ['i'], 4009)]
LDEs formed:0

distinct LDEs:
i1=i2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/products/multiproductcomposite.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: iterator i=components_.begin()  i!=components_.end()  ++i, ++n
induction variable: ['i', 'n']
{
L4010: (isInSubset_[n][currentIndex_]&,r) 
	loop info: Size j=0  j<i->product->numberOfProducts()  ++j
	induction variable: ['i', 'n', 'j']
		{
		L4011: (numberCashFlowsThisStep[j+offset]=,w) 
		L4012: (numberOfCashflows[j],r) 
			loop info: Size k=0  k<i->numberOfCashflows[j]  ++k
			induction variable: ['i', 'n', 'j', 'k']
			{
			L4013: (cashflows[j][k],r) 
			L4014: (cashFlowsGenerated[j+offset][k],r) 
			L4015: (timeIndices[from.timeIndex],r) 
			}
 		}
	loop info: Size j=0  j<i->product->numberOfProducts()  ++j
	induction variable: ['i', 'n', 'j', 'k']
	{
	}
 }
array table
-----------------------------------------------
cashflows -> [('[j][k]', 'r', 'normalized', ['i', 'n', 'j', 'k'], 4013)]
LDEs formed:0

numberCashFlowsThisStep -> [('[j+offset]', 'w', 'not normalized', ['i', 'n', 'j', 'k'], 4011)]
LDEs formed:1

isInSubset_ -> [('[n][currentIndex_]', 'r', 'not normalized', ['i', 'n', 'j', 'k'], 4010)]
LDEs formed:0

timeIndices -> [('[from.timeIndex]', 'r', 'not normalized', ['i', 'n', 'j', 'k'], 4015)]
LDEs formed:0

numberOfCashflows -> [('[j]', 'r', 'normalized', ['i', 'n', 'j', 'k'], 4012)]
LDEs formed:0

cashFlowsGenerated -> [('[j+offset][k]', 'r', 'not normalized', ['i', 'n', 'j', 'k'], 4014)]
LDEs formed:0

distinct LDEs:
j1+offset=j2+offset
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/products/singleproductcomposite.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: iterator i=components_.begin()  i!=components_.end()  ++i, ++n
induction variable: ['i', 'n']
{
L4015: (isInSubset_[n][currentIndex_]&,r) 
	loop info: Size j=0  j<i->product->numberOfProducts()  ++j
	induction variable: ['i', 'n', 'j']
		{
		L4016: (numberOfCashflows[j],r) 
			loop info: Size k=0  k<i->numberOfCashflows[j]  ++k
			induction variable: ['i', 'n', 'j', 'k']
			{
			L4017: (cashflows[j][k],r) 
			L4018: (cashFlowsGenerated[0][k+offset],r) 
			L4019: (timeIndices[from.timeIndex],r) 
			}
		L4020: (numberCashFlowsThisStep[0]=,w) 
		}
 }
array table
-----------------------------------------------
cashflows -> [('[j][k]', 'r', 'normalized', ['i', 'n', 'j', 'k'], 4017)]
LDEs formed:0

numberCashFlowsThisStep -> [('[0]', 'w', 'normalized', ['i', 'n', 'j', 'k'], 4020)]
LDEs formed:1

isInSubset_ -> [('[n][currentIndex_]', 'r', 'not normalized', ['i', 'n', 'j', 'k'], 4015)]
LDEs formed:0

timeIndices -> [('[from.timeIndex]', 'r', 'not normalized', ['i', 'n', 'j', 'k'], 4019)]
LDEs formed:0

numberOfCashflows -> [('[j]', 'r', 'normalized', ['i', 'n', 'j', 'k'], 4016)]
LDEs formed:0

cashFlowsGenerated -> [('[0][k+offset]', 'r', 'not normalized', ['i', 'n', 'j', 'k'], 4018)]
LDEs formed:0

distinct LDEs:
0=0
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/products/compositeproduct.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: i=components_.begin()  i!=components_.end()  ++i
induction variable: ['i']
{
	loop info: Size j=0  j<productTimes.size()  ++j
	induction variable: ['i', 'j']
	{
	L4019: (timeIndices[j]=,w) 
	L4020: (productTimes[j],r) 
	}
 }
array table
-----------------------------------------------
timeIndices -> [('[j]', 'w', 'normalized', ['i', 'j'], 4019)]
LDEs formed:1

productTimes -> [('[j]', 'r', 'normalized', ['i', 'j'], 4020)]
LDEs formed:0

distinct LDEs:
j1=j2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/products/multistep/callspecifiedmultiproduct.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/products/multistep/multisteptarn.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/products/multistep/multistepcoinitialswaps.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=currentIndex_ i<lastIndex_ i++
induction variable: ['i']
{
L4021: (genCashFlows[i][0].timeIndex=,w) 
L4022: (genCashFlows[i][0].amount=,w) 
L4023: (fixedAccruals_[currentIndex_],r) 
L4024: (genCashFlows[i][1].timeIndex=,w) 
L4025: (genCashFlows[i][1].amount=,w) 
L4026: (floatingAccruals_[currentIndex_],r) 
L4027: (numberCashFlowsThisStep[i]=,w) 
}
array table
-----------------------------------------------
fixedAccruals_ -> [('[currentIndex_]', 'r', 'not normalized', ['i'], 4023)]
LDEs formed:0

genCashFlows -> [('[i][0]', 'w', 'normalized', ['i'], 4021), ('[i][0]', 'w', 'normalized', ['i'], 4022), ('[i][1]', 'w', 'normalized', ['i'], 4024), ('[i][1]', 'w', 'normalized', ['i'], 4025)]
LDEs formed:20

numberCashFlowsThisStep -> [('[i]', 'w', 'normalized', ['i'], 4027)]
LDEs formed:1

floatingAccruals_ -> [('[currentIndex_]', 'r', 'not normalized', ['i'], 4026)]
LDEs formed:0

distinct LDEs:
i1=i2,1=1
i1=i2,0=0
i1=i2,0=1
i1=i2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/products/multistep/multisteppathwisewrapper.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i < numberOfProducts_  ++i
induction variable: ['i']
{
L4027: (cashFlowsGenerated[i][j].timeIndex=,w) (cashFlowsGenerated_[i][j].timeIndex,r) 
L4028: (cashFlowsGenerated[i][j].amount=,w) (cashFlowsGenerated_[i][j].amount,r) 
}
array table
-----------------------------------------------
cashFlowsGenerated_ -> [('[i][j]', 'r', 'not normalized', ['i'], 4027), ('[i][j]', 'r', 'not normalized', ['i'], 4028)]
LDEs formed:0

cashFlowsGenerated -> [('[i][j]', 'w', 'not normalized', ['i'], 4027), ('[i][j]', 'w', 'not normalized', ['i'], 4028)]
LDEs formed:6

distinct LDEs:
i1=i2,j=j
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/products/multistep/cashrebate.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<numberOfProducts_  ++i
induction variable: ['i']
{
L4029: (numberCashFlowsThisStep[i]=,w) 
L4030: (genCashFlows[i][0].timeIndex=,w) 
L4031: (genCashFlows[i][0].amount=,w) (amounts_[i][currentIndex_],r) 
}
array table
-----------------------------------------------
genCashFlows -> [('[i][0]', 'w', 'normalized', ['i'], 4030), ('[i][0]', 'w', 'normalized', ['i'], 4031)]
LDEs formed:6

numberCashFlowsThisStep -> [('[i]', 'w', 'normalized', ['i'], 4029)]
LDEs formed:1

amounts_ -> [('[i][currentIndex_]', 'r', 'not normalized', ['i'], 4031)]
LDEs formed:0

distinct LDEs:
i1=i2,0=0
i1=i2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/products/multistep/multistepperiodcapletswaptions.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: unsigned long i=0  i < numberPeriods  ++i
induction variable: ['i']
{
L4032: (rateTimes_[currentIndex_+(i+1)*period_]-,r) (rateTimes_[currentIndex_+i*period_],r) 
}
array table
-----------------------------------------------
rateTimes_ -> [('[currentIndex_+(i+1)*period_]', 'r', 'not normalized', ['i'], 4032), ('[currentIndex_+i*period_]', 'r', 'not normalized', ['i'], 4032)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/products/multistep/multistepcoterminalswaps.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0 i<=currentIndex_ i++
induction variable: ['i']
{
L4033: (genCashFlows[i][0].timeIndex=,w) 
L4034: (genCashFlows[i][0].amount=,w) 
L4035: (fixedAccruals_[currentIndex_],r) 
L4036: (genCashFlows[i][1].timeIndex=,w) 
L4037: (genCashFlows[i][1].amount=,w) 
L4038: (floatingAccruals_[currentIndex_],r) 
L4039: (numberCashFlowsThisStep[i]=,w) 
}
array table
-----------------------------------------------
fixedAccruals_ -> [('[currentIndex_]', 'r', 'not normalized', ['i'], 4035)]
LDEs formed:0

genCashFlows -> [('[i][0]', 'w', 'normalized', ['i'], 4033), ('[i][0]', 'w', 'normalized', ['i'], 4034), ('[i][1]', 'w', 'normalized', ['i'], 4036), ('[i][1]', 'w', 'normalized', ['i'], 4037)]
LDEs formed:20

numberCashFlowsThisStep -> [('[i]', 'w', 'normalized', ['i'], 4039)]
LDEs formed:1

floatingAccruals_ -> [('[currentIndex_]', 'r', 'not normalized', ['i'], 4038)]
LDEs formed:0

distinct LDEs:
i1=i2,1=1
i1=i2,0=0
i1=i2,0=1
i1=i2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/products/pathwise/pathwiseproductswaption.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size k=currentIndex_  k < numberRates_  ++k
induction variable: ['k']
{
L4039: (cashFlowsGenerated[currentIndex_][0].amount,r) (rateTimes_[k+1]-,r) (rateTimes_[k],r) 
L4040: (rateTimes_[k+1]-,r) (rateTimes_[k],r) 
	loop info: Size l=k  l < numberRates_  ++l
	induction variable: ['k', 'l']
	{
	}
 }
array table
-----------------------------------------------
cashFlowsGenerated -> [('[currentIndex_][0]', 'r', 'not normalized', ['k', 'l'], 4039)]
LDEs formed:0

rateTimes_ -> [('[k+1]', 'r', 'normalized', ['k', 'l'], 4039), ('[k]', 'r', 'normalized', ['k', 'l'], 4039), ('[k+1]', 'r', 'normalized', ['k', 'l'], 4040), ('[k]', 'r', 'normalized', ['k', 'l'], 4040)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size k=currentIndex_  k < numberRates_  ++k
induction variable: ['k']
{
L4041: (forwards_[k]+=,w) 
L4042: (forwards_[k]-=,w) 
L4043: (forwards_[k]-=,w) 
L4044: (strikes_[currentIndex_],r) 
L4045: (strikes_[currentIndex_],r) 
L4046: (cashFlowsGenerated[currentIndex_][0].amount,r) 
}
array table
-----------------------------------------------
strikes_ -> [('[currentIndex_]', 'r', 'not normalized', ['k'], 4044), ('[currentIndex_]', 'r', 'not normalized', ['k'], 4045)]
LDEs formed:0

forwards_ -> [('[k]', 'w', 'normalized', ['k'], 4041), ('[k]', 'w', 'normalized', ['k'], 4042), ('[k]', 'w', 'normalized', ['k'], 4043)]
LDEs formed:6

cashFlowsGenerated -> [('[currentIndex_][0]', 'r', 'not normalized', ['k'], 4046)]
LDEs formed:0

distinct LDEs:
k1=k2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/products/pathwise/pathwiseproductcaplet.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i <= currentIndex_  ++i
induction variable: ['i']
{
L4047: (cashFlowsGenerated[currentIndex_][0].amount,r) (accruals_[i]*,r) 
L4048: (cashFlowsGenerated[currentIndex_][0].amount,r) 
}
array table
-----------------------------------------------
accruals_ -> [('[i]', 'r', 'normalized', ['i'], 4047)]
LDEs formed:0

cashFlowsGenerated -> [('[currentIndex_][0]', 'r', 'not normalized', ['i'], 4047), ('[currentIndex_][0]', 'r', 'not normalized', ['i'], 4048)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size j=0  j < startsAndEnds_.size()  ++j
induction variable: ['j']
{
L4049: (startsAndEnds_[j].first,r) (startsAndEnds_[j].second,r) (startsAndEnds_[j].first<<,r) (startsAndEnds_[j].second,r) 
L4050: (startsAndEnds_[j].second,r) (startsAndEnds_[j].first<<,r) (startsAndEnds_[j].second,r) 
}
array table
-----------------------------------------------
startsAndEnds_ -> [('[j]', 'r', 'normalized', ['j'], 4049), ('[j]', 'r', 'normalized', ['j'], 4049), ('[j]', 'r', 'normalized', ['j'], 4049), ('[j]', 'r', 'normalized', ['j'], 4049), ('[j]', 'r', 'normalized', ['j'], 4050), ('[j]', 'r', 'normalized', ['j'], 4050), ('[j]', 'r', 'normalized', ['j'], 4050)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i <  innerCashFlowsGenerated_.size()  ++i
induction variable: ['i']
{
L4051: (innerCashFlowsGenerated_[i].resize,r) 
	loop info: Size j=0  j < underlyingCaplets_.maxNumberOfCashFlowsPerProductPerStep()  ++j
	induction variable: ['i', 'j']
	{
	}
 }
array table
-----------------------------------------------
innerCashFlowsGenerated_ -> [('[i]', 'r', 'normalized', ['i', 'j'], 4051)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size j=0  j < numberRates_  ++j
induction variable: ['j']
{
L4052: (innerCashFlowSizes_[j],r) 
	loop info: Size k=0  k < startsAndEnds_.size()  ++k
	induction variable: ['j', 'k']
		{
		L4053: (startsAndEnds_[k].first,r) (startsAndEnds_[k].second,r) 
			loop info: Size l=0  l < innerCashFlowSizes_[j]  ++l
			induction variable: ['j', 'k', 'l']
				{
				}
 		}
 }
array table
-----------------------------------------------
startsAndEnds_ -> [('[k]', 'r', 'normalized', ['j', 'k', 'l'], 4053), ('[k]', 'r', 'normalized', ['j', 'k', 'l'], 4053)]
LDEs formed:0

innerCashFlowSizes_ -> [('[j]', 'r', 'normalized', ['j', 'k', 'l'], 4052)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/products/pathwise/pathwiseproductcashrebate.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<numberOfProducts_  ++i
induction variable: ['i']
{
L4053: (numberCashFlowsThisStep[i]=,w) 
L4054: (cashFlowsGenerated[i][0].timeIndex=,w) 
L4055: (cashFlowsGenerated[i][0].amount,r) (amounts_[i][currentIndex_],r) 
	loop info: Size k=1  k <= evolution_.numberOfRates()  ++k
	induction variable: ['i', 'k']
	{
	}
 }
array table
-----------------------------------------------
amounts_ -> [('[i][currentIndex_]', 'r', 'not normalized', ['i', 'k'], 4055)]
LDEs formed:0

numberCashFlowsThisStep -> [('[i]', 'w', 'normalized', ['i', 'k'], 4053)]
LDEs formed:1

cashFlowsGenerated -> [('[i][0]', 'w', 'normalized', ['i', 'k'], 4054), ('[i][0]', 'r', 'normalized', ['i', 'k'], 4055)]
LDEs formed:4

distinct LDEs:
i1=i2,0=0
i1=i2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/products/pathwise/pathwiseproductinversefloater.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/products/pathwise/pathwiseproductcallspecified.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/products/pathwise/pathwiseproductswap.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/products/onestep/onestepcoterminalswaps.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size indexOfTime=0 indexOfTime<lastIndex_ indexOfTime++
induction variable: ['indexOfTime']
{
	loop info: Size i=0 i<=indexOfTime i++
	induction variable: ['indexOfTime', 'i']
	{
	L4056: (genCashFlows[i][(indexOfTime-i)*2].timeIndex=,w) 
	L4057: (genCashFlows[i][(indexOfTime-i)*2].amount=,w) 
	L4058: (fixedAccruals_[indexOfTime],r) 
	L4059: (genCashFlows[i][(indexOfTime-i)*2+1].timeIndex=,w) 
	L4060: (genCashFlows[i][(indexOfTime-i)*2+1].amount=,w) 
	L4061: (floatingAccruals_[indexOfTime],r) 
	L4062: (numberCashFlowsThisStep[i]+=,w) 
	}
 }
array table
-----------------------------------------------
fixedAccruals_ -> [('[indexOfTime]', 'r', 'normalized', ['indexOfTime', 'i'], 4058)]
LDEs formed:0

genCashFlows -> [('[i][(indexOfTime-i)*2]', 'w', 'normalized', ['indexOfTime', 'i'], 4056), ('[i][(indexOfTime-i)*2]', 'w', 'normalized', ['indexOfTime', 'i'], 4057), ('[i][(indexOfTime-i)*2+1]', 'w', 'normalized', ['indexOfTime', 'i'], 4059), ('[i][(indexOfTime-i)*2+1]', 'w', 'normalized', ['indexOfTime', 'i'], 4060)]
LDEs formed:20

numberCashFlowsThisStep -> [('[i]', 'w', 'normalized', ['indexOfTime', 'i'], 4062)]
LDEs formed:1

floatingAccruals_ -> [('[indexOfTime]', 'r', 'normalized', ['indexOfTime', 'i'], 4061)]
LDEs formed:0

distinct LDEs:
i1=i2,(indexOfTime1-i1)*2=(indexOfTime2-i2)*2+1
i1=i2,(indexOfTime1-i1)*2+1=(indexOfTime2-i2)*2+1
i1=i2,(indexOfTime1-i1)*2=(indexOfTime2-i2)*2
i1=i2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/products/onestep/onestepoptionlets.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<payoffs_.size()  ++i
induction variable: ['i']
{
L4062: (payoffs_[i],r) 
L4063: (numberCashFlowsThisStep[i]=,w) 
L4064: (genCashFlows[i][0].timeIndex=,w) 
L4065: (genCashFlows[i][0].amount=,w) (accruals_[i],r) 
}
array table
-----------------------------------------------
accruals_ -> [('[i]', 'r', 'normalized', ['i'], 4065)]
LDEs formed:0

genCashFlows -> [('[i][0]', 'w', 'normalized', ['i'], 4064), ('[i][0]', 'w', 'normalized', ['i'], 4065)]
LDEs formed:6

numberCashFlowsThisStep -> [('[i]', 'w', 'normalized', ['i'], 4063)]
LDEs formed:1

payoffs_ -> [('[i]', 'r', 'normalized', ['i'], 4062)]
LDEs formed:0

distinct LDEs:
i1=i2,0=0
i1=i2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/products/onestep/onestepforwards.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<strikes_.size()  ++i
induction variable: ['i']
{
L4063: (genCashFlows[i][0].timeIndex=,w) 
L4064: (genCashFlows[i][0].amount=,w) 
L4065: (strikes_[i],r) (accruals_[i],r) 
}
array table
-----------------------------------------------
accruals_ -> [('[i]', 'r', 'normalized', ['i'], 4065)]
LDEs formed:0

genCashFlows -> [('[i][0]', 'w', 'normalized', ['i'], 4063), ('[i][0]', 'w', 'normalized', ['i'], 4064)]
LDEs formed:6

strikes_ -> [('[i]', 'r', 'normalized', ['i'], 4065)]
LDEs formed:0

distinct LDEs:
i1=i2,0=0
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/products/onestep/onestepcoinitialswaps.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size indexOfTime=0 indexOfTime<lastIndex_ indexOfTime++
induction variable: ['indexOfTime']
{
	loop info: Size i=indexOfTime i<lastIndex_ i++
	induction variable: ['indexOfTime', 'i']
	{
	L4066: (genCashFlows[i][(indexOfTime)*2].timeIndex=,w) 
	L4067: (genCashFlows[i][(indexOfTime)*2].amount=,w) 
	L4068: (fixedAccruals_[indexOfTime],r) 
	L4069: (genCashFlows[i][(indexOfTime)*2+1].timeIndex=,w) 
	L4070: (genCashFlows[i][(indexOfTime)*2+1].amount=,w) 
	L4071: (floatingAccruals_[indexOfTime],r) 
	L4072: (numberCashFlowsThisStep[i]+=,w) 
	}
 }
array table
-----------------------------------------------
fixedAccruals_ -> [('[indexOfTime]', 'r', 'normalized', ['indexOfTime', 'i'], 4068)]
LDEs formed:0

genCashFlows -> [('[i][(indexOfTime)*2]', 'w', 'normalized', ['indexOfTime', 'i'], 4066), ('[i][(indexOfTime)*2]', 'w', 'normalized', ['indexOfTime', 'i'], 4067), ('[i][(indexOfTime)*2+1]', 'w', 'normalized', ['indexOfTime', 'i'], 4069), ('[i][(indexOfTime)*2+1]', 'w', 'normalized', ['indexOfTime', 'i'], 4070)]
LDEs formed:20

numberCashFlowsThisStep -> [('[i]', 'w', 'normalized', ['indexOfTime', 'i'], 4072)]
LDEs formed:1

floatingAccruals_ -> [('[indexOfTime]', 'r', 'normalized', ['indexOfTime', 'i'], 4071)]
LDEs formed:0

distinct LDEs:
i1=i2,(indexOfTime1)*2+1=(indexOfTime2)*2+1
i1=i2
i1=i2,(indexOfTime1)*2=(indexOfTime2)*2
i1=i2,(indexOfTime1)*2=(indexOfTime2)*2+1
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/pathwisegreeks/vegabumpcluster.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size k=0  k < allBumps_.size()  ++k
induction variable: ['k']
{
	loop info: Size f=allBumps_[k].factorBegin()  f <  allBumps_[k].factorEnd()  ++f
	induction variable: ['k', 'f']
	{
	L4072: (v[s][r][f],r) 
	L4073: (v[s][r][f]=,w) 
	}
 }
array table
-----------------------------------------------
v -> [('[s][r][f]', 'r', 'not normalized', ['k', 'f'], 4072), ('[s][r][f]', 'w', 'not normalized', ['k', 'f'], 4073)]
LDEs formed:6

distinct LDEs:
s=s,r=r,f1=f2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/pathwisegreeks/bumpinstrumentjacobian.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

L4074: (derivatives_[j][k]=,w) 
}
array table
-----------------------------------------------
derivatives_ -> [('[j][k]', 'w', 'not normalized', ['k', 'i', 'f'], 4074)]
LDEs formed:2

distinct LDEs:
j=j,k1=k2
#########################################################################################
L4075: (derivatives_[initj][k]=,w) 
}
array table
-----------------------------------------------
derivatives_ -> [('[initj][k]', 'w', 'not normalized', ['k', 'i', 'f'], 4075)]
LDEs formed:2

distinct LDEs:
initj=initj,k1=k2
#########################################################################################
loop info: Size k=0  k < bumps_.numberBumps()  ++k
induction variable: ['k']
{
L4076: (bumpMatrix_[initj][k]=,w) (onePercentBumps_[initj][k]=,w) (derivatives_[initj][k]/,r) 
}
array table
-----------------------------------------------
bumpMatrix_ -> [('[initj][k]', 'w', 'not normalized', ['k'], 4076)]
LDEs formed:2

onePercentBumps_ -> [('[initj][k]', 'w', 'not normalized', ['k'], 4076)]
LDEs formed:2

derivatives_ -> [('[initj][k]', 'r', 'not normalized', ['k'], 4076)]
LDEs formed:0

distinct LDEs:
initj=initj,k1=k2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/pathwisegreeks/ratepseudorootjacobian.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i < pseudoBumps.size()  ++i
induction variable: ['i']
{
L4077: (pseudoBumps[i].rows,r) 
L4078: (pseudoBumps[i].rows,r) 
L4079: (pseudoBumps[i].columns,r) 
L4080: (pseudoBumps[i].columns,r) 
L4081: (pseudoBumps[i],r) 
}
array table
-----------------------------------------------
pseudoBumps -> [('[i]', 'r', 'normalized', ['i'], 4077), ('[i]', 'r', 'normalized', ['i'], 4078), ('[i]', 'r', 'normalized', ['i'], 4079), ('[i]', 'r', 'normalized', ['i'], 4080), ('[i]', 'r', 'normalized', ['i'], 4081)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i =0  i < numberBumps_  ++i
induction variable: ['i']
{
L4082: (pseudoBumped_[i],r) 
L4083: (driftsComputers_[i].compute,r) 
	loop info: Size j =0  j < aliveIndex_  ++j
	induction variable: ['i', 'j']
	{
	}
	loop info: Size j=aliveIndex_  j < numberRates  ++j
	induction variable: ['i', 'j']
	{
	L4084: (bumpedRates_[j]=,w) (oldRates[j]+,r) (displacements_[j],r) 
		loop info: Size k=0  k < factors_  ++k
		induction variable: ['i', 'j', 'k']
		{
		}
	L4085: (bumpedRates_[j]+=,w) (drifts_[j],r) 
		loop info: Size k=0  k < factors_  ++k
		induction variable: ['i', 'j', 'k']
		{
		}
	L4086: (bumpedRates_[j]=,w) (bumpedRates_[j],r) 
	L4087: (bumpedRates_[j]-=,w) (displacements_[j],r) 
	L4088: (bumpedRates_[j]-,r) (newRates[j],r) 
	L4089: (B[i][j]=,w) 
	}
 }
array table
-----------------------------------------------
drifts_ -> [('[j]', 'r', 'normalized', ['i', 'j', 'k'], 4085)]
LDEs formed:0

driftsComputers_ -> [('[i]', 'r', 'normalized', ['i', 'j', 'k'], 4083)]
LDEs formed:0

B -> [('[i][j]', 'w', 'normalized', ['i', 'j', 'k'], 4089)]
LDEs formed:2

displacements_ -> [('[j]', 'r', 'normalized', ['i', 'j', 'k'], 4084), ('[j]', 'r', 'normalized', ['i', 'j', 'k'], 4087)]
LDEs formed:0

oldRates -> [('[j]', 'r', 'normalized', ['i', 'j', 'k'], 4084)]
LDEs formed:0

newRates -> [('[j]', 'r', 'normalized', ['i', 'j', 'k'], 4088)]
LDEs formed:0

pseudoBumped_ -> [('[i]', 'r', 'normalized', ['i', 'j', 'k'], 4082)]
LDEs formed:0

bumpedRates_ -> [('[j]', 'w', 'normalized', ['i', 'j', 'k'], 4084), ('[j]', 'w', 'normalized', ['i', 'j', 'k'], 4085), ('[j]', 'w', 'normalized', ['i', 'j', 'k'], 4086), ('[j]', 'r', 'normalized', ['i', 'j', 'k'], 4086), ('[j]', 'w', 'normalized', ['i', 'j', 'k'], 4087), ('[j]', 'r', 'normalized', ['i', 'j', 'k'], 4088)]
LDEs formed:18

distinct LDEs:
j1=j2
i1=i2,j1=j2
#########################################################################################
loop info: Size i=0  i < pseudoBumps.size()  ++i
induction variable: ['i']
{
L4089: (pseudoBumps[i].rows,r) 
L4090: (pseudoBumps[i].rows,r) 
L4091: (pseudoBumps[i].columns,r) 
L4092: (pseudoBumps[i].columns,r) 
}
array table
-----------------------------------------------
pseudoBumps -> [('[i]', 'r', 'normalized', ['i'], 4089), ('[i]', 'r', 'normalized', ['i'], 4090), ('[i]', 'r', 'normalized', ['i'], 4091), ('[i]', 'r', 'normalized', ['i'], 4092)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size f=0  f < factors_  ++f
induction variable: ['f']
{
L4093: (e_[aliveIndex_][f]=,w) 
	loop info: Size j= aliveIndex_+1  j < numberRates  ++j
	induction variable: ['f', 'j']
	{
	}
 }
array table
-----------------------------------------------
e_ -> [('[aliveIndex_][f]', 'w', 'not normalized', ['f', 'j'], 4093)]
LDEs formed:2

distinct LDEs:
aliveIndex_=aliveIndex_,f1=f2
#########################################################################################
L4094: (ratios_[j]*,r) (taus_[j]*,r) (pseudoRoot_[j][f],r) 
L4095: (pseudoRoot_[j][f],r) 
L4096: (e_[j][f]*,r) (taus_[j],r) 
L4097: (gaussians[f],r) 
L4098: (newRates[j]+,r) (displacements_[j],r) 
L4099: (allDerivatives_[j][j][f]=,w) 
	loop info: Size k= j+1  k < numberRates   ++k
	induction variable: ['f', 'k']
	{
	}
 }
array table
-----------------------------------------------
displacements_ -> [('[j]', 'r', 'not normalized', ['f', 'k'], 4098)]
LDEs formed:0

taus_ -> [('[j]', 'r', 'not normalized', ['f', 'k'], 4094), ('[j]', 'r', 'not normalized', ['f', 'k'], 4096)]
LDEs formed:0

ratios_ -> [('[j]', 'r', 'not normalized', ['f', 'k'], 4094)]
LDEs formed:0

pseudoRoot_ -> [('[j][f]', 'r', 'not normalized', ['f', 'k'], 4094), ('[j][f]', 'r', 'not normalized', ['f', 'k'], 4095)]
LDEs formed:0

e_ -> [('[j][f]', 'r', 'not normalized', ['f', 'k'], 4096)]
LDEs formed:0

gaussians -> [('[f]', 'r', 'normalized', ['f', 'k'], 4097)]
LDEs formed:0

newRates -> [('[j]', 'r', 'not normalized', ['f', 'k'], 4098)]
LDEs formed:0

allDerivatives_ -> [('[j][j][f]', 'w', 'not normalized', ['f', 'k'], 4099)]
LDEs formed:3

distinct LDEs:
j=j,j=j,f1=f2
#########################################################################################
loop info: Size i =0  i < numberBumps_  ++i
induction variable: ['i']
{
	loop info:   j < aliveIndex_  ++j
	induction variable: ['i', 'j']
	{
	L4100: (B[i][j]=,w) 
	}
	loop info: Size k=aliveIndex_  k < numberRates  ++k
	induction variable: ['i', 'j', 'k']
		{
		}
L4101: (B[i][j]=,w) 
}
array table
-----------------------------------------------
B -> [('[i][j]', 'w', 'normalized', ['i', 'j', 'k'], 4100), ('[i][j]', 'w', 'normalized', ['i', 'j', 'k'], 4101)]
LDEs formed:6

distinct LDEs:
i1=i2,j1=j2
#########################################################################################
loop info: Size f=0  f < factors_  ++f
induction variable: ['f']
{
L4102: (e_[aliveIndex_][f]=,w) 
	loop info: Size j= aliveIndex_+1  j < numberRates  ++j
	induction variable: ['f', 'j']
	{
	}
 }
array table
-----------------------------------------------
e_ -> [('[aliveIndex_][f]', 'w', 'not normalized', ['f', 'j'], 4102)]
LDEs formed:2

distinct LDEs:
aliveIndex_=aliveIndex_,f1=f2
#########################################################################################
L4103: (ratios_[j]*,r) (taus_[j]*,r) (pseudoRoot_[j][f],r) 
L4104: (pseudoRoot_[j][f],r) 
L4105: (e_[j][f]*,r) (taus_[j],r) 
L4106: (gaussians[f],r) 
L4107: (newRates[j]+,r) (displacements_[j],r) 
L4108: (B[j][j][f]=,w) 
	loop info: Size k= 0  k < aliveIndex_   ++k
	induction variable: ['f', 'k']
	{
	}
	loop info: Size k= j+1  k < numberRates   ++k
	induction variable: ['f', 'k']
	{
	}
 }
array table
-----------------------------------------------
displacements_ -> [('[j]', 'r', 'not normalized', ['f', 'k'], 4107)]
LDEs formed:0

B -> [('[j][j][f]', 'w', 'not normalized', ['f', 'k'], 4108)]
LDEs formed:3

taus_ -> [('[j]', 'r', 'not normalized', ['f', 'k'], 4103), ('[j]', 'r', 'not normalized', ['f', 'k'], 4105)]
LDEs formed:0

ratios_ -> [('[j]', 'r', 'not normalized', ['f', 'k'], 4103)]
LDEs formed:0

pseudoRoot_ -> [('[j][f]', 'r', 'not normalized', ['f', 'k'], 4103), ('[j][f]', 'r', 'not normalized', ['f', 'k'], 4104)]
LDEs formed:0

e_ -> [('[j][f]', 'r', 'not normalized', ['f', 'k'], 4105)]
LDEs formed:0

gaussians -> [('[f]', 'r', 'normalized', ['f', 'k'], 4106)]
LDEs formed:0

newRates -> [('[j]', 'r', 'not normalized', ['f', 'k'], 4107)]
LDEs formed:0

distinct LDEs:
j=j,j=j,f1=f2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/models/marketmodels/pathwisegreeks/swaptionpseudojacobian.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size rate=startIndex  rate<endIndex  ++rate
induction variable: ['rate']
{
	loop info: Size f =0  f < factors  ++f
	induction variable: ['rate', 'f']
	{
		loop info: Size rate2 = startIndex  rate2<endIndex  ++rate2
		induction variable: ['rate', 'f', 'rate2']
		{
		L4108: (zed[0][zIndex2]*,r) (thisPseudo[rate2][f],r) 
		}
	L4109: (zed[0][zIndex],r) 
	L4110: (thisDerivative[rate][f]=,w) 
	}
 }
array table
-----------------------------------------------
thisDerivative -> [('[rate][f]', 'w', 'normalized', ['rate', 'f', 'rate2'], 4110)]
LDEs formed:2

thisPseudo -> [('[rate2][f]', 'r', 'normalized', ['rate', 'f', 'rate2'], 4108)]
LDEs formed:0

zed -> [('[0][zIndex2]', 'r', 'not normalized', ['rate', 'f', 'rate2'], 4108), ('[0][zIndex]', 'r', 'not normalized', ['rate', 'f', 'rate2'], 4109)]
LDEs formed:0

distinct LDEs:
rate1=rate2,f1=f2
#########################################################################################
loop info: Size i=0  i < annuities_.size()  ++i
induction variable: ['i']
{
L4110: (currentRates_[i],r) 
L4111: (expiries_[i],r) 
L4112: (annuities_[i],r) 
}
array table
-----------------------------------------------
expiries_ -> [('[i]', 'r', 'normalized', ['i'], 4111)]
LDEs formed:0

currentRates_ -> [('[i]', 'r', 'normalized', ['i'], 4110)]
LDEs formed:0

annuities_ -> [('[i]', 'r', 'normalized', ['i'], 4112)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i < annuities_.size()  ++i
induction variable: ['i']
{
L4113: (currentRates_[i],r) 
L4114: (expiries_[i],r) 
L4115: (expiries_[i],r) 
L4116: (annuities_[i],r) 
}
array table
-----------------------------------------------
expiries_ -> [('[i]', 'r', 'normalized', ['i'], 4114), ('[i]', 'r', 'normalized', ['i'], 4115)]
LDEs formed:0

currentRates_ -> [('[i]', 'r', 'normalized', ['i'], 4113)]
LDEs formed:0

annuities_ -> [('[i]', 'r', 'normalized', ['i'], 4116)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size j = startIndex  j < endIndex  ++j
induction variable: ['j']
{
L4117: (expiries[capletIndex]=,w) 
L4118: (totalCovariance[j][j],r) 
L4119: (displacedImpliedVols[capletIndex]=,w) (totalCovariance[j][j]/,r) 
L4120: (initialRates[capletIndex]=,w) 
L4121: (annuities[capletIndex]=,w) 
L4122: (displacedImpliedVols[capletIndex]*,r) 
L4123: (displacedImpliedVols[capletIndex],r) 
L4124: (displacedImpliedVols[capletIndex]*,r) 
L4125: (capletPrices[capletIndex]=,w) 
}
array table
-----------------------------------------------
annuities -> [('[capletIndex]', 'w', 'not normalized', ['j'], 4121)]
LDEs formed:1

initialRates -> [('[capletIndex]', 'w', 'not normalized', ['j'], 4120)]
LDEs formed:1

capletPrices -> [('[capletIndex]', 'w', 'not normalized', ['j'], 4125)]
LDEs formed:1

expiries -> [('[capletIndex]', 'w', 'not normalized', ['j'], 4117)]
LDEs formed:1

totalCovariance -> [('[j][j]', 'r', 'normalized', ['j'], 4118), ('[j][j]', 'r', 'normalized', ['j'], 4119)]
LDEs formed:0

displacedImpliedVols -> [('[capletIndex]', 'w', 'not normalized', ['j'], 4119), ('[capletIndex]', 'r', 'not normalized', ['j'], 4122), ('[capletIndex]', 'r', 'not normalized', ['j'], 4123), ('[capletIndex]', 'r', 'not normalized', ['j'], 4124)]
LDEs formed:4

distinct LDEs:
capletIndex=capletIndex
#########################################################################################
loop info: Size step =0  step < inputModel->evolution().numberOfSteps()  ++step
induction variable: ['step']
{
	loop info: Size f=0  f < factors  ++f
	induction variable: ['step', 'f']
		{
		L4125: (displacedImpliedVols[rate-startIndex]*,r) 
		L4126: (displacedImpliedVols[rate-startIndex]*,r) 
		L4127: (annuities[rate-startIndex],r) 
		L4128: (thisDerivative[rate][f]=,w) 
		}
 }
array table
-----------------------------------------------
thisDerivative -> [('[rate][f]', 'w', 'not normalized', ['step', 'f'], 4128)]
LDEs formed:2

annuities -> [('[rate-startIndex]', 'r', 'not normalized', ['step', 'f'], 4127)]
LDEs formed:0

displacedImpliedVols -> [('[rate-startIndex]', 'r', 'not normalized', ['step', 'f'], 4125), ('[rate-startIndex]', 'r', 'not normalized', ['step', 'f'], 4126)]
LDEs formed:0

distinct LDEs:
rate=rate,f1=f2
#########################################################################################
loop info: Size step =0  step < inputModel->evolution().numberOfSteps()  ++step
induction variable: ['step']
{
	loop info: Size f=0  f < factors  ++f
	induction variable: ['step', 'f']
		{
		L4127: (thisDerivative[rate][f]=,w) (priceDerivatives_[step][rate][f]/,r) 
		}
 }
array table
-----------------------------------------------
thisDerivative -> [('[rate][f]', 'w', 'not normalized', ['step', 'f'], 4127)]
LDEs formed:2

priceDerivatives_ -> [('[step][rate][f]', 'r', 'not normalized', ['step', 'f'], 4127)]
LDEs formed:0

distinct LDEs:
rate=rate,f1=f2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/indexes/bmaindex.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/indexes/inflationindex.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<n  ++i
induction variable: ['i']
{
L4128: (dates[i]=,w) 
L4129: (rates[i]=,w) 
}
array table
-----------------------------------------------
dates -> [('[i]', 'w', 'normalized', ['i'], 4128)]
LDEs formed:1

rates -> [('[i]', 'w', 'normalized', ['i'], 4129)]
LDEs formed:1

distinct LDEs:
i1=i2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/pricingengines/basket/mcamericanbasketengine.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<assetNumber_  ++i
induction variable: ['i']
{
L4130: (tmp[i]=,w) (path[i][t]*,r) 
}
array table
-----------------------------------------------
tmp -> [('[i]', 'w', 'normalized', ['i'], 4130)]
LDEs formed:1

path -> [('[i][t]', 'r', 'not normalized', ['i'], 4130)]
LDEs formed:0

distinct LDEs:
i1=i2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/pricingengines/basket/mceuropeanbasketengine.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/pricingengines/asian/fdblackscholesasianengine.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<arguments_.fixingDates.size()  ++i
induction variable: ['i']
{
L4131: (arguments_.fixingDates[i],r) 
}
array table
-----------------------------------------------
arguments_.fixingDates -> [('[i]', 'r', 'normalized', ['i'], 4131)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/pricingengines/asian/analytic_discr_geom_av_strike.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<arguments_.fixingDates.size()  i++
induction variable: ['i']
{
L4132: (arguments_.fixingDates[i],r) (arguments_.fixingDates[0],r) 
L4133: (arguments_.fixingDates[0],r) 
L4134: (arguments_.fixingDates[i],r) 
}
array table
-----------------------------------------------
arguments_.fixingDates -> [('[i]', 'r', 'normalized', ['i'], 4132), ('[0]', 'r', 'normalized', ['i'], 4132), ('[0]', 'r', 'normalized', ['i'], 4133), ('[i]', 'r', 'normalized', ['i'], 4134)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/pricingengines/asian/mc_discr_geom_av_price.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=1  i<n+1  i++
induction variable: ['i']
{
L4135: (path[i],r) 
}
array table
-----------------------------------------------
path -> [('[i]', 'r', 'normalized', ['i'], 4135)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/pricingengines/asian/analytic_discr_geom_av_price.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: i=0  i<arguments_.fixingDates.size()  i++
induction variable: ['i']
{
L4136: (arguments_.fixingDates[i],r) 
L4137: (arguments_.fixingDates[i],r) 
}
array table
-----------------------------------------------
arguments_.fixingDates -> [('[i]', 'r', 'normalized', ['i'], 4136), ('[i]', 'r', 'normalized', ['i'], 4137)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/pricingengines/cliquet/mcperformanceengine.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i = 2   i < n  i++
induction variable: ['i']
{
L4138: (discounts_[i-1]*,r) (path[i]/,r) (path[i-1],r) 
}
array table
-----------------------------------------------
path -> [('[i]', 'r', 'normalized', ['i'], 4138), ('[i-1]', 'r', 'normalized', ['i'], 4138)]
LDEs formed:0

discounts_ -> [('[i-1]', 'r', 'normalized', ['i'], 4138)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/pricingengines/cliquet/analyticcliquetengine.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i = 1  i < resetDates.size()  i++
induction variable: ['i']
{
L4139: (resetDates[i-1],r) 
L4140: (resetDates[i],r) 
L4141: (resetDates[i-1],r) 
L4142: (resetDates[i],r) 
L4143: (resetDates[i-1],r) 
L4144: (resetDates[i-1],r) (resetDates[i],r) 
L4145: (resetDates[i-1],r) (resetDates[i],r) 
L4146: (resetDates[i-1],r) (resetDates[i],r) 
L4147: (resetDates[i-1],r) 
L4148: (resetDates[i-1],r) (resetDates[i],r) 
L4149: (resetDates[i-1],r) (resetDates[i],r) 
}
array table
-----------------------------------------------
resetDates -> [('[i-1]', 'r', 'normalized', ['i'], 4139), ('[i]', 'r', 'normalized', ['i'], 4140), ('[i-1]', 'r', 'normalized', ['i'], 4141), ('[i]', 'r', 'normalized', ['i'], 4142), ('[i-1]', 'r', 'normalized', ['i'], 4143), ('[i-1]', 'r', 'normalized', ['i'], 4144), ('[i]', 'r', 'normalized', ['i'], 4144), ('[i-1]', 'r', 'normalized', ['i'], 4145), ('[i]', 'r', 'normalized', ['i'], 4145), ('[i-1]', 'r', 'normalized', ['i'], 4146), ('[i]', 'r', 'normalized', ['i'], 4146), ('[i-1]', 'r', 'normalized', ['i'], 4147), ('[i-1]', 'r', 'normalized', ['i'], 4148), ('[i]', 'r', 'normalized', ['i'], 4148), ('[i-1]', 'r', 'normalized', ['i'], 4149), ('[i]', 'r', 'normalized', ['i'], 4149)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/pricingengines/cliquet/analyticperformanceengine.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i = 1  i < resetDates.size()  i++
induction variable: ['i']
{
L4150: (resetDates[i-1],r) 
L4151: (resetDates[i],r) 
L4152: (resetDates[i-1],r) 
L4153: (resetDates[i],r) 
L4154: (resetDates[i-1],r) 
L4155: (resetDates[i-1],r) (resetDates[i],r) 
L4156: (resetDates[i-1],r) (resetDates[i],r) 
L4157: (resetDates[i-1],r) (resetDates[i],r) 
L4158: (resetDates[i-1],r) 
L4159: (resetDates[i-1],r) (resetDates[i],r) 
L4160: (resetDates[i-1],r) (resetDates[i],r) 
}
array table
-----------------------------------------------
resetDates -> [('[i-1]', 'r', 'normalized', ['i'], 4150), ('[i]', 'r', 'normalized', ['i'], 4151), ('[i-1]', 'r', 'normalized', ['i'], 4152), ('[i]', 'r', 'normalized', ['i'], 4153), ('[i-1]', 'r', 'normalized', ['i'], 4154), ('[i-1]', 'r', 'normalized', ['i'], 4155), ('[i]', 'r', 'normalized', ['i'], 4155), ('[i-1]', 'r', 'normalized', ['i'], 4156), ('[i]', 'r', 'normalized', ['i'], 4156), ('[i-1]', 'r', 'normalized', ['i'], 4157), ('[i]', 'r', 'normalized', ['i'], 4157), ('[i-1]', 'r', 'normalized', ['i'], 4158), ('[i-1]', 'r', 'normalized', ['i'], 4159), ('[i]', 'r', 'normalized', ['i'], 4159), ('[i-1]', 'r', 'normalized', ['i'], 4160), ('[i]', 'r', 'normalized', ['i'], 4160)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/pricingengines/vanilla/mcdigitalengine.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: i=0  i<n-1  i++
induction variable: ['i']
{
L4161: (path[i+1]/,r) (path[i],r) 
L4162: (timeGrid[i+1],r) 
L4163: (timeGrid[i+2],r) 
L4164: (u[i],r) 
}
array table
-----------------------------------------------
path -> [('[i+1]', 'r', 'normalized', ['i'], 4161), ('[i]', 'r', 'normalized', ['i'], 4161)]
LDEs formed:0

u -> [('[i]', 'r', 'normalized', ['i'], 4164)]
LDEs formed:0

timeGrid -> [('[i+1]', 'r', 'normalized', ['i'], 4162), ('[i+2]', 'r', 'normalized', ['i'], 4163)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: i=0  i<n-1  i++
induction variable: ['i']
{
L4164: (path[i+1]/,r) (path[i],r) 
L4165: (timeGrid[i+1],r) 
L4166: (timeGrid[i+1],r) 
L4167: (timeGrid[i+2],r) 
L4168: (u[i],r) 
}
array table
-----------------------------------------------
path -> [('[i+1]', 'r', 'normalized', ['i'], 4164), ('[i]', 'r', 'normalized', ['i'], 4164)]
LDEs formed:0

u -> [('[i]', 'r', 'normalized', ['i'], 4168)]
LDEs formed:0

timeGrid -> [('[i+1]', 'r', 'normalized', ['i'], 4165), ('[i+1]', 'r', 'normalized', ['i'], 4166), ('[i+2]', 'r', 'normalized', ['i'], 4167)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/pricingengines/vanilla/discretizedvanillaoption.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<stoppingTimes_.size()  ++i
induction variable: ['i']
{
L4168: (stoppingTimes_[i]=,w) 
L4169: (stoppingTimes_[i]=,w) (stoppingTimes_[i],r) 
}
array table
-----------------------------------------------
stoppingTimes_ -> [('[i]', 'w', 'normalized', ['i'], 4168), ('[i]', 'w', 'normalized', ['i'], 4169), ('[i]', 'r', 'normalized', ['i'], 4169)]
LDEs formed:5

distinct LDEs:
i1=i2
#########################################################################################
loop info: Size i=0  i<stoppingTimes_.size()  i++
induction variable: ['i']
{
L4170: (stoppingTimes_[i],r) 
}
array table
-----------------------------------------------
stoppingTimes_ -> [('[i]', 'r', 'normalized', ['i'], 4170)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size j=0  j<values_.size()  j++
induction variable: ['j']
{
L4171: (values_[j]=,w) (values_[j],r) 
L4172: (grid[j],r) 
}
array table
-----------------------------------------------
grid -> [('[j]', 'r', 'normalized', ['j'], 4172)]
LDEs formed:0

values_ -> [('[j]', 'w', 'normalized', ['j'], 4171), ('[j]', 'r', 'normalized', ['j'], 4171)]
LDEs formed:2

distinct LDEs:
j1=j2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/pricingengines/vanilla/fdsimplebsswingengine.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/pricingengines/vanilla/analyticgjrgarchengine.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: i=1  i < T  ++i
induction variable: ['i']
{
L4172: (m1ai[i]=,w) (m1ai[i-1]*,r) 
L4173: (m2ai[i]=,w) (m2ai[i-1]*,r) 
L4174: (m3ai[i]=,w) (m3ai[i-1]*,r) 
}
array table
-----------------------------------------------
m3ai -> [('[i]', 'w', 'normalized', ['i'], 4174), ('[i-1]', 'r', 'normalized', ['i'], 4174)]
LDEs formed:2

m1ai -> [('[i]', 'w', 'normalized', ['i'], 4172), ('[i-1]', 'r', 'normalized', ['i'], 4172)]
LDEs formed:2

m2ai -> [('[i]', 'w', 'normalized', ['i'], 4173), ('[i-1]', 'r', 'normalized', ['i'], 4173)]
LDEs formed:2

distinct LDEs:
i1=i2-1
i1=i2
#########################################################################################
loop info: i = 0  i < T  ++i
induction variable: ['i']
{
L4174: (m1ai[i],r) 
L4175: (m2ai[i],r) 
L4176: (m3ai[i],r) 
	loop info: j = 0  j < T-i-1  ++j
	induction variable: ['i', 'j']
	{
	L4177: (m1ai[j+1],r) (m1ai[j+1],r) 
	L4178: (m2ai[j+1],r) 
	L4179: (m1ai[j+1],r) 
	L4180: (m2ai[j+1],r) 
	L4181: (m1ai[j+1]-,r) (m2ai[j+1],r) 
	L4182: (m2ai[j+1]*,r) 
	L4183: (m1ai[j+1],r) 
	L4184: (m1ai[j+1]*,r) 
	L4185: (m1ai[j]*,r) 
	L4186: (m1ai[j+1],r) 
	L4187: (m2ai[j+1],r) 
	L4188: (m2ai[j]*,r) 
	L4189: (m1ai[i+j+1],r) 
	L4190: (m1ai[i+j+1]*,r) 
	L4191: (m1ai[j]*,r) 
	L4192: (m1ai[j]*,r) 
	L4193: (m1ai[j+1],r) 
	L4194: (m1ai[j]*,r) 
		loop info: k = 0  k < T-i-j-2  ++k
		induction variable: ['i', 'j', 'k']
		{
		L4195: (m1ai[k+1],r) 
		L4196: (m1ai[k+1]*,r) 
		L4197: (m1ai[k+1],r) 
		L4198: (m1ai[k+1]*,r) 
		L4199: (m1ai[k]*,r) 
		L4200: (m1ai[k]*,r) 
		}
 	}
 }
array table
-----------------------------------------------
m3ai -> [('[i]', 'r', 'normalized', ['i', 'j', 'k'], 4176)]
LDEs formed:0

m1ai -> [('[i]', 'r', 'normalized', ['i', 'j', 'k'], 4174), ('[j+1]', 'r', 'normalized', ['i', 'j', 'k'], 4177), ('[j+1]', 'r', 'normalized', ['i', 'j', 'k'], 4177), ('[j+1]', 'r', 'normalized', ['i', 'j', 'k'], 4179), ('[j+1]', 'r', 'normalized', ['i', 'j', 'k'], 4181), ('[j+1]', 'r', 'normalized', ['i', 'j', 'k'], 4183), ('[j+1]', 'r', 'normalized', ['i', 'j', 'k'], 4184), ('[j]', 'r', 'normalized', ['i', 'j', 'k'], 4185), ('[j+1]', 'r', 'normalized', ['i', 'j', 'k'], 4186), ('[i+j+1]', 'r', 'normalized', ['i', 'j', 'k'], 4189), ('[i+j+1]', 'r', 'normalized', ['i', 'j', 'k'], 4190), ('[j]', 'r', 'normalized', ['i', 'j', 'k'], 4191), ('[j]', 'r', 'normalized', ['i', 'j', 'k'], 4192), ('[j+1]', 'r', 'normalized', ['i', 'j', 'k'], 4193), ('[j]', 'r', 'normalized', ['i', 'j', 'k'], 4194), ('[k+1]', 'r', 'normalized', ['i', 'j', 'k'], 4195), ('[k+1]', 'r', 'normalized', ['i', 'j', 'k'], 4196), ('[k+1]', 'r', 'normalized', ['i', 'j', 'k'], 4197), ('[k+1]', 'r', 'normalized', ['i', 'j', 'k'], 4198), ('[k]', 'r', 'normalized', ['i', 'j', 'k'], 4199), ('[k]', 'r', 'normalized', ['i', 'j', 'k'], 4200)]
LDEs formed:0

m2ai -> [('[i]', 'r', 'normalized', ['i', 'j', 'k'], 4175), ('[j+1]', 'r', 'normalized', ['i', 'j', 'k'], 4178), ('[j+1]', 'r', 'normalized', ['i', 'j', 'k'], 4180), ('[j+1]', 'r', 'normalized', ['i', 'j', 'k'], 4181), ('[j+1]', 'r', 'normalized', ['i', 'j', 'k'], 4182), ('[j+1]', 'r', 'normalized', ['i', 'j', 'k'], 4187), ('[j]', 'r', 'normalized', ['i', 'j', 'k'], 4188)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/pricingengines/vanilla/mchestonhullwhiteengine.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size j=0  j < states.size()  ++j
induction variable: ['j']
{
L4189: (states[j]=,w) (path[j][path.pathSize()-1],r) 
}
array table
-----------------------------------------------
states -> [('[j]', 'w', 'normalized', ['j'], 4189)]
LDEs formed:1

path -> [('[j][path.pathSize()-1]', 'r', 'not normalized', ['j'], 4189)]
LDEs formed:0

distinct LDEs:
j1=j2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/pricingengines/vanilla/fdhestonhullwhitevanillaengine.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i < cachedArgs2results_.size()  ++i
induction variable: ['i']
{
L4190: (cachedArgs2results_[i].first.exercise-,r) 
L4191: (cachedArgs2results_[i].first.exercise-,r) 
L4192: (cachedArgs2results_[i].first.payoff,r) 
L4193: (cachedArgs2results_[i].second,r) 
}
array table
-----------------------------------------------
cachedArgs2results_ -> [('[i]', 'r', 'normalized', ['i'], 4190), ('[i]', 'r', 'normalized', ['i'], 4191), ('[i]', 'r', 'normalized', ['i'], 4192), ('[i]', 'r', 'normalized', ['i'], 4193)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i < strikes_.size()  ++i
induction variable: ['i']
{
L4194: (cachedArgs2results_[i].first.exercise=,w) 
L4195: (cachedArgs2results_[i].first.payoff=,w) 
L4196: (strikes_[i],r) 
L4197: (strikes_[i],r) 
L4198: (cachedArgs2results_[i].second,r) 
}
array table
-----------------------------------------------
strikes_ -> [('[i]', 'r', 'normalized', ['i'], 4196), ('[i]', 'r', 'normalized', ['i'], 4197)]
LDEs formed:0

cachedArgs2results_ -> [('[i]', 'w', 'normalized', ['i'], 4194), ('[i]', 'w', 'normalized', ['i'], 4195), ('[i]', 'r', 'normalized', ['i'], 4198)]
LDEs formed:5

distinct LDEs:
i1=i2
#########################################################################################
loop info: Size i=0  i < strikes_.size()  ++i
induction variable: ['i']
{
L4199: (strikes_[i],r) 
L4200: (cachedArgs2results_[i].second.value+=,w) 
}
array table
-----------------------------------------------
strikes_ -> [('[i]', 'r', 'normalized', ['i'], 4199)]
LDEs formed:0

cachedArgs2results_ -> [('[i]', 'w', 'normalized', ['i'], 4200)]
LDEs formed:1

distinct LDEs:
i1=i2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/pricingengines/vanilla/fdhestonvanillaengine.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i < cachedArgs2results_.size()  ++i
induction variable: ['i']
{
L4201: (cachedArgs2results_[i].first.exercise-,r) 
L4202: (cachedArgs2results_[i].first.exercise-,r) 
L4203: (cachedArgs2results_[i].first.payoff,r) 
L4204: (cachedArgs2results_[i].second,r) 
}
array table
-----------------------------------------------
cachedArgs2results_ -> [('[i]', 'r', 'normalized', ['i'], 4201), ('[i]', 'r', 'normalized', ['i'], 4202), ('[i]', 'r', 'normalized', ['i'], 4203), ('[i]', 'r', 'normalized', ['i'], 4204)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i < strikes_.size()  ++i
induction variable: ['i']
{
L4205: (cachedArgs2results_[i].first.exercise=,w) 
L4206: (cachedArgs2results_[i].first.payoff=,w) 
L4207: (strikes_[i],r) 
L4208: (strikes_[i],r) 
L4209: (cachedArgs2results_[i].second,r) 
}
array table
-----------------------------------------------
strikes_ -> [('[i]', 'r', 'normalized', ['i'], 4207), ('[i]', 'r', 'normalized', ['i'], 4208)]
LDEs formed:0

cachedArgs2results_ -> [('[i]', 'w', 'normalized', ['i'], 4205), ('[i]', 'w', 'normalized', ['i'], 4206), ('[i]', 'r', 'normalized', ['i'], 4209)]
LDEs formed:5

distinct LDEs:
i1=i2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/pricingengines/vanilla/analyticdividendeuropeanengine.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: i = 0  i < arguments_.cashFlow.size()  i++
induction variable: ['i']
{
L4210: (arguments_.cashFlow[i]-,r) 
L4211: (arguments_.cashFlow[i]-,r) 
L4212: (arguments_.cashFlow[i]-,r) 
}
array table
-----------------------------------------------
arguments_.cashFlow -> [('[i]', 'r', 'normalized', ['i'], 4210), ('[i]', 'r', 'normalized', ['i'], 4211), ('[i]', 'r', 'normalized', ['i'], 4212)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/pricingengines/vanilla/analyticptdhestonengine.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i <timeGrid_.size()-1  ++i
induction variable: ['i']
{
L4213: (timeGrid_[i],r) 
L4214: (timeGrid_[i+1],r) 
L4215: (r_[i]=,w) 
L4216: (q_[i]=,w) 
}
array table
-----------------------------------------------
timeGrid_ -> [('[i]', 'r', 'normalized', ['i'], 4213), ('[i+1]', 'r', 'normalized', ['i'], 4214)]
LDEs formed:0

r_ -> [('[i]', 'w', 'normalized', ['i'], 4215)]
LDEs formed:1

q_ -> [('[i]', 'w', 'normalized', ['i'], 4216)]
LDEs formed:1

distinct LDEs:
i1=i2
#########################################################################################
loop info: Size i=timeGrid_.size()-1  i > 0  --i
induction variable: ['i']
{
L4217: (timeGrid_[i-1],r) 
L4218: (timeGrid_[i],r) 
L4219: (r_[i-1]-,r) (q_[i-1],r) 
}
array table
-----------------------------------------------
timeGrid_ -> [('[i-1]', 'r', 'normalized', ['i'], 4217), ('[i]', 'r', 'normalized', ['i'], 4218)]
LDEs formed:0

r_ -> [('[i-1]', 'r', 'normalized', ['i'], 4219)]
LDEs formed:0

q_ -> [('[i-1]', 'r', 'normalized', ['i'], 4219)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=1  i <= n  ++i
induction variable: ['i']
{
L4220: (timeGrid[i-1]+,r) (timeGrid[i],r) 
}
array table
-----------------------------------------------
timeGrid -> [('[i-1]', 'r', 'normalized', ['i'], 4220), ('[i]', 'r', 'normalized', ['i'], 4220)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/pricingengines/barrier/mcbarrierengine.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: i = 0  i < n-1  i++
induction variable: ['i']
{
L4221: (path[i+1],r) 
L4222: (timeGrid[i],r) 
L4223: (u[i],r) 
}
array table
-----------------------------------------------
path -> [('[i+1]', 'r', 'normalized', ['i'], 4221)]
LDEs formed:0

u -> [('[i]', 'r', 'normalized', ['i'], 4223)]
LDEs formed:0

timeGrid -> [('[i]', 'r', 'normalized', ['i'], 4222)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: i = 0  i < n-1  i++
induction variable: ['i']
{
L4223: (path[i+1],r) 
L4224: (timeGrid[i],r) 
L4225: (u[i],r) 
}
array table
-----------------------------------------------
path -> [('[i+1]', 'r', 'normalized', ['i'], 4223)]
LDEs formed:0

u -> [('[i]', 'r', 'normalized', ['i'], 4225)]
LDEs formed:0

timeGrid -> [('[i]', 'r', 'normalized', ['i'], 4224)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: i = 0  i < n-1  i++
induction variable: ['i']
{
L4225: (path[i+1],r) 
L4226: (timeGrid[i],r) 
L4227: (u[i],r) 
}
array table
-----------------------------------------------
path -> [('[i+1]', 'r', 'normalized', ['i'], 4225)]
LDEs formed:0

u -> [('[i]', 'r', 'normalized', ['i'], 4227)]
LDEs formed:0

timeGrid -> [('[i]', 'r', 'normalized', ['i'], 4226)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: i = 0  i < n-1  i++
induction variable: ['i']
{
L4227: (path[i+1],r) 
L4228: (timeGrid[i],r) 
L4229: (u[i],r) 
}
array table
-----------------------------------------------
path -> [('[i+1]', 'r', 'normalized', ['i'], 4227)]
LDEs formed:0

u -> [('[i]', 'r', 'normalized', ['i'], 4229)]
LDEs formed:0

timeGrid -> [('[i]', 'r', 'normalized', ['i'], 4228)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: i = 1  i < n  i++
induction variable: ['i']
{
L4229: (path[i],r) 
}
array table
-----------------------------------------------
path -> [('[i]', 'r', 'normalized', ['i'], 4229)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: i = 1  i < n  i++
induction variable: ['i']
{
L4230: (path[i],r) 
}
array table
-----------------------------------------------
path -> [('[i]', 'r', 'normalized', ['i'], 4230)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: i = 1  i < n  i++
induction variable: ['i']
{
L4231: (path[i],r) 
}
array table
-----------------------------------------------
path -> [('[i]', 'r', 'normalized', ['i'], 4231)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: i = 1  i < n  i++
induction variable: ['i']
{
L4232: (path[i],r) 
}
array table
-----------------------------------------------
path -> [('[i]', 'r', 'normalized', ['i'], 4232)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/pricingengines/barrier/discretizedbarrieroption.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<stoppingTimes_.size()  ++i
induction variable: ['i']
{
L4233: (stoppingTimes_[i]=,w) 
L4234: (stoppingTimes_[i]=,w) (stoppingTimes_[i],r) 
}
array table
-----------------------------------------------
stoppingTimes_ -> [('[i]', 'w', 'normalized', ['i'], 4233), ('[i]', 'w', 'normalized', ['i'], 4234), ('[i]', 'r', 'normalized', ['i'], 4234)]
LDEs formed:5

distinct LDEs:
i1=i2
#########################################################################################
loop info: Size i=0  i<stoppingTimes_.size()  i++
induction variable: ['i']
{
L4235: (stoppingTimes_[i],r) 
}
array table
-----------------------------------------------
stoppingTimes_ -> [('[i]', 'r', 'normalized', ['i'], 4235)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size j=0  j<optvalues.size()  j++
induction variable: ['j']
{
L4236: (grid[j],r) 
L4237: (optvalues[j]=,w) 
L4238: (grid[j],r) 
L4239: (optvalues[j]=,w) 
L4240: (optvalues[j]=,w) 
L4241: (grid[j],r) 
L4242: (optvalues[j]=,w) 
L4243: (optvalues[j]=,w) (optvalues[j],r) 
L4244: (grid[j],r) 
L4245: (grid[j],r) 
L4246: (optvalues[j]=,w) 
L4247: (grid[j],r) 
L4248: (optvalues[j]=,w) 
L4249: (optvalues[j]=,w) 
L4250: (grid[j],r) 
L4251: (optvalues[j]=,w) 
L4252: (optvalues[j]=,w) (optvalues[j],r) 
L4253: (grid[j],r) 
}
array table
-----------------------------------------------
optvalues -> [('[j]', 'w', 'normalized', ['j'], 4237), ('[j]', 'w', 'normalized', ['j'], 4239), ('[j]', 'w', 'normalized', ['j'], 4240), ('[j]', 'w', 'normalized', ['j'], 4242), ('[j]', 'w', 'normalized', ['j'], 4243), ('[j]', 'r', 'normalized', ['j'], 4243), ('[j]', 'w', 'normalized', ['j'], 4246), ('[j]', 'w', 'normalized', ['j'], 4248), ('[j]', 'w', 'normalized', ['j'], 4249), ('[j]', 'w', 'normalized', ['j'], 4251), ('[j]', 'w', 'normalized', ['j'], 4252), ('[j]', 'r', 'normalized', ['j'], 4252)]
LDEs formed:75

grid -> [('[j]', 'r', 'normalized', ['j'], 4236), ('[j]', 'r', 'normalized', ['j'], 4238), ('[j]', 'r', 'normalized', ['j'], 4241), ('[j]', 'r', 'normalized', ['j'], 4244), ('[j]', 'r', 'normalized', ['j'], 4245), ('[j]', 'r', 'normalized', ['j'], 4247), ('[j]', 'r', 'normalized', ['j'], 4250), ('[j]', 'r', 'normalized', ['j'], 4253)]
LDEs formed:0

distinct LDEs:
j1=j2
#########################################################################################
loop info: Size j=0  j<optvalues.size()-1  ++j
induction variable: ['j']
{
L4254: (grid[j],r) (grid[j+1],r) 
L4255: (grid[j+1],r) (grid[j],r) 
L4256: (optvalues[j+1],r) 
L4257: (grid[j],r) 
L4258: (grid[j+1]-,r) 
L4259: (grid[j+1]-,r) (grid[j],r) 
L4260: (optvalues[j+1]=,w) 
}
array table
-----------------------------------------------
optvalues -> [('[j+1]', 'r', 'normalized', ['j'], 4256), ('[j+1]', 'w', 'normalized', ['j'], 4260)]
LDEs formed:2

grid -> [('[j]', 'r', 'normalized', ['j'], 4254), ('[j+1]', 'r', 'normalized', ['j'], 4254), ('[j+1]', 'r', 'normalized', ['j'], 4255), ('[j]', 'r', 'normalized', ['j'], 4255), ('[j]', 'r', 'normalized', ['j'], 4257), ('[j+1]', 'r', 'normalized', ['j'], 4258), ('[j+1]', 'r', 'normalized', ['j'], 4259), ('[j]', 'r', 'normalized', ['j'], 4259)]
LDEs formed:0

distinct LDEs:
j1+1=j2+1
#########################################################################################
loop info: Size j=0  j<optvalues.size()-1  ++j
induction variable: ['j']
{
L4260: (grid[j],r) (grid[j+1],r) 
L4261: (grid[j+1],r) (grid[j],r) 
L4262: (optvalues[j+1],r) 
L4263: (grid[j],r) 
L4264: (grid[j+1]-,r) 
L4265: (grid[j+1]-,r) (grid[j],r) 
L4266: (optvalues[j+1]=,w) 
}
array table
-----------------------------------------------
optvalues -> [('[j+1]', 'r', 'normalized', ['j'], 4262), ('[j+1]', 'w', 'normalized', ['j'], 4266)]
LDEs formed:2

grid -> [('[j]', 'r', 'normalized', ['j'], 4260), ('[j+1]', 'r', 'normalized', ['j'], 4260), ('[j+1]', 'r', 'normalized', ['j'], 4261), ('[j]', 'r', 'normalized', ['j'], 4261), ('[j]', 'r', 'normalized', ['j'], 4263), ('[j+1]', 'r', 'normalized', ['j'], 4264), ('[j+1]', 'r', 'normalized', ['j'], 4265), ('[j]', 'r', 'normalized', ['j'], 4265)]
LDEs formed:0

distinct LDEs:
j1+1=j2+1
#########################################################################################
loop info: Size j=0  j<optvalues.size()-1  ++j
induction variable: ['j']
{
L4266: (grid[j],r) (grid[j+1],r) 
L4267: (grid[j+1],r) (grid[j],r) 
L4268: (optvalues[j],r) 
L4269: (grid[j],r) 
L4270: (grid[j+1]-,r) 
L4271: (grid[j+1]-,r) (grid[j],r) 
L4272: (optvalues[j]=,w) 
}
array table
-----------------------------------------------
optvalues -> [('[j]', 'r', 'normalized', ['j'], 4268), ('[j]', 'w', 'normalized', ['j'], 4272)]
LDEs formed:2

grid -> [('[j]', 'r', 'normalized', ['j'], 4266), ('[j+1]', 'r', 'normalized', ['j'], 4266), ('[j+1]', 'r', 'normalized', ['j'], 4267), ('[j]', 'r', 'normalized', ['j'], 4267), ('[j]', 'r', 'normalized', ['j'], 4269), ('[j+1]', 'r', 'normalized', ['j'], 4270), ('[j+1]', 'r', 'normalized', ['j'], 4271), ('[j]', 'r', 'normalized', ['j'], 4271)]
LDEs formed:0

distinct LDEs:
j1=j2
#########################################################################################
loop info: Size j=0  j<optvalues.size()-1  ++j
induction variable: ['j']
{
L4272: (grid[j],r) (grid[j+1],r) 
L4273: (grid[j+1],r) (grid[j],r) 
L4274: (optvalues[j],r) 
L4275: (grid[j],r) 
L4276: (grid[j+1]-,r) 
L4277: (grid[j+1]-,r) (grid[j],r) 
L4278: (optvalues[j]=,w) 
}
array table
-----------------------------------------------
optvalues -> [('[j]', 'r', 'normalized', ['j'], 4274), ('[j]', 'w', 'normalized', ['j'], 4278)]
LDEs formed:2

grid -> [('[j]', 'r', 'normalized', ['j'], 4272), ('[j+1]', 'r', 'normalized', ['j'], 4272), ('[j+1]', 'r', 'normalized', ['j'], 4273), ('[j]', 'r', 'normalized', ['j'], 4273), ('[j]', 'r', 'normalized', ['j'], 4275), ('[j+1]', 'r', 'normalized', ['j'], 4276), ('[j+1]', 'r', 'normalized', ['j'], 4277), ('[j]', 'r', 'normalized', ['j'], 4277)]
LDEs formed:0

distinct LDEs:
j1=j2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/pricingengines/capfloor/blackcapfloorengine.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<optionlets  ++i
induction variable: ['i']
{
L4278: (arguments_.endDates[i],r) 
L4279: (arguments_.nominals[i]*,r) 
L4280: (arguments_.gearings[i]*,r) 
L4281: (arguments_.accrualTimes[i],r) 
L4282: (arguments_.forwards[i],r) 
L4283: (arguments_.fixingDates[i],r) 
L4284: (arguments_.capRates[i],r) 
L4285: (stdDevs[i]=,w) 
L4286: (vegas[i]=,w) 
L4287: (stdDevs[i],r) 
L4288: (values[i]=,w) 
L4289: (stdDevs[i],r) 
L4290: (arguments_.floorRates[i],r) 
L4291: (stdDevs[i]=,w) 
L4292: (stdDevs[i],r) 
L4293: (stdDevs[i],r) 
L4294: (values[i]=,w) 
L4295: (vegas[i]=,w) 
L4296: (values[i]-=,w) 
L4297: (vegas[i]-=,w) 
L4298: (values[i],r) 
L4299: (vegas[i],r) 
}
array table
-----------------------------------------------
arguments_.capRates -> [('[i]', 'r', 'normalized', ['i'], 4284)]
LDEs formed:0

arguments_.floorRates -> [('[i]', 'r', 'normalized', ['i'], 4290)]
LDEs formed:0

arguments_.forwards -> [('[i]', 'r', 'normalized', ['i'], 4282)]
LDEs formed:0

stdDevs -> [('[i]', 'w', 'normalized', ['i'], 4285), ('[i]', 'r', 'normalized', ['i'], 4287), ('[i]', 'r', 'normalized', ['i'], 4289), ('[i]', 'w', 'normalized', ['i'], 4291), ('[i]', 'r', 'normalized', ['i'], 4292), ('[i]', 'r', 'normalized', ['i'], 4293)]
LDEs formed:11

arguments_.gearings -> [('[i]', 'r', 'normalized', ['i'], 4280)]
LDEs formed:0

vegas -> [('[i]', 'w', 'normalized', ['i'], 4286), ('[i]', 'w', 'normalized', ['i'], 4295), ('[i]', 'w', 'normalized', ['i'], 4297), ('[i]', 'r', 'normalized', ['i'], 4299)]
LDEs formed:9

values -> [('[i]', 'w', 'normalized', ['i'], 4288), ('[i]', 'w', 'normalized', ['i'], 4294), ('[i]', 'w', 'normalized', ['i'], 4296), ('[i]', 'r', 'normalized', ['i'], 4298)]
LDEs formed:9

arguments_.endDates -> [('[i]', 'r', 'normalized', ['i'], 4278)]
LDEs formed:0

arguments_.accrualTimes -> [('[i]', 'r', 'normalized', ['i'], 4281)]
LDEs formed:0

arguments_.fixingDates -> [('[i]', 'r', 'normalized', ['i'], 4283)]
LDEs formed:0

arguments_.nominals -> [('[i]', 'r', 'normalized', ['i'], 4279)]
LDEs formed:0

distinct LDEs:
i1=i2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/pricingengines/capfloor/analyticcapfloorengine.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<nPeriods  i++
induction variable: ['i']
{
L4280: (arguments_.fixingDates[i],r) 
L4281: (arguments_.endDates[i],r) 
L4282: (arguments_.accrualTimes[i],r) 
L4283: (arguments_.forwards[i],r) 
L4284: (arguments_.capRates[i],r) 
L4285: (arguments_.nominals[i]*,r) 
L4286: (arguments_.gearings[i],r) 
L4287: (arguments_.floorRates[i],r) 
L4288: (arguments_.nominals[i]*,r) 
L4289: (arguments_.gearings[i],r) 
L4290: (arguments_.startDates[i],r) 
L4291: (arguments_.capRates[i]*,r) 
L4292: (arguments_.nominals[i]*,r) 
L4293: (arguments_.gearings[i]*,r) 
L4294: (arguments_.floorRates[i]*,r) 
L4295: (arguments_.nominals[i]*,r) 
L4296: (arguments_.gearings[i]*,r) 
}
array table
-----------------------------------------------
arguments_.floorRates -> [('[i]', 'r', 'normalized', ['i'], 4287), ('[i]', 'r', 'normalized', ['i'], 4294)]
LDEs formed:0

arguments_.forwards -> [('[i]', 'r', 'normalized', ['i'], 4283)]
LDEs formed:0

arguments_.startDates -> [('[i]', 'r', 'normalized', ['i'], 4290)]
LDEs formed:0

arguments_.gearings -> [('[i]', 'r', 'normalized', ['i'], 4286), ('[i]', 'r', 'normalized', ['i'], 4289), ('[i]', 'r', 'normalized', ['i'], 4293), ('[i]', 'r', 'normalized', ['i'], 4296)]
LDEs formed:0

arguments_.accrualTimes -> [('[i]', 'r', 'normalized', ['i'], 4282)]
LDEs formed:0

arguments_.endDates -> [('[i]', 'r', 'normalized', ['i'], 4281)]
LDEs formed:0

arguments_.fixingDates -> [('[i]', 'r', 'normalized', ['i'], 4280)]
LDEs formed:0

arguments_.capRates -> [('[i]', 'r', 'normalized', ['i'], 4284), ('[i]', 'r', 'normalized', ['i'], 4291)]
LDEs formed:0

arguments_.nominals -> [('[i]', 'r', 'normalized', ['i'], 4285), ('[i]', 'r', 'normalized', ['i'], 4288), ('[i]', 'r', 'normalized', ['i'], 4292), ('[i]', 'r', 'normalized', ['i'], 4295)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/pricingengines/capfloor/bacheliercapfloorengine.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<optionlets  ++i
induction variable: ['i']
{
L4296: (arguments_.endDates[i],r) 
L4297: (arguments_.nominals[i]*,r) 
L4298: (arguments_.gearings[i]*,r) 
L4299: (arguments_.accrualTimes[i],r) 
L4300: (arguments_.forwards[i],r) 
L4301: (arguments_.fixingDates[i],r) 
L4302: (arguments_.capRates[i],r) 
L4303: (stdDevs[i]=,w) 
L4304: (vegas[i]=,w) 
L4305: (stdDevs[i],r) 
L4306: (values[i]=,w) 
L4307: (stdDevs[i],r) 
L4308: (arguments_.floorRates[i],r) 
L4309: (stdDevs[i]=,w) 
L4310: (stdDevs[i],r) 
L4311: (stdDevs[i],r) 
L4312: (values[i]=,w) 
L4313: (vegas[i]=,w) 
L4314: (values[i]-=,w) 
L4315: (vegas[i]-=,w) 
L4316: (values[i],r) 
L4317: (vegas[i],r) 
}
array table
-----------------------------------------------
arguments_.capRates -> [('[i]', 'r', 'normalized', ['i'], 4302)]
LDEs formed:0

arguments_.floorRates -> [('[i]', 'r', 'normalized', ['i'], 4308)]
LDEs formed:0

arguments_.forwards -> [('[i]', 'r', 'normalized', ['i'], 4300)]
LDEs formed:0

stdDevs -> [('[i]', 'w', 'normalized', ['i'], 4303), ('[i]', 'r', 'normalized', ['i'], 4305), ('[i]', 'r', 'normalized', ['i'], 4307), ('[i]', 'w', 'normalized', ['i'], 4309), ('[i]', 'r', 'normalized', ['i'], 4310), ('[i]', 'r', 'normalized', ['i'], 4311)]
LDEs formed:11

arguments_.gearings -> [('[i]', 'r', 'normalized', ['i'], 4298)]
LDEs formed:0

vegas -> [('[i]', 'w', 'normalized', ['i'], 4304), ('[i]', 'w', 'normalized', ['i'], 4313), ('[i]', 'w', 'normalized', ['i'], 4315), ('[i]', 'r', 'normalized', ['i'], 4317)]
LDEs formed:9

values -> [('[i]', 'w', 'normalized', ['i'], 4306), ('[i]', 'w', 'normalized', ['i'], 4312), ('[i]', 'w', 'normalized', ['i'], 4314), ('[i]', 'r', 'normalized', ['i'], 4316)]
LDEs formed:9

arguments_.endDates -> [('[i]', 'r', 'normalized', ['i'], 4296)]
LDEs formed:0

arguments_.accrualTimes -> [('[i]', 'r', 'normalized', ['i'], 4299)]
LDEs formed:0

arguments_.fixingDates -> [('[i]', 'r', 'normalized', ['i'], 4301)]
LDEs formed:0

arguments_.nominals -> [('[i]', 'r', 'normalized', ['i'], 4297)]
LDEs formed:0

distinct LDEs:
i1=i2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/pricingengines/capfloor/discretizedcapfloor.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<startTimes_.size()  i++
induction variable: ['i']
{
L4298: (startTimes_[i],r) 
L4299: (endTimes_[i],r) 
L4300: (arguments_.accrualTimes[i],r) 
L4301: (arguments_.gearings[i],r) 
L4302: (arguments_.nominals[i],r) 
L4303: (arguments_.capRates[i]*,r) 
	loop info: Size j=0  j<values_.size()  j++
	induction variable: ['i', 'j']
			{
			}
L4304: (arguments_.floorRates[i]*,r) 
	loop info: Size j=0  j<values_.size()  j++
	induction variable: ['i', 'j']
			{
			}
 }
array table
-----------------------------------------------
arguments_.floorRates -> [('[i]', 'r', 'normalized', ['i', 'j'], 4304)]
LDEs formed:0

endTimes_ -> [('[i]', 'r', 'normalized', ['i', 'j'], 4299)]
LDEs formed:0

arguments_.gearings -> [('[i]', 'r', 'normalized', ['i', 'j'], 4301)]
LDEs formed:0

arguments_.accrualTimes -> [('[i]', 'r', 'normalized', ['i', 'j'], 4300)]
LDEs formed:0

arguments_.capRates -> [('[i]', 'r', 'normalized', ['i', 'j'], 4303)]
LDEs formed:0

arguments_.nominals -> [('[i]', 'r', 'normalized', ['i', 'j'], 4302)]
LDEs formed:0

startTimes_ -> [('[i]', 'r', 'normalized', ['i', 'j'], 4298)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<endTimes_.size()  i++
induction variable: ['i']
{
L4299: (endTimes_[i],r) 
L4300: (startTimes_[i],r) 
L4301: (arguments_.nominals[i],r) 
L4302: (arguments_.accrualTimes[i],r) 
L4303: (arguments_.forwards[i],r) 
L4304: (arguments_.gearings[i],r) 
L4305: (arguments_.capRates[i],r) 
L4306: (arguments_.floorRates[i],r) 
}
array table
-----------------------------------------------
arguments_.floorRates -> [('[i]', 'r', 'normalized', ['i'], 4306)]
LDEs formed:0

arguments_.forwards -> [('[i]', 'r', 'normalized', ['i'], 4303)]
LDEs formed:0

endTimes_ -> [('[i]', 'r', 'normalized', ['i'], 4299)]
LDEs formed:0

arguments_.gearings -> [('[i]', 'r', 'normalized', ['i'], 4304)]
LDEs formed:0

arguments_.accrualTimes -> [('[i]', 'r', 'normalized', ['i'], 4302)]
LDEs formed:0

arguments_.capRates -> [('[i]', 'r', 'normalized', ['i'], 4305)]
LDEs formed:0

arguments_.nominals -> [('[i]', 'r', 'normalized', ['i'], 4301)]
LDEs formed:0

startTimes_ -> [('[i]', 'r', 'normalized', ['i'], 4300)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/pricingengines/capfloor/mchullwhiteengine.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i = 0  i<fixingTimes_.size()  i++
induction variable: ['i']
{
L4301: (args_.accrualTimes[i],r) 
L4302: (startTimes_[i],r) 
L4303: (endTimes_[i],r) 
L4304: (fixingTimes_[i],r) 
L4305: (args_.forwards[i],r) 
L4306: (path[i-pastFixings+2],r) 
L4307: (path[i-pastFixings+1],r) 
L4308: (path[i-pastFixings+2],r) 
L4309: (args_.capRates[i],r) 
L4310: (args_.floorRates[i],r) 
L4311: (args_.gearings[i]*,r) 
L4312: (args_.nominals[i]*,r) 
}
array table
-----------------------------------------------
args_.gearings -> [('[i]', 'r', 'normalized', ['i'], 4311)]
LDEs formed:0

args_.accrualTimes -> [('[i]', 'r', 'normalized', ['i'], 4301)]
LDEs formed:0

endTimes_ -> [('[i]', 'r', 'normalized', ['i'], 4303)]
LDEs formed:0

args_.nominals -> [('[i]', 'r', 'normalized', ['i'], 4312)]
LDEs formed:0

fixingTimes_ -> [('[i]', 'r', 'normalized', ['i'], 4304)]
LDEs formed:0

args_.capRates -> [('[i]', 'r', 'normalized', ['i'], 4309)]
LDEs formed:0

args_.forwards -> [('[i]', 'r', 'normalized', ['i'], 4305)]
LDEs formed:0

path -> [('[i-pastFixings+2]', 'r', 'not normalized', ['i'], 4306), ('[i-pastFixings+1]', 'r', 'not normalized', ['i'], 4307), ('[i-pastFixings+2]', 'r', 'not normalized', ['i'], 4308)]
LDEs formed:0

args_.floorRates -> [('[i]', 'r', 'normalized', ['i'], 4310)]
LDEs formed:0

startTimes_ -> [('[i]', 'r', 'normalized', ['i'], 4302)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/pricingengines/capfloor/gaussian1dcapfloorengine.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i = 0  i < optionlets  ++i
induction variable: ['i']
{
L4303: (arguments_.startDates[i],r) 
L4304: (arguments_.endDates[i],r) 
L4305: (arguments_.indexes[i],r) 
L4306: (arguments_.nominals[i]*,r) (arguments_.gearings[i],r) 
L4307: (arguments_.fixingDates[i],r) 
L4308: (arguments_.capRates[i],r) 
L4309: (values[i]=,w) 
L4310: (arguments_.forwards[i]-,r) 
L4311: (arguments_.accrualTimes[i],r) 
	loop info: Size j = 0  j < z.size()  j++
	induction variable: ['i', 'j']
				{
				L4312: (arguments_.accrualTimes[i]*,r) 
				L4313: (z[j],r) 
				L4314: (z[j],r) 
				L4315: (z[j],r) 
				L4316: (z[j],r) 
				L4317: (arguments_.capRates[i]*,r) 
				L4318: (arguments_.accrualTimes[i]*,r) 
				L4319: (z[j],r) 
				L4320: (p[j]=,w) 
				L4321: (z[j],r) 
				}
	loop info: Size j = 0  j < z.size() - 1  j++
	induction variable: ['i', 'j']
				{
				L4322: (p[j],r) (z[j],r) (z[j],r) 
				L4323: (z[j + 1],r) 
				}
L4324: (p[z.size() - 2],r) 
L4325: (z[z.size() - 2],r) (z[z.size() - 1],r) 
L4326: (p[0],r) (z[0],r) 
L4327: (z[0],r) 
L4328: (p[z.size() - 2],r) (z[z.size() - 2],r) 
L4329: (z[z.size() - 1],r) 
L4330: (values[i]=,w) 
L4331: (arguments_.floorRates[i],r) 
L4332: (arguments_.forwards[i]-,r) 
L4333: (arguments_.accrualTimes[i],r) 
	loop info: Size j = 0  j < z.size()  j++
	induction variable: ['i', 'j']
				{
				L4334: (arguments_.accrualTimes[i]*,r) 
				L4335: (z[j],r) 
				L4336: (z[j],r) 
				L4337: (z[j],r) 
				L4338: (z[j],r) 
				L4339: (arguments_.floorRates[i]*,r) 
				L4340: (arguments_.accrualTimes[i]*,r) 
				L4341: (z[j],r) 
				L4342: (p[j]=,w) 
				L4343: (z[j],r) 
				}
	loop info: Size j = 0  j < z.size() - 1  j++
	induction variable: ['i', 'j']
				{
				L4344: (p[j],r) (z[j],r) (z[j],r) 
				L4345: (z[j + 1],r) 
				}
L4346: (p[z.size() - 2],r) 
L4347: (z[z.size() - 2],r) (z[z.size() - 1],r) 
L4348: (p[0],r) (z[0],r) 
L4349: (z[0],r) 
L4350: (p[0],r) (z[0],r) 
L4351: (z[0],r) 
L4352: (values[i]=,w) 
L4353: (values[i]-=,w) 
L4354: (values[i],r) 
}
array table
-----------------------------------------------
arguments_.floorRates -> [('[i]', 'r', 'normalized', ['i', 'j'], 4331), ('[i]', 'r', 'normalized', ['i', 'j'], 4339)]
LDEs formed:0

arguments_.forwards -> [('[i]', 'r', 'normalized', ['i', 'j'], 4310), ('[i]', 'r', 'normalized', ['i', 'j'], 4332)]
LDEs formed:0

arguments_.indexes -> [('[i]', 'r', 'normalized', ['i', 'j'], 4305)]
LDEs formed:0

arguments_.startDates -> [('[i]', 'r', 'normalized', ['i', 'j'], 4303)]
LDEs formed:0

arguments_.gearings -> [('[i]', 'r', 'normalized', ['i', 'j'], 4306)]
LDEs formed:0

arguments_.accrualTimes -> [('[i]', 'r', 'normalized', ['i', 'j'], 4311), ('[i]', 'r', 'normalized', ['i', 'j'], 4312), ('[i]', 'r', 'normalized', ['i', 'j'], 4318), ('[i]', 'r', 'normalized', ['i', 'j'], 4333), ('[i]', 'r', 'normalized', ['i', 'j'], 4334), ('[i]', 'r', 'normalized', ['i', 'j'], 4340)]
LDEs formed:0

p -> [('[j]', 'w', 'normalized', ['i', 'j'], 4320), ('[j]', 'r', 'normalized', ['i', 'j'], 4322), ('[z.size() - 2]', 'r', 'not normalized', ['i', 'j'], 4324), ('[0]', 'r', 'normalized', ['i', 'j'], 4326), ('[z.size() - 2]', 'r', 'not normalized', ['i', 'j'], 4328), ('[j]', 'w', 'normalized', ['i', 'j'], 4342), ('[j]', 'r', 'normalized', ['i', 'j'], 4344), ('[z.size() - 2]', 'r', 'not normalized', ['i', 'j'], 4346), ('[0]', 'r', 'normalized', ['i', 'j'], 4348), ('[0]', 'r', 'normalized', ['i', 'j'], 4350)]
LDEs formed:19

values -> [('[i]', 'w', 'normalized', ['i', 'j'], 4309), ('[i]', 'w', 'normalized', ['i', 'j'], 4330), ('[i]', 'w', 'normalized', ['i', 'j'], 4352), ('[i]', 'w', 'normalized', ['i', 'j'], 4353), ('[i]', 'r', 'normalized', ['i', 'j'], 4354)]
LDEs formed:14

z -> [('[j]', 'r', 'normalized', ['i', 'j'], 4313), ('[j]', 'r', 'normalized', ['i', 'j'], 4314), ('[j]', 'r', 'normalized', ['i', 'j'], 4315), ('[j]', 'r', 'normalized', ['i', 'j'], 4316), ('[j]', 'r', 'normalized', ['i', 'j'], 4319), ('[j]', 'r', 'normalized', ['i', 'j'], 4321), ('[j]', 'r', 'normalized', ['i', 'j'], 4322), ('[j]', 'r', 'normalized', ['i', 'j'], 4322), ('[j + 1]', 'r', 'normalized', ['i', 'j'], 4323), ('[z.size() - 2]', 'r', 'not normalized', ['i', 'j'], 4325), ('[z.size() - 1]', 'r', 'not normalized', ['i', 'j'], 4325), ('[0]', 'r', 'normalized', ['i', 'j'], 4326), ('[0]', 'r', 'normalized', ['i', 'j'], 4327), ('[z.size() - 2]', 'r', 'not normalized', ['i', 'j'], 4328), ('[z.size() - 1]', 'r', 'not normalized', ['i', 'j'], 4329), ('[j]', 'r', 'normalized', ['i', 'j'], 4335), ('[j]', 'r', 'normalized', ['i', 'j'], 4336), ('[j]', 'r', 'normalized', ['i', 'j'], 4337), ('[j]', 'r', 'normalized', ['i', 'j'], 4338), ('[j]', 'r', 'normalized', ['i', 'j'], 4341), ('[j]', 'r', 'normalized', ['i', 'j'], 4343), ('[j]', 'r', 'normalized', ['i', 'j'], 4344), ('[j]', 'r', 'normalized', ['i', 'j'], 4344), ('[j + 1]', 'r', 'normalized', ['i', 'j'], 4345), ('[z.size() - 2]', 'r', 'not normalized', ['i', 'j'], 4347), ('[z.size() - 1]', 'r', 'not normalized', ['i', 'j'], 4347), ('[0]', 'r', 'normalized', ['i', 'j'], 4348), ('[0]', 'r', 'normalized', ['i', 'j'], 4349), ('[0]', 'r', 'normalized', ['i', 'j'], 4350), ('[0]', 'r', 'normalized', ['i', 'j'], 4351)]
LDEs formed:0

arguments_.endDates -> [('[i]', 'r', 'normalized', ['i', 'j'], 4304)]
LDEs formed:0

arguments_.capRates -> [('[i]', 'r', 'normalized', ['i', 'j'], 4308), ('[i]', 'r', 'normalized', ['i', 'j'], 4317)]
LDEs formed:0

arguments_.fixingDates -> [('[i]', 'r', 'normalized', ['i', 'j'], 4307)]
LDEs formed:0

arguments_.nominals -> [('[i]', 'r', 'normalized', ['i', 'j'], 4306)]
LDEs formed:0

distinct LDEs:
j1=j2
j1=z.size() - 2
j1=0
i1=i2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/pricingengines/swap/discountingswapengine.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<n  ++i
induction variable: ['i']
{
L4307: (arguments_.legs[i],r) 
L4308: (results_.legNPV[i],r) 
L4309: (results_.legBPS[i],r) 
L4310: (results_.legNPV[i]*=,w) (arguments_.payer[i],r) 
L4311: (results_.legBPS[i]*=,w) (arguments_.payer[i],r) 
L4312: (arguments_.legs[i].empty,r) 
L4313: (arguments_.legs[i],r) 
L4314: (results_.startDiscounts[i]=,w) 
L4315: (results_.startDiscounts[i]=,w) 
L4316: (arguments_.legs[i],r) 
L4317: (results_.endDiscounts[i]=,w) 
L4318: (results_.endDiscounts[i]=,w) 
L4319: (results_.startDiscounts[i]=,w) 
L4320: (results_.endDiscounts[i]=,w) 
L4321: (results_.legNPV[i],r) 
}
array table
-----------------------------------------------
results_.endDiscounts -> [('[i]', 'w', 'normalized', ['i'], 4317), ('[i]', 'w', 'normalized', ['i'], 4318), ('[i]', 'w', 'normalized', ['i'], 4320)]
LDEs formed:6

arguments_.legs -> [('[i]', 'r', 'normalized', ['i'], 4307), ('[i]', 'r', 'normalized', ['i'], 4312), ('[i]', 'r', 'normalized', ['i'], 4313), ('[i]', 'r', 'normalized', ['i'], 4316)]
LDEs formed:0

results_.legNPV -> [('[i]', 'r', 'normalized', ['i'], 4308), ('[i]', 'w', 'normalized', ['i'], 4310), ('[i]', 'r', 'normalized', ['i'], 4321)]
LDEs formed:3

results_.startDiscounts -> [('[i]', 'w', 'normalized', ['i'], 4314), ('[i]', 'w', 'normalized', ['i'], 4315), ('[i]', 'w', 'normalized', ['i'], 4319)]
LDEs formed:6

results_.legBPS -> [('[i]', 'r', 'normalized', ['i'], 4309), ('[i]', 'w', 'normalized', ['i'], 4311)]
LDEs formed:2

arguments_.payer -> [('[i]', 'r', 'normalized', ['i'], 4310), ('[i]', 'r', 'normalized', ['i'], 4311)]
LDEs formed:0

distinct LDEs:
i1=i2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/pricingengines/swap/discretizedswap.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<fixedResetTimes_.size()  i++
induction variable: ['i']
{
L4312: (fixedResetTimes_[i],r) 
}
array table
-----------------------------------------------
fixedResetTimes_ -> [('[i]', 'r', 'normalized', ['i'], 4312)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<fixedPayTimes_.size()  i++
induction variable: ['i']
{
L4313: (fixedPayTimes_[i],r) 
}
array table
-----------------------------------------------
fixedPayTimes_ -> [('[i]', 'r', 'normalized', ['i'], 4313)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<floatingResetTimes_.size()  i++
induction variable: ['i']
{
L4314: (floatingResetTimes_[i],r) 
}
array table
-----------------------------------------------
floatingResetTimes_ -> [('[i]', 'r', 'normalized', ['i'], 4314)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<floatingPayTimes_.size()  i++
induction variable: ['i']
{
L4315: (floatingPayTimes_[i],r) 
}
array table
-----------------------------------------------
floatingPayTimes_ -> [('[i]', 'r', 'normalized', ['i'], 4315)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<floatingResetTimes_.size()  i++
induction variable: ['i']
{
L4316: (floatingResetTimes_[i],r) 
L4317: (floatingPayTimes_[i],r) 
L4318: (arguments_.floatingAccrualTimes[i],r) 
L4319: (arguments_.floatingSpreads[i],r) 
	loop info: Size j=0  j<values_.size()  j++
	induction variable: ['i', 'j']
		{
		L4320: (values_[j]+=,w) 
		L4321: (values_[j]-=,w) 
		}
 }
array table
-----------------------------------------------
floatingPayTimes_ -> [('[i]', 'r', 'normalized', ['i', 'j'], 4317)]
LDEs formed:0

arguments_.floatingSpreads -> [('[i]', 'r', 'normalized', ['i', 'j'], 4319)]
LDEs formed:0

floatingResetTimes_ -> [('[i]', 'r', 'normalized', ['i', 'j'], 4316)]
LDEs formed:0

values_ -> [('[j]', 'w', 'normalized', ['i', 'j'], 4320), ('[j]', 'w', 'normalized', ['i', 'j'], 4321)]
LDEs formed:3

arguments_.floatingAccrualTimes -> [('[i]', 'r', 'normalized', ['i', 'j'], 4318)]
LDEs formed:0

distinct LDEs:
j1=j2
#########################################################################################
loop info: Size i=0  i<fixedResetTimes_.size()  i++
induction variable: ['i']
{
L4319: (fixedResetTimes_[i],r) 
L4320: (fixedPayTimes_[i],r) 
L4321: (arguments_.fixedCoupons[i],r) 
	loop info: Size j=0  j<values_.size()  j++
	induction variable: ['i', 'j']
		{
		L4322: (values_[j]-=,w) 
		L4323: (values_[j]+=,w) 
		}
 }
array table
-----------------------------------------------
arguments_.fixedCoupons -> [('[i]', 'r', 'normalized', ['i', 'j'], 4321)]
LDEs formed:0

fixedResetTimes_ -> [('[i]', 'r', 'normalized', ['i', 'j'], 4319)]
LDEs formed:0

fixedPayTimes_ -> [('[i]', 'r', 'normalized', ['i', 'j'], 4320)]
LDEs formed:0

values_ -> [('[j]', 'w', 'normalized', ['i', 'j'], 4322), ('[j]', 'w', 'normalized', ['i', 'j'], 4323)]
LDEs formed:3

distinct LDEs:
j1=j2
#########################################################################################
loop info: Size i=0  i<fixedPayTimes_.size()  i++
induction variable: ['i']
{
L4324: (fixedPayTimes_[i],r) 
L4325: (fixedResetTimes_[i],r) 
L4326: (arguments_.fixedCoupons[i],r) 
}
array table
-----------------------------------------------
arguments_.fixedCoupons -> [('[i]', 'r', 'normalized', ['i'], 4326)]
LDEs formed:0

fixedResetTimes_ -> [('[i]', 'r', 'normalized', ['i'], 4325)]
LDEs formed:0

fixedPayTimes_ -> [('[i]', 'r', 'normalized', ['i'], 4324)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<floatingPayTimes_.size()  i++
induction variable: ['i']
{
L4325: (floatingPayTimes_[i],r) 
L4326: (floatingResetTimes_[i],r) 
L4327: (arguments_.floatingCoupons[i],r) 
}
array table
-----------------------------------------------
floatingPayTimes_ -> [('[i]', 'r', 'normalized', ['i'], 4325)]
LDEs formed:0

arguments_.floatingCoupons -> [('[i]', 'r', 'normalized', ['i'], 4327)]
LDEs formed:0

floatingResetTimes_ -> [('[i]', 'r', 'normalized', ['i'], 4326)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/pricingengines/swaption/jamshidianswaptionengine.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<size  i++
induction variable: ['i']
{
L4327: (times_[i],r) 
L4328: (amounts_[i]*,r) 
}
array table
-----------------------------------------------
amounts_ -> [('[i]', 'r', 'normalized', ['i'], 4328)]
LDEs formed:0

times_ -> [('[i]', 'r', 'normalized', ['i'], 4327)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<size  i++
induction variable: ['i']
{
L4328: (arguments_.fixedPayDates[i],r) 
L4329: (amounts[i]*,r) 
}
array table
-----------------------------------------------
amounts -> [('[i]', 'r', 'normalized', ['i'], 4329)]
LDEs formed:0

arguments_.fixedPayDates -> [('[i]', 'r', 'normalized', ['i'], 4328)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/pricingengines/swaption/discretizedswaption.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<arguments_.exercise->dates().size()  i++
induction variable: ['i']
{
	loop info: Size j=0  j<arguments_.fixedPayDates.size()  j++
	induction variable: ['i', 'j']
	{
	L4329: (arguments_.fixedPayDates[j],r) 
	L4330: (arguments_.fixedResetDates[j],r) 
	L4331: (arguments_.fixedPayDates[j]=,w) 
	}
L4332: (arguments_.fixedResetDates[j],r) 
L4333: (arguments_.fixedResetDates[j]=,w) 
	loop info: Size j=0  j<arguments_.floatingResetDates.size()  j++
	induction variable: ['i', 'j']
	{
	L4334: (arguments_.floatingResetDates[j],r) 
	L4335: (arguments_.floatingResetDates[j]=,w) 
	}
 }
array table
-----------------------------------------------
arguments_.floatingResetDates -> [('[j]', 'r', 'normalized', ['i', 'j'], 4334), ('[j]', 'w', 'normalized', ['i', 'j'], 4335)]
LDEs formed:2

arguments_.fixedResetDates -> [('[j]', 'r', 'normalized', ['i', 'j'], 4330), ('[j]', 'r', 'normalized', ['i', 'j'], 4332), ('[j]', 'w', 'normalized', ['i', 'j'], 4333)]
LDEs formed:3

arguments_.fixedPayDates -> [('[j]', 'r', 'normalized', ['i', 'j'], 4329), ('[j]', 'w', 'normalized', ['i', 'j'], 4331)]
LDEs formed:2

distinct LDEs:
j1=j2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/pricingengines/swaption/treeswaptionengine.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/pricingengines/swaption/gaussian1dswaptionengine.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size l = k1  l < arguments_.floatingCoupons.size()  l++
induction variable: ['l']
{
L4332: (arguments_.floatingFixingDates[l],r) 
L4333: (arguments_.floatingPayDates[l],r) 
}
array table
-----------------------------------------------
arguments_.floatingFixingDates -> [('[l]', 'r', 'normalized', ['l'], 4332)]
LDEs formed:0

arguments_.floatingPayDates -> [('[l]', 'r', 'normalized', ['l'], 4333)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size l = j1  l < arguments_.fixedCoupons.size()  l++
induction variable: ['l']
{
L4334: (arguments_.fixedPayDates[l],r) 
}
array table
-----------------------------------------------
arguments_.fixedPayDates -> [('[l]', 'r', 'normalized', ['l'], 4334)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i = 0  i < yg.size()  i++
induction variable: ['i']
{
L4335: (p[i]=,w) (yg[i],r) 
}
array table
-----------------------------------------------
p -> [('[i]', 'w', 'normalized', ['i'], 4335)]
LDEs formed:1

yg -> [('[i]', 'r', 'normalized', ['i'], 4335)]
LDEs formed:0

distinct LDEs:
i1=i2
#########################################################################################
loop info: Size i = 0  i < z.size() - 1  i++
induction variable: ['i']
{
L4336: (p[i],r) (z[i],r) (z[i],r) 
L4337: (z[i + 1],r) 
}
array table
-----------------------------------------------
p -> [('[i]', 'r', 'normalized', ['i'], 4336)]
LDEs formed:0

z -> [('[i]', 'r', 'normalized', ['i'], 4336), ('[i]', 'r', 'normalized', ['i'], 4336), ('[i + 1]', 'r', 'normalized', ['i'], 4337)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size m = 0  m < npvp0.size()  m++
induction variable: ['m']
{
L4338: (z[k],r) 
L4339: (npvp1[m].begin,r) 
	loop info: Size i = 0  i < yg.size()  i++
	induction variable: ['m', 'i']
		{
		L4340: (p[i]=,w) (yg[i],r) 
		}
	loop info: Size i = 0  i < z.size() - 1  i++
	induction variable: ['m', 'i']
		{
		L4341: (p[i],r) (z[i],r) 
		L4342: (z[i],r) (z[i + 1],r) 
		}
L4343: (p[z.size() - 2],r) 
L4344: (z[z.size() - 2],r) 
L4345: (z[z.size() - 1],r) 
L4346: (p[0],r) 
L4347: (z[0],r) (z[0],r) 
L4348: (p[z.size() - 2],r) 
L4349: (z[z.size() - 2],r) 
L4350: (z[z.size() - 1],r) 
L4351: (p[0],r) (z[0],r) (z[0],r) 
L4352: (npvp0[m][k]=,w) 
}
array table
-----------------------------------------------
p -> [('[i]', 'w', 'normalized', ['m', 'i'], 4340), ('[i]', 'r', 'normalized', ['m', 'i'], 4341), ('[z.size() - 2]', 'r', 'not normalized', ['m', 'i'], 4343), ('[0]', 'r', 'normalized', ['m', 'i'], 4346), ('[z.size() - 2]', 'r', 'not normalized', ['m', 'i'], 4348), ('[0]', 'r', 'normalized', ['m', 'i'], 4351)]
LDEs formed:6

z -> [('[k]', 'r', 'not normalized', ['m', 'i'], 4338), ('[i]', 'r', 'normalized', ['m', 'i'], 4341), ('[i]', 'r', 'normalized', ['m', 'i'], 4342), ('[i + 1]', 'r', 'normalized', ['m', 'i'], 4342), ('[z.size() - 2]', 'r', 'not normalized', ['m', 'i'], 4344), ('[z.size() - 1]', 'r', 'not normalized', ['m', 'i'], 4345), ('[0]', 'r', 'normalized', ['m', 'i'], 4347), ('[0]', 'r', 'normalized', ['m', 'i'], 4347), ('[z.size() - 2]', 'r', 'not normalized', ['m', 'i'], 4349), ('[z.size() - 1]', 'r', 'not normalized', ['m', 'i'], 4350), ('[0]', 'r', 'normalized', ['m', 'i'], 4351), ('[0]', 'r', 'normalized', ['m', 'i'], 4351)]
LDEs formed:0

npvp1 -> [('[m]', 'r', 'normalized', ['m', 'i'], 4339)]
LDEs formed:0

npvp0 -> [('[m][k]', 'w', 'not normalized', ['m', 'i'], 4352)]
LDEs formed:2

yg -> [('[i]', 'r', 'normalized', ['m', 'i'], 4340)]
LDEs formed:0

distinct LDEs:
m1=m2,k=k
i1=z.size() - 2
i1=0
i1=i2
#########################################################################################
loop info: Size l = j1  l < arguments_.fixedCoupons.size()  l++
induction variable: ['l']
{
L4341: (arguments_.fixedCoupons[l]*,r) 
L4342: (arguments_.fixedPayDates[l],r) 
L4343: (z[k],r) 
}
array table
-----------------------------------------------
arguments_.fixedPayDates -> [('[l]', 'r', 'normalized', ['l'], 4342)]
LDEs formed:0

arguments_.fixedCoupons -> [('[l]', 'r', 'normalized', ['l'], 4341)]
LDEs formed:0

z -> [('[k]', 'r', 'not normalized', ['l'], 4343)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i = 0  i < npvp0.size()  i++
induction variable: ['i']
{
L4344: (prob[i]=,w) (npvp1[i][0]*,r) 
}
array table
-----------------------------------------------
npvp1 -> [('[i][0]', 'r', 'normalized', ['i'], 4344)]
LDEs formed:0

prob -> [('[i]', 'w', 'normalized', ['i'], 4344)]
LDEs formed:1

distinct LDEs:
i1=i2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/pricingengines/swaption/fdg2swaptionengine.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i < exerciseDates.size()  ++i
induction variable: ['i']
{
L4345: (exerciseDates[i],r) 
L4346: (t2d[t]=,w) (exerciseDates[i],r) 
}
array table
-----------------------------------------------
exerciseDates -> [('[i]', 'r', 'normalized', ['i'], 4345), ('[i]', 'r', 'normalized', ['i'], 4346)]
LDEs formed:0

t2d -> [('[t]', 'w', 'not normalized', ['i'], 4346)]
LDEs formed:1

distinct LDEs:
t=t
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/pricingengines/swaption/gaussian1djamshidianswaptionengine.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i = startIndex_  i < size  i++
induction variable: ['i']
{
L4347: (times_[i],r) 
L4348: (amounts_[i]*,r) 
}
array table
-----------------------------------------------
amounts_ -> [('[i]', 'r', 'normalized', ['i'], 4348)]
LDEs formed:0

times_ -> [('[i]', 'r', 'normalized', ['i'], 4347)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i = startIndex  i < size  i++
induction variable: ['i']
{
L4348: (arguments_.fixedPayDates[i],r) 
L4349: (arguments_.fixedPayDates[i],r) 
L4350: (arguments_.fixedResetDates[startIndex],r) 
L4351: (arguments_.fixedResetDates[startIndex],r) 
L4352: (arguments_.fixedPayDates[i],r) 
L4353: (amounts[i]*,r) 
}
array table
-----------------------------------------------
amounts -> [('[i]', 'r', 'normalized', ['i'], 4353)]
LDEs formed:0

arguments_.fixedResetDates -> [('[startIndex]', 'r', 'not normalized', ['i'], 4350), ('[startIndex]', 'r', 'not normalized', ['i'], 4351)]
LDEs formed:0

arguments_.fixedPayDates -> [('[i]', 'r', 'normalized', ['i'], 4348), ('[i]', 'r', 'normalized', ['i'], 4349), ('[i]', 'r', 'normalized', ['i'], 4352)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/pricingengines/swaption/fdhullwhiteswaptionengine.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i < exerciseDates.size()  ++i
induction variable: ['i']
{
L4353: (exerciseDates[i],r) 
L4354: (t2d[t]=,w) (exerciseDates[i],r) 
}
array table
-----------------------------------------------
exerciseDates -> [('[i]', 'r', 'normalized', ['i'], 4353), ('[i]', 'r', 'normalized', ['i'], 4354)]
LDEs formed:0

t2d -> [('[t]', 'w', 'not normalized', ['i'], 4354)]
LDEs formed:1

distinct LDEs:
t=t
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/pricingengines/swaption/gaussian1dnonstandardswaptionengine.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i = fixedIdx  i < arguments_.fixedResetDates.size()  i++
induction variable: ['i']
{
L4355: (arguments_.fixedCoupons[i]*,r) 
L4356: (arguments_.fixedPayDates[i],r) 
L4357: (arguments_.fixedPayDates[i],r) 
}
array table
-----------------------------------------------
arguments_.fixedPayDates -> [('[i]', 'r', 'normalized', ['i'], 4356), ('[i]', 'r', 'normalized', ['i'], 4357)]
LDEs formed:0

arguments_.fixedCoupons -> [('[i]', 'r', 'normalized', ['i'], 4355)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i = fixedIdx  i < arguments_.fixedResetDates.size()  i++
induction variable: ['i']
{
L4356: (arguments_.fixedNominal[i],r) 
L4357: (arguments_.fixedRate[i],r) 
L4358: (arguments_.fixedNominal[i]*,r) 
L4359: (arguments_.fixedNominal[i],r) 
}
array table
-----------------------------------------------
arguments_.fixedNominal -> [('[i]', 'r', 'normalized', ['i'], 4356), ('[i]', 'r', 'normalized', ['i'], 4358), ('[i]', 'r', 'normalized', ['i'], 4359)]
LDEs formed:0

arguments_.fixedRate -> [('[i]', 'r', 'normalized', ['i'], 4357)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i = 0  i < yg.size()  i++
induction variable: ['i']
{
L4358: (p[i]=,w) (yg[i],r) 
}
array table
-----------------------------------------------
p -> [('[i]', 'w', 'normalized', ['i'], 4358)]
LDEs formed:1

yg -> [('[i]', 'r', 'normalized', ['i'], 4358)]
LDEs formed:0

distinct LDEs:
i1=i2
#########################################################################################
loop info: Size i = 0  i < z.size() - 1  i++
induction variable: ['i']
{
L4359: (p[i],r) (z[i],r) 
L4360: (z[i],r) (z[i + 1],r) 
}
array table
-----------------------------------------------
p -> [('[i]', 'r', 'normalized', ['i'], 4359)]
LDEs formed:0

z -> [('[i]', 'r', 'normalized', ['i'], 4359), ('[i]', 'r', 'normalized', ['i'], 4360), ('[i + 1]', 'r', 'normalized', ['i'], 4360)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size m = 0  m < npvp0.size()  m++
induction variable: ['m']
{
L4361: (z[k],r) 
L4362: (npvp1[m].begin,r) 
	loop info: Size i = 0  i < yg.size()  i++
	induction variable: ['m', 'i']
		{
		L4363: (p[i]=,w) (yg[i],r) 
		}
	loop info: Size i = 0  i < z.size() - 1  i++
	induction variable: ['m', 'i']
		{
		L4364: (p[i],r) (z[i],r) 
		L4365: (z[i],r) (z[i + 1],r) 
		}
L4366: (p[z.size() - 2],r) 
L4367: (z[z.size() - 2],r) 
L4368: (z[z.size() - 1],r) 
L4369: (p[0],r) 
L4370: (z[0],r) (z[0],r) 
L4371: (p[z.size() - 2],r) 
L4372: (z[z.size() - 2],r) 
L4373: (z[z.size() - 1],r) 
L4374: (p[0],r) (z[0],r) 
L4375: (z[0],r) 
L4376: (npvp0[m][k]=,w) 
}
array table
-----------------------------------------------
p -> [('[i]', 'w', 'normalized', ['m', 'i'], 4363), ('[i]', 'r', 'normalized', ['m', 'i'], 4364), ('[z.size() - 2]', 'r', 'not normalized', ['m', 'i'], 4366), ('[0]', 'r', 'normalized', ['m', 'i'], 4369), ('[z.size() - 2]', 'r', 'not normalized', ['m', 'i'], 4371), ('[0]', 'r', 'normalized', ['m', 'i'], 4374)]
LDEs formed:6

z -> [('[k]', 'r', 'not normalized', ['m', 'i'], 4361), ('[i]', 'r', 'normalized', ['m', 'i'], 4364), ('[i]', 'r', 'normalized', ['m', 'i'], 4365), ('[i + 1]', 'r', 'normalized', ['m', 'i'], 4365), ('[z.size() - 2]', 'r', 'not normalized', ['m', 'i'], 4367), ('[z.size() - 1]', 'r', 'not normalized', ['m', 'i'], 4368), ('[0]', 'r', 'normalized', ['m', 'i'], 4370), ('[0]', 'r', 'normalized', ['m', 'i'], 4370), ('[z.size() - 2]', 'r', 'not normalized', ['m', 'i'], 4372), ('[z.size() - 1]', 'r', 'not normalized', ['m', 'i'], 4373), ('[0]', 'r', 'normalized', ['m', 'i'], 4374), ('[0]', 'r', 'normalized', ['m', 'i'], 4375)]
LDEs formed:0

npvp1 -> [('[m]', 'r', 'normalized', ['m', 'i'], 4362)]
LDEs formed:0

npvp0 -> [('[m][k]', 'w', 'not normalized', ['m', 'i'], 4376)]
LDEs formed:2

yg -> [('[i]', 'r', 'normalized', ['m', 'i'], 4363)]
LDEs formed:0

distinct LDEs:
m1=m2,k=k
i1=z.size() - 2
i1=0
i1=i2
#########################################################################################
loop info: Size l = j1  l < arguments_.fixedCoupons.size()  l++
induction variable: ['l']
{
L4364: (arguments_.fixedPayDates[l],r) 
L4365: (arguments_.fixedCoupons[l]*,r) 
L4366: (arguments_.fixedPayDates[l],r) 
L4367: (z[k],r) 
}
array table
-----------------------------------------------
arguments_.fixedPayDates -> [('[l]', 'r', 'normalized', ['l'], 4364), ('[l]', 'r', 'normalized', ['l'], 4366)]
LDEs formed:0

arguments_.fixedCoupons -> [('[l]', 'r', 'normalized', ['l'], 4365)]
LDEs formed:0

z -> [('[k]', 'r', 'not normalized', ['l'], 4367)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i = 0  i < npvp0.size()  i++
induction variable: ['i']
{
L4368: (prob[i]=,w) (npvp1[i][0]*,r) 
}
array table
-----------------------------------------------
npvp1 -> [('[i][0]', 'r', 'normalized', ['i'], 4368)]
LDEs formed:0

prob -> [('[i]', 'w', 'normalized', ['i'], 4368)]
LDEs formed:1

distinct LDEs:
i1=i2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/pricingengines/swaption/basketgeneratingengine.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i = minIdxAlive  i < exercise->dates().size()  i++
induction variable: ['i']
{
L4369: (solution[1],r) 
L4370: (solution[2]=,w) 
L4371: (solution[2],r) 
L4372: (solution[0]=,w) 
L4373: (solution[0],r) 
L4374: (solution[2],r) 
L4375: (solution[2],r) 
L4376: (solution[0],r) 
}
array table
-----------------------------------------------
solution -> [('[1]', 'r', 'normalized', ['i'], 4369), ('[2]', 'w', 'normalized', ['i'], 4370), ('[2]', 'r', 'normalized', ['i'], 4371), ('[0]', 'w', 'normalized', ['i'], 4372), ('[0]', 'r', 'normalized', ['i'], 4373), ('[2]', 'r', 'normalized', ['i'], 4374), ('[2]', 'r', 'normalized', ['i'], 4375), ('[0]', 'r', 'normalized', ['i'], 4376)]
LDEs formed:15

distinct LDEs:
2=2
1=0
2=0
1=2
0=0
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/pricingengines/swaption/gaussian1dfloatfloatswaptionengine.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i = idx1  i < arguments_.leg1ResetDates.size()  i++
induction variable: ['i']
{
L4377: (arguments_.nominal1[i],r) 
}
array table
-----------------------------------------------
arguments_.nominal1 -> [('[i]', 'r', 'normalized', ['i'], 4377)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i = idx1  i < arguments_.leg1ResetDates.size()  i++
induction variable: ['i']
{
L4378: (arguments_.leg1AccrualTimes[i]*,r) (arguments_.nominal1[i],r) 
}
array table
-----------------------------------------------
arguments_.nominal1 -> [('[i]', 'r', 'normalized', ['i'], 4378)]
LDEs formed:0

arguments_.leg1AccrualTimes -> [('[i]', 'r', 'normalized', ['i'], 4378)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size k = 0  k < (event0 > expiry ? npv0.size() : 1)  k++
induction variable: ['k']
{
L4379: (z[k],r) 
	loop info: Size i = 0  i < yg.size()  i++
	induction variable: ['k', 'i']
		{
		L4380: (p[i]=,w) (yg[i],r) 
		L4381: (pa[i]=,w) (yg[i],r) 
		}
	loop info: Size i = 0  i < z.size() - 1  i++
	induction variable: ['k', 'i']
		{
		L4382: (p[i],r) (z[i],r) 
		L4383: (z[i],r) (z[i + 1],r) 
		L4384: (pa[i],r) (z[i],r) 
		L4385: (z[i],r) (z[i + 1],r) 
		}
L4386: (p[z.size() - 2],r) 
L4387: (z[z.size() - 2],r) (z[z.size() - 1],r) 
L4388: (p[0],r) (z[0],r) 
L4389: (z[0],r) 
L4390: (pa[z.size() - 2],r) 
L4391: (z[z.size() - 2],r) (z[z.size() - 1],r) 
L4392: (pa[0],r) (z[0],r) 
L4393: (z[0],r) 
L4394: (p[z.size() - 2],r) (z[z.size() - 2],r) 
L4395: (z[z.size() - 1],r) 
L4396: (p[0],r) (z[0],r) 
L4397: (z[0],r) 
L4398: (pa[z.size() - 2],r) (z[z.size() - 2],r) 
L4399: (z[z.size() - 1],r) 
L4400: (pa[0],r) 
L4401: (z[0],r) (z[0],r) 
L4402: (npv0[k]=,w) 
L4403: (npv0a[k]=,w) 
	loop info: Size m = 0  m < npvp0.size()  m++
	induction variable: ['k', 'i', 'm']
		{
		L4404: (z[k],r) 
		L4405: (npvp1[m].begin,r) 
			loop info: Size i = 0  i < yg.size()  i++
			induction variable: ['k', 'i', 'm']
				{
				L4406: (p[i]=,w) (yg[i],r) 
				}
			loop info: Size i = 0  i < z.size() - 1  i++
			induction variable: ['k', 'i', 'm']
				{
				L4407: (p[i],r) (z[i],r) 
				L4408: (z[i],r) (z[i + 1],r) 
				}
		L4409: (p[z.size() - 2],r) 
		L4410: (z[z.size() - 2],r) 
		L4411: (z[z.size() - 1],r) 
		L4412: (p[0],r) 
		L4413: (z[0],r) (z[0],r) 
		L4414: (p[z.size() - 2],r) 
		L4415: (z[z.size() - 2],r) 
		L4416: (z[z.size() - 1],r) 
		L4417: (p[0],r) (z[0],r) 
		L4418: (z[0],r) 
		L4419: (npvp0[m][k]=,w) 
		}
L4420: (z[k],r) 
L4421: (arguments_.leg1PayDates[j],r) 
L4422: (arguments_.leg1IsRedemptionFlow[j],r) 
L4423: (arguments_.leg1Coupons[j],r) 
L4424: (arguments_.leg1FixingDates[j],r) 
L4425: (arguments_.leg1FixingDates[j],r) 
L4426: (arguments_.leg1FixingDates[j],r) 
L4427: (arguments_.leg1FixingDates[j],r) 
L4428: (arguments_.leg1Spreads[j]+,r) 
L4429: (arguments_.leg1Gearings[j]*,r) 
L4430: (arguments_.leg1CappedRates[j],r) 
L4431: (arguments_.leg1CappedRates[j],r) 
L4432: (arguments_.leg1FlooredRates[j],r) 
L4433: (arguments_.leg1FlooredRates[j],r) 
L4434: (arguments_.nominal1[j]*,r) 
L4435: (arguments_.leg1AccrualTimes[j],r) 
L4436: (npv0a[k]-=,w) 
L4437: (arguments_.leg1PayDates[j],r) 
L4438: (arguments_.leg1FixingDates[j],r) 
L4439: (arguments_.leg2PayDates[j],r) 
L4440: (arguments_.leg2IsRedemptionFlow[j],r) 
L4441: (arguments_.leg2Coupons[j],r) 
L4442: (arguments_.leg2FixingDates[j],r) 
L4443: (arguments_.leg2FixingDates[j],r) 
L4444: (arguments_.leg2FixingDates[j],r) 
L4445: (arguments_.leg2FixingDates[j],r) 
L4446: (arguments_.leg2Spreads[j]+,r) 
L4447: (arguments_.leg2Gearings[j]*,r) 
L4448: (arguments_.leg2CappedRates[j],r) 
L4449: (arguments_.leg2CappedRates[j],r) 
L4450: (arguments_.leg2FlooredRates[j],r) 
L4451: (arguments_.leg2FlooredRates[j],r) 
L4452: (arguments_.nominal2[j]*,r) 
L4453: (arguments_.leg2AccrualTimes[j],r) 
L4454: (npv0a[k]+=,w) 
L4455: (arguments_.leg2PayDates[j],r) 
L4456: (arguments_.leg2FixingDates[j],r) 
L4457: (npv0a[k]+,r) 
L4458: (z[k],r) 
L4459: (npv0[k],r) 
L4460: (npvp0[exIdx-1][k]=,w) 
L4461: (z[k],r) 
	loop info: Size ii = exIdx  ii < noEx+1  ++ii
	induction variable: ['k', 'i', 'm', 'ii']
					{
					}
L4462: (npv0[k]=,w) (npv0[k],r) 
}
array table
-----------------------------------------------
arguments_.leg2Coupons -> [('[j]', 'r', 'not normalized', ['k', 'i', 'm', 'ii'], 4441)]
LDEs formed:0

arguments_.leg1Gearings -> [('[j]', 'r', 'not normalized', ['k', 'i', 'm', 'ii'], 4429)]
LDEs formed:0

arguments_.leg2FlooredRates -> [('[j]', 'r', 'not normalized', ['k', 'i', 'm', 'ii'], 4450), ('[j]', 'r', 'not normalized', ['k', 'i', 'm', 'ii'], 4451)]
LDEs formed:0

arguments_.leg2Gearings -> [('[j]', 'r', 'not normalized', ['k', 'i', 'm', 'ii'], 4447)]
LDEs formed:0

pa -> [('[i]', 'w', 'normalized', ['k', 'i', 'm', 'ii'], 4381), ('[i]', 'r', 'normalized', ['k', 'i', 'm', 'ii'], 4384), ('[z.size() - 2]', 'r', 'not normalized', ['k', 'i', 'm', 'ii'], 4390), ('[0]', 'r', 'normalized', ['k', 'i', 'm', 'ii'], 4392), ('[z.size() - 2]', 'r', 'not normalized', ['k', 'i', 'm', 'ii'], 4398), ('[0]', 'r', 'normalized', ['k', 'i', 'm', 'ii'], 4400)]
LDEs formed:6

arguments_.leg1AccrualTimes -> [('[j]', 'r', 'not normalized', ['k', 'i', 'm', 'ii'], 4435)]
LDEs formed:0

arguments_.leg1CappedRates -> [('[j]', 'r', 'not normalized', ['k', 'i', 'm', 'ii'], 4430), ('[j]', 'r', 'not normalized', ['k', 'i', 'm', 'ii'], 4431)]
LDEs formed:0

arguments_.leg2FixingDates -> [('[j]', 'r', 'not normalized', ['k', 'i', 'm', 'ii'], 4442), ('[j]', 'r', 'not normalized', ['k', 'i', 'm', 'ii'], 4443), ('[j]', 'r', 'not normalized', ['k', 'i', 'm', 'ii'], 4444), ('[j]', 'r', 'not normalized', ['k', 'i', 'm', 'ii'], 4445), ('[j]', 'r', 'not normalized', ['k', 'i', 'm', 'ii'], 4456)]
LDEs formed:0

arguments_.leg2CappedRates -> [('[j]', 'r', 'not normalized', ['k', 'i', 'm', 'ii'], 4448), ('[j]', 'r', 'not normalized', ['k', 'i', 'm', 'ii'], 4449)]
LDEs formed:0

npv0 -> [('[k]', 'w', 'normalized', ['k', 'i', 'm', 'ii'], 4402), ('[k]', 'r', 'normalized', ['k', 'i', 'm', 'ii'], 4459), ('[k]', 'w', 'normalized', ['k', 'i', 'm', 'ii'], 4462), ('[k]', 'r', 'normalized', ['k', 'i', 'm', 'ii'], 4462)]
LDEs formed:7

arguments_.leg1Spreads -> [('[j]', 'r', 'not normalized', ['k', 'i', 'm', 'ii'], 4428)]
LDEs formed:0

npv0a -> [('[k]', 'w', 'normalized', ['k', 'i', 'm', 'ii'], 4403), ('[k]', 'w', 'normalized', ['k', 'i', 'm', 'ii'], 4436), ('[k]', 'w', 'normalized', ['k', 'i', 'm', 'ii'], 4454), ('[k]', 'r', 'normalized', ['k', 'i', 'm', 'ii'], 4457)]
LDEs formed:9

arguments_.leg2IsRedemptionFlow -> [('[j]', 'r', 'not normalized', ['k', 'i', 'm', 'ii'], 4440)]
LDEs formed:0

yg -> [('[i]', 'r', 'normalized', ['k', 'i', 'm', 'ii'], 4380), ('[i]', 'r', 'normalized', ['k', 'i', 'm', 'ii'], 4381), ('[i]', 'r', 'normalized', ['k', 'i', 'm', 'ii'], 4406)]
LDEs formed:0

arguments_.leg1IsRedemptionFlow -> [('[j]', 'r', 'not normalized', ['k', 'i', 'm', 'ii'], 4422)]
LDEs formed:0

arguments_.nominal1 -> [('[j]', 'r', 'not normalized', ['k', 'i', 'm', 'ii'], 4434)]
LDEs formed:0

arguments_.nominal2 -> [('[j]', 'r', 'not normalized', ['k', 'i', 'm', 'ii'], 4452)]
LDEs formed:0

npvp1 -> [('[m]', 'r', 'normalized', ['k', 'i', 'm', 'ii'], 4405)]
LDEs formed:0

npvp0 -> [('[m][k]', 'w', 'normalized', ['k', 'i', 'm', 'ii'], 4419), ('[exIdx-1][k]', 'w', 'not normalized', ['k', 'i', 'm', 'ii'], 4460)]
LDEs formed:6

arguments_.leg2PayDates -> [('[j]', 'r', 'not normalized', ['k', 'i', 'm', 'ii'], 4439), ('[j]', 'r', 'not normalized', ['k', 'i', 'm', 'ii'], 4455)]
LDEs formed:0

arguments_.leg2AccrualTimes -> [('[j]', 'r', 'not normalized', ['k', 'i', 'm', 'ii'], 4453)]
LDEs formed:0

arguments_.leg2Spreads -> [('[j]', 'r', 'not normalized', ['k', 'i', 'm', 'ii'], 4446)]
LDEs formed:0

arguments_.leg1FixingDates -> [('[j]', 'r', 'not normalized', ['k', 'i', 'm', 'ii'], 4424), ('[j]', 'r', 'not normalized', ['k', 'i', 'm', 'ii'], 4425), ('[j]', 'r', 'not normalized', ['k', 'i', 'm', 'ii'], 4426), ('[j]', 'r', 'not normalized', ['k', 'i', 'm', 'ii'], 4427), ('[j]', 'r', 'not normalized', ['k', 'i', 'm', 'ii'], 4438)]
LDEs formed:0

p -> [('[i]', 'w', 'normalized', ['k', 'i', 'm', 'ii'], 4380), ('[i]', 'r', 'normalized', ['k', 'i', 'm', 'ii'], 4382), ('[z.size() - 2]', 'r', 'not normalized', ['k', 'i', 'm', 'ii'], 4386), ('[0]', 'r', 'normalized', ['k', 'i', 'm', 'ii'], 4388), ('[z.size() - 2]', 'r', 'not normalized', ['k', 'i', 'm', 'ii'], 4394), ('[0]', 'r', 'normalized', ['k', 'i', 'm', 'ii'], 4396), ('[i]', 'w', 'normalized', ['k', 'i', 'm', 'ii'], 4406), ('[i]', 'r', 'normalized', ['k', 'i', 'm', 'ii'], 4407), ('[z.size() - 2]', 'r', 'not normalized', ['k', 'i', 'm', 'ii'], 4409), ('[0]', 'r', 'normalized', ['k', 'i', 'm', 'ii'], 4412), ('[z.size() - 2]', 'r', 'not normalized', ['k', 'i', 'm', 'ii'], 4414), ('[0]', 'r', 'normalized', ['k', 'i', 'm', 'ii'], 4417)]
LDEs formed:23

arguments_.leg1Coupons -> [('[j]', 'r', 'not normalized', ['k', 'i', 'm', 'ii'], 4423)]
LDEs formed:0

z -> [('[k]', 'r', 'normalized', ['k', 'i', 'm', 'ii'], 4379), ('[i]', 'r', 'normalized', ['k', 'i', 'm', 'ii'], 4382), ('[i]', 'r', 'normalized', ['k', 'i', 'm', 'ii'], 4383), ('[i + 1]', 'r', 'normalized', ['k', 'i', 'm', 'ii'], 4383), ('[i]', 'r', 'normalized', ['k', 'i', 'm', 'ii'], 4384), ('[i]', 'r', 'normalized', ['k', 'i', 'm', 'ii'], 4385), ('[i + 1]', 'r', 'normalized', ['k', 'i', 'm', 'ii'], 4385), ('[z.size() - 2]', 'r', 'not normalized', ['k', 'i', 'm', 'ii'], 4387), ('[z.size() - 1]', 'r', 'not normalized', ['k', 'i', 'm', 'ii'], 4387), ('[0]', 'r', 'normalized', ['k', 'i', 'm', 'ii'], 4388), ('[0]', 'r', 'normalized', ['k', 'i', 'm', 'ii'], 4389), ('[z.size() - 2]', 'r', 'not normalized', ['k', 'i', 'm', 'ii'], 4391), ('[z.size() - 1]', 'r', 'not normalized', ['k', 'i', 'm', 'ii'], 4391), ('[0]', 'r', 'normalized', ['k', 'i', 'm', 'ii'], 4392), ('[0]', 'r', 'normalized', ['k', 'i', 'm', 'ii'], 4393), ('[z.size() - 2]', 'r', 'not normalized', ['k', 'i', 'm', 'ii'], 4394), ('[z.size() - 1]', 'r', 'not normalized', ['k', 'i', 'm', 'ii'], 4395), ('[0]', 'r', 'normalized', ['k', 'i', 'm', 'ii'], 4396), ('[0]', 'r', 'normalized', ['k', 'i', 'm', 'ii'], 4397), ('[z.size() - 2]', 'r', 'not normalized', ['k', 'i', 'm', 'ii'], 4398), ('[z.size() - 1]', 'r', 'not normalized', ['k', 'i', 'm', 'ii'], 4399), ('[0]', 'r', 'normalized', ['k', 'i', 'm', 'ii'], 4401), ('[0]', 'r', 'normalized', ['k', 'i', 'm', 'ii'], 4401), ('[k]', 'r', 'normalized', ['k', 'i', 'm', 'ii'], 4404), ('[i]', 'r', 'normalized', ['k', 'i', 'm', 'ii'], 4407), ('[i]', 'r', 'normalized', ['k', 'i', 'm', 'ii'], 4408), ('[i + 1]', 'r', 'normalized', ['k', 'i', 'm', 'ii'], 4408), ('[z.size() - 2]', 'r', 'not normalized', ['k', 'i', 'm', 'ii'], 4410), ('[z.size() - 1]', 'r', 'not normalized', ['k', 'i', 'm', 'ii'], 4411), ('[0]', 'r', 'normalized', ['k', 'i', 'm', 'ii'], 4413), ('[0]', 'r', 'normalized', ['k', 'i', 'm', 'ii'], 4413), ('[z.size() - 2]', 'r', 'not normalized', ['k', 'i', 'm', 'ii'], 4415), ('[z.size() - 1]', 'r', 'not normalized', ['k', 'i', 'm', 'ii'], 4416), ('[0]', 'r', 'normalized', ['k', 'i', 'm', 'ii'], 4417), ('[0]', 'r', 'normalized', ['k', 'i', 'm', 'ii'], 4418), ('[k]', 'r', 'normalized', ['k', 'i', 'm', 'ii'], 4420), ('[k]', 'r', 'normalized', ['k', 'i', 'm', 'ii'], 4458), ('[k]', 'r', 'normalized', ['k', 'i', 'm', 'ii'], 4461)]
LDEs formed:0

arguments_.leg1PayDates -> [('[j]', 'r', 'not normalized', ['k', 'i', 'm', 'ii'], 4421), ('[j]', 'r', 'not normalized', ['k', 'i', 'm', 'ii'], 4437)]
LDEs formed:0

arguments_.leg1FlooredRates -> [('[j]', 'r', 'not normalized', ['k', 'i', 'm', 'ii'], 4432), ('[j]', 'r', 'not normalized', ['k', 'i', 'm', 'ii'], 4433)]
LDEs formed:0

distinct LDEs:
m1=exIdx-1,k1=k2
i1=z.size() - 2
m1=m2,k1=k2
i1=i2
k1=k2
exIdx-1=exIdx-1,k1=k2
i1=0
#########################################################################################
loop info: Size i=0 i<npvp0.size() ++i
induction variable: ['i']
{
L4434: (npvp1[i].swap,r) (npvp0[i],r) 
}
array table
-----------------------------------------------
npvp1 -> [('[i]', 'r', 'normalized', ['i'], 4434)]
LDEs formed:0

npvp0 -> [('[i]', 'r', 'normalized', ['i'], 4434)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i = 0  i < noEx+1  i++
induction variable: ['i']
{
L4435: (prob[i]=,w) (npvp1[i][0]*,r) 
}
array table
-----------------------------------------------
npvp1 -> [('[i][0]', 'r', 'normalized', ['i'], 4435)]
LDEs formed:0

prob -> [('[i]', 'w', 'normalized', ['i'], 4435)]
LDEs formed:1

distinct LDEs:
i1=i2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/pricingengines/inflation/inflationcapfloorengines.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<optionlets  ++i
induction variable: ['i']
{
L4436: (arguments_.payDates[i],r) 
L4437: (arguments_.nominals[i]*,r) 
L4438: (arguments_.gearings[i]*,r) 
L4439: (arguments_.accrualTimes[i],r) 
L4440: (forwards[i]=,w) (arguments_.fixingDates[i],r) 
L4441: (forwards[i],r) 
L4442: (arguments_.fixingDates[i],r) 
L4443: (arguments_.capRates[i],r) 
L4444: (stdDevs[i]=,w) 
L4445: (values[i]=,w) 
L4446: (stdDevs[i],r) 
L4447: (arguments_.floorRates[i],r) 
L4448: (stdDevs[i]=,w) 
L4449: (stdDevs[i],r) 
L4450: (values[i]=,w) 
L4451: (values[i]-=,w) 
L4452: (values[i],r) 
}
array table
-----------------------------------------------
arguments_.capRates -> [('[i]', 'r', 'normalized', ['i'], 4443)]
LDEs formed:0

arguments_.floorRates -> [('[i]', 'r', 'normalized', ['i'], 4447)]
LDEs formed:0

stdDevs -> [('[i]', 'w', 'normalized', ['i'], 4444), ('[i]', 'r', 'normalized', ['i'], 4446), ('[i]', 'w', 'normalized', ['i'], 4448), ('[i]', 'r', 'normalized', ['i'], 4449)]
LDEs formed:7

forwards -> [('[i]', 'w', 'normalized', ['i'], 4440), ('[i]', 'r', 'normalized', ['i'], 4441)]
LDEs formed:2

arguments_.gearings -> [('[i]', 'r', 'normalized', ['i'], 4438)]
LDEs formed:0

arguments_.payDates -> [('[i]', 'r', 'normalized', ['i'], 4436)]
LDEs formed:0

values -> [('[i]', 'w', 'normalized', ['i'], 4445), ('[i]', 'w', 'normalized', ['i'], 4450), ('[i]', 'w', 'normalized', ['i'], 4451), ('[i]', 'r', 'normalized', ['i'], 4452)]
LDEs formed:9

arguments_.accrualTimes -> [('[i]', 'r', 'normalized', ['i'], 4439)]
LDEs formed:0

arguments_.fixingDates -> [('[i]', 'r', 'normalized', ['i'], 4440), ('[i]', 'r', 'normalized', ['i'], 4442)]
LDEs formed:0

arguments_.nominals -> [('[i]', 'r', 'normalized', ['i'], 4437)]
LDEs formed:0

distinct LDEs:
i1=i2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/pricingengines/credit/midpointcdsengine.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<arguments_.leg.size()  ++i
induction variable: ['i']
{
L4438: (arguments_.leg[i]-,r) 
L4439: (arguments_.leg[i],r) 
}
array table
-----------------------------------------------
arguments_.leg -> [('[i]', 'r', 'normalized', ['i'], 4438), ('[i]', 'r', 'normalized', ['i'], 4439)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/pricingengines/credit/integralcdsengine.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<arguments_.leg.size()  ++i
induction variable: ['i']
{
L4440: (arguments_.leg[i]-,r) 
L4441: (arguments_.leg[i],r) 
}
array table
-----------------------------------------------
arguments_.leg -> [('[i]', 'r', 'normalized', ['i'], 4440), ('[i]', 'r', 'normalized', ['i'], 4441)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/instruments/inflationcapfloor.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<n  ++i
induction variable: ['i']
{
L4442: (yoyLeg_[i],r) 
L4443: (startDates[i]=,w) 
L4444: (fixingDates[i]=,w) 
L4445: (payDates[i]=,w) 
L4446: (accrualTimes[i]=,w) 
L4447: (nominals[i]=,w) 
L4448: (gearings[i]=,w) 
L4449: (spreads[i]=,w) 
L4450: (capRates[i]=,w) (capRates_[i]-,r) 
L4451: (capRates[i]=,w) 
L4452: (floorRates[i]=,w) (floorRates_[i]-,r) 
L4453: (floorRates[i]=,w) 
}
array table
-----------------------------------------------
yoyLeg_ -> [('[i]', 'r', 'normalized', ['i'], 4442)]
LDEs formed:0

spreads -> [('[i]', 'w', 'normalized', ['i'], 4449)]
LDEs formed:1

accrualTimes -> [('[i]', 'w', 'normalized', ['i'], 4446)]
LDEs formed:1

nominals -> [('[i]', 'w', 'normalized', ['i'], 4447)]
LDEs formed:1

capRates_ -> [('[i]', 'r', 'normalized', ['i'], 4450)]
LDEs formed:0

floorRates_ -> [('[i]', 'r', 'normalized', ['i'], 4452)]
LDEs formed:0

capRates -> [('[i]', 'w', 'normalized', ['i'], 4450), ('[i]', 'w', 'normalized', ['i'], 4451)]
LDEs formed:3

payDates -> [('[i]', 'w', 'normalized', ['i'], 4445)]
LDEs formed:1

fixingDates -> [('[i]', 'w', 'normalized', ['i'], 4444)]
LDEs formed:1

floorRates -> [('[i]', 'w', 'normalized', ['i'], 4452), ('[i]', 'w', 'normalized', ['i'], 4453)]
LDEs formed:3

gearings -> [('[i]', 'w', 'normalized', ['i'], 4448)]
LDEs formed:1

startDates -> [('[i]', 'w', 'normalized', ['i'], 4443)]
LDEs formed:1

distinct LDEs:
i1=i2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/instruments/dividendbarrieroption.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i = 0  i < cashFlow.size()  i++
induction variable: ['i']
{
L4444: (cashFlow[i]-,r) 
L4445: (cashFlow[i]-,r) 
}
array table
-----------------------------------------------
cashFlow -> [('[i]', 'r', 'normalized', ['i'], 4444), ('[i]', 'r', 'normalized', ['i'], 4445)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/instruments/capfloor.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<n  ++i
induction variable: ['i']
{
L4446: (floatingLeg_[i],r) 
L4447: (startDates[i]=,w) 
L4448: (fixingDates[i]=,w) 
L4449: (endDates[i]=,w) 
L4450: (accrualTimes[i]=,w) 
L4451: (endDates[i],r) 
L4452: (forwards[i]=,w) 
L4453: (forwards[i]=,w) 
L4454: (nominals[i]=,w) 
L4455: (gearings[i]=,w) 
L4456: (spreads[i]=,w) 
L4457: (capRates[i]=,w) (capRates_[i]-,r) 
L4458: (capRates[i]=,w) 
L4459: (floorRates[i]=,w) (floorRates_[i]-,r) 
L4460: (floorRates[i]=,w) 
L4461: (indexes[i]=,w) 
}
array table
-----------------------------------------------
floatingLeg_ -> [('[i]', 'r', 'normalized', ['i'], 4446)]
LDEs formed:0

spreads -> [('[i]', 'w', 'normalized', ['i'], 4456)]
LDEs formed:1

forwards -> [('[i]', 'w', 'normalized', ['i'], 4452), ('[i]', 'w', 'normalized', ['i'], 4453)]
LDEs formed:3

accrualTimes -> [('[i]', 'w', 'normalized', ['i'], 4450)]
LDEs formed:1

nominals -> [('[i]', 'w', 'normalized', ['i'], 4454)]
LDEs formed:1

capRates_ -> [('[i]', 'r', 'normalized', ['i'], 4457)]
LDEs formed:0

capRates -> [('[i]', 'w', 'normalized', ['i'], 4457), ('[i]', 'w', 'normalized', ['i'], 4458)]
LDEs formed:3

floorRates_ -> [('[i]', 'r', 'normalized', ['i'], 4459)]
LDEs formed:0

endDates -> [('[i]', 'w', 'normalized', ['i'], 4449), ('[i]', 'r', 'normalized', ['i'], 4451)]
LDEs formed:2

fixingDates -> [('[i]', 'w', 'normalized', ['i'], 4448)]
LDEs formed:1

indexes -> [('[i]', 'w', 'normalized', ['i'], 4461)]
LDEs formed:1

floorRates -> [('[i]', 'w', 'normalized', ['i'], 4459), ('[i]', 'w', 'normalized', ['i'], 4460)]
LDEs formed:3

gearings -> [('[i]', 'w', 'normalized', ['i'], 4455)]
LDEs formed:1

startDates -> [('[i]', 'w', 'normalized', ['i'], 4447)]
LDEs formed:1

distinct LDEs:
i1=i2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/instruments/fixedratebondforward.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i = 0  i < cf.size()  ++i
induction variable: ['i']
{
L4448: (cf[i]-,r) 
L4449: (cf[i]-,r) 
L4450: (cf[i]-,r) 
L4451: (cf[i]-,r) 
}
array table
-----------------------------------------------
cf -> [('[i]', 'r', 'normalized', ['i'], 4448), ('[i]', 'r', 'normalized', ['i'], 4449), ('[i]', 'r', 'normalized', ['i'], 4450), ('[i]', 'r', 'normalized', ['i'], 4451)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/instruments/vanillaswap.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<fixedCoupons.size()  ++i
induction variable: ['i']
{
L4452: (fixedCoupons[i],r) 
L4453: (fixedPayDates[i]=,w) 
L4454: (fixedResetDates[i]=,w) 
L4455: (fixedCoupons[i]=,w) 
}
array table
-----------------------------------------------
fixedCoupons -> [('[i]', 'r', 'normalized', ['i'], 4452), ('[i]', 'w', 'normalized', ['i'], 4455)]
LDEs formed:2

fixedResetDates -> [('[i]', 'w', 'normalized', ['i'], 4454)]
LDEs formed:1

fixedPayDates -> [('[i]', 'w', 'normalized', ['i'], 4453)]
LDEs formed:1

distinct LDEs:
i1=i2
#########################################################################################
loop info: Size i=0  i<floatingCoupons.size()  ++i
induction variable: ['i']
{
L4454: (floatingCoupons[i],r) 
L4455: (floatingResetDates[i]=,w) 
L4456: (floatingPayDates[i]=,w) 
L4457: (floatingFixingDates[i]=,w) 
L4458: (floatingAccrualTimes[i]=,w) 
L4459: (floatingSpreads[i]=,w) 
L4460: (floatingCoupons[i]=,w) 
L4461: (floatingCoupons[i]=,w) 
}
array table
-----------------------------------------------
floatingResetDates -> [('[i]', 'w', 'normalized', ['i'], 4455)]
LDEs formed:1

floatingSpreads -> [('[i]', 'w', 'normalized', ['i'], 4459)]
LDEs formed:1

floatingFixingDates -> [('[i]', 'w', 'normalized', ['i'], 4457)]
LDEs formed:1

floatingCoupons -> [('[i]', 'r', 'normalized', ['i'], 4454), ('[i]', 'w', 'normalized', ['i'], 4460), ('[i]', 'w', 'normalized', ['i'], 4461)]
LDEs formed:5

floatingPayDates -> [('[i]', 'w', 'normalized', ['i'], 4456)]
LDEs formed:1

floatingAccrualTimes -> [('[i]', 'w', 'normalized', ['i'], 4458)]
LDEs formed:1

distinct LDEs:
i1=i2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/instruments/bond.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=1  i<notionalSchedule_.size()  ++i
induction variable: ['i']
{
L4459: (redemptions[i],r) 
L4460: (notionals_[i-1]-,r) (notionals_[i],r) 
L4461: (notionalSchedule_[i],r) 
L4462: (notionalSchedule_[i],r) 
}
array table
-----------------------------------------------
notionals_ -> [('[i-1]', 'r', 'normalized', ['i'], 4460), ('[i]', 'r', 'normalized', ['i'], 4460)]
LDEs formed:0

redemptions -> [('[i]', 'r', 'normalized', ['i'], 4459)]
LDEs formed:0

notionalSchedule_ -> [('[i]', 'r', 'normalized', ['i'], 4461), ('[i]', 'r', 'normalized', ['i'], 4462)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<cashflows_.size()  ++i
induction variable: ['i']
{
L4463: (cashflows_[i],r) 
}
array table
-----------------------------------------------
cashflows_ -> [('[i]', 'r', 'normalized', ['i'], 4463)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/instruments/vanillaswingoption.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i < dates_.size()  ++i
induction variable: ['i']
{
L4464: (seconds_[i],r) 
L4465: (dates_[i-1],r) (dates_[i],r) 
L4466: (dates_[i-1]==,r) (dates_[i],r) 
L4467: (seconds_[i-1],r) (seconds_[i],r) 
}
array table
-----------------------------------------------
seconds_ -> [('[i]', 'r', 'normalized', ['i'], 4464), ('[i-1]', 'r', 'normalized', ['i'], 4467), ('[i]', 'r', 'normalized', ['i'], 4467)]
LDEs formed:0

dates_ -> [('[i-1]', 'r', 'normalized', ['i'], 4465), ('[i]', 'r', 'normalized', ['i'], 4465), ('[i-1]', 'r', 'normalized', ['i'], 4466), ('[i]', 'r', 'normalized', ['i'], 4466)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/instruments/cpiswap.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/instruments/cliquetoption.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<resetDates.size()  ++i
induction variable: ['i']
{
L4467: (resetDates[i],r) 
L4468: (resetDates[i],r) (resetDates[i-1],r) 
}
array table
-----------------------------------------------
resetDates -> [('[i]', 'r', 'normalized', ['i'], 4467), ('[i]', 'r', 'normalized', ['i'], 4468), ('[i-1]', 'r', 'normalized', ['i'], 4468)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/instruments/yearonyearinflationswap.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<fixedCoupons.size()  ++i
induction variable: ['i']
{
L4469: (fixedCoupons[i],r) 
L4470: (fixedPayDates[i]=,w) 
L4471: (fixedResetDates[i]=,w) 
L4472: (fixedCoupons[i]=,w) 
}
array table
-----------------------------------------------
fixedCoupons -> [('[i]', 'r', 'normalized', ['i'], 4469), ('[i]', 'w', 'normalized', ['i'], 4472)]
LDEs formed:2

fixedResetDates -> [('[i]', 'w', 'normalized', ['i'], 4471)]
LDEs formed:1

fixedPayDates -> [('[i]', 'w', 'normalized', ['i'], 4470)]
LDEs formed:1

distinct LDEs:
i1=i2
#########################################################################################
loop info: Size i=0  i<yoyCoupons.size()  ++i
induction variable: ['i']
{
L4471: (yoyCoupons[i],r) 
L4472: (yoyResetDates[i]=,w) 
L4473: (yoyPayDates[i]=,w) 
L4474: (yoyFixingDates[i]=,w) 
L4475: (yoyAccrualTimes[i]=,w) 
L4476: (yoySpreads[i]=,w) 
L4477: (yoyCoupons[i]=,w) 
L4478: (yoyCoupons[i]=,w) 
}
array table
-----------------------------------------------
yoyResetDates -> [('[i]', 'w', 'normalized', ['i'], 4472)]
LDEs formed:1

yoyPayDates -> [('[i]', 'w', 'normalized', ['i'], 4473)]
LDEs formed:1

yoyFixingDates -> [('[i]', 'w', 'normalized', ['i'], 4474)]
LDEs formed:1

yoyAccrualTimes -> [('[i]', 'w', 'normalized', ['i'], 4475)]
LDEs formed:1

yoyCoupons -> [('[i]', 'r', 'normalized', ['i'], 4471), ('[i]', 'w', 'normalized', ['i'], 4477), ('[i]', 'w', 'normalized', ['i'], 4478)]
LDEs formed:5

yoySpreads -> [('[i]', 'w', 'normalized', ['i'], 4476)]
LDEs formed:1

distinct LDEs:
i1=i2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/instruments/bmaswap.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/instruments/compositeinstrument.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/instruments/assetswap.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: i = bondLeg.begin()  i<bondLeg.end()-1 && (*i)->date()<=dealMaturity  ++i
induction variable: ['i']
{
L4477: (legs_[0].push_back,r) 
}
array table
-----------------------------------------------
legs_ -> [('[0]', 'r', 'normalized', ['i'], 4477)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Leg::const_iterator i=bondLeg.begin()  i<bondLeg.end()  ++i
induction variable: ['i']
{
L4478: (legs_[0].push_back,r) 
}
array table
-----------------------------------------------
legs_ -> [('[0]', 'r', 'normalized', ['i'], 4478)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<fixedCoupons.size()  ++i
induction variable: ['i']
{
L4479: (fixedCoupons[i],r) 
L4480: (fixedPayDates[i]=,w) 
L4481: (fixedResetDates[i]=,w) 
L4482: (fixedCoupons[i]=,w) 
}
array table
-----------------------------------------------
fixedCoupons -> [('[i]', 'r', 'normalized', ['i'], 4479), ('[i]', 'w', 'normalized', ['i'], 4482)]
LDEs formed:2

fixedResetDates -> [('[i]', 'w', 'normalized', ['i'], 4481)]
LDEs formed:1

fixedPayDates -> [('[i]', 'w', 'normalized', ['i'], 4480)]
LDEs formed:1

distinct LDEs:
i1=i2
#########################################################################################
loop info: Size i=0  i<floatingCoupons.size()  ++i
induction variable: ['i']
{
L4481: (floatingCoupons[i],r) 
L4482: (floatingResetDates[i]=,w) 
L4483: (floatingPayDates[i]=,w) 
L4484: (floatingFixingDates[i]=,w) 
L4485: (floatingAccrualTimes[i]=,w) 
L4486: (floatingSpreads[i]=,w) 
}
array table
-----------------------------------------------
floatingResetDates -> [('[i]', 'w', 'normalized', ['i'], 4482)]
LDEs formed:1

floatingSpreads -> [('[i]', 'w', 'normalized', ['i'], 4486)]
LDEs formed:1

floatingFixingDates -> [('[i]', 'w', 'normalized', ['i'], 4484)]
LDEs formed:1

floatingCoupons -> [('[i]', 'r', 'normalized', ['i'], 4481)]
LDEs formed:0

floatingPayDates -> [('[i]', 'w', 'normalized', ['i'], 4483)]
LDEs formed:1

floatingAccrualTimes -> [('[i]', 'w', 'normalized', ['i'], 4485)]
LDEs formed:1

distinct LDEs:
i1=i2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/instruments/zerocouponinflationswap.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/instruments/overnightindexedswap.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/instruments/dividendvanillaoption.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i = 0  i < cashFlow.size()  i++
induction variable: ['i']
{
L4486: (cashFlow[i]-,r) 
L4487: (cashFlow[i]-,r) 
}
array table
-----------------------------------------------
cashFlow -> [('[i]', 'r', 'normalized', ['i'], 4486), ('[i]', 'r', 'normalized', ['i'], 4487)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/instruments/floatfloatswap.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i = 0  i < cappedRate1_.size()  i++
induction variable: ['i']
{
L4488: (cappedRate1_[i]==,r) 
L4489: (cappedRate1_[i],r) 
L4490: (cappedRate1_[i],r) 
L4491: (cappedRate1_[0]<<,r) 
}
array table
-----------------------------------------------
cappedRate1_ -> [('[i]', 'r', 'normalized', ['i'], 4488), ('[i]', 'r', 'normalized', ['i'], 4489), ('[i]', 'r', 'normalized', ['i'], 4490), ('[0]', 'r', 'normalized', ['i'], 4491)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i = 0  i < cappedRate2_.size()  i++
induction variable: ['i']
{
L4492: (cappedRate2_[i]==,r) 
L4493: (cappedRate2_[i],r) 
L4494: (cappedRate2_[i],r) 
L4495: (cappedRate2_[0]<<,r) 
}
array table
-----------------------------------------------
cappedRate2_ -> [('[i]', 'r', 'normalized', ['i'], 4492), ('[i]', 'r', 'normalized', ['i'], 4493), ('[i]', 'r', 'normalized', ['i'], 4494), ('[0]', 'r', 'normalized', ['i'], 4495)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i = 0  i < flooredRate1_.size()  i++
induction variable: ['i']
{
L4496: (flooredRate1_[i]==,r) 
L4497: (flooredRate1_[i],r) 
L4498: (flooredRate1_[i],r) 
L4499: (flooredRate1_[0]<<,r) 
}
array table
-----------------------------------------------
flooredRate1_ -> [('[i]', 'r', 'normalized', ['i'], 4496), ('[i]', 'r', 'normalized', ['i'], 4497), ('[i]', 'r', 'normalized', ['i'], 4498), ('[0]', 'r', 'normalized', ['i'], 4499)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i = 0  i < flooredRate2_.size()  i++
induction variable: ['i']
{
L4500: (flooredRate2_[i]==,r) 
L4501: (flooredRate2_[i],r) 
L4502: (flooredRate2_[i],r) 
L4503: (flooredRate2_[0]<<,r) 
}
array table
-----------------------------------------------
flooredRate2_ -> [('[i]', 'r', 'normalized', ['i'], 4500), ('[i]', 'r', 'normalized', ['i'], 4501), ('[i]', 'r', 'normalized', ['i'], 4502), ('[0]', 'r', 'normalized', ['i'], 4503)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i = 0  i < legs_[0].size() - 1  i++
induction variable: ['i']
{
L4504: (nominal1_[i + 1]-,r) (nominal1_[i],r) 
L4505: (legs_[0].begin,r) 
L4506: (legs_[0].insert,r) 
L4507: (legs_[0][i]-,r) 
L4508: (nominal1_[i],r) 
}
array table
-----------------------------------------------
nominal1_ -> [('[i + 1]', 'r', 'normalized', ['i'], 4504), ('[i]', 'r', 'normalized', ['i'], 4504), ('[i]', 'r', 'normalized', ['i'], 4508)]
LDEs formed:0

legs_ -> [('[0]', 'r', 'normalized', ['i'], 4505), ('[0]', 'r', 'normalized', ['i'], 4506), ('[0][i]', 'r', 'normalized', ['i'], 4507)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i = 0  i < legs_[1].size() - 1  i++
induction variable: ['i']
{
L4508: (nominal2_[i + 1]-,r) (nominal2_[i],r) 
L4509: (legs_[1].begin,r) 
L4510: (legs_[1].insert,r) 
L4511: (legs_[1][i]-,r) 
L4512: (nominal2_[i],r) 
}
array table
-----------------------------------------------
nominal2_ -> [('[i + 1]', 'r', 'normalized', ['i'], 4508), ('[i]', 'r', 'normalized', ['i'], 4508), ('[i]', 'r', 'normalized', ['i'], 4512)]
LDEs formed:0

legs_ -> [('[1]', 'r', 'normalized', ['i'], 4509), ('[1]', 'r', 'normalized', ['i'], 4510), ('[1][i]', 'r', 'normalized', ['i'], 4511)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i = 0  i < leg1Coupons.size()  ++i
induction variable: ['i']
{
L4512: (leg1Coupons[i],r) 
L4513: (leg1AccrualTimes[i]=,w) 
L4514: (leg1PayDates[i]=,w) 
L4515: (leg1ResetDates[i]=,w) 
L4516: (leg1FixingDates[i]=,w) 
L4517: (leg1Spreads[i]=,w) 
L4518: (leg1Gearings[i]=,w) 
L4519: (leg1Coupons[i]=,w) 
L4520: (leg1Coupons[i]=,w) 
L4521: (leg1Coupons[i],r) 
L4522: (leg1CappedRates[i]=,w) 
L4523: (leg1FlooredRates[i]=,w) 
L4524: (leg1Coupons[i],r) 
L4525: (leg1IsRedemptionFlow[i]=,w) 
L4526: (leg1Coupons[i]=,w) 
L4527: (leg1ResetDates[i]=,w) (leg1ResetDates[jIdx],r) 
L4528: (leg1FixingDates[i]=,w) 
L4529: (leg1FixingDates[jIdx],r) 
L4530: (leg1AccrualTimes[i]=,w) 
L4531: (leg1Spreads[i]=,w) 
L4532: (leg1Gearings[i]=,w) 
L4533: (leg1PayDates[i]=,w) 
}
array table
-----------------------------------------------
leg1Spreads -> [('[i]', 'w', 'normalized', ['i'], 4517), ('[i]', 'w', 'normalized', ['i'], 4531)]
LDEs formed:3

leg1IsRedemptionFlow -> [('[i]', 'w', 'normalized', ['i'], 4525)]
LDEs formed:1

leg1Gearings -> [('[i]', 'w', 'normalized', ['i'], 4518), ('[i]', 'w', 'normalized', ['i'], 4532)]
LDEs formed:3

leg1CappedRates -> [('[i]', 'w', 'normalized', ['i'], 4522)]
LDEs formed:1

leg1PayDates -> [('[i]', 'w', 'normalized', ['i'], 4514), ('[i]', 'w', 'normalized', ['i'], 4533)]
LDEs formed:3

leg1FixingDates -> [('[i]', 'w', 'normalized', ['i'], 4516), ('[i]', 'w', 'normalized', ['i'], 4528), ('[jIdx]', 'r', 'not normalized', ['i'], 4529)]
LDEs formed:5

leg1FlooredRates -> [('[i]', 'w', 'normalized', ['i'], 4523)]
LDEs formed:1

leg1Coupons -> [('[i]', 'r', 'normalized', ['i'], 4512), ('[i]', 'w', 'normalized', ['i'], 4519), ('[i]', 'w', 'normalized', ['i'], 4520), ('[i]', 'r', 'normalized', ['i'], 4521), ('[i]', 'r', 'normalized', ['i'], 4524), ('[i]', 'w', 'normalized', ['i'], 4526)]
LDEs formed:15

leg1AccrualTimes -> [('[i]', 'w', 'normalized', ['i'], 4513), ('[i]', 'w', 'normalized', ['i'], 4530)]
LDEs formed:3

leg1ResetDates -> [('[i]', 'w', 'normalized', ['i'], 4515), ('[i]', 'w', 'normalized', ['i'], 4527), ('[jIdx]', 'r', 'not normalized', ['i'], 4527)]
LDEs formed:5

distinct LDEs:
i1=jIdx
i1=i2
#########################################################################################
loop info: Size i = 0  i < leg2Coupons.size()  ++i
induction variable: ['i']
{
L4528: (leg2Coupons[i],r) 
L4529: (leg2AccrualTimes[i]=,w) 
L4530: (leg2PayDates[i]=,w) 
L4531: (leg2ResetDates[i]=,w) 
L4532: (leg2FixingDates[i]=,w) 
L4533: (leg2Spreads[i]=,w) 
L4534: (leg2Gearings[i]=,w) 
L4535: (leg2Coupons[i]=,w) 
L4536: (leg2Coupons[i]=,w) 
L4537: (leg2Coupons[i],r) 
L4538: (leg2CappedRates[i]=,w) 
L4539: (leg2FlooredRates[i]=,w) 
L4540: (leg2Coupons[i],r) 
L4541: (leg2IsRedemptionFlow[i]=,w) 
L4542: (leg2Coupons[i]=,w) 
L4543: (leg2ResetDates[i]=,w) (leg2ResetDates[jIdx],r) 
L4544: (leg2FixingDates[i]=,w) 
L4545: (leg2FixingDates[jIdx],r) 
L4546: (leg2AccrualTimes[i]=,w) 
L4547: (leg2Spreads[i]=,w) 
L4548: (leg2Gearings[i]=,w) 
L4549: (leg2PayDates[i]=,w) 
}
array table
-----------------------------------------------
leg2Coupons -> [('[i]', 'r', 'normalized', ['i'], 4528), ('[i]', 'w', 'normalized', ['i'], 4535), ('[i]', 'w', 'normalized', ['i'], 4536), ('[i]', 'r', 'normalized', ['i'], 4537), ('[i]', 'r', 'normalized', ['i'], 4540), ('[i]', 'w', 'normalized', ['i'], 4542)]
LDEs formed:15

leg2CappedRates -> [('[i]', 'w', 'normalized', ['i'], 4538)]
LDEs formed:1

leg2Spreads -> [('[i]', 'w', 'normalized', ['i'], 4533), ('[i]', 'w', 'normalized', ['i'], 4547)]
LDEs formed:3

leg2FixingDates -> [('[i]', 'w', 'normalized', ['i'], 4532), ('[i]', 'w', 'normalized', ['i'], 4544), ('[jIdx]', 'r', 'not normalized', ['i'], 4545)]
LDEs formed:5

leg2AccrualTimes -> [('[i]', 'w', 'normalized', ['i'], 4529), ('[i]', 'w', 'normalized', ['i'], 4546)]
LDEs formed:3

leg2Gearings -> [('[i]', 'w', 'normalized', ['i'], 4534), ('[i]', 'w', 'normalized', ['i'], 4548)]
LDEs formed:3

leg2IsRedemptionFlow -> [('[i]', 'w', 'normalized', ['i'], 4541)]
LDEs formed:1

leg2PayDates -> [('[i]', 'w', 'normalized', ['i'], 4530), ('[i]', 'w', 'normalized', ['i'], 4549)]
LDEs formed:3

leg2FlooredRates -> [('[i]', 'w', 'normalized', ['i'], 4539)]
LDEs formed:1

leg2ResetDates -> [('[i]', 'w', 'normalized', ['i'], 4531), ('[i]', 'w', 'normalized', ['i'], 4543), ('[jIdx]', 'r', 'not normalized', ['i'], 4543)]
LDEs formed:5

distinct LDEs:
i1=jIdx
i1=i2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/instruments/nonstandardswap.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i = 0  i < legs_[0].size() - 1  i++
induction variable: ['i']
{
L4544: (fixedNominal_[i + 1]-,r) (fixedNominal_[i],r) 
L4545: (legs_[0].begin,r) 
L4546: (legs_[0].insert,r) 
L4547: (legs_[0][i]-,r) 
L4548: (fixedNominal_[i],r) 
}
array table
-----------------------------------------------
fixedNominal_ -> [('[i + 1]', 'r', 'normalized', ['i'], 4544), ('[i]', 'r', 'normalized', ['i'], 4544), ('[i]', 'r', 'normalized', ['i'], 4548)]
LDEs formed:0

legs_ -> [('[0]', 'r', 'normalized', ['i'], 4545), ('[0]', 'r', 'normalized', ['i'], 4546), ('[0][i]', 'r', 'normalized', ['i'], 4547)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i = 0  i < legs_[1].size() - 1  i++
induction variable: ['i']
{
L4548: (floatingNominal_[i + 1]-,r) (floatingNominal_[i],r) 
L4549: (legs_[1].begin,r) 
L4550: (legs_[1].insert,r) 
L4551: (legs_[1][i]-,r) 
L4552: (floatingNominal_[i],r) 
}
array table
-----------------------------------------------
floatingNominal_ -> [('[i + 1]', 'r', 'normalized', ['i'], 4548), ('[i]', 'r', 'normalized', ['i'], 4548), ('[i]', 'r', 'normalized', ['i'], 4552)]
LDEs formed:0

legs_ -> [('[1]', 'r', 'normalized', ['i'], 4549), ('[1]', 'r', 'normalized', ['i'], 4550), ('[1][i]', 'r', 'normalized', ['i'], 4551)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i = 0  i < fixedCoupons.size()  ++i
induction variable: ['i']
{
L4552: (fixedCoupons[i],r) 
L4553: (fixedPayDates[i]=,w) 
L4554: (fixedResetDates[i]=,w) 
L4555: (fixedCoupons[i]=,w) 
L4556: (fixedCoupons[i],r) 
L4557: (fixedIsRedemptionFlow[i]=,w) 
L4558: (fixedCoupons[i]=,w) 
L4559: (fixedResetDates[i]=,w) 
L4560: (fixedResetDates[jIdx],r) 
L4561: (fixedPayDates[i]=,w) 
}
array table
-----------------------------------------------
fixedCoupons -> [('[i]', 'r', 'normalized', ['i'], 4552), ('[i]', 'w', 'normalized', ['i'], 4555), ('[i]', 'r', 'normalized', ['i'], 4556), ('[i]', 'w', 'normalized', ['i'], 4558)]
LDEs formed:7

fixedIsRedemptionFlow -> [('[i]', 'w', 'normalized', ['i'], 4557)]
LDEs formed:1

fixedResetDates -> [('[i]', 'w', 'normalized', ['i'], 4554), ('[i]', 'w', 'normalized', ['i'], 4559), ('[jIdx]', 'r', 'not normalized', ['i'], 4560)]
LDEs formed:5

fixedPayDates -> [('[i]', 'w', 'normalized', ['i'], 4553), ('[i]', 'w', 'normalized', ['i'], 4561)]
LDEs formed:3

distinct LDEs:
i1=jIdx
i1=i2
#########################################################################################
loop info: Size i = 0  i < floatingCoupons.size()  ++i
induction variable: ['i']
{
L4562: (floatingCoupons[i],r) 
L4563: (floatingResetDates[i]=,w) 
L4564: (floatingPayDates[i]=,w) 
L4565: (floatingFixingDates[i]=,w) 
L4566: (floatingAccrualTimes[i]=,w) 
L4567: (floatingSpreads[i]=,w) 
L4568: (floatingGearings[i]=,w) 
L4569: (floatingCoupons[i]=,w) 
L4570: (floatingCoupons[i]=,w) 
L4571: (floatingCoupons[i],r) 
L4572: (floatingIsRedemptionFlow[i]=,w) 
L4573: (floatingCoupons[i]=,w) 
L4574: (floatingResetDates[i]=,w) 
L4575: (floatingResetDates[jIdx],r) 
L4576: (floatingFixingDates[i]=,w) 
L4577: (floatingFixingDates[jIdx],r) 
L4578: (floatingAccrualTimes[i]=,w) 
L4579: (floatingSpreads[i]=,w) 
L4580: (floatingGearings[i]=,w) 
L4581: (floatingPayDates[i]=,w) 
}
array table
-----------------------------------------------
floatingResetDates -> [('[i]', 'w', 'normalized', ['i'], 4563), ('[i]', 'w', 'normalized', ['i'], 4574), ('[jIdx]', 'r', 'not normalized', ['i'], 4575)]
LDEs formed:5

floatingSpreads -> [('[i]', 'w', 'normalized', ['i'], 4567), ('[i]', 'w', 'normalized', ['i'], 4579)]
LDEs formed:3

floatingFixingDates -> [('[i]', 'w', 'normalized', ['i'], 4565), ('[i]', 'w', 'normalized', ['i'], 4576), ('[jIdx]', 'r', 'not normalized', ['i'], 4577)]
LDEs formed:5

floatingCoupons -> [('[i]', 'r', 'normalized', ['i'], 4562), ('[i]', 'w', 'normalized', ['i'], 4569), ('[i]', 'w', 'normalized', ['i'], 4570), ('[i]', 'r', 'normalized', ['i'], 4571), ('[i]', 'w', 'normalized', ['i'], 4573)]
LDEs formed:12

floatingIsRedemptionFlow -> [('[i]', 'w', 'normalized', ['i'], 4572)]
LDEs formed:1

floatingPayDates -> [('[i]', 'w', 'normalized', ['i'], 4564), ('[i]', 'w', 'normalized', ['i'], 4581)]
LDEs formed:3

floatingAccrualTimes -> [('[i]', 'w', 'normalized', ['i'], 4566), ('[i]', 'w', 'normalized', ['i'], 4578)]
LDEs formed:3

floatingGearings -> [('[i]', 'w', 'normalized', ['i'], 4568), ('[i]', 'w', 'normalized', ['i'], 4580)]
LDEs formed:3

distinct LDEs:
i1=jIdx
i1=i2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/instruments/swap.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size j=0  j<legs_.size()  ++j
induction variable: ['j']
{
L4581: (payer[j],r) (payer_[j]=,w) 
	loop info: Leg::iterator i = legs_[j].begin()  i!= legs_[j].end()  ++i
	induction variable: ['j', 'i']
	{
	}
 }
array table
-----------------------------------------------
payer_ -> [('[j]', 'w', 'normalized', ['j', 'i'], 4581)]
LDEs formed:1

payer -> [('[j]', 'r', 'normalized', ['j', 'i'], 4581)]
LDEs formed:0

distinct LDEs:
j1=j2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/instruments/bonds/btp.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<k  ++i
induction variable: ['i']
{
L4582: (outstandings[i],r) 
L4583: (btps[i]-,r) 
}
array table
-----------------------------------------------
outstandings -> [('[i]', 'r', 'normalized', ['i'], 4582)]
LDEs formed:0

btps -> [('[i]', 'r', 'normalized', ['i'], 4583)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<n_  ++i
induction variable: ['i']
{
L4584: (weights_[i]=,w) (outstandings[i]/,r) 
L4585: (quotes_[i],r) 
}
array table
-----------------------------------------------
outstandings -> [('[i]', 'r', 'normalized', ['i'], 4584)]
LDEs formed:0

quotes_ -> [('[i]', 'r', 'normalized', ['i'], 4585)]
LDEs formed:0

weights_ -> [('[i]', 'w', 'normalized', ['i'], 4584)]
LDEs formed:1

distinct LDEs:
i1=i2
#########################################################################################
loop info: Size i=0  i<nSwaps_  ++i
induction variable: ['i']
{
L4585: (swapLenghts_[i]=,w) 
L4586: (swaps_[i]=,w) 
L4587: (swapLenghts_[i]*,r) 
}
array table
-----------------------------------------------
swaps_ -> [('[i]', 'w', 'normalized', ['i'], 4586)]
LDEs formed:1

swapLenghts_ -> [('[i]', 'w', 'normalized', ['i'], 4585), ('[i]', 'r', 'normalized', ['i'], 4587)]
LDEs formed:2

distinct LDEs:
i1=i2
#########################################################################################
loop info: Size i=0  i<basket_->size()  ++i
induction variable: ['i']
{
L4588: (yields_[i]=,w) 
L4589: (btps[i],r) (quotes[i]-,r) 
L4590: (yields_[i],r) 
L4591: (durations_[i]=,w) 
L4592: (btps[i],r) (yields_[i],r) 
}
array table
-----------------------------------------------
quotes -> [('[i]', 'r', 'normalized', ['i'], 4589)]
LDEs formed:0

durations_ -> [('[i]', 'w', 'normalized', ['i'], 4591)]
LDEs formed:1

btps -> [('[i]', 'r', 'normalized', ['i'], 4589), ('[i]', 'r', 'normalized', ['i'], 4592)]
LDEs formed:0

yields_ -> [('[i]', 'w', 'normalized', ['i'], 4588), ('[i]', 'r', 'normalized', ['i'], 4590), ('[i]', 'r', 'normalized', ['i'], 4592)]
LDEs formed:3

distinct LDEs:
i1=i2
#########################################################################################
loop info: Size i=1  i<nSwaps_  ++i
induction variable: ['i']
{
L4593: (swapRates_[i]=,w) (swaps_[i]-,r) 
L4594: (swaps_[i]-,r) 
L4595: (swapRates_[i],r) 
L4596: (swapBondYields_[i]=,w) 
L4597: (swapBondYields_[i],r) 
L4598: (swapBondDurations_[i]=,w) 
L4599: (swapBondYields_[i],r) 
L4600: (swapBondDurations_[i],r) 
}
array table
-----------------------------------------------
swapBondYields_ -> [('[i]', 'w', 'normalized', ['i'], 4596), ('[i]', 'r', 'normalized', ['i'], 4597), ('[i]', 'r', 'normalized', ['i'], 4599)]
LDEs formed:3

swaps_ -> [('[i]', 'r', 'normalized', ['i'], 4593), ('[i]', 'r', 'normalized', ['i'], 4594)]
LDEs formed:0

swapRates_ -> [('[i]', 'w', 'normalized', ['i'], 4593), ('[i]', 'r', 'normalized', ['i'], 4595)]
LDEs formed:2

swapBondDurations_ -> [('[i]', 'w', 'normalized', ['i'], 4598), ('[i]', 'r', 'normalized', ['i'], 4600)]
LDEs formed:2

distinct LDEs:
i1=i2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/instruments/bonds/cpibond.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/cashflows/rangeaccrual.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0 i<observationsNo_ i++
induction variable: ['i']
{
L4601: (observationDates_[i],r) 
}
array table
-----------------------------------------------
observationDates_ -> [('[i]', 'r', 'normalized', ['i'], 4601)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<observationDates.size()  i++
induction variable: ['i']
{
L4602: (initialValues_[i]=,w) 
L4603: (observationDates[i],r) 
}
array table
-----------------------------------------------
initialValues_ -> [('[i]', 'w', 'normalized', ['i'], 4602)]
LDEs formed:1

observationDates -> [('[i]', 'r', 'normalized', ['i'], 4603)]
LDEs formed:0

distinct LDEs:
i1=i2
#########################################################################################
loop info: Size i=0 i<observationsNo_ i++
induction variable: ['i']
{
L4604: (initialValues_[i+1],r) 
L4605: (observationTimes_[i],r) 
}
array table
-----------------------------------------------
initialValues_ -> [('[i+1]', 'r', 'normalized', ['i'], 4604)]
LDEs formed:0

observationTimes_ -> [('[i]', 'r', 'normalized', ['i'], 4605)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/cashflows/lineartsrpricer.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/cashflows/conundrumpricer.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<n  ++i
induction variable: ['i']
{
L4606: (fixedLeg[i],r) 
}
array table
-----------------------------------------------
fixedLeg -> [('[i]', 'r', 'normalized', ['i'], 4606)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<accruals_.size()  i++
induction variable: ['i']
{
L4607: (accruals_[i]*,r) 
}
array table
-----------------------------------------------
accruals_ -> [('[i]', 'r', 'normalized', ['i'], 4607)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<accruals_.size()  i++
induction variable: ['i']
{
L4608: (accruals_[i]*,r) 
L4609: (accruals_[i]*,r) 
}
array table
-----------------------------------------------
accruals_ -> [('[i]', 'r', 'normalized', ['i'], 4608), ('[i]', 'r', 'normalized', ['i'], 4609)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<accruals_.size()  i++
induction variable: ['i']
{
L4610: (accruals_[i]*,r) 
L4611: (accruals_[i]*,r) 
L4612: (accruals_[i]*,r) 
}
array table
-----------------------------------------------
accruals_ -> [('[i]', 'r', 'normalized', ['i'], 4610), ('[i]', 'r', 'normalized', ['i'], 4611), ('[i]', 'r', 'normalized', ['i'], 4612)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<n  ++i
induction variable: ['i']
{
L4613: (fixedLeg[i],r) 
}
array table
-----------------------------------------------
fixedLeg -> [('[i]', 'r', 'normalized', ['i'], 4613)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<accruals_.size()  i++
induction variable: ['i']
{
L4614: (accruals_[i]*,r) (swapPaymentDiscounts_[i],r) 
L4615: (shapedSwapPaymentTimes_[i]*,r) 
L4616: (shapedSwapPaymentTimes_[i]*,r) (accruals_[i]*,r) (swapPaymentDiscounts_[i],r) 
L4617: (shapedSwapPaymentTimes_[i]*,r) 
}
array table
-----------------------------------------------
accruals_ -> [('[i]', 'r', 'normalized', ['i'], 4614), ('[i]', 'r', 'normalized', ['i'], 4616)]
LDEs formed:0

shapedSwapPaymentTimes_ -> [('[i]', 'r', 'normalized', ['i'], 4615), ('[i]', 'r', 'normalized', ['i'], 4616), ('[i]', 'r', 'normalized', ['i'], 4617)]
LDEs formed:0

swapPaymentDiscounts_ -> [('[i]', 'r', 'normalized', ['i'], 4614), ('[i]', 'r', 'normalized', ['i'], 4616)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<accruals_.size()  i++
induction variable: ['i']
{
L4617: (accruals_[i]*,r) (swapPaymentDiscounts_[i],r) 
L4618: (shapedSwapPaymentTimes_[i]*,r) 
L4619: (shapedSwapPaymentTimes_[i]*,r) (accruals_[i]*,r) (swapPaymentDiscounts_[i],r) 
L4620: (shapedSwapPaymentTimes_[i]*,r) 
L4621: (shapedSwapPaymentTimes_[i]*,r) (shapedSwapPaymentTimes_[i]*,r) (accruals_[i]*,r) 
L4622: (swapPaymentDiscounts_[i]*,r) (shapedSwapPaymentTimes_[i]*,r) 
}
array table
-----------------------------------------------
accruals_ -> [('[i]', 'r', 'normalized', ['i'], 4617), ('[i]', 'r', 'normalized', ['i'], 4619), ('[i]', 'r', 'normalized', ['i'], 4621)]
LDEs formed:0

shapedSwapPaymentTimes_ -> [('[i]', 'r', 'normalized', ['i'], 4618), ('[i]', 'r', 'normalized', ['i'], 4619), ('[i]', 'r', 'normalized', ['i'], 4620), ('[i]', 'r', 'normalized', ['i'], 4621), ('[i]', 'r', 'normalized', ['i'], 4621), ('[i]', 'r', 'normalized', ['i'], 4622)]
LDEs formed:0

swapPaymentDiscounts_ -> [('[i]', 'r', 'normalized', ['i'], 4617), ('[i]', 'r', 'normalized', ['i'], 4619), ('[i]', 'r', 'normalized', ['i'], 4622)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<o_.accruals_.size()  i++
induction variable: ['i']
{
L4623: (o_.accruals_[i]*,r) (o_.swapPaymentDiscounts_[i],r) 
L4624: (o_.shapedSwapPaymentTimes_[i]*,r) 
L4625: (o_.shapedSwapPaymentTimes_[i]*,r) 
}
array table
-----------------------------------------------
o_.accruals_ -> [('[i]', 'r', 'normalized', ['i'], 4623)]
LDEs formed:0

o_.swapPaymentDiscounts_ -> [('[i]', 'r', 'normalized', ['i'], 4623)]
LDEs formed:0

o_.shapedSwapPaymentTimes_ -> [('[i]', 'r', 'normalized', ['i'], 4624), ('[i]', 'r', 'normalized', ['i'], 4625)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<accruals_.size()  i++
induction variable: ['i']
{
L4626: (accruals_[i]*,r) (swapPaymentDiscounts_[i],r) 
L4627: (accruals_[i]*,r) (swapPaymentDiscounts_[i]*,r) (shapedSwapPaymentTimes_[i],r) 
}
array table
-----------------------------------------------
accruals_ -> [('[i]', 'r', 'normalized', ['i'], 4626), ('[i]', 'r', 'normalized', ['i'], 4627)]
LDEs formed:0

shapedSwapPaymentTimes_ -> [('[i]', 'r', 'normalized', ['i'], 4627)]
LDEs formed:0

swapPaymentDiscounts_ -> [('[i]', 'r', 'normalized', ['i'], 4626), ('[i]', 'r', 'normalized', ['i'], 4627)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/cashflows/cpicoupon.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/cashflows/timebasket.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: const_iterator j = begin()  j != end()  ++j
induction variable: ['j']
{
L4628: (result[pDate]+=,w) 
L4629: (result[pDate]+=,w) 
L4630: (result[nDate]+=,w) 
}
array table
-----------------------------------------------
result -> [('[pDate]', 'w', 'not normalized', ['j'], 4628), ('[pDate]', 'w', 'not normalized', ['j'], 4629), ('[nDate]', 'w', 'not normalized', ['j'], 4630)]
LDEs formed:6

distinct LDEs:
nDate=nDate
pDate=nDate
pDate=pDate
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/cashflows/couponpricer.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<leg.size()  ++i
induction variable: ['i']
{
L4631: (leg[i]-,r) 
}
array table
-----------------------------------------------
leg -> [('[i]', 'r', 'normalized', ['i'], 4631)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<nCashFlows  ++i
induction variable: ['i']
{
L4632: (pricers[i],r) (pricers[nPricers-1],r) 
L4633: (leg[i]-,r) 
}
array table
-----------------------------------------------
pricers -> [('[i]', 'r', 'normalized', ['i'], 4632), ('[nPricers-1]', 'r', 'not normalized', ['i'], 4632)]
LDEs formed:0

leg -> [('[i]', 'r', 'normalized', ['i'], 4633)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/cashflows/averagebmacoupon.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<fixingDates.size() - 1  ++i
induction variable: ['i']
{
L4634: (fixingDates[i],r) 
L4635: (fixingDates[i+1],r) 
L4636: (fixingDates[i],r) 
L4637: (fixingDates[i+1],r) 
L4638: (fixingDates[i],r) 
}
array table
-----------------------------------------------
fixingDates -> [('[i]', 'r', 'normalized', ['i'], 4634), ('[i+1]', 'r', 'normalized', ['i'], 4635), ('[i]', 'r', 'normalized', ['i'], 4636), ('[i+1]', 'r', 'normalized', ['i'], 4637), ('[i]', 'r', 'normalized', ['i'], 4638)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/cashflows/yoyinflationcoupon.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/cashflows/cashflows.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<leg.size()  ++i
induction variable: ['i']
{
L4639: (leg[i],r) 
L4640: (leg[i]-,r) 
}
array table
-----------------------------------------------
leg -> [('[i]', 'r', 'normalized', ['i'], 4639), ('[i]', 'r', 'normalized', ['i'], 4640)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<leg.size()  ++i
induction variable: ['i']
{
L4641: (leg[i],r) 
L4642: (leg[i]-,r) 
}
array table
-----------------------------------------------
leg -> [('[i]', 'r', 'normalized', ['i'], 4641), ('[i]', 'r', 'normalized', ['i'], 4642)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<leg.size()  ++i
induction variable: ['i']
{
L4643: (leg[i]-,r) 
L4644: (leg[i]-,r) 
L4645: (leg[i]-,r) 
L4646: (leg[i]-,r) 
}
array table
-----------------------------------------------
leg -> [('[i]', 'r', 'normalized', ['i'], 4643), ('[i]', 'r', 'normalized', ['i'], 4644), ('[i]', 'r', 'normalized', ['i'], 4645), ('[i]', 'r', 'normalized', ['i'], 4646)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<leg.size()  ++i
induction variable: ['i']
{
L4647: (leg[i]-,r) 
L4648: (leg[i]-,r) 
L4649: (leg[i]-,r) 
}
array table
-----------------------------------------------
leg -> [('[i]', 'r', 'normalized', ['i'], 4647), ('[i]', 'r', 'normalized', ['i'], 4648), ('[i]', 'r', 'normalized', ['i'], 4649)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<leg.size()  ++i
induction variable: ['i']
{
L4650: (leg[i],r) 
L4651: (leg[i],r) 
}
array table
-----------------------------------------------
leg -> [('[i]', 'r', 'normalized', ['i'], 4650), ('[i]', 'r', 'normalized', ['i'], 4651)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<leg.size()  ++i
induction variable: ['i']
{
L4652: (leg[i],r) 
}
array table
-----------------------------------------------
leg -> [('[i]', 'r', 'normalized', ['i'], 4652)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<leg.size()  ++i
induction variable: ['i']
{
L4653: (leg[i]-,r) 
L4654: (leg[i]-,r) 
L4655: (leg[i]-,r) 
L4656: (leg[i]-,r) 
L4657: (leg[i],r) 
}
array table
-----------------------------------------------
leg -> [('[i]', 'r', 'normalized', ['i'], 4653), ('[i]', 'r', 'normalized', ['i'], 4654), ('[i]', 'r', 'normalized', ['i'], 4655), ('[i]', 'r', 'normalized', ['i'], 4656), ('[i]', 'r', 'normalized', ['i'], 4657)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<leg.size()  ++i
induction variable: ['i']
{
L4658: (leg[i]-,r) 
L4659: (leg[i]-,r) 
L4660: (leg[i]-,r) 
L4661: (leg[i]-,r) 
L4662: (leg[i],r) 
}
array table
-----------------------------------------------
leg -> [('[i]', 'r', 'normalized', ['i'], 4658), ('[i]', 'r', 'normalized', ['i'], 4659), ('[i]', 'r', 'normalized', ['i'], 4660), ('[i]', 'r', 'normalized', ['i'], 4661), ('[i]', 'r', 'normalized', ['i'], 4662)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i = 0  i < leg_.size()  ++i
induction variable: ['i']
{
L4663: (leg_[i]-,r) 
L4664: (leg_[i]-,r) 
L4665: (leg_[i]-,r) 
}
array table
-----------------------------------------------
leg_ -> [('[i]', 'r', 'normalized', ['i'], 4663), ('[i]', 'r', 'normalized', ['i'], 4664), ('[i]', 'r', 'normalized', ['i'], 4665)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i = 0  i < leg.size()  ++i
induction variable: ['i']
{
L4666: (leg[i]-,r) 
}
array table
-----------------------------------------------
leg -> [('[i]', 'r', 'normalized', ['i'], 4666)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<leg.size()  ++i
induction variable: ['i']
{
L4667: (leg[i]-,r) 
L4668: (leg[i]-,r) 
L4669: (leg[i]-,r) 
L4670: (leg[i]-,r) 
L4671: (leg[i],r) 
}
array table
-----------------------------------------------
leg -> [('[i]', 'r', 'normalized', ['i'], 4667), ('[i]', 'r', 'normalized', ['i'], 4668), ('[i]', 'r', 'normalized', ['i'], 4669), ('[i]', 'r', 'normalized', ['i'], 4670), ('[i]', 'r', 'normalized', ['i'], 4671)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<leg.size()  ++i
induction variable: ['i']
{
L4672: (leg[i]-,r) 
L4673: (leg[i]-,r) 
L4674: (leg[i]-,r) 
L4675: (leg[i]-,r) 
L4676: (leg[i],r) 
}
array table
-----------------------------------------------
leg -> [('[i]', 'r', 'normalized', ['i'], 4672), ('[i]', 'r', 'normalized', ['i'], 4673), ('[i]', 'r', 'normalized', ['i'], 4674), ('[i]', 'r', 'normalized', ['i'], 4675), ('[i]', 'r', 'normalized', ['i'], 4676)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/cashflows/fixedratecoupon.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=2  i<schedule_.size()-1  ++i
induction variable: ['i']
{
L4677: (couponRates_[i-1],r) 
L4678: (notionals_[i-1],r) 
}
array table
-----------------------------------------------
notionals_ -> [('[i-1]', 'r', 'normalized', ['i'], 4678)]
LDEs formed:0

couponRates_ -> [('[i-1]', 'r', 'normalized', ['i'], 4677)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/cashflows/overnightindexedcoupon.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/time/schedule.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/time/ecb.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/time/calendar.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/time/daycounters/actualactual.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/time/daycounters/business252.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/time/calendars/jointcalendar.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/termstructures/yieldtermstructure.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<nJumps_  ++i
induction variable: ['i']
{
L4678: (jumpTimes_[i],r) (jumpTimes_[i],r) 
L4679: (jumps_[i]-,r) 
L4680: (jumps_[i]-,r) 
}
array table
-----------------------------------------------
jumps_ -> [('[i]', 'r', 'normalized', ['i'], 4679), ('[i]', 'r', 'normalized', ['i'], 4680)]
LDEs formed:0

jumpTimes_ -> [('[i]', 'r', 'normalized', ['i'], 4678), ('[i]', 'r', 'normalized', ['i'], 4678)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/termstructures/defaulttermstructure.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<nJumps_ && jumpTimes_[i]<t  ++i
induction variable: ['i']
{
L4679: (jumps_[i]-,r) 
L4680: (jumps_[i]-,r) 
}
array table
-----------------------------------------------
jumps_ -> [('[i]', 'r', 'normalized', ['i'], 4679), ('[i]', 'r', 'normalized', ['i'], 4680)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/termstructures/yield/forwardstructure.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/termstructures/yield/fittedbonddiscountcurve.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<bondHelpers_.size()  ++i
induction variable: ['i']
{
L4681: (bondHelpers_[i]-,r) 
L4682: (bondHelpers_[i]-,r) 
L4683: (bondHelpers_[i]-,r) 
L4684: (bondHelpers_[i]-,r) 
}
array table
-----------------------------------------------
bondHelpers_ -> [('[i]', 'r', 'normalized', ['i'], 4681), ('[i]', 'r', 'normalized', ['i'], 4682), ('[i]', 'r', 'normalized', ['i'], 4683), ('[i]', 'r', 'normalized', ['i'], 4684)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<curve_->bondHelpers_.size()  ++i
induction variable: ['i']
{
L4685: (bondHelpers_[i]-,r) 
L4686: (bondHelpers_[i]-,r) 
L4687: (weights_[i]=,w) 
L4688: (weights_[i]*,r) (weights_[i],r) 
	loop info: Size k=0  k<cf.size()  ++k
	induction variable: ['i', 'k']
	{
	L4689: (cf[k]-,r) 
	L4690: (firstCashFlow_[i]=,w) 
	}
 }
array table
-----------------------------------------------
firstCashFlow_ -> [('[i]', 'w', 'normalized', ['i', 'k'], 4690)]
LDEs formed:1

bondHelpers_ -> [('[i]', 'r', 'normalized', ['i', 'k'], 4685), ('[i]', 'r', 'normalized', ['i', 'k'], 4686)]
LDEs formed:0

weights_ -> [('[i]', 'w', 'normalized', ['i', 'k'], 4687), ('[i]', 'r', 'normalized', ['i', 'k'], 4688), ('[i]', 'r', 'normalized', ['i', 'k'], 4688)]
LDEs formed:3

cf -> [('[k]', 'r', 'normalized', ['i', 'k'], 4689)]
LDEs formed:0

distinct LDEs:
i1=i2
#########################################################################################
loop info: Size i=0  i<n  ++i
induction variable: ['i']
{
L4690: (bondHelpers_[i]-,r) 
	loop info: Size k=firstCashFlow_[i]  k<cf.size()  ++k
	induction variable: ['i', 'k']
	{
	L4691: (cf[k]-,r) 
	L4692: (cf[k]-,r) 
	}
L4693: (bondHelpers_[i]-,r) 
L4694: (weights_[i]*,r) 
}
array table
-----------------------------------------------
bondHelpers_ -> [('[i]', 'r', 'normalized', ['i', 'k'], 4690), ('[i]', 'r', 'normalized', ['i', 'k'], 4693)]
LDEs formed:0

weights_ -> [('[i]', 'r', 'normalized', ['i', 'k'], 4694)]
LDEs formed:0

cf -> [('[k]', 'r', 'normalized', ['i', 'k'], 4691), ('[k]', 'r', 'normalized', ['i', 'k'], 4692)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/termstructures/yield/nonlinearfittingmethods.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<N-1  ++i
induction variable: ['i']
{
L4693: (x[i]*,r) 
}
array table
-----------------------------------------------
x -> [('[i]', 'r', 'normalized', ['i'], 4693)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<N-1  i++
induction variable: ['i']
{
L4694: (x[i]*,r) 
L4695: (x[i],r) 
}
array table
-----------------------------------------------
x -> [('[i]', 'r', 'normalized', ['i'], 4694), ('[i]', 'r', 'normalized', ['i'], 4695)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<size_  ++i
induction variable: ['i']
{
L4696: (x[i]*,r) 
}
array table
-----------------------------------------------
x -> [('[i]', 'r', 'normalized', ['i'], 4696)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<size_  ++i
induction variable: ['i']
{
L4697: (x[i]*,r) 
L4698: (x[i]*,r) 
L4699: (x[i]*,r) 
L4700: (x[i]*,r) 
}
array table
-----------------------------------------------
x -> [('[i]', 'r', 'normalized', ['i'], 4697), ('[i]', 'r', 'normalized', ['i'], 4698), ('[i]', 'r', 'normalized', ['i'], 4699), ('[i]', 'r', 'normalized', ['i'], 4700)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/termstructures/inflation/seasonality.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<seasonalityFactors.size()  i++
induction variable: ['i']
{
L4701: (seasonalityFactors_[i]=,w) (seasonalityFactors[i],r) 
}
array table
-----------------------------------------------
seasonalityFactors_ -> [('[i]', 'w', 'normalized', ['i'], 4701)]
LDEs formed:1

seasonalityFactors -> [('[i]', 'r', 'normalized', ['i'], 4701)]
LDEs formed:0

distinct LDEs:
i1=i2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/termstructures/volatility/sabrinterpolatedsmilesection.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<volHandles_.size()  ++i
induction variable: ['i']
{
L4702: (volHandles_[i]-,r) 
L4703: (strikes_[i],r) 
L4704: (volHandles_[i]-,r) 
L4705: (strikes_[i],r) 
L4706: (volHandles_[i]-,r) 
}
array table
-----------------------------------------------
volHandles_ -> [('[i]', 'r', 'normalized', ['i'], 4702), ('[i]', 'r', 'normalized', ['i'], 4704), ('[i]', 'r', 'normalized', ['i'], 4706)]
LDEs formed:0

strikes_ -> [('[i]', 'r', 'normalized', ['i'], 4703), ('[i]', 'r', 'normalized', ['i'], 4705)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/termstructures/volatility/smilesectionutils.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i = 0  i < moneynessGrid.size() - 1  i++
induction variable: ['i']
{
L4706: (moneynessGrid[i],r) (moneynessGrid[i + 1],r) 
L4707: (moneynessGrid[i]<<,r) 
L4708: (moneynessGrid[i + 1]<<,r) 
}
array table
-----------------------------------------------
moneynessGrid -> [('[i]', 'r', 'normalized', ['i'], 4706), ('[i + 1]', 'r', 'normalized', ['i'], 4706), ('[i]', 'r', 'normalized', ['i'], 4707), ('[i + 1]', 'r', 'normalized', ['i'], 4708)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i = 0  i < tmp.size()  i++
induction variable: ['i']
{
L4709: (tmp[i]*,r) 
L4710: (tmp[i],r) 
L4711: (tmp[i],r) 
}
array table
-----------------------------------------------
tmp -> [('[i]', 'r', 'normalized', ['i'], 4709), ('[i]', 'r', 'normalized', ['i'], 4710), ('[i]', 'r', 'normalized', ['i'], 4711)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i = 1  i < k_.size()  i++
induction variable: ['i']
{
L4712: (k_[i],r) 
}
array table
-----------------------------------------------
k_ -> [('[i]', 'r', 'normalized', ['i'], 4712)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/termstructures/volatility/kahalesmilesection.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0 i<k_.size() ++i
induction variable: ['i']
{
L4713: (k_[i]+=,w) 
}
array table
-----------------------------------------------
k_ -> [('[i]', 'w', 'normalized', ['i'], 4713)]
LDEs formed:1

distinct LDEs:
i1=i2
#########################################################################################
loop info: Size i = leftIndex_  i < rightIndex_  i++
induction variable: ['i']
{
L4714: (k_[i],r) 
L4715: (k_[i + 1],r) 
L4716: (c_[i],r) 
L4717: (c_[i + 1],r) 
L4718: (c_[i + 1]-,r) (c_[i],r) (k_[i + 1]-,r) (k_[i],r) 
L4719: (c_[i + 2]-,r) (c_[i + 1],r) (k_[i + 2]-,r) (k_[i + 1],r) 
L4720: (cFunctions_[leftIndex_ > 0 ? i - leftIndex_ + 1 : 0]=,w) 
}
array table
-----------------------------------------------
c_ -> [('[i]', 'r', 'normalized', ['i'], 4716), ('[i + 1]', 'r', 'normalized', ['i'], 4717), ('[i + 1]', 'r', 'normalized', ['i'], 4718), ('[i]', 'r', 'normalized', ['i'], 4718), ('[i + 2]', 'r', 'normalized', ['i'], 4719), ('[i + 1]', 'r', 'normalized', ['i'], 4719)]
LDEs formed:0

k_ -> [('[i]', 'r', 'normalized', ['i'], 4714), ('[i + 1]', 'r', 'normalized', ['i'], 4715), ('[i + 1]', 'r', 'normalized', ['i'], 4718), ('[i]', 'r', 'normalized', ['i'], 4718), ('[i + 2]', 'r', 'normalized', ['i'], 4719), ('[i + 1]', 'r', 'normalized', ['i'], 4719)]
LDEs formed:0

cFunctions_ -> [('[leftIndex_ > 0 ? i - leftIndex_ + 1 : 0]', 'w', 'not normalized', ['i'], 4720)]
LDEs formed:1

distinct LDEs:
leftIndex_ > 0 ? i1 - leftIndex_ + 1 : 0=leftIndex_ > 0 ? i2 - leftIndex_ + 1 : 0
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/termstructures/volatility/abcdcalibration.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<times_.size()   i++
induction variable: ['i']
{
L4721: (blackVols_[i]*,r) (blackVols_[i]*,r) (times_[i],r) 
L4722: (weights_[i]=,w) 
L4723: (weights_[i],r) 
}
array table
-----------------------------------------------
blackVols_ -> [('[i]', 'r', 'normalized', ['i'], 4721), ('[i]', 'r', 'normalized', ['i'], 4721)]
LDEs formed:0

weights_ -> [('[i]', 'w', 'normalized', ['i'], 4722), ('[i]', 'r', 'normalized', ['i'], 4723)]
LDEs formed:2

times_ -> [('[i]', 'r', 'normalized', ['i'], 4721)]
LDEs formed:0

distinct LDEs:
i1=i2
#########################################################################################
loop info: Size i=0  i<times_.size()   i++
induction variable: ['i']
{
L4722: (weights_[i]/=,w) 
}
array table
-----------------------------------------------
weights_ -> [('[i]', 'w', 'normalized', ['i'], 4722)]
LDEs formed:1

distinct LDEs:
i1=i2
#########################################################################################
loop info: Size i=0  i<t.size()   i++
induction variable: ['i']
{
L4723: (k[i]=,w) (blackVols[i]/,r) (t[i],r) 
}
array table
-----------------------------------------------
k -> [('[i]', 'w', 'normalized', ['i'], 4723)]
LDEs formed:1

t -> [('[i]', 'r', 'normalized', ['i'], 4723)]
LDEs formed:0

blackVols -> [('[i]', 'r', 'normalized', ['i'], 4723)]
LDEs formed:0

distinct LDEs:
i1=i2
#########################################################################################
loop info: Size i=0  i<times_.size()   i++
induction variable: ['i']
{
L4724: (times_[i],r) (blackVols_[i],r) 
L4725: (weights_[i],r) 
}
array table
-----------------------------------------------
blackVols_ -> [('[i]', 'r', 'normalized', ['i'], 4724)]
LDEs formed:0

weights_ -> [('[i]', 'r', 'normalized', ['i'], 4725)]
LDEs formed:0

times_ -> [('[i]', 'r', 'normalized', ['i'], 4724)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<times_.size()   i++
induction variable: ['i']
{
L4725: (times_[i],r) (blackVols_[i],r) 
}
array table
-----------------------------------------------
blackVols_ -> [('[i]', 'r', 'normalized', ['i'], 4725)]
LDEs formed:0

times_ -> [('[i]', 'r', 'normalized', ['i'], 4725)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<times_.size()   i++
induction variable: ['i']
{
L4726: (results[i]=,w) (times_[i],r) (blackVols_[i],r) (weights_[i],r) 
}
array table
-----------------------------------------------
blackVols_ -> [('[i]', 'r', 'normalized', ['i'], 4726)]
LDEs formed:0

results -> [('[i]', 'w', 'normalized', ['i'], 4726)]
LDEs formed:1

weights_ -> [('[i]', 'r', 'normalized', ['i'], 4726)]
LDEs formed:0

times_ -> [('[i]', 'r', 'normalized', ['i'], 4726)]
LDEs formed:0

distinct LDEs:
i1=i2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/termstructures/volatility/equityfx/blackvariancecurve.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: j=1  j<=blackVolCurve.size()  j++
induction variable: ['j']
{
L4727: (times_[j]=,w) (dates[j-1],r) 
L4728: (times_[j],r) (times_[j-1],r) 
L4729: (variances_[j]=,w) (times_[j]*,r) 
L4730: (blackVolCurve[j-1]*,r) (blackVolCurve[j-1],r) 
L4731: (variances_[j],r) (variances_[j-1],r) 
}
array table
-----------------------------------------------
blackVolCurve -> [('[j-1]', 'r', 'normalized', ['j'], 4730), ('[j-1]', 'r', 'normalized', ['j'], 4730)]
LDEs formed:0

dates -> [('[j-1]', 'r', 'normalized', ['j'], 4727)]
LDEs formed:0

variances_ -> [('[j]', 'w', 'normalized', ['j'], 4729), ('[j]', 'r', 'normalized', ['j'], 4731), ('[j-1]', 'r', 'normalized', ['j'], 4731)]
LDEs formed:3

times_ -> [('[j]', 'w', 'normalized', ['j'], 4727), ('[j]', 'r', 'normalized', ['j'], 4728), ('[j-1]', 'r', 'normalized', ['j'], 4728), ('[j]', 'r', 'normalized', ['j'], 4729)]
LDEs formed:4

distinct LDEs:
j1=j2
j1=j2-1
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/termstructures/volatility/equityfx/blackvariancesurface.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: i=0  i<blackVolMatrix.rows()  i++
induction variable: ['i']
{
L4730: (variances_[i][0]=,w) 
}
array table
-----------------------------------------------
variances_ -> [('[i][0]', 'w', 'normalized', ['i'], 4730)]
LDEs formed:2

distinct LDEs:
i1=i2,0=0
#########################################################################################
loop info: j=1  j<=blackVolMatrix.columns()  j++
induction variable: ['j']
{
L4731: (times_[j]=,w) (dates[j-1],r) 
L4732: (times_[j],r) (times_[j-1],r) 
	loop info: i=0  i<blackVolMatrix.rows()  i++
	induction variable: ['j', 'i']
	{
	L4733: (variances_[i][j]=,w) (times_[j]*,r) 
	L4734: (blackVolMatrix[i][j-1]*,r) (blackVolMatrix[i][j-1],r) 
	}
 }
array table
-----------------------------------------------
blackVolMatrix -> [('[i][j-1]', 'r', 'normalized', ['j', 'i'], 4734), ('[i][j-1]', 'r', 'normalized', ['j', 'i'], 4734)]
LDEs formed:0

dates -> [('[j-1]', 'r', 'normalized', ['j', 'i'], 4731)]
LDEs formed:0

variances_ -> [('[i][j]', 'w', 'normalized', ['j', 'i'], 4733)]
LDEs formed:2

times_ -> [('[j]', 'w', 'normalized', ['j', 'i'], 4731), ('[j]', 'r', 'normalized', ['j', 'i'], 4732), ('[j-1]', 'r', 'normalized', ['j', 'i'], 4732), ('[j]', 'r', 'normalized', ['j', 'i'], 4733)]
LDEs formed:4

distinct LDEs:
j1=j2
i1=i2,j1=j2
j1=j2-1
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/termstructures/volatility/capfloor/capfloortermvolsurface.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<nOptionTenors_  ++i
induction variable: ['i']
{
L4734: (volHandles_[i].resize,r) 
	loop info: Size j=0  j<nStrikes_  ++j
	induction variable: ['i', 'j']
	{
	}
 }
array table
-----------------------------------------------
volHandles_ -> [('[i]', 'r', 'normalized', ['i', 'j'], 4734)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<nOptionTenors_  ++i
induction variable: ['i']
{
L4735: (volHandles_[i].resize,r) 
	loop info: Size j=0  j<nStrikes_  ++j
	induction variable: ['i', 'j']
	{
	}
 }
array table
-----------------------------------------------
volHandles_ -> [('[i]', 'r', 'normalized', ['i', 'j'], 4735)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<nOptionTenors_  ++i
induction variable: ['i']
{
L4736: (optionDates_[i]=,w) (optionTenors_[i],r) 
L4737: (optionTimes_[i]=,w) (optionDates_[i],r) 
}
array table
-----------------------------------------------
optionTenors_ -> [('[i]', 'r', 'normalized', ['i'], 4736)]
LDEs formed:0

optionDates_ -> [('[i]', 'w', 'normalized', ['i'], 4736), ('[i]', 'r', 'normalized', ['i'], 4737)]
LDEs formed:2

optionTimes_ -> [('[i]', 'w', 'normalized', ['i'], 4737)]
LDEs formed:1

distinct LDEs:
i1=i2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/termstructures/volatility/capfloor/capfloortermvolcurve.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<nOptionTenors_  ++i
induction variable: ['i']
{
L4738: (optionDates_[i]=,w) (optionTenors_[i],r) 
L4739: (optionTimes_[i]=,w) (optionDates_[i],r) 
}
array table
-----------------------------------------------
optionTenors_ -> [('[i]', 'r', 'normalized', ['i'], 4738)]
LDEs formed:0

optionDates_ -> [('[i]', 'w', 'normalized', ['i'], 4738), ('[i]', 'r', 'normalized', ['i'], 4739)]
LDEs formed:2

optionTimes_ -> [('[i]', 'w', 'normalized', ['i'], 4739)]
LDEs formed:1

distinct LDEs:
i1=i2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/termstructures/volatility/optionlet/strippedoptionletadapter.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0 i<optionletStrikes.size() i++
induction variable: ['i']
{
L4740: (optionletStrikes[i],r) 
}
array table
-----------------------------------------------
optionletStrikes -> [('[i]', 'r', 'normalized', ['i'], 4740)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<nInterpolations_  ++i
induction variable: ['i']
{
L4741: (strikeInterpolations_[i]=,w) 
L4742: (optionletTimes[i],r) (atmForward[i],r) 
L4743: (isParameterFixed_[0],r) 
L4744: (isParameterFixed_[1],r) 
L4745: (isParameterFixed_[2],r) 
L4746: (isParameterFixed_[3],r) 
L4747: (strikeInterpolations_[i]=,w) 
L4748: (strikeInterpolations_[i]-,r) 
L4749: (optionletTimes[i]<<,r) 
L4750: (strikeInterpolations_[i]-,r) 
L4751: (strikeInterpolations_[i]-,r) 
L4752: (strikeInterpolations_[i]-,r) 
L4753: (strikeInterpolations_[i]-,r) 
L4754: (strikeInterpolations_[i]-,r) 
}
array table
-----------------------------------------------
optionletTimes -> [('[i]', 'r', 'normalized', ['i'], 4742), ('[i]', 'r', 'normalized', ['i'], 4749)]
LDEs formed:0

strikeInterpolations_ -> [('[i]', 'w', 'normalized', ['i'], 4741), ('[i]', 'w', 'normalized', ['i'], 4747), ('[i]', 'r', 'normalized', ['i'], 4748), ('[i]', 'r', 'normalized', ['i'], 4750), ('[i]', 'r', 'normalized', ['i'], 4751), ('[i]', 'r', 'normalized', ['i'], 4752), ('[i]', 'r', 'normalized', ['i'], 4753), ('[i]', 'r', 'normalized', ['i'], 4754)]
LDEs formed:15

atmForward -> [('[i]', 'r', 'normalized', ['i'], 4742)]
LDEs formed:0

isParameterFixed_ -> [('[0]', 'r', 'normalized', ['i'], 4743), ('[1]', 'r', 'normalized', ['i'], 4744), ('[2]', 'r', 'normalized', ['i'], 4745), ('[3]', 'r', 'normalized', ['i'], 4746)]
LDEs formed:0

distinct LDEs:
i1=i2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/termstructures/volatility/optionlet/optionletstripper1.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<nOptionletTenors_  ++i
induction variable: ['i']
{
L4747: (capFloorLengths_[i],r) 
L4748: (optionletDates_[i]=,w) 
L4749: (optionletPaymentDates_[i]=,w) 
L4750: (optionletAccrualPeriods_[i]=,w) 
L4751: (optionletTimes_[i]=,w) 
L4752: (optionletDates_[i],r) 
L4753: (atmOptionletRate_[i]=,w) 
}
array table
-----------------------------------------------
optionletAccrualPeriods_ -> [('[i]', 'w', 'normalized', ['i'], 4750)]
LDEs formed:1

capFloorLengths_ -> [('[i]', 'r', 'normalized', ['i'], 4747)]
LDEs formed:0

optionletPaymentDates_ -> [('[i]', 'w', 'normalized', ['i'], 4749)]
LDEs formed:1

atmOptionletRate_ -> [('[i]', 'w', 'normalized', ['i'], 4753)]
LDEs formed:1

optionletDates_ -> [('[i]', 'w', 'normalized', ['i'], 4748), ('[i]', 'r', 'normalized', ['i'], 4752)]
LDEs formed:2

optionletTimes_ -> [('[i]', 'w', 'normalized', ['i'], 4751)]
LDEs formed:1

distinct LDEs:
i1=i2
#########################################################################################
loop info: Size i=0  i<nOptionletTenors_  ++i
induction variable: ['i']
{
L4752: (atmOptionletRate_[i],r) 
}
array table
-----------------------------------------------
atmOptionletRate_ -> [('[i]', 'r', 'normalized', ['i'], 4752)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size j=0  j<nStrikes_  ++j
induction variable: ['j']
{
L4753: (strikes[j],r) 
	loop info: Size i=0  i<nOptionletTenors_  ++i
	induction variable: ['j', 'i']
	{
	L4754: (volQuotes_[i][j]=,w) 
	L4755: (volQuotes_[i][j],r) 
	L4756: (capFloors_[i][j]=,w) 
	L4757: (capFloorLengths_[i],r) 
	L4758: (strikes[j],r) 
	L4759: (volQuotes_[i][j],r) 
	L4760: (capFloors_[i][j]=,w) 
	L4761: (capFloorLengths_[i],r) 
	L4762: (strikes[j],r) 
	}
 }
array table
-----------------------------------------------
capFloors_ -> [('[i][j]', 'w', 'normalized', ['j', 'i'], 4756), ('[i][j]', 'w', 'normalized', ['j', 'i'], 4760)]
LDEs formed:6

capFloorLengths_ -> [('[i]', 'r', 'normalized', ['j', 'i'], 4757), ('[i]', 'r', 'normalized', ['j', 'i'], 4761)]
LDEs formed:0

volQuotes_ -> [('[i][j]', 'w', 'normalized', ['j', 'i'], 4754), ('[i][j]', 'r', 'normalized', ['j', 'i'], 4755), ('[i][j]', 'r', 'normalized', ['j', 'i'], 4759)]
LDEs formed:6

strikes -> [('[j]', 'r', 'normalized', ['j', 'i'], 4753), ('[j]', 'r', 'normalized', ['j', 'i'], 4758), ('[j]', 'r', 'normalized', ['j', 'i'], 4762)]
LDEs formed:0

distinct LDEs:
i1=i2,j1=j2
#########################################################################################
loop info: Size j=0  j<nStrikes_  ++j
induction variable: ['j']
{
L4763: (strikes[j],r) 
	loop info: Size i=0  i<nOptionletTenors_  ++i
	induction variable: ['j', 'i']
	{
	L4764: (capFloorVols_[i][j]=,w) 
	L4765: (capFloorLengths_[i],r) (strikes[j],r) 
	L4766: (volQuotes_[i][j]-,r) (capFloorVols_[i][j],r) 
	L4767: (capFloorPrices_[i][j]=,w) (capFloors_[i][j]-,r) 
	L4768: (optionletPrices_[i][j]=,w) (capFloorPrices_[i][j]-,r) 
	L4769: (capFloorPrices_[i][j],r) 
	L4770: (optionletPaymentDates_[i],r) 
	L4771: (optionletAccrualPeriods_[i]*,r) 
	L4772: (optionletStDevs_[i][j]=,w) 
	L4773: (strikes[j],r) (atmOptionletRate_[i],r) 
	L4774: (optionletPrices_[i][j],r) 
	L4775: (optionletStDevs_[i][j],r) 
	L4776: (optionletStDevs_[i][j]=,w) 
	L4777: (optionletTimes_[i],r) 
	L4778: (strikes[j],r) (atmOptionletRate_[i],r) 
	L4779: (optionletTimes_[i],r) (optionletPrices_[i][j],r) 
	L4780: (optionletStDevs_[i][j]=,w) 
	L4781: (strikes[j],r) 
	L4782: (atmOptionletRate_[i],r) 
	L4783: (optionletPrices_[i][j]<<,r) 
	L4784: (optionletDates_[i]<<,r) 
	L4785: (optionletVolatilities_[i][j]=,w) (optionletStDevs_[i][j]/,r) 
	L4786: (optionletTimes_[i],r) 
	}
 }
array table
-----------------------------------------------
optionletDates_ -> [('[i]', 'r', 'normalized', ['j', 'i'], 4784)]
LDEs formed:0

capFloorPrices_ -> [('[i][j]', 'w', 'normalized', ['j', 'i'], 4767), ('[i][j]', 'r', 'normalized', ['j', 'i'], 4768), ('[i][j]', 'r', 'normalized', ['j', 'i'], 4769)]
LDEs formed:6

capFloorVols_ -> [('[i][j]', 'w', 'normalized', ['j', 'i'], 4764), ('[i][j]', 'r', 'normalized', ['j', 'i'], 4766)]
LDEs formed:4

strikes -> [('[j]', 'r', 'normalized', ['j', 'i'], 4763), ('[j]', 'r', 'normalized', ['j', 'i'], 4765), ('[j]', 'r', 'normalized', ['j', 'i'], 4773), ('[j]', 'r', 'normalized', ['j', 'i'], 4778), ('[j]', 'r', 'normalized', ['j', 'i'], 4781)]
LDEs formed:0

optionletAccrualPeriods_ -> [('[i]', 'r', 'normalized', ['j', 'i'], 4771)]
LDEs formed:0

capFloors_ -> [('[i][j]', 'r', 'normalized', ['j', 'i'], 4767)]
LDEs formed:0

capFloorLengths_ -> [('[i]', 'r', 'normalized', ['j', 'i'], 4765)]
LDEs formed:0

optionletStDevs_ -> [('[i][j]', 'w', 'normalized', ['j', 'i'], 4772), ('[i][j]', 'r', 'normalized', ['j', 'i'], 4775), ('[i][j]', 'w', 'normalized', ['j', 'i'], 4776), ('[i][j]', 'w', 'normalized', ['j', 'i'], 4780), ('[i][j]', 'r', 'normalized', ['j', 'i'], 4785)]
LDEs formed:24

optionletPaymentDates_ -> [('[i]', 'r', 'normalized', ['j', 'i'], 4770)]
LDEs formed:0

atmOptionletRate_ -> [('[i]', 'r', 'normalized', ['j', 'i'], 4773), ('[i]', 'r', 'normalized', ['j', 'i'], 4778), ('[i]', 'r', 'normalized', ['j', 'i'], 4782)]
LDEs formed:0

optionletPrices_ -> [('[i][j]', 'w', 'normalized', ['j', 'i'], 4768), ('[i][j]', 'r', 'normalized', ['j', 'i'], 4774), ('[i][j]', 'r', 'normalized', ['j', 'i'], 4779), ('[i][j]', 'r', 'normalized', ['j', 'i'], 4783)]
LDEs formed:8

optionletTimes_ -> [('[i]', 'r', 'normalized', ['j', 'i'], 4777), ('[i]', 'r', 'normalized', ['j', 'i'], 4779), ('[i]', 'r', 'normalized', ['j', 'i'], 4786)]
LDEs formed:0

volQuotes_ -> [('[i][j]', 'r', 'normalized', ['j', 'i'], 4766)]
LDEs formed:0

optionletVolatilities_ -> [('[i][j]', 'w', 'normalized', ['j', 'i'], 4785)]
LDEs formed:2

distinct LDEs:
i1=i2,j1=j2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/termstructures/volatility/optionlet/strippedoptionlet.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/termstructures/volatility/optionlet/optionletstripper2.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<optionletTimes_.size()  ++i
induction variable: ['i']
{
L4786: (optionletStrikes_[i]=,w) 
L4787: (optionletVolatilities_[i]=,w) 
}
array table
-----------------------------------------------
optionletVolatilities_ -> [('[i]', 'w', 'normalized', ['i'], 4787)]
LDEs formed:1

optionletStrikes_ -> [('[i]', 'w', 'normalized', ['i'], 4786)]
LDEs formed:1

distinct LDEs:
i1=i2
#########################################################################################
loop info: Size j=0  j<nOptionExpiries_  ++j
induction variable: ['j']
{
L4787: (optionExpiriesTimes[j],r) 
L4788: (caps_[j]=,w) 
L4789: (optionExpiriesTenors[j],r) 
L4790: (atmCapFloorStrikes_[j]=,w) 
L4791: (caps_[j]-,r) 
L4792: (atmCapFloorPrices_[j]=,w) (caps_[j]-,r) 
}
array table
-----------------------------------------------
atmCapFloorStrikes_ -> [('[j]', 'w', 'normalized', ['j'], 4790)]
LDEs formed:1

optionExpiriesTimes -> [('[j]', 'r', 'normalized', ['j'], 4787)]
LDEs formed:0

atmCapFloorPrices_ -> [('[j]', 'w', 'normalized', ['j'], 4792)]
LDEs formed:1

optionExpiriesTenors -> [('[j]', 'r', 'normalized', ['j'], 4789)]
LDEs formed:0

caps_ -> [('[j]', 'w', 'normalized', ['j'], 4788), ('[j]', 'r', 'normalized', ['j'], 4791), ('[j]', 'r', 'normalized', ['j'], 4792)]
LDEs formed:3

distinct LDEs:
j1=j2
#########################################################################################
loop info: Size j=0  j<nOptionExpiries_  ++j
induction variable: ['j']
{
	loop info: Size i=0  i<optionletVolatilities_.size()  ++i
	induction variable: ['j', 'i']
	{
	L4793: (caps_[j]-,r) 
	L4794: (optionletTimes_[i],r) 
	L4795: (atmCapFloorStrikes_[j],r) 
	L4796: (spreadsVolImplied_[j],r) 
	L4797: (optionletStrikes_[i].begin,r) 
	L4798: (optionletStrikes_[i].end,r) 
	L4799: (atmCapFloorStrikes_[j],r) 
	L4800: (optionletStrikes_[i].begin,r) 
	L4801: (optionletStrikes_[i].insert,r) 
	L4802: (optionletStrikes_[i].begin,r) 
	L4803: (atmCapFloorStrikes_[j],r) 
	L4804: (optionletVolatilities_[i].insert,r) 
	L4805: (optionletVolatilities_[i].begin,r) 
	}
 }
array table
-----------------------------------------------
atmCapFloorStrikes_ -> [('[j]', 'r', 'normalized', ['j', 'i'], 4795), ('[j]', 'r', 'normalized', ['j', 'i'], 4799), ('[j]', 'r', 'normalized', ['j', 'i'], 4803)]
LDEs formed:0

caps_ -> [('[j]', 'r', 'normalized', ['j', 'i'], 4793)]
LDEs formed:0

spreadsVolImplied_ -> [('[j]', 'r', 'normalized', ['j', 'i'], 4796)]
LDEs formed:0

optionletVolatilities_ -> [('[i]', 'r', 'normalized', ['j', 'i'], 4804), ('[i]', 'r', 'normalized', ['j', 'i'], 4805)]
LDEs formed:0

optionletStrikes_ -> [('[i]', 'r', 'normalized', ['j', 'i'], 4797), ('[i]', 'r', 'normalized', ['j', 'i'], 4798), ('[i]', 'r', 'normalized', ['j', 'i'], 4800), ('[i]', 'r', 'normalized', ['j', 'i'], 4801), ('[i]', 'r', 'normalized', ['j', 'i'], 4802)]
LDEs formed:0

optionletTimes_ -> [('[i]', 'r', 'normalized', ['j', 'i'], 4794)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size j=0  j<nOptionExpiries_  ++j
induction variable: ['j']
{
L4795: (caps_[j],r) (atmCapFloorPrices_[j],r) 
L4796: (result[j]=,w) 
}
array table
-----------------------------------------------
atmCapFloorPrices_ -> [('[j]', 'r', 'normalized', ['j'], 4795)]
LDEs formed:0

caps_ -> [('[j]', 'r', 'normalized', ['j'], 4795)]
LDEs formed:0

result -> [('[j]', 'w', 'normalized', ['j'], 4796)]
LDEs formed:1

distinct LDEs:
j1=j2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/termstructures/volatility/swaption/swaptionvolcube.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/termstructures/volatility/swaption/cmsmarketcalibration.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

L4797: (swapTenors[i],r) 
}
array table
-----------------------------------------------
swapTenors -> [('[i]', 'r', 'normalized', ['i', 'j'], 4797)]
LDEs formed:0

distinct LDEs:
#########################################################################################
L4798: (swapTenors[i],r) 
}
array table
-----------------------------------------------
swapTenors -> [('[i]', 'r', 'normalized', ['i', 'j'], 4798)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i = 0  i < nSwapTenors  ++i
induction variable: ['i']
{
L4799: (x[0 + 3 * i],r) 
L4800: (x[1 + 3 * i],r) 
L4801: (x[2 + 3 * i]*,r) (x[2 + 3 * i],r) 
	loop info: Size j = 0  j < beta.size()  ++j
	induction variable: ['i', 'j']
	{
	L4802: (swapLengths[j],r) 
	L4803: (beta[j]=,w) 
	}
L4804: (swapTenors[i],r) 
}
array table
-----------------------------------------------
x -> [('[0 + 3 * i]', 'r', 'normalized', ['i', 'j'], 4799), ('[1 + 3 * i]', 'r', 'normalized', ['i', 'j'], 4800), ('[2 + 3 * i]', 'r', 'normalized', ['i', 'j'], 4801), ('[2 + 3 * i]', 'r', 'normalized', ['i', 'j'], 4801)]
LDEs formed:0

beta -> [('[j]', 'w', 'normalized', ['i', 'j'], 4803)]
LDEs formed:1

swapLengths -> [('[j]', 'r', 'normalized', ['i', 'j'], 4802)]
LDEs formed:0

swapTenors -> [('[i]', 'r', 'normalized', ['i', 'j'], 4804)]
LDEs formed:0

distinct LDEs:
j1=j2
#########################################################################################
loop info: Size i = 0  i < nSwapTenors  ++i
induction variable: ['i']
{
L4805: (x[0 + 3 * i],r) 
L4806: (x[1 + 3 * i],r) 
L4807: (x[2 + 3 * i]*,r) (x[2 + 3 * i],r) 
	loop info: Size j = 0  j < beta.size()  ++j
	induction variable: ['i', 'j']
	{
	L4808: (swapLengths[j],r) 
	L4809: (beta[j]=,w) 
	}
L4810: (swapTenors[i],r) 
}
array table
-----------------------------------------------
x -> [('[0 + 3 * i]', 'r', 'normalized', ['i', 'j'], 4805), ('[1 + 3 * i]', 'r', 'normalized', ['i', 'j'], 4806), ('[2 + 3 * i]', 'r', 'normalized', ['i', 'j'], 4807), ('[2 + 3 * i]', 'r', 'normalized', ['i', 'j'], 4807)]
LDEs formed:0

beta -> [('[j]', 'w', 'normalized', ['i', 'j'], 4809)]
LDEs formed:1

swapLengths -> [('[j]', 'r', 'normalized', ['i', 'j'], 4808)]
LDEs formed:0

swapTenors -> [('[i]', 'r', 'normalized', ['i', 'j'], 4810)]
LDEs formed:0

distinct LDEs:
j1=j2
#########################################################################################
loop info: Size i = 0  i < nSwapTenors  ++i
induction variable: ['i']
{
	loop info: Size j = 0  j < nSwapLengths  ++j
	induction variable: ['i', 'j']
	{
	L4811: (betasGuess[i * nSwapLengths + j]=,w) 
	L4812: (guess[j][i],r) 
	}
 }
array table
-----------------------------------------------
betasGuess -> [('[i * nSwapLengths + j]', 'w', 'not normalized', ['i', 'j'], 4811)]
LDEs formed:1

guess -> [('[j][i]', 'r', 'normalized', ['i', 'j'], 4812)]
LDEs formed:0

distinct LDEs:
i1 * nSwapLengths + j1=i2 * nSwapLengths + j2
#########################################################################################
loop info: Size i = 0  i < nSwapTenors  ++i
induction variable: ['i']
{
	loop info: Size j = 0  j < nSwapLengths  ++j
	induction variable: ['i', 'j']
	{
	L4813: (result[j][i]=,w) 
	L4814: (tmp[i * nSwapLengths + j],r) 
	}
 }
array table
-----------------------------------------------
tmp -> [('[i * nSwapLengths + j]', 'r', 'not normalized', ['i', 'j'], 4814)]
LDEs formed:0

result -> [('[j][i]', 'w', 'normalized', ['i', 'j'], 4813)]
LDEs formed:2

distinct LDEs:
j1=j2,i1=i2
#########################################################################################
loop info: Size j = 0  j < nSwapLengths  ++j
induction variable: ['j']
{
L4814: (result[j][nSwapTenors]=,w) 
}
array table
-----------------------------------------------
result -> [('[j][nSwapTenors]', 'w', 'not normalized', ['j'], 4814)]
LDEs formed:2

distinct LDEs:
j1=j2,nSwapTenors=nSwapTenors
#########################################################################################
loop info: Size i = 0  i < nSwapTenors  ++i
induction variable: ['i']
{
	loop info: Size j = 0  j < nSwapLengths  ++j
	induction variable: ['i', 'j']
	{
	L4815: (betasReversionGuess[i * nSwapLengths + j]=,w) 
	L4816: (guess[j][i],r) 
	}
 }
array table
-----------------------------------------------
betasReversionGuess -> [('[i * nSwapLengths + j]', 'w', 'not normalized', ['i', 'j'], 4815)]
LDEs formed:1

guess -> [('[j][i]', 'r', 'normalized', ['i', 'j'], 4816)]
LDEs formed:0

distinct LDEs:
i1 * nSwapLengths + j1=i2 * nSwapLengths + j2
#########################################################################################
loop info: Size i = 0  i < nSwapTenors  ++i
induction variable: ['i']
{
	loop info: Size j = 0  j < nSwapLengths  ++j
	induction variable: ['i', 'j']
	{
	L4817: (result[j][i]=,w) 
	L4818: (tmp[i * nSwapLengths + j],r) 
	}
 }
array table
-----------------------------------------------
tmp -> [('[i * nSwapLengths + j]', 'r', 'not normalized', ['i', 'j'], 4818)]
LDEs formed:0

result -> [('[j][i]', 'w', 'normalized', ['i', 'j'], 4817)]
LDEs formed:2

distinct LDEs:
j1=j2,i1=i2
#########################################################################################
loop info: Size j = 0  j < nSwapLengths  ++j
induction variable: ['j']
{
L4818: (result[j][nSwapTenors]=,w) (tmp[nBeta],r) 
}
array table
-----------------------------------------------
tmp -> [('[nBeta]', 'r', 'not normalized', ['j'], 4818)]
LDEs formed:0

result -> [('[j][nSwapTenors]', 'w', 'not normalized', ['j'], 4818)]
LDEs formed:2

distinct LDEs:
j1=j2,nSwapTenors=nSwapTenors
#########################################################################################
loop info: Size i = 0  i < nSwapTenors  ++i
induction variable: ['i']
{
	loop info: Size j = 0  j < nParams  ++j
	induction variable: ['i', 'j']
	{
	L4819: (betasGuess[i * 3 + j]=,w) 
	L4820: (guess[j][i],r) 
	L4821: (guess[j][i],r) 
	}
 }
array table
-----------------------------------------------
betasGuess -> [('[i * 3 + j]', 'w', 'normalized', ['i', 'j'], 4819)]
LDEs formed:1

guess -> [('[j][i]', 'r', 'normalized', ['i', 'j'], 4820), ('[j][i]', 'r', 'normalized', ['i', 'j'], 4821)]
LDEs formed:0

distinct LDEs:
i1 * 3 + j1=i2 * 3 + j2
#########################################################################################
loop info: Size i = 0  i < nSwapTenors  ++i
induction variable: ['i']
{
	loop info: Size j = 0  j < 3  ++j
	induction variable: ['i', 'j']
	{
	L4822: (result[j][i]=,w) 
	L4823: (tmp[i * 3 + j],r) 
	L4824: (tmp[i * 3 + j]*,r) (tmp[i * 3 + j],r) 
	}
 }
array table
-----------------------------------------------
tmp -> [('[i * 3 + j]', 'r', 'normalized', ['i', 'j'], 4823), ('[i * 3 + j]', 'r', 'normalized', ['i', 'j'], 4824), ('[i * 3 + j]', 'r', 'normalized', ['i', 'j'], 4824)]
LDEs formed:0

result -> [('[j][i]', 'w', 'normalized', ['i', 'j'], 4822)]
LDEs formed:2

distinct LDEs:
j1=j2,i1=i2
#########################################################################################
loop info: Size j = 0  j < nSwapLengths  ++j
induction variable: ['j']
{
L4823: (result[j][nSwapTenors]=,w) 
}
array table
-----------------------------------------------
result -> [('[j][nSwapTenors]', 'w', 'not normalized', ['j'], 4823)]
LDEs formed:2

distinct LDEs:
j1=j2,nSwapTenors=nSwapTenors
#########################################################################################
loop info: Size i = 0  i < nSwapTenors  ++i
induction variable: ['i']
{
	loop info: Size j = 0  j < nParams  ++j
	induction variable: ['i', 'j']
	{
	L4824: (betasReversionGuess[i * nSwapLengths + j]=,w) 
	L4825: (guess[j][i],r) 
	L4826: (guess[j][i],r) 
	}
 }
array table
-----------------------------------------------
betasReversionGuess -> [('[i * nSwapLengths + j]', 'w', 'not normalized', ['i', 'j'], 4824)]
LDEs formed:1

guess -> [('[j][i]', 'r', 'normalized', ['i', 'j'], 4825), ('[j][i]', 'r', 'normalized', ['i', 'j'], 4826)]
LDEs formed:0

distinct LDEs:
i1 * nSwapLengths + j1=i2 * nSwapLengths + j2
#########################################################################################
loop info: Size i = 0  i < nSwapTenors  ++i
induction variable: ['i']
{
	loop info: Size j = 0  j < 3  ++j
	induction variable: ['i', 'j']
	{
	L4827: (result[j][i]=,w) 
	L4828: (tmp[i * nSwapLengths + j],r) 
	L4829: (tmp[i * 3 + j]*,r) (tmp[i * 3 + j],r) 
	}
 }
array table
-----------------------------------------------
tmp -> [('[i * nSwapLengths + j]', 'r', 'not normalized', ['i', 'j'], 4828), ('[i * 3 + j]', 'r', 'normalized', ['i', 'j'], 4829), ('[i * 3 + j]', 'r', 'normalized', ['i', 'j'], 4829)]
LDEs formed:0

result -> [('[j][i]', 'w', 'normalized', ['i', 'j'], 4827)]
LDEs formed:2

distinct LDEs:
j1=j2,i1=i2
#########################################################################################
loop info: Size j = 0  j < nSwapLengths  ++j
induction variable: ['j']
{
L4828: (result[j][nSwapTenors]=,w) (tmp[nParams],r) 
}
array table
-----------------------------------------------
tmp -> [('[nParams]', 'r', 'not normalized', ['j'], 4828)]
LDEs formed:0

result -> [('[j][nSwapTenors]', 'w', 'not normalized', ['j'], 4828)]
LDEs formed:2

distinct LDEs:
j1=j2,nSwapTenors=nSwapTenors
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/termstructures/volatility/swaption/swaptionvolmatrix.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<vols.rows()  ++i
induction variable: ['i']
{
L4829: (volHandles_[i].resize,r) 
L4830: (shiftValues_[i].resize,r) 
	loop info: Size j=0  j<vols.columns()  ++j
	induction variable: ['i', 'j']
	{
	L4831: (volHandles_[i][j]=,w) 
	L4832: (vols[i][j],r) 
	L4833: (shiftValues_[i][j]=,w) (shifts[i][j],r) 
	}
 }
array table
-----------------------------------------------
volHandles_ -> [('[i]', 'r', 'normalized', ['i', 'j'], 4829), ('[i][j]', 'w', 'normalized', ['i', 'j'], 4831)]
LDEs formed:4

shiftValues_ -> [('[i]', 'r', 'normalized', ['i', 'j'], 4830), ('[i][j]', 'w', 'normalized', ['i', 'j'], 4833)]
LDEs formed:4

vols -> [('[i][j]', 'r', 'normalized', ['i', 'j'], 4832)]
LDEs formed:0

shifts -> [('[i][j]', 'r', 'normalized', ['i', 'j'], 4833)]
LDEs formed:0

distinct LDEs:
i1=i2,j1=j2
i1=i2
#########################################################################################
loop info: Size i=0  i<vols.rows()  ++i
induction variable: ['i']
{
L4834: (volHandles_[i].resize,r) 
L4835: (shiftValues_[i].resize,r) 
	loop info: Size j=0  j<vols.columns()  ++j
	induction variable: ['i', 'j']
	{
	L4836: (volHandles_[i][j]=,w) 
	L4837: (vols[i][j],r) 
	L4838: (shiftValues_[i][j]=,w) (shifts[i][j],r) 
	}
 }
array table
-----------------------------------------------
volHandles_ -> [('[i]', 'r', 'normalized', ['i', 'j'], 4834), ('[i][j]', 'w', 'normalized', ['i', 'j'], 4836)]
LDEs formed:4

shiftValues_ -> [('[i]', 'r', 'normalized', ['i', 'j'], 4835), ('[i][j]', 'w', 'normalized', ['i', 'j'], 4838)]
LDEs formed:4

vols -> [('[i][j]', 'r', 'normalized', ['i', 'j'], 4837)]
LDEs formed:0

shifts -> [('[i][j]', 'r', 'normalized', ['i', 'j'], 4838)]
LDEs formed:0

distinct LDEs:
i1=i2,j1=j2
i1=i2
#########################################################################################
loop info: Size i=0  i<vols.rows()  ++i
induction variable: ['i']
{
L4839: (volHandles_[i].resize,r) 
L4840: (shiftValues_[i].resize,r) 
	loop info: Size j=0  j<vols.columns()  ++j
	induction variable: ['i', 'j']
	{
	L4841: (volHandles_[i][j]=,w) 
	L4842: (vols[i][j],r) 
	L4843: (shiftValues_[i][j]=,w) (shifts[i][j],r) 
	}
 }
array table
-----------------------------------------------
volHandles_ -> [('[i]', 'r', 'normalized', ['i', 'j'], 4839), ('[i][j]', 'w', 'normalized', ['i', 'j'], 4841)]
LDEs formed:4

shiftValues_ -> [('[i]', 'r', 'normalized', ['i', 'j'], 4840), ('[i][j]', 'w', 'normalized', ['i', 'j'], 4843)]
LDEs formed:4

vols -> [('[i][j]', 'r', 'normalized', ['i', 'j'], 4842)]
LDEs formed:0

shifts -> [('[i][j]', 'r', 'normalized', ['i', 'j'], 4843)]
LDEs formed:0

distinct LDEs:
i1=i2,j1=j2
i1=i2
#########################################################################################
loop info: Size i=0  i<volatilities_.rows()  ++i
induction variable: ['i']
{
	loop info: Size j=0  j<volatilities_.columns()  ++j
	induction variable: ['i', 'j']
	{
	L4844: (volatilities_[i][j]=,w) (volHandles_[i][j]-,r) 
	L4845: (shifts_[i][j]=,w) (shiftValues_[i][j],r) 
	}
 }
array table
-----------------------------------------------
volHandles_ -> [('[i][j]', 'r', 'normalized', ['i', 'j'], 4844)]
LDEs formed:0

shiftValues_ -> [('[i][j]', 'r', 'normalized', ['i', 'j'], 4845)]
LDEs formed:0

volatilities_ -> [('[i][j]', 'w', 'normalized', ['i', 'j'], 4844)]
LDEs formed:2

shifts_ -> [('[i][j]', 'w', 'normalized', ['i', 'j'], 4845)]
LDEs formed:2

distinct LDEs:
i1=i2,j1=j2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/termstructures/volatility/swaption/swaptionvolcube2.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<nStrikes_  i++
induction variable: ['i']
{
L4846: (volSpreadsMatrix_[i][j][k]=,w) 
L4847: (volSpreads_[j*nSwapTenors_+k][i]-,r) 
}
array table
-----------------------------------------------
volSpreadsMatrix_ -> [('[i][j][k]', 'w', 'not normalized', ['i'], 4846)]
LDEs formed:3

volSpreads_ -> [('[j*nSwapTenors_+k][i]', 'r', 'not normalized', ['i'], 4847)]
LDEs formed:0

distinct LDEs:
i1=i2,j=j,k=k
#########################################################################################
loop info: Size i=0  i<nStrikes_  i++
induction variable: ['i']
{
L4848: (volSpreadsInterpolator_[i]=,w) 
L4849: (volSpreadsMatrix_[i],r) 
L4850: (volSpreadsInterpolator_[i].enableExtrapolation,r) 
}
array table
-----------------------------------------------
volSpreadsMatrix_ -> [('[i]', 'r', 'normalized', ['i'], 4849)]
LDEs formed:0

volSpreadsInterpolator_ -> [('[i]', 'w', 'normalized', ['i'], 4848), ('[i]', 'r', 'normalized', ['i'], 4850)]
LDEs formed:2

distinct LDEs:
i1=i2
#########################################################################################
loop info: Size i=0  i<nStrikes_  ++i
induction variable: ['i']
{
L4851: (strikeSpreads_[i],r) 
L4852: (volSpreadsInterpolator_[i],r) 
}
array table
-----------------------------------------------
volSpreadsInterpolator_ -> [('[i]', 'r', 'normalized', ['i'], 4852)]
LDEs formed:0

strikeSpreads_ -> [('[i]', 'r', 'normalized', ['i'], 4851)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/termstructures/volatility/swaption/swaptionvoldiscrete.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=1  i<nOptionTenors_  ++i
induction variable: ['i']
{
L4852: (optionDates_[i],r) (optionDates_[i-1],r) 
L4853: (optionDates_[i-1]<<,r) 
L4854: (optionDates_[i],r) 
}
array table
-----------------------------------------------
optionDates_ -> [('[i]', 'r', 'normalized', ['i'], 4852), ('[i-1]', 'r', 'normalized', ['i'], 4852), ('[i-1]', 'r', 'normalized', ['i'], 4853), ('[i]', 'r', 'normalized', ['i'], 4854)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<nOptionTenors_  ++i
induction variable: ['i']
{
L4855: (optionDates_[i]=,w) (optionTenors_[i],r) 
L4856: (optionDatesAsReal_[i]=,w) 
L4857: (optionDates_[i].serialNumber,r) 
}
array table
-----------------------------------------------
optionTenors_ -> [('[i]', 'r', 'normalized', ['i'], 4855)]
LDEs formed:0

optionDates_ -> [('[i]', 'w', 'normalized', ['i'], 4855), ('[i]', 'r', 'normalized', ['i'], 4857)]
LDEs formed:2

optionDatesAsReal_ -> [('[i]', 'w', 'normalized', ['i'], 4856)]
LDEs formed:1

distinct LDEs:
i1=i2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/termstructures/volatility/swaption/cmsmarket.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size j=0  j<nSwapIndexes_  ++j
induction variable: ['j']
{
L4857: (swapTenors_[j]=,w) (swapIndexes_[j]-,r) 
L4858: (pricers_[j],r) 
	loop info: Size i=0  i<nExercise_  ++i
	induction variable: ['j', 'i']
	{
	L4859: (bidAskSpreads_[i][j*2],r) 
	L4860: (bidAskSpreads_[i][j*2+1],r) 
	}
 }
array table
-----------------------------------------------
swapTenors_ -> [('[j]', 'w', 'normalized', ['j', 'i'], 4857)]
LDEs formed:1

bidAskSpreads_ -> [('[i][j*2]', 'r', 'normalized', ['j', 'i'], 4859), ('[i][j*2+1]', 'r', 'normalized', ['j', 'i'], 4860)]
LDEs formed:0

pricers_ -> [('[j]', 'r', 'normalized', ['j', 'i'], 4858)]
LDEs formed:0

swapIndexes_ -> [('[j]', 'r', 'normalized', ['j', 'i'], 4857)]
LDEs formed:0

distinct LDEs:
j1=j2
#########################################################################################
loop info: Size i=0  i<nExercise_  ++i
induction variable: ['i']
{
L4858: (swapLengths_[i-1],r) 
	loop info: Size j=0  j<nSwapIndexes_  ++j
	induction variable: ['i', 'j']
	{
	L4859: (spotSwaps_[i][j]=,w) (swapLengths_[i],r) 
	L4860: (swapIndexes_[j],r) 
	L4861: (fwdSwaps_[i][j]=,w) (swapLengths_[i]-,r) 
	L4862: (swapIndexes_[j],r) 
	L4863: (pricers_[j],r) 
	}
 }
array table
-----------------------------------------------
pricers_ -> [('[j]', 'r', 'normalized', ['i', 'j'], 4863)]
LDEs formed:0

swapLengths_ -> [('[i-1]', 'r', 'normalized', ['i', 'j'], 4858), ('[i]', 'r', 'normalized', ['i', 'j'], 4859), ('[i]', 'r', 'normalized', ['i', 'j'], 4861)]
LDEs formed:0

spotSwaps_ -> [('[i][j]', 'w', 'normalized', ['i', 'j'], 4859)]
LDEs formed:2

swapIndexes_ -> [('[j]', 'r', 'normalized', ['i', 'j'], 4860), ('[j]', 'r', 'normalized', ['i', 'j'], 4862)]
LDEs formed:0

fwdSwaps_ -> [('[i][j]', 'w', 'normalized', ['i', 'j'], 4861)]
LDEs formed:2

distinct LDEs:
i1=i2,j1=j2
#########################################################################################
loop info: Size j=0  j<nSwapIndexes_  ++j
induction variable: ['j']
{
	loop info: Size i=0  i<nExercise_  ++i
	induction variable: ['j', 'i']
	{
	L4862: (mktBidSpreads_[i][j]=,w) (bidAskSpreads_[i][j*2]-,r) 
	L4863: (mktAskSpreads_[i][j]=,w) (bidAskSpreads_[i][j*2+1]-,r) 
	L4864: (mktSpreads_[i][j]=,w) (mktBidSpreads_[i][j]+,r) (mktAskSpreads_[i][j],r) 
	L4865: (spotSwaps_[i][j]-,r) 
	L4866: (spotFloatLegNPV_[i][j]=,w) 
	L4867: (spotFloatLegBPS_[i][j]=,w) 
	L4868: (mktSpotCmsLegNPV_[i][j]=,w) (spotFloatLegNPV_[i][j]+,r) 
	L4869: (spotFloatLegBPS_[i][j]*,r) (mktSpreads_[i][j]/,r) 
	L4870: (mktFwdCmsLegNPV_[i][j]=,w) (mktSpotCmsLegNPV_[i][j]-,r) 
	L4871: (mktSpotCmsLegNPV_[i][j],r) 
	L4872: (mdlFwdCmsLegNPV_[i][j]=,w) (fwdSwaps_[i][j]-,r) 
	L4873: (errFwdCmsLegNPV_[i][j]=,w) (mdlFwdCmsLegNPV_[i][j]-,r) 
	L4874: (mktFwdCmsLegNPV_[i][j],r) 
	L4875: (mdlSpotCmsLegNPV_[i][j]=,w) (mdlFwdCmsLegNPV_[i][j],r) 
	L4876: (mdlSpotCmsLegNPV_[i][j],r) 
	L4877: (errSpotCmsLegNPV_[i][j]=,w) (mdlSpotCmsLegNPV_[i][j]-,r) 
	L4878: (mktSpotCmsLegNPV_[i][j],r) 
	L4879: (spotFloatLegNPV_[i][j]+,r) (mdlSpotCmsLegNPV_[i][j],r) 
	L4880: (mdlSpreads_[i][j]=,w) (spotFloatLegBPS_[i][j]*,r) 
	L4881: (errSpreads_[i][j]=,w) (mdlSpreads_[i][j]-,r) (mktSpreads_[i][j],r) 
	}
 }
array table
-----------------------------------------------
mktSpreads_ -> [('[i][j]', 'w', 'normalized', ['j', 'i'], 4864), ('[i][j]', 'r', 'normalized', ['j', 'i'], 4869), ('[i][j]', 'r', 'normalized', ['j', 'i'], 4881)]
LDEs formed:6

bidAskSpreads_ -> [('[i][j*2]', 'r', 'normalized', ['j', 'i'], 4862), ('[i][j*2+1]', 'r', 'normalized', ['j', 'i'], 4863)]
LDEs formed:0

spotFloatLegBPS_ -> [('[i][j]', 'w', 'normalized', ['j', 'i'], 4867), ('[i][j]', 'r', 'normalized', ['j', 'i'], 4869), ('[i][j]', 'r', 'normalized', ['j', 'i'], 4880)]
LDEs formed:6

fwdSwaps_ -> [('[i][j]', 'r', 'normalized', ['j', 'i'], 4872)]
LDEs formed:0

mktBidSpreads_ -> [('[i][j]', 'w', 'normalized', ['j', 'i'], 4862), ('[i][j]', 'r', 'normalized', ['j', 'i'], 4864)]
LDEs formed:4

mdlFwdCmsLegNPV_ -> [('[i][j]', 'w', 'normalized', ['j', 'i'], 4872), ('[i][j]', 'r', 'normalized', ['j', 'i'], 4873), ('[i][j]', 'r', 'normalized', ['j', 'i'], 4875)]
LDEs formed:6

spotFloatLegNPV_ -> [('[i][j]', 'w', 'normalized', ['j', 'i'], 4866), ('[i][j]', 'r', 'normalized', ['j', 'i'], 4868), ('[i][j]', 'r', 'normalized', ['j', 'i'], 4879)]
LDEs formed:6

mktFwdCmsLegNPV_ -> [('[i][j]', 'w', 'normalized', ['j', 'i'], 4870), ('[i][j]', 'r', 'normalized', ['j', 'i'], 4874)]
LDEs formed:4

mdlSpotCmsLegNPV_ -> [('[i][j]', 'w', 'normalized', ['j', 'i'], 4875), ('[i][j]', 'r', 'normalized', ['j', 'i'], 4876), ('[i][j]', 'r', 'normalized', ['j', 'i'], 4877), ('[i][j]', 'r', 'normalized', ['j', 'i'], 4879)]
LDEs formed:8

mdlSpreads_ -> [('[i][j]', 'w', 'normalized', ['j', 'i'], 4880), ('[i][j]', 'r', 'normalized', ['j', 'i'], 4881)]
LDEs formed:4

errSpotCmsLegNPV_ -> [('[i][j]', 'w', 'normalized', ['j', 'i'], 4877)]
LDEs formed:2

mktAskSpreads_ -> [('[i][j]', 'w', 'normalized', ['j', 'i'], 4863), ('[i][j]', 'r', 'normalized', ['j', 'i'], 4864)]
LDEs formed:4

mktSpotCmsLegNPV_ -> [('[i][j]', 'w', 'normalized', ['j', 'i'], 4868), ('[i][j]', 'r', 'normalized', ['j', 'i'], 4870), ('[i][j]', 'r', 'normalized', ['j', 'i'], 4871), ('[i][j]', 'r', 'normalized', ['j', 'i'], 4878)]
LDEs formed:8

errSpreads_ -> [('[i][j]', 'w', 'normalized', ['j', 'i'], 4881)]
LDEs formed:2

spotSwaps_ -> [('[i][j]', 'r', 'normalized', ['j', 'i'], 4865)]
LDEs formed:0

errFwdCmsLegNPV_ -> [('[i][j]', 'w', 'normalized', ['j', 'i'], 4873)]
LDEs formed:2

distinct LDEs:
i1=i2,j1=j2
#########################################################################################
loop info: Size j = 0  j < nSwapIndexes_  ++j
induction variable: ['j']
{
L4874: (pricers_[j]-,r) 
L4875: (pricers_[j],r) 
}
array table
-----------------------------------------------
pricers_ -> [('[j]', 'r', 'normalized', ['j'], 4874), ('[j]', 'r', 'normalized', ['j'], 4875)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<nExercise_  ++i
induction variable: ['i']
{
	loop info: Size j=0  j<nSwapIndexes_  ++j
	induction variable: ['i', 'j']
	{
	L4876: (w[i][j]*,r) (var[i][j]*,r) (var[i][j],r) 
	}
 }
array table
-----------------------------------------------
var -> [('[i][j]', 'r', 'normalized', ['i', 'j'], 4876), ('[i][j]', 'r', 'normalized', ['i', 'j'], 4876)]
LDEs formed:0

w -> [('[i][j]', 'r', 'normalized', ['i', 'j'], 4876)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<nExercise_  ++i
induction variable: ['i']
{
	loop info: Size j=0  j<nSwapIndexes_  ++j
	induction variable: ['i', 'j']
	{
	L4877: (weightedVars[i*nSwapIndexes_+j]=,w) (w[i][j],r) (var[i][j],r) 
	}
 }
array table
-----------------------------------------------
var -> [('[i][j]', 'r', 'normalized', ['i', 'j'], 4877)]
LDEs formed:0

weightedVars -> [('[i*nSwapIndexes_+j]', 'w', 'not normalized', ['i', 'j'], 4877)]
LDEs formed:1

w -> [('[i][j]', 'r', 'normalized', ['i', 'j'], 4877)]
LDEs formed:0

distinct LDEs:
i1*nSwapIndexes_+j1=i2*nSwapIndexes_+j2
#########################################################################################
loop info: Size j=0  j<nSwapIndexes_  ++j
induction variable: ['j']
{
	loop info: Size i=0  i<nExercise_  ++i
	induction variable: ['j', 'i']
	{
	L4878: (result[j*nExercise_+i][0]=,w) (swapTenors_[j].length,r) 
	L4879: (result[j*nExercise_+i][1]=,w) (swapLengths_[i].length,r) 
	L4880: (result[j*nExercise_+i][2]=,w) (mktBidSpreads_[i][j]*,r) 
	L4881: (result[j*nExercise_+i][3]=,w) (mktAskSpreads_[i][j]*,r) 
	L4882: (result[j*nExercise_+i][4]=,w) (mktSpreads_[i][j]*,r) 
	L4883: (result[j*nExercise_+i][5]=,w) (mdlSpreads_[i][j]*,r) 
	L4884: (result[j*nExercise_+i][6]=,w) (errSpreads_[i][j]*,r) 
	L4885: (mdlSpreads_[i][j],r) (mktAskSpreads_[i][j],r) 
	L4886: (result[j*nExercise_+i][7]=,w) (mdlSpreads_[i][j]-,r) 
	L4887: (mktAskSpreads_[i][j],r) 
	L4888: (mdlSpreads_[i][j],r) (mktBidSpreads_[i][j],r) 
	L4889: (result[j*nExercise_+i][7]=,w) (mktBidSpreads_[i][j]-,r) 
	L4890: (mdlSpreads_[i][j],r) 
	L4891: (result[j*nExercise_+i][7]=,w) 
	L4892: (result[j*nExercise_+i][ 8]=,w) (mktSpotCmsLegNPV_[i][j],r) 
	L4893: (result[j*nExercise_+i][ 9]=,w) (mdlSpotCmsLegNPV_[i][j],r) 
	L4894: (result[j*nExercise_+i][10]=,w) (errSpotCmsLegNPV_[i][j],r) 
	L4895: (result[j*nExercise_+i][11]=,w) (mktFwdCmsLegNPV_[i][j],r) 
	L4896: (result[j*nExercise_+i][12]=,w) (mdlFwdCmsLegNPV_[i][j],r) 
	L4897: (result[j*nExercise_+i][13]=,w) (errFwdCmsLegNPV_[i][j],r) 
	}
 }
array table
-----------------------------------------------
mktSpreads_ -> [('[i][j]', 'r', 'normalized', ['j', 'i'], 4882)]
LDEs formed:0

mdlFwdCmsLegNPV_ -> [('[i][j]', 'r', 'normalized', ['j', 'i'], 4896)]
LDEs formed:0

swapTenors_ -> [('[j]', 'r', 'normalized', ['j', 'i'], 4878)]
LDEs formed:0

swapLengths_ -> [('[i]', 'r', 'normalized', ['j', 'i'], 4879)]
LDEs formed:0

mktBidSpreads_ -> [('[i][j]', 'r', 'normalized', ['j', 'i'], 4880), ('[i][j]', 'r', 'normalized', ['j', 'i'], 4888), ('[i][j]', 'r', 'normalized', ['j', 'i'], 4889)]
LDEs formed:0

errSpotCmsLegNPV_ -> [('[i][j]', 'r', 'normalized', ['j', 'i'], 4894)]
LDEs formed:0

errSpreads_ -> [('[i][j]', 'r', 'normalized', ['j', 'i'], 4884)]
LDEs formed:0

mktFwdCmsLegNPV_ -> [('[i][j]', 'r', 'normalized', ['j', 'i'], 4895)]
LDEs formed:0

mdlSpotCmsLegNPV_ -> [('[i][j]', 'r', 'normalized', ['j', 'i'], 4893)]
LDEs formed:0

result -> [('[j*nExercise_+i][0]', 'w', 'not normalized', ['j', 'i'], 4878), ('[j*nExercise_+i][1]', 'w', 'not normalized', ['j', 'i'], 4879), ('[j*nExercise_+i][2]', 'w', 'not normalized', ['j', 'i'], 4880), ('[j*nExercise_+i][3]', 'w', 'not normalized', ['j', 'i'], 4881), ('[j*nExercise_+i][4]', 'w', 'not normalized', ['j', 'i'], 4882), ('[j*nExercise_+i][5]', 'w', 'not normalized', ['j', 'i'], 4883), ('[j*nExercise_+i][6]', 'w', 'not normalized', ['j', 'i'], 4884), ('[j*nExercise_+i][7]', 'w', 'not normalized', ['j', 'i'], 4886), ('[j*nExercise_+i][7]', 'w', 'not normalized', ['j', 'i'], 4889), ('[j*nExercise_+i][7]', 'w', 'not normalized', ['j', 'i'], 4891), ('[j*nExercise_+i][ 8]', 'w', 'not normalized', ['j', 'i'], 4892), ('[j*nExercise_+i][ 9]', 'w', 'not normalized', ['j', 'i'], 4893), ('[j*nExercise_+i][10]', 'w', 'not normalized', ['j', 'i'], 4894), ('[j*nExercise_+i][11]', 'w', 'not normalized', ['j', 'i'], 4895), ('[j*nExercise_+i][12]', 'w', 'not normalized', ['j', 'i'], 4896), ('[j*nExercise_+i][13]', 'w', 'not normalized', ['j', 'i'], 4897)]
LDEs formed:272

mktAskSpreads_ -> [('[i][j]', 'r', 'normalized', ['j', 'i'], 4881), ('[i][j]', 'r', 'normalized', ['j', 'i'], 4885), ('[i][j]', 'r', 'normalized', ['j', 'i'], 4887)]
LDEs formed:0

mktSpotCmsLegNPV_ -> [('[i][j]', 'r', 'normalized', ['j', 'i'], 4892)]
LDEs formed:0

mdlSpreads_ -> [('[i][j]', 'r', 'normalized', ['j', 'i'], 4883), ('[i][j]', 'r', 'normalized', ['j', 'i'], 4885), ('[i][j]', 'r', 'normalized', ['j', 'i'], 4886), ('[i][j]', 'r', 'normalized', ['j', 'i'], 4888), ('[i][j]', 'r', 'normalized', ['j', 'i'], 4890)]
LDEs formed:0

errFwdCmsLegNPV_ -> [('[i][j]', 'r', 'normalized', ['j', 'i'], 4897)]
LDEs formed:0

distinct LDEs:
j1*nExercise_+i1=j2*nExercise_+i2,3= 9
j1*nExercise_+i1=j2*nExercise_+i2,3= 8
j1*nExercise_+i1=j2*nExercise_+i2,6=7
j1*nExercise_+i1=j2*nExercise_+i2,7=7
j1*nExercise_+i1=j2*nExercise_+i2,4=5
j1*nExercise_+i1=j2*nExercise_+i2,4=4
j1*nExercise_+i1=j2*nExercise_+i2,4=7
j1*nExercise_+i1=j2*nExercise_+i2,4=6
j1*nExercise_+i1=j2*nExercise_+i2,3=3
j1*nExercise_+i1=j2*nExercise_+i2,3=6
j1*nExercise_+i1=j2*nExercise_+i2,3=7
j1*nExercise_+i1=j2*nExercise_+i2,3=4
j1*nExercise_+i1=j2*nExercise_+i2,3=5
j1*nExercise_+i1=j2*nExercise_+i2,0=1
j1*nExercise_+i1=j2*nExercise_+i2,0=0
j1*nExercise_+i1=j2*nExercise_+i2,0=3
j1*nExercise_+i1=j2*nExercise_+i2,0=2
j1*nExercise_+i1=j2*nExercise_+i2,0=5
j1*nExercise_+i1=j2*nExercise_+i2,0=4
j1*nExercise_+i1=j2*nExercise_+i2,0=7
j1*nExercise_+i1=j2*nExercise_+i2,0=6
j1*nExercise_+i1=j2*nExercise_+i2,2=13
j1*nExercise_+i1=j2*nExercise_+i2, 8=12
j1*nExercise_+i1=j2*nExercise_+i2, 8=13
j1*nExercise_+i1=j2*nExercise_+i2, 8=10
j1*nExercise_+i1=j2*nExercise_+i2,6=6
j1*nExercise_+i1=j2*nExercise_+i2,2=11
j1*nExercise_+i1=j2*nExercise_+i2,2=10
j1*nExercise_+i1=j2*nExercise_+i2,5=12
j1*nExercise_+i1=j2*nExercise_+i2,5=13
j1*nExercise_+i1=j2*nExercise_+i2,5=10
j1*nExercise_+i1=j2*nExercise_+i2,5=11
j1*nExercise_+i1=j2*nExercise_+i2,4= 8
j1*nExercise_+i1=j2*nExercise_+i2,4= 9
j1*nExercise_+i1=j2*nExercise_+i2,2= 8
j1*nExercise_+i1=j2*nExercise_+i2,2= 9
j1*nExercise_+i1=j2*nExercise_+i2,5= 9
j1*nExercise_+i1=j2*nExercise_+i2,5= 8
j1*nExercise_+i1=j2*nExercise_+i2,4=11
j1*nExercise_+i1=j2*nExercise_+i2,4=10
j1*nExercise_+i1=j2*nExercise_+i2,4=13
j1*nExercise_+i1=j2*nExercise_+i2,4=12
j1*nExercise_+i1=j2*nExercise_+i2,7=10
j1*nExercise_+i1=j2*nExercise_+i2,7=11
j1*nExercise_+i1=j2*nExercise_+i2,7=12
j1*nExercise_+i1=j2*nExercise_+i2,7=13
j1*nExercise_+i1=j2*nExercise_+i2, 9=11
j1*nExercise_+i1=j2*nExercise_+i2, 9=10
j1*nExercise_+i1=j2*nExercise_+i2, 9=13
j1*nExercise_+i1=j2*nExercise_+i2, 9=12
j1*nExercise_+i1=j2*nExercise_+i2,5=5
j1*nExercise_+i1=j2*nExercise_+i2,5=6
j1*nExercise_+i1=j2*nExercise_+i2,5=7
j1*nExercise_+i1=j2*nExercise_+i2,1=12
j1*nExercise_+i1=j2*nExercise_+i2,1=13
j1*nExercise_+i1=j2*nExercise_+i2,1=10
j1*nExercise_+i1=j2*nExercise_+i2,1=11
j1*nExercise_+i1=j2*nExercise_+i2,0= 8
j1*nExercise_+i1=j2*nExercise_+i2,0= 9
j1*nExercise_+i1=j2*nExercise_+i2,10=13
j1*nExercise_+i1=j2*nExercise_+i2,10=12
j1*nExercise_+i1=j2*nExercise_+i2,10=11
j1*nExercise_+i1=j2*nExercise_+i2,10=10
j1*nExercise_+i1=j2*nExercise_+i2,6= 8
j1*nExercise_+i1=j2*nExercise_+i2,6= 9
j1*nExercise_+i1=j2*nExercise_+i2,1=4
j1*nExercise_+i1=j2*nExercise_+i2,1=5
j1*nExercise_+i1=j2*nExercise_+i2,1=6
j1*nExercise_+i1=j2*nExercise_+i2,1=7
j1*nExercise_+i1=j2*nExercise_+i2,1=1
j1*nExercise_+i1=j2*nExercise_+i2,1=2
j1*nExercise_+i1=j2*nExercise_+i2,1=3
j1*nExercise_+i1=j2*nExercise_+i2, 9= 9
j1*nExercise_+i1=j2*nExercise_+i2,2=7
j1*nExercise_+i1=j2*nExercise_+i2,2=6
j1*nExercise_+i1=j2*nExercise_+i2,2=5
j1*nExercise_+i1=j2*nExercise_+i2,2=4
j1*nExercise_+i1=j2*nExercise_+i2,2=3
j1*nExercise_+i1=j2*nExercise_+i2,2=2
j1*nExercise_+i1=j2*nExercise_+i2,6=13
j1*nExercise_+i1=j2*nExercise_+i2,6=12
j1*nExercise_+i1=j2*nExercise_+i2,6=11
j1*nExercise_+i1=j2*nExercise_+i2,6=10
j1*nExercise_+i1=j2*nExercise_+i2,11=11
j1*nExercise_+i1=j2*nExercise_+i2,11=12
j1*nExercise_+i1=j2*nExercise_+i2,11=13
j1*nExercise_+i1=j2*nExercise_+i2,0=11
j1*nExercise_+i1=j2*nExercise_+i2,0=10
j1*nExercise_+i1=j2*nExercise_+i2,0=13
j1*nExercise_+i1=j2*nExercise_+i2,0=12
j1*nExercise_+i1=j2*nExercise_+i2,7= 9
j1*nExercise_+i1=j2*nExercise_+i2,7= 8
j1*nExercise_+i1=j2*nExercise_+i2,2=12
j1*nExercise_+i1=j2*nExercise_+i2,12=13
j1*nExercise_+i1=j2*nExercise_+i2,12=12
j1*nExercise_+i1=j2*nExercise_+i2,1= 9
j1*nExercise_+i1=j2*nExercise_+i2,1= 8
j1*nExercise_+i1=j2*nExercise_+i2,3=10
j1*nExercise_+i1=j2*nExercise_+i2,3=11
j1*nExercise_+i1=j2*nExercise_+i2,3=12
j1*nExercise_+i1=j2*nExercise_+i2,3=13
j1*nExercise_+i1=j2*nExercise_+i2,13=13
j1*nExercise_+i1=j2*nExercise_+i2, 8=11
j1*nExercise_+i1=j2*nExercise_+i2, 8= 9
j1*nExercise_+i1=j2*nExercise_+i2, 8= 8
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/utilities/dataparsers.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/math/modifiedbessel.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/math/beta.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/math/incompletegamma.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/math/bspline.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<knots.size()-1  ++i
induction variable: ['i']
{
L4898: (knots[i],r) (knots[i+1],r) 
}
array table
-----------------------------------------------
knots -> [('[i]', 'r', 'normalized', ['i'], 4898), ('[i+1]', 'r', 'normalized', ['i'], 4898)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/math/matrix.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i < m.rows()  ++i
induction variable: ['i']
{
L4899: (pert[i],r) 
}
array table
-----------------------------------------------
pert -> [('[i]', 'r', 'normalized', ['i'], 4899)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/math/integrals/gaussianquadratures.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: i=1  i < n  ++i
induction variable: ['i']
{
L4900: (x_[i]=,w) 
L4901: (e[i-1]=,w) 
}
array table
-----------------------------------------------
e -> [('[i-1]', 'w', 'normalized', ['i'], 4901)]
LDEs formed:1

x_ -> [('[i]', 'w', 'normalized', ['i'], 4900)]
LDEs formed:1

distinct LDEs:
i1=i2
i1-1=i2-1
#########################################################################################
loop info: i=0  i<n  ++i
induction variable: ['i']
{
L4901: (w_[i]=,w) (ev[0][i]*,r) (ev[0][i]/,r) (x_[i],r) 
}
array table
-----------------------------------------------
w_ -> [('[i]', 'w', 'normalized', ['i'], 4901)]
LDEs formed:1

ev -> [('[0][i]', 'r', 'normalized', ['i'], 4901), ('[0][i]', 'r', 'normalized', ['i'], 4901)]
LDEs formed:0

x_ -> [('[i]', 'r', 'normalized', ['i'], 4901)]
LDEs formed:0

distinct LDEs:
i1=i2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/math/integrals/kronrodintegral.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: k = 0  k < 5  k++
induction variable: ['k']
{
L4902: (x1[k],r) 
L4903: (w10[k]*,r) 
L4904: (w21a[k]*,r) 
L4905: (w21a[k]*,r) 
L4906: (savfun[k]=,w) 
L4907: (fv1[k]=,w) 
L4908: (fv2[k]=,w) 
}
array table
-----------------------------------------------
savfun -> [('[k]', 'w', 'normalized', ['k'], 4906)]
LDEs formed:1

w10 -> [('[k]', 'r', 'normalized', ['k'], 4903)]
LDEs formed:0

w21a -> [('[k]', 'r', 'normalized', ['k'], 4904), ('[k]', 'r', 'normalized', ['k'], 4905)]
LDEs formed:0

x1 -> [('[k]', 'r', 'normalized', ['k'], 4902)]
LDEs formed:0

fv2 -> [('[k]', 'w', 'normalized', ['k'], 4908)]
LDEs formed:1

fv1 -> [('[k]', 'w', 'normalized', ['k'], 4907)]
LDEs formed:1

distinct LDEs:
k1=k2
#########################################################################################
loop info: k = 0  k < 5  k++
induction variable: ['k']
{
L4908: (x2[k],r) 
L4909: (w21b[k]*,r) 
L4910: (w21b[k]*,r) 
L4911: (savfun[k + 5]=,w) 
L4912: (fv3[k]=,w) 
L4913: (fv4[k]=,w) 
}
array table
-----------------------------------------------
x2 -> [('[k]', 'r', 'normalized', ['k'], 4908)]
LDEs formed:0

fv4 -> [('[k]', 'w', 'normalized', ['k'], 4913)]
LDEs formed:1

w21b -> [('[k]', 'r', 'normalized', ['k'], 4909), ('[k]', 'r', 'normalized', ['k'], 4910)]
LDEs formed:0

savfun -> [('[k + 5]', 'w', 'normalized', ['k'], 4911)]
LDEs formed:1

fv3 -> [('[k]', 'w', 'normalized', ['k'], 4912)]
LDEs formed:1

distinct LDEs:
k1=k2
k1 + 5=k2 + 5
#########################################################################################
loop info: k = 0  k < 11  k++
induction variable: ['k']
{
L4913: (x3[k],r) 
L4914: (w43b[k],r) 
L4915: (savfun[k + 10]=,w) 
}
array table
-----------------------------------------------
x3 -> [('[k]', 'r', 'normalized', ['k'], 4913)]
LDEs formed:0

savfun -> [('[k + 10]', 'w', 'normalized', ['k'], 4915)]
LDEs formed:1

w43b -> [('[k]', 'r', 'normalized', ['k'], 4914)]
LDEs formed:0

distinct LDEs:
k1 + 10=k2 + 10
#########################################################################################
loop info: k = 0  k < 22  k++
induction variable: ['k']
{
L4915: (x4[k],r) 
L4916: (w87b[k]*,r) 
}
array table
-----------------------------------------------
w87b -> [('[k]', 'r', 'normalized', ['k'], 4916)]
LDEs formed:0

x4 -> [('[k]', 'r', 'normalized', ['k'], 4915)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: j = 1, j2 = 2  j < 4  j++, j2 += 2
induction variable: ['j', 'j2']
{
L4916: (k15t[j2],r) 
L4917: (g7w[j],r) 
L4918: (k15w[j2],r) 
}
array table
-----------------------------------------------
g7w -> [('[j]', 'r', 'normalized', ['j', 'j2'], 4917)]
LDEs formed:0

k15w -> [('[j2]', 'r', 'normalized', ['j', 'j2'], 4918)]
LDEs formed:0

k15t -> [('[j2]', 'r', 'normalized', ['j', 'j2'], 4916)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: j2 = 1  j2 < 8  j2 += 2
induction variable: ['j2']
{
L4917: (k15t[j2],r) 
L4918: (k15w[j2],r) 
}
array table
-----------------------------------------------
k15w -> [('[j2]', 'r', 'normalized', ['j2'], 4918)]
LDEs formed:0

k15t -> [('[j2]', 'r', 'normalized', ['j2'], 4917)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/math/integrals/discreteintegrals.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i < n-1  ++i
induction variable: ['i']
{
L4918: (x[i+1]-,r) (x[i],r) (f[i]+,r) (f[i+1],r) 
}
array table
-----------------------------------------------
x -> [('[i+1]', 'r', 'normalized', ['i'], 4918), ('[i]', 'r', 'normalized', ['i'], 4918)]
LDEs formed:0

f -> [('[i]', 'r', 'normalized', ['i'], 4918), ('[i+1]', 'r', 'normalized', ['i'], 4918)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size j=0  j < n-2  j+=2
induction variable: ['j']
{
L4919: (x[j+1]-,r) (x[j],r) 
L4920: (x[j+2]-,r) (x[j+1],r) 
L4921: (x[j]-,r) (x[j+1]+,r) (x[j+2],r) 
L4922: (x[j+2]-,r) (x[j],r) 
L4923: (x[j]-,r) (x[j+1]+,r) (x[j+2],r) 
L4924: (f[j]+,r) (f[j+1]+,r) (f[j+2],r) 
}
array table
-----------------------------------------------
x -> [('[j+1]', 'r', 'normalized', ['j'], 4919), ('[j]', 'r', 'normalized', ['j'], 4919), ('[j+2]', 'r', 'normalized', ['j'], 4920), ('[j+1]', 'r', 'normalized', ['j'], 4920), ('[j]', 'r', 'normalized', ['j'], 4921), ('[j+1]', 'r', 'normalized', ['j'], 4921), ('[j+2]', 'r', 'normalized', ['j'], 4921), ('[j+2]', 'r', 'normalized', ['j'], 4922), ('[j]', 'r', 'normalized', ['j'], 4922), ('[j]', 'r', 'normalized', ['j'], 4923), ('[j+1]', 'r', 'normalized', ['j'], 4923), ('[j+2]', 'r', 'normalized', ['j'], 4923)]
LDEs formed:0

f -> [('[j]', 'r', 'normalized', ['j'], 4924), ('[j+1]', 'r', 'normalized', ['j'], 4924), ('[j+2]', 'r', 'normalized', ['j'], 4924)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/math/integrals/filonintegral.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=1  i <= n_  ++i
induction variable: ['i']
{
L4925: (v[2*i]*,r) (x[2*i],r) 
L4926: (v[2*i-1]*,r) (x[2*i-1],r) 
}
array table
-----------------------------------------------
x -> [('[2*i]', 'r', 'normalized', ['i'], 4925), ('[2*i-1]', 'r', 'normalized', ['i'], 4926)]
LDEs formed:0

v -> [('[2*i]', 'r', 'normalized', ['i'], 4925), ('[2*i-1]', 'r', 'normalized', ['i'], 4926)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/math/matrixutilities/basisincompleteordered.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size j=0  j<currentBasis_.size()  ++j
induction variable: ['j']
{
L4927: (currentBasis_[j].begin,r) 
	loop info: Size k=0  k<euclideanDimension_  ++k
	induction variable: ['j', 'k']
	{
	}
 }
array table
-----------------------------------------------
currentBasis_ -> [('[j]', 'r', 'normalized', ['j', 'k'], 4927)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size j=0  j < numberVectors_  ++j
induction variable: ['j']
{
L4928: (validVectors_[j],r) 
	loop info: Size k=0  k< numberVectors_  ++k
	induction variable: ['j', 'k']
		{
			loop info: Size m=0  m < dimension_  ++m
			induction variable: ['j', 'k', 'm']
			{
			}
		L4929: (validVectors_[k],r) 
			loop info: Size l=0  l < k  ++l
			induction variable: ['j', 'k', 'm', 'l']
				{
				L4930: (validVectors_[l]&,r) 
					loop info: Size n=0  n < dimension_  ++n
					induction variable: ['j', 'k', 'm', 'l', 'n']
						{
						}
 				}
		L4931: (validVectors_[k]=,w) 
			loop info: Size m=0  m < dimension_  ++m
			induction variable: ['j', 'k', 'm', 'l', 'n']
					{
					}
		L4932: (validVectors_[k],r) 
		}
	loop info: Size r=0  r < numberVectors_  ++r
	induction variable: ['j', 'k', 'm', 'l', 'n', 'r']
		{
			loop info: Size s=0  s < dimension_  ++s
			induction variable: ['j', 'k', 'm', 'l', 'n', 'r', 's']
			{
			}
 		}
	loop info: Size t=0  t < dimension_  ++t
	induction variable: ['j', 'k', 'm', 'l', 'n', 'r', 's', 't']
			{
			}
L4933: (validVectors_[j]=,w) 
L4934: (validVectors_[j],r) 
}
array table
-----------------------------------------------
validVectors_ -> [('[j]', 'r', 'normalized', ['j', 'k', 'm', 'l', 'n', 'r', 's', 't'], 4928), ('[k]', 'r', 'normalized', ['j', 'k', 'm', 'l', 'n', 'r', 's', 't'], 4929), ('[l]', 'r', 'normalized', ['j', 'k', 'm', 'l', 'n', 'r', 's', 't'], 4930), ('[k]', 'w', 'normalized', ['j', 'k', 'm', 'l', 'n', 'r', 's', 't'], 4931), ('[k]', 'r', 'normalized', ['j', 'k', 'm', 'l', 'n', 'r', 's', 't'], 4932), ('[j]', 'w', 'normalized', ['j', 'k', 'm', 'l', 'n', 'r', 's', 't'], 4933), ('[j]', 'r', 'normalized', ['j', 'k', 'm', 'l', 'n', 'r', 's', 't'], 4934)]
LDEs formed:13

distinct LDEs:
l1=k2
j1=j2
k1=k2
l1=j2
j1=k2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/math/matrixutilities/tqreigendecomposition.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: i=0  i < ev_.rows()  ++i
induction variable: ['i']
{
L4935: (ev_[i][i]=,w) 
}
array table
-----------------------------------------------
ev_ -> [('[i][i]', 'w', 'normalized', ['i'], 4935)]
LDEs formed:2

distinct LDEs:
i1=i2,i1=i2
#########################################################################################
loop info: Size k=n-1  k >=1  --k
induction variable: ['k']
{
L4936: (d_[l],r) 
L4937: (d_[k-1],r) (e_[k],r) 
L4938: (e_[k],r) (d_[k],r) 
L4939: (d_[k+1],r) 
L4940: (d_[k]*,r) (d_[k]+,r) (d_[k-1]*,r) (d_[k-1],r) 
L4941: (d_[k-1]*,r) (d_[k]+,r) (e[k]*,r) (e[k],r) 
L4942: (d_[k]+,r) (d_[k-1],r) 
L4943: (d_[k],r) (d_[k],r) 
	loop info: Size i=l+1  i <= k && !recoverUnderflow  ++i
	induction variable: ['k', 'i']
		{
		L4944: (e[i],r) 
		L4945: (e[i],r) 
		L4946: (e[i-1]=,w) 
		L4947: (e[i-1],r) 
		L4948: (e[i-1],r) 
		L4949: (e[i-1],r) 
		L4950: (d_[i-1]-,r) 
		L4951: (d_[i]-,r) 
		L4952: (d_[i-1]=,w) 
			loop info: Size j=0  j < ev_.rows()  ++j
			induction variable: ['k', 'i', 'j']
				{
				L4953: (ev_[j][i-1],r) 
				L4954: (ev_[j][i-1]=,w) (ev_[j][i]+,r) 
				L4955: (ev_[j][i]=,w) (ev_[j][i]-,r) 
				}
		L4956: (d_[i-1]-=,w) 
		L4957: (e[l]=,w) 
		}
L4958: (d_[k]-=,w) 
L4959: (e[k]=,w) 
L4960: (e[l]=,w) 
}
array table
-----------------------------------------------
d_ -> [('[l]', 'r', 'not normalized', ['k', 'i', 'j'], 4936), ('[k-1]', 'r', 'normalized', ['k', 'i', 'j'], 4937), ('[k]', 'r', 'normalized', ['k', 'i', 'j'], 4938), ('[k+1]', 'r', 'normalized', ['k', 'i', 'j'], 4939), ('[k]', 'r', 'normalized', ['k', 'i', 'j'], 4940), ('[k]', 'r', 'normalized', ['k', 'i', 'j'], 4940), ('[k-1]', 'r', 'normalized', ['k', 'i', 'j'], 4940), ('[k-1]', 'r', 'normalized', ['k', 'i', 'j'], 4940), ('[k-1]', 'r', 'normalized', ['k', 'i', 'j'], 4941), ('[k]', 'r', 'normalized', ['k', 'i', 'j'], 4941), ('[k]', 'r', 'normalized', ['k', 'i', 'j'], 4942), ('[k-1]', 'r', 'normalized', ['k', 'i', 'j'], 4942), ('[k]', 'r', 'normalized', ['k', 'i', 'j'], 4943), ('[k]', 'r', 'normalized', ['k', 'i', 'j'], 4943), ('[i-1]', 'r', 'normalized', ['k', 'i', 'j'], 4950), ('[i]', 'r', 'normalized', ['k', 'i', 'j'], 4951), ('[i-1]', 'w', 'normalized', ['k', 'i', 'j'], 4952), ('[i-1]', 'w', 'normalized', ['k', 'i', 'j'], 4956), ('[k]', 'w', 'normalized', ['k', 'i', 'j'], 4958)]
LDEs formed:54

e_ -> [('[k]', 'r', 'normalized', ['k', 'i', 'j'], 4937), ('[k]', 'r', 'normalized', ['k', 'i', 'j'], 4938)]
LDEs formed:0

e -> [('[k]', 'r', 'normalized', ['k', 'i', 'j'], 4941), ('[k]', 'r', 'normalized', ['k', 'i', 'j'], 4941), ('[i]', 'r', 'normalized', ['k', 'i', 'j'], 4944), ('[i]', 'r', 'normalized', ['k', 'i', 'j'], 4945), ('[i-1]', 'w', 'normalized', ['k', 'i', 'j'], 4946), ('[i-1]', 'r', 'normalized', ['k', 'i', 'j'], 4947), ('[i-1]', 'r', 'normalized', ['k', 'i', 'j'], 4948), ('[i-1]', 'r', 'normalized', ['k', 'i', 'j'], 4949), ('[l]', 'w', 'not normalized', ['k', 'i', 'j'], 4957), ('[k]', 'w', 'normalized', ['k', 'i', 'j'], 4959), ('[l]', 'w', 'not normalized', ['k', 'i', 'j'], 4960)]
LDEs formed:38

ev_ -> [('[j][i-1]', 'r', 'normalized', ['k', 'i', 'j'], 4953), ('[j][i-1]', 'w', 'normalized', ['k', 'i', 'j'], 4954), ('[j][i]', 'r', 'normalized', ['k', 'i', 'j'], 4954), ('[j][i]', 'w', 'normalized', ['k', 'i', 'j'], 4955), ('[j][i]', 'r', 'normalized', ['k', 'i', 'j'], 4955)]
LDEs formed:18

distinct LDEs:
j1=j2,i1-1=i2-1
k1+1=k2
l=i2-1
j1=j2,i1-1=i2
k1-1=k2
i1=i2-1
k1+1=i2-1
i1=k2
k1=k2
i1=l
l=k2
k1=i2-1
j1=j2,i1=i2
l=l
k1-1=i2-1
i1-1=i2-1
#########################################################################################
loop info: i=0  i<n  i++
induction variable: ['i']
{
L4956: (temp[i]=,w) (d_[i],r) 
}
array table
-----------------------------------------------
d_ -> [('[i]', 'r', 'normalized', ['i'], 4956)]
LDEs formed:0

temp -> [('[i]', 'w', 'normalized', ['i'], 4956)]
LDEs formed:1

distinct LDEs:
i1=i2
#########################################################################################
loop info: i=0  i<n  i++
induction variable: ['i']
{
L4957: (d_[i]=,w) (temp[i].first,r) 
L4958: (temp[i].second,r) 
	loop info: Size j=0  j<ev_.rows()  ++j
	induction variable: ['i', 'j']
	{
	L4959: (ev_[j][i]=,w) (temp[i].second,r) 
	}
 }
array table
-----------------------------------------------
d_ -> [('[i]', 'w', 'normalized', ['i', 'j'], 4957)]
LDEs formed:1

temp -> [('[i]', 'r', 'normalized', ['i', 'j'], 4957), ('[i]', 'r', 'normalized', ['i', 'j'], 4958), ('[i]', 'r', 'normalized', ['i', 'j'], 4959)]
LDEs formed:0

ev_ -> [('[j][i]', 'w', 'normalized', ['i', 'j'], 4959)]
LDEs formed:2

distinct LDEs:
j1=j2,i1=i2
i1=i2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/math/matrixutilities/pseudosqrt.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

L4960: (matrix[i][i]/,r) 
	loop info: Size j=0  j<pseudoCols  ++j
	induction variable: ['i', 'j']
		{
		}
 }
array table
-----------------------------------------------
matrix -> [('[i][i]', 'r', 'normalized', ['i', 'j'], 4960)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: i=0  i<size_  i++
induction variable: ['i']
{
	loop info: k=0  k<size_  k++
	induction variable: ['i', 'k']
	{
	L4961: (currentRoot_[i][k]=,w) 
		loop info: j=0  j<=k  j++
		induction variable: ['i', 'k', 'j']
			{
			L4962: (currentRoot_[i][k]*=,w) 
			L4963: (x[i*(i-1)/2+j],r) 
			L4964: (currentRoot_[i][k]*=,w) 
			L4965: (x[i*(i-1)/2+j],r) 
			}
 	}
 }
array table
-----------------------------------------------
x -> [('[i*(i-1)/2+j]', 'r', 'normalized', ['i', 'k', 'j'], 4963), ('[i*(i-1)/2+j]', 'r', 'normalized', ['i', 'k', 'j'], 4965)]
LDEs formed:0

currentRoot_ -> [('[i][k]', 'w', 'normalized', ['i', 'k', 'j'], 4961), ('[i][k]', 'w', 'normalized', ['i', 'k', 'j'], 4962), ('[i][k]', 'w', 'normalized', ['i', 'k', 'j'], 4964)]
LDEs formed:12

distinct LDEs:
i1=i2,k1=k2
#########################################################################################
loop info: i=0  i<size_  i++
induction variable: ['i']
{
	loop info: k=0  k<size_  k++
	induction variable: ['i', 'k']
	{
		loop info: j=0  j<=k  j++
		induction variable: ['i', 'k', 'j']
		{
		L4965: (currentRoot_[i][k]*=,w) 
		L4966: (x[j*size_+i],r) 
		L4967: (currentRoot_[i][k]*=,w) 
		L4968: (x[j*size_+i],r) 
		}
 	}
 }
array table
-----------------------------------------------
x -> [('[j*size_+i]', 'r', 'not normalized', ['i', 'k', 'j'], 4966), ('[j*size_+i]', 'r', 'not normalized', ['i', 'k', 'j'], 4968)]
LDEs formed:0

currentRoot_ -> [('[i][k]', 'w', 'normalized', ['i', 'k', 'j'], 4965), ('[i][k]', 'w', 'normalized', ['i', 'k', 'j'], 4967)]
LDEs formed:6

distinct LDEs:
i1=i2,k1=k2
#########################################################################################
loop info: i=0 i<size_ i++
induction variable: ['i']
{
	loop info: j=0 j<size_ j++
	induction variable: ['i', 'j']
	{
	L4968: (currentMatrix_[i][j]*,r) (targetVariance_[i],r) 
	L4969: (targetVariance_[j]-,r) (targetMatrix_[i][j],r) 
	}
 }
array table
-----------------------------------------------
targetMatrix_ -> [('[i][j]', 'r', 'normalized', ['i', 'j'], 4969)]
LDEs formed:0

targetVariance_ -> [('[i]', 'r', 'normalized', ['i', 'j'], 4968), ('[j]', 'r', 'normalized', ['i', 'j'], 4969)]
LDEs formed:0

currentMatrix_ -> [('[i][j]', 'r', 'normalized', ['i', 'j'], 4968)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: i=0  i<size  i++
induction variable: ['i']
{
L4969: (variance[i]=,w) (targetMatrix[i][i],r) 
}
array table
-----------------------------------------------
variance -> [('[i]', 'w', 'normalized', ['i'], 4969)]
LDEs formed:1

targetMatrix -> [('[i][i]', 'r', 'normalized', ['i'], 4969)]
LDEs formed:0

distinct LDEs:
i1=i2
#########################################################################################
loop info: i=0  i<size  i++
induction variable: ['i']
{
	loop info: j=0  j<size  j++
	induction variable: ['i', 'j']
	{
	L4970: (result[i][j]/=,w) (approxMatrix[i][i],r) 
	}
 }
array table
-----------------------------------------------
approxMatrix -> [('[i][i]', 'r', 'normalized', ['i', 'j'], 4970)]
LDEs formed:0

result -> [('[i][j]', 'w', 'normalized', ['i', 'j'], 4970)]
LDEs formed:2

distinct LDEs:
i1=i2,j1=j2
#########################################################################################
loop info: i=0  i<size  i++
induction variable: ['i']
{
	loop info: j=0  j<size  j++
	induction variable: ['i', 'j']
	{
	L4971: (result[i][j]/=,w) (variance[i],r) 
	}
 }
array table
-----------------------------------------------
variance -> [('[i]', 'r', 'normalized', ['i', 'j'], 4971)]
LDEs formed:0

result -> [('[i][j]', 'w', 'normalized', ['i', 'j'], 4971)]
LDEs formed:2

distinct LDEs:
i1=i2,j1=j2
#########################################################################################
loop info: i=1  i<size  i++
induction variable: ['i']
{
	loop info: j=0  j<i  j++
	induction variable: ['i', 'j']
	{
	L4972: (theta[i*(i-1)/2+j]=,w) (result[i][j],r) 
	L4973: (theta[i*(i-1)/2+j],r) 
	L4974: (theta[i*(i-1)/2+j]=,w) 
	L4975: (theta[i*(i-1)/2+j],r) 
	L4976: (theta[i*(i-1)/2+j]=,w) 
		loop info: k=0  k<j  k++
		induction variable: ['i', 'j', 'k']
		{
		L4977: (theta[i*(i-1)/2+j]/=,w) (theta[i*(i-1)/2+k],r) 
		L4978: (theta[i*(i-1)/2+j],r) 
		L4979: (theta[i*(i-1)/2+j]=,w) 
		L4980: (theta[i*(i-1)/2+j],r) 
		L4981: (theta[i*(i-1)/2+j]=,w) 
		}
	L4982: (theta[i*(i-1)/2+j]=,w) (theta[i*(i-1)/2+j],r) 
	L4983: (result[i][i],r) 
	L4984: (theta[i*(i-1)/2+j]=,w) (theta[i*(i-1)/2+j],r) 
	}
 }
array table
-----------------------------------------------
theta -> [('[i*(i-1)/2+j]', 'w', 'normalized', ['i', 'j', 'k'], 4972), ('[i*(i-1)/2+j]', 'r', 'normalized', ['i', 'j', 'k'], 4973), ('[i*(i-1)/2+j]', 'w', 'normalized', ['i', 'j', 'k'], 4974), ('[i*(i-1)/2+j]', 'r', 'normalized', ['i', 'j', 'k'], 4975), ('[i*(i-1)/2+j]', 'w', 'normalized', ['i', 'j', 'k'], 4976), ('[i*(i-1)/2+j]', 'w', 'normalized', ['i', 'j', 'k'], 4977), ('[i*(i-1)/2+k]', 'r', 'normalized', ['i', 'j', 'k'], 4977), ('[i*(i-1)/2+j]', 'r', 'normalized', ['i', 'j', 'k'], 4978), ('[i*(i-1)/2+j]', 'w', 'normalized', ['i', 'j', 'k'], 4979), ('[i*(i-1)/2+j]', 'r', 'normalized', ['i', 'j', 'k'], 4980), ('[i*(i-1)/2+j]', 'w', 'normalized', ['i', 'j', 'k'], 4981), ('[i*(i-1)/2+j]', 'w', 'normalized', ['i', 'j', 'k'], 4982), ('[i*(i-1)/2+j]', 'r', 'normalized', ['i', 'j', 'k'], 4982), ('[i*(i-1)/2+j]', 'w', 'normalized', ['i', 'j', 'k'], 4984), ('[i*(i-1)/2+j]', 'r', 'normalized', ['i', 'j', 'k'], 4984)]
LDEs formed:92

result -> [('[i][j]', 'r', 'normalized', ['i', 'j', 'k'], 4972), ('[i][i]', 'r', 'normalized', ['i', 'j', 'k'], 4983)]
LDEs formed:0

distinct LDEs:
i1*(i1-1)/2+j1=i2*(i2-1)/2+k2
i1*(i1-1)/2+j1=i2*(i2-1)/2+j2
#########################################################################################
loop info: i=0  i<size  i++
induction variable: ['i']
{
	loop info: k=0  k<size  k++
	induction variable: ['i', 'k']
	{
	L4984: (result[i][k]=,w) 
		loop info: j=0  j<=k  j++
		induction variable: ['i', 'k', 'j']
			{
			L4985: (result[i][k]*=,w) 
			L4986: (theta[i*(i-1)/2+j],r) 
			L4987: (result[i][k]*=,w) 
			L4988: (theta[i*(i-1)/2+j],r) 
			}
 	}
 }
array table
-----------------------------------------------
theta -> [('[i*(i-1)/2+j]', 'r', 'normalized', ['i', 'k', 'j'], 4986), ('[i*(i-1)/2+j]', 'r', 'normalized', ['i', 'k', 'j'], 4988)]
LDEs formed:0

result -> [('[i][k]', 'w', 'normalized', ['i', 'k', 'j'], 4984), ('[i][k]', 'w', 'normalized', ['i', 'k', 'j'], 4985), ('[i][k]', 'w', 'normalized', ['i', 'k', 'j'], 4987)]
LDEs formed:12

distinct LDEs:
i1=i2,k1=k2
#########################################################################################
loop info: i=0  i<size  i++
induction variable: ['i']
{
	loop info: j=0  j<size-1  j++
	induction variable: ['i', 'j']
	{
	L4988: (theta[j*size+i]=,w) (result[i][j],r) 
	L4989: (theta[j*size+i],r) 
	L4990: (theta[j*size+i]=,w) 
	L4991: (theta[j*size+i],r) 
	L4992: (theta[j*size+i]=,w) 
		loop info: k=0 k<j k++
		induction variable: ['i', 'j', 'k']
		{
		L4993: (theta[j*size+i]/=,w) (theta[k*size+i],r) 
		L4994: (theta[j*size+i],r) 
		L4995: (theta[j*size+i]=,w) 
		L4996: (theta[j*size+i],r) 
		L4997: (theta[j*size+i]=,w) 
		}
	L4998: (theta[j*size+i]=,w) (theta[j*size+i],r) 
	L4999: (result[i][j+1],r) 
	L5000: (theta[j*size+i]=,w) (theta[j*size+i],r) 
	}
 }
array table
-----------------------------------------------
theta -> [('[j*size+i]', 'w', 'not normalized', ['i', 'j', 'k'], 4988), ('[j*size+i]', 'r', 'not normalized', ['i', 'j', 'k'], 4989), ('[j*size+i]', 'w', 'not normalized', ['i', 'j', 'k'], 4990), ('[j*size+i]', 'r', 'not normalized', ['i', 'j', 'k'], 4991), ('[j*size+i]', 'w', 'not normalized', ['i', 'j', 'k'], 4992), ('[j*size+i]', 'w', 'not normalized', ['i', 'j', 'k'], 4993), ('[k*size+i]', 'r', 'not normalized', ['i', 'j', 'k'], 4993), ('[j*size+i]', 'r', 'not normalized', ['i', 'j', 'k'], 4994), ('[j*size+i]', 'w', 'not normalized', ['i', 'j', 'k'], 4995), ('[j*size+i]', 'r', 'not normalized', ['i', 'j', 'k'], 4996), ('[j*size+i]', 'w', 'not normalized', ['i', 'j', 'k'], 4997), ('[j*size+i]', 'w', 'not normalized', ['i', 'j', 'k'], 4998), ('[j*size+i]', 'r', 'not normalized', ['i', 'j', 'k'], 4998), ('[j*size+i]', 'w', 'not normalized', ['i', 'j', 'k'], 5000), ('[j*size+i]', 'r', 'not normalized', ['i', 'j', 'k'], 5000)]
LDEs formed:92

result -> [('[i][j]', 'r', 'normalized', ['i', 'j', 'k'], 4988), ('[i][j+1]', 'r', 'normalized', ['i', 'j', 'k'], 4999)]
LDEs formed:0

distinct LDEs:
j1*size+i1=j2*size+i2
j1*size+i1=k2*size+i2
#########################################################################################
loop info: i=0  i<size  i++
induction variable: ['i']
{
	loop info: k=0  k<size  k++
	induction variable: ['i', 'k']
	{
		loop info: j=0  j<=k  j++
		induction variable: ['i', 'k', 'j']
		{
		L5000: (result[i][k]*=,w) (theta[j*size+i],r) 
		L5001: (result[i][k]*=,w) (theta[j*size+i],r) 
		}
 	}
 }
array table
-----------------------------------------------
theta -> [('[j*size+i]', 'r', 'not normalized', ['i', 'k', 'j'], 5000), ('[j*size+i]', 'r', 'not normalized', ['i', 'k', 'j'], 5001)]
LDEs formed:0

result -> [('[i][k]', 'w', 'normalized', ['i', 'k', 'j'], 5000), ('[i][k]', 'w', 'normalized', ['i', 'k', 'j'], 5001)]
LDEs formed:6

distinct LDEs:
i1=i2,k1=k2
#########################################################################################
loop info: i=0  i<size  i++
induction variable: ['i']
{
	loop info: j=0  j<size  j++
	induction variable: ['i', 'j']
	{
	L5002: (result[i][j]*=,w) (variance[i],r) 
	}
 }
array table
-----------------------------------------------
variance -> [('[i]', 'r', 'normalized', ['i', 'j'], 5002)]
LDEs formed:0

result -> [('[i][j]', 'w', 'normalized', ['i', 'j'], 5002)]
LDEs formed:2

distinct LDEs:
i1=i2,j1=j2
#########################################################################################
loop info: Size i=0  i<size  ++i
induction variable: ['i']
{
L5003: (diagonal[i][i]=,w) 
}
array table
-----------------------------------------------
diagonal -> [('[i][i]', 'w', 'normalized', ['i'], 5003)]
LDEs formed:2

distinct LDEs:
i1=i2,i1=i2
#########################################################################################
loop info: Size i=0  i<size  ++i
induction variable: ['i']
{
L5004: (diagonal[i][i]=,w) 
}
array table
-----------------------------------------------
diagonal -> [('[i][i]', 'w', 'normalized', ['i'], 5004)]
LDEs formed:2

distinct LDEs:
i1=i2,i1=i2
#########################################################################################
loop info: Size i=1  components<enough && i<size  ++i
induction variable: ['i']
{
L5005: (eigenValues[i],r) 
}
array table
-----------------------------------------------
eigenValues -> [('[i]', 'r', 'normalized', ['i'], 5005)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/math/matrixutilities/bicgstab.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/math/matrixutilities/choleskydecomposition.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: i=0  i<size  i++
induction variable: ['i']
{
	loop info: j=i  j<size  j++
	induction variable: ['i', 'j']
	{
	L5006: (S[i][j],r) 
		loop info: Integer k=0  k<=Integer(i)-1  k++
		induction variable: ['i', 'j', 'k']
		{
		L5007: (result[i][k]*,r) (result[j][k],r) 
		}
	L5008: (result[i][i]=,w) 
	L5009: (result[i][i]==,r) 
	L5010: (result[j][i]=,w) 
	L5011: (result[i][i],r) 
	}
 }
array table
-----------------------------------------------
S -> [('[i][j]', 'r', 'normalized', ['i', 'j', 'k'], 5006)]
LDEs formed:0

result -> [('[i][k]', 'r', 'normalized', ['i', 'j', 'k'], 5007), ('[j][k]', 'r', 'normalized', ['i', 'j', 'k'], 5007), ('[i][i]', 'w', 'normalized', ['i', 'j', 'k'], 5008), ('[i][i]', 'r', 'normalized', ['i', 'j', 'k'], 5009), ('[j][i]', 'w', 'normalized', ['i', 'j', 'k'], 5010), ('[i][i]', 'r', 'normalized', ['i', 'j', 'k'], 5011)]
LDEs formed:22

distinct LDEs:
j1=j2,i1=i2
i1=j2,k1=i2
i1=i2,k1=i2
i1=j2,i1=i2
j1=i2,k1=i2
i1=i2,i1=i2
j1=j2,k1=i2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/math/matrixutilities/svd.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: k = 0  k < std::max(nct,nrt)  k++
induction variable: ['k']
{
L5012: (s[k],r) 
L5013: (s_[k]=,w) 
	loop info: i = k  i < m_  i++
	induction variable: ['k', 'i']
		{
		L5014: (s_[k]=,w) (s_[k],r) (A[i][k],r) 
		}
L5015: (s_[k],r) 
L5016: (A[k][k],r) 
L5017: (s_[k]=,w) (s_[k],r) 
	loop info: i = k  i < m_  i++
	induction variable: ['k', 'i']
			{
			L5018: (A[i][k]/=,w) (s_[k],r) 
			}
L5019: (A[k][k]+=,w) 
L5020: (s_[k]=,w) (s_[k],r) 
	loop info: j = k+1  j < n_  j++
	induction variable: ['k', 'i', 'j']
	{
	L5021: (s_[k],r) 
		loop info: i = k  i < m_  i++
		induction variable: ['k', 'i', 'j']
			{
			L5022: (A[i][k]*,r) (A[i][j],r) 
			}
	L5023: (A[k][k],r) 
		loop info: i = k  i < m_  i++
		induction variable: ['k', 'i', 'j']
			{
			L5024: (A[i][j]+=,w) (A[i][k],r) 
			}
	L5025: (e[j]=,w) (A[k][j],r) 
	}
	loop info: i = k  i < m_  i++
	induction variable: ['k', 'i', 'j']
		{
		L5026: (U_[i][k]=,w) (A[i][k],r) 
		}
L5027: (e[k],r) 
L5028: (e[k]=,w) 
	loop info: i = k+1  i < n_  i++
	induction variable: ['k', 'i', 'j']
		{
		L5029: (e[k]=,w) (e[k],r) (e[i],r) 
		}
L5030: (e[k],r) 
L5031: (e[k+1],r) 
L5032: (e[k]=,w) (e[k],r) 
	loop info: i = k+1  i < n_  i++
	induction variable: ['k', 'i', 'j']
			{
			L5033: (e[i]/=,w) (e[k],r) 
			}
L5034: (e[k+1]+=,w) 
L5035: (e[k]=,w) (e[k],r) 
L5036: (e[k],r) 
	loop info: i = k+1  i < m_  i++
	induction variable: ['k', 'i', 'j']
			{
			L5037: (work[i]=,w) 
			}
	loop info: i = k+1  i < m_  i++
	induction variable: ['k', 'i', 'j']
				{
				L5038: (work[i]+=,w) (e[j]*,r) (A[i][j],r) 
				}
	loop info: j = k+1  j < n_  j++
	induction variable: ['k', 'i', 'j']
			{
			L5039: (e[j]/,r) (e[k+1],r) 
				loop info: i = k+1  i < m_  i++
				induction variable: ['k', 'i', 'j']
				{
				L5040: (A[i][j]+=,w) (work[i],r) 
				}
 			}
	loop info: i = k+1  i < n_  i++
	induction variable: ['k', 'i', 'j']
		{
		L5041: (V_[i][k]=,w) (e[i],r) 
		}
 }
array table
-----------------------------------------------
A -> [('[i][k]', 'r', 'normalized', ['k', 'i', 'j'], 5014), ('[k][k]', 'r', 'normalized', ['k', 'i', 'j'], 5016), ('[i][k]', 'w', 'normalized', ['k', 'i', 'j'], 5018), ('[k][k]', 'w', 'normalized', ['k', 'i', 'j'], 5019), ('[i][k]', 'r', 'normalized', ['k', 'i', 'j'], 5022), ('[i][j]', 'r', 'normalized', ['k', 'i', 'j'], 5022), ('[k][k]', 'r', 'normalized', ['k', 'i', 'j'], 5023), ('[i][j]', 'w', 'normalized', ['k', 'i', 'j'], 5024), ('[i][k]', 'r', 'normalized', ['k', 'i', 'j'], 5024), ('[k][j]', 'r', 'normalized', ['k', 'i', 'j'], 5025), ('[i][k]', 'r', 'normalized', ['k', 'i', 'j'], 5026), ('[i][j]', 'r', 'normalized', ['k', 'i', 'j'], 5038), ('[i][j]', 'w', 'normalized', ['k', 'i', 'j'], 5040)]
LDEs formed:92

U_ -> [('[i][k]', 'w', 'normalized', ['k', 'i', 'j'], 5026)]
LDEs formed:2

e -> [('[j]', 'w', 'normalized', ['k', 'i', 'j'], 5025), ('[k]', 'r', 'normalized', ['k', 'i', 'j'], 5027), ('[k]', 'w', 'normalized', ['k', 'i', 'j'], 5028), ('[k]', 'w', 'normalized', ['k', 'i', 'j'], 5029), ('[k]', 'r', 'normalized', ['k', 'i', 'j'], 5029), ('[i]', 'r', 'normalized', ['k', 'i', 'j'], 5029), ('[k]', 'r', 'normalized', ['k', 'i', 'j'], 5030), ('[k+1]', 'r', 'normalized', ['k', 'i', 'j'], 5031), ('[k]', 'w', 'normalized', ['k', 'i', 'j'], 5032), ('[k]', 'r', 'normalized', ['k', 'i', 'j'], 5032), ('[i]', 'w', 'normalized', ['k', 'i', 'j'], 5033), ('[k]', 'r', 'normalized', ['k', 'i', 'j'], 5033), ('[k+1]', 'w', 'normalized', ['k', 'i', 'j'], 5034), ('[k]', 'w', 'normalized', ['k', 'i', 'j'], 5035), ('[k]', 'r', 'normalized', ['k', 'i', 'j'], 5035), ('[k]', 'r', 'normalized', ['k', 'i', 'j'], 5036), ('[j]', 'r', 'normalized', ['k', 'i', 'j'], 5038), ('[j]', 'r', 'normalized', ['k', 'i', 'j'], 5039), ('[k+1]', 'r', 'normalized', ['k', 'i', 'j'], 5039), ('[i]', 'r', 'normalized', ['k', 'i', 'j'], 5041)]
LDEs formed:119

work -> [('[i]', 'w', 'normalized', ['k', 'i', 'j'], 5037), ('[i]', 'w', 'normalized', ['k', 'i', 'j'], 5038), ('[i]', 'r', 'normalized', ['k', 'i', 'j'], 5040)]
LDEs formed:5

s -> [('[k]', 'r', 'normalized', ['k', 'i', 'j'], 5012)]
LDEs formed:0

s_ -> [('[k]', 'w', 'normalized', ['k', 'i', 'j'], 5013), ('[k]', 'w', 'normalized', ['k', 'i', 'j'], 5014), ('[k]', 'r', 'normalized', ['k', 'i', 'j'], 5014), ('[k]', 'r', 'normalized', ['k', 'i', 'j'], 5015), ('[k]', 'w', 'normalized', ['k', 'i', 'j'], 5017), ('[k]', 'r', 'normalized', ['k', 'i', 'j'], 5017), ('[k]', 'r', 'normalized', ['k', 'i', 'j'], 5018), ('[k]', 'w', 'normalized', ['k', 'i', 'j'], 5020), ('[k]', 'r', 'normalized', ['k', 'i', 'j'], 5020), ('[k]', 'r', 'normalized', ['k', 'i', 'j'], 5021)]
LDEs formed:34

V_ -> [('[i][k]', 'w', 'normalized', ['k', 'i', 'j'], 5041)]
LDEs formed:2

distinct LDEs:
i1=i2,k1=k2
i1=i2,k1=j2
i1=i2,j1=j2
j1=k2
k1=k2,k1=k2
i1=k2,j1=j2
i1=k2,k1=k2
i1=k2,k1=j2
k1=k2+1
j1=k2+1
k1=i2,k1=j2
k1=k2
i1=i2
k1=k2,k1=j2
j1=j2
i1=k2+1
j1=i2
k1=i2
k1+1=k2+1
#########################################################################################
loop info: j = nct  j < n_  j++
induction variable: ['j']
{
	loop info: i = 0  i < m_  i++
	induction variable: ['j', 'i']
	{
	L5042: (U_[i][j]=,w) 
	}
L5043: (U_[j][j]=,w) 
}
array table
-----------------------------------------------
U_ -> [('[i][j]', 'w', 'normalized', ['j', 'i'], 5042), ('[j][j]', 'w', 'normalized', ['j', 'i'], 5043)]
LDEs formed:6

distinct LDEs:
i1=j2,j1=j2
i1=i2,j1=j2
j1=j2,j1=j2
#########################################################################################
loop info: k = nct-1  k >= 0  --k
induction variable: ['k']
{
L5044: (s_[k],r) 
	loop info: j = k+1  j < n_  ++j
	induction variable: ['k', 'j']
		{
			loop info: i = k  i < m_  i++
			induction variable: ['k', 'j', 'i']
			{
			L5045: (U_[i][k]*,r) (U_[i][j],r) 
			}
		L5046: (U_[k][k],r) 
			loop info: i = k  i < m_  i++
			induction variable: ['k', 'j', 'i']
			{
			L5047: (U_[i][j]+=,w) (U_[i][k],r) 
			}
 		}
L5048: (U_[i][k]=,w) (U_[i][k],r) 
L5049: (U_[k][k]=,w) (U_[k][k],r) 
	loop info: i = 0  i < k-1  i++
	induction variable: ['k', 'j', 'i']
		{
		L5050: (U_[i][k]=,w) 
		}
	loop info: i = 0  i < m_  i++
	induction variable: ['k', 'j', 'i']
		{
		L5051: (U_[i][k]=,w) 
		}
L5052: (U_[k][k]=,w) 
}
array table
-----------------------------------------------
U_ -> [('[i][k]', 'r', 'normalized', ['k', 'j', 'i'], 5045), ('[i][j]', 'r', 'normalized', ['k', 'j', 'i'], 5045), ('[k][k]', 'r', 'normalized', ['k', 'j', 'i'], 5046), ('[i][j]', 'w', 'normalized', ['k', 'j', 'i'], 5047), ('[i][k]', 'r', 'normalized', ['k', 'j', 'i'], 5047), ('[i][k]', 'w', 'normalized', ['k', 'j', 'i'], 5048), ('[i][k]', 'r', 'normalized', ['k', 'j', 'i'], 5048), ('[k][k]', 'w', 'normalized', ['k', 'j', 'i'], 5049), ('[k][k]', 'r', 'normalized', ['k', 'j', 'i'], 5049), ('[i][k]', 'w', 'normalized', ['k', 'j', 'i'], 5050), ('[i][k]', 'w', 'normalized', ['k', 'j', 'i'], 5051), ('[k][k]', 'w', 'normalized', ['k', 'j', 'i'], 5052)]
LDEs formed:114

s_ -> [('[k]', 'r', 'normalized', ['k', 'j', 'i'], 5044)]
LDEs formed:0

distinct LDEs:
i1=i2,k1=k2
i1=i2,k1=j2
i1=i2,j1=j2
k1=k2,k1=k2
i1=k2,k1=k2
i1=k2,j1=k2
#########################################################################################
loop info: k = n_-1  k >= 0  --k
induction variable: ['k']
{
L5045: (e[k],r) 
	loop info: j = k+1  j < n_  ++j
	induction variable: ['k', 'j']
		{
			loop info: i = k+1  i < n_  i++
			induction variable: ['k', 'j', 'i']
			{
			L5046: (V_[i][k]*,r) (V_[i][j],r) 
			}
		L5047: (V_[k+1][k],r) 
			loop info: i = k+1  i < n_  i++
			induction variable: ['k', 'j', 'i']
			{
			L5048: (V_[i][j]+=,w) (V_[i][k],r) 
			}
 		}
	loop info: i = 0  i < n_  i++
	induction variable: ['k', 'j', 'i']
	{
	L5049: (V_[i][k]=,w) 
	}
L5050: (V_[k][k]=,w) 
}
array table
-----------------------------------------------
e -> [('[k]', 'r', 'normalized', ['k', 'j', 'i'], 5045)]
LDEs formed:0

V_ -> [('[i][k]', 'r', 'normalized', ['k', 'j', 'i'], 5046), ('[i][j]', 'r', 'normalized', ['k', 'j', 'i'], 5046), ('[k+1][k]', 'r', 'normalized', ['k', 'j', 'i'], 5047), ('[i][j]', 'w', 'normalized', ['k', 'j', 'i'], 5048), ('[i][k]', 'r', 'normalized', ['k', 'j', 'i'], 5048), ('[i][k]', 'w', 'normalized', ['k', 'j', 'i'], 5049), ('[k][k]', 'w', 'normalized', ['k', 'j', 'i'], 5050)]
LDEs formed:36

distinct LDEs:
i1=i2,k1=k2
k1+1=i2,k1=j2
i1=i2,j1=j2
k1+1=i2,k1=k2
k1=k2,k1=k2
i1=k2,k1=k2
k1+1=k2,k1=k2
i1=k2,j1=k2
i1=i2,k1=j2
#########################################################################################
loop info: k = p-2  k >= -1  --k
induction variable: ['k']
{
L5051: (e[k],r) (s_[k],r) 
L5052: (s_[k+1],r) 
L5053: (e[k]=,w) 
}
array table
-----------------------------------------------
s_ -> [('[k]', 'r', 'normalized', ['k'], 5051), ('[k+1]', 'r', 'normalized', ['k'], 5052)]
LDEs formed:0

e -> [('[k]', 'r', 'normalized', ['k'], 5051), ('[k]', 'w', 'normalized', ['k'], 5053)]
LDEs formed:2

distinct LDEs:
k1=k2
#########################################################################################
loop info: ks = p-1  ks >= k  --ks
induction variable: ['ks']
{
L5054: (e[ks],r) 
L5055: (e[ks-1],r) 
L5056: (s_[ks],r) 
L5057: (s_[ks]=,w) 
}
array table
-----------------------------------------------
s_ -> [('[ks]', 'r', 'normalized', ['ks'], 5056), ('[ks]', 'w', 'normalized', ['ks'], 5057)]
LDEs formed:2

e -> [('[ks]', 'r', 'normalized', ['ks'], 5054), ('[ks-1]', 'r', 'normalized', ['ks'], 5055)]
LDEs formed:0

distinct LDEs:
ks1=ks2
#########################################################################################
loop info: j = p-2  j >= k  --j
induction variable: ['j']
{
L5056: (s_[j],r) 
L5057: (s_[j]/,r) 
L5058: (s_[j]=,w) 
L5059: (e[j-1],r) 
L5060: (e[j-1]=,w) (e[j-1],r) 
	loop info: i = 0  i < n_  i++
	induction variable: ['j', 'i']
	{
	L5061: (V_[i][j]+,r) (V_[i][p-1],r) 
	L5062: (V_[i][p-1]=,w) (V_[i][j]+,r) (V_[i][p-1],r) 
	L5063: (V_[i][j]=,w) 
	}
 }
array table
-----------------------------------------------
e -> [('[j-1]', 'r', 'normalized', ['j', 'i'], 5059), ('[j-1]', 'w', 'normalized', ['j', 'i'], 5060), ('[j-1]', 'r', 'normalized', ['j', 'i'], 5060)]
LDEs formed:3

s_ -> [('[j]', 'r', 'normalized', ['j', 'i'], 5056), ('[j]', 'r', 'normalized', ['j', 'i'], 5057), ('[j]', 'w', 'normalized', ['j', 'i'], 5058)]
LDEs formed:3

V_ -> [('[i][j]', 'r', 'normalized', ['j', 'i'], 5061), ('[i][p-1]', 'r', 'not normalized', ['j', 'i'], 5061), ('[i][p-1]', 'w', 'not normalized', ['j', 'i'], 5062), ('[i][j]', 'r', 'normalized', ['j', 'i'], 5062), ('[i][p-1]', 'r', 'not normalized', ['j', 'i'], 5062), ('[i][j]', 'w', 'normalized', ['j', 'i'], 5063)]
LDEs formed:22

distinct LDEs:
i1=i2,j1=p-1
j1-1=j2-1
i1=i2,p-1=p-1
i1=i2,j1=j2
j1=j2
#########################################################################################
loop info: j = k  j < p  j++
induction variable: ['j']
{
L5064: (s_[j],r) 
L5065: (s_[j]/,r) 
L5066: (s_[j]=,w) 
L5067: (e[j],r) 
L5068: (e[j]=,w) (e[j],r) 
	loop info: i = 0  i < m_  i++
	induction variable: ['j', 'i']
	{
	L5069: (U_[i][j]+,r) (U_[i][k-1],r) 
	L5070: (U_[i][k-1]=,w) (U_[i][j]+,r) (U_[i][k-1],r) 
	L5071: (U_[i][j]=,w) 
	}
 }
array table
-----------------------------------------------
e -> [('[j]', 'r', 'normalized', ['j', 'i'], 5067), ('[j]', 'w', 'normalized', ['j', 'i'], 5068), ('[j]', 'r', 'normalized', ['j', 'i'], 5068)]
LDEs formed:3

U_ -> [('[i][j]', 'r', 'normalized', ['j', 'i'], 5069), ('[i][k-1]', 'r', 'not normalized', ['j', 'i'], 5069), ('[i][k-1]', 'w', 'not normalized', ['j', 'i'], 5070), ('[i][j]', 'r', 'normalized', ['j', 'i'], 5070), ('[i][k-1]', 'r', 'not normalized', ['j', 'i'], 5070), ('[i][j]', 'w', 'normalized', ['j', 'i'], 5071)]
LDEs formed:22

s_ -> [('[j]', 'r', 'normalized', ['j', 'i'], 5064), ('[j]', 'r', 'normalized', ['j', 'i'], 5065), ('[j]', 'w', 'normalized', ['j', 'i'], 5066)]
LDEs formed:3

distinct LDEs:
i1=i2,k-1=k-1
j1=j2
i1=i2,j1=k-1
i1=i2,j1=j2
#########################################################################################
loop info: j = k  j < p-1  j++
induction variable: ['j']
{
L5067: (e[j-1]=,w) 
L5068: (s_[j]+,r) (e[j],r) 
L5069: (e[j]=,w) (e[j]-,r) (s_[j],r) 
L5070: (s_[j+1],r) 
L5071: (s_[j+1]=,w) (s_[j+1],r) 
	loop info: i = 0  i < n_  i++
	induction variable: ['j', 'i']
	{
	L5072: (V_[i][j]+,r) (V_[i][j+1],r) 
	L5073: (V_[i][j+1]=,w) (V_[i][j]+,r) (V_[i][j+1],r) 
	L5074: (V_[i][j]=,w) 
	}
L5075: (s_[j]=,w) 
L5076: (e[j]+,r) (s_[j+1],r) 
L5077: (s_[j+1]=,w) (e[j]+,r) (s_[j+1],r) 
L5078: (e[j+1],r) 
L5079: (e[j+1]=,w) (e[j+1],r) 
	loop info: i = 0  i < m_  i++
	induction variable: ['j', 'i']
		{
		L5080: (U_[i][j]+,r) (U_[i][j+1],r) 
		L5081: (U_[i][j+1]=,w) (U_[i][j]+,r) (U_[i][j+1],r) 
		L5082: (U_[i][j]=,w) 
		}
 }
array table
-----------------------------------------------
s_ -> [('[j]', 'r', 'normalized', ['j', 'i'], 5068), ('[j]', 'r', 'normalized', ['j', 'i'], 5069), ('[j+1]', 'r', 'normalized', ['j', 'i'], 5070), ('[j+1]', 'w', 'normalized', ['j', 'i'], 5071), ('[j+1]', 'r', 'normalized', ['j', 'i'], 5071), ('[j]', 'w', 'normalized', ['j', 'i'], 5075), ('[j+1]', 'r', 'normalized', ['j', 'i'], 5076), ('[j+1]', 'w', 'normalized', ['j', 'i'], 5077), ('[j+1]', 'r', 'normalized', ['j', 'i'], 5077)]
LDEs formed:24

U_ -> [('[i][j]', 'r', 'normalized', ['j', 'i'], 5080), ('[i][j+1]', 'r', 'normalized', ['j', 'i'], 5080), ('[i][j+1]', 'w', 'normalized', ['j', 'i'], 5081), ('[i][j]', 'r', 'normalized', ['j', 'i'], 5081), ('[i][j+1]', 'r', 'normalized', ['j', 'i'], 5081), ('[i][j]', 'w', 'normalized', ['j', 'i'], 5082)]
LDEs formed:22

e -> [('[j-1]', 'w', 'normalized', ['j', 'i'], 5067), ('[j]', 'r', 'normalized', ['j', 'i'], 5068), ('[j]', 'w', 'normalized', ['j', 'i'], 5069), ('[j]', 'r', 'normalized', ['j', 'i'], 5069), ('[j]', 'r', 'normalized', ['j', 'i'], 5076), ('[j]', 'r', 'normalized', ['j', 'i'], 5077), ('[j+1]', 'r', 'normalized', ['j', 'i'], 5078), ('[j+1]', 'w', 'normalized', ['j', 'i'], 5079), ('[j+1]', 'r', 'normalized', ['j', 'i'], 5079)]
LDEs formed:24

V_ -> [('[i][j]', 'r', 'normalized', ['j', 'i'], 5072), ('[i][j+1]', 'r', 'normalized', ['j', 'i'], 5072), ('[i][j+1]', 'w', 'normalized', ['j', 'i'], 5073), ('[i][j]', 'r', 'normalized', ['j', 'i'], 5073), ('[i][j+1]', 'r', 'normalized', ['j', 'i'], 5073), ('[i][j]', 'w', 'normalized', ['j', 'i'], 5074)]
LDEs formed:22

distinct LDEs:
j1-1=j2
i1=i2,j1=j2
j1+1=j2+1
j1=j2+1
j1-1=j2+1
i1=i2,j1+1=j2+1
j1-1=j2-1
j1=j2
i1=i2,j1=j2+1
#########################################################################################
loop info: i = 0  i <= pp  i++
induction variable: ['i']
{
L5075: (V_[i][k]=,w) (V_[i][k],r) 
}
array table
-----------------------------------------------
V_ -> [('[i][k]', 'w', 'not normalized', ['i'], 5075), ('[i][k]', 'r', 'not normalized', ['i'], 5075)]
LDEs formed:4

distinct LDEs:
i1=i2,k=k
#########################################################################################
loop info: i = 0  i < n_  i++
induction variable: ['i']
{
L5076: (V_[i][k],r) (V_[i][k+1],r) 
}
array table
-----------------------------------------------
V_ -> [('[i][k]', 'r', 'not normalized', ['i'], 5076), ('[i][k+1]', 'r', 'not normalized', ['i'], 5076)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: i = 0  i < m_  i++
induction variable: ['i']
{
L5077: (U_[i][k],r) (U_[i][k+1],r) 
}
array table
-----------------------------------------------
U_ -> [('[i][k]', 'r', 'not normalized', ['i'], 5077), ('[i][k+1]', 'r', 'not normalized', ['i'], 5077)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i = 0  i < Size(n_)  i++
induction variable: ['i']
{
	loop info: Size j = 0  j < Size(n_)  j++
	induction variable: ['i', 'j']
	{
	L5078: (S[i][j]=,w) 
	}
L5079: (S[i][i]=,w) (s_[i],r) 
}
array table
-----------------------------------------------
S -> [('[i][j]', 'w', 'normalized', ['i', 'j'], 5078), ('[i][i]', 'w', 'normalized', ['i', 'j'], 5079)]
LDEs formed:6

s_ -> [('[i]', 'r', 'normalized', ['i', 'j'], 5079)]
LDEs formed:0

distinct LDEs:
i1=i2,j1=i2
i1=i2,j1=j2
i1=i2,i1=i2
#########################################################################################
loop info: Size i = 0  i < s_.size()  i++
induction variable: ['i']
{
L5080: (s_[i],r) 
}
array table
-----------------------------------------------
s_ -> [('[i]', 'r', 'normalized', ['i'], 5080)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/math/matrixutilities/symmetricschurdecomposition.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size q=0  q<size  q++
induction variable: ['q']
{
L5081: (diagonal_[q]=,w) (s[q][q],r) 
L5082: (eigenVectors_[q][q]=,w) 
}
array table
-----------------------------------------------
diagonal_ -> [('[q]', 'w', 'normalized', ['q'], 5081)]
LDEs formed:1

s -> [('[q][q]', 'r', 'normalized', ['q'], 5081)]
LDEs formed:0

eigenVectors_ -> [('[q][q]', 'w', 'normalized', ['q'], 5082)]
LDEs formed:2

distinct LDEs:
q1=q2,q1=q2
q1=q2
#########################################################################################
loop info: Size a=0  a<size-1  a++
induction variable: ['a']
{
	loop info: Size b=a+1  b<size  b++
	induction variable: ['a', 'b']
	{
	L5083: (ss[a][b],r) 
	}
 }
array table
-----------------------------------------------
ss -> [('[a][b]', 'r', 'normalized', ['a', 'b'], 5083)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: j=0  j<size-1  j++
induction variable: ['j']
{
	loop info: k=j+1  k<size  k++
	induction variable: ['j', 'k']
	{
	L5084: (ss[j][k],r) 
	L5085: (diagonal_[j],r) 
	L5086: (diagonal_[k],r) 
	L5087: (ss[j][k]=,w) 
	L5088: (ss[j][k],r) 
	L5089: (diagonal_[k]-,r) (diagonal_[j],r) 
	L5090: (ss[j][k]/,r) 
	L5091: (ss[j][k],r) 
	L5092: (ss[j][k],r) 
	L5093: (tmpAccumulate[j]-=,w) 
	L5094: (tmpAccumulate[k]+=,w) 
	L5095: (diagonal_[j]-=,w) 
	L5096: (diagonal_[k]+=,w) 
	L5097: (ss[j][k]=,w) 
		loop info: l=0  l+1<=j  l++
		induction variable: ['j', 'k', 'l']
			{
			}
		loop info: l=k+1  l<size  l++
		induction variable: ['j', 'k', 'l']
			{
			}
 	}
 }
array table
-----------------------------------------------
ss -> [('[j][k]', 'r', 'normalized', ['j', 'k', 'l'], 5084), ('[j][k]', 'w', 'normalized', ['j', 'k', 'l'], 5087), ('[j][k]', 'r', 'normalized', ['j', 'k', 'l'], 5088), ('[j][k]', 'r', 'normalized', ['j', 'k', 'l'], 5090), ('[j][k]', 'r', 'normalized', ['j', 'k', 'l'], 5091), ('[j][k]', 'r', 'normalized', ['j', 'k', 'l'], 5092), ('[j][k]', 'w', 'normalized', ['j', 'k', 'l'], 5097)]
LDEs formed:26

diagonal_ -> [('[j]', 'r', 'normalized', ['j', 'k', 'l'], 5085), ('[k]', 'r', 'normalized', ['j', 'k', 'l'], 5086), ('[k]', 'r', 'normalized', ['j', 'k', 'l'], 5089), ('[j]', 'r', 'normalized', ['j', 'k', 'l'], 5089), ('[j]', 'w', 'normalized', ['j', 'k', 'l'], 5095), ('[k]', 'w', 'normalized', ['j', 'k', 'l'], 5096)]
LDEs formed:11

tmpAccumulate -> [('[j]', 'w', 'normalized', ['j', 'k', 'l'], 5093), ('[k]', 'w', 'normalized', ['j', 'k', 'l'], 5094)]
LDEs formed:3

distinct LDEs:
j1=j2
k1=k2
j1=j2,k1=k2
j1=k2
#########################################################################################
loop info: k=0  k<size  k++
induction variable: ['k']
{
L5095: (tmpDiag[k]+=,w) (tmpAccumulate[k],r) 
L5096: (diagonal_[k]=,w) (tmpDiag[k],r) 
L5097: (tmpAccumulate[k]=,w) 
}
array table
-----------------------------------------------
tmpAccumulate -> [('[k]', 'r', 'normalized', ['k'], 5095), ('[k]', 'w', 'normalized', ['k'], 5097)]
LDEs formed:2

tmpDiag -> [('[k]', 'w', 'normalized', ['k'], 5095), ('[k]', 'r', 'normalized', ['k'], 5096)]
LDEs formed:2

diagonal_ -> [('[k]', 'w', 'normalized', ['k'], 5096)]
LDEs formed:1

distinct LDEs:
k1=k2
#########################################################################################
loop info: col=0  col<size  col++
induction variable: ['col']
{
L5097: (temp[col]=,w) (diagonal_[col],r) 
}
array table
-----------------------------------------------
diagonal_ -> [('[col]', 'r', 'normalized', ['col'], 5097)]
LDEs formed:0

temp -> [('[col]', 'w', 'normalized', ['col'], 5097)]
LDEs formed:1

distinct LDEs:
col1=col2
#########################################################################################
loop info: col=0  col<size  col++
induction variable: ['col']
{
L5098: (diagonal_[col]=,w) 
L5099: (temp[col].first/,r) 
L5100: (temp[col].first,r) 
L5101: (temp[col].second,r) 
	loop info: row=0  row<size  row++
	induction variable: ['col', 'row']
	{
	L5102: (eigenVectors_[row][col]=,w) (temp[col].second,r) 
	}
 }
array table
-----------------------------------------------
diagonal_ -> [('[col]', 'w', 'normalized', ['col', 'row'], 5098)]
LDEs formed:1

eigenVectors_ -> [('[row][col]', 'w', 'normalized', ['col', 'row'], 5102)]
LDEs formed:2

temp -> [('[col]', 'r', 'normalized', ['col', 'row'], 5099), ('[col]', 'r', 'normalized', ['col', 'row'], 5100), ('[col]', 'r', 'normalized', ['col', 'row'], 5101), ('[col]', 'r', 'normalized', ['col', 'row'], 5102)]
LDEs formed:0

distinct LDEs:
row1=row2,col1=col2
col1=col2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/math/matrixutilities/tapcorrelations.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=1  i<m.rows()  ++i
induction variable: ['i']
{
	loop info: Size j=0  j<bound  ++j
	induction variable: ['i', 'j']
	{
	L5103: (m[i][j]=,w) (angles[k],r) 
	L5104: (m[i][j]*=,w) 
	L5105: (angles[k],r) 
	}
L5106: (m[i][bound]=,w) 
	loop info: Size j=bound+1  j<m.rows()  ++j
	induction variable: ['i', 'j']
	{
	}
 }
array table
-----------------------------------------------
m -> [('[i][j]', 'w', 'normalized', ['i', 'j'], 5103), ('[i][j]', 'w', 'normalized', ['i', 'j'], 5104), ('[i][bound]', 'w', 'not normalized', ['i', 'j'], 5106)]
LDEs formed:12

angles -> [('[k]', 'r', 'not normalized', ['i', 'j'], 5103), ('[k]', 'r', 'not normalized', ['i', 'j'], 5105)]
LDEs formed:0

distinct LDEs:
i1=i2,bound=bound
i1=i2,j1=bound
i1=i2,j1=j2
#########################################################################################
loop info: Size i=0  i<m.rows()  ++i
induction variable: ['i']
{
L5106: (angles[i-1],r) 
L5107: (angles[i-1],r) 
	loop info: Size j=0  j<i  ++j
	induction variable: ['i', 'j']
	{
	}
L5108: (m[i][i]=,w) 
	loop info: Size j=i+1  j<m.rows()  ++j
	induction variable: ['i', 'j']
	{
	}
 }
array table
-----------------------------------------------
m -> [('[i][i]', 'w', 'normalized', ['i', 'j'], 5108)]
LDEs formed:2

angles -> [('[i-1]', 'r', 'normalized', ['i', 'j'], 5106), ('[i-1]', 'r', 'normalized', ['i', 'j'], 5107)]
LDEs formed:0

distinct LDEs:
i1=i2,i1=i2
#########################################################################################
loop info: Size i=0  i<m.rows()  ++i
induction variable: ['i']
{
L5108: (m[i][0]=,w) 
L5109: (m[i][1]=,w) 
L5110: (m[i][2]=,w) 
}
array table
-----------------------------------------------
m -> [('[i][0]', 'w', 'normalized', ['i'], 5108), ('[i][1]', 'w', 'normalized', ['i'], 5109), ('[i][2]', 'w', 'normalized', ['i'], 5110)]
LDEs formed:12

distinct LDEs:
i1=i2,2=2
i1=i2,0=0
i1=i2,0=1
i1=i2,0=2
i1=i2,1=1
i1=i2,1=2
#########################################################################################
loop info: Size i=0  i<target_.rows()  ++i
induction variable: ['i']
{
	loop info: Size j=0  j<i  ++j
	induction variable: ['i', 'j']
	{
	L5111: (result[k]=,w) (differences[i][j],r) 
	}
 }
array table
-----------------------------------------------
differences -> [('[i][j]', 'r', 'normalized', ['i', 'j'], 5111)]
LDEs formed:0

result -> [('[k]', 'w', 'not normalized', ['i', 'j'], 5111)]
LDEs formed:1

distinct LDEs:
k=k
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/math/matrixutilities/sparseilupreconditioner.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Integer ii=0  ii<n  ++ii
induction variable: ['ii']
{
	loop info: Integer k=0  k<n  ++k
	induction variable: ['ii', 'k']
	{
	L5112: (w[k]=,w) 
	}
	loop info: Integer i=0  i<n  ++i
	induction variable: ['ii', 'k', 'i']
	{
	L5113: (w[i],r) 
	L5114: (w[i],r) (levii[i]=,w) 
	}
	loop info: Integer k=jj+1  k<n  ++k
	induction variable: ['ii', 'k', 'i']
		{
		L5115: (levii[k],r) 
		}
L5116: (levii[jj],r) 
	loop info:   iter != end  ++iter
	induction variable: ['ii', 'k', 'i', 'iter']
			{
			}
L5117: (w[jj],r) 
L5118: (nonZeroEntries[0],r) 
	loop info: Size k=0  k<nonZeros.size()  ++k
	induction variable: ['ii', 'k', 'i', 'iter']
			{
			L5119: (nonZeros[k],r) 
			L5120: (levii[j]==,r) 
			L5121: (w[j]=,w) (nonZeroEntries[k],r) 
			L5122: (levii[j]=,w) 
			L5123: (w[j]-=,w) (nonZeroEntries[k],r) 
			L5124: (levii[j]=,w) (levii[j],r) 
			}
L5125: (w[jj]=,w) 
	loop info: Size i=0  i<w.size()  ++i
	induction variable: ['ii', 'k', 'i', 'iter']
	{
	L5126: (w[i],r) 
	}
	loop info: Size i=0  i<levii.size()  ++i
	induction variable: ['ii', 'k', 'i', 'iter']
	{
	L5127: (levii[i],r) 
	}
L5128: (wNonZeros[k],r) 
L5129: (wNonZeroEntries[k],r) 
L5130: (wNonZeroEntries[k],r) 
L5131: (leviiNonZeroEntries[k],r) 
}
array table
-----------------------------------------------
levii -> [('[i]', 'w', 'normalized', ['ii', 'k', 'i', 'iter'], 5114), ('[k]', 'r', 'normalized', ['ii', 'k', 'i', 'iter'], 5115), ('[jj]', 'r', 'not normalized', ['ii', 'k', 'i', 'iter'], 5116), ('[j]', 'r', 'not normalized', ['ii', 'k', 'i', 'iter'], 5120), ('[j]', 'w', 'not normalized', ['ii', 'k', 'i', 'iter'], 5122), ('[j]', 'w', 'not normalized', ['ii', 'k', 'i', 'iter'], 5124), ('[j]', 'r', 'not normalized', ['ii', 'k', 'i', 'iter'], 5124), ('[i]', 'r', 'normalized', ['ii', 'k', 'i', 'iter'], 5127)]
LDEs formed:21

nonZeros -> [('[k]', 'r', 'normalized', ['ii', 'k', 'i', 'iter'], 5119)]
LDEs formed:0

nonZeroEntries -> [('[0]', 'r', 'normalized', ['ii', 'k', 'i', 'iter'], 5118), ('[k]', 'r', 'normalized', ['ii', 'k', 'i', 'iter'], 5121), ('[k]', 'r', 'normalized', ['ii', 'k', 'i', 'iter'], 5123)]
LDEs formed:0

wNonZeros -> [('[k]', 'r', 'normalized', ['ii', 'k', 'i', 'iter'], 5128)]
LDEs formed:0

wNonZeroEntries -> [('[k]', 'r', 'normalized', ['ii', 'k', 'i', 'iter'], 5129), ('[k]', 'r', 'normalized', ['ii', 'k', 'i', 'iter'], 5130)]
LDEs formed:0

w -> [('[k]', 'w', 'normalized', ['ii', 'k', 'i', 'iter'], 5112), ('[i]', 'r', 'normalized', ['ii', 'k', 'i', 'iter'], 5113), ('[i]', 'r', 'normalized', ['ii', 'k', 'i', 'iter'], 5114), ('[jj]', 'r', 'not normalized', ['ii', 'k', 'i', 'iter'], 5117), ('[j]', 'w', 'not normalized', ['ii', 'k', 'i', 'iter'], 5121), ('[j]', 'w', 'not normalized', ['ii', 'k', 'i', 'iter'], 5123), ('[jj]', 'w', 'not normalized', ['ii', 'k', 'i', 'iter'], 5125), ('[i]', 'r', 'normalized', ['ii', 'k', 'i', 'iter'], 5126)]
LDEs formed:26

leviiNonZeroEntries -> [('[k]', 'r', 'normalized', ['ii', 'k', 'i', 'iter'], 5131)]
LDEs formed:0

distinct LDEs:
j=j
i1=jj
i1=j
k1=jj
k1=j
jj=j
i1=k2
k1=k2
jj=jj
i1=i2
#########################################################################################
loop info: Integer i=1  i<=n-1  ++i
induction variable: ['i']
{
L5132: (y[i]=,w) (b[i]/,r) 
L5133: (lBands_[j],r) 
L5134: (lBands_[j],r) 
L5135: (y[i]-=,w) (y[k]/,r) 
}
array table
-----------------------------------------------
y -> [('[i]', 'w', 'normalized', ['i'], 5132), ('[i]', 'w', 'normalized', ['i'], 5135), ('[k]', 'r', 'not normalized', ['i'], 5135)]
LDEs formed:5

lBands_ -> [('[j]', 'r', 'not normalized', ['i'], 5133), ('[j]', 'r', 'not normalized', ['i'], 5134)]
LDEs formed:0

b -> [('[i]', 'r', 'normalized', ['i'], 5132)]
LDEs formed:0

distinct LDEs:
i1=k
i1=i2
#########################################################################################
loop info: Integer i=n-2  i>=0  --i
induction variable: ['i']
{
L5133: (x[i]=,w) (y[i]/,r) 
	loop info: Size j=0  j<uBands_.size() && i+uBands_[j] <= n-1  ++j
	induction variable: ['i', 'j']
	{
	L5134: (x[i]-=,w) (uBands_[j],r) (uBands_[j],r) 
	}
 }
array table
-----------------------------------------------
y -> [('[i]', 'r', 'normalized', ['i', 'j'], 5133)]
LDEs formed:0

x -> [('[i]', 'w', 'normalized', ['i', 'j'], 5133), ('[i]', 'w', 'normalized', ['i', 'j'], 5134)]
LDEs formed:3

uBands_ -> [('[j]', 'r', 'normalized', ['i', 'j'], 5134), ('[j]', 'r', 'normalized', ['i', 'j'], 5134)]
LDEs formed:0

distinct LDEs:
i1=i2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/math/matrixutilities/qrdecomposition.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i < n  ++i
induction variable: ['i']
{
L5135: (r[i][i]=,w) (rdiag[i],r) 
}
array table
-----------------------------------------------
r -> [('[i][i]', 'w', 'normalized', ['i'], 5135)]
LDEs formed:2

rdiag -> [('[i]', 'r', 'normalized', ['i'], 5135)]
LDEs formed:0

distinct LDEs:
i1=i2,i1=i2
#########################################################################################
loop info: Size k=0  k < m  ++k
induction variable: ['k']
{
L5136: (w[k]=,w) 
	loop info: Size j=0  j < std::min(n, m)  ++j
	induction variable: ['k', 'j']
	{
	L5137: (mT[j][j],r) 
		loop info: Size i=j  i<m  ++i
		induction variable: ['k', 'j', 'i']
			{
			L5138: (w[i]-=,w) (mT[j][i]*,r) 
			}
	L5139: (q[k][j]=,w) (w[j],r) 
	}
 }
array table
-----------------------------------------------
q -> [('[k][j]', 'w', 'normalized', ['k', 'j', 'i'], 5139)]
LDEs formed:2

mT -> [('[j][j]', 'r', 'normalized', ['k', 'j', 'i'], 5137), ('[j][i]', 'r', 'normalized', ['k', 'j', 'i'], 5138)]
LDEs formed:0

w -> [('[k]', 'w', 'normalized', ['k', 'j', 'i'], 5136), ('[i]', 'w', 'normalized', ['k', 'j', 'i'], 5138), ('[j]', 'r', 'normalized', ['k', 'j', 'i'], 5139)]
LDEs formed:5

distinct LDEs:
k1=j2
k1=k2
i1=i2
k1=k2,j1=j2
k1=i2
i1=j2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/math/matrixutilities/getcovariance.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<size  ++i
induction variable: ['i']
{
L5140: (stdDevs_[i]=,w) (variances_[i],r) 
L5141: (correlationMatrix_[i][i]=,w) 
	loop info: Size j=0  j<i  ++j
	induction variable: ['i', 'j']
	{
	L5142: (cov[i][j]-,r) (cov[j][i],r) 
	L5143: (nc[" << i << ", " << j << "]=,w) 
	L5144: (cov[i][j]<<,r) 
	L5145: (cov[j][i],r) 
	L5146: (correlationMatrix_[i][j]=,w) (correlationMatrix_[j][i]=,w) 
	L5147: (cov[i][j]/,r) (stdDevs_[i]*,r) (stdDevs_[j],r) 
	}
 }
array table
-----------------------------------------------
correlationMatrix_ -> [('[i][i]', 'w', 'normalized', ['i', 'j'], 5141), ('[i][j]', 'w', 'normalized', ['i', 'j'], 5146), ('[j][i]', 'w', 'normalized', ['i', 'j'], 5146)]
LDEs formed:12

nc -> [('[" << i << ", " << j << "]', 'w', 'normalized', ['i', 'j'], 5143)]
LDEs formed:1

variances_ -> [('[i]', 'r', 'normalized', ['i', 'j'], 5140)]
LDEs formed:0

stdDevs_ -> [('[i]', 'w', 'normalized', ['i', 'j'], 5140), ('[i]', 'r', 'normalized', ['i', 'j'], 5147), ('[j]', 'r', 'normalized', ['i', 'j'], 5147)]
LDEs formed:3

cov -> [('[i][j]', 'r', 'normalized', ['i', 'j'], 5142), ('[j][i]', 'r', 'normalized', ['i', 'j'], 5142), ('[i][j]', 'r', 'normalized', ['i', 'j'], 5144), ('[j][i]', 'r', 'normalized', ['i', 'j'], 5145), ('[i][j]', 'r', 'normalized', ['i', 'j'], 5147)]
LDEs formed:0

distinct LDEs:
j1=j2,i1=i2
" << i1 << ", " << j1 << "=" << i2 << ", " << j2 << "
i1=i2,j1=j2
i1=i2
i1=j2,i1=i2
i1=i2,i1=j2
i1=j2,j1=i2
i1=i2,i1=i2
i1=j2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/math/matrixutilities/factorreduction.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

L5148: (previousCorrels[iCol]=,w) 
L5149: (previousCorrels[iCol]-,r) 
}
array table
-----------------------------------------------
previousCorrels -> [('[iCol]', 'w', 'normalized', ['iCol', 'iRow'], 5148), ('[iCol]', 'r', 'normalized', ['iCol', 'iRow'], 5149)]
LDEs formed:2

distinct LDEs:
iCol1=iCol2
#########################################################################################
loop info: Size iCol=0  iCol<n  iCol++
induction variable: ['iCol']
{
L5150: (mtrx[iMax][iCol],r) 
L5151: (previousCorrels[iCol],r) 
L5152: (previousCorrels[iCol],r) 
}
array table
-----------------------------------------------
previousCorrels -> [('[iCol]', 'r', 'normalized', ['iCol'], 5151), ('[iCol]', 'r', 'normalized', ['iCol'], 5152)]
LDEs formed:0

mtrx -> [('[iMax][iCol]', 'r', 'not normalized', ['iCol'], 5150)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/math/statistics/histogram.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<breaks_.size()  ++i
induction variable: ['i']
{
L5151: (breaks_[i]=,w) 
}
array table
-----------------------------------------------
breaks_ -> [('[i]', 'w', 'normalized', ['i'], 5151)]
LDEs formed:1

distinct LDEs:
i1=i2
#########################################################################################
loop info: Size i=0  i<breaks_.size()  ++i
induction variable: ['i']
{
L5152: (breaks_[i],r) 
L5153: (++counts_[i],w) 
}
array table
-----------------------------------------------
counts_ -> [('[i]', 'w', 'normalized', ['i'], 5153)]
LDEs formed:1

breaks_ -> [('[i]', 'r', 'normalized', ['i'], 5152)]
LDEs formed:0

distinct LDEs:
i1=i2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/math/statistics/generalstatistics.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/math/statistics/discrepancystatistics.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: i=0  i<N  i++
induction variable: ['i']
{
	loop info: Size k=0  k<dimension_  k++
	induction variable: ['i', 'k']
	{
	L5153: (stats_[k].sampleData,r) 
	}
 }
array table
-----------------------------------------------
stats_ -> [('[k]', 'r', 'normalized', ['i', 'k'], 5153)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: i=0  i<N  i++
induction variable: ['i']
{
	loop info: Size j=0  j<N  j++
	induction variable: ['i', 'j']
	{
		loop info: Size k=0  k<dimension_  k++
		induction variable: ['i', 'j', 'k']
		{
		L5154: (stats_[k].sampleData,r) 
		L5155: (stats_[k].sampleData,r) 
		}
 	}
 }
array table
-----------------------------------------------
stats_ -> [('[k]', 'r', 'normalized', ['i', 'j', 'k'], 5154), ('[k]', 'r', 'normalized', ['i', 'j', 'k'], 5155)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/math/randomnumbers/knuthuniformrng.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: j=0 j<KK j++
induction variable: ['j']
{
L5156: (u[j]=,w) (ul[j]=,w) 
}
array table
-----------------------------------------------
ul -> [('[j]', 'w', 'normalized', ['j'], 5156)]
LDEs formed:1

u -> [('[j]', 'w', 'normalized', ['j'], 5156)]
LDEs formed:1

distinct LDEs:
j1=j2
#########################################################################################
loop info: j=KK+KK-2 j>=KK --j
induction variable: ['j']
{
L5157: (ul[j-(KK-LL)]=,w) (ul[j-(KK-LL)],r) 
L5158: (u[j-(KK-LL)]=,w) (u[j-(KK-LL)],r) (u[j],r) 
L5159: (ul[j-KK]=,w) (ul[j-KK],r) (u[j-KK]=,w) (u[j-KK],r) (u[j],r) 
}
array table
-----------------------------------------------
ul -> [('[j-(KK-LL)]', 'w', 'not normalized', ['j'], 5157), ('[j-(KK-LL)]', 'r', 'not normalized', ['j'], 5157), ('[j-KK]', 'w', 'not normalized', ['j'], 5159), ('[j-KK]', 'r', 'not normalized', ['j'], 5159)]
LDEs formed:7

u -> [('[j-(KK-LL)]', 'w', 'not normalized', ['j'], 5158), ('[j-(KK-LL)]', 'r', 'not normalized', ['j'], 5158), ('[j]', 'r', 'normalized', ['j'], 5158), ('[j-KK]', 'w', 'not normalized', ['j'], 5159), ('[j-KK]', 'r', 'not normalized', ['j'], 5159), ('[j]', 'r', 'normalized', ['j'], 5159)]
LDEs formed:11

distinct LDEs:
j1-(KK-LL)=j2
j1=j2-KK
j1-(KK-LL)=j2-(KK-LL)
j1-(KK-LL)=j2-KK
j1-KK=j2-KK
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/math/randomnumbers/mt19937uniformrng.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: mti=1  mti<N  mti++
induction variable: ['mti']
{
L5160: (mt[mti]=,w) 
L5161: (mt[mti-1]^,r) (mt[mti-1]>>,r) 
L5162: (mt[mti]&=,w) 
}
array table
-----------------------------------------------
mt -> [('[mti]', 'w', 'normalized', ['mti'], 5160), ('[mti-1]', 'r', 'normalized', ['mti'], 5161), ('[mti-1]', 'r', 'normalized', ['mti'], 5161), ('[mti]', 'w', 'normalized', ['mti'], 5162)]
LDEs formed:7

distinct LDEs:
mti1=mti2-1
mti1=mti2
#########################################################################################
loop info:   k  k--
induction variable: ['k']
{
L5163: (mt[i]=,w) (mt[i]^,r) (mt[i-1]^,r) (mt[i-1]>>,r) 
L5164: (seeds[j]+,r) 
L5165: (mt[i]&=,w) 
L5166: (mt[0]=,w) (mt[N-1],r) 
}
array table
-----------------------------------------------
mt -> [('[i]', 'w', 'not normalized', ['k'], 5163), ('[i]', 'r', 'not normalized', ['k'], 5163), ('[i-1]', 'r', 'not normalized', ['k'], 5163), ('[i-1]', 'r', 'not normalized', ['k'], 5163), ('[i]', 'w', 'not normalized', ['k'], 5165), ('[0]', 'w', 'normalized', ['k'], 5166), ('[N-1]', 'r', 'not normalized', ['k'], 5166)]
LDEs formed:18

seeds -> [('[j]', 'r', 'not normalized', ['k'], 5164)]
LDEs formed:0

distinct LDEs:
i=i-1
i=0
0=0
0=N-1
i=i
i-1=0
i=N-1
#########################################################################################
loop info: k=N-1  k  k--
induction variable: ['k']
{
L5165: (mt[i]=,w) (mt[i]^,r) (mt[i-1]^,r) (mt[i-1]>>,r) 
L5166: (mt[i]&=,w) 
L5167: (mt[0]=,w) (mt[N-1],r) 
}
array table
-----------------------------------------------
mt -> [('[i]', 'w', 'not normalized', ['k'], 5165), ('[i]', 'r', 'not normalized', ['k'], 5165), ('[i-1]', 'r', 'not normalized', ['k'], 5165), ('[i-1]', 'r', 'not normalized', ['k'], 5165), ('[i]', 'w', 'not normalized', ['k'], 5166), ('[0]', 'w', 'normalized', ['k'], 5167), ('[N-1]', 'r', 'not normalized', ['k'], 5167)]
LDEs formed:18

distinct LDEs:
i=i-1
i=0
0=0
0=N-1
i=i
i-1=0
i=N-1
#########################################################################################
loop info: kk=0 kk<N-M kk++
induction variable: ['kk']
{
L5168: (mt[kk]&,r) (mt[kk+1]&,r) 
L5169: (mt[kk]=,w) (mt[kk+M]^,r) (mag01[y & 0x1UL],r) 
}
array table
-----------------------------------------------
mt -> [('[kk]', 'r', 'normalized', ['kk'], 5168), ('[kk+1]', 'r', 'normalized', ['kk'], 5168), ('[kk]', 'w', 'normalized', ['kk'], 5169), ('[kk+M]', 'r', 'not normalized', ['kk'], 5169)]
LDEs formed:4

mag01 -> [('[y & 0x1UL]', 'r', 'not normalized', ['kk'], 5169)]
LDEs formed:0

distinct LDEs:
kk1+1=kk2
kk1=kk2
kk1=kk2+M
#########################################################################################
loop info:  kk<N-1 kk++
induction variable: ['kk']
{
L5170: (mt[kk]&,r) (mt[kk+1]&,r) 
L5171: (mt[kk]=,w) (mt[(kk+M)-N]^,r) (mag01[y & 0x1UL],r) 
}
array table
-----------------------------------------------
mt -> [('[kk]', 'r', 'normalized', ['kk'], 5170), ('[kk+1]', 'r', 'normalized', ['kk'], 5170), ('[kk]', 'w', 'normalized', ['kk'], 5171), ('[(kk+M)-N]', 'r', 'not normalized', ['kk'], 5171)]
LDEs formed:4

mag01 -> [('[y & 0x1UL]', 'r', 'not normalized', ['kk'], 5171)]
LDEs formed:0

distinct LDEs:
kk1+1=kk2
kk1=kk2
kk1=(kk2+M)-N
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/math/randomnumbers/faurersg.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

L5172: (powBase_[ii][j2]=,w) (powBase_[ii][j2+1]-,r) (powBase_[ii][base_],r) 
}
array table
-----------------------------------------------
powBase_ -> [('[ii][j2]', 'w', 'not normalized', ['ii', 'j1'], 5172), ('[ii][j2+1]', 'r', 'not normalized', ['ii', 'j1'], 5172), ('[ii][base_]', 'r', 'not normalized', ['ii', 'j1'], 5172)]
LDEs formed:6

distinct LDEs:
ii1=ii2,j2=base_
ii1=ii2,j2=j2
ii1=ii2,j2=j2+1
#########################################################################################
loop info: k=0  k<mbit_  k++
induction variable: ['k']
{
L5173: (pascal3D[k][0][k]=,w) 
L5174: (pascal3D[k][1][0]=,w) 
L5175: (pascal3D[k][1][k]=,w) 
}
array table
-----------------------------------------------
pascal3D -> [('[k][0][k]', 'w', 'normalized', ['k'], 5173), ('[k][1][0]', 'w', 'normalized', ['k'], 5174), ('[k][1][k]', 'w', 'normalized', ['k'], 5175)]
LDEs formed:18

distinct LDEs:
k1=k2,1=1,k1=k2
k1=k2,0=1,k1=k2
k1=k2,1=1,0=0
k1=k2,0=0,k1=k2
k1=k2,1=1,0=k2
k1=k2,0=1,k1=0
#########################################################################################
loop info: k=2  k<mbit_   k++
induction variable: ['k']
{
	loop info: i=1  i<k   i++
	induction variable: ['k', 'i']
	{
	L5176: (pascal3D[k-1][1][i-1],r) 
	L5177: (pascal3D[k-1][1][i],r) 
	L5178: (pascal3D[k][1][i]=,w) 
	}
 }
array table
-----------------------------------------------
pascal3D -> [('[k-1][1][i-1]', 'r', 'normalized', ['k', 'i'], 5176), ('[k-1][1][i]', 'r', 'normalized', ['k', 'i'], 5177), ('[k][1][i]', 'w', 'normalized', ['k', 'i'], 5178)]
LDEs formed:9

distinct LDEs:
k1-1=k2,1=1,i1-1=i2
k1-1=k2,1=1,i1=i2
k1=k2,1=1,i1=i2
#########################################################################################
loop info: Size i=0  i<dimensionality_   i++
induction variable: ['i']
{
	loop info: Size j=0  j<=bit   j++
	induction variable: ['i', 'j']
	{
	L5179: (gray_[i][j],r) 
	L5180: (gray_[i][j]=,w) (pascal3D[bit][i][j]+,r) 
	L5181: (gray_[i][j],r) 
	L5182: (integerSequence_[i]+=,w) (powBase_[j][g2],r) 
	}
 }
array table
-----------------------------------------------
powBase_ -> [('[j][g2]', 'r', 'not normalized', ['i', 'j'], 5182)]
LDEs formed:0

pascal3D -> [('[bit][i][j]', 'r', 'not normalized', ['i', 'j'], 5180)]
LDEs formed:0

integerSequence_ -> [('[i]', 'w', 'normalized', ['i', 'j'], 5182)]
LDEs formed:1

gray_ -> [('[i][j]', 'r', 'normalized', ['i', 'j'], 5179), ('[i][j]', 'w', 'normalized', ['i', 'j'], 5180), ('[i][j]', 'r', 'normalized', ['i', 'j'], 5181)]
LDEs formed:6

distinct LDEs:
i1=i2,j1=j2
i1=i2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/math/randomnumbers/latticersg.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size j=0  j < dimensionality_  ++j
induction variable: ['j']
{
L5182: (z_[j]/,r) 
L5183: (sequence_.value[j]=,w) 
}
array table
-----------------------------------------------
z_ -> [('[j]', 'r', 'normalized', ['j'], 5182)]
LDEs formed:0

sequence_.value -> [('[j]', 'w', 'normalized', ['j'], 5183)]
LDEs formed:1

distinct LDEs:
j1=j2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/math/randomnumbers/sobolrsg.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info:   k<std::min<Size>(dimensionality_,altDegree)  k++,index++
induction variable: ['k', 'index']
{
L5184: (ppmt[k]=,w) (AltPrimitivePolynomials[currentDegree-1][index],r) 
L5185: (ppmt[k]==,r) 
L5186: (ppmt[k]=,w) (AltPrimitivePolynomials[currentDegree-1][index],r) 
L5187: (degree[k]=,w) 
}
array table
-----------------------------------------------
AltPrimitivePolynomials -> [('[currentDegree-1][index]', 'r', 'not normalized', ['k', 'index'], 5184), ('[currentDegree-1][index]', 'r', 'not normalized', ['k', 'index'], 5186)]
LDEs formed:0

degree -> [('[k]', 'w', 'normalized', ['k', 'index'], 5187)]
LDEs formed:1

ppmt -> [('[k]', 'w', 'normalized', ['k', 'index'], 5184), ('[k]', 'r', 'normalized', ['k', 'index'], 5185), ('[k]', 'w', 'normalized', ['k', 'index'], 5186)]
LDEs formed:5

distinct LDEs:
k1=k2
#########################################################################################
loop info:   k<dimensionality_  k++,index++
induction variable: ['k', 'index']
{
L5187: (ppmt[k]=,w) (PrimitivePolynomials[currentDegree-1][index],r) 
L5188: (ppmt[k]==,r) 
L5189: (ppmt[k]=,w) (PrimitivePolynomials[currentDegree-1][index],r) 
L5190: (degree[k]=,w) 
}
array table
-----------------------------------------------
PrimitivePolynomials -> [('[currentDegree-1][index]', 'r', 'not normalized', ['k', 'index'], 5187), ('[currentDegree-1][index]', 'r', 'not normalized', ['k', 'index'], 5189)]
LDEs formed:0

degree -> [('[k]', 'w', 'normalized', ['k', 'index'], 5190)]
LDEs formed:1

ppmt -> [('[k]', 'w', 'normalized', ['k', 'index'], 5187), ('[k]', 'r', 'normalized', ['k', 'index'], 5188), ('[k]', 'w', 'normalized', ['k', 'index'], 5189)]
LDEs formed:5

distinct LDEs:
k1=k2
#########################################################################################
loop info: k=1  k<maxTabulated  k++
induction variable: ['k']
{
	loop info: Size l=1  l<=degree[k]  l++
	induction variable: ['k', 'l']
	{
	L5190: (directionIntegers_[k][l-1]=,w) 
	L5191: (directionIntegers_[k][l-1]<<=,w) 
	}
 }
array table
-----------------------------------------------
directionIntegers_ -> [('[k][l-1]', 'w', 'normalized', ['k', 'l'], 5190), ('[k][l-1]', 'w', 'normalized', ['k', 'l'], 5191)]
LDEs formed:6

distinct LDEs:
k1=k2,l1-1=l2-1
#########################################################################################
loop info: k=1  k<std::min(dimensionality_, maxTabulated)  k++
induction variable: ['k']
{
L5192: (initializers[k-1][j],r) 
L5193: (directionIntegers_[k][j]=,w) (initializers[k-1][j],r) 
L5194: (directionIntegers_[k][j]<<=,w) 
}
array table
-----------------------------------------------
initializers -> [('[k-1][j]', 'r', 'not normalized', ['k'], 5192), ('[k-1][j]', 'r', 'not normalized', ['k'], 5193)]
LDEs formed:0

directionIntegers_ -> [('[k][j]', 'w', 'not normalized', ['k'], 5193), ('[k][j]', 'w', 'not normalized', ['k'], 5194)]
LDEs formed:6

distinct LDEs:
k1=k2,j=j
#########################################################################################
loop info: k=1  k<std::min(dimensionality_, maxTabulated)  k++
induction variable: ['k']
{
L5195: (SLinitializers[k-1][j],r) 
L5196: (directionIntegers_[k][j]=,w) (SLinitializers[k-1][j],r) 
L5197: (directionIntegers_[k][j]<<=,w) 
}
array table
-----------------------------------------------
SLinitializers -> [('[k-1][j]', 'r', 'not normalized', ['k'], 5195), ('[k-1][j]', 'r', 'not normalized', ['k'], 5196)]
LDEs formed:0

directionIntegers_ -> [('[k][j]', 'w', 'not normalized', ['k'], 5196), ('[k][j]', 'w', 'not normalized', ['k'], 5197)]
LDEs formed:6

distinct LDEs:
k1=k2,j=j
#########################################################################################
loop info: k=1  k<std::min(dimensionality_, maxTabulated)  k++
induction variable: ['k']
{
L5198: (Linitializers[k-1][j],r) 
L5199: (directionIntegers_[k][j]=,w) (Linitializers[k-1][j],r) 
L5200: (directionIntegers_[k][j]<<=,w) 
}
array table
-----------------------------------------------
directionIntegers_ -> [('[k][j]', 'w', 'not normalized', ['k'], 5199), ('[k][j]', 'w', 'not normalized', ['k'], 5200)]
LDEs formed:6

Linitializers -> [('[k-1][j]', 'r', 'not normalized', ['k'], 5198), ('[k-1][j]', 'r', 'not normalized', ['k'], 5199)]
LDEs formed:0

distinct LDEs:
k1=k2,j=j
#########################################################################################
loop info: k=1  k<std::min(dimensionality_, maxTabulated)  k++
induction variable: ['k']
{
L5200: (JoeKuoD5initializers[k-1][j],r) 
L5201: (directionIntegers_[k][j]=,w) (JoeKuoD5initializers[k-1][j],r) 
L5202: (directionIntegers_[k][j]<<=,w) 
}
array table
-----------------------------------------------
directionIntegers_ -> [('[k][j]', 'w', 'not normalized', ['k'], 5201), ('[k][j]', 'w', 'not normalized', ['k'], 5202)]
LDEs formed:6

JoeKuoD5initializers -> [('[k-1][j]', 'r', 'not normalized', ['k'], 5200), ('[k-1][j]', 'r', 'not normalized', ['k'], 5201)]
LDEs formed:0

distinct LDEs:
k1=k2,j=j
#########################################################################################
loop info: k=1  k<std::min(dimensionality_, maxTabulated)  k++
induction variable: ['k']
{
L5202: (JoeKuoD6initializers[k-1][j],r) 
L5203: (directionIntegers_[k][j]=,w) (JoeKuoD6initializers[k-1][j],r) 
L5204: (directionIntegers_[k][j]<<=,w) 
}
array table
-----------------------------------------------
directionIntegers_ -> [('[k][j]', 'w', 'not normalized', ['k'], 5203), ('[k][j]', 'w', 'not normalized', ['k'], 5204)]
LDEs formed:6

JoeKuoD6initializers -> [('[k-1][j]', 'r', 'not normalized', ['k'], 5202), ('[k-1][j]', 'r', 'not normalized', ['k'], 5203)]
LDEs formed:0

distinct LDEs:
k1=k2,j=j
#########################################################################################
loop info: k=1  k<std::min(dimensionality_, maxTabulated)  k++
induction variable: ['k']
{
L5204: (JoeKuoD7initializers[k-1][j],r) 
L5205: (directionIntegers_[k][j]=,w) (JoeKuoD7initializers[k-1][j],r) 
L5206: (directionIntegers_[k][j]<<=,w) 
}
array table
-----------------------------------------------
JoeKuoD7initializers -> [('[k-1][j]', 'r', 'not normalized', ['k'], 5204), ('[k-1][j]', 'r', 'not normalized', ['k'], 5205)]
LDEs formed:0

directionIntegers_ -> [('[k][j]', 'w', 'not normalized', ['k'], 5205), ('[k][j]', 'w', 'not normalized', ['k'], 5206)]
LDEs formed:6

distinct LDEs:
k1=k2,j=j
#########################################################################################
loop info: k=1  k<std::min(dimensionality_, maxTabulated)  k++
induction variable: ['k']
{
L5207: (Kuoinitializers[k-1][j],r) 
L5208: (directionIntegers_[k][j]=,w) (Kuoinitializers[k-1][j],r) 
L5209: (directionIntegers_[k][j]<<=,w) 
}
array table
-----------------------------------------------
Kuoinitializers -> [('[k-1][j]', 'r', 'not normalized', ['k'], 5207), ('[k-1][j]', 'r', 'not normalized', ['k'], 5208)]
LDEs formed:0

directionIntegers_ -> [('[k][j]', 'w', 'not normalized', ['k'], 5208), ('[k][j]', 'w', 'not normalized', ['k'], 5209)]
LDEs formed:6

distinct LDEs:
k1=k2,j=j
#########################################################################################
loop info: k=1  k<std::min(dimensionality_, maxTabulated)  k++
induction variable: ['k']
{
L5210: (Kuo2initializers[k-1][j],r) 
L5211: (directionIntegers_[k][j]=,w) (Kuo2initializers[k-1][j],r) 
L5212: (directionIntegers_[k][j]<<=,w) 
}
array table
-----------------------------------------------
directionIntegers_ -> [('[k][j]', 'w', 'not normalized', ['k'], 5211), ('[k][j]', 'w', 'not normalized', ['k'], 5212)]
LDEs formed:6

Kuo2initializers -> [('[k-1][j]', 'r', 'not normalized', ['k'], 5210), ('[k-1][j]', 'r', 'not normalized', ['k'], 5211)]
LDEs formed:0

distinct LDEs:
k1=k2,j=j
#########################################################################################
loop info: k=1  k<std::min(dimensionality_, maxTabulated)  k++
induction variable: ['k']
{
L5212: (Kuo3initializers[k-1][j],r) 
L5213: (directionIntegers_[k][j]=,w) (Kuo3initializers[k-1][j],r) 
L5214: (directionIntegers_[k][j]<<=,w) 
}
array table
-----------------------------------------------
Kuo3initializers -> [('[k-1][j]', 'r', 'not normalized', ['k'], 5212), ('[k-1][j]', 'r', 'not normalized', ['k'], 5213)]
LDEs formed:0

directionIntegers_ -> [('[k][j]', 'w', 'not normalized', ['k'], 5213), ('[k][j]', 'w', 'not normalized', ['k'], 5214)]
LDEs formed:6

distinct LDEs:
k1=k2,j=j
#########################################################################################
loop info: k=maxTabulated  k<dimensionality_  k++
induction variable: ['k']
{
	loop info: Size l=1  l<=degree[k]  l++
	induction variable: ['k', 'l']
	{
	L5215: (directionIntegers_[k][l-1]=,w) 
	L5216: (directionIntegers_[k][l-1]&,r) 
	L5217: (directionIntegers_[k][l-1]<<=,w) 
	}
 }
array table
-----------------------------------------------
directionIntegers_ -> [('[k][l-1]', 'w', 'normalized', ['k', 'l'], 5215), ('[k][l-1]', 'r', 'normalized', ['k', 'l'], 5216), ('[k][l-1]', 'w', 'normalized', ['k', 'l'], 5217)]
LDEs formed:10

distinct LDEs:
k1=k2,l1-1=l2-1
#########################################################################################
loop info: k=1  k<dimensionality_  k++
induction variable: ['k']
{
L5218: (degree[k],r) 
	loop info: int l=gk  l<bits_  l++
	induction variable: ['k', 'l']
	{
	L5219: (directionIntegers_[k][l-gk]>>,r) 
	L5220: (a[k][j],r) (ppmt[k],r) 
	L5221: (a[k][0],r) 
	L5222: (a[k][gk],r) 
	L5223: (ppmt[k],r) 
	L5224: (a[k][j]=,w) (ppmt[k]>>,r) 
		loop info: Size j=1  j<gk  j++
		induction variable: ['k', 'l', 'j']
		{
		L5225: (a[k][j],r) 
		L5226: (ppmt[k]>>,r) 
		L5227: (directionIntegers_[k][l-j],r) 
		}
	L5228: (a[k][gk],r) (directionIntegers_[k][l-gk],r) 
	L5229: (directionIntegers_[k][l-gk],r) 
	L5230: (directionIntegers_[k][l]=,w) 
	}
 }
array table
-----------------------------------------------
a -> [('[k][j]', 'r', 'not normalized', ['k', 'l', 'j'], 5220), ('[k][0]', 'r', 'normalized', ['k', 'l', 'j'], 5221), ('[k][gk]', 'r', 'not normalized', ['k', 'l', 'j'], 5222), ('[k][j]', 'w', 'not normalized', ['k', 'l', 'j'], 5224), ('[k][j]', 'r', 'normalized', ['k', 'l', 'j'], 5225), ('[k][gk]', 'r', 'not normalized', ['k', 'l', 'j'], 5228)]
LDEs formed:12

directionIntegers_ -> [('[k][l-gk]', 'r', 'not normalized', ['k', 'l', 'j'], 5219), ('[k][l-j]', 'r', 'normalized', ['k', 'l', 'j'], 5227), ('[k][l-gk]', 'r', 'not normalized', ['k', 'l', 'j'], 5228), ('[k][l-gk]', 'r', 'not normalized', ['k', 'l', 'j'], 5229), ('[k][l]', 'w', 'normalized', ['k', 'l', 'j'], 5230)]
LDEs formed:10

degree -> [('[k]', 'r', 'normalized', ['k', 'l', 'j'], 5218)]
LDEs formed:0

ppmt -> [('[k]', 'r', 'normalized', ['k', 'l', 'j'], 5220), ('[k]', 'r', 'normalized', ['k', 'l', 'j'], 5223), ('[k]', 'r', 'normalized', ['k', 'l', 'j'], 5224), ('[k]', 'r', 'normalized', ['k', 'l', 'j'], 5226)]
LDEs formed:0

distinct LDEs:
k1=k2,0=j2
k1=k2,l1=l2
k1=k2,l1-j1=l2
k1=k2,l1-gk=l2
k1=k2,j1=j2
k1=k2,gk=j2
#########################################################################################
loop info: k=0  k<std::min(32UL,dimensionality_)  k++
induction variable: ['k']
{
L5227: (degree[k]<<,r) 
L5228: (ppmt[k]<<,r) 
	loop info: j=0  j<10  j++
	induction variable: ['k', 'j']
	{
	L5229: (directionIntegers_[k][j],r) 
	}
 }
array table
-----------------------------------------------
directionIntegers_ -> [('[k][j]', 'r', 'normalized', ['k', 'j'], 5229)]
LDEs formed:0

degree -> [('[k]', 'r', 'normalized', ['k', 'j'], 5227)]
LDEs formed:0

ppmt -> [('[k]', 'r', 'normalized', ['k', 'j'], 5228)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: k=0  k<dimensionality_  k++
induction variable: ['k']
{
L5229: (integerSequence_[k]=,w) (directionIntegers_[k][0],r) 
}
array table
-----------------------------------------------
directionIntegers_ -> [('[k][0]', 'r', 'normalized', ['k'], 5229)]
LDEs formed:0

integerSequence_ -> [('[k]', 'w', 'normalized', ['k'], 5229)]
LDEs formed:1

distinct LDEs:
k1=k2
#########################################################################################
loop info: Size k=0  k<dimensionality_  k++
induction variable: ['k']
{
L5230: (integerSequence_[k]=,w) 
	loop info: Size index=0  index<ops  index++
	induction variable: ['k', 'index']
	{
	L5231: (integerSequence_[k]^=,w) (directionIntegers_[k][index],r) 
	}
 }
array table
-----------------------------------------------
directionIntegers_ -> [('[k][index]', 'r', 'normalized', ['k', 'index'], 5231)]
LDEs formed:0

integerSequence_ -> [('[k]', 'w', 'normalized', ['k', 'index'], 5230), ('[k]', 'w', 'normalized', ['k', 'index'], 5231)]
LDEs formed:3

distinct LDEs:
k1=k2
#########################################################################################
loop info: Size k=0  k<dimensionality_  k++
induction variable: ['k']
{
L5232: (integerSequence_[k]^=,w) (directionIntegers_[k][j],r) 
}
array table
-----------------------------------------------
directionIntegers_ -> [('[k][j]', 'r', 'not normalized', ['k'], 5232)]
LDEs formed:0

integerSequence_ -> [('[k]', 'w', 'normalized', ['k'], 5232)]
LDEs formed:1

distinct LDEs:
k1=k2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/math/randomnumbers/lecuyeruniformrng.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: int j=bufferSize+7  j>=0  j--
induction variable: ['j']
{
L5233: (buffer[j]=,w) 
}
array table
-----------------------------------------------
buffer -> [('[j]', 'w', 'normalized', ['j'], 5233)]
LDEs formed:1

distinct LDEs:
j1=j2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/math/randomnumbers/seedgenerator.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/math/randomnumbers/haltonrsg.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<dimensionality_  ++i
induction variable: ['i']
{
L5234: (randomStart_[i],r) 
L5235: (sequence_.value[i]=,w) (randomShift_[i],r) 
L5236: (sequence_.value[i]-=,w) (sequence_.value[i],r) 
}
array table
-----------------------------------------------
sequence_.value -> [('[i]', 'w', 'normalized', ['i'], 5235), ('[i]', 'w', 'normalized', ['i'], 5236), ('[i]', 'r', 'normalized', ['i'], 5236)]
LDEs formed:5

randomShift_ -> [('[i]', 'r', 'normalized', ['i'], 5235)]
LDEs formed:0

randomStart_ -> [('[i]', 'r', 'normalized', ['i'], 5234)]
LDEs formed:0

distinct LDEs:
i1=i2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/math/randomnumbers/sobolbrownianbridgersg.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/math/optimization/lmdif.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info:  i=0  i<n  i++ 
induction variable: ['i']
{
L5235: (x[i],r) 
}
array table
-----------------------------------------------
x -> [('[i]', 'r', 'normalized', ['i'], 5235)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info:  j=0  j<n  j++ 
induction variable: ['j']
{
L5236: (x[j],r) 
L5237: (x[j]=,w) 
L5238: (x[j]=,w) 
	loop info:  i=0  i<m  i++ 
	induction variable: ['j', 'i']
	{
	L5239: (fjac[ij]=,w) (wa[i]-,r) (fvec[i],r) 
	L5240: (fjac[i+m*j]*,r) 
	}
 }
array table
-----------------------------------------------
x -> [('[j]', 'r', 'normalized', ['j', 'i'], 5236), ('[j]', 'w', 'normalized', ['j', 'i'], 5237), ('[j]', 'w', 'normalized', ['j', 'i'], 5238)]
LDEs formed:5

fjac -> [('[ij]', 'w', 'not normalized', ['j', 'i'], 5239), ('[i+m*j]', 'r', 'not normalized', ['j', 'i'], 5240)]
LDEs formed:2

wa -> [('[i]', 'r', 'normalized', ['j', 'i'], 5239)]
LDEs formed:0

fvec -> [('[i]', 'r', 'normalized', ['j', 'i'], 5239)]
LDEs formed:0

distinct LDEs:
j1=j2
ij=ij
ij=i2+m*j2
#########################################################################################
loop info:  j=0  j<n  j++ 
induction variable: ['j']
{
L5240: (acnorm[j]=,w) (a[ij],r) 
L5241: (rdiag[j]=,w) (acnorm[j],r) 
L5242: (wa[j]=,w) (rdiag[j],r) 
L5243: (ipvt[j]=,w) 
}
array table
-----------------------------------------------
a -> [('[ij]', 'r', 'not normalized', ['j'], 5240)]
LDEs formed:0

acnorm -> [('[j]', 'w', 'normalized', ['j'], 5240), ('[j]', 'r', 'normalized', ['j'], 5241)]
LDEs formed:2

wa -> [('[j]', 'w', 'normalized', ['j'], 5242)]
LDEs formed:1

rdiag -> [('[j]', 'w', 'normalized', ['j'], 5241), ('[j]', 'r', 'normalized', ['j'], 5242)]
LDEs formed:2

ipvt -> [('[j]', 'w', 'normalized', ['j'], 5243)]
LDEs formed:1

distinct LDEs:
j1=j2
#########################################################################################
loop info:  j=0  j<minmn  j++ 
induction variable: ['j']
{
	loop info:  k=j  k<n  k++ 
	induction variable: ['j', 'k']
	{
	L5244: (rdiag[k],r) (rdiag[kmax],r) 
	}
	loop info:  i=0  i<m  i++ 
	induction variable: ['j', 'k', 'i']
	{
	L5245: (a[ij],r) 
	L5246: (a[ij]=,w) (a[jj],r) 
	L5247: (a[jj]=,w) 
	}
L5248: (rdiag[kmax]=,w) (rdiag[j],r) 
L5249: (wa[kmax]=,w) (wa[j],r) 
L5250: (ipvt[j],r) 
L5251: (ipvt[j]=,w) (ipvt[kmax],r) 
L5252: (ipvt[kmax]=,w) 
L5253: (a[jj],r) 
L5254: (a[jj],r) 
	loop info:  i=j  i<m  i++ 
	induction variable: ['j', 'k', 'i']
	{
	L5255: (a[ij]/=,w) 
	}
L5256: (a[jj]+=,w) 
	loop info:  k=jp1  k<n  k++ 
	induction variable: ['j', 'k', 'i']
		{
			loop info:  i=j  i<m  i++ 
			induction variable: ['j', 'k', 'i']
			{
			L5257: (a[jj]*,r) (a[ij],r) 
			}
		L5258: (a[j+m*j],r) 
			loop info:  i=j  i<m  i++ 
			induction variable: ['j', 'k', 'i']
			{
			L5259: (a[ij]-=,w) (a[jj],r) 
			}
		L5260: (rdiag[k],r) 
		L5261: (a[j+m*k]/,r) (rdiag[k],r) 
		L5262: (rdiag[k]*=,w) 
		L5263: (rdiag[k]/,r) (wa[k],r) 
		L5264: (rdiag[k]=,w) (a[jp1+m*k],r) 
		L5265: (wa[k]=,w) (rdiag[k],r) 
		}
L5266: (rdiag[j]=,w) 
}
array table
-----------------------------------------------
a -> [('[ij]', 'r', 'not normalized', ['j', 'k', 'i'], 5245), ('[ij]', 'w', 'not normalized', ['j', 'k', 'i'], 5246), ('[jj]', 'r', 'not normalized', ['j', 'k', 'i'], 5246), ('[jj]', 'w', 'not normalized', ['j', 'k', 'i'], 5247), ('[jj]', 'r', 'not normalized', ['j', 'k', 'i'], 5253), ('[jj]', 'r', 'not normalized', ['j', 'k', 'i'], 5254), ('[ij]', 'w', 'not normalized', ['j', 'k', 'i'], 5255), ('[jj]', 'w', 'not normalized', ['j', 'k', 'i'], 5256), ('[jj]', 'r', 'not normalized', ['j', 'k', 'i'], 5257), ('[ij]', 'r', 'not normalized', ['j', 'k', 'i'], 5257), ('[j+m*j]', 'r', 'not normalized', ['j', 'k', 'i'], 5258), ('[ij]', 'w', 'not normalized', ['j', 'k', 'i'], 5259), ('[jj]', 'r', 'not normalized', ['j', 'k', 'i'], 5259), ('[j+m*k]', 'r', 'not normalized', ['j', 'k', 'i'], 5261), ('[jp1+m*k]', 'r', 'not normalized', ['j', 'k', 'i'], 5264)]
LDEs formed:65

wa -> [('[kmax]', 'w', 'not normalized', ['j', 'k', 'i'], 5249), ('[j]', 'r', 'normalized', ['j', 'k', 'i'], 5249), ('[k]', 'r', 'normalized', ['j', 'k', 'i'], 5263), ('[k]', 'w', 'normalized', ['j', 'k', 'i'], 5265)]
LDEs formed:7

rdiag -> [('[k]', 'r', 'normalized', ['j', 'k', 'i'], 5244), ('[kmax]', 'r', 'not normalized', ['j', 'k', 'i'], 5244), ('[kmax]', 'w', 'not normalized', ['j', 'k', 'i'], 5248), ('[j]', 'r', 'normalized', ['j', 'k', 'i'], 5248), ('[k]', 'r', 'normalized', ['j', 'k', 'i'], 5260), ('[k]', 'r', 'normalized', ['j', 'k', 'i'], 5261), ('[k]', 'w', 'normalized', ['j', 'k', 'i'], 5262), ('[k]', 'r', 'normalized', ['j', 'k', 'i'], 5263), ('[k]', 'w', 'normalized', ['j', 'k', 'i'], 5264), ('[k]', 'r', 'normalized', ['j', 'k', 'i'], 5265), ('[j]', 'w', 'normalized', ['j', 'k', 'i'], 5266)]
LDEs formed:38

ipvt -> [('[j]', 'r', 'normalized', ['j', 'k', 'i'], 5250), ('[j]', 'w', 'normalized', ['j', 'k', 'i'], 5251), ('[kmax]', 'r', 'not normalized', ['j', 'k', 'i'], 5251), ('[kmax]', 'w', 'not normalized', ['j', 'k', 'i'], 5252)]
LDEs formed:7

distinct LDEs:
ij=jp1+m*k2
ij=ij
j1=k2
ij=j2+m*j2
jj=j2+m*k2
ij=j2+m*k2
ij=jj
kmax=j2
jj=jj
kmax=kmax
j1=j2
k1=k2
jj=j2+m*j2
kmax=k2
jj=jp1+m*k2
#########################################################################################
loop info:  j=0  j<n  j++ 
induction variable: ['j']
{
	loop info:  i=j  i<n  i++ 
	induction variable: ['j', 'i']
	{
	L5253: (r[ij]=,w) (r[ik],r) 
	}
L5254: (x[j]=,w) (r[kk],r) 
L5255: (wa[j]=,w) (qtb[j],r) 
}
array table
-----------------------------------------------
x -> [('[j]', 'w', 'normalized', ['j', 'i'], 5254)]
LDEs formed:1

r -> [('[ij]', 'w', 'not normalized', ['j', 'i'], 5253), ('[ik]', 'r', 'not normalized', ['j', 'i'], 5253), ('[kk]', 'r', 'not normalized', ['j', 'i'], 5254)]
LDEs formed:3

qtb -> [('[j]', 'r', 'normalized', ['j', 'i'], 5255)]
LDEs formed:0

wa -> [('[j]', 'w', 'normalized', ['j', 'i'], 5255)]
LDEs formed:1

distinct LDEs:
j1=j2
ij=kk
ij=ij
ij=ik
#########################################################################################
loop info:  j=0  j<n  j++ 
induction variable: ['j']
{
L5256: (ipvt[j],r) 
L5257: (diag[l]==,r) 
	loop info:  k=j  k<n  k++ 
	induction variable: ['j', 'k']
	{
	}
L5258: (sdiag[j]=,w) (diag[l],r) 
	loop info:  k=j  k<n  k++ 
	induction variable: ['j', 'k']
	{
	L5259: (sdiag[k]==,r) 
	L5260: (r[kk],r) (sdiag[k],r) 
	L5261: (r[kk]/,r) (sdiag[k],r) 
	L5262: (sdiag[k]/,r) (r[kk],r) 
	L5263: (r[kk]=,w) (r[kk]+,r) (sdiag[k],r) 
	L5264: (wa[k]+,r) 
	L5265: (wa[k]+,r) 
	L5266: (wa[k]=,w) 
		loop info:  i=kp1  i<n  i++ 
		induction variable: ['j', 'k', 'i']
			{
			L5267: (r[ik]+,r) (sdiag[i],r) 
			L5268: (sdiag[i]=,w) (r[ik]+,r) (sdiag[i],r) 
			L5269: (r[ik]=,w) 
			}
 	}
L5270: (sdiag[j]=,w) (r[kk],r) 
L5271: (r[kk]=,w) (x[j],r) 
}
array table
-----------------------------------------------
wa -> [('[k]', 'r', 'normalized', ['j', 'k', 'i'], 5264), ('[k]', 'r', 'normalized', ['j', 'k', 'i'], 5265), ('[k]', 'w', 'normalized', ['j', 'k', 'i'], 5266)]
LDEs formed:3

diag -> [('[l]', 'r', 'not normalized', ['j', 'k', 'i'], 5257), ('[l]', 'r', 'not normalized', ['j', 'k', 'i'], 5258)]
LDEs formed:0

r -> [('[kk]', 'r', 'not normalized', ['j', 'k', 'i'], 5260), ('[kk]', 'r', 'not normalized', ['j', 'k', 'i'], 5261), ('[kk]', 'r', 'not normalized', ['j', 'k', 'i'], 5262), ('[kk]', 'w', 'not normalized', ['j', 'k', 'i'], 5263), ('[kk]', 'r', 'not normalized', ['j', 'k', 'i'], 5263), ('[ik]', 'r', 'not normalized', ['j', 'k', 'i'], 5267), ('[ik]', 'r', 'not normalized', ['j', 'k', 'i'], 5268), ('[ik]', 'w', 'not normalized', ['j', 'k', 'i'], 5269), ('[kk]', 'r', 'not normalized', ['j', 'k', 'i'], 5270), ('[kk]', 'w', 'not normalized', ['j', 'k', 'i'], 5271)]
LDEs formed:27

ipvt -> [('[j]', 'r', 'normalized', ['j', 'k', 'i'], 5256)]
LDEs formed:0

sdiag -> [('[j]', 'w', 'normalized', ['j', 'k', 'i'], 5258), ('[k]', 'r', 'normalized', ['j', 'k', 'i'], 5259), ('[k]', 'r', 'normalized', ['j', 'k', 'i'], 5260), ('[k]', 'r', 'normalized', ['j', 'k', 'i'], 5261), ('[k]', 'r', 'normalized', ['j', 'k', 'i'], 5262), ('[k]', 'r', 'normalized', ['j', 'k', 'i'], 5263), ('[i]', 'r', 'normalized', ['j', 'k', 'i'], 5267), ('[i]', 'w', 'normalized', ['j', 'k', 'i'], 5268), ('[i]', 'r', 'normalized', ['j', 'k', 'i'], 5268), ('[j]', 'w', 'normalized', ['j', 'k', 'i'], 5270)]
LDEs formed:27

x -> [('[j]', 'r', 'normalized', ['j', 'k', 'i'], 5271)]
LDEs formed:0

distinct LDEs:
ik=ik
j1=k2
kk=kk
kk=ik
k1=k2
i1=i2
j1=j2
j1=i2
k1=i2
#########################################################################################
loop info:  j=0  j<n  j++ 
induction variable: ['j']
{
L5272: (sdiag[j]==,r) 
L5273: (wa[j]=,w) 
}
array table
-----------------------------------------------
sdiag -> [('[j]', 'r', 'normalized', ['j'], 5272)]
LDEs formed:0

wa -> [('[j]', 'w', 'normalized', ['j'], 5273)]
LDEs formed:1

distinct LDEs:
j1=j2
#########################################################################################
loop info:  k=0  k<nsing  k++ 
induction variable: ['k']
{
	loop info:  i=jp1  i<nsing  i++ 
	induction variable: ['k', 'i']
		{
		L5274: (r[ij]*,r) (wa[i],r) 
		}
L5275: (wa[j]=,w) (wa[j]-,r) (sdiag[j],r) 
}
array table
-----------------------------------------------
r -> [('[ij]', 'r', 'not normalized', ['k', 'i'], 5274)]
LDEs formed:0

wa -> [('[i]', 'r', 'normalized', ['k', 'i'], 5274), ('[j]', 'w', 'not normalized', ['k', 'i'], 5275), ('[j]', 'r', 'not normalized', ['k', 'i'], 5275)]
LDEs formed:3

sdiag -> [('[j]', 'r', 'not normalized', ['k', 'i'], 5275)]
LDEs formed:0

distinct LDEs:
j=j
i1=j
#########################################################################################
loop info:  j=0  j<n  j++ 
induction variable: ['j']
{
L5276: (ipvt[j],r) 
L5277: (x[l]=,w) (wa[j],r) 
}
array table
-----------------------------------------------
x -> [('[l]', 'w', 'not normalized', ['j'], 5277)]
LDEs formed:1

ipvt -> [('[j]', 'r', 'normalized', ['j'], 5276)]
LDEs formed:0

wa -> [('[j]', 'r', 'normalized', ['j'], 5277)]
LDEs formed:0

distinct LDEs:
l=l
#########################################################################################
loop info:  j=0  j<n  j++ 
induction variable: ['j']
{
L5278: (wa1[j]=,w) (qtb[j],r) 
L5279: (r[jj]==,r) 
L5280: (wa1[j]=,w) 
}
array table
-----------------------------------------------
r -> [('[jj]', 'r', 'not normalized', ['j'], 5279)]
LDEs formed:0

qtb -> [('[j]', 'r', 'normalized', ['j'], 5278)]
LDEs formed:0

wa1 -> [('[j]', 'w', 'normalized', ['j'], 5278), ('[j]', 'w', 'normalized', ['j'], 5280)]
LDEs formed:3

distinct LDEs:
j1=j2
#########################################################################################
loop info:  k=0  k<nsing  k++ 
induction variable: ['k']
{
L5281: (wa1[j]=,w) (wa1[j]/,r) (r[j+ldr*j],r) 
L5282: (wa1[j],r) 
	loop info:  i=0  i<=jm1  i++ 
	induction variable: ['k', 'i']
		{
		L5283: (wa1[i]-=,w) (r[ij]*,r) 
		}
 }
array table
-----------------------------------------------
r -> [('[j+ldr*j]', 'r', 'not normalized', ['k', 'i'], 5281), ('[ij]', 'r', 'not normalized', ['k', 'i'], 5283)]
LDEs formed:0

wa1 -> [('[j]', 'w', 'not normalized', ['k', 'i'], 5281), ('[j]', 'r', 'not normalized', ['k', 'i'], 5281), ('[j]', 'r', 'not normalized', ['k', 'i'], 5282), ('[i]', 'w', 'normalized', ['k', 'i'], 5283)]
LDEs formed:7

distinct LDEs:
j=j
j=i2
i1=i2
#########################################################################################
loop info:  j=0  j<n  j++ 
induction variable: ['j']
{
L5284: (ipvt[j],r) 
L5285: (x[l]=,w) (wa1[j],r) 
}
array table
-----------------------------------------------
x -> [('[l]', 'w', 'not normalized', ['j'], 5285)]
LDEs formed:1

ipvt -> [('[j]', 'r', 'normalized', ['j'], 5284)]
LDEs formed:0

wa1 -> [('[j]', 'r', 'normalized', ['j'], 5285)]
LDEs formed:0

distinct LDEs:
l=l
#########################################################################################
loop info:  j=0  j<n  j++ 
induction variable: ['j']
{
L5286: (ipvt[j],r) 
L5287: (wa1[j]=,w) (diag[l]*,r) (wa2[l]/,r) 
}
array table
-----------------------------------------------
diag -> [('[l]', 'r', 'not normalized', ['j'], 5287)]
LDEs formed:0

ipvt -> [('[j]', 'r', 'normalized', ['j'], 5286)]
LDEs formed:0

wa1 -> [('[j]', 'w', 'normalized', ['j'], 5287)]
LDEs formed:1

wa2 -> [('[l]', 'r', 'not normalized', ['j'], 5287)]
LDEs formed:0

distinct LDEs:
j1=j2
#########################################################################################
loop info:  j=0  j<n  j++ 
induction variable: ['j']
{
	loop info:  i=0  i<=jm1  i++ 
	induction variable: ['j', 'i']
		{
		L5288: (r[ij]*,r) (wa1[i],r) 
		}
L5289: (wa1[j]=,w) (wa1[j]-,r) (r[j+ldr*j],r) 
}
array table
-----------------------------------------------
r -> [('[ij]', 'r', 'not normalized', ['j', 'i'], 5288), ('[j+ldr*j]', 'r', 'not normalized', ['j', 'i'], 5289)]
LDEs formed:0

wa1 -> [('[i]', 'r', 'normalized', ['j', 'i'], 5288), ('[j]', 'w', 'normalized', ['j', 'i'], 5289), ('[j]', 'r', 'normalized', ['j', 'i'], 5289)]
LDEs formed:3

distinct LDEs:
j1=j2
i1=j2
#########################################################################################
loop info:  j=0  j<n  j++ 
induction variable: ['j']
{
	loop info:  i=0  i<=j  i++ 
	induction variable: ['j', 'i']
	{
	L5290: (r[ij]*,r) (qtb[i],r) 
	}
L5291: (ipvt[j],r) 
L5292: (wa1[j]=,w) (diag[l],r) 
}
array table
-----------------------------------------------
diag -> [('[l]', 'r', 'not normalized', ['j', 'i'], 5292)]
LDEs formed:0

r -> [('[ij]', 'r', 'not normalized', ['j', 'i'], 5290)]
LDEs formed:0

qtb -> [('[i]', 'r', 'normalized', ['j', 'i'], 5290)]
LDEs formed:0

ipvt -> [('[j]', 'r', 'normalized', ['j', 'i'], 5291)]
LDEs formed:0

wa1 -> [('[j]', 'w', 'normalized', ['j', 'i'], 5292)]
LDEs formed:1

distinct LDEs:
j1=j2
#########################################################################################
loop info:  j=0  j<n  j++ 
induction variable: ['j']
{
L5293: (ipvt[j],r) 
L5294: (wa1[j]=,w) (diag[l]*,r) (wa2[l]/,r) 
}
array table
-----------------------------------------------
diag -> [('[l]', 'r', 'not normalized', ['j'], 5294)]
LDEs formed:0

ipvt -> [('[j]', 'r', 'normalized', ['j'], 5293)]
LDEs formed:0

wa1 -> [('[j]', 'w', 'normalized', ['j'], 5294)]
LDEs formed:1

wa2 -> [('[l]', 'r', 'not normalized', ['j'], 5294)]
LDEs formed:0

distinct LDEs:
j1=j2
#########################################################################################
loop info:  j=0  j<n  j++ 
induction variable: ['j']
{
L5295: (wa1[j]=,w) (wa1[j]/,r) (sdiag[j],r) 
L5296: (wa1[j],r) 
	loop info:  i=jp1  i<n  i++ 
	induction variable: ['j', 'i']
		{
		L5297: (wa1[i]-=,w) (r[ij]*,r) 
		}
 }
array table
-----------------------------------------------
r -> [('[ij]', 'r', 'not normalized', ['j', 'i'], 5297)]
LDEs formed:0

sdiag -> [('[j]', 'r', 'normalized', ['j', 'i'], 5295)]
LDEs formed:0

wa1 -> [('[j]', 'w', 'normalized', ['j', 'i'], 5295), ('[j]', 'r', 'normalized', ['j', 'i'], 5295), ('[j]', 'r', 'normalized', ['j', 'i'], 5296), ('[i]', 'w', 'normalized', ['j', 'i'], 5297)]
LDEs formed:7

distinct LDEs:
j1=j2
j1=i2
i1=i2
#########################################################################################
loop info:  j=0  j<n  j++ 
induction variable: ['j']
{
L5298: (diag[j],r) 
}
array table
-----------------------------------------------
diag -> [('[j]', 'r', 'normalized', ['j'], 5298)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info:  j=0  j<n  j++ 
induction variable: ['j']
{
L5299: (diag[j]=,w) (wa2[j],r) 
L5300: (wa2[j]==,r) 
L5301: (diag[j]=,w) 
}
array table
-----------------------------------------------
diag -> [('[j]', 'w', 'normalized', ['j'], 5299), ('[j]', 'w', 'normalized', ['j'], 5301)]
LDEs formed:3

wa2 -> [('[j]', 'r', 'normalized', ['j'], 5299), ('[j]', 'r', 'normalized', ['j'], 5300)]
LDEs formed:0

distinct LDEs:
j1=j2
#########################################################################################
loop info:  j=0  j<n  j++ 
induction variable: ['j']
{
L5301: (fjac[jj],r) 
	loop info:  i=j  i<m  i++ 
	induction variable: ['j', 'i']
		{
		L5302: (fjac[ij]*,r) (wa4[i],r) 
		L5303: (fjac[i+m*j]*,r) 
		}
	loop info:  i=j  i<m  i++ 
	induction variable: ['j', 'i']
		{
		L5304: (wa4[i]+=,w) (fjac[ij]*,r) 
		L5305: (fjac[i+m*j]*,r) 
		}
L5306: (fjac[jj]=,w) (wa1[j],r) 
L5307: (fjac[j+m*j]*,r) 
L5308: (qtf[j]=,w) (wa4[j],r) 
}
array table
-----------------------------------------------
qtf -> [('[j]', 'w', 'normalized', ['j', 'i'], 5308)]
LDEs formed:1

wa4 -> [('[i]', 'r', 'normalized', ['j', 'i'], 5302), ('[i]', 'w', 'normalized', ['j', 'i'], 5304), ('[j]', 'r', 'normalized', ['j', 'i'], 5308)]
LDEs formed:3

fjac -> [('[jj]', 'r', 'not normalized', ['j', 'i'], 5301), ('[ij]', 'r', 'not normalized', ['j', 'i'], 5302), ('[i+m*j]', 'r', 'not normalized', ['j', 'i'], 5303), ('[ij]', 'r', 'not normalized', ['j', 'i'], 5304), ('[i+m*j]', 'r', 'not normalized', ['j', 'i'], 5305), ('[jj]', 'w', 'not normalized', ['j', 'i'], 5306), ('[j+m*j]', 'r', 'not normalized', ['j', 'i'], 5307)]
LDEs formed:7

wa1 -> [('[j]', 'r', 'normalized', ['j', 'i'], 5306)]
LDEs formed:0

distinct LDEs:
ij=jj
jj=jj
i1=i2
j1=j2
i1+m*j1=jj
jj=j2+m*j2
i1=j2
#########################################################################################
loop info:  j=0  j<n  j++ 
induction variable: ['j']
{
L5307: (ipvt[j],r) 
L5308: (wa2[l],r) 
	loop info:  i=0  i<=j  i++ 
	induction variable: ['j', 'i']
		{
		L5309: (fjac[ij]*,r) (qtf[i]/,r) 
		L5310: (fjac[i+m*j]*,r) 
		}
L5311: (wa2[l],r) 
}
array table
-----------------------------------------------
qtf -> [('[i]', 'r', 'normalized', ['j', 'i'], 5309)]
LDEs formed:0

fjac -> [('[ij]', 'r', 'not normalized', ['j', 'i'], 5309), ('[i+m*j]', 'r', 'not normalized', ['j', 'i'], 5310)]
LDEs formed:0

ipvt -> [('[j]', 'r', 'normalized', ['j', 'i'], 5307)]
LDEs formed:0

wa2 -> [('[l]', 'r', 'not normalized', ['j', 'i'], 5308), ('[l]', 'r', 'not normalized', ['j', 'i'], 5311)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info:  j=0  j<n  j++ 
induction variable: ['j']
{
L5312: (wa1[j]=,w) (wa1[j],r) 
L5313: (wa2[j]=,w) (x[j]+,r) (wa1[j],r) 
L5314: (wa3[j]=,w) (diag[j]*,r) (wa1[j],r) 
}
array table
-----------------------------------------------
x -> [('[j]', 'r', 'normalized', ['j'], 5313)]
LDEs formed:0

wa3 -> [('[j]', 'w', 'normalized', ['j'], 5314)]
LDEs formed:1

wa2 -> [('[j]', 'w', 'normalized', ['j'], 5313)]
LDEs formed:1

wa1 -> [('[j]', 'w', 'normalized', ['j'], 5312), ('[j]', 'r', 'normalized', ['j'], 5312), ('[j]', 'r', 'normalized', ['j'], 5313), ('[j]', 'r', 'normalized', ['j'], 5314)]
LDEs formed:4

diag -> [('[j]', 'r', 'normalized', ['j'], 5314)]
LDEs formed:0

distinct LDEs:
j1=j2
#########################################################################################
loop info:  j=0  j<n  j++ 
induction variable: ['j']
{
L5315: (wa3[j]=,w) 
L5316: (ipvt[j],r) 
L5317: (wa1[l],r) 
	loop info:  i=0  i<=j  i++ 
	induction variable: ['j', 'i']
	{
	L5318: (wa3[i]+=,w) (fjac[ij]*,r) 
	L5319: (fjac[i+m*j]*,r) 
	}
 }
array table
-----------------------------------------------
fjac -> [('[ij]', 'r', 'not normalized', ['j', 'i'], 5318), ('[i+m*j]', 'r', 'not normalized', ['j', 'i'], 5319)]
LDEs formed:0

wa3 -> [('[j]', 'w', 'normalized', ['j', 'i'], 5315), ('[i]', 'w', 'normalized', ['j', 'i'], 5318)]
LDEs formed:3

ipvt -> [('[j]', 'r', 'normalized', ['j', 'i'], 5316)]
LDEs formed:0

wa1 -> [('[l]', 'r', 'not normalized', ['j', 'i'], 5317)]
LDEs formed:0

distinct LDEs:
j1=j2
j1=i2
i1=i2
#########################################################################################
loop info:  j=0  j<n  j++ 
induction variable: ['j']
{
L5318: (x[j]=,w) (wa2[j],r) 
L5319: (wa2[j]=,w) (diag[j]*,r) (x[j],r) 
}
array table
-----------------------------------------------
x -> [('[j]', 'w', 'normalized', ['j'], 5318), ('[j]', 'r', 'normalized', ['j'], 5319)]
LDEs formed:2

wa2 -> [('[j]', 'r', 'normalized', ['j'], 5318), ('[j]', 'w', 'normalized', ['j'], 5319)]
LDEs formed:2

diag -> [('[j]', 'r', 'normalized', ['j'], 5319)]
LDEs formed:0

distinct LDEs:
j1=j2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/math/optimization/projection.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/math/optimization/simplex.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<vertices.size()  ++i
induction variable: ['i']
{
L5320: (vertices[i]-,r) 
}
array table
-----------------------------------------------
vertices -> [('[i]', 'r', 'normalized', ['i'], 5320)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: i=0  i<n  i++
induction variable: ['i']
{
L5321: (direction[i]=,w) 
L5322: (vertices_[i+1],r) 
}
array table
-----------------------------------------------
vertices_ -> [('[i+1]', 'r', 'normalized', ['i'], 5322)]
LDEs formed:0

direction -> [('[i]', 'w', 'normalized', ['i'], 5321)]
LDEs formed:1

distinct LDEs:
i1=i2
#########################################################################################
loop info: i=1 i<=n  i++
induction variable: ['i']
{
L5322: (values_[i],r) (values_[iHighest],r) 
L5323: (values_[i],r) (values_[iNextHighest],r) 
L5324: (values_[i],r) (values_[iLowest],r) 
}
array table
-----------------------------------------------
values_ -> [('[i]', 'r', 'normalized', ['i'], 5322), ('[iHighest]', 'r', 'not normalized', ['i'], 5322), ('[i]', 'r', 'normalized', ['i'], 5323), ('[iNextHighest]', 'r', 'not normalized', ['i'], 5323), ('[i]', 'r', 'normalized', ['i'], 5324), ('[iLowest]', 'r', 'not normalized', ['i'], 5324)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<=n  i++
induction variable: ['i']
{
L5325: (vertices_[i]=,w) 
L5326: (vertices_[i]+,r) (vertices_[iLowest],r) 
L5327: (vertices_[i]+=,w) (vertices_[iLowest],r) 
L5328: (vertices_[i]*=,w) 
L5329: (values_[i]=,w) (vertices_[i],r) 
}
array table
-----------------------------------------------
vertices_ -> [('[i]', 'w', 'normalized', ['i'], 5325), ('[i]', 'r', 'normalized', ['i'], 5326), ('[iLowest]', 'r', 'not normalized', ['i'], 5326), ('[i]', 'w', 'normalized', ['i'], 5327), ('[iLowest]', 'r', 'not normalized', ['i'], 5327), ('[i]', 'w', 'normalized', ['i'], 5328), ('[i]', 'r', 'normalized', ['i'], 5329)]
LDEs formed:18

values_ -> [('[i]', 'w', 'normalized', ['i'], 5329)]
LDEs formed:1

distinct LDEs:
i1=iLowest
i1=i2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/math/optimization/differentialevolution.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size popIter = 0  popIter < population.size()  popIter++
induction variable: ['popIter']
{
L5330: (population[popIter].values=,w) (population[popIter].values,r) 
L5331: (shuffledPop1[popIter].values-,r) (shuffledPop2[popIter].values,r) 
}
array table
-----------------------------------------------
shuffledPop1 -> [('[popIter]', 'r', 'normalized', ['popIter'], 5331)]
LDEs formed:0

shuffledPop2 -> [('[popIter]', 'r', 'normalized', ['popIter'], 5331)]
LDEs formed:0

population -> [('[popIter]', 'w', 'normalized', ['popIter'], 5330), ('[popIter]', 'r', 'normalized', ['popIter'], 5330)]
LDEs formed:2

distinct LDEs:
popIter1=popIter2
#########################################################################################
loop info: Size popIter = 0  popIter < population.size()  popIter++
induction variable: ['popIter']
{
	loop info: Size jitterIter = 0  jitterIter < jitter.size()  jitterIter++
	induction variable: ['popIter', 'jitterIter']
	{
	L5331: (jitter[jitterIter]=,w) 
	}
L5332: (population[popIter].values=,w) 
L5333: (shuffledPop1[popIter].values-,r) (population[popIter].values,r) 
}
array table
-----------------------------------------------
shuffledPop1 -> [('[popIter]', 'r', 'normalized', ['popIter', 'jitterIter'], 5333)]
LDEs formed:0

jitter -> [('[jitterIter]', 'w', 'normalized', ['popIter', 'jitterIter'], 5331)]
LDEs formed:1

population -> [('[popIter]', 'w', 'normalized', ['popIter', 'jitterIter'], 5332), ('[popIter]', 'r', 'normalized', ['popIter', 'jitterIter'], 5333)]
LDEs formed:2

distinct LDEs:
jitterIter1=jitterIter2
popIter1=popIter2
#########################################################################################
loop info: Size popIter = 0  popIter < population.size()  popIter++
induction variable: ['popIter']
{
L5334: (population[popIter].values=,w) (oldPopulation[popIter].values,r) 
L5335: (oldPopulation[popIter].values,r) 
L5336: (population[popIter].values-,r) (shuffledPop1[popIter].values,r) 
}
array table
-----------------------------------------------
oldPopulation -> [('[popIter]', 'r', 'normalized', ['popIter'], 5334), ('[popIter]', 'r', 'normalized', ['popIter'], 5335)]
LDEs formed:0

shuffledPop1 -> [('[popIter]', 'r', 'normalized', ['popIter'], 5336)]
LDEs formed:0

population -> [('[popIter]', 'w', 'normalized', ['popIter'], 5334), ('[popIter]', 'r', 'normalized', ['popIter'], 5336)]
LDEs formed:2

distinct LDEs:
popIter1=popIter2
#########################################################################################
loop info: Size popIter = 0  popIter < population.size()  popIter++
induction variable: ['popIter']
{
L5337: (population[popIter].values=,w) (population[popIter].values,r) 
L5338: (shuffledPop1[popIter].values-,r) (shuffledPop2[popIter].values,r) 
}
array table
-----------------------------------------------
shuffledPop1 -> [('[popIter]', 'r', 'normalized', ['popIter'], 5338)]
LDEs formed:0

shuffledPop2 -> [('[popIter]', 'r', 'normalized', ['popIter'], 5338)]
LDEs formed:0

population -> [('[popIter]', 'w', 'normalized', ['popIter'], 5337), ('[popIter]', 'r', 'normalized', ['popIter'], 5337)]
LDEs formed:2

distinct LDEs:
popIter1=popIter2
#########################################################################################
loop info: Size popIter = 0  popIter < population.size()  popIter++
induction variable: ['popIter']
{
L5338: (population[popIter].values=,w) (population[popIter].values,r) 
L5339: (shuffledPop1[popIter].values-,r) (shuffledPop2[popIter].values,r) 
}
array table
-----------------------------------------------
shuffledPop1 -> [('[popIter]', 'r', 'normalized', ['popIter'], 5339)]
LDEs formed:0

shuffledPop2 -> [('[popIter]', 'r', 'normalized', ['popIter'], 5339)]
LDEs formed:0

population -> [('[popIter]', 'w', 'normalized', ['popIter'], 5338), ('[popIter]', 'r', 'normalized', ['popIter'], 5338)]
LDEs formed:2

distinct LDEs:
popIter1=popIter2
#########################################################################################
loop info: Size popIter = 0  popIter < population.size()  popIter++
induction variable: ['popIter']
{
L5339: (population[popIter].values=,w) (oldPopulation[popIter].values,r) 
L5340: (shuffledPop1[popIter].values-,r) (shuffledPop2[popIter].values,r) 
}
array table
-----------------------------------------------
oldPopulation -> [('[popIter]', 'r', 'normalized', ['popIter'], 5339)]
LDEs formed:0

shuffledPop2 -> [('[popIter]', 'r', 'normalized', ['popIter'], 5340)]
LDEs formed:0

shuffledPop1 -> [('[popIter]', 'r', 'normalized', ['popIter'], 5340)]
LDEs formed:0

population -> [('[popIter]', 'w', 'normalized', ['popIter'], 5339)]
LDEs formed:1

distinct LDEs:
popIter1=popIter2
#########################################################################################
loop info: Size popIter = 0  popIter < population.size()  popIter++
induction variable: ['popIter']
{
L5340: (population[popIter].values=,w) (oldPopulation[popIter].values,r) 
L5341: (shuffledPop1[popIter].values-,r) (shuffledPop2[popIter].values,r) 
L5342: (population[popIter].values,r) 
}
array table
-----------------------------------------------
oldPopulation -> [('[popIter]', 'r', 'normalized', ['popIter'], 5340)]
LDEs formed:0

shuffledPop2 -> [('[popIter]', 'r', 'normalized', ['popIter'], 5341)]
LDEs formed:0

shuffledPop1 -> [('[popIter]', 'r', 'normalized', ['popIter'], 5341)]
LDEs formed:0

population -> [('[popIter]', 'w', 'normalized', ['popIter'], 5340), ('[popIter]', 'r', 'normalized', ['popIter'], 5342)]
LDEs formed:2

distinct LDEs:
popIter1=popIter2
#########################################################################################
loop info: Size popIter = 0  popIter < population.size()  popIter++
induction variable: ['popIter']
{
L5343: (population[popIter].values=,w) 
L5344: (population[popIter].values=,w) 
L5345: (currGenSizeWeights_[popIter],r) 
L5346: (shuffledPop1[popIter].values-,r) (shuffledPop2[popIter].values,r) 
}
array table
-----------------------------------------------
currGenSizeWeights_ -> [('[popIter]', 'r', 'normalized', ['popIter'], 5345)]
LDEs formed:0

shuffledPop1 -> [('[popIter]', 'r', 'normalized', ['popIter'], 5346)]
LDEs formed:0

shuffledPop2 -> [('[popIter]', 'r', 'normalized', ['popIter'], 5346)]
LDEs formed:0

population -> [('[popIter]', 'w', 'normalized', ['popIter'], 5343), ('[popIter]', 'w', 'normalized', ['popIter'], 5344)]
LDEs formed:3

distinct LDEs:
popIter1=popIter2
#########################################################################################
loop info: Size popIter = 0  popIter < population.size()  popIter++
induction variable: ['popIter']
{
L5345: (population[popIter].values=,w) (oldPopulation[popIter].values*,r) (invCrossoverMask[popIter],r) 
L5346: (mutantPopulation[popIter].values*,r) (crossoverMask[popIter],r) 
	loop info: Size memIter = 0  memIter < population[popIter].values.size()  memIter++
	induction variable: ['popIter', 'memIter']
		{
		L5347: (population[popIter].values,r) (upperBound_[memIter],r) 
		L5348: (population[popIter].values,r) (upperBound_[memIter],r) 
		L5349: (mirrorPopulation[popIter].values,r) 
		L5350: (upperBound_[memIter],r) 
		L5351: (population[popIter].values,r) (lowerBound_[memIter],r) 
		L5352: (population[popIter].values,r) (lowerBound_[memIter],r) 
		L5353: (mirrorPopulation[popIter].values,r) 
		L5354: (lowerBound_[memIter],r) 
		}
L5355: (population[popIter].cost=,w) (population[popIter].values,r) 
L5356: (population[popIter].cost=,w) 
}
array table
-----------------------------------------------
mutantPopulation -> [('[popIter]', 'r', 'normalized', ['popIter', 'memIter'], 5346)]
LDEs formed:0

mirrorPopulation -> [('[popIter]', 'r', 'normalized', ['popIter', 'memIter'], 5349), ('[popIter]', 'r', 'normalized', ['popIter', 'memIter'], 5353)]
LDEs formed:0

lowerBound_ -> [('[memIter]', 'r', 'normalized', ['popIter', 'memIter'], 5351), ('[memIter]', 'r', 'normalized', ['popIter', 'memIter'], 5352), ('[memIter]', 'r', 'normalized', ['popIter', 'memIter'], 5354)]
LDEs formed:0

crossoverMask -> [('[popIter]', 'r', 'normalized', ['popIter', 'memIter'], 5346)]
LDEs formed:0

invCrossoverMask -> [('[popIter]', 'r', 'normalized', ['popIter', 'memIter'], 5345)]
LDEs formed:0

upperBound_ -> [('[memIter]', 'r', 'normalized', ['popIter', 'memIter'], 5347), ('[memIter]', 'r', 'normalized', ['popIter', 'memIter'], 5348), ('[memIter]', 'r', 'normalized', ['popIter', 'memIter'], 5350)]
LDEs formed:0

oldPopulation -> [('[popIter]', 'r', 'normalized', ['popIter', 'memIter'], 5345)]
LDEs formed:0

population -> [('[popIter]', 'w', 'normalized', ['popIter', 'memIter'], 5345), ('[popIter]', 'r', 'normalized', ['popIter', 'memIter'], 5347), ('[popIter]', 'r', 'normalized', ['popIter', 'memIter'], 5348), ('[popIter]', 'r', 'normalized', ['popIter', 'memIter'], 5351), ('[popIter]', 'r', 'normalized', ['popIter', 'memIter'], 5352), ('[popIter]', 'w', 'normalized', ['popIter', 'memIter'], 5355), ('[popIter]', 'r', 'normalized', ['popIter', 'memIter'], 5355), ('[popIter]', 'w', 'normalized', ['popIter', 'memIter'], 5356)]
LDEs formed:21

distinct LDEs:
popIter1=popIter2
#########################################################################################
loop info: Size cmIter = 0  cmIter < crossoverMask.size()  cmIter++
induction variable: ['cmIter']
{
	loop info: Size memIter = 0  memIter < crossoverMask[cmIter].size()  memIter++
	induction variable: ['cmIter', 'memIter']
	{
	L5357: (mutationProbabilities[cmIter],r) 
	L5358: (invCrossoverMask[cmIter][memIter]=,w) 
	L5359: (crossoverMask[cmIter][memIter]=,w) 
	}
 }
array table
-----------------------------------------------
mutationProbabilities -> [('[cmIter]', 'r', 'normalized', ['cmIter', 'memIter'], 5357)]
LDEs formed:0

invCrossoverMask -> [('[cmIter][memIter]', 'w', 'normalized', ['cmIter', 'memIter'], 5358)]
LDEs formed:2

crossoverMask -> [('[cmIter][memIter]', 'w', 'normalized', ['cmIter', 'memIter'], 5359)]
LDEs formed:2

distinct LDEs:
cmIter1=cmIter2,memIter1=memIter2
#########################################################################################
loop info: Size coIter = 0 coIter< currGenCrossover_.size()  coIter++
induction variable: ['coIter']
{
L5360: (mutationProbabilities[coIter]=,w) 
L5361: (currGenCrossover_[coIter],r) 
L5362: (currGenCrossover_[coIter],r) 
}
array table
-----------------------------------------------
mutationProbabilities -> [('[coIter]', 'w', 'normalized', ['coIter'], 5360)]
LDEs formed:1

currGenCrossover_ -> [('[coIter]', 'r', 'normalized', ['coIter'], 5361), ('[coIter]', 'r', 'normalized', ['coIter'], 5362)]
LDEs formed:0

distinct LDEs:
coIter1=coIter2
#########################################################################################
loop info: Size coIter = 0 coIter < currGenSizeWeights_.size()  coIter++
induction variable: ['coIter']
{
L5363: (currGenSizeWeights_[coIter]=,w) 
}
array table
-----------------------------------------------
currGenSizeWeights_ -> [('[coIter]', 'w', 'normalized', ['coIter'], 5363)]
LDEs formed:1

distinct LDEs:
coIter1=coIter2
#########################################################################################
loop info: Size coIter = 0 coIter < currGenCrossover_.size()  coIter++
induction variable: ['coIter']
{
L5364: (currGenCrossover_[coIter]=,w) 
}
array table
-----------------------------------------------
currGenCrossover_ -> [('[coIter]', 'w', 'normalized', ['coIter'], 5364)]
LDEs formed:1

distinct LDEs:
coIter1=coIter2
#########################################################################################
loop info: Size j = 1  j < population.size()  ++j
induction variable: ['j']
{
	loop info: Size i = 0  i < p.currentValue().size()  ++i
	induction variable: ['j', 'i']
	{
	L5365: (lowerBound_[i],r) (upperBound_[i],r) 
	L5366: (population[j].values,r) 
	}
L5367: (population[j].cost=,w) (population[j].values,r) 
}
array table
-----------------------------------------------
upperBound_ -> [('[i]', 'r', 'normalized', ['j', 'i'], 5365)]
LDEs formed:0

population -> [('[j]', 'r', 'normalized', ['j', 'i'], 5366), ('[j]', 'w', 'normalized', ['j', 'i'], 5367), ('[j]', 'r', 'normalized', ['j', 'i'], 5367)]
LDEs formed:3

lowerBound_ -> [('[i]', 'r', 'normalized', ['j', 'i'], 5365)]
LDEs formed:0

distinct LDEs:
j1=j2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/math/optimization/bfgs.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i = 0  i < P.currentValue().size()  ++i
induction variable: ['i']
{
L5366: (diffGradient[i]*,r) 
L5367: (diffGradient[i]*,r) (diffGradientWithHessianApplied[i],r) 
L5368: (diffGradient[i],r) 
}
array table
-----------------------------------------------
diffGradient -> [('[i]', 'r', 'normalized', ['i'], 5366), ('[i]', 'r', 'normalized', ['i'], 5367), ('[i]', 'r', 'normalized', ['i'], 5368)]
LDEs formed:0

diffGradientWithHessianApplied -> [('[i]', 'r', 'normalized', ['i'], 5367)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i = 0  i < P.currentValue().size()  ++i
induction variable: ['i']
{
L5368: (inverseHessian_[i][j]+=,w) 
L5369: (inverseHessian_[i][j]-=,w) (diffGradientWithHessianApplied[i]*,r) (diffGradientWithHessianApplied[j],r) 
L5370: (inverseHessian_[i][j]+=,w) (diffGradient[i]*,r) (diffGradient[j],r) 
}
array table
-----------------------------------------------
diffGradientWithHessianApplied -> [('[i]', 'r', 'normalized', ['i'], 5369), ('[j]', 'r', 'not normalized', ['i'], 5369)]
LDEs formed:0

diffGradient -> [('[i]', 'r', 'normalized', ['i'], 5370), ('[j]', 'r', 'not normalized', ['i'], 5370)]
LDEs formed:0

inverseHessian_ -> [('[i][j]', 'w', 'not normalized', ['i'], 5368), ('[i][j]', 'w', 'not normalized', ['i'], 5369), ('[i][j]', 'w', 'not normalized', ['i'], 5370)]
LDEs formed:12

distinct LDEs:
i1=i2,j=j
#########################################################################################
loop info: Size i = 0  i < P.currentValue().size()  ++i
induction variable: ['i']
{
L5371: (direction[i]=,w) 
	loop info: Size j = 0  j < P.currentValue().size()  ++j
	induction variable: ['i', 'j']
	{
	}
 }
array table
-----------------------------------------------
direction -> [('[i]', 'w', 'normalized', ['i', 'j'], 5371)]
LDEs formed:1

distinct LDEs:
i1=i2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/math/distributions/gammadistribution.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/math/distributions/bivariatestudenttdistribution.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/math/distributions/bivariatenormaldistribution.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<5  i++
induction variable: ['i']
{
	loop info: Size j=0 j<5  j++
	induction variable: ['i', 'j']
	{
	L5372: (x_[i]*,r) (x_[j]*,r) 
	L5373: (y_[i]-,r) (y_[j]-,r) 
	L5374: (y_[i]-,r) (y_[j]-,r) 
	}
 }
array table
-----------------------------------------------
x_ -> [('[i]', 'r', 'normalized', ['i', 'j'], 5372), ('[j]', 'r', 'normalized', ['i', 'j'], 5372)]
LDEs formed:0

y_ -> [('[i]', 'r', 'normalized', ['i', 'j'], 5373), ('[j]', 'r', 'normalized', ['i', 'j'], 5373), ('[i]', 'r', 'normalized', ['i', 'j'], 5374), ('[j]', 'r', 'normalized', ['i', 'j'], 5374)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/math/distributions/chisquaredistribution.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/methods/lattices/trinomialtree.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<nTimeSteps  i++
induction variable: ['i']
{
L5375: (timeGrid[i],r) 
	loop info: Integer j=jMin  j<=jMax  j++
	induction variable: ['i', 'j']
	{
	L5376: (dx_[i],r) 
	L5377: (dx_[i+1]+,r) 
	L5378: (dx_[i+1],r) 
	L5379: (dx_[i+1],r) 
	}
 }
array table
-----------------------------------------------
dx_ -> [('[i]', 'r', 'normalized', ['i', 'j'], 5376), ('[i+1]', 'r', 'normalized', ['i', 'j'], 5377), ('[i+1]', 'r', 'normalized', ['i', 'j'], 5378), ('[i+1]', 'r', 'normalized', ['i', 'j'], 5379)]
LDEs formed:0

timeGrid -> [('[i]', 'r', 'normalized', ['i', 'j'], 5375)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/methods/montecarlo/lsmbasissystem.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<v.size()  ++i
induction variable: ['i']
{
L5376: (v[i].size,r) 
L5377: (v[i].begin,r) (v[i].end,r) 
}
array table
-----------------------------------------------
v -> [('[i]', 'r', 'normalized', ['i'], 5376), ('[i]', 'r', 'normalized', ['i'], 5377), ('[i]', 'r', 'normalized', ['i'], 5377)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<dim  ++i
induction variable: ['i']
{
	loop info: Size j=0  j<v.size()  ++j
	induction variable: ['i', 'j']
	{
	L5378: (v[j],r) 
	L5379: (x[i]+=,w) 
	}
 }
array table
-----------------------------------------------
x -> [('[i]', 'w', 'normalized', ['i', 'j'], 5379)]
LDEs formed:1

v -> [('[j]', 'r', 'normalized', ['i', 'j'], 5378)]
LDEs formed:0

distinct LDEs:
i1=i2
#########################################################################################
loop info: Size i=0  i<=order  ++i
induction variable: ['i']
{
L5379: (ret[i]=,w) 
L5380: (ret[i]=,w) 
L5381: (ret[i]=,w) 
L5382: (ret[i]=,w) 
L5383: (ret[i]=,w) 
L5384: (ret[i]=,w) 
L5385: (ret[i]=,w) 
}
array table
-----------------------------------------------
ret -> [('[i]', 'w', 'normalized', ['i'], 5379), ('[i]', 'w', 'normalized', ['i'], 5380), ('[i]', 'w', 'normalized', ['i'], 5381), ('[i]', 'w', 'normalized', ['i'], 5382), ('[i]', 'w', 'normalized', ['i'], 5383), ('[i]', 'w', 'normalized', ['i'], 5384), ('[i]', 'w', 'normalized', ['i'], 5385)]
LDEs formed:28

distinct LDEs:
i1=i2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/methods/montecarlo/genericlsregression.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=steps-1  i!=0  --i
induction variable: ['i']
{
L5386: (simulationData[i],r) 
	loop info: j=0  j<exerciseData.size()  ++j
	induction variable: ['i', 'j']
	{
	L5387: (exerciseData[j].isValid,r) 
	L5388: (exerciseData[j].values.begin,r) 
	L5389: (exerciseData[j].values.end,r) 
	L5390: (exerciseData[j].cumulatedCashFlows,r) 
	L5391: (exerciseData[j].controlValue,r) 
	}
	loop info: Size k=0  k<N  ++k
	induction variable: ['i', 'j', 'k']
	{
	L5392: (target[k]=,w) (covariance[k][N]+,r) (means[k]*,r) (means[N],r) 
		loop info: Size l=0  l<=k  ++l
		induction variable: ['i', 'j', 'k', 'l']
		{
		}
 	}
L5393: (basisCoefficients[i-1].resize,r) 
L5394: (basisCoefficients[i-1].begin,r) 
	loop info: j=0  j<exerciseData.size()  ++j
	induction variable: ['i', 'j', 'k', 'l']
	{
	L5395: (exerciseData[j].isValid,r) 
	L5396: (exerciseData[j].exerciseValue,r) 
	L5397: (exerciseData[j].cumulatedCashFlows,r) 
	L5398: (exerciseData[j].values.begin,r) 
	L5399: (exerciseData[j].values.end,r) 
	L5400: (exerciseData[j].controlValue,r) 
	L5401: (simulationData[i-1][j].cumulatedCashFlows+=,w) 
	}
 }
array table
-----------------------------------------------
basisCoefficients -> [('[i-1]', 'r', 'normalized', ['i', 'j', 'k', 'l'], 5393), ('[i-1]', 'r', 'normalized', ['i', 'j', 'k', 'l'], 5394)]
LDEs formed:0

target -> [('[k]', 'w', 'normalized', ['i', 'j', 'k', 'l'], 5392)]
LDEs formed:1

means -> [('[k]', 'r', 'normalized', ['i', 'j', 'k', 'l'], 5392), ('[N]', 'r', 'not normalized', ['i', 'j', 'k', 'l'], 5392)]
LDEs formed:0

exerciseData -> [('[j]', 'r', 'normalized', ['i', 'j', 'k', 'l'], 5387), ('[j]', 'r', 'normalized', ['i', 'j', 'k', 'l'], 5388), ('[j]', 'r', 'normalized', ['i', 'j', 'k', 'l'], 5389), ('[j]', 'r', 'normalized', ['i', 'j', 'k', 'l'], 5390), ('[j]', 'r', 'normalized', ['i', 'j', 'k', 'l'], 5391), ('[j]', 'r', 'normalized', ['i', 'j', 'k', 'l'], 5395), ('[j]', 'r', 'normalized', ['i', 'j', 'k', 'l'], 5396), ('[j]', 'r', 'normalized', ['i', 'j', 'k', 'l'], 5397), ('[j]', 'r', 'normalized', ['i', 'j', 'k', 'l'], 5398), ('[j]', 'r', 'normalized', ['i', 'j', 'k', 'l'], 5399), ('[j]', 'r', 'normalized', ['i', 'j', 'k', 'l'], 5400)]
LDEs formed:0

covariance -> [('[k][N]', 'r', 'not normalized', ['i', 'j', 'k', 'l'], 5392)]
LDEs formed:0

simulationData -> [('[i]', 'r', 'normalized', ['i', 'j', 'k', 'l'], 5386), ('[i-1][j]', 'w', 'normalized', ['i', 'j', 'k', 'l'], 5401)]
LDEs formed:4

distinct LDEs:
k1=k2
i1-1=i2-1,j1=j2
i1=i2-1
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/methods/montecarlo/parametricexercise.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<simulationData_.size()  ++i
induction variable: ['i']
{
L5402: (simulationData_[i].isValid,r) 
}
array table
-----------------------------------------------
simulationData_ -> [('[i]', 'r', 'normalized', ['i'], 5402)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<simulationData_.size()  ++i
induction variable: ['i']
{
L5403: (simulationData_[i].isValid,r) 
L5404: (simulationData_[i].values,r) 
L5405: (simulationData_[i].exerciseValue,r) 
L5406: (simulationData_[i].cumulatedCashFlows,r) 
}
array table
-----------------------------------------------
simulationData_ -> [('[i]', 'r', 'normalized', ['i'], 5403), ('[i]', 'r', 'normalized', ['i'], 5404), ('[i]', 'r', 'normalized', ['i'], 5405), ('[i]', 'r', 'normalized', ['i'], 5406)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=steps-1  i!=0  --i
induction variable: ['i']
{
L5407: (simulationData[i],r) 
L5408: (parameters[i-1].resize,r) 
L5409: (parameters[i-1].size,r) 
L5410: (parameters[i-1],r) 
L5411: (parameters[i-1].begin,r) (parameters[i-1].end,r) 
L5412: (parameters[i-1].begin,r) 
L5413: (simulationData[i-1],r) 
	loop info: Size j=0  j<previousData.size()  ++j
	induction variable: ['i', 'j']
	{
	L5414: (exerciseData[j].isValid,r) 
	L5415: (parameters[i-1],r) 
	L5416: (exerciseData[j].values,r) 
	L5417: (previousData[j].cumulatedCashFlows+=,w) 
	L5418: (exerciseData[j].exerciseValue,r) 
	L5419: (previousData[j].cumulatedCashFlows+=,w) 
	L5420: (exerciseData[j].cumulatedCashFlows,r) 
	}
 }
array table
-----------------------------------------------
exerciseData -> [('[j]', 'r', 'normalized', ['i', 'j'], 5414), ('[j]', 'r', 'normalized', ['i', 'j'], 5416), ('[j]', 'r', 'normalized', ['i', 'j'], 5418), ('[j]', 'r', 'normalized', ['i', 'j'], 5420)]
LDEs formed:0

simulationData -> [('[i]', 'r', 'normalized', ['i', 'j'], 5407), ('[i-1]', 'r', 'normalized', ['i', 'j'], 5413)]
LDEs formed:0

previousData -> [('[j]', 'w', 'normalized', ['i', 'j'], 5417), ('[j]', 'w', 'normalized', ['i', 'j'], 5419)]
LDEs formed:3

parameters -> [('[i-1]', 'r', 'normalized', ['i', 'j'], 5408), ('[i-1]', 'r', 'normalized', ['i', 'j'], 5409), ('[i-1]', 'r', 'normalized', ['i', 'j'], 5410), ('[i-1]', 'r', 'normalized', ['i', 'j'], 5411), ('[i-1]', 'r', 'normalized', ['i', 'j'], 5411), ('[i-1]', 'r', 'normalized', ['i', 'j'], 5412), ('[i-1]', 'r', 'normalized', ['i', 'j'], 5415)]
LDEs formed:0

distinct LDEs:
j1=j2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/methods/montecarlo/brownianbridge.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size j=0, i=1  i<size_  ++i
induction variable: ['i']
{
L5416: (map[j],r) 
L5417: (map[k],r) 
L5418: (map[l]=,w) 
L5419: (bridgeIndex_[i]=,w) 
L5420: (leftIndex_[i]=,w) 
L5421: (rightIndex_[i]=,w) 
L5422: (leftWeight_[i]=,w) (t_[k]-,r) (t_[l],r) (t_[k]-,r) (t_[j-1],r) 
L5423: (rightWeight_[i]=,w) (t_[l]-,r) (t_[j-1],r) (t_[k]-,r) (t_[j-1],r) 
L5424: (stdDev_[i]=,w) 
L5425: (t_[l]-,r) (t_[j-1],r) (t_[k]-,r) (t_[l],r) 
L5426: (t_[k]-,r) (t_[j-1],r) 
L5427: (leftWeight_[i]=,w) (t_[k]-,r) (t_[l],r) (t_[k],r) 
L5428: (rightWeight_[i]=,w) (t_[l]/,r) (t_[k],r) 
L5429: (stdDev_[i]=,w) (t_[l]*,r) (t_[k]-,r) (t_[l],r) (t_[k],r) 
}
array table
-----------------------------------------------
map -> [('[j]', 'r', 'not normalized', ['i'], 5416), ('[k]', 'r', 'not normalized', ['i'], 5417), ('[l]', 'w', 'not normalized', ['i'], 5418)]
LDEs formed:3

rightIndex_ -> [('[i]', 'w', 'normalized', ['i'], 5421)]
LDEs formed:1

t_ -> [('[k]', 'r', 'not normalized', ['i'], 5422), ('[l]', 'r', 'not normalized', ['i'], 5422), ('[k]', 'r', 'not normalized', ['i'], 5422), ('[j-1]', 'r', 'not normalized', ['i'], 5422), ('[l]', 'r', 'not normalized', ['i'], 5423), ('[j-1]', 'r', 'not normalized', ['i'], 5423), ('[k]', 'r', 'not normalized', ['i'], 5423), ('[j-1]', 'r', 'not normalized', ['i'], 5423), ('[l]', 'r', 'not normalized', ['i'], 5425), ('[j-1]', 'r', 'not normalized', ['i'], 5425), ('[k]', 'r', 'not normalized', ['i'], 5425), ('[l]', 'r', 'not normalized', ['i'], 5425), ('[k]', 'r', 'not normalized', ['i'], 5426), ('[j-1]', 'r', 'not normalized', ['i'], 5426), ('[k]', 'r', 'not normalized', ['i'], 5427), ('[l]', 'r', 'not normalized', ['i'], 5427), ('[k]', 'r', 'not normalized', ['i'], 5427), ('[l]', 'r', 'not normalized', ['i'], 5428), ('[k]', 'r', 'not normalized', ['i'], 5428), ('[l]', 'r', 'not normalized', ['i'], 5429), ('[k]', 'r', 'not normalized', ['i'], 5429), ('[l]', 'r', 'not normalized', ['i'], 5429), ('[k]', 'r', 'not normalized', ['i'], 5429)]
LDEs formed:0

bridgeIndex_ -> [('[i]', 'w', 'normalized', ['i'], 5419)]
LDEs formed:1

rightWeight_ -> [('[i]', 'w', 'normalized', ['i'], 5423), ('[i]', 'w', 'normalized', ['i'], 5428)]
LDEs formed:3

leftWeight_ -> [('[i]', 'w', 'normalized', ['i'], 5422), ('[i]', 'w', 'normalized', ['i'], 5427)]
LDEs formed:3

leftIndex_ -> [('[i]', 'w', 'normalized', ['i'], 5420)]
LDEs formed:1

stdDev_ -> [('[i]', 'w', 'normalized', ['i'], 5424), ('[i]', 'w', 'normalized', ['i'], 5429)]
LDEs formed:3

distinct LDEs:
k=l
l=l
j=l
i1=i2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/methods/finitedifferences/tridiagonaloperator.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size j=1  j<=n_-1  ++j
induction variable: ['j']
{
L5430: (temp_[j]=,w) (upperDiagonal_[j-1]/,r) 
L5431: (diagonal_[j]-,r) (lowerDiagonal_[j-1]*,r) (temp_[j],r) 
L5432: (result[j]=,w) (rhs[j]-,r) (lowerDiagonal_[j-1]*,r) (result[j-1],r) 
}
array table
-----------------------------------------------
rhs -> [('[j]', 'r', 'normalized', ['j'], 5432)]
LDEs formed:0

upperDiagonal_ -> [('[j-1]', 'r', 'normalized', ['j'], 5430)]
LDEs formed:0

result -> [('[j]', 'w', 'normalized', ['j'], 5432), ('[j-1]', 'r', 'normalized', ['j'], 5432)]
LDEs formed:2

diagonal_ -> [('[j]', 'r', 'normalized', ['j'], 5431)]
LDEs formed:0

lowerDiagonal_ -> [('[j-1]', 'r', 'normalized', ['j'], 5431), ('[j-1]', 'r', 'normalized', ['j'], 5432)]
LDEs formed:0

temp_ -> [('[j]', 'w', 'normalized', ['j'], 5430), ('[j]', 'r', 'normalized', ['j'], 5431)]
LDEs formed:2

distinct LDEs:
j1=j2
j1=j2-1
#########################################################################################
loop info: Size sorIteration=0  err>tol   ++sorIteration
induction variable: ['sorIteration']
{
L5432: (rhs[0]-,r) 
L5433: (upperDiagonal_[0]*,r) (result[1]-,r) 
L5434: (diagonal_[0]*,r) (result[0],r) (diagonal_[0],r) 
L5435: (result[0]+=,w) 
	loop info: i=1  i<n_-1   ++i
	induction variable: ['sorIteration', 'i']
	{
	L5436: (rhs[i]-,r) 
	L5437: (upperDiagonal_[i]*,r) (result[i+1]-,r) 
	L5438: (diagonal_[i]*,r) (result[i]-,r) 
	L5439: (lowerDiagonal_[i-1]*,r) (result[i-1],r) (diagonal_[i],r) 
	L5440: (result[i]+=,w) 
	}
L5441: (rhs[i]-,r) 
L5442: (diagonal_[i]*,r) (result[i]-,r) 
L5443: (lowerDiagonal_[i-1]*,r) (result[i-1],r) (diagonal_[i],r) 
L5444: (result[i]+=,w) 
}
array table
-----------------------------------------------
diagonal_ -> [('[0]', 'r', 'normalized', ['sorIteration', 'i'], 5434), ('[0]', 'r', 'normalized', ['sorIteration', 'i'], 5434), ('[i]', 'r', 'normalized', ['sorIteration', 'i'], 5438), ('[i]', 'r', 'normalized', ['sorIteration', 'i'], 5439), ('[i]', 'r', 'normalized', ['sorIteration', 'i'], 5442), ('[i]', 'r', 'normalized', ['sorIteration', 'i'], 5443)]
LDEs formed:0

rhs -> [('[0]', 'r', 'normalized', ['sorIteration', 'i'], 5432), ('[i]', 'r', 'normalized', ['sorIteration', 'i'], 5436), ('[i]', 'r', 'normalized', ['sorIteration', 'i'], 5441)]
LDEs formed:0

lowerDiagonal_ -> [('[i-1]', 'r', 'normalized', ['sorIteration', 'i'], 5439), ('[i-1]', 'r', 'normalized', ['sorIteration', 'i'], 5443)]
LDEs formed:0

upperDiagonal_ -> [('[0]', 'r', 'normalized', ['sorIteration', 'i'], 5433), ('[i]', 'r', 'normalized', ['sorIteration', 'i'], 5437)]
LDEs formed:0

result -> [('[1]', 'r', 'normalized', ['sorIteration', 'i'], 5433), ('[0]', 'r', 'normalized', ['sorIteration', 'i'], 5434), ('[0]', 'w', 'normalized', ['sorIteration', 'i'], 5435), ('[i+1]', 'r', 'normalized', ['sorIteration', 'i'], 5437), ('[i]', 'r', 'normalized', ['sorIteration', 'i'], 5438), ('[i-1]', 'r', 'normalized', ['sorIteration', 'i'], 5439), ('[i]', 'w', 'normalized', ['sorIteration', 'i'], 5440), ('[i]', 'r', 'normalized', ['sorIteration', 'i'], 5442), ('[i-1]', 'r', 'normalized', ['sorIteration', 'i'], 5443), ('[i]', 'w', 'normalized', ['sorIteration', 'i'], 5444)]
LDEs formed:27

distinct LDEs:
i1-1=i2
i1+1=i2
0=0
i1=i2
0=i2-1
1=0
0=i2
0=i2+1
1=i2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/methods/finitedifferences/meshers/uniformgridmesher.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i < layout->dim().size()  ++i
induction variable: ['i']
{
L5445: (dx_[i]=,w) (boundaries[i].second-,r) (boundaries[i].first,r) 
L5446: (locations_[i]=,w) 
	loop info: Size j=0  j < layout->dim()[i]  ++j
	induction variable: ['i', 'j']
	{
	L5447: (locations_[i][j]=,w) (boundaries[i].first+,r) (dx_[i],r) 
	}
 }
array table
-----------------------------------------------
dx_ -> [('[i]', 'w', 'normalized', ['i', 'j'], 5445), ('[i]', 'r', 'normalized', ['i', 'j'], 5447)]
LDEs formed:2

boundaries -> [('[i]', 'r', 'normalized', ['i', 'j'], 5445), ('[i]', 'r', 'normalized', ['i', 'j'], 5445), ('[i]', 'r', 'normalized', ['i', 'j'], 5447)]
LDEs formed:0

locations_ -> [('[i]', 'w', 'normalized', ['i', 'j'], 5446), ('[i][j]', 'w', 'normalized', ['i', 'j'], 5447)]
LDEs formed:6

distinct LDEs:
i1=i2,j1=j2
i1=i2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/methods/finitedifferences/meshers/concentrating1dmesher.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=1  i < size-1  ++i
induction variable: ['i']
{
L5448: (locations_[i]=,w) 
}
array table
-----------------------------------------------
locations_ -> [('[i]', 'w', 'normalized', ['i'], 5448)]
LDEs formed:1

distinct LDEs:
i1=i2
#########################################################################################
loop info: Size i=1  i < size-1  ++i
induction variable: ['i']
{
L5449: (locations_[i]=,w) 
}
array table
-----------------------------------------------
locations_ -> [('[i]', 'w', 'normalized', ['i'], 5449)]
LDEs formed:1

distinct LDEs:
i1=i2
#########################################################################################
loop info: Size i=0  i < size-1  ++i
induction variable: ['i']
{
L5450: (dplus_[i]=,w) (dminus_[i+1]=,w) (locations_[i+1]-,r) (locations_[i],r) 
}
array table
-----------------------------------------------
locations_ -> [('[i+1]', 'r', 'normalized', ['i'], 5450), ('[i]', 'r', 'normalized', ['i'], 5450)]
LDEs formed:0

dminus_ -> [('[i+1]', 'w', 'normalized', ['i'], 5450)]
LDEs formed:1

dplus_ -> [('[i]', 'w', 'normalized', ['i'], 5450)]
LDEs formed:1

distinct LDEs:
i1+1=i2+1
i1=i2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/methods/finitedifferences/meshers/fdmmeshercomposite.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i < dim.size()  ++i
induction variable: ['i']
{
L5451: (dim[i]=,w) (meshers[i]-,r) 
}
array table
-----------------------------------------------
dim -> [('[i]', 'w', 'normalized', ['i'], 5451)]
LDEs formed:1

meshers -> [('[i]', 'r', 'normalized', ['i'], 5451)]
LDEs formed:0

distinct LDEs:
i1=i2
#########################################################################################
loop info: Size i=0  i < mesher.size()  ++i
induction variable: ['i']
{
L5452: (mesher[i]-,r) 
}
array table
-----------------------------------------------
mesher -> [('[i]', 'r', 'normalized', ['i'], 5452)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/methods/finitedifferences/meshers/fdmblackscholesmultistrikemesher.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i < locations_.size()  ++i
induction variable: ['i']
{
L5453: (dplus_[i]=,w) 
L5454: (dminus_[i]=,w) 
}
array table
-----------------------------------------------
dminus_ -> [('[i]', 'w', 'normalized', ['i'], 5454)]
LDEs formed:1

dplus_ -> [('[i]', 'w', 'normalized', ['i'], 5453)]
LDEs formed:1

distinct LDEs:
i1=i2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/methods/finitedifferences/meshers/fdmblackscholesmesher.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i < locations_.size()  ++i
induction variable: ['i']
{
L5454: (dplus_[i]=,w) 
L5455: (dminus_[i]=,w) 
}
array table
-----------------------------------------------
dminus_ -> [('[i]', 'w', 'normalized', ['i'], 5455)]
LDEs formed:1

dplus_ -> [('[i]', 'w', 'normalized', ['i'], 5454)]
LDEs formed:1

distinct LDEs:
i1=i2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/methods/finitedifferences/meshers/fdmhestonvariancemesher.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i < size  ++i
induction variable: ['i']
{
	loop info: Size j=b  j < e  ++j
	induction variable: ['i', 'j']
	{
	L5455: (vGrid[i]+=,w) (tp[j].first/,r) 
	L5456: (pGrid[i]+=,w) (tp[j].second/,r) 
	}
 }
array table
-----------------------------------------------
vGrid -> [('[i]', 'w', 'normalized', ['i', 'j'], 5455)]
LDEs formed:1

pGrid -> [('[i]', 'w', 'normalized', ['i', 'j'], 5456)]
LDEs formed:1

tp -> [('[j]', 'r', 'normalized', ['i', 'j'], 5455), ('[j]', 'r', 'normalized', ['i', 'j'], 5456)]
LDEs formed:0

distinct LDEs:
i1=i2
#########################################################################################
loop info: Size i=0  i < size  ++i
induction variable: ['i']
{
L5457: (pGrid[i]=,w) 
L5458: (vGrid[i]=,w) 
}
array table
-----------------------------------------------
vGrid -> [('[i]', 'w', 'normalized', ['i'], 5458)]
LDEs formed:1

pGrid -> [('[i]', 'w', 'normalized', ['i'], 5457)]
LDEs formed:1

distinct LDEs:
i1=i2
#########################################################################################
loop info: Size i=1  i<vGrid.size()  ++i
induction variable: ['i']
{
L5458: (vGrid[i-1],r) (vGrid[i],r) 
L5459: (vGrid[i-1]-,r) (vGrid[i]-,r) 
L5460: (vGrid[i-1]=,w) 
L5461: (vGrid[i]=,w) 
}
array table
-----------------------------------------------
vGrid -> [('[i-1]', 'r', 'normalized', ['i'], 5458), ('[i]', 'r', 'normalized', ['i'], 5458), ('[i-1]', 'r', 'normalized', ['i'], 5459), ('[i]', 'r', 'normalized', ['i'], 5459), ('[i-1]', 'w', 'normalized', ['i'], 5460), ('[i]', 'w', 'normalized', ['i'], 5461)]
LDEs formed:11

distinct LDEs:
i1=i2
i1-1=i2
i1-1=i2-1
#########################################################################################
loop info: Size i=0  i < size-1  ++i
induction variable: ['i']
{
L5462: (dminus_[i+1]=,w) (dplus_[i]=,w) (vGrid[i+1]-,r) (vGrid[i],r) 
}
array table
-----------------------------------------------
vGrid -> [('[i+1]', 'r', 'normalized', ['i'], 5462), ('[i]', 'r', 'normalized', ['i'], 5462)]
LDEs formed:0

dminus_ -> [('[i+1]', 'w', 'normalized', ['i'], 5462)]
LDEs formed:1

dplus_ -> [('[i]', 'w', 'normalized', ['i'], 5462)]
LDEs formed:1

distinct LDEs:
i1+1=i2+1
i1=i2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/methods/finitedifferences/meshers/exponentialjump1dmesher.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i < steps  ++i
induction variable: ['i']
{
L5463: (locations_[i]=,w) 
}
array table
-----------------------------------------------
locations_ -> [('[i]', 'w', 'normalized', ['i'], 5463)]
LDEs formed:1

distinct LDEs:
i1=i2
#########################################################################################
loop info: Size i=0  i < steps-1  ++i
induction variable: ['i']
{
L5464: (dminus_[i+1]=,w) (dplus_[i]=,w) (locations_[i+1]-,r) (locations_[i],r) 
}
array table
-----------------------------------------------
locations_ -> [('[i+1]', 'r', 'normalized', ['i'], 5464), ('[i]', 'r', 'normalized', ['i'], 5464)]
LDEs formed:0

dminus_ -> [('[i+1]', 'w', 'normalized', ['i'], 5464)]
LDEs formed:1

dplus_ -> [('[i]', 'w', 'normalized', ['i'], 5464)]
LDEs formed:1

distinct LDEs:
i1+1=i2+1
i1=i2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/methods/finitedifferences/meshers/fdmsimpleprocess1dmesher.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size l=1  l<=tAvgSteps  ++l
induction variable: ['l']
{
L5465: (locations_[0]+=,w) 
	loop info: Size i=1  i < size-1  ++i
	induction variable: ['l', 'i']
	{
	L5466: (locations_[i]+=,w) 
	}
 }
array table
-----------------------------------------------
locations_ -> [('[0]', 'w', 'normalized', ['l', 'i'], 5465), ('[i]', 'w', 'normalized', ['l', 'i'], 5466)]
LDEs formed:3

distinct LDEs:
0=i2
0=0
i1=i2
#########################################################################################
loop info: Size i=0  i < size-1  ++i
induction variable: ['i']
{
L5467: (dminus_[i+1]=,w) (dplus_[i]=,w) (locations_[i+1]-,r) (locations_[i],r) 
}
array table
-----------------------------------------------
locations_ -> [('[i+1]', 'r', 'normalized', ['i'], 5467), ('[i]', 'r', 'normalized', ['i'], 5467)]
LDEs formed:0

dminus_ -> [('[i+1]', 'w', 'normalized', ['i'], 5467)]
LDEs formed:1

dplus_ -> [('[i]', 'w', 'normalized', ['i'], 5467)]
LDEs formed:1

distinct LDEs:
i1+1=i2+1
i1=i2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/methods/finitedifferences/operators/secondordermixedderivativeop.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: FdmLinearOpIterator iter = layout->begin()  iter!=endIter  ++iter
induction variable: ['iter']
{
L5468: (a00_[i]=,w) (a01_[i]=,w) (a02_[i]=,w) (a10_[i]=,w) (a20_[i]=,w) 
L5469: (a21_[i]=,w) (a12_[i]=,w) (a11_[i]=,w) (a22_[i]=,w) 
L5470: (a22_[i]=,w) (a21_[i]=,w) (a20_[i]=,w) (a10_[i]=,w) (a00_[i]=,w) 
L5471: (a11_[i]=,w) (a02_[i]=,w) (a01_[i]=,w) (a12_[i]=,w) 
L5472: (a00_[i]=,w) (a01_[i]=,w) (a02_[i]=,w) (a12_[i]=,w) (a22_[i]=,w) 
L5473: (a20_[i]=,w) (a11_[i]=,w) (a10_[i]=,w) (a21_[i]=,w) 
L5474: (a20_[i]=,w) (a21_[i]=,w) (a22_[i]=,w) (a12_[i]=,w) (a02_[i]=,w) 
L5475: (a10_[i]=,w) (a01_[i]=,w) (a00_[i]=,w) (a11_[i]=,w) 
L5476: (a00_[i]=,w) (a01_[i]=,w) (a02_[i]=,w) 
L5477: (a20_[i]=,w) (a10_[i]=,w) 
L5478: (a11_[i]=,w) (a21_[i]=,w) 
L5479: (a12_[i]=,w) (a22_[i]=,w) 
L5480: (a20_[i]=,w) (a21_[i]=,w) (a22_[i]=,w) 
L5481: (a10_[i]=,w) (a00_[i]=,w) 
L5482: (a01_[i]=,w) (a11_[i]=,w) 
L5483: (a02_[i]=,w) (a12_[i]=,w) 
L5484: (a00_[i]=,w) (a10_[i]=,w) (a20_[i]=,w) 
L5485: (a02_[i]=,w) (a01_[i]=,w) 
L5486: (a11_[i]=,w) (a12_[i]=,w) 
L5487: (a21_[i]=,w) (a22_[i]=,w) 
L5488: (a22_[i]=,w) (a12_[i]=,w) (a02_[i]=,w) 
L5489: (a01_[i]=,w) (a00_[i]=,w) 
L5490: (a10_[i]=,w) (a11_[i]=,w) 
L5491: (a20_[i]=,w) (a21_[i]=,w) 
L5492: (a00_[i]=,w) 
L5493: (a10_[i]=,w) 
L5494: (a20_[i]=,w) 
L5495: (a01_[i]=,w) 
L5496: (a11_[i]=,w) 
L5497: (a21_[i]=,w) 
L5498: (a02_[i]=,w) 
L5499: (a12_[i]=,w) 
L5500: (a22_[i]=,w) 
}
array table
-----------------------------------------------
a00_ -> [('[i]', 'w', 'not normalized', ['iter'], 5468), ('[i]', 'w', 'not normalized', ['iter'], 5470), ('[i]', 'w', 'not normalized', ['iter'], 5472), ('[i]', 'w', 'not normalized', ['iter'], 5475), ('[i]', 'w', 'not normalized', ['iter'], 5476), ('[i]', 'w', 'not normalized', ['iter'], 5481), ('[i]', 'w', 'not normalized', ['iter'], 5484), ('[i]', 'w', 'not normalized', ['iter'], 5489), ('[i]', 'w', 'not normalized', ['iter'], 5492)]
LDEs formed:45

a01_ -> [('[i]', 'w', 'not normalized', ['iter'], 5468), ('[i]', 'w', 'not normalized', ['iter'], 5471), ('[i]', 'w', 'not normalized', ['iter'], 5472), ('[i]', 'w', 'not normalized', ['iter'], 5475), ('[i]', 'w', 'not normalized', ['iter'], 5476), ('[i]', 'w', 'not normalized', ['iter'], 5482), ('[i]', 'w', 'not normalized', ['iter'], 5485), ('[i]', 'w', 'not normalized', ['iter'], 5489), ('[i]', 'w', 'not normalized', ['iter'], 5495)]
LDEs formed:45

a10_ -> [('[i]', 'w', 'not normalized', ['iter'], 5468), ('[i]', 'w', 'not normalized', ['iter'], 5470), ('[i]', 'w', 'not normalized', ['iter'], 5473), ('[i]', 'w', 'not normalized', ['iter'], 5475), ('[i]', 'w', 'not normalized', ['iter'], 5477), ('[i]', 'w', 'not normalized', ['iter'], 5481), ('[i]', 'w', 'not normalized', ['iter'], 5484), ('[i]', 'w', 'not normalized', ['iter'], 5490), ('[i]', 'w', 'not normalized', ['iter'], 5493)]
LDEs formed:45

a11_ -> [('[i]', 'w', 'not normalized', ['iter'], 5469), ('[i]', 'w', 'not normalized', ['iter'], 5471), ('[i]', 'w', 'not normalized', ['iter'], 5473), ('[i]', 'w', 'not normalized', ['iter'], 5475), ('[i]', 'w', 'not normalized', ['iter'], 5478), ('[i]', 'w', 'not normalized', ['iter'], 5482), ('[i]', 'w', 'not normalized', ['iter'], 5486), ('[i]', 'w', 'not normalized', ['iter'], 5490), ('[i]', 'w', 'not normalized', ['iter'], 5496)]
LDEs formed:45

a20_ -> [('[i]', 'w', 'not normalized', ['iter'], 5468), ('[i]', 'w', 'not normalized', ['iter'], 5470), ('[i]', 'w', 'not normalized', ['iter'], 5473), ('[i]', 'w', 'not normalized', ['iter'], 5474), ('[i]', 'w', 'not normalized', ['iter'], 5477), ('[i]', 'w', 'not normalized', ['iter'], 5480), ('[i]', 'w', 'not normalized', ['iter'], 5484), ('[i]', 'w', 'not normalized', ['iter'], 5491), ('[i]', 'w', 'not normalized', ['iter'], 5494)]
LDEs formed:45

a12_ -> [('[i]', 'w', 'not normalized', ['iter'], 5469), ('[i]', 'w', 'not normalized', ['iter'], 5471), ('[i]', 'w', 'not normalized', ['iter'], 5472), ('[i]', 'w', 'not normalized', ['iter'], 5474), ('[i]', 'w', 'not normalized', ['iter'], 5479), ('[i]', 'w', 'not normalized', ['iter'], 5483), ('[i]', 'w', 'not normalized', ['iter'], 5486), ('[i]', 'w', 'not normalized', ['iter'], 5488), ('[i]', 'w', 'not normalized', ['iter'], 5499)]
LDEs formed:45

a22_ -> [('[i]', 'w', 'not normalized', ['iter'], 5469), ('[i]', 'w', 'not normalized', ['iter'], 5470), ('[i]', 'w', 'not normalized', ['iter'], 5472), ('[i]', 'w', 'not normalized', ['iter'], 5474), ('[i]', 'w', 'not normalized', ['iter'], 5479), ('[i]', 'w', 'not normalized', ['iter'], 5480), ('[i]', 'w', 'not normalized', ['iter'], 5487), ('[i]', 'w', 'not normalized', ['iter'], 5488), ('[i]', 'w', 'not normalized', ['iter'], 5500)]
LDEs formed:45

a02_ -> [('[i]', 'w', 'not normalized', ['iter'], 5468), ('[i]', 'w', 'not normalized', ['iter'], 5471), ('[i]', 'w', 'not normalized', ['iter'], 5472), ('[i]', 'w', 'not normalized', ['iter'], 5474), ('[i]', 'w', 'not normalized', ['iter'], 5476), ('[i]', 'w', 'not normalized', ['iter'], 5483), ('[i]', 'w', 'not normalized', ['iter'], 5485), ('[i]', 'w', 'not normalized', ['iter'], 5488), ('[i]', 'w', 'not normalized', ['iter'], 5498)]
LDEs formed:45

a21_ -> [('[i]', 'w', 'not normalized', ['iter'], 5469), ('[i]', 'w', 'not normalized', ['iter'], 5470), ('[i]', 'w', 'not normalized', ['iter'], 5473), ('[i]', 'w', 'not normalized', ['iter'], 5474), ('[i]', 'w', 'not normalized', ['iter'], 5478), ('[i]', 'w', 'not normalized', ['iter'], 5480), ('[i]', 'w', 'not normalized', ['iter'], 5487), ('[i]', 'w', 'not normalized', ['iter'], 5491), ('[i]', 'w', 'not normalized', ['iter'], 5497)]
LDEs formed:45

distinct LDEs:
i=i
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/methods/finitedifferences/operators/secondderivativeop.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: FdmLinearOpIterator iter = layout->begin()  iter!=endIter  ++iter
induction variable: ['iter']
{
L5498: (lower_[i]=,w) (diag_[i]=,w) (upper_[i]=,w) 
L5499: (lower_[i]=,w) 
L5500: (diag_[i]=,w) 
L5501: (upper_[i]=,w) 
}
array table
-----------------------------------------------
lower_ -> [('[i]', 'w', 'not normalized', ['iter'], 5498), ('[i]', 'w', 'not normalized', ['iter'], 5499)]
LDEs formed:3

diag_ -> [('[i]', 'w', 'not normalized', ['iter'], 5498), ('[i]', 'w', 'not normalized', ['iter'], 5500)]
LDEs formed:3

upper_ -> [('[i]', 'w', 'not normalized', ['iter'], 5498), ('[i]', 'w', 'not normalized', ['iter'], 5501)]
LDEs formed:3

distinct LDEs:
i=i
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/methods/finitedifferences/operators/fdmbatesop.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i < f.rows()  ++i
induction variable: ['i']
{
L5502: (interpl[i]=,w) 
}
array table
-----------------------------------------------
interpl -> [('[i]', 'w', 'normalized', ['i'], 5502)]
LDEs formed:1

distinct LDEs:
i1=i2
#########################################################################################
loop info: FdmLinearOpIterator iter=layout->begin()  iter!=endIter  ++iter
induction variable: ['iter']
{
L5503: (integral[iter.index()]=,w) 
L5504: (interpl[j],r) (x[i],r) 
}
array table
-----------------------------------------------
x -> [('[i]', 'r', 'not normalized', ['iter'], 5504)]
LDEs formed:0

integral -> [('[iter.index()]', 'w', 'not normalized', ['iter'], 5503)]
LDEs formed:1

interpl -> [('[j]', 'r', 'not normalized', ['iter'], 5504)]
LDEs formed:0

distinct LDEs:
iter1.index()=iter2.index()
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/methods/finitedifferences/operators/firstderivativeop.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: FdmLinearOpIterator iter = layout->begin()  iter!=endIter  ++iter
induction variable: ['iter']
{
L5505: (lower_[i]=,w) 
L5506: (diag_[i]=,w) (upper_[i]=,w) 
L5507: (lower_[i]=,w) (diag_[i]=,w) 
L5508: (upper_[i]=,w) 
L5509: (lower_[i]=,w) 
L5510: (diag_[i]=,w) 
L5511: (upper_[i]=,w) 
}
array table
-----------------------------------------------
lower_ -> [('[i]', 'w', 'not normalized', ['iter'], 5505), ('[i]', 'w', 'not normalized', ['iter'], 5507), ('[i]', 'w', 'not normalized', ['iter'], 5509)]
LDEs formed:6

diag_ -> [('[i]', 'w', 'not normalized', ['iter'], 5506), ('[i]', 'w', 'not normalized', ['iter'], 5507), ('[i]', 'w', 'not normalized', ['iter'], 5510)]
LDEs formed:6

upper_ -> [('[i]', 'w', 'not normalized', ['iter'], 5506), ('[i]', 'w', 'not normalized', ['iter'], 5508), ('[i]', 'w', 'not normalized', ['iter'], 5511)]
LDEs formed:6

distinct LDEs:
i=i
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/methods/finitedifferences/operators/ninepointlinearop.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: FdmLinearOpIterator iter = layout->begin()  iter!=endIter  ++iter
induction variable: ['iter']
{
L5512: (i10_[i]=,w) 
L5513: (i01_[i]=,w) 
L5514: (i21_[i]=,w) 
L5515: (i12_[i]=,w) 
L5516: (i00_[i]=,w) 
L5517: (i20_[i]=,w) 
L5518: (i02_[i]=,w) 
L5519: (i22_[i]=,w) 
}
array table
-----------------------------------------------
i22_ -> [('[i]', 'w', 'not normalized', ['iter'], 5519)]
LDEs formed:1

i02_ -> [('[i]', 'w', 'not normalized', ['iter'], 5518)]
LDEs formed:1

i21_ -> [('[i]', 'w', 'not normalized', ['iter'], 5514)]
LDEs formed:1

i00_ -> [('[i]', 'w', 'not normalized', ['iter'], 5516)]
LDEs formed:1

i01_ -> [('[i]', 'w', 'not normalized', ['iter'], 5513)]
LDEs formed:1

i10_ -> [('[i]', 'w', 'not normalized', ['iter'], 5512)]
LDEs formed:1

i20_ -> [('[i]', 'w', 'not normalized', ['iter'], 5517)]
LDEs formed:1

i12_ -> [('[i]', 'w', 'not normalized', ['iter'], 5515)]
LDEs formed:1

distinct LDEs:
i=i
#########################################################################################
loop info: Size i=0  i < retVal.size()  ++i
induction variable: ['i']
{
L5516: (retVal[i]=,w) (a00[i]*,r) (i00[i],r) 
L5517: (a01[i]*,r) (i01[i],r) 
L5518: (a02[i]*,r) (i02[i],r) 
L5519: (a10[i]*,r) (i10[i],r) 
L5520: (a11[i]*,r) (u[i],r) 
L5521: (a12[i]*,r) (i12[i],r) 
L5522: (a20[i]*,r) (i20[i],r) 
L5523: (a21[i]*,r) (i21[i],r) 
L5524: (a22[i]*,r) (i22[i],r) 
}
array table
-----------------------------------------------
a20 -> [('[i]', 'r', 'normalized', ['i'], 5522)]
LDEs formed:0

a21 -> [('[i]', 'r', 'normalized', ['i'], 5523)]
LDEs formed:0

a22 -> [('[i]', 'r', 'normalized', ['i'], 5524)]
LDEs formed:0

a11 -> [('[i]', 'r', 'normalized', ['i'], 5520)]
LDEs formed:0

a10 -> [('[i]', 'r', 'normalized', ['i'], 5519)]
LDEs formed:0

a12 -> [('[i]', 'r', 'normalized', ['i'], 5521)]
LDEs formed:0

a02 -> [('[i]', 'r', 'normalized', ['i'], 5518)]
LDEs formed:0

i21 -> [('[i]', 'r', 'normalized', ['i'], 5523)]
LDEs formed:0

a00 -> [('[i]', 'r', 'normalized', ['i'], 5516)]
LDEs formed:0

a01 -> [('[i]', 'r', 'normalized', ['i'], 5517)]
LDEs formed:0

i10 -> [('[i]', 'r', 'normalized', ['i'], 5519)]
LDEs formed:0

i12 -> [('[i]', 'r', 'normalized', ['i'], 5521)]
LDEs formed:0

i02 -> [('[i]', 'r', 'normalized', ['i'], 5518)]
LDEs formed:0

i20 -> [('[i]', 'r', 'normalized', ['i'], 5522)]
LDEs formed:0

i00 -> [('[i]', 'r', 'normalized', ['i'], 5516)]
LDEs formed:0

i01 -> [('[i]', 'r', 'normalized', ['i'], 5517)]
LDEs formed:0

u -> [('[i]', 'r', 'normalized', ['i'], 5520)]
LDEs formed:0

retVal -> [('[i]', 'w', 'normalized', ['i'], 5516)]
LDEs formed:1

i22 -> [('[i]', 'r', 'normalized', ['i'], 5524)]
LDEs formed:0

distinct LDEs:
i1=i2
#########################################################################################
loop info: Size i=0  i < index->size()  ++i
induction variable: ['i']
{
L5525: (i00_[i],r) (a00_[i],r) 
L5526: (i01_[i],r) (a01_[i],r) 
L5527: (i02_[i],r) (a02_[i],r) 
L5528: (i10_[i],r) (a10_[i],r) 
L5529: (a11_[i],r) 
L5530: (i12_[i],r) (a12_[i],r) 
L5531: (i20_[i],r) (a20_[i],r) 
L5532: (i21_[i],r) (a21_[i],r) 
L5533: (i22_[i],r) (a22_[i],r) 
}
array table
-----------------------------------------------
a00_ -> [('[i]', 'r', 'normalized', ['i'], 5525)]
LDEs formed:0

i22_ -> [('[i]', 'r', 'normalized', ['i'], 5533)]
LDEs formed:0

i02_ -> [('[i]', 'r', 'normalized', ['i'], 5527)]
LDEs formed:0

a01_ -> [('[i]', 'r', 'normalized', ['i'], 5526)]
LDEs formed:0

i21_ -> [('[i]', 'r', 'normalized', ['i'], 5532)]
LDEs formed:0

i00_ -> [('[i]', 'r', 'normalized', ['i'], 5525)]
LDEs formed:0

a10_ -> [('[i]', 'r', 'normalized', ['i'], 5528)]
LDEs formed:0

i01_ -> [('[i]', 'r', 'normalized', ['i'], 5526)]
LDEs formed:0

a11_ -> [('[i]', 'r', 'normalized', ['i'], 5529)]
LDEs formed:0

a21_ -> [('[i]', 'r', 'normalized', ['i'], 5532)]
LDEs formed:0

i10_ -> [('[i]', 'r', 'normalized', ['i'], 5528)]
LDEs formed:0

a20_ -> [('[i]', 'r', 'normalized', ['i'], 5531)]
LDEs formed:0

a12_ -> [('[i]', 'r', 'normalized', ['i'], 5530)]
LDEs formed:0

a22_ -> [('[i]', 'r', 'normalized', ['i'], 5533)]
LDEs formed:0

a02_ -> [('[i]', 'r', 'normalized', ['i'], 5527)]
LDEs formed:0

i20_ -> [('[i]', 'r', 'normalized', ['i'], 5531)]
LDEs formed:0

i12_ -> [('[i]', 'r', 'normalized', ['i'], 5530)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i < size  ++i
induction variable: ['i']
{
L5531: (u[i],r) 
L5532: (retVal.a11_[i]=,w) (a11_[i]*,r) (retVal.a00_[i]=,w) (a00_[i]*,r) 
L5533: (retVal.a01_[i]=,w) (a01_[i]*,r) (retVal.a02_[i]=,w) (a02_[i]*,r) 
L5534: (retVal.a10_[i]=,w) (a10_[i]*,r) (retVal.a20_[i]=,w) (a20_[i]*,r) 
L5535: (retVal.a21_[i]=,w) (a21_[i]*,r) (retVal.a12_[i]=,w) (a12_[i]*,r) 
L5536: (retVal.a22_[i]=,w) (a22_[i]*,r) 
}
array table
-----------------------------------------------
a00_ -> [('[i]', 'r', 'normalized', ['i'], 5532)]
LDEs formed:0

retVal.a11_ -> [('[i]', 'w', 'normalized', ['i'], 5532)]
LDEs formed:1

a01_ -> [('[i]', 'r', 'normalized', ['i'], 5533)]
LDEs formed:0

retVal.a10_ -> [('[i]', 'w', 'normalized', ['i'], 5534)]
LDEs formed:1

a10_ -> [('[i]', 'r', 'normalized', ['i'], 5534)]
LDEs formed:0

retVal.a22_ -> [('[i]', 'w', 'normalized', ['i'], 5536)]
LDEs formed:1

retVal.a01_ -> [('[i]', 'w', 'normalized', ['i'], 5533)]
LDEs formed:1

retVal.a21_ -> [('[i]', 'w', 'normalized', ['i'], 5535)]
LDEs formed:1

a11_ -> [('[i]', 'r', 'normalized', ['i'], 5532)]
LDEs formed:0

retVal.a00_ -> [('[i]', 'w', 'normalized', ['i'], 5532)]
LDEs formed:1

a22_ -> [('[i]', 'r', 'normalized', ['i'], 5536)]
LDEs formed:0

a20_ -> [('[i]', 'r', 'normalized', ['i'], 5534)]
LDEs formed:0

u -> [('[i]', 'r', 'normalized', ['i'], 5531)]
LDEs formed:0

retVal.a02_ -> [('[i]', 'w', 'normalized', ['i'], 5533)]
LDEs formed:1

a21_ -> [('[i]', 'r', 'normalized', ['i'], 5535)]
LDEs formed:0

a12_ -> [('[i]', 'r', 'normalized', ['i'], 5535)]
LDEs formed:0

retVal.a12_ -> [('[i]', 'w', 'normalized', ['i'], 5535)]
LDEs formed:1

a02_ -> [('[i]', 'r', 'normalized', ['i'], 5533)]
LDEs formed:0

retVal.a20_ -> [('[i]', 'w', 'normalized', ['i'], 5534)]
LDEs formed:1

distinct LDEs:
i1=i2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/methods/finitedifferences/operators/triplebandlinearop.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: FdmLinearOpIterator iter = layout->begin()  iter!=endIter  ++iter
induction variable: ['iter']
{
L5535: (i0_[i]=,w) 
L5536: (i2_[i]=,w) 
L5537: (reverseIndex_[newIndex]=,w) 
}
array table
-----------------------------------------------
reverseIndex_ -> [('[newIndex]', 'w', 'not normalized', ['iter'], 5537)]
LDEs formed:1

i0_ -> [('[i]', 'w', 'not normalized', ['iter'], 5535)]
LDEs formed:1

i2_ -> [('[i]', 'w', 'not normalized', ['iter'], 5536)]
LDEs formed:1

distinct LDEs:
i=i
newIndex=newIndex
#########################################################################################
loop info: Size i=0  i < size  ++i
induction variable: ['i']
{
L5537: (diag[i]=,w) (y_diag[i],r) 
L5538: (lower[i]=,w) (y_lower[i],r) 
L5539: (upper[i]=,w) (y_upper[i],r) 
}
array table
-----------------------------------------------
upper -> [('[i]', 'w', 'normalized', ['i'], 5539)]
LDEs formed:1

lower -> [('[i]', 'w', 'normalized', ['i'], 5538)]
LDEs formed:1

y_lower -> [('[i]', 'r', 'normalized', ['i'], 5538)]
LDEs formed:0

y_diag -> [('[i]', 'r', 'normalized', ['i'], 5537)]
LDEs formed:0

diag -> [('[i]', 'w', 'normalized', ['i'], 5537)]
LDEs formed:1

y_upper -> [('[i]', 'r', 'normalized', ['i'], 5539)]
LDEs formed:0

distinct LDEs:
i1=i2
#########################################################################################
loop info: Size i=0  i < size  ++i
induction variable: ['i']
{
L5540: (diag[i]=,w) (y_diag[i]+,r) (bptr[i*binc],r) 
L5541: (lower[i]=,w) (y_lower[i],r) 
L5542: (upper[i]=,w) (y_upper[i],r) 
}
array table
-----------------------------------------------
upper -> [('[i]', 'w', 'normalized', ['i'], 5542)]
LDEs formed:1

lower -> [('[i]', 'w', 'normalized', ['i'], 5541)]
LDEs formed:1

y_lower -> [('[i]', 'r', 'normalized', ['i'], 5541)]
LDEs formed:0

y_diag -> [('[i]', 'r', 'normalized', ['i'], 5540)]
LDEs formed:0

diag -> [('[i]', 'w', 'normalized', ['i'], 5540)]
LDEs formed:1

bptr -> [('[i*binc]', 'r', 'not normalized', ['i'], 5540)]
LDEs formed:0

y_upper -> [('[i]', 'r', 'normalized', ['i'], 5542)]
LDEs formed:0

distinct LDEs:
i1=i2
#########################################################################################
loop info: Size i=0  i < size  ++i
induction variable: ['i']
{
L5543: (aptr[i*ainc],r) 
L5544: (diag[i]=,w) (y_diag[i]+,r) (x_diag[i],r) 
L5545: (lower[i]=,w) (y_lower[i]+,r) (x_lower[i],r) 
L5546: (upper[i]=,w) (y_upper[i]+,r) (x_upper[i],r) 
}
array table
-----------------------------------------------
upper -> [('[i]', 'w', 'normalized', ['i'], 5546)]
LDEs formed:1

lower -> [('[i]', 'w', 'normalized', ['i'], 5545)]
LDEs formed:1

y_lower -> [('[i]', 'r', 'normalized', ['i'], 5545)]
LDEs formed:0

y_diag -> [('[i]', 'r', 'normalized', ['i'], 5544)]
LDEs formed:0

diag -> [('[i]', 'w', 'normalized', ['i'], 5544)]
LDEs formed:1

x_upper -> [('[i]', 'r', 'normalized', ['i'], 5546)]
LDEs formed:0

aptr -> [('[i*ainc]', 'r', 'not normalized', ['i'], 5543)]
LDEs formed:0

y_upper -> [('[i]', 'r', 'normalized', ['i'], 5546)]
LDEs formed:0

x_lower -> [('[i]', 'r', 'normalized', ['i'], 5545)]
LDEs formed:0

x_diag -> [('[i]', 'r', 'normalized', ['i'], 5544)]
LDEs formed:0

distinct LDEs:
i1=i2
#########################################################################################
loop info: Size i=0  i < size  ++i
induction variable: ['i']
{
L5545: (aptr[i*ainc],r) 
L5546: (diag[i]=,w) (y_diag[i]+,r) (x_diag[i]+,r) (bptr[i*binc],r) 
L5547: (lower[i]=,w) (y_lower[i]+,r) (x_lower[i],r) 
L5548: (upper[i]=,w) (y_upper[i]+,r) (x_upper[i],r) 
}
array table
-----------------------------------------------
upper -> [('[i]', 'w', 'normalized', ['i'], 5548)]
LDEs formed:1

lower -> [('[i]', 'w', 'normalized', ['i'], 5547)]
LDEs formed:1

y_lower -> [('[i]', 'r', 'normalized', ['i'], 5547)]
LDEs formed:0

y_diag -> [('[i]', 'r', 'normalized', ['i'], 5546)]
LDEs formed:0

diag -> [('[i]', 'w', 'normalized', ['i'], 5546)]
LDEs formed:1

x_upper -> [('[i]', 'r', 'normalized', ['i'], 5548)]
LDEs formed:0

aptr -> [('[i*ainc]', 'r', 'not normalized', ['i'], 5545)]
LDEs formed:0

bptr -> [('[i*binc]', 'r', 'not normalized', ['i'], 5546)]
LDEs formed:0

y_upper -> [('[i]', 'r', 'normalized', ['i'], 5548)]
LDEs formed:0

x_lower -> [('[i]', 'r', 'normalized', ['i'], 5547)]
LDEs formed:0

x_diag -> [('[i]', 'r', 'normalized', ['i'], 5546)]
LDEs formed:0

distinct LDEs:
i1=i2
#########################################################################################
loop info: Size i=0  i < size  ++i
induction variable: ['i']
{
L5547: (retVal.lower_[i]=,w) (lower_[i]+,r) (m.lower_[i],r) 
L5548: (retVal.diag_[i]=,w) (diag_[i]+,r) (m.diag_[i],r) 
L5549: (retVal.upper_[i]=,w) (upper_[i]+,r) (m.upper_[i],r) 
}
array table
-----------------------------------------------
retVal.lower_ -> [('[i]', 'w', 'normalized', ['i'], 5547)]
LDEs formed:1

m.diag_ -> [('[i]', 'r', 'normalized', ['i'], 5548)]
LDEs formed:0

lower_ -> [('[i]', 'r', 'normalized', ['i'], 5547)]
LDEs formed:0

m.lower_ -> [('[i]', 'r', 'normalized', ['i'], 5547)]
LDEs formed:0

retVal.diag_ -> [('[i]', 'w', 'normalized', ['i'], 5548)]
LDEs formed:1

upper_ -> [('[i]', 'r', 'normalized', ['i'], 5549)]
LDEs formed:0

m.upper_ -> [('[i]', 'r', 'normalized', ['i'], 5549)]
LDEs formed:0

diag_ -> [('[i]', 'r', 'normalized', ['i'], 5548)]
LDEs formed:0

retVal.upper_ -> [('[i]', 'w', 'normalized', ['i'], 5549)]
LDEs formed:1

distinct LDEs:
i1=i2
#########################################################################################
loop info: Size i=0  i < size  ++i
induction variable: ['i']
{
L5550: (u[i],r) 
L5551: (retVal.lower_[i]=,w) (lower_[i]*,r) 
L5552: (retVal.diag_[i]=,w) (diag_[i]*,r) 
L5553: (retVal.upper_[i]=,w) (upper_[i]*,r) 
}
array table
-----------------------------------------------
retVal.lower_ -> [('[i]', 'w', 'normalized', ['i'], 5551)]
LDEs formed:1

lower_ -> [('[i]', 'r', 'normalized', ['i'], 5551)]
LDEs formed:0

u -> [('[i]', 'r', 'normalized', ['i'], 5550)]
LDEs formed:0

upper_ -> [('[i]', 'r', 'normalized', ['i'], 5553)]
LDEs formed:0

retVal.diag_ -> [('[i]', 'w', 'normalized', ['i'], 5552)]
LDEs formed:1

diag_ -> [('[i]', 'r', 'normalized', ['i'], 5552)]
LDEs formed:0

retVal.upper_ -> [('[i]', 'w', 'normalized', ['i'], 5553)]
LDEs formed:1

distinct LDEs:
i1=i2
#########################################################################################
loop info: Size i=0  i < size  ++i
induction variable: ['i']
{
L5554: (retVal.lower_[i]=,w) (lower_[i],r) 
L5555: (retVal.upper_[i]=,w) (upper_[i],r) 
L5556: (retVal.diag_[i]=,w) (diag_[i]+,r) (u[i],r) 
}
array table
-----------------------------------------------
retVal.lower_ -> [('[i]', 'w', 'normalized', ['i'], 5554)]
LDEs formed:1

lower_ -> [('[i]', 'r', 'normalized', ['i'], 5554)]
LDEs formed:0

retVal.diag_ -> [('[i]', 'w', 'normalized', ['i'], 5556)]
LDEs formed:1

upper_ -> [('[i]', 'r', 'normalized', ['i'], 5555)]
LDEs formed:0

u -> [('[i]', 'r', 'normalized', ['i'], 5556)]
LDEs formed:0

diag_ -> [('[i]', 'r', 'normalized', ['i'], 5556)]
LDEs formed:0

retVal.upper_ -> [('[i]', 'w', 'normalized', ['i'], 5555)]
LDEs formed:1

distinct LDEs:
i1=i2
#########################################################################################
loop info: Size i=0  i < index->size()  ++i
induction variable: ['i']
{
L5556: (retVal[i]=,w) (i0ptr[i],r) (lptr[i]+,r) (r[i]*,r) (dptr[i]+,r) (i2ptr[i],r) (uptr[i],r) 
}
array table
-----------------------------------------------
i0ptr -> [('[i]', 'r', 'normalized', ['i'], 5556)]
LDEs formed:0

i2ptr -> [('[i]', 'r', 'normalized', ['i'], 5556)]
LDEs formed:0

lptr -> [('[i]', 'r', 'normalized', ['i'], 5556)]
LDEs formed:0

r -> [('[i]', 'r', 'normalized', ['i'], 5556)]
LDEs formed:0

dptr -> [('[i]', 'r', 'normalized', ['i'], 5556)]
LDEs formed:0

retVal -> [('[i]', 'w', 'normalized', ['i'], 5556)]
LDEs formed:1

uptr -> [('[i]', 'r', 'normalized', ['i'], 5556)]
LDEs formed:0

distinct LDEs:
i1=i2
#########################################################################################
loop info: Size i=0  i < n  ++i
induction variable: ['i']
{
L5557: (i0_[i],r) (lower_[i],r) 
L5558: (diag_[i],r) 
L5559: (i2_[i],r) (upper_[i],r) 
}
array table
-----------------------------------------------
upper_ -> [('[i]', 'r', 'normalized', ['i'], 5559)]
LDEs formed:0

i2_ -> [('[i]', 'r', 'normalized', ['i'], 5559)]
LDEs formed:0

lower_ -> [('[i]', 'r', 'normalized', ['i'], 5557)]
LDEs formed:0

i0_ -> [('[i]', 'r', 'normalized', ['i'], 5557)]
LDEs formed:0

diag_ -> [('[i]', 'r', 'normalized', ['i'], 5558)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size j=1  j<=layout->size()-1  j++
induction variable: ['j']
{
L5559: (reverseIndex_[j],r) 
L5560: (tmp[j]=,w) (uptr[rim1]*,r) 
L5561: (dptr[ri]-,r) (tmp[j]*,r) (lptr[ri],r) 
L5562: (retVal[ri]=,w) (r[ri]-,r) (lptr[ri]*,r) (retVal[rim1],r) 
}
array table
-----------------------------------------------
tmp -> [('[j]', 'w', 'normalized', ['j'], 5560), ('[j]', 'r', 'normalized', ['j'], 5561)]
LDEs formed:2

reverseIndex_ -> [('[j]', 'r', 'normalized', ['j'], 5559)]
LDEs formed:0

lptr -> [('[ri]', 'r', 'not normalized', ['j'], 5561), ('[ri]', 'r', 'not normalized', ['j'], 5562)]
LDEs formed:0

r -> [('[ri]', 'r', 'not normalized', ['j'], 5562)]
LDEs formed:0

dptr -> [('[ri]', 'r', 'not normalized', ['j'], 5561)]
LDEs formed:0

retVal -> [('[ri]', 'w', 'not normalized', ['j'], 5562), ('[rim1]', 'r', 'not normalized', ['j'], 5562)]
LDEs formed:2

uptr -> [('[rim1]', 'r', 'not normalized', ['j'], 5560)]
LDEs formed:0

distinct LDEs:
j1=j2
ri=ri
ri=rim1
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/methods/finitedifferences/solvers/fdm3dimsolver.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i < z_.size()  ++i
induction variable: ['i']
{
L5561: (resultValues_[i].begin,r) 
L5562: (interpolation_[i]=,w) 
L5563: (resultValues_[i],r) 
}
array table
-----------------------------------------------
resultValues_ -> [('[i]', 'r', 'normalized', ['i'], 5561), ('[i]', 'r', 'normalized', ['i'], 5563)]
LDEs formed:0

interpolation_ -> [('[i]', 'w', 'normalized', ['i'], 5562)]
LDEs formed:1

distinct LDEs:
i1=i2
#########################################################################################
loop info: Size i=0  i < z_.size()  ++i
induction variable: ['i']
{
L5563: (zArray[i]=,w) (interpolation_[i]-,r) 
}
array table
-----------------------------------------------
zArray -> [('[i]', 'w', 'normalized', ['i'], 5563)]
LDEs formed:1

interpolation_ -> [('[i]', 'r', 'normalized', ['i'], 5563)]
LDEs formed:0

distinct LDEs:
i1=i2
#########################################################################################
loop info: Size i=0  i < z_.size()  ++i
induction variable: ['i']
{
L5564: (thetaValues[i].begin,r) 
}
array table
-----------------------------------------------
thetaValues -> [('[i]', 'r', 'normalized', ['i'], 5564)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i < z_.size()  ++i
induction variable: ['i']
{
L5565: (zArray[i]=,w) 
L5566: (thetaValues[i],r) 
}
array table
-----------------------------------------------
zArray -> [('[i]', 'w', 'normalized', ['i'], 5565)]
LDEs formed:1

thetaValues -> [('[i]', 'r', 'normalized', ['i'], 5566)]
LDEs formed:0

distinct LDEs:
i1=i2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/methods/finitedifferences/utilities/fdmquantohelper.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i < retVal.size()  ++i
induction variable: ['i']
{
L5567: (retVal[i],r) 
L5568: (equityVol[i]*,r) 
}
array table
-----------------------------------------------
retVal -> [('[i]', 'r', 'normalized', ['i'], 5567)]
LDEs formed:0

equityVol -> [('[i]', 'r', 'normalized', ['i'], 5568)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/methods/finitedifferences/utilities/fdminnervaluecalculator.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i < x.size()  ++i
induction variable: ['i']
{
L5569: (x[i]=,w) 
}
array table
-----------------------------------------------
x -> [('[i]', 'w', 'normalized', ['i'], 5569)]
LDEs formed:1

distinct LDEs:
i1=i2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/methods/finitedifferences/utilities/fdmdividendhandler.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i = 0  i < x_.size()  ++i
induction variable: ['i']
{
L5570: (x_[i]=,w) (tmp[i*spacing],r) 
}
array table
-----------------------------------------------
tmp -> [('[i*spacing]', 'r', 'not normalized', ['i'], 5570)]
LDEs formed:0

x_ -> [('[i]', 'w', 'normalized', ['i'], 5570)]
LDEs formed:1

distinct LDEs:
i1=i2
#########################################################################################
loop info: Size k=0  k<x_.size()  ++k
induction variable: ['k']
{
L5571: (a[k]=,w) (x_[0],r) (x_[k]-,r) 
}
array table
-----------------------------------------------
a -> [('[k]', 'w', 'normalized', ['k'], 5571)]
LDEs formed:1

x_ -> [('[0]', 'r', 'normalized', ['k'], 5571), ('[k]', 'r', 'normalized', ['k'], 5571)]
LDEs formed:0

distinct LDEs:
k1=k2
#########################################################################################
loop info: Size i=0  i<mesher_->layout()->dim().size()  ++i
induction variable: ['i']
{
	loop info: Size j=0  j<mesher_->layout()->dim()[i]  ++j
	induction variable: ['i', 'j']
		{
			loop info: Size k=0  k<x_.size()  ++k
			induction variable: ['i', 'j', 'k']
			{
			L5572: (tmp[k]=,w) (aCopy[index],r) 
			}
			loop info: Size k=0  k<x_.size()  ++k
			induction variable: ['i', 'j', 'k']
			{
			L5573: (a[index]=,w) 
			L5574: (x_[0],r) (x_[k]-,r) 
			}
 		}
 }
array table
-----------------------------------------------
tmp -> [('[k]', 'w', 'normalized', ['i', 'j', 'k'], 5572)]
LDEs formed:1

a -> [('[index]', 'w', 'not normalized', ['i', 'j', 'k'], 5573)]
LDEs formed:1

aCopy -> [('[index]', 'r', 'not normalized', ['i', 'j', 'k'], 5572)]
LDEs formed:0

x_ -> [('[0]', 'r', 'normalized', ['i', 'j', 'k'], 5574), ('[k]', 'r', 'normalized', ['i', 'j', 'k'], 5574)]
LDEs formed:0

distinct LDEs:
index=index
k1=k2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/methods/finitedifferences/utilities/fdmmesherintegral.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i < x.size()  ++i
induction variable: ['i']
{
L5575: (g[i]=,w) 
}
array table
-----------------------------------------------
g -> [('[i]', 'w', 'normalized', ['i'], 5575)]
LDEs formed:1

distinct LDEs:
i1=i2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/methods/finitedifferences/schemes/craigsneydscheme.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/methods/finitedifferences/schemes/hundsdorferscheme.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/methods/finitedifferences/schemes/modifiedcraigsneydscheme.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/methods/finitedifferences/schemes/douglasscheme.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/methods/finitedifferences/stepconditions/fdmbermudanstepcondition.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/methods/finitedifferences/stepconditions/fdmarithmeticaveragecondition.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i = 0  i < x_.size()  ++i
induction variable: ['i']
{
L5576: (x_[i]=,w) (tmp[i*xSpacing],r) 
}
array table
-----------------------------------------------
tmp -> [('[i*xSpacing]', 'r', 'not normalized', ['i'], 5576)]
LDEs formed:0

x_ -> [('[i]', 'w', 'normalized', ['i'], 5576)]
LDEs formed:1

distinct LDEs:
i1=i2
#########################################################################################
loop info: Size i = 0  i < a_.size()  ++i
induction variable: ['i']
{
L5577: (a_[i]=,w) (tmp[i*aSpacing],r) 
}
array table
-----------------------------------------------
tmp -> [('[i*aSpacing]', 'r', 'not normalized', ['i'], 5577)]
LDEs formed:0

a_ -> [('[i]', 'w', 'normalized', ['i'], 5577)]
LDEs formed:1

distinct LDEs:
i1=i2
#########################################################################################
loop info: Size i=0  i<x_.size()  ++i
induction variable: ['i']
{
	loop info: Size j=0  j<a_.size()  ++j
	induction variable: ['i', 'j']
	{
	L5578: (tmp[j]=,w) (aCopy[index],r) 
	}
	loop info: Size j=0  j<a_.size()  ++j
	induction variable: ['i', 'j']
	{
	L5579: (a[index]=,w) (a_[j]+,r) 
	L5580: (x_[i],r) 
	}
 }
array table
-----------------------------------------------
tmp -> [('[j]', 'w', 'normalized', ['i', 'j'], 5578)]
LDEs formed:1

a -> [('[index]', 'w', 'not normalized', ['i', 'j'], 5579)]
LDEs formed:1

aCopy -> [('[index]', 'r', 'not normalized', ['i', 'j'], 5578)]
LDEs formed:0

x_ -> [('[i]', 'r', 'normalized', ['i', 'j'], 5580)]
LDEs formed:0

a_ -> [('[j]', 'r', 'normalized', ['i', 'j'], 5579)]
LDEs formed:0

distinct LDEs:
index=index
j1=j2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/processes/jointstochasticprocess.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: const_iterator iter = l_.begin()  iter != l_.end()  ++iter
induction variable: ['iter']
{
L5580: (vsize_[iter - l_.begin()],r) 
}
array table
-----------------------------------------------
vsize_ -> [('[iter - l_.begin()]', 'r', 'not normalized', ['iter'], 5580)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i < l_.size()  ++i
induction variable: ['i']
{
L5581: (l_[i]-,r) 
L5582: (vsize_[i],r) 
}
array table
-----------------------------------------------
l_ -> [('[i]', 'r', 'normalized', ['i'], 5581)]
LDEs formed:0

vsize_ -> [('[i]', 'r', 'normalized', ['i'], 5582)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i < l_.size()  ++i
induction variable: ['i']
{
L5583: (l_[i]-,r) 
L5584: (vsize_[i],r) 
}
array table
-----------------------------------------------
l_ -> [('[i]', 'r', 'normalized', ['i'], 5583)]
LDEs formed:0

vsize_ -> [('[i]', 'r', 'normalized', ['i'], 5584)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size j=0  j < l_.size()  ++j
induction variable: ['j']
{
L5585: (vsize_[j],r) 
L5586: (l_[j]-,r) 
	loop info: Size i=0  i < pCov.rows()  ++i
	induction variable: ['j', 'i']
	{
	}
 }
array table
-----------------------------------------------
l_ -> [('[j]', 'r', 'normalized', ['j', 'i'], 5586)]
LDEs formed:0

vsize_ -> [('[j]', 'r', 'normalized', ['j', 'i'], 5585)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i < size()  ++i
induction variable: ['i']
{
	loop info: Size j=0  j < size()  ++j
	induction variable: ['i', 'j']
	{
	L5586: (crossModelCovar[i][j]*=,w) (volatility[i]*,r) (volatility[j],r) 
	}
 }
array table
-----------------------------------------------
crossModelCovar -> [('[i][j]', 'w', 'normalized', ['i', 'j'], 5586)]
LDEs formed:2

volatility -> [('[i]', 'r', 'normalized', ['i', 'j'], 5586), ('[j]', 'r', 'normalized', ['i', 'j'], 5586)]
LDEs formed:0

distinct LDEs:
i1=i2,j1=j2
#########################################################################################
loop info: Size i=0  i < l_.size()  ++i
induction variable: ['i']
{
L5587: (l_[i]-,r) 
L5588: (vsize_[i],r) 
}
array table
-----------------------------------------------
l_ -> [('[i]', 'r', 'normalized', ['i'], 5587)]
LDEs formed:0

vsize_ -> [('[i]', 'r', 'normalized', ['i'], 5588)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i < cov.rows()  ++i
induction variable: ['i']
{
	loop info: Size j=i  j < cov.columns()  ++j
	induction variable: ['i', 'j']
	{
	L5589: (sqrtDiag[i]*,r) (sqrtDiag[j],r) 
	L5590: (cov[i][j]=,w) (cov[j][i]=,w) (cov[i][j]/,r) 
	}
 }
array table
-----------------------------------------------
sqrtDiag -> [('[i]', 'r', 'normalized', ['i', 'j'], 5589), ('[j]', 'r', 'normalized', ['i', 'j'], 5589)]
LDEs formed:0

cov -> [('[i][j]', 'w', 'normalized', ['i', 'j'], 5590), ('[j][i]', 'w', 'normalized', ['i', 'j'], 5590), ('[i][j]', 'r', 'normalized', ['i', 'j'], 5590)]
LDEs formed:10

distinct LDEs:
j1=j2,i1=i2
i1=i2,j1=j2
i1=j2,j1=i2
#########################################################################################
loop info: Size j = 0  j < l_.size()  ++j
induction variable: ['j']
{
L5591: (vfactors_[j],r) 
L5592: (l_[j]-,r) 
	loop info: Size i=0  i < stdDev.rows()  ++i
	induction variable: ['j', 'i']
	{
	}
	loop info: Size i=0  i < s.size()  ++i
	induction variable: ['j', 'i']
	{
	L5593: (s[i],r) 
	L5594: (w[i][i]=,w) (s[i],r) 
	}
	loop info: Size i=0  i < stdDev.rows()  ++i
	induction variable: ['j', 'i']
	{
	}
 }
array table
-----------------------------------------------
l_ -> [('[j]', 'r', 'normalized', ['j', 'i'], 5592)]
LDEs formed:0

s -> [('[i]', 'r', 'normalized', ['j', 'i'], 5593), ('[i]', 'r', 'normalized', ['j', 'i'], 5594)]
LDEs formed:0

vfactors_ -> [('[j]', 'r', 'normalized', ['j', 'i'], 5591)]
LDEs formed:0

w -> [('[i][i]', 'w', 'normalized', ['j', 'i'], 5594)]
LDEs formed:2

distinct LDEs:
i1=i2,i1=i2
#########################################################################################
loop info: const_iterator iter = l_.begin()  iter != l_.end()  ++iter
induction variable: ['iter']
{
L5595: (vfactors_[i],r) 
L5596: (vfactors_[i]+,r) 
L5597: (vsize_[i],r) 
L5598: (vsize_[i]+,r) 
L5599: (vsize_[i],r) 
}
array table
-----------------------------------------------
vsize_ -> [('[i]', 'r', 'not normalized', ['iter'], 5597), ('[i]', 'r', 'not normalized', ['iter'], 5598), ('[i]', 'r', 'not normalized', ['iter'], 5599)]
LDEs formed:0

vfactors_ -> [('[i]', 'r', 'not normalized', ['iter'], 5595), ('[i]', 'r', 'not normalized', ['iter'], 5596)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/processes/stochasticprocessarray.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<size()  ++i
induction variable: ['i']
{
L5597: (processes_[i]-,r) (x[i],r) 
}
array table
-----------------------------------------------
x -> [('[i]', 'r', 'normalized', ['i'], 5597)]
LDEs formed:0

processes_ -> [('[i]', 'r', 'normalized', ['i'], 5597)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<size()  ++i
induction variable: ['i']
{
L5598: (processes_[i]-,r) (x0[i],r) 
}
array table
-----------------------------------------------
x0 -> [('[i]', 'r', 'normalized', ['i'], 5598)]
LDEs formed:0

processes_ -> [('[i]', 'r', 'normalized', ['i'], 5598)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/processes/mfstateprocess.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size k = i  k < j  k++
induction variable: ['k']
{
L5599: (vols_[k]*,r) (vols_[k]*,r) 
L5600: (times_[k]-,r) (times_[k - 1],r) 
L5601: (vols_[k]*,r) (vols_[k]*,r) 
L5602: (times_[k],r) 
L5603: (times_[k - 1],r) 
}
array table
-----------------------------------------------
vols_ -> [('[k]', 'r', 'normalized', ['k'], 5599), ('[k]', 'r', 'normalized', ['k'], 5599), ('[k]', 'r', 'normalized', ['k'], 5601), ('[k]', 'r', 'normalized', ['k'], 5601)]
LDEs formed:0

times_ -> [('[k]', 'r', 'normalized', ['k'], 5600), ('[k - 1]', 'r', 'normalized', ['k'], 5600), ('[k]', 'r', 'normalized', ['k'], 5602), ('[k - 1]', 'r', 'normalized', ['k'], 5603)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/processes/hestonprocess.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Integer i=m-1  i >= 0  --i
induction variable: ['i']
{
L5604: (nominator[i],r) 
L5605: (denominator[i],r) 
}
array table
-----------------------------------------------
nominator -> [('[i]', 'r', 'normalized', ['i'], 5604)]
LDEs formed:0

denominator -> [('[i]', 'r', 'normalized', ['i'], 5605)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/processes/gsrprocess.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/legacy/libormarketmodels/lfmcovarparam.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<size_  ++i
induction variable: ['i']
{
	loop info: Size j=0  j<=i ++j
	induction variable: ['i', 'j']
	{
		loop info: Size k=0  k < 64  ++k
		induction variable: ['i', 'j', 'k']
		{
		L5606: (tmp[i][j]+=,w) 
		}
	L5607: (tmp[j][i]=,w) (tmp[i][j],r) 
	}
 }
array table
-----------------------------------------------
tmp -> [('[i][j]', 'w', 'normalized', ['i', 'j', 'k'], 5606), ('[j][i]', 'w', 'normalized', ['i', 'j', 'k'], 5607), ('[i][j]', 'r', 'normalized', ['i', 'j', 'k'], 5607)]
LDEs formed:10

distinct LDEs:
j1=j2,i1=i2
i1=i2,j1=j2
i1=j2,j1=i2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/legacy/libormarketmodels/lmlinexpvolmodel.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<size_  ++i
induction variable: ['i']
{
L5608: (fixingTimes_[i],r) 
L5609: (tmp[i]=,w) 
}
array table
-----------------------------------------------
tmp -> [('[i]', 'w', 'normalized', ['i'], 5609)]
LDEs formed:1

fixingTimes_ -> [('[i]', 'r', 'normalized', ['i'], 5608)]
LDEs formed:0

distinct LDEs:
i1=i2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/legacy/libormarketmodels/lmextlinexpvolmodel.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i <size_  ++i
induction variable: ['i']
{
L5609: (arguments_[i+4]=,w) 
}
array table
-----------------------------------------------
arguments_ -> [('[i+4]', 'w', 'normalized', ['i'], 5609)]
LDEs formed:1

distinct LDEs:
i1+4=i2+4
#########################################################################################
loop info: Size i=0  i<size_  ++i
induction variable: ['i']
{
L5610: (tmp[i]*=,w) (arguments_[i+4],r) 
}
array table
-----------------------------------------------
tmp -> [('[i]', 'w', 'normalized', ['i'], 5610)]
LDEs formed:1

arguments_ -> [('[i+4]', 'r', 'normalized', ['i'], 5610)]
LDEs formed:0

distinct LDEs:
i1=i2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/legacy/libormarketmodels/lfmprocess.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i = 0  i < size_  ++i
induction variable: ['i']
{
L5611: (flows[i],r) 
L5612: (initialValues_[i]=,w) 
L5613: (accrualPeriod_[i]=,w) 
L5614: (fixingDates_[i]=,w) 
L5615: (fixingTimes_[i]=,w) 
L5616: (accrualStartTimes_[i]=,w) 
L5617: (accrualEndTimes_[i]=,w) 
}
array table
-----------------------------------------------
accrualEndTimes_ -> [('[i]', 'w', 'normalized', ['i'], 5617)]
LDEs formed:1

fixingDates_ -> [('[i]', 'w', 'normalized', ['i'], 5614)]
LDEs formed:1

accrualPeriod_ -> [('[i]', 'w', 'normalized', ['i'], 5613)]
LDEs formed:1

initialValues_ -> [('[i]', 'w', 'normalized', ['i'], 5612)]
LDEs formed:1

flows -> [('[i]', 'r', 'normalized', ['i'], 5611)]
LDEs formed:0

fixingTimes_ -> [('[i]', 'w', 'normalized', ['i'], 5615)]
LDEs formed:1

accrualStartTimes_ -> [('[i]', 'w', 'normalized', ['i'], 5616)]
LDEs formed:1

distinct LDEs:
i1=i2
#########################################################################################
loop info: Size k=m  k<size_  ++k
induction variable: ['k']
{
L5617: (m1[k]=,w) (accrualPeriod_[k]*,r) (x[k]/,r) (accrualPeriod_[k]*,r) (x[k],r) 
L5618: (f[k]=,w) 
L5619: (covariance[k][k],r) 
}
array table
-----------------------------------------------
accrualPeriod_ -> [('[k]', 'r', 'normalized', ['k'], 5617), ('[k]', 'r', 'normalized', ['k'], 5617)]
LDEs formed:0

f -> [('[k]', 'w', 'normalized', ['k'], 5618)]
LDEs formed:1

m1 -> [('[k]', 'w', 'normalized', ['k'], 5617)]
LDEs formed:1

covariance -> [('[k][k]', 'r', 'normalized', ['k'], 5619)]
LDEs formed:0

x -> [('[k]', 'r', 'normalized', ['k'], 5617), ('[k]', 'r', 'normalized', ['k'], 5617)]
LDEs formed:0

distinct LDEs:
k1=k2
#########################################################################################
loop info: Size k=0  k<size_  ++k
induction variable: ['k']
{
L5618: (tmp[k]=,w) (x0[k]*,r) (dx[k],r) 
}
array table
-----------------------------------------------
tmp -> [('[k]', 'w', 'normalized', ['k'], 5618)]
LDEs formed:1

x0 -> [('[k]', 'r', 'normalized', ['k'], 5618)]
LDEs formed:0

dx -> [('[k]', 'r', 'normalized', ['k'], 5618)]
LDEs formed:0

distinct LDEs:
k1=k2
#########################################################################################
loop info: Size k=m  k<size_  ++k
induction variable: ['k']
{
L5619: (accrualPeriod_[k]*,r) (x0[k],r) 
L5620: (m1[k]=,w) 
L5621: (covariance[k][k],r) 
L5622: (m2[k]=,w) 
L5623: (f[k]=,w) (x0[k]*,r) 
L5624: (covariance[k][k],r) 
}
array table
-----------------------------------------------
f -> [('[k]', 'w', 'normalized', ['k'], 5623)]
LDEs formed:1

accrualPeriod_ -> [('[k]', 'r', 'normalized', ['k'], 5619)]
LDEs formed:0

covariance -> [('[k][k]', 'r', 'normalized', ['k'], 5621), ('[k][k]', 'r', 'normalized', ['k'], 5624)]
LDEs formed:0

m1 -> [('[k]', 'w', 'normalized', ['k'], 5620)]
LDEs formed:1

m2 -> [('[k]', 'w', 'normalized', ['k'], 5622)]
LDEs formed:1

x0 -> [('[k]', 'r', 'normalized', ['k'], 5619), ('[k]', 'r', 'normalized', ['k'], 5623)]
LDEs formed:0

distinct LDEs:
k1=k2
#########################################################################################
loop info: Size i = 1  i < size_  ++i
induction variable: ['i']
{
L5624: (discountFactors[i]=,w) 
L5625: (discountFactors[i-1]/,r) (rates[i]*,r) (accrualPeriod_[i],r) 
}
array table
-----------------------------------------------
discountFactors -> [('[i]', 'w', 'normalized', ['i'], 5624), ('[i-1]', 'r', 'normalized', ['i'], 5625)]
LDEs formed:2

accrualPeriod_ -> [('[i]', 'r', 'normalized', ['i'], 5625)]
LDEs formed:0

rates -> [('[i]', 'r', 'normalized', ['i'], 5625)]
LDEs formed:0

distinct LDEs:
i1=i2-1
i1=i2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/legacy/libormarketmodels/lfmcovarproxy.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<size_  ++i
induction variable: ['i']
{
L5626: (vol[i],r) 
}
array table
-----------------------------------------------
vol -> [('[i]', 'r', 'normalized', ['i'], 5626)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<size_  ++i
induction variable: ['i']
{
	loop info: Size j=0  j<size_  ++j
	induction variable: ['i', 'j']
	{
	L5627: (tmp[i][j]=,w) (volatility[i]*,r) (correlation[i][j]*,r) (volatility[j],r) 
	}
 }
array table
-----------------------------------------------
tmp -> [('[i][j]', 'w', 'normalized', ['i', 'j'], 5627)]
LDEs formed:2

correlation -> [('[i][j]', 'r', 'normalized', ['i', 'j'], 5627)]
LDEs formed:0

volatility -> [('[i]', 'r', 'normalized', ['i', 'j'], 5627), ('[j]', 'r', 'normalized', ['i', 'j'], 5627)]
LDEs formed:0

distinct LDEs:
i1=i2,j1=j2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/legacy/libormarketmodels/lmfixedvolmodel.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i = 1  i < startTimes_.size()  i++
induction variable: ['i']
{
L5628: (startTimes_[i],r) (startTimes_[i-1],r) 
L5629: (startTimes_[i]<<,r) 
L5630: (startTimes_[i-1]<<,r) 
}
array table
-----------------------------------------------
startTimes_ -> [('[i]', 'r', 'normalized', ['i'], 5628), ('[i-1]', 'r', 'normalized', ['i'], 5628), ('[i]', 'r', 'normalized', ['i'], 5629), ('[i-1]', 'r', 'normalized', ['i'], 5630)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=ti  i<size_  ++i
induction variable: ['i']
{
L5631: (tmp[i]=,w) (volatilities_[i-ti],r) 
}
array table
-----------------------------------------------
tmp -> [('[i]', 'w', 'normalized', ['i'], 5631)]
LDEs formed:1

volatilities_ -> [('[i-ti]', 'r', 'not normalized', ['i'], 5631)]
LDEs formed:0

distinct LDEs:
i1=i2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/legacy/libormarketmodels/lmlinexpcorrmodel.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<size_  ++i
induction variable: ['i']
{
	loop info: Size j=i  j<size_  ++j
	induction variable: ['i', 'j']
	{
	L5632: (corrMatrix_[i][j]=,w) (corrMatrix_[j][i],r) 
	}
 }
array table
-----------------------------------------------
corrMatrix_ -> [('[i][j]', 'w', 'normalized', ['i', 'j'], 5632), ('[j][i]', 'r', 'normalized', ['i', 'j'], 5632)]
LDEs formed:4

distinct LDEs:
i1=i2,j1=j2
i1=j2,j1=i2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/legacy/libormarketmodels/liborforwardmodel.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i < process->size()  ++i
induction variable: ['i']
{
L5633: (accrualPeriod_[i]=,w) 
L5634: (f_[i]=,w) (accrualPeriod_[i]*,r) 
}
array table
-----------------------------------------------
accrualPeriod_ -> [('[i]', 'w', 'normalized', ['i'], 5633), ('[i]', 'r', 'normalized', ['i'], 5634)]
LDEs formed:2

f_ -> [('[i]', 'w', 'normalized', ['i'], 5634)]
LDEs formed:1

distinct LDEs:
i1=i2
#########################################################################################
loop info: Size k=alpha+1  k<=beta  ++k
induction variable: ['k']
{
L5635: (accrualPeriod_[k],r) 
	loop info: Size j=alpha+1  j<=k  ++j
	induction variable: ['k', 'j']
	{
	L5636: (f_[j],r) 
	}
 }
array table
-----------------------------------------------
accrualPeriod_ -> [('[k]', 'r', 'normalized', ['k', 'j'], 5635)]
LDEs formed:0

f_ -> [('[j]', 'r', 'normalized', ['k', 'j'], 5636)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=alpha+1  i<=beta  ++i
induction variable: ['i']
{
L5637: (accrualPeriod_[i],r) 
	loop info: Size j=alpha+1  j<=i  ++j
	induction variable: ['i', 'j']
	{
	L5638: (f_[j],r) 
	}
L5639: (omega[i]=,w) 
}
array table
-----------------------------------------------
accrualPeriod_ -> [('[i]', 'r', 'normalized', ['i', 'j'], 5637)]
LDEs formed:0

omega -> [('[i]', 'w', 'normalized', ['i', 'j'], 5639)]
LDEs formed:1

f_ -> [('[j]', 'r', 'normalized', ['i', 'j'], 5638)]
LDEs formed:0

distinct LDEs:
i1=i2
#########################################################################################
loop info: Size i=alpha+1  i <=beta  ++i
induction variable: ['i']
{
L5639: (w[i]*,r) (f[i],r) 
}
array table
-----------------------------------------------
w -> [('[i]', 'r', 'normalized', ['i'], 5639)]
LDEs formed:0

f -> [('[i]', 'r', 'normalized', ['i'], 5639)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i < size  ++i
induction variable: ['i']
{
L5640: (lengths[i]=,w) 
}
array table
-----------------------------------------------
lengths -> [('[i]', 'w', 'normalized', ['i'], 5640)]
LDEs formed:1

distinct LDEs:
i1=i2
#########################################################################################
loop info: Size k=0  k < size  ++k
induction variable: ['k']
{
	loop info: Size i=alpha+1  i <= k+size  ++i
	induction variable: ['k', 'i']
	{
		loop info: Size j=i  j <= k+size  ++j
		induction variable: ['k', 'i', 'j']
		{
		L5641: (var[i-alpha-1][j-alpha-1]=,w) (var[j-alpha-1][i-alpha-1]=,w) 
		}
 	}
	loop info: Size l=1  l <= size  ++l
	induction variable: ['k', 'i', 'j', 'l']
	{
		loop info: Size i=alpha+1  i <= beta  ++i
		induction variable: ['k', 'i', 'j', 'l']
		{
			loop info: Size j=alpha+1  j <= beta  ++j
			induction variable: ['k', 'i', 'j', 'l']
			{
			L5642: (w[i]*,r) (w[j]*,r) (f[i]*,r) (f[j]*,r) (var[i-alpha-1][j-alpha-1],r) 
			}
 		}
	L5643: (volatilities[k][l-1]=,w) 
	}
 }
array table
-----------------------------------------------
var -> [('[i-alpha-1][j-alpha-1]', 'w', 'not normalized', ['k', 'i', 'j', 'l'], 5641), ('[j-alpha-1][i-alpha-1]', 'w', 'not normalized', ['k', 'i', 'j', 'l'], 5641), ('[i-alpha-1][j-alpha-1]', 'r', 'not normalized', ['k', 'i', 'j', 'l'], 5642)]
LDEs formed:10

volatilities -> [('[k][l-1]', 'w', 'normalized', ['k', 'i', 'j', 'l'], 5643)]
LDEs formed:2

w -> [('[i]', 'r', 'normalized', ['k', 'i', 'j', 'l'], 5642), ('[j]', 'r', 'normalized', ['k', 'i', 'j', 'l'], 5642)]
LDEs formed:0

f -> [('[i]', 'r', 'normalized', ['k', 'i', 'j', 'l'], 5642), ('[j]', 'r', 'normalized', ['k', 'i', 'j', 'l'], 5642)]
LDEs formed:0

distinct LDEs:
k1=k2,l1-1=l2-1
j1-alpha-1=j2-alpha-1,i1-alpha-1=i2-alpha-1
i1-alpha-1=i2-alpha-1,j1-alpha-1=j2-alpha-1
i1-alpha-1=j2-alpha-1,j1-alpha-1=i2-alpha-1
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/legacy/libormarketmodels/lmexpcorrmodel.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<size_  ++i
induction variable: ['i']
{
	loop info: Size j=i  j<size_  ++j
	induction variable: ['i', 'j']
	{
	L5643: (corrMatrix_[i][j]=,w) (corrMatrix_[j][i],r) 
	}
 }
array table
-----------------------------------------------
corrMatrix_ -> [('[i][j]', 'w', 'normalized', ['i', 'j'], 5643), ('[j][i]', 'r', 'normalized', ['i', 'j'], 5643)]
LDEs formed:4

distinct LDEs:
i1=i2,j1=j2
i1=j2,j1=i2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/ql/legacy/libormarketmodels/lfmhullwhiteparam.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i < size_-1  ++i
induction variable: ['i']
{
L5644: (tmpSqrtCorr[i],r) (tmpSqrtCorr[i]+,r) (sqrtCorr[i],r) 
L5645: (tmpSqrtCorr[i],r) (tmpSqrtCorr[i]+,r) 
L5646: (tmpSqrtCorr[i],r) 
}
array table
-----------------------------------------------
sqrtCorr -> [('[i]', 'r', 'normalized', ['i'], 5644)]
LDEs formed:0

tmpSqrtCorr -> [('[i]', 'r', 'normalized', ['i'], 5644), ('[i]', 'r', 'normalized', ['i'], 5644), ('[i]', 'r', 'normalized', ['i'], 5645), ('[i]', 'r', 'normalized', ['i'], 5645), ('[i]', 'r', 'normalized', ['i'], 5646)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i = 1  i < size_  ++i
induction variable: ['i']
{
	loop info: Size j = 1  j < i  ++j
	induction variable: ['i', 'j']
	{
	L5647: (lambda[i-j-1]*,r) (lambda[i-j-1],r) 
	L5648: (fixingTimes[j+1]-,r) (fixingTimes[j],r) 
	}
L5649: (fixingDates[i],r) 
L5650: (fixingDates[0],r) 
L5651: (fixingDates[i],r) 
L5652: (fixingTimes[1]-,r) (fixingTimes[0],r) 
	loop info: Size q=0  q<factors_  ++q
	induction variable: ['i', 'j', 'q']
	{
	L5653: (diffusion_[i-1][q]=,w) (sqrtCorr[i-1][q]*,r) 
	}
 }
array table
-----------------------------------------------
fixingDates -> [('[i]', 'r', 'normalized', ['i', 'j', 'q'], 5649), ('[0]', 'r', 'normalized', ['i', 'j', 'q'], 5650), ('[i]', 'r', 'normalized', ['i', 'j', 'q'], 5651)]
LDEs formed:0

fixingTimes -> [('[j+1]', 'r', 'normalized', ['i', 'j', 'q'], 5648), ('[j]', 'r', 'normalized', ['i', 'j', 'q'], 5648), ('[1]', 'r', 'normalized', ['i', 'j', 'q'], 5652), ('[0]', 'r', 'normalized', ['i', 'j', 'q'], 5652)]
LDEs formed:0

sqrtCorr -> [('[i-1][q]', 'r', 'normalized', ['i', 'j', 'q'], 5653)]
LDEs formed:0

diffusion_ -> [('[i-1][q]', 'w', 'normalized', ['i', 'j', 'q'], 5653)]
LDEs formed:2

lambda -> [('[i-j-1]', 'r', 'normalized', ['i', 'j', 'q'], 5647), ('[i-j-1]', 'r', 'normalized', ['i', 'j', 'q'], 5647)]
LDEs formed:0

distinct LDEs:
i1-1=i2-1,q1=q2
#########################################################################################
loop info: Size k=m  k<size_  ++k
induction variable: ['k']
{
	loop info: Size q=0  q<factors_  ++q
	induction variable: ['k', 'q']
	{
	L5648: (tmp[k][q]=,w) (diffusion_[k-m][q],r) 
	}
 }
array table
-----------------------------------------------
tmp -> [('[k][q]', 'w', 'normalized', ['k', 'q'], 5648)]
LDEs formed:2

diffusion_ -> [('[k-m][q]', 'r', 'not normalized', ['k', 'q'], 5648)]
LDEs formed:0

distinct LDEs:
k1=k2,q1=q2
#########################################################################################
loop info: Size k=m  k<size_  ++k
induction variable: ['k']
{
	loop info: Size i=m  i<size_  ++i
	induction variable: ['k', 'i']
	{
	L5649: (tmp[k][i]=,w) (covariance_[k-m][i-m],r) 
	}
 }
array table
-----------------------------------------------
tmp -> [('[k][i]', 'w', 'normalized', ['k', 'i'], 5649)]
LDEs formed:2

covariance_ -> [('[k-m][i-m]', 'r', 'not normalized', ['k', 'i'], 5649)]
LDEs formed:0

distinct LDEs:
k1=k2,i1=i2
#########################################################################################
loop info: Size i=0  i<last  ++i
induction variable: ['i']
{
L5650: (fixingTimes_[i+1],r) 
L5651: (fixingTimes_[i],r) 
	loop info: Size k=i  k<size_-1  ++k
	induction variable: ['i', 'k']
	{
		loop info: Size l=i  l<size_-1  ++l
		induction variable: ['i', 'k', 'l']
		{
		L5652: (tmp[k+1][l+1]+=,w) (covariance_[k-i][l-i]*,r) 
		}
 	}
 }
array table
-----------------------------------------------
tmp -> [('[k+1][l+1]', 'w', 'normalized', ['i', 'k', 'l'], 5652)]
LDEs formed:2

covariance_ -> [('[k-i][l-i]', 'r', 'normalized', ['i', 'k', 'l'], 5652)]
LDEs formed:0

fixingTimes_ -> [('[i+1]', 'r', 'normalized', ['i', 'k', 'l'], 5650), ('[i]', 'r', 'normalized', ['i', 'k', 'l'], 5651)]
LDEs formed:0

distinct LDEs:
k1+1=k2+1,l1+1=l2+1
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/Examples/CallableBonds/CallableBonds.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/Examples/DiscreteHedging/DiscreteHedging.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size step = 0  step < n-1  step++
induction variable: ['step']
{
L5652: (path[step+1],r) 
}
array table
-----------------------------------------------
path -> [('[step+1]', 'r', 'normalized', ['step'], 5652)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/Examples/Replication/Replication.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/Examples/MarketModels/MarketModels.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i < numberRates  ++i
induction variable: ['i']
{
L5653: (swaptions[i].startIndex_=,w) 
L5654: (swaptions[i].endIndex_=,w) 
}
array table
-----------------------------------------------
swaptions -> [('[i]', 'w', 'normalized', ['i'], 5653), ('[i]', 'w', 'normalized', ['i'], 5654)]
LDEs formed:3

distinct LDEs:
i1=i2
#########################################################################################
loop info: Size i=0  i < 4  ++i
induction variable: ['i']
{
L5655: (values[r++]<<,r) 
	loop info: Size i=0  i < numberRates  ++i, ++r
	induction variable: ['i', 'r']
	{
	}
	loop info:   r < values.size()  ++r
	induction variable: ['i', 'r']
	{
	L5656: (values[r]<<,r) (errors[r]<<,r) 
	L5657: (values[r],r) 
	}
 }
array table
-----------------------------------------------
errors -> [('[r]', 'r', 'normalized', ['i', 'r'], 5656)]
LDEs formed:0

values -> [('[r++]', 'r', 'not normalized', ['i', 'r'], 5655), ('[r]', 'r', 'normalized', ['i', 'r'], 5656), ('[r]', 'r', 'normalized', ['i', 'r'], 5657)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size s=0  s < isExerciseTime.size()  ++s
induction variable: ['s']
{
L5658: (isExerciseTime[s],r) 
}
array table
-----------------------------------------------
isExerciseTime -> [('[s]', 'r', 'normalized', ['s'], 5658)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i < 4  ++i
induction variable: ['i']
{
L5659: (values[r++]<<,r) 
	loop info: Size i=0  i < numberRates  ++i, ++r
	induction variable: ['i', 'r']
	{
	}
	loop info:   r < values.size()  ++r
	induction variable: ['i', 'r']
	{
	L5660: (values[r]<<,r) (errors[r]<<,r) 
	L5661: (values[r],r) 
	}
 }
array table
-----------------------------------------------
errors -> [('[r]', 'r', 'normalized', ['i', 'r'], 5660)]
LDEs formed:0

values -> [('[r++]', 'r', 'not normalized', ['i', 'r'], 5659), ('[r]', 'r', 'normalized', ['i', 'r'], 5660), ('[r]', 'r', 'normalized', ['i', 'r'], 5661)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size s=0  s < isExerciseTime.size()  ++s
induction variable: ['s']
{
L5662: (isExerciseTime[s],r) 
}
array table
-----------------------------------------------
isExerciseTime -> [('[s]', 'r', 'normalized', ['s'], 5662)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/Examples/ConvertibleBonds/ConvertibleBonds.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<LENGTH(callLength)  i++
induction variable: ['i']
{
L5663: (callPrices[i],r) 
L5664: (callLength[i],r) 
}
array table
-----------------------------------------------
callPrices -> [('[i]', 'r', 'normalized', ['i'], 5663)]
LDEs formed:0

callLength -> [('[i]', 'r', 'normalized', ['i'], 5664)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size j=0  j<LENGTH(putLength)  j++
induction variable: ['j']
{
L5665: (putPrices[j],r) 
L5666: (putLength[j],r) 
}
array table
-----------------------------------------------
putLength -> [('[j]', 'r', 'normalized', ['j'], 5666)]
LDEs formed:0

putPrices -> [('[j]', 'r', 'normalized', ['j'], 5665)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/Examples/Gaussian1dModels/Gaussian1dModels.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size j = 0  j < basket.size()  ++j
induction variable: ['j']
{
L5666: (basket[j],r) 
}
array table
-----------------------------------------------
basket -> [('[j]', 'r', 'normalized', ['j'], 5666)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size j = 0  j < basket.size()  ++j
induction variable: ['j']
{
L5667: (basket[j],r) 
L5668: (volatility[j]<<,r) (basket[j]-,r) 
L5669: (basket[j]-,r) 
L5670: (basket[j]-,r) (basket[j]-,r) 
L5671: (basket[j]-,r) 
}
array table
-----------------------------------------------
basket -> [('[j]', 'r', 'normalized', ['j'], 5667), ('[j]', 'r', 'normalized', ['j'], 5668), ('[j]', 'r', 'normalized', ['j'], 5669), ('[j]', 'r', 'normalized', ['j'], 5670), ('[j]', 'r', 'normalized', ['j'], 5670), ('[j]', 'r', 'normalized', ['j'], 5671)]
LDEs formed:0

volatility -> [('[j]', 'r', 'normalized', ['j'], 5668)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/Examples/EquityOption/EquityOption.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/Examples/CDS/CDS.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<4  i++
induction variable: ['i']
{
L5669: (tenors[i],r) 
}
array table
-----------------------------------------------
tenors -> [('[i]', 'r', 'normalized', ['i'], 5669)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<4  i++
induction variable: ['i']
{
L5670: (quoted_spreads[i],r) 
L5671: (tenors[i],r) 
}
array table
-----------------------------------------------
tenors -> [('[i]', 'r', 'normalized', ['i'], 5671)]
LDEs formed:0

quoted_spreads -> [('[i]', 'r', 'normalized', ['i'], 5670)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<hr_curve_data.size()  i++
induction variable: ['i']
{
L5671: (hr_curve_data[i].first<<,r) 
L5672: (hr_curve_data[i].second<<,r) 
}
array table
-----------------------------------------------
hr_curve_data -> [('[i]', 'r', 'normalized', ['i'], 5671), ('[i]', 'r', 'normalized', ['i'], 5672)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/Examples/MultidimIntegral/MultidimIntegral.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/Examples/FRA/FRA.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: i=0  i<LENGTH(monthsToStart)  i++
induction variable: ['i']
{
L5673: (monthsToStart[i],r) 
L5674: (monthsToStart[i],r) 
L5675: (monthsToStart[i],r) 
L5676: (monthsToStart[i],r) 
}
array table
-----------------------------------------------
monthsToStart -> [('[i]', 'r', 'normalized', ['i'], 5673), ('[i]', 'r', 'normalized', ['i'], 5674), ('[i]', 'r', 'normalized', ['i'], 5675), ('[i]', 'r', 'normalized', ['i'], 5676)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: i=0  i<LENGTH(monthsToStart)  i++
induction variable: ['i']
{
L5677: (monthsToStart[i],r) 
L5678: (monthsToStart[i],r) 
L5679: (monthsToStart[i],r) 
L5680: (monthsToStart[i],r) 
}
array table
-----------------------------------------------
monthsToStart -> [('[i]', 'r', 'normalized', ['i'], 5677), ('[i]', 'r', 'normalized', ['i'], 5678), ('[i]', 'r', 'normalized', ['i'], 5679), ('[i]', 'r', 'normalized', ['i'], 5680)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/Examples/LatentModel/LatentModel.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<hazardRates.size()  i++
induction variable: ['i']
{
L5681: (defTS[i],r) 
}
array table
-----------------------------------------------
defTS -> [('[i]', 'r', 'normalized', ['i'], 5681)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size numEvts=0  numEvts <=theBskt->size()  numEvts++
induction variable: ['numEvts']
{
L5682: (probEventsGLatent[numEvts]<<,r) 
L5683: (probEventsTLatent[numEvts]<<,r) 
L5684: (probEventsGRandLoss[numEvts]<<,r) 
L5685: (probEventsTRandLoss[numEvts],r) 
}
array table
-----------------------------------------------
probEventsTLatent -> [('[numEvts]', 'r', 'normalized', ['numEvts'], 5683)]
LDEs formed:0

probEventsGRandLoss -> [('[numEvts]', 'r', 'normalized', ['numEvts'], 5684)]
LDEs formed:0

probEventsTRandLoss -> [('[numEvts]', 'r', 'normalized', ['numEvts'], 5685)]
LDEs formed:0

probEventsGLatent -> [('[numEvts]', 'r', 'normalized', ['numEvts'], 5682)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/Examples/BasketLosses/BasketLosses.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<hazardRates.size()  i++
induction variable: ['i']
{
L5683: (hazardRates[i],r) 
}
array table
-----------------------------------------------
hazardRates -> [('[i]', 'r', 'normalized', ['i'], 5683)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<hazardRates.size()  i++
induction variable: ['i']
{
L5684: (defTS[i],r) 
}
array table
-----------------------------------------------
defTS -> [('[i]', 'r', 'normalized', ['i'], 5684)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/Examples/BermudanSwaption/BermudanSwaption.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<numRows  i++
induction variable: ['i']
{
L5685: (helpers[i]-,r) 
L5686: (helpers[i]-,r) 
L5687: (swaptionVols[k],r) 
L5688: (swapLenghts[j],r) 
L5689: (swaptionVols[k],r) 
}
array table
-----------------------------------------------
swapLenghts -> [('[j]', 'r', 'not normalized', ['i'], 5688)]
LDEs formed:0

helpers -> [('[i]', 'r', 'normalized', ['i'], 5685), ('[i]', 'r', 'normalized', ['i'], 5686)]
LDEs formed:0

swaptionVols -> [('[k]', 'r', 'not normalized', ['i'], 5687), ('[k]', 'r', 'not normalized', ['i'], 5689)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: i=0  i<numRows  i++
induction variable: ['i']
{
L5690: (swaptionVols[k],r) 
L5691: (swaptionMaturities[i],r) 
L5692: (swapLenghts[j],r) 
}
array table
-----------------------------------------------
swaptionMaturities -> [('[i]', 'r', 'normalized', ['i'], 5691)]
LDEs formed:0

swapLenghts -> [('[j]', 'r', 'not normalized', ['i'], 5692)]
LDEs formed:0

swaptionVols -> [('[k]', 'r', 'not normalized', ['i'], 5690)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: i=0  i<leg.size()  i++
induction variable: ['i']
{
L5691: (leg[i],r) 
}
array table
-----------------------------------------------
leg -> [('[i]', 'r', 'normalized', ['i'], 5691)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/Examples/Bonds/Bonds.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=0  i<numberOfBonds  i++
induction variable: ['i']
{
L5692: (marketQuotes[i],r) 
}
array table
-----------------------------------------------
marketQuotes -> [('[i]', 'r', 'normalized', ['i'], 5692)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<numberOfBonds  i++
induction variable: ['i']
{
L5693: (quoteHandle[i].linkTo,r) (quote[i],r) 
}
array table
-----------------------------------------------
quote -> [('[i]', 'r', 'normalized', ['i'], 5693)]
LDEs formed:0

quoteHandle -> [('[i]', 'r', 'normalized', ['i'], 5693)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<numberOfBonds  i++
induction variable: ['i']
{
L5694: (issueDates[i],r) (maturities[i],r) 
L5695: (quoteHandle[i],r) 
L5696: (couponRates[i],r) 
L5697: (issueDates[i],r) 
L5698: (quoteHandle[i],r) 
}
array table
-----------------------------------------------
couponRates -> [('[i]', 'r', 'normalized', ['i'], 5696)]
LDEs formed:0

maturities -> [('[i]', 'r', 'normalized', ['i'], 5694)]
LDEs formed:0

quoteHandle -> [('[i]', 'r', 'normalized', ['i'], 5695), ('[i]', 'r', 'normalized', ['i'], 5698)]
LDEs formed:0

issueDates -> [('[i]', 'r', 'normalized', ['i'], 5694), ('[i]', 'r', 'normalized', ['i'], 5697)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<numberOfBonds  i++
induction variable: ['i']
{
L5698: (bondsHelpers[i],r) 
}
array table
-----------------------------------------------
bondsHelpers -> [('[i]', 'r', 'normalized', ['i'], 5698)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLib/Examples/FittedBondCurve/FittedBondCurve.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: Size i=1  i<dates.size()  ++i
induction variable: ['i']
{
L5699: (dates[i-1],r) (dates[i],r) 
L5700: (dates[i],r) 
}
array table
-----------------------------------------------
dates -> [('[i-1]', 'r', 'normalized', ['i'], 5699), ('[i]', 'r', 'normalized', ['i'], 5699), ('[i]', 'r', 'normalized', ['i'], 5700)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<numberOfBonds  i++
induction variable: ['i']
{
L5701: (cleanPrice[i]=,w) 
}
array table
-----------------------------------------------
cleanPrice -> [('[i]', 'w', 'normalized', ['i'], 5701)]
LDEs formed:1

distinct LDEs:
i1=i2
#########################################################################################
loop info: Size i=0  i<numberOfBonds  i++
induction variable: ['i']
{
L5702: (cleanPrice[i],r) 
}
array table
-----------------------------------------------
cleanPrice -> [('[i]', 'r', 'normalized', ['i'], 5702)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<numberOfBonds  i++
induction variable: ['i']
{
L5703: (quoteHandle[i].linkTo,r) (quote[i],r) 
}
array table
-----------------------------------------------
quote -> [('[i]', 'r', 'normalized', ['i'], 5703)]
LDEs formed:0

quoteHandle -> [('[i]', 'r', 'normalized', ['i'], 5703)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size j=0  j<LENGTH(lengths)  j++
induction variable: ['j']
{
L5704: (lengths[j]*,r) 
L5705: (quoteHandle[j],r) 
L5706: (coupons[j],r) 
L5707: (quoteHandle[j],r) 
L5708: (coupons[j],r) 
}
array table
-----------------------------------------------
lengths -> [('[j]', 'r', 'normalized', ['j'], 5704)]
LDEs formed:0

quoteHandle -> [('[j]', 'r', 'normalized', ['j'], 5705), ('[j]', 'r', 'normalized', ['j'], 5707)]
LDEs formed:0

coupons -> [('[j]', 'r', 'normalized', ['j'], 5706), ('[j]', 'r', 'normalized', ['j'], 5708)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i< LENGTH(knots)  i++
induction variable: ['i']
{
L5709: (knots[i],r) 
}
array table
-----------------------------------------------
knots -> [('[i]', 'r', 'normalized', ['i'], 5709)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<instrumentsA.size()  i++
induction variable: ['i']
{
L5710: (instrumentsA[i]-,r) 
L5711: (instrumentsA[i]-,r) 
	loop info: Size j=0  j<cfSize-1  j++
	induction variable: ['i', 'j']
	{
	L5712: (cfs[j]-,r) 
	L5713: (cfs[j]-,r) 
	}
L5714: (cfs[cfSize-1]-,r) 
L5715: (coupons[i]<<,r) 
}
array table
-----------------------------------------------
instrumentsA -> [('[i]', 'r', 'normalized', ['i', 'j'], 5710), ('[i]', 'r', 'normalized', ['i', 'j'], 5711)]
LDEs formed:0

cfs -> [('[j]', 'r', 'normalized', ['i', 'j'], 5712), ('[j]', 'r', 'normalized', ['i', 'j'], 5713), ('[cfSize-1]', 'r', 'not normalized', ['i', 'j'], 5714)]
LDEs formed:0

coupons -> [('[i]', 'r', 'normalized', ['i', 'j'], 5715)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<instrumentsA.size()  i++
induction variable: ['i']
{
L5716: (instrumentsA[i]-,r) 
L5717: (instrumentsA[i]-,r) 
	loop info: Size j=0  j<cfSize-1  j++
	induction variable: ['i', 'j']
	{
	L5718: (cfs[j]-,r) 
	L5719: (cfs[j]-,r) 
	}
L5720: (cfs[cfSize-1]-,r) 
L5721: (coupons[i]<<,r) 
}
array table
-----------------------------------------------
instrumentsA -> [('[i]', 'r', 'normalized', ['i', 'j'], 5716), ('[i]', 'r', 'normalized', ['i', 'j'], 5717)]
LDEs formed:0

cfs -> [('[j]', 'r', 'normalized', ['i', 'j'], 5718), ('[j]', 'r', 'normalized', ['i', 'j'], 5719), ('[cfSize-1]', 'r', 'not normalized', ['i', 'j'], 5720)]
LDEs formed:0

coupons -> [('[i]', 'r', 'normalized', ['i', 'j'], 5721)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<instrumentsA.size()  i++
induction variable: ['i']
{
L5722: (instrumentsA[i]-,r) 
L5723: (instrumentsA[i]-,r) 
	loop info: Size j=0  j<cfSize-1  j++
	induction variable: ['i', 'j']
	{
	L5724: (cfs[j]-,r) 
	L5725: (cfs[j]-,r) 
	}
L5726: (cfs[cfSize-1]-,r) 
L5727: (coupons[i+1]<<,r) 
}
array table
-----------------------------------------------
instrumentsA -> [('[i]', 'r', 'normalized', ['i', 'j'], 5722), ('[i]', 'r', 'normalized', ['i', 'j'], 5723)]
LDEs formed:0

cfs -> [('[j]', 'r', 'normalized', ['i', 'j'], 5724), ('[j]', 'r', 'normalized', ['i', 'j'], 5725), ('[cfSize-1]', 'r', 'not normalized', ['i', 'j'], 5726)]
LDEs formed:0

coupons -> [('[i+1]', 'r', 'normalized', ['i', 'j'], 5727)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size k=0  k<LENGTH(lengths)-1  k++
induction variable: ['k']
{
L5728: (instrumentsA[k]-,r) 
L5729: (instrumentsA[k]-,r) 
L5730: (quote[k+1]-,r) 
}
array table
-----------------------------------------------
quote -> [('[k+1]', 'r', 'normalized', ['k'], 5730)]
LDEs formed:0

instrumentsA -> [('[k]', 'r', 'normalized', ['k'], 5728), ('[k]', 'r', 'normalized', ['k'], 5729)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: Size i=0  i<instrumentsA.size()  i++
induction variable: ['i']
{
L5730: (instrumentsA[i]-,r) 
L5731: (instrumentsA[i]-,r) 
	loop info: Size j=0  j<cfSize-1  j++
	induction variable: ['i', 'j']
	{
	L5732: (cfs[j]-,r) 
	L5733: (cfs[j]-,r) 
	}
L5734: (cfs[cfSize-1]-,r) 
L5735: (coupons[i+1]<<,r) 
}
array table
-----------------------------------------------
instrumentsA -> [('[i]', 'r', 'normalized', ['i', 'j'], 5730), ('[i]', 'r', 'normalized', ['i', 'j'], 5731)]
LDEs formed:0

cfs -> [('[j]', 'r', 'normalized', ['i', 'j'], 5732), ('[j]', 'r', 'normalized', ['i', 'j'], 5733), ('[cfSize-1]', 'r', 'not normalized', ['i', 'j'], 5734)]
LDEs formed:0

coupons -> [('[i+1]', 'r', 'normalized', ['i', 'j'], 5735)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/ObjectHandler/xlsdk/framewrk.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/ObjectHandler/oh/utilities.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info:   yearOffset < size  ++yearOffset
induction variable: ['yearOffset']
{
L5736: (YearOffset[yearOffset],r) 
}
array table
-----------------------------------------------
YearOffset -> [('[yearOffset]', 'r', 'normalized', ['yearOffset'], 5736)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info:   monthoffset < size  ++monthoffset
induction variable: ['monthoffset']
{
L5737: (pMonth[monthoffset],r) 
}
array table
-----------------------------------------------
pMonth -> [('[monthoffset]', 'r', 'normalized', ['monthoffset'], 5737)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/ObjectHandler/oh/processor.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/ObjectHandler/oh/serializationfactory.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/ObjectHandler/oh/repository.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/ObjectHandler/Examples/C++/example.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/ObjectHandler/ohxl/repositoryxl.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/ObjectHandler/ohxl/functions/manual.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: int numValidRows=xMulti.val.array.rows  numValidRows  --numValidRows
induction variable: ['numValidRows']
{
	loop info: int i=0  i<xMulti.val.array.columns  ++i
	induction variable: ['numValidRows', 'i']
	{
	L5738: (xMulti.val.array.lparray[index].xltype&,r) 
	}
 }
array table
-----------------------------------------------
xMulti.val.array.lparray -> [('[index]', 'r', 'not normalized', ['numValidRows', 'i'], 5738)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: int numValidCols=xMulti.val.array.columns  numValidCols  --numValidCols
induction variable: ['numValidCols']
{
	loop info: int i=0  i<xMulti.val.array.rows  ++i
	induction variable: ['numValidCols', 'i']
	{
	L5739: (xMulti.val.array.lparray[index].xltype&,r) 
	}
 }
array table
-----------------------------------------------
xMulti.val.array.lparray -> [('[index]', 'r', 'not normalized', ['numValidCols', 'i'], 5739)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: int i=0  i<numValidRows  ++i
induction variable: ['i']
{
	loop info: int j=0  j<numValidCols  ++j
	induction variable: ['i', 'j']
	{
	L5740: (xRet.val.array.lparray[indexTarget],r) 
	L5741: (val.array.lparray[indexSource],r) 
	}
 }
array table
-----------------------------------------------
xRet.val.array.lparray -> [('[indexTarget]', 'r', 'not normalized', ['i', 'j'], 5740)]
LDEs formed:0

val.array.lparray -> [('[indexSource]', 'r', 'not normalized', ['i', 'j'], 5741)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: int i=0  i<xRet.val.array.columns * xRet.val.array.rows  ++i
induction variable: ['i']
{
L5742: (xRet.val.array.lparray[i].xltype&,r) (xRet.val.array.lparray[i].val.str,r) 
L5743: (xRet.val.array.lparray[i].val.str,r) 
}
array table
-----------------------------------------------
xRet.val.array.lparray -> [('[i]', 'r', 'normalized', ['i'], 5742), ('[i]', 'r', 'normalized', ['i'], 5742), ('[i]', 'r', 'normalized', ['i'], 5743)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: int j=0  j<xMulti.val.array.columns  ++j
induction variable: ['j']
{
L5744: (xMulti.val.array.lparray[index].xltype&,r) 
}
array table
-----------------------------------------------
xMulti.val.array.lparray -> [('[index]', 'r', 'not normalized', ['j'], 5744)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: int i=0  i<xMulti->val.array.rows  ++i
induction variable: ['i']
{
	loop info: int j=0  j<numCols  ++j
	induction variable: ['i', 'j']
		{
		L5745: (xRet.val.array.lparray[indexTarget],r) 
		L5746: (val.array.lparray[indexSource],r) 
		}
 }
array table
-----------------------------------------------
xRet.val.array.lparray -> [('[indexTarget]', 'r', 'not normalized', ['i', 'j'], 5745)]
LDEs formed:0

val.array.lparray -> [('[indexSource]', 'r', 'not normalized', ['i', 'j'], 5746)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: int i=0  i<xRet.val.array.columns * xRet.val.array.rows  ++i
induction variable: ['i']
{
L5747: (xRet.val.array.lparray[i].xltype&,r) (xRet.val.array.lparray[i].val.str,r) 
L5748: (xRet.val.array.lparray[i].val.str,r) 
}
array table
-----------------------------------------------
xRet.val.array.lparray -> [('[i]', 'r', 'normalized', ['i'], 5747), ('[i]', 'r', 'normalized', ['i'], 5747), ('[i]', 'r', 'normalized', ['i'], 5748)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: int i=0  i<xMulti.val.array.rows  ++i
induction variable: ['i']
{
L5749: (xMulti.val.array.lparray[index].xltype&,r) 
}
array table
-----------------------------------------------
xMulti.val.array.lparray -> [('[index]', 'r', 'not normalized', ['i'], 5749)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: int i=0  i<xMulti->val.array.rows  ++i
induction variable: ['i']
{
	loop info: int j=0  j<xMulti->val.array.columns  ++j
	induction variable: ['i', 'j']
	{
	L5750: (xRet.val.array.lparray[indexTarget],r) 
	L5751: (val.array.lparray[indexSource],r) 
	}
 }
array table
-----------------------------------------------
xRet.val.array.lparray -> [('[indexTarget]', 'r', 'not normalized', ['i', 'j'], 5750)]
LDEs formed:0

val.array.lparray -> [('[indexSource]', 'r', 'not normalized', ['i', 'j'], 5751)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: int i=0  i<xRet.val.array.columns * xRet.val.array.rows  ++i
induction variable: ['i']
{
L5752: (xRet.val.array.lparray[i].xltype&,r) (xRet.val.array.lparray[i].val.str,r) 
L5753: (xRet.val.array.lparray[i].val.str,r) 
}
array table
-----------------------------------------------
xRet.val.array.lparray -> [('[i]', 'r', 'normalized', ['i'], 5752), ('[i]', 'r', 'normalized', ['i'], 5752), ('[i]', 'r', 'normalized', ['i'], 5753)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: int i=0  i<sizeInput  i++
induction variable: ['i']
{
L5754: (flagsCpp[i],r) 
L5755: (xRet.val.array.lparray[idx++],r) (val.array.lparray[i],r) 
}
array table
-----------------------------------------------
flagsCpp -> [('[i]', 'r', 'normalized', ['i'], 5754)]
LDEs formed:0

xRet.val.array.lparray -> [('[idx++]', 'r', 'not normalized', ['i'], 5755)]
LDEs formed:0

val.array.lparray -> [('[i]', 'r', 'normalized', ['i'], 5755)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/ObjectHandler/ohxl/conversions/validations.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/ObjectHandler/ohxl/utilities/xlutilities.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: int i=0  i<size  ++i
induction variable: ['i']
{
L5756: (val.array.lparray[i].xltype&,r) 
L5757: (val.array.lparray[i].val.str,r) 
L5758: (val.array.lparray[i].val.str,r) 
}
array table
-----------------------------------------------
val.array.lparray -> [('[i]', 'r', 'normalized', ['i'], 5756), ('[i]', 'r', 'normalized', ['i'], 5757), ('[i]', 'r', 'normalized', ['i'], 5758)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: unsigned char i=1  i<=xValue->val.str[0]  i++
induction variable: ['i']
{
L5759: (val.str[i]==,r) (val.str[i]==,r) 
}
array table
-----------------------------------------------
val.str -> [('[i]', 'r', 'normalized', ['i'], 5759), ('[i]', 'r', 'normalized', ['i'], 5759)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/log4cxx/src/test/cpp/abts.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: i = 0  testlist[i] != NULL  i++
induction variable: ['i']
{
L5760: (testlist[i],r) 
}
array table
-----------------------------------------------
testlist -> [('[i]', 'r', 'normalized', ['i'], 5760)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: i = 1  i < argc  i++
induction variable: ['i']
{
L5761: (argv[i],r) 
L5762: (argv[i],r) 
L5763: (argv[i],r) 
L5764: (argv[i],r) 
L5765: (argv[i][0]==,r) 
L5766: (argv[i],r) 
}
array table
-----------------------------------------------
argv -> [('[i]', 'r', 'normalized', ['i'], 5761), ('[i]', 'r', 'normalized', ['i'], 5762), ('[i]', 'r', 'normalized', ['i'], 5763), ('[i]', 'r', 'normalized', ['i'], 5764), ('[i][0]', 'r', 'normalized', ['i'], 5765), ('[i]', 'r', 'normalized', ['i'], 5766)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: i = 1  i < argc  i++
induction variable: ['i']
{
L5767: (testlist[i - 1]=,w) (argv[i],r) 
}
array table
-----------------------------------------------
testlist -> [('[i - 1]', 'w', 'normalized', ['i'], 5767)]
LDEs formed:1

argv -> [('[i]', 'r', 'normalized', ['i'], 5767)]
LDEs formed:0

distinct LDEs:
i1 - 1=i2 - 1
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/log4cxx/src/test/cpp/l7dtestcase.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: int i = 0  i < 3  i++
induction variable: ['i']
{
L5768: (bundles[i],r) 
}
array table
-----------------------------------------------
bundles -> [('[i]', 'r', 'normalized', ['i'], 5768)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/log4cxx/src/test/cpp/asyncappendertestcase.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/log4cxx/src/test/cpp/util/binarycompare.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: int i = 0  i < BUFSIZE  i++
induction variable: ['i']
{
L5769: (contents1[i],r) (contents2[i],r) 
L5770: (contents1[i],r) 
L5771: (contents2[i],r) 
}
array table
-----------------------------------------------
contents2 -> [('[i]', 'r', 'normalized', ['i'], 5769), ('[i]', 'r', 'normalized', ['i'], 5771)]
LDEs formed:0

contents1 -> [('[i]', 'r', 'normalized', ['i'], 5769), ('[i]', 'r', 'normalized', ['i'], 5770)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/log4cxx/src/test/cpp/util/serializationtesthelper.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: int i = 0  i < endScan  i++
induction variable: ['i']
{
L5771: (expected[i],r) (actual[i],r) 
L5772: (expected[i],r) (actual[i],r) 
}
array table
-----------------------------------------------
expected -> [('[i]', 'r', 'normalized', ['i'], 5771), ('[i]', 'r', 'normalized', ['i'], 5772)]
LDEs formed:0

actual -> [('[i]', 'r', 'normalized', ['i'], 5771), ('[i]', 'r', 'normalized', ['i'], 5772)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/log4cxx/src/test/cpp/helpers/charsetencodertestcase.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: size_t i = 0  i < out.limit()  i++
induction variable: ['i']
{
L5773: (utf8_greet[i],r) 
}
array table
-----------------------------------------------
utf8_greet -> [('[i]', 'r', 'normalized', ['i'], 5773)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: int i = 0  i < package->getRepetitions()  i++
induction variable: ['i']
{
L5774: (buf[BUFSIZE],r) 
	loop info: size_t i = 0  i < out.limit() && pass  i++
	induction variable: ['i']
			{
			L5775: (expected[i]==,r) 
			}
 }
array table
-----------------------------------------------
expected -> [('[i]', 'r', 'normalized', ['i'], 5775)]
LDEs formed:0

buf -> [('[BUFSIZE]', 'r', 'not normalized', ['i'], 5774)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: int i = 0  i < THREAD_COUNT  i++
induction variable: ['i']
{
L5775: (threads[i].run,r) 
}
array table
-----------------------------------------------
threads -> [('[i]', 'r', 'normalized', ['i'], 5775)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: int i = 0  i < THREAD_COUNT  i++
induction variable: ['i']
{
L5776: (threads[i].join,r) 
}
array table
-----------------------------------------------
threads -> [('[i]', 'r', 'normalized', ['i'], 5776)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/log4cxx/src/test/cpp/helpers/cyclicbuffertestcase.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: i = 0  i < MAX  i++
induction variable: ['i']
{
L5777: (e[i],r) 
	loop info: int j = limit  j >= 0  j--
	induction variable: ['i', 'j']
	{
	L5778: (e[i - (limit - j)],r) 
	}
 }
array table
-----------------------------------------------
e -> [('[i]', 'r', 'normalized', ['i', 'j'], 5777), ('[i - (limit - j)]', 'r', 'not normalized', ['i', 'j'], 5778)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: int i = 0  i < numberOfAdds  i++
induction variable: ['i']
{
L5779: (e[i],r) 
}
array table
-----------------------------------------------
e -> [('[i]', 'r', 'normalized', ['i'], 5779)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: int j = 0  j < len  j++
induction variable: ['j']
{
L5780: (e[offset + j],r) 
}
array table
-----------------------------------------------
e -> [('[offset + j]', 'r', 'not normalized', ['j'], 5780)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/log4cxx/src/test/cpp/rolling/obsoletedailyrollingfileappendertest.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: int i = 0  i < 25  i++
induction variable: ['i']
{
L5781: (msg[8]=,w) 
L5782: (msg[9]=,w) 
}
array table
-----------------------------------------------
msg -> [('[8]', 'w', 'normalized', ['i'], 5781), ('[9]', 'w', 'normalized', ['i'], 5782)]
LDEs formed:3

distinct LDEs:
9=9
8=8
8=9
#########################################################################################
loop info: int i = 0  i < 25  i++
induction variable: ['i']
{
L5783: (msg[8]=,w) 
L5784: (msg[9]=,w) 
}
array table
-----------------------------------------------
msg -> [('[8]', 'w', 'normalized', ['i'], 5783), ('[9]', 'w', 'normalized', ['i'], 5784)]
LDEs formed:3

distinct LDEs:
9=9
8=8
8=9
#########################################################################################
loop info: size_t i = 0  i < files.size()  i++
induction variable: ['i']
{
L5785: (files[i],r) 
}
array table
-----------------------------------------------
files -> [('[i]', 'r', 'normalized', ['i'], 5785)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/log4cxx/src/test/cpp/rolling/manualrollingtest.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: int i = 0  i < 25  i++
induction variable: ['i']
{
L5786: (msg[8]=,w) 
L5787: (msg[7]=,w) 
L5788: (msg[8]=,w) 
}
array table
-----------------------------------------------
msg -> [('[8]', 'w', 'normalized', ['i'], 5786), ('[7]', 'w', 'normalized', ['i'], 5787), ('[8]', 'w', 'normalized', ['i'], 5788)]
LDEs formed:6

distinct LDEs:
7=7
8=7
8=8
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/log4cxx/src/test/cpp/rolling/filterbasedrollingtest.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: int i = 0  i < 25  i++
induction variable: ['i']
{
L5789: (msg[10],r) 
L5790: (msg[8]=,w) 
L5791: (msg[7]=,w) 
L5792: (msg[8]=,w) 
}
array table
-----------------------------------------------
msg -> [('[10]', 'r', 'normalized', ['i'], 5789), ('[8]', 'w', 'normalized', ['i'], 5790), ('[7]', 'w', 'normalized', ['i'], 5791), ('[8]', 'w', 'normalized', ['i'], 5792)]
LDEs formed:9

distinct LDEs:
10=8
7=7
8=7
8=8
10=7
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/log4cxx/src/test/cpp/rolling/timebasedrollingtest.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: int i = 0  i < 4  i++
induction variable: ['i']
{
L5793: (filenames[i]=,w) 
L5794: (filenames[i],r) 
}
array table
-----------------------------------------------
filenames -> [('[i]', 'w', 'normalized', ['i'], 5793), ('[i]', 'r', 'normalized', ['i'], 5794)]
LDEs formed:2

distinct LDEs:
i1=i2
#########################################################################################
loop info: int i = 0  i < 4  i++
induction variable: ['i']
{
L5795: (filenames[i],r) 
}
array table
-----------------------------------------------
filenames -> [('[i]', 'r', 'normalized', ['i'], 5795)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: int i = 0  i < 4  i++
induction variable: ['i']
{
L5796: (filenames[i]=,w) 
L5797: (filenames[i],r) 
}
array table
-----------------------------------------------
filenames -> [('[i]', 'w', 'normalized', ['i'], 5796), ('[i]', 'r', 'normalized', ['i'], 5797)]
LDEs formed:2

distinct LDEs:
i1=i2
#########################################################################################
loop info: int i = 0  i < 4  i++
induction variable: ['i']
{
L5798: (filenames[i],r) 
}
array table
-----------------------------------------------
filenames -> [('[i]', 'r', 'normalized', ['i'], 5798)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: int i = 0  i < 4  i++
induction variable: ['i']
{
L5799: (filenames[i]=,w) 
L5800: (filenames[i],r) 
L5801: (filenames[i].append,r) 
}
array table
-----------------------------------------------
filenames -> [('[i]', 'w', 'normalized', ['i'], 5799), ('[i]', 'r', 'normalized', ['i'], 5800), ('[i]', 'r', 'normalized', ['i'], 5801)]
LDEs formed:3

distinct LDEs:
i1=i2
#########################################################################################
loop info: int i = 0  i < 3  i++
induction variable: ['i']
{
L5802: (filenames[i]=,w) 
L5803: (filenames[i],r) 
}
array table
-----------------------------------------------
filenames -> [('[i]', 'w', 'normalized', ['i'], 5802), ('[i]', 'r', 'normalized', ['i'], 5803)]
LDEs formed:2

distinct LDEs:
i1=i2
#########################################################################################
loop info: int i = 0  i < 4  i++
induction variable: ['i']
{
L5804: (filenames[i],r) 
}
array table
-----------------------------------------------
filenames -> [('[i]', 'r', 'normalized', ['i'], 5804)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: int i = 0  i < 3  i++
induction variable: ['i']
{
L5805: (filenames[i]=,w) 
L5806: (filenames[i],r) 
}
array table
-----------------------------------------------
filenames -> [('[i]', 'w', 'normalized', ['i'], 5805), ('[i]', 'r', 'normalized', ['i'], 5806)]
LDEs formed:2

distinct LDEs:
i1=i2
#########################################################################################
loop info: int i = 0  i < 4  i++
induction variable: ['i']
{
L5807: (filenames[i],r) 
}
array table
-----------------------------------------------
filenames -> [('[i]', 'r', 'normalized', ['i'], 5807)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: int i = 0  i < 3  i++
induction variable: ['i']
{
L5808: (filenames[i]=,w) 
L5809: (filenames[i],r) 
L5810: (filenames[i].append,r) 
}
array table
-----------------------------------------------
filenames -> [('[i]', 'w', 'normalized', ['i'], 5808), ('[i]', 'r', 'normalized', ['i'], 5809), ('[i]', 'r', 'normalized', ['i'], 5810)]
LDEs formed:3

distinct LDEs:
i1=i2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/log4cxx/src/test/cpp/rolling/sizebasedrollingtest.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: int i = 0  i < 25  i++
induction variable: ['i']
{
L5811: (msg[8]=,w) 
L5812: (msg[7]=,w) 
L5813: (msg[8]=,w) 
}
array table
-----------------------------------------------
msg -> [('[8]', 'w', 'normalized', ['i'], 5811), ('[7]', 'w', 'normalized', ['i'], 5812), ('[8]', 'w', 'normalized', ['i'], 5813)]
LDEs formed:6

distinct LDEs:
7=7
8=7
8=8
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/log4cxx/src/test/cpp/rolling/obsoleterollingfileappendertest.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: int i = 0  i < 25  i++
induction variable: ['i']
{
L5814: (msg[8]=,w) 
L5815: (msg[7]=,w) 
L5816: (msg[8]=,w) 
}
array table
-----------------------------------------------
msg -> [('[8]', 'w', 'normalized', ['i'], 5814), ('[7]', 'w', 'normalized', ['i'], 5815), ('[8]', 'w', 'normalized', ['i'], 5816)]
LDEs formed:6

distinct LDEs:
7=7
8=7
8=8
#########################################################################################
loop info: int i = 0  i < 25  i++
induction variable: ['i']
{
L5817: (msg[8]=,w) 
L5818: (msg[7]=,w) 
L5819: (msg[8]=,w) 
}
array table
-----------------------------------------------
msg -> [('[8]', 'w', 'normalized', ['i'], 5817), ('[7]', 'w', 'normalized', ['i'], 5818), ('[8]', 'w', 'normalized', ['i'], 5819)]
LDEs formed:6

distinct LDEs:
7=7
8=7
8=8
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/log4cxx/src/test/cpp/net/telnetappendertestcase.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/log4cxx/src/test/cpp/net/sockethubappendertestcase.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/log4cxx/src/test/cpp/varia/levelmatchfiltertestcase.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: int x = 0  x < length  x++
induction variable: ['x']
{
L5820: (levelArray[x]-,r) 
L5821: (levelArray[x]-,r) 
}
array table
-----------------------------------------------
levelArray -> [('[x]', 'r', 'normalized', ['x'], 5820), ('[x]', 'r', 'normalized', ['x'], 5821)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: int x = 0  x < length  x++
induction variable: ['x']
{
L5822: (levelArray[x]-,r) 
L5823: (levelArray[x]-,r) 
}
array table
-----------------------------------------------
levelArray -> [('[x]', 'r', 'normalized', ['x'], 5822), ('[x]', 'r', 'normalized', ['x'], 5823)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/log4cxx/src/test/cpp/varia/levelrangefiltertestcase.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: int x = 0  x < length  x++
induction variable: ['x']
{
L5824: (levelArray[x],r) 
	loop info: int y = length - 1  y >= 0  y--
	induction variable: ['x', 'y']
	{
	L5825: (levelArray[y],r) 
	L5826: (levelArray[x]-,r) 
	L5827: (levelArray[y]-,r) 
	}
 }
array table
-----------------------------------------------
levelArray -> [('[x]', 'r', 'normalized', ['x', 'y'], 5824), ('[y]', 'r', 'normalized', ['x', 'y'], 5825), ('[x]', 'r', 'normalized', ['x', 'y'], 5826), ('[y]', 'r', 'normalized', ['x', 'y'], 5827)]
LDEs formed:0

distinct LDEs:
#########################################################################################
loop info: int x = 0  x < length  x++
induction variable: ['x']
{
L5828: (levelArray[x],r) 
	loop info: int y = length - 1  y >= 0  y--
	induction variable: ['x', 'y']
	{
	L5829: (levelArray[y],r) 
	L5830: (levelArray[x]-,r) 
	L5831: (levelArray[y]-,r) 
	}
 }
array table
-----------------------------------------------
levelArray -> [('[x]', 'r', 'normalized', ['x', 'y'], 5828), ('[y]', 'r', 'normalized', ['x', 'y'], 5829), ('[x]', 'r', 'normalized', ['x', 'y'], 5830), ('[y]', 'r', 'normalized', ['x', 'y'], 5831)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/log4cxx/src/main/cpp/dailyrollingfileappender.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: size_t i = 0  i < datePattern.length()  i++
induction variable: ['i']
{
L5832: (datePattern[i]==,r) 
L5833: (datePattern[i],r) 
}
array table
-----------------------------------------------
datePattern -> [('[i]', 'r', 'normalized', ['i'], 5832), ('[i]', 'r', 'normalized', ['i'], 5833)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/log4cxx/src/main/cpp/filterbasedtriggeringpolicy.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/log4cxx/src/main/cpp/nameabbreviator.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/log4cxx/src/main/cpp/logger.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/log4cxx/src/main/cpp/defaultconfigurator.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: int i = 0  names[i] != 0  i++
induction variable: ['i']
{
L5834: (names[i],r) 
}
array table
-----------------------------------------------
names -> [('[i]', 'r', 'normalized', ['i'], 5834)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/log4cxx/src/main/cpp/propertysetter.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/log4cxx/src/main/cpp/file.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/log4cxx/src/main/cpp/smtpappender.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: int i = 0  i < fields  i++
induction variable: ['i']
{
L5835: (request[i].flags&,r) 
L5836: (result[i]=,w) 
L5837: (result[i]=,w) 
}
array table
-----------------------------------------------
request -> [('[i]', 'r', 'normalized', ['i'], 5835)]
LDEs formed:0

result -> [('[i]', 'w', 'normalized', ['i'], 5836), ('[i]', 'w', 'normalized', ['i'], 5837)]
LDEs formed:3

distinct LDEs:
i1=i2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/log4cxx/src/main/cpp/loggingevent.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/log4cxx/src/main/cpp/properties.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/log4cxx/src/main/cpp/charsetdecoder.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/log4cxx/src/main/cpp/simpledateformat.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info:  size_t i = hours.length()  i-- > 0  
induction variable: []
{
L5838: (s[hourPos--]=,w) (hours[i],r) 
}
array table
-----------------------------------------------
hours -> [('[i]', 'r', 'not normalized', [], 5838)]
LDEs formed:0

s -> [('[hourPos--]', 'w', 'not normalized', [], 5838)]
LDEs formed:1

distinct LDEs:
hourPos--=hourPos--
#########################################################################################
loop info:  size_t j = min.length()  j-- > 0  
induction variable: []
{
L5839: (s[minPos--]=,w) (min[j],r) 
}
array table
-----------------------------------------------
s -> [('[minPos--]', 'w', 'not normalized', [], 5839)]
LDEs formed:1

min -> [('[j]', 'r', 'not normalized', [], 5839)]
LDEs formed:0

distinct LDEs:
minPos--=minPos--
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/log4cxx/src/main/cpp/cyclicbuffer.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: i = 0  i < loopLen  i++
induction variable: ['i']
{
L5840: (temp[i]=,w) (ea[first],r) 
L5841: (ea[first]=,w) 
}
array table
-----------------------------------------------
ea -> [('[first]', 'r', 'not normalized', ['i'], 5840), ('[first]', 'w', 'not normalized', ['i'], 5841)]
LDEs formed:2

temp -> [('[i]', 'w', 'normalized', ['i'], 5840)]
LDEs formed:1

distinct LDEs:
first=first
i1=i2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/log4cxx/src/main/cpp/fixedwindowrollingpolicy.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/log4cxx/src/main/cpp/patternparser.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/log4cxx/src/main/cpp/cacheddateformat.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: LogString::size_type i = 0  i < formatted.length()  i++
induction variable: ['i']
{
L5841: (formatted[i],r) (plusMagic[i],r) 
}
array table
-----------------------------------------------
plusMagic -> [('[i]', 'r', 'normalized', ['i'], 5841)]
LDEs formed:0

formatted -> [('[i]', 'r', 'normalized', ['i'], 5841)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/log4cxx/src/main/cpp/hierarchy.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/log4cxx/src/main/cpp/appenderattachableimpl.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/log4cxx/src/main/cpp/odbcappender.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/log4cxx/src/main/cpp/fallbackerrorhandler.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/log4cxx/src/examples/cpp/console.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: int i = 1  i < argc  i++
induction variable: ['i']
{
L5842: (argv[i],r) 
L5843: (argv[i],r) 
L5844: (argv[i],r) 
L5845: (argv[i],r) 
L5846: (argv[i],r) 
L5847: (argv[i],r) 
L5848: (argv[i],r) 
L5849: (argv[i],r) 
L5850: (argv[i],r) 
L5851: (argv[i],r) 
}
array table
-----------------------------------------------
argv -> [('[i]', 'r', 'normalized', ['i'], 5842), ('[i]', 'r', 'normalized', ['i'], 5843), ('[i]', 'r', 'normalized', ['i'], 5844), ('[i]', 'r', 'normalized', ['i'], 5845), ('[i]', 'r', 'normalized', ['i'], 5846), ('[i]', 'r', 'normalized', ['i'], 5847), ('[i]', 'r', 'normalized', ['i'], 5848), ('[i]', 'r', 'normalized', ['i'], 5849), ('[i]', 'r', 'normalized', ['i'], 5850), ('[i]', 'r', 'normalized', ['i'], 5851)]
LDEs formed:0

distinct LDEs:
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLibXL/qlxl/conversions/opertovector.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loop info: int i=0  i<size  ++i
induction variable: ['i']
{
L5852: (a[i]=,w) (val.array.lparray[i],r) 
}
array table
-----------------------------------------------
a -> [('[i]', 'w', 'normalized', ['i'], 5852)]
LDEs formed:1

val.array.lparray -> [('[i]', 'r', 'normalized', ['i'], 5852)]
LDEs formed:0

distinct LDEs:
i1=i2
#########################################################################################
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLibXL/qlxl/conversions/matrixtooper.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/rakesh/Downloads/quantlib-master/QuantLibXL/qlxl/conversions/opertomatrix.cpp ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

***************************************stats******************************************
total_ldes: 7024
distinct_ldes: 1982
maximum_ldes_for_a_loop: 105
total_array_refs: 10200
normalized_array_refs: 8919
maximum_loop_nest: 11
total_read_count: 8172
total_write_count: 2028
n-variable_ldes: {0: 151, 1: 31, 2: 1276, 3: 27, 4: 319, 5: 3, 6: 167, 7: 1, 8: 6, 10: 1}
